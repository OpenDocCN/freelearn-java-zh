- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects, Immutability, Switch Expressions, and Pattern Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter includes 30 problems, tackling, among others, some less-known features
    of `java.util.Objects`, some interesting aspects of immutability, the newest features
    of `switch` expressions, and deep coverage of the cool pattern matching capabilities
    of `instanceof` and `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll be up to date with all these topics, which
    are non-optional in any Java developer’s arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your programming prowess on `Objects`, immutability,
    `switch` expressions, and pattern matching. I strongly encourage you to give each
    problem a try before you turn to the solutions and download the example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explaining and exemplifying UTF-8, UTF-16, and UTF-32**: Provide a detailed
    explanation of what UTF-8, UTF-16, and UTF-32 are. Include several snippets of
    code to show how these work in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Checking a sub-range in the range from 0 to length**: Write a program that
    checks whether the given sub-range [*given start*, *given start* + *given end*)
    is within the bounds of the range from [*0*, *given length*). If the given sub-range
    is not in the [*0*, *given length*) range, then throw an `IndexOutOfBoundsException`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Returning an identity string**: Write a program that returns a string representation
    of an object without calling the overridden `toString()` or `hashCode()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hooking unnamed classes and instance main methods**: Give a quick introduction
    to JDK 21 unnamed classes and instance main methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding code snippets in Java API documentation**: Provide examples of adding
    code snippets in Java API documentation via the new `@snippet` tag.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoking default methods from** `Proxy` **instances**: Write several programs
    that invoke interface `default` methods from `Proxy` instances in JDK 8, JDK 9,
    and JDK 16.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Converting between bytes and hex-encoded strings**: Provide several snippets
    of code for converting between bytes and hex-encoded strings (including byte arrays).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exemplify the initialization-on-demand holder design pattern**: Write a program
    that implements the initialization-on-demand holder design pattern in the classical
    way (before JDK 16) and another program that implements this design pattern based
    on the fact that, from JDK 16+, Java inner classes can have static members and
    static initializers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding nested classes in anonymous classes**: Write a meaningful example
    that uses nested classes in anonymous classes (pre-JDK 16, and JDK 16+).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exemplify erasure vs. overloading**: Explain in a nutshell what type erasure
    in Java and polymorphic overloading are, and exemplify how they work together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Xlinting default constructors**: Explain and exemplify the JDK 16+ hint for
    classes with default constructors,`-Xlint:missing-explicit-ctor`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Working with the receiver parameter**: Explain the role of the Java receiver
    parameter and exemplify its usage in code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing an immutable stack**: Provide a program that creates an immutable
    stack implementation from zero (implement `isEmpty()`, `push()`, `pop()`, and
    `peek()` operations).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Revealing a common mistake with Strings**: Write a simple use case of strings
    that contain a common mistake (for instance, related to the `String` immutability
    characteristic).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using the enhanced NullPointerException**: Exemplify, from your experience,
    the top 5 causes of `NullPointerException` and explain how JDK 14 improves NPE
    messages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using yield in switch expressions**: Explain and exemplify the usage of the
    `yield` keyword with `switch` expressions in JDK 13+.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling the case null clause in switch**: Write a bunch of examples to show
    different approaches for handling `null` values in `switch` expressions (including
    JDK 17+ approaches).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Taking on the hard way to discover equals()**: Explain and exemplify how
    `equals()` is different from the `==` operator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hooking instanceof in a nutshell**: Provide a brief overview with snippets
    of code to highlight the main aspect of the `instanceof` operator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing pattern matching**: Provide a theoretical dissertation including
    the main aspects and terminology for *pattern matching* in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing type pattern matching for instanceof**: Provide the theoretical
    and practical support for using the *type pattern matching* for `instanceof`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handling the scope of a binding variable in type patterns for instanceof**:
    Explain in detail, including snippets of code, the scope of *binding variables*
    in *type patterns* for `instanceof`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rewriting equals() via type patterns for instanceof**: Exemplify in code
    the implementation of `equals()` (including for generic classes) before and after
    *type patterns* for `instanceof` have been introduced.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling type patterns for instanceof and generics**: Provide several examples
    that use the combo *type patterns* for `instanceof` and generics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling type patterns for instanceof and streams**: Can we use *type patterns*
    for `instanceof` and the Stream API together? If yes, provide at least an example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing type pattern matching for switch**: *Type patterns* are available
    for `instanceof` but are also available for `switch`. Provide here the theoretical
    headlines and an example of this topic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding guarded pattern labels in switch**: Provide a brief coverage of *guarded
    pattern labels* in `switch` for JDK 17 and 21.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dealing with pattern label dominance in switch**: Pattern label dominance
    in `switch` is a cool feature, so exemplify it here in a comprehensive approach
    with plenty of examples.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dealing with completeness (type coverage) in pattern labels for switch**:
    This is another cool topic for `switch` expressions. Explain and exemplify it
    in detail (theory ad examples).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Understanding the unconditional patterns and nulls in switch expressions**:
    Explain how `null` values are handled by unconditional patterns of `switch` expressions
    before and after JDK 19.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: 38\. Explain and exemplifying UTF-8, UTF-16, and UTF-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Character encoding/decoding is important for browsers, databases, text editors,
    filesystems, networking, and so on, so it’s a major topic for any programmer.
    Check out the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1.png](img/B19665_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Representing text with different char sets'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 2.1*, we see several Chinese characters represented in UTF-8, UTF-16,
    and ANSI on a computer screen. But, what are these? What is ANSI? What is UTF-8
    and how did we get to it? Why don’t these characters look normal in ANSI?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the story may begin with computers trying to represent characters (such
    as letters from the alphabet or digits or punctuation marks). The computers understand/process
    everything from the real world as a binary representation, so as a sequence of
    0 and 1\. This means that every character (for instance, A, 5, +, and so on) has
    to be mapped to a sequence of 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: The process of mapping a character to a sequence of 0 and 1 is known as *character
    encoding* or simply *encoding*. The reverse process of un-mapping a sequence of
    0 and 1 to a character is known as *character decoding* or simply *decoding*.
    Ideally, an encoding-decoding cycle should return the same character; otherwise,
    we obtain something that we don’t understand or we cannot use.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the Chinese character, ![](img/B19665_02_001.png), should be encoded
    in the computer’s memory as a sequence of 0 and 1\. Next, when this sequence is
    decoded, we expect back the same Chinese letter, ![](img/B19665_02_002.png). In
    *Figure 2.1*, this happens in the left and middle screenshots, while in the right
    screenshot, the returned character is ![](img/B19665_02_003.png)…. A Chinese speaker
    will not understand this (actually, nobody will), so something went wrong!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don’t have only Chinese characters to represent. We have many
    other sets of characters grouped in alphabets, emoticons, and so on. A set of
    characters has well-defined content (for instance, an alphabet has a certain number
    of well-defined characters) and is known as a *character set* or, in short, a
    *charset*.
  prefs: []
  type: TYPE_NORMAL
- en: Having a charset, the problem is to define a set of rules (a standard) that
    clearly explains how the characters of this charset should be encoded/decoded
    in the computer memory. Without having a clear set of rules, the encoding and
    decoding may lead to errors or indecipherable characters. Such a standard is known
    as an *encoding scheme*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first encoding schemes was ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ASCII encoding scheme (or single-byte encoding)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASCII stands for American Standard Code for Information Interchange. This encoding
    scheme relies on a 7-bit binary system. In other words, each character that is
    part of the ASCII charset ([http://ee.hawaii.edu/~tep/EE160/Book/chap4/subsection2.1.1.1.html](http://ee.hawaii.edu/~tep/EE160/Book/chap4/subsection2.1.1.1.html))
    should be representable (encoded) on 7 bits. A 7-bit number can be a decimal between
    0 and 127, as in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2.png](img/B19665_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: ASCII charset encoding'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, ASCII is an encoding scheme based on a 7-bit system that supports 128 different
    characters. But, we know that computers operate on bytes (octets) and a byte has
    8 bits. This means that ASCII is a single-byte encoding scheme that leaves a bit
    free for each byte. See the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3.png](img/B19665_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The highlighted bit is left free in ASCII encoding'
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASCII encoding, the letter A is 65, the letter B is 66, and so on. In Java,
    we can easily check this via the existing API, as in the following simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, let’s see the encoding of the text *Hello World*. This time, we added the
    free bit as well, so the result will be 01001000 01100101 01101100 01101100 01101111
    0100000 01010111 01101111 01110010 01101100 01100100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we perform a match, then we see that 01001000 is *H*, 01100101 is *e*, 01101100
    is *l*, 01101111 is *o*, 0100000 is space, 01010111 is *W*, 01110010 is *r*, and
    01100100 is *d*. So, besides letters, the ASCII encoding can represent the English
    alphabet (upper and lower case), digits, space, punctuation marks, and some special
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the core ASCII for English, we also have ASCII extensions, which are
    basically variations of the original ASCII to support other alphabets. Most probably,
    you’ve heard about the ISO-8859-1 (known as ISO Latin 1), which is a famous ASCII
    extension. But, even with ASCII extensions, there are still a lot of characters
    in the world that cannot be encoded yet. There are countries that have a lot more
    characters than ASCII can encode, and even countries that don’t use alphabets.
    So, ASCII has its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: I know what you are thinking … let’s use that free bit (2⁷+127). Yes, but even
    so, we can go up to 256 characters. Still not enough! It is time to encode characters
    using more than 1 byte.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing multi-byte encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In different parts of the world, people started to create multi-byte encoding
    schemes (commonly, 2 bytes). For instance, speaker of the Chinese language, which
    has a lot of characters, created Shift-JIS and Big5, which use 1 or 2 bytes to
    represent characters.
  prefs: []
  type: TYPE_NORMAL
- en: But, what happens when most of the countries come up with their own multi-byte
    encoding schemes trying to cover their special characters, symbols, and so on?
    Obviously, this leads to a huge incompatibility between the encoding schemes used
    in different countries. Even worse, some countries have multiple encoding schemes
    that are totally incompatible with each other. For instance, Japan has three different
    incompatible encoding schemes, which means that encoding a document with one of
    these encoding schemes and decoding with another will lead to a garbled document.
  prefs: []
  type: TYPE_NORMAL
- en: However, this incompatibility was not such a big issue before the Internet,
    since which documents have been massively shared all around the globe using computers.
    At that moment, the incompatibility between the encoding schemes conceived in
    isolation (for instance, countries and geographical regions) started to be painful.
  prefs: []
  type: TYPE_NORMAL
- en: It was the perfect moment for the Unicode Consortium to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a nutshell, Unicode ([https://unicode-table.com/en/](https://unicode-table.com/en/))
    is a universal encoding standard capable of encoding/decoding every possible character
    in the world (we are talking about hundreds of thousands of characters).
  prefs: []
  type: TYPE_NORMAL
- en: Unicode needs more bytes to represent all these characters. But, Unicode didn’t
    get involved in this representation. It just assigned a number to each character.
    This number is named a *code point*. For instance, the letter *A* in Unicode is
    associated with the code point 65 in decimal, and we refer to it as U+0041\. This
    is the constant U+ followed by 65 in hexadecimal. As you can see, in Unicode,
    *A* is 65, exactly as in the ASCII encoding. In other words, Unicode is backward
    compatible with ASCII. As you’ll see soon, this is big, so keep it in mind!
  prefs: []
  type: TYPE_NORMAL
- en: 'Early versions of Unicode contain characters having code points less than 65,535
    (0xFFFF). Java represents these characters via the 16-bit `char` data type. For
    instance, the French ![](img/B19665_02_004.png) (*e* with circumflex) is associated
    with the Unicode 234 decimal or U+00EA hexadecimal. In Java, we can use `charAt()`
    to reveal this for any Unicode character less than 65,535:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We also may see the binary representation of this character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Later, Unicode added more and more characters up to 1,114,112 (0x10FFFF). Obviously,
    the 16-bit Java `char` was not enough to represent these characters, and calling
    `charAt()` was not useful anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Java 19+ supports Unicode 14.0\. The `java.lang.Character` API supports Level
    14 of the **Unicode Character Database** (**UCD**). In numbers, we have 47 new
    emojis, 838 new characters, and 5 new scripts. Java 20+ supports Unicode 15.0,
    which means 4,489 new characters for `java.lang.Character`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, JDK 21 has added a set of methods especially for working with emojis
    based on their code point. Among these methods, we have `boolean isEmoji(int codePoint)`,
    `boolean isEmojiPresentation(int codePoint)`, `boolean isEmojiModifier(int codePoint)`,
    `boolean isEmojiModifierBase(int` `codePoint)`, `boolean isEmojiComponent(int
    codePoint)`, and `boolean isExtendedPictographic(int codePoint)`. In the bundled
    code, you can find a small application showing you how to fetch all available
    emojis and check if a given string contains emoji. So, we can easily obtain the
    code point of a character via `Character.codePointAt()` and pass it as an argument
    to these methods to determine whether the character is an emoji or not.
  prefs: []
  type: TYPE_NORMAL
- en: However, Unicode doesn’t get involved in how these code points are encoded into
    bits. This is the job of special encoding schemes within Unicode, such as the
    **Unicode Transformation Format** (**UTF**) schemes. Most commonly, we use UTF-32,
    UTF-16, and UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'UTF-32 is an encoding scheme for Unicode that represents every code point on
    4 bytes (32 bits). For instance, the letter *A* (having code point 65), which
    can be encoded on a 7-bit system, is encoded in UTF-32 as in the following figure
    next to the other two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4.png](img/B19665_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Three characters sample encoded in UTF-32'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 2.4*, UTF-32 uses 4 bytes (fixed length) to represent
    every character. In the case of the letter *A*, we see that UTF-32 wasted 3 bytes
    of memory. This means that converting an ASCII file to UTF-32 will increase its
    size by 4 times (for instance, a 1KB ASCII file is a 4KB UTF-32 file). Because
    of this shortcoming, UTF-32 is not very popular.
  prefs: []
  type: TYPE_NORMAL
- en: Java doesn’t support UTF-32 as a standard charset but it relies on *surrogate
    pairs* (introduced in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'UTF-16 is an encoding scheme for Unicode that represents every code point on
    2 or 4 bytes (not on 3 bytes). UTF-16 has a variable length and uses an optional
    **Byte-Order Mark** (**BOM**), but it is recommended to use UTF-16BE (BE stands
    for Big-Endian byte order), or UTF-16LE (LE stands for Little-Endian byte order).
    While more details about Big-Endian vs. Little-Endian are available at [https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness),
    the following figure reveals how the orders of bytes differ in UTF-16BE (left
    side) vs. UTF-16LE (right side) for three characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5.png](img/B19665_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: UTF-16BE (left side) vs. UTF-16LE (right side)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the figure is self-explanatory, let’s move forward. Now, we have to tackle
    a trickier aspect of UTF-16\. We know that in UTF-32, we take the *code point*
    and transform it into a 32-bit number and that’s it. But, in UTF-16, we can’t
    do that every time because we have code points that don’t accommodate 16 bits.
    This being said, UTF-16 uses the so-called 16-bit *code units*. It can use 1 or
    2 *code units* per *code point*. There are three types of code units, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A code point needs a single code unit: these are 16-bit code units (covering
    U+0000 to U+D7FF, and U+E000 to U+FFFF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A code point needs 2 code units:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first code unit is named *high surrogate* and it covers 1,024 values (U+D800
    to U+DBFF)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second code unit is named *low surrogate* and it covers 1,024 values (U+DC00
    to U+DFFF)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *high surrogate* followed by a *low surrogate* is named a *surrogate pair*.
    Surrogate pairs are needed to represent the so-called *supplementary* Unicode
    characters or characters having a code point larger than 65,535 (0xFFFF).
  prefs: []
  type: TYPE_NORMAL
- en: 'Characters such as the letter A (65) or the Chinese ![](img/B19665_02_005.png)
    (26263) have a code point that can be represented via a single code unit. The
    following figure shows these characters in UTF-16BE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6.png](img/B19665_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: UTF-16 encoding of A and ![](img/B19665_02_006.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This was easy! Now, let’s consider the following figure (encoding of Unicode,
    *Smiling Face with Heart-Shaped Eyes*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7.png](img/B19665_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: UTF-16 encoding using a surrogate pair'
  prefs: []
  type: TYPE_NORMAL
- en: The character from this figure has a code point of 128525 (or, 1 F60D) and is
    represented on 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the first byte: the sequence of 6 bits, 110110, identifies a high surrogate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the third byte: the sequence of 6 bits, 110111, identifies a low surrogate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These 12 bits (identifying the high and low surrogates) can be dropped and
    we keep the rest of the 20 bits: 00001111011000001101\. We can compute this number
    as 2⁰ + 2² + 2³ + 2⁹ + 2^(10) + 2^(12) + 2^(13) + 2^(14) + 2^(15) = 1 + 4 + 8
    + 512 + 1024 + 4096 + 8192 + 16384 + 32768 = 62989 (or, the hexadecimal, F60D).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to compute F60D + 0x10000 = 1 F60D, or in decimal 62989 + 65536
    = 128525 (the code point of this Unicode character). We have to add 0x10000 because
    the characters that use 2 code units(a surrogate pair) are always of form 1 F…
  prefs: []
  type: TYPE_NORMAL
- en: Java supports UTF-16, UTF-16BE, and UTF-16LE. Actually, UTF-16 is the native
    character encoding for Java.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UTF-8 is an encoding scheme for Unicode that represents every code point on
    1, 2, 3, or 4 bytes. Having this 1- to 4-byte flexibility, UTF-8 uses space in
    a very efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is the most popular encoding scheme that dominates the Internet and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we know that the code point of the letter A is 65 and it can
    be encoded using a 7-bit binary representation. The following figure represents
    this letter encoded in UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8.png](img/B19665_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Letter A encoded in UTF-8'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very cool! UTF-8 has used a single byte to encode A. The first (leftmost)
    0 signals that this is a single-byte encoding. Next, let’s see the Chinese character,
    ![](img/B19665_02_007.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9.png](img/B19665_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Chinese character, ![](img/B19665_02_006.png), encoded in UTF-8'
  prefs: []
  type: TYPE_NORMAL
- en: The code point of ![](img/B19665_02_007.png) is 26263, so UTF-8 uses 3 bytes
    to represent it. The first byte contains 4 bits (1110) that signal that this is
    a 3-byte encoding. The next two bytes start with 2 bits of 10\. All these 8 bits
    can be dropped and we keep only the remaining 16 bits, which gives us the expected
    code point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s tackle the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10.png](img/B19665_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: UTF-8 encoding with 4 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: This time, the first byte signals that this is a 4-byte encoding via 11110\.
    The remaining 3 bytes start with 10\. All these 11 bits can be dropped and we
    keep only the remaining 21 bits, 000011111011000001101, which gives us the expected
    code point, 128525.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure you can see the UTF-8 template used for encoding Unicode
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11.png](img/B19665_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: UTF-8 template used for encoding Unicode characters'
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that 8 zeros in a row (00000000 – U+0000) are interpreted as NULL?
    A NULL represents the end of the string, so sending it “accidentally” will be
    a problem because the remaining string will not be processed. Fortunately, UTF-8
    prevents this issue, and sending a NULL can be done only if we effectively send
    the U+0000 code point.
  prefs: []
  type: TYPE_NORMAL
- en: Java and Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As long as we use characters with code points less than 65,535 (0xFFFF), we
    can rely on the `charAt()` method to obtain the code point. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these examples, we may write a helper method that returns the binary
    representation of strings having code points less than 65,535 (0xFFFF) as follows
    (you already saw the imperative version of the following functional code earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code against a Unicode character having a code point greater
    than 65,535 (0xFFFF), then you’ll get the wrong result. You’ll not get an exception
    or any kind of warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `charAt()` covers only a subset of Unicode characters. For covering all
    Unicode characters, Java provides an API that consists of several methods. For
    instance, if we replace `charAt()` with `codePointAt()`, then we obtain the correct
    code point in all cases, as you can see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12.png](img/B19665_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: charAt() vs. codePointAt()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the last example, `c2`. Since `codePointAt()` returns the correct
    code point (128525), we can obtain the binary representation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we need a method that returns the binary encoding of any Unicode character,
    then we can replace the `chars()` call with the `codePoints()` call. The `codePoints()`
    method returns the code points of the given sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `codePoints()` method is just one of the methods provided by Java to work
    around code points. The Java API also includes `codePointAt()`, `offsetByCodePoints()`,
    `codePointCount()`, `codePointBefore()`, `codePointOf()`, and so on. You can find
    several examples of them in the bundled code next to this one for obtaining a
    `String` from a given code point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `toChars()` method gets a code point and returns the UTF-16 representation
    via a `char[]`. The string returned by the first example (`str1`) has a length
    of 1 and is the letter A. The second example returns a string of length 2 since
    the character having the code point 128525 needs a surrogate pair. The returned
    `char[]` contains both the high and low surrogates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s have a helper method that allows us to obtain the binary representation
    of a string for a given encoding scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this method is quite simple, as you can see in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can practice more examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 18 defaults the charset to UTF-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before JDK 18, the default charset was determined based on the operating system
    charset and locale (for instance, on a Windows machine, it could be windows-1252).
    Starting with JDK 18, the default charset is UTF-8 (`Charset.defaultCharset()`
    returns the string, UTF-8). Or, having a `PrintStream` instance, we can find out
    the used charset via the `charset()` method (starting with JDK 18).
  prefs: []
  type: TYPE_NORMAL
- en: 'But, the default charset can be explicitly set via the `file.encoding` and
    `native.encoding` system properties at the command line. For instance, you may
    need to perform such modification to compile legacy code developed before JDK
    18:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, since JDK 18, classes that use encoding (for instance, `FileReader`/`FileWriter`,
    `InputStreamReader`/`OutputStreamWriter`, `PrintStream`, `Formatter`, `Scanner`,
    and `URLEncoder`/`URLDecoder`) can take advantage of UTF-8 out of the box. For
    instance, using UTF-8 before JDK 18 for reading a file can be accomplished by
    explicitly specifying this charset encoding scheme as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Accomplishing the same thing in JDK 18+ doesn’t require explicitly specifying
    the charset encoding scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for `System.out` and `System.err`, JDK 18+ still uses the default
    system charset. So, if you are using `System.out`/`err` and you see question marks
    (?) instead of the expected characters, then most probably you should set UTF-8
    via the new properties `-Dstdout.encoding` and `-Dstderr.encoding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can set them as environment variables to set them globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code you can see more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 39\. Checking a sub-range in the range from 0 to length
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking that a given sub-range is in the range from 0 to the given length is
    a common check in a lot of problems. For instance, let’s consider that we have
    to write a function responsible for checking if the client can increase the pressure
    in a water pipe. The client gives us the current average pressure (`avgPressure`),
    the maximum pressure (`maxPressure`), and the amount of extra pressure that should
    be applied (`unitsOfPressure`).
  prefs: []
  type: TYPE_NORMAL
- en: 'But, before we can apply our secret algorithm, we have to check that the inputs
    are correct. So, we have to ensure that none of the following cases happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`avgPressure` is less than 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unitsOfPressure` is less than 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxPressure` is less than 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range [`avgPressure`, `avgPressure` + `unitsOfPressure`) is out of bounds
    represented by `maxPressure`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in code lines, our function may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing composite conditions such as ours is prone to accidental mistakes.
    It is better to rely on the Java API whenever possible. And, for this use case,
    it is possible! Starting with JDK 9, in `java.util.Objects`, we have the method
    `checkFromIndexSize(int fromIndex, int size, int length)`, and starting with JDK
    16, we also have a flavor for `long` arguments, `checkFromIndexSize(int fromIndex,
    int size, int length)`. If we consider that `avgPressure` is `fromIndex`, `unitsOfPressure`
    is `size`, and `maxPressure` is `length`, then `checkFromIndexSize()` performs
    the arguments validation and throws an `IndexOutOfBoundsException` if something
    goes wrong. So, we write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the code bundle, you can see one more example of using `checkFromIndexSize()`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides `checkFromIndexSize()`, in `java.util.Objects`, we can find several
    other companions that cover common composite conditions such as `checkIndex(int
    index, int length)` – JDK 9, `checkIndex(long index, long length)` – JDK 16, `checkFromToIndex(int
    fromIndex, int toIndex, int length)` – JDK 9, and `checkFromToIndex(long fromIndex,
    long toIndex, long length)` – JDK 16.
  prefs: []
  type: TYPE_NORMAL
- en: And, by the way, if we switch the context to strings, then JDK 21 provides an
    overload of the well-known `String.indexOf()`, capable of searching a character/substring
    in a given string between a given begin index and end index. The signature is
    `indexOf(String str, int beginIndex, int endIndex)` and it returns the index of
    the first occurrence of `str`, or -1 if `str` is not found. Basically, this is
    a neat version of `s.substring(beginIndex, endIndex).indexOf(str) + beginIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: 40\. Returning an identity string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what’s an *identity string*? An identity string is a string built from
    an object without calling the overridden `toString()` or `hashCode()`. It is equivalent
    to the following concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 19, this string is wrapped in `Objects.toIdentityString(Object
    object)`. Consider the following class (`object`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling `toIdentityString()`, we obtain something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the overridden `MyPoint.toString()` method was not called. If we
    print out the hash code of `p`, we get `76ed5528`, which is exactly what `toIdentityString()`
    returned. Now, let’s override `hashCode()` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This time, `toIdentityString()` returns the same thing, while our `hashCode()`
    returns `14ef3`.
  prefs: []
  type: TYPE_NORMAL
- en: 41\. Hooking unnamed classes and instance main methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you have to initiate a student in Java. The classical approach
    of introducing Java is to show the student a *Hello World!* Example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest Java example but it is not simple to explain to the student
    what `public` or `static` or `String[]` are. The ceremony involved in this simple
    example may scare the student – *if this is a simple example, then how is it a
    more complex one*?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, starting with JDK 21 (JEP 445), we have *instance main methods*,
    which is a preview feature that allows us to shorten the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even go further and remove the explicit class declaration as well. This
    feature is known as *unnamed classes*. An unnamed class resides in the unnamed
    package that resides in the unnamed module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Java will generate the class on our behalf. The name of the class will be the
    same as the name of the source file.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all we need to introduce Java to a student. I strongly encourage you
    to read JEP 445 (and the new JEPs that will continue this JDK 21 preview feature
    work) to discover all the aspects involved in these features.
  prefs: []
  type: TYPE_NORMAL
- en: 42\. Adding code snippets in Java API documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m sure that you are familiar with generating **Java API documentation** (**Javadoc**)
    for your projects. We can do it via the `javadoc` tool from the command line,
    via IDE support, via the Maven plugin (`maven-javadoc-plugin`), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common case in writing the Javadoc consists of adding snippets of code to
    exemplify the usage of a non-trivial class or method. Before JDK 18, adding snippets
    of code in documentation can be done via `{@code...}` or the `<pre>` tag. The
    added code is treated as plain text, is not validated for correctness, and is
    not discoverable by other tools. Let’s quickly see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can see the full example. The Javadoc is generated
    at build time via the Maven plugin (`maven-javadoc-plugin`), so simply trigger
    a build.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the output is in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13.png](img/B19665_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Simple output from @snippet'
  prefs: []
  type: TYPE_NORMAL
- en: 'The effective code starts from the newline placed after the colon (`:`) and
    ends before the closing right curly bracket (`}`). The code indentation is treated
    as in code blocks, so the compiler removes the incidental white spaces and we
    can indent the code with respect to the closing right curly bracket (`}`). Check
    out the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14.png](img/B19665_02_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Indentation of code snippets'
  prefs: []
  type: TYPE_NORMAL
- en: In the top example, the closing right curly bracket is aligned under the opening
    left curly bracket, while in the bottom example, we shifted the closing right
    curly bracket to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the generated HTML, you’ll easily identify this attribute as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the code is a structured text such as a *properties* file, then you can
    follow this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the generated HTML, you’ll have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how can we alter what is displayed in a snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Using markup comments and regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Highlighting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Highlighting a whole line can be done via `@highlight` without arguments, as
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15.png](img/B19665_02_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Highlighting a whole line of code'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this figure, the first line of code was bolded.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to highlight multiple lines, then we can define *regions*. A region
    can be treated as anonymous or have an explicit name. An anonymous region is demarcated
    by the word `region` placed as an argument of the markup tag and the `@end` tag
    placed at the end of the region. Here is an example for highlighting two regions
    (an anonymous one and a named one (`R1`)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16.png](img/B19665_02_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Highlighting a block of code using regions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions allow us to highlight a certain part of the code. For instance,
    highlighting everything that occurs between quotes can be done via `@highlight
    regex=''".*"''`. Or, highlighting only the word *Calibrate* can be done via the
    `substring="Calibrate"` argument, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17.png](img/B19665_02_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Highlighting only the word “Calibrate”'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about adding links in code.
  prefs: []
  type: TYPE_NORMAL
- en: Linking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.18.png](img/B19665_02_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Adding links in code'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can modify the code’s text.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the code’s text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we may need to alter the code’s text. For instance, instead of `Telemeter.Calibrate.at(0.00001,
    "HIGH");`, we want to render in documentation `Telemeter.Calibrate.at(eps, "HIGH");`.
    So, we need to replace `0.00001` with `eps`. This is the perfect job for the `@replace`
    tag. Common arguments include `substring="…"` (or, `regex="…"`) and `replacement="..."`.
    Here is the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19.png](img/B19665_02_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Replacing the code’s text'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to perform multiple replacements in a block of code, then rely
    on regions. In the following example, we apply a regular expression to a block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20.png](img/B19665_02_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: Applying multiple replacements via a simple regex and an anonymous
    region'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to perform more replacements on the same line, then just chain multiple
    `@replace` tags (this statement applies to all tags such as `@highlight`, `@link`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Using external snippets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have used only inlined snippets. But, there are scenarios when using
    inlined snippets is not a convenient approach (for instance, if we need to repeat
    some parts of the documentation) or it is not possible to use them (for instance,
    if we want to embed `/*…*/` comments, which cannot be added in inlined snippets).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.21.png](img/B19665_02_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: External snippets in snippet-files'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But, we can also customize the place and folder name of external snippets.
    For instance, let’s place the external snippets in a folder named `snippet-src`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22.png](img/B19665_02_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: External snippets in a custom folder and place'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This path is relative to your machine, so feel free to adjust it accordingly
    in `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `AtSnippet.txt` and `ParamDefaultSnippet.properties` can be loaded exactly
    as you saw earlier for `MainSnippet.txt`. However, loading Java sources, such
    as `DistanceSnippet.java`, can be done via `{@snippet class…}`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'But, do not add explicitly the `.java` extension because you’ll get an error
    such as *file not found on source path or snippet path: DistanceSnippet/java.java*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When using Java sources as external snippets, pay attention to the following
    note.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Regions in external snippets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The external snippets support regions via `@start region=…` and `@end region=…`.
    For instance, in `AtSnippet.txt`, we have the following region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we load the region as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We obtain only the code from the region without the text, *// This is an example
    used in the documentation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a properties file with two regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The region `dist` is used to show the default values for the arguments of the
    `distance()` method in the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23.png](img/B19665_02_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: Using the dist region'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, the `at` region is used to show the default values for the arguments of
    the `at()` method in the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24.png](img/B19665_02_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.24: Using the “at” region'
  prefs: []
  type: TYPE_NORMAL
- en: 'In external snippets, we can use the same tags as in the inlined snippets.
    For instance, in the following figure, you can see the complete source of `AtSnippet.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25.png](img/B19665_02_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.25: Source of AtSnippet.txt'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the presence of `@highlight` and `@replace`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 19, the Javadoc search feature was also improved. In other
    words, JDK 19+ can generate a standalone search page for searching in the Javadoc
    API documentation. Moreover, the search syntax has been enhanced to support multiple
    search words.
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 43\. Invoking default methods from Proxy instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JDK 8, we can define `default` methods in interfaces. For instance,
    let’s consider the following interfaces (for brevity, all methods from these interfaces
    are declared as `default`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26.png](img/B19665_02_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.26: Interfaces: Printable, Writable, Draft, and Book'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s assume that we want to use the Java Reflection API to invoke these
    default methods. As a quick reminder, the `Proxy` class goal is used to provide
    support for creating dynamic implementations of interfaces at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let’s see how we can use the Proxy API for calling our `default`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling a `default` method of an interface in JDK 8 relies on a little trick.
    Basically, we create from scratch a *package-private* constructor from the Lookup
    API. Next, we make this constructor accessible – this means that Java will not
    check the access modifiers to this constructor and, therefore, will not throw
    an `IllegalAccessException` when we try to use it. Finally, we use this constructor
    to wrap an instance of an interface (for instance, `Printable`) and use reflective
    access to the `default` methods declared in this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in code lines, we can invoke the default method `Printable.print()` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s focus on the `Writable` and `Draft` interfaces. `Draft` extends
    `Writable` and overrides the `default write()`method. Now, every time we explicitly
    invoke the `Writable.write()` method, we expect that the `Draft.write()` method
    is invoked automatically behind the scenes. A possible implementation looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s focus on the `Printable` and `Book` interfaces. `Book` extends
    `Printable` and doesn’t define any methods. So, when we call the inherited `print()`
    method, we expect that the `Printable.print()` method is invoked. While you can
    check this solution in the bundled code, let’s focus on the same tasks using JDK
    9+.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 9+, pre-JDK 16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you just saw, before JDK 9, the Java Reflection API provides access to non-public
    class members. This means that external reflective code (for instance, third-party
    libraries) can have deep access to JDK internals. But, starting with JDK 9, this
    is not possible because the new module system relies on strong encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a smooth transition from JDK 8 to JDK 9, we can use the `--illegal-access`
    option. The values of this option range from `deny` (sustains strong encapsulation,
    so no illegal reflective code is permitted) to `permit` (the most relaxed level
    of strong encapsulation, allowing access to platform modules only from unnamed
    modules). Between `permit` (which is the default in JDK 9) and `deny`, we have
    two more values: `warn` and `debug`. However, `--illegal-access=permit;` support
    was removed in JDK 17.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, the previous code may not work in JDK 9+, or it might still
    work but you’ll see a warning such as *WARNING: An illegal reflective access operation
    has occurred*.'
  prefs: []
  type: TYPE_NORMAL
- en: But, we can “fix” our code to avoid illegal reflective access via `MethodHandles`.
    Among its goodies, this class exposes lookup methods for creating method handles
    for fields and methods. Once we have a `Lookup`, we can rely on its `findSpecial()`
    method to gain access to the `default` methods of an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on `MethodHandles`, we can invoke the default method `Printable.print()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: While in the bundled code, you can see more examples; let’s tackle the same
    topic starting with JDK 16.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 16+
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JDK 16, we can simplify the previous code thanks to the new static
    method, `InvocationHandler.invokeDefault()`. As its name suggests, this method
    is useful for invoking `default` methods. In code lines, our previous examples
    for calling `Printable.print()` can be simplified via `invokeDefault()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, every time we explicitly invoke the `Writable.write()`
    method, we expect that the `Draft.write()` method is invoked automatically behind
    the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can practice more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 44\. Converting between bytes and hex-encoded strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting bytes to hexadecimal (and vice versa) is a common operation in applications
    that manipulate fluxes of files/messages, perform encoding/decoding tasks, process
    images, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Java byte is a number in the [-128, +127] range and is represented using
    1 signed byte (8 bits). A hexadecimal (base 16) is a system based on 16 digits
    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F). In other words, those 8
    bits of a byte value accommodate exactly 2 hexadecimal characters in the range
    00 to FF. The decimal <-> binary <-> hexadecimal mapping is resumed in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27.png](img/B19665_02_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.27: Decimal to binary to hexadecimal conversion'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, 122 in binary is 01111010\. Since 0111 is in hexadecimal 7, and
    1010 is A, this results in 122 being 7A in hexadecimal (also written as 0x7A).
  prefs: []
  type: TYPE_NORMAL
- en: How about a negative byte? We know from the previous chapter that Java represents
    a negative number as *two’s complement* of the positive number. This means that
    -122 in binary is 10000110 (retain the first 7 bits of positive 122 = 1111010,
    flip(1111010) = 0000101, add(0000001) = 00000110, and append sign bit 1, 10000110)
    and in hexadecimal, is 0x86.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a negative number to hexadecimal can be done in several ways, but
    we can easily obtain the lower 4 bits as 10000110 & 0xF = 0110, and the higher
    four bits as (10000110>> 4) & 0xF = 1000 & 0xF = 1000 (here, the 0xF (binary,
    1111) mask is useful only for negative numbers). Since, 0110 = 6 and 1000 = 8,
    we see that 10000110 is in hexadecimal 0x86\.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a deep coverage of bits manipulation in Java or you simply face
    issues in understanding the current topic, then please consider the book *The
    Complete Coding Interview Guide in Java*, especially *Chapter 9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in code lines, we can rely on this simple algorithm and `Character.forDigit(int
    d, int r)`, which returns the character representation for the given digit (`d`)
    in the given radix (`r`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other ways to solve this problem (in the bundled code, you can
    see another flavor of this solution). For example, if we know that the `Integer.toHexString(int
    n)` method returns a string that represents the unsigned integer in base 16 of
    the given argument, then all we need is to apply the 0xFF (binary, 11111111) mask
    for negatives as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If there is an approach that we should avoid, then that is the one based on
    `String.format()`. The `String.format("%02x ", byte_nr)` approach is concise but
    very slow!
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the reverse process? Converting a given hexadecimal string (for instance,
    7d, 09, and so on) to a byte is quite easy. Just take the first (`d1`) and second
    (`d2`) character of the given string and apply the relation, `(byte) ((d1 << 4)
    + d2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the bundled code. If you rely on third-party
    libraries, then check Apache Commons Codec (`Hex.encodeHexString()`), Guava (`BaseEncoding`),
    Spring Security (`Hex.encode()`), Bouncy Castle (`Hex.toHexString()`), and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 17+
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JDK 17, we can use the `java.util.HexFormat` class. This class
    has plenty of static methods for handling hexadecimal numbers, including `String
    toHexDigits(byte value)` and `byte[]parseHex(CharSequence string)`. So, we can
    convert a byte to a hexadecimal string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And, vice versa as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can also see the extrapolation of these solutions for
    converting an array of bytes (`byte[]`) to a `String`, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 45\. Exemplify the initialization-on-demand holder design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we tackle the solution of implementing the initialization-on-demand holder
    design pattern, let’s quickly recap a few ingredients of this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Static vs. non-static blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, we can have *initialization non-static blocks* and *static blocks*.
    An initialization non-static block (or simply, a non-static block) is automatically
    called every single time we instantiate the class. On the other hand, an initialization
    static block (or simply, a static block) is called a single time when the class
    itself is initialized. No matter how many subsequent instances of that class we
    create, the static block will never get executed again. In code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s run the following test code to create three instances of `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output reveals that the static initializer is called only once, while the
    non-static initializer is called three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, the static initializer is called before the non-static one. Next,
    let’s talk about nested classes.
  prefs: []
  type: TYPE_NORMAL
- en: Nested classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested classes can be static or non-static. A non-static nested class is referred
    to as an *inner clas*s; further, it can be a *local inner class* (declared in
    a method) or an *anonymous inner class* (class with no name). On the other hand,
    a nested class that is declared static is referred to as a *static nested class*.
    The following figure clarifies these statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28.png](img/B19665_02_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.28: Java nested classes'
  prefs: []
  type: TYPE_NORMAL
- en: Since `B` is a static class declared in `A`, we say that `B` is a static nested
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling the initialization-on-demand holder design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initialization-on-demand holder design pattern refers to a thread-safe
    lazy-loaded singleton (single instance) implementation. Before JDK 16, we can
    exemplify this design pattern in code as follows (we want a single thread-safe
    instance of `Connection`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: No matter how many times a thread (multiple threads) calls `Connection.get()`,
    we always get the same instance of `Connection`. This is the instance created
    when we called `get()` for the first time (first thread), and Java has initialized
    the `LazyConnection` class and its statics. In other words, if we never call `get()`,
    then the `LazyConnection` class and its statics are never initialized (this is
    why we name it lazy initialization). And, this is thread-safe because static initializers
    can be constructed (here, `INSTANCE`) and referenced without explicit synchronization
    since they are run before any thread can use the class (here, `LazyConnection`).
  prefs: []
  type: TYPE_NORMAL
- en: JDK 16+
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until JDK 16, an inner class could contain static members as constant variables
    but it couldn’t contain static initializers. In other words, the following code
    would not compile because of the static initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: But, starting with JDK 16, the previous code is compiled without issues. In
    other words, starting with JDK 16, Java inner classes can have static members
    and static initializers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to tackle the initialization-on-demand holder design pattern
    from another angle. We can replace the static nested class, `LazyConnection`,
    with a local inner class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `LazyConnection` is visible only in its containing method, `get()`.
    As long as we don’t call the `get()` method, the connection will not be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 46\. Adding nested classes in anonymous classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous problem, we had a brief overview of nested classes. As a quick
    reminder, an anonymous class (or, anonymous inner class) is like a local inner
    class without a name. Their purpose is to provide a more concise and expressive
    code. However, the code readability may be affected (look ugly), but it may be
    worth it if you can perform some specific task without having to do a full-blown
    class. For instance, an anonymous class is useful for altering the behavior of
    an existing method without spinning a new class. Java uses them typically for
    event handling and listeners (in GUI applications). Probably the most famous example
    of an anonymous class is this one from Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, while local inner classes are actually class declarations, anonymous
    classes are expressions. To create an anonymous class, we have to extend an existing
    class or implement an interface, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28.png](img/B19665_02_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.29: Anonymous class via class extension and interface implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Because they don’t have names, anonymous classes must be declared and instantiated
    in a single expression. The resulting instance can be assigned to a variable that
    can be referred to later. The standard syntax for expressions looks like calling
    a regular Java constructor having the class in a code block ending with a semi-colon
    (`;`). The presence of a semi-colon is a hint that an anonymous class is an expression
    that must be part of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, anonymous classes cannot have explicit constructors, be abstract, have
    a single instance, implement multiple interfaces, or be extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s tackle a few examples of nesting classes in anonymous classes.
    For instance, let’s consider the following interface of a printing service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Printer` interface all over the place in our printing service,
    but we also want to have a helper method that is compact and simply tests our
    printer functions without requiring further actions or an extra class. We decided
    to hide this code in a static method named `printerTest()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the `best` quality print requires some extra settings wrapped in the
    inner `Tools` class. As you can see, the inner `Tools` class is nested in the
    anonymous class. Another approach consists of moving the `Tools` class inside
    the `print()` method. So, `Tools` becomes a local inner class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this approach is that the `Tools` class cannot be used outside
    of `print()`. So, this strict encapsulation will restrict us from adding a new
    method (next to `print()`) that also needs the `Tools` class.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 16+
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But, remember from the previous problem that, starting with JDK 16, Java inner
    classes can have static members and static initializers. This means that we can
    drop the `Tools` class and rely on two static methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find it more convenient to pick up these helpers in a static class,
    then do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 47\. Exemplify erasure vs. overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we join them in an example, let’s quickly tackle erasure and overloading
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Erasure in a nutshell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java uses *type erasure* at compile time in order to enforce type constraints
    and backward compatibility with old bytecode. Basically, at compilation time,
    all type arguments are replaced by `Object` (any generic must be convertible to
    `Object`) or type bounds (`extends` or `super`). Next, at runtime, the type erased
    by the compiler will be replaced by our type. A common case of type erasure implies
    generics.
  prefs: []
  type: TYPE_NORMAL
- en: Erasure of generic types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Practically, the compiler erases the unbound types (such as `E`, `T`, `U`,
    and so on) with the bounded `Object`. This enforces type safety, as in the following
    example of *class type erasure*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler applies type erasure to replace `E` with `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If the `E` parameter is bound, then the compiler uses the first bound class.
    For instance, in a class such as `class Node<T extends Comparable<T>> {...}`,
    the compiler will replace `T` with `Comparable`. In the same manner, in a class
    such as `class Computation<T extends Number> {...}`, all occurrences of `T` would
    be replaced by the compiler with the upper bound `Number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following case, which is a classical case of *method type erasure*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? When we call `listOf(1, "one")`, we are actually passing
    two different types to the generic parameters `T` and `R`. The compiler type erasure
    has replaced `T` with `Object`. In this way, we can insert different types in
    the `ArrayList` and the code works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Erasure and bridge methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bridge methods* are created by the compiler to cover corner cases. Specifically,
    when the compiler encounters an implementation of a parameterized interface or
    an extension of a parameterized class, it may need to generate a bridge method
    (also known as a synthetic method) as part of the type erasure phase. For instance,
    let’s consider the following parameterized class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And, an extension of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Type erasure modifies `Puzzle.setPiece(E)` as `Puzzle.setPiece(Object)`. This
    means that the `FunPuzzle.setPiece(String)` method does not override the `Puzzle.setPiece(Object)`
    method. Since the signatures of the methods are not compatible, the compiler must
    accommodate the polymorphism of generic types via a bridge (synthetic) method
    meant to guarantee that sub-typing works as expected. Let’s highlight this method
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever you see a bridge method in the stack trace, you will know what
    it is and why it is there.
  prefs: []
  type: TYPE_NORMAL
- en: Type erasure and heap pollution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever seen an unchecked warning? I’m sure you have! It’s one of those
    things that is common to all Java developers. They may occur at compile-time as
    the result of type checking, or at runtime as a result of a cast or method call.
    In both cases, we talk about the fact that the compiler cannot validate the correctness
    of an operation, which implies some parameterized types. Not every unchecked warning
    is dangerous, but there are cases when we have to consider and deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: A particular case is represented by *heap pollution.* If a parameterized variable
    of a certain type points to an object that is not of that type, then we are prone
    to deal with a code that leads to heap pollution. A good candidate for such scenarios
    involves methods with `varargs` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `listOf()` declaration will cause this warning: *Possible heap pollution
    from parameterized vararg type T*. So, what’s happening here?'
  prefs: []
  type: TYPE_NORMAL
- en: The story begins when the compiler replaces the formal `T...` parameter into
    an array. After applying type erasure, the `T...` parameter becomes `T[]`, and
    finally `Object[]`. Consequently, we opened a gate to possible heap pollution.
    But, our code just added the elements of `Object[]` into a `List<Object>`, so
    we are in the safe area.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, if you know that the body of the `varargs` method is not prone
    to generate a specific exception (for example, `ClassCastException`) or to use
    the `varargs` parameter in an improper operation, then we can instruct the compiler
    to suppress these warnings. We can do it via the `@SafeVarargs` annotation as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `@SafeVarargs` is a hint that sustains that the annotated method will use
    the `varargs` formal parameter only in proper operations. More common, but less
    recommended, is to use `@SuppressWarnings({"unchecked", "varargs"})`, which simply
    suppresses such warnings without claiming that the `varargs` formal parameter
    is not used in improper operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s tackle this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the type erasure transforms the `List<Integer>...` into `List[]`,
    which is a subtype of `Object[]`. This allows us to do the assignment: `Object[]
    listsAsArray = lists;`. But, check out the last two lines of code where we create
    a `List<String>` and store it in `listsAsArray[0]`. In the last line, we try to
    access the first `Integer` from `lists[0]`, which obviously leads to a `ClassCastException`.
    This is an improper operation of using `varargs`, so it is not advisable to use
    `@SafeVarargs` in this case. We should have taken the following warnings seriously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now, that you are familiar with type erasure, let’s briefly cover polymorphic
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic overloading in a nutshell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since *overloading* (also known as “ad hoc” polymorphism) is a core concept
    of **Object-Oriented Programming** (**OOP**), I’m sure you are familiar with Java
    method overloading, so I’ll not insist on the basic theory of this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I’m aware that some people don’t agree that overloading can be a form
    of polymorphism, but that is another topic that we will not tackle here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be more practical and jump into a suite of quizzes meant to highlight
    some interesting aspects of overloading. More precisely, we will discuss *type
    dominance*. So, let’s tackle the first quiz (`wordie` is an initially empty string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'What will happen? If you answered that the compiler will point out that there
    is no suitable method found for `kaboom(1)`, then you’re right. The compiler looks
    for a method that gets an integer argument, `kaboom(int)`. Okay, that was easy!
    Here is the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We know that the first two `kaboom()` instances are useless. How about `kaboom(long)`
    and `kaboom(Integer)`? You are right, `kaboom(long)` will be called. If we remove
    `kaboom(long)`, then `kaboom(Integer)` is called.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: In primitive overloading, the compiler starts by searching for a one-to-one
    match. If this attempt fails, then the compiler searches for an overloading flavor
    taking a primitive broader domain than the primitive current domain (for instance,
    for an `int`, it looks for `int`, `long`, `float`, or `double`). If this fails
    as well, then the compiler checks for overloading taking boxed types (`Integer`,
    `Float`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the previous statements, let’s have this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This time, `wordie` will be `i`. The `kaboom(Integer)` is called since there
    is no `kaboom(int`/`long`/`float`/`double)`. If we had a `kaboom(double)`, then
    that method has higher precedence than `kaboom(Integer)`. Interesting, right?!
    On the other hand, if we remove `kaboom(Integer)`, then don’t expect that `kaboom(Long)`
    will be called. Any other `kaboom(boxed type)` with a broader/narrow domain than
    `Integer` will not be called. This is happening because the compiler follows the
    inheritance path based on an IS-A relationship, so after `kaboom(Integer)`, it
    looks for `kaboom(Number)`, since `Integer` is a `Number`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: In boxed type overloading, the compiler starts by searching for a one-to-one
    match. If this attempt fails, then the compiler will not consider any overloading
    flavor taking a boxed type with a broader domain than the current domain (of course,
    a narrow domain is ignored as well). It looks for `Number` as being the superclass
    of all boxed types. If `Number` is not found, the compiler goes up in the hierarchy
    until it reaches the `java.lang.Object`, which is the end of the road.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let’s complicate things a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: So, which method will be called this time? I know, you think `kaboom(Number)`,
    right? At least, my simple logic pushes me to think that this is a common-sense
    choice. And it is correct!
  prefs: []
  type: TYPE_NORMAL
- en: If we remove `kaboom(Number)`, then the compiler will call the `varargs` method,
    `kaboom(Number...)`. This makes sense since `kaboom(1)` uses a single argument,
    so `kaboom(Number)` should have higher precedence than `kaboom(Number...)`. This
    logic reverses if we call `kaboom(1,2,3)` since `kaboom(Number)` is no longer
    representing a valid overloading for this call, and `kaboom(Number...)` is the
    right choice.
  prefs: []
  type: TYPE_NORMAL
- en: But, this logic applies because `Number` is the superclass of all boxed classes
    (`Integer`, `Double`, `Float`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: How about now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This time, the compiler will “bypass” `kaboom(File...)` and will call `kaboom(Object...)`.
    Based on the same logic, a call of `kaboom(1, 2, 3)` will call `kaboom(Object...)`
    since there is no `kaboom(Number...)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: In overloading, if the call has a single argument, then the method with a single
    argument has higher precedence than its `varargs` counterpart. On the other hand,
    if the call has more arguments of the same type, then the `varargs` method is
    called since the one-argument method is not suitable anymore. When the call has
    a single argument but only the `varargs` overloading is available, then this method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This time, `kaboom()` has no arguments and the compiler cannot find a unique
    match. This means that the reference to `kaboom()` is ambiguous since both methods
    match (`kaboom(java.lang.Number...)` in `modern.challenge.Main` and method `kaboom(java.io.File...)`
    in `modern.challenge.Main`).
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can play even more with polymorphic overloading and
    test your knowledge. Moreover, try to challenge yourself and introduce generics
    in the equation as well.
  prefs: []
  type: TYPE_NORMAL
- en: Erasure vs. overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, based on the previous experience, check out this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'What will happen? Well, this is a case where overloading and type erasure collide.
    The type erasure will replace `List<A>` with `List<Object>` and `List<B>` with
    `List<Object>` as well. So, overloading is not possible and we get an error such
    as *name clash: print(java.util.List<modern.challenge.B>) and print (java.util.List<modern.challenge.A>)
    have the same erasure*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this issue, we can add a dummy argument to one of these two
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can have the same call for both methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Done! You can practice these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 48\. Xlinting default constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that a Java class with no explicit constructor automatically gets an
    “invisible” default constructor for setting default values of the instance variables.
    The following `House` class falls in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If this is exactly what we wanted, then it is no problem. But, if we are concerned
    about the fact that the default constructors are exposed by classes to publicly
    exported packages, then we have to consider using JDK 16+.
  prefs: []
  type: TYPE_NORMAL
- en: 'JDK 16+ added a dedicated *lint* meant to warn us about the classes that have
    default constructors. In order to take advantage of this *lint*, we have to follow
    two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Export the package containing that class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile with `-Xlint:missing-explicit-ctor` (or `-Xlint`, `-Xlint:all`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we export the package `modern.challenge` in `module-info` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you compile the code with `-Xlint:missing-explicit-ctor`, you’ll see a
    warning like in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30.png](img/B19665_02_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.30: The warning produced by -Xlint:missing-explicit-ctor'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can easily find out which classes have default constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 49\. Working with the receiver parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JDK 8, we can enrich any of our instance methods with the optional
    *receiver parameter*. This is a purely syntactic parameter of enclosing type exposed
    via the `this` keyword. The following two snippets of code are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Do not conclude that `revision2()` is an overloading of `revision1()`, or vice
    versa. Both methods have the same output, the same signature, and produce the
    same bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The receiver parameter can be used in inner classes as well. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, but why use the receiver parameter? Well, JDK 8 introduced so-called
    *type annotations*, which are exactly as the name suggests: annotations that can
    be applied to types. In this context, the receiver parameter was added for annotating
    the type of object for which the method is called. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, check this more elaborate example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Every client of a `Parcel` must call these methods in a precise sequence drawn
    via type annotations and receiver parameters. In other words, an order can be
    placed only if it is a new order, it can be shipped only if the order was placed,
    it can be delivered only if it was shipped, it can be paid only if it was delivered,
    and it can be closed only if it was paid.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, this strict sequence is pointed out only by these hypothetical
    annotations. But, this is the right road to implement further a static analysis
    tool that will understand the meaning of these annotations and trigger warnings
    every time a client of `Parcel` doesn’t follow this precise sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 50\. Implementing an immutable stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common coding challenge in interviews is this: Implement an immutable stack
    in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Being an abstract data type, a stack needs at least this contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Having this contract, we can focus on the immutable implementation. Generally
    speaking, an immutable data structure stays the same until an operation attempts
    to change it (for instance, to add, put, remove, delete, push, and so on). If
    an operation attempts to alter the content of an immutable data structure, a new
    instance of that data structure must be created and used by that operation, while
    the previous instance remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our context, we have two operations that can alter the stack content:
    push and pop. The push operation should return a new stack containing the pushed
    element, while the pop operation should return the previous stack. But, in order
    to accomplish this, we need to start from somewhere, so we need an empty initial
    stack. This is a singleton stack that can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StackIterator` is a trivial implementation of the Java `Iterator`. Nothing
    fancy here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have the `Iterator` and an empty stack singleton. Finally, we can
    implement the logic of the immutable stack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a stack starts by calling the`ImmutableStack.empty()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can how this stack can be used further.
  prefs: []
  type: TYPE_NORMAL
- en: 51\. Revealing a common mistake with Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everybody knows that `String` is an immutable class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even so, we are still prone to accidentally write code that ignores the fact
    that `String` is immutable. Check out this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Somehow, it is logical to think that the `replace()` call has replaced the text
    *start* with *stop* and now `str` is *stop*. This is the cognitive power of words
    (*replace* is a verb that clearly induces the idea that the text was replaced).
    But, `String` is immutable! Oh… we already know that! This means that `replace()`
    cannot alter the original `str`. There are many such silly mistakes that we are
    prone to accidentally make, so pay extra attention to such simple things, since
    they can waste your time in the debugging stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is obvious and self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget that `String` is immutable!
  prefs: []
  type: TYPE_NORMAL
- en: 52\. Using the enhanced NullPointerException
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take your time to dissect the following trivial code and try to identify the
    parts that are prone to cause a `NullPointerException` (these parts are marked
    as numbered warnings, which will be explained after the snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'You noticed the warnings? Of course, you did! There are five major scenarios
    behind most **NullPointerException** (**NPEs**) and each of them is present in
    the previous class. Prior to JDK 14, an NPE doesn’t contain detailed information
    about the cause. Look at this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This message is just a starting point for the debugging process. We don’t know
    the root cause of this NPE or which variable is `null`. But, starting with JDK
    14 (JEP 358), we have really helpful NPE messages. For example, in JDK 14+, the
    previous message looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part of the message gives us important information about the
    root cause of this NPE. Now, we know that the `str` variable is `null`, so no
    need to debug further. We can just focus on how to fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s tackle each of the five major root causes of NPEs.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING 1! NPE when calling an instance method via a null object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code written by a client of `ChainSaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The client passes a chainsaw model that is not supported by this class, so
    the `initChainSaw()` method returns `null`. This is really bad because every time
    the client uses the `cs` variable, they will get back an NPE as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Instead of returning `null`, it is better to throw an explicit exception that
    informs the client that they cannot continue because we don’t have this chainsaw
    model (we can go for the classical `IllegalArgumentException` or, the more suggestive
    one in this case (but quite uncommon for `null` value handling), `UnsupportedOperationException`).
    This may be the proper fix in this case, but it is not universally true. There
    are cases when it is better to return an empty object (for example, an empty string,
    collection, or array) or a default object (for example, an object with minimalist
    settings) that doesn’t break the client code. Since JDK 8, we can use `Optional`
    as well. Of course, there are cases when returning `null` makes sense but that
    is more common in APIs and special situations.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING 2! NPE when accessing (or modifying) the field of a null object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code written by a client of `ChainSaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Practically, the NPE, in this case, has the same root cause as the previous
    case. We try to access the `started` field of `ChainSaw`. Since this is a primitive
    `boolean`, it was initialized by JVM with `false`, but we cannot “see” that since
    we try to access this field through a `null` variable represented by `cs`.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING 3! NPE when null is passed in the method argument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code written by a client of `ChainSaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not a good citizen if you want a `null ChainSaw`, but who am I to judge?
    It is possible for this to happen and will lead to the following NPE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The message is crystal clear. We attempt to call the `String.endWith()` method
    with a `null` argument represented by the `model` variable. To fix this issue,
    we have to add a guard condition to ensure that the passed `model` argument is
    not `null` (and eventually, not empty). In this case, we can throw an `IllegalArgumentException`
    to inform the client that we are here and we are guarding. Another approach may
    consist of replacing the given `null` with a dummy model that passes through our
    code without issues (for instance, since the model is a `String`, we can reassign
    an empty string, **““**). However, personally, I don’t recommend this approach,
    not even for small methods. You never know how the code will evolve and such dummy
    reassignments can lead to brittle code.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING 4! NPE when accessing the index value of a null array/collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code written by a client of `ChainSaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an array of `ChainSaw` was quite challenging in this example. We accidentally
    slipped a `null` value (actually, we did it intentionally) and an unsupported
    model. In return, we get the following NPE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The message informs us that the `cs` variable is `null`. This is happening
    at line 37 in `ChainSaw`, so in the for loop of the `performance()` method. While
    looping the given array, our code iterated over the `null` value, which doesn’t
    have the `speed` field. Pay attention to this kind of scenario: even if the given
    array/collection itself is not `null`, it doesn’t mean that it cannot contain
    `null` items. So, adding a guarding check before handling each item can save us
    from an NPE in this case. Depending on the context, we can throw an `IllegalArgumentException`
    when the loop passes over the first `null` or simply ignore `null` values and
    don’t break the flow (in general, this is more suitable). Of course, using a collection
    that doesn’t accept `null` values is also a good approach (Apache Commons Collection
    and Guava have such collections).'
  prefs: []
  type: TYPE_NORMAL
- en: WARNING 5! NPE when accessing a field via a getter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code written by a client of `ChainSaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the associated NPE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Practically, the getter `getPower()` returned `null` since the `power` field
    is `null`. Why? The answer is in the line `return new ChainSaw(model, null, (int)
    (Math.random() * 100));` of the `initChainSaw()` method. Because we didn’t decide
    yet on the algorithm for calculating the power of a chainsaw, we passed `null`
    to the `ChainSaw` constructor. Further, the constructor simply sets the `power`
    field as `this.power = power`. If it was a public constructor, then most probably
    we would have added some guarded conditions, but being a private constructor,
    it is better to fix the issue right from the root and not pass that `null`. Since
    the `power` is a `String`, we can simply pass an empty string or a suggestive
    string such as `UNKNOWN_POWER`. We also may leave a TODO comment in code such
    as `// TODO (JIRA ####): replace UNKNOWN_POWER with code`. This will remind us
    to fix this in the next release. Meanwhile, the code has eliminated the NPE risk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, after we fixed all these five NPE risks, the code has become the following
    (the added code is highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, our code is NPE-free. At least until reality contradicts us and a
    new NPE occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 53\. Using yield in switch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we’re going to look at how `switch` expressions have evolved in JDK 13+.
  prefs: []
  type: TYPE_NORMAL
- en: Java SE 13 added the new `yield` statement, which can be used instead of the
    `break` statement in switch expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that a JDK 12+ `switch` expression can be written as follows (`playerType`
    is a Java enum):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we know that a label’s arrow can point to a curly-braces block as
    well (this works only in JDK 12, **not in JDK 13+**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `break` can be confusing because it can be used in old-school `switch`
    statements and in the new `switch` expressions, JDK 13 added the `yield` statement
    to be used instead of `break`. The `yield` statement takes one argument representing
    the value produced by the current case. The previous examples can be written from
    JDK 13+ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In other words, starting with JDK 13+, a `switch` expression can rely on `yield`
    but not on `break`, and a `switch` statement can rely on `break` but not on `yield`.
  prefs: []
  type: TYPE_NORMAL
- en: 54\. Tackling the case null clause in switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before JDK 17, a `null` case in a `switch` was commonly coded as a guarding
    condition outside the `switch`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 17+ (JEP 427), we can treat a `null` case as any other common
    case. For instance, here we have a `null` case that is responsible for handling
    the scenarios when the passed argument is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'In certain contexts, `null` and `default` have the same meaning, so we can
    chain them in the same `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you might find it more readable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I suggest you think twice before patching your `switch` expressions
    with `case null`, especially if you plan to do it only for silently sweeping these
    values. Overall, your code may become brittle and exposed to unexpected behaviors/results
    that ignore the presence of `null` values. In the bundled code, you can test the
    complete examples.
  prefs: []
  type: TYPE_NORMAL
- en: 55\. Taking on the hard way to discover equals()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: So, initially, `listOfInt1` and `listOfInt2` have the same items, [`x1`=14,
    `y1`=14, `x2`=129, `y2`=129]. But, what will contain `listOfInt1`/`listOfInt2`
    after executing the code based on `removeIf()` and `==`, respectively `equals()`?
  prefs: []
  type: TYPE_NORMAL
- en: The first list will remain with a single item, [129]. When `t` is `x1`, we know
    that `x1 == x1`, so 14 is removed. But, why is `x2` removed? When `t` is `y1`,
    we know that `y1 == x1` should be `false` since, via `==`, we compare the object’s
    references in memory, not their values. Obviously, `y1` and `x1` should have different
    references in the memory… or shouldn’t they ? Actually, Java has an internal rule
    to cache integers in -127 … 128\. Since `x1`=14 is cached, `y1`=14 uses the cache
    so no new `Integer` is created. This is why `y1 == x1` and `y1` is removed as
    well. Next, `t` is `x2`, and `x2 == x2`, so `x2` is removed. Finally, `t` is `y2`,
    but `y2 == x2` returns `false`, since 129 > 128 is not cached, so `x2` and `y2`
    have different references in memory.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when we use `equals()`, which is the recommended approach
    for comparing the object’s values, the resulting list is empty. When `t` is `x1`,
    `x1` =`x1`, so 14 is removed. When `t` is `y1`, `y1` =`x1`, so `y1` is removed
    as well. Next, `t` is `x2`, and `x2`= `x2`, so `x2` is removed. Finally, `t` is
    `y2`, and `y2` =`x2`, so `y2` is removed as well.
  prefs: []
  type: TYPE_NORMAL
- en: 56\. Hooking instanceof in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having an object (`o`) and a type (`t`), we can use the `instanceof` operator
    to test if `o` is of type `t` by writing `o instanceof t`. This is a `boolean`
    operator that is very useful to ensure the success of a subsequent casting operation.
    For instance, check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '`instanceof` returns `true` if we test the object (for instance, `Wardrobe`)
    against the type itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '`instanceof` returns true if the tested object (for instance, `Wardrobe`) is
    an instance of a subclass of the type (for instance `Plywood`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '`instanceof` returns `true` if the tested object (for instance, `Wardrobe`)
    implements the interface represented by the type (for instance, `Furniture`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, consider the following note:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The logic behind `instanceof` relies on the IS-A relationship (this is detailed
    in *The Complete Coding Interview Guide in Java*, *Chapter 6*, *What is inheritance?*).
    In a nutshell, this relationship is based on interface implementation or class
    inheritance. For instance, `wardrobe instanceof Plywood` returns `true` because
    `Wardrobe` extends `Plywood`, so `Wardrobe` IS A `Plywood`. Similarly, `Wardrobe`
    IS A `Furniture`. On the other hand, `Plywood` IS-not-A `Furniture`, so `plywood
    instanceof Furniture` returns `false`. In this context, since every Java class
    extends `Object`, we know that `foo instanceof Object` returns `true` as long
    as `foo` is an instance of a Java class. In addition, `null instanceof Object`
    (or any other object) returns `false`, so this operator doesn’t require an explicit
    `null` check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, keep in mind that `instanceof` works only with reified types (reified
    type information is available at runtime), which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types (`int`, `float`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw types (`List`, `Set`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-generic classes/interfaces (`String`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types with unbounded wildcards (`List<?>`, `Map<?, ?>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays of reifiable types (`String[]`, `Map<?, ?>[]`, `Set<?>[]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we cannot use the `instanceof` operator (or casts) with parameterized
    types because the type erasures alter all type parameters in generic code, so
    we cannot say which parameterized type for a generic type is in use at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 57\. Introducing pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 16 has introduced one of the major and complex features of Java, referred
    to as *pattern matching*. The future is wide open for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, *pattern matching* defines a synthetic expression for checking/testing
    whether a given variable has certain properties. If those properties are met,
    then automatically extract one or more parts of that variable into other variables.
    From this point forward, we can use those extracted variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pattern matching instance (pay attention, this has nothing to do with design
    patterns) is a structure made of several components as follows (this is basically
    the pattern matching terminology):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *target operand* or the argument of the predicate: This is a variable (or
    an expression) that we aim to match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *predicate* (or *test*): This is a check that takes place at runtime and
    aims to determine if the given *target operand* does or doesn’t have one or more
    properties (we match the *target operand* against the properties).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One or more variables are referred to as *pattern variables* or *binding variables*:
    these variables are automatically extracted from the *target operand* if and only
    if the *predicate*/*test* succeeds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have the *pattern* itself, which is represented by the *predicate*
    + *binding variables*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.31.png](img/B19665_02_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.31: Pattern matching components'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can say that Java pattern matching is a synthetic expression of a complex
    solution composed of four components: target operand, predicate/test, binding
    variable(s), and pattern = predicate + binding variable(s).'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of binding variables in pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler decides the scope (visibility) of the binding variables, so we
    don’t have to bother with such aspects via special modifiers or other tricks.
    In the case of predicates that always pass (like an `if(true) {}`), the compiler
    scopes the binding variables exactly as for the Java *local variables*.
  prefs: []
  type: TYPE_NORMAL
- en: But, most patterns make sense precisely because the predicate may fail. In such
    cases, the compiler applies a technique called *flow scoping*. That is actually
    a combination of the *regular scoping* and *definitive assignment*.
  prefs: []
  type: TYPE_NORMAL
- en: The *definitive assignment* is a technique used by the compiler based on the
    structure of statements and expressions to ensure that a local variable (or blank
    `final` field) is definitely assigned before it is accessed by the code. In a
    pattern-matching context, a binding variable is assigned only if the predicate
    passes, so the *definitive assignment* aim is to find out the precise place when
    this is happening. Next, the regular block scope represents the code where the
    binding variable is in scope.
  prefs: []
  type: TYPE_NORMAL
- en: Do you want this as a simple important note? Here it is.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: In pattern matching, the binding variable is flow-scoped. In other words, the
    scope of a binding variable covers only the block where the predicate passed.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover this topic in *Problem 59*.
  prefs: []
  type: TYPE_NORMAL
- en: Guarded patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we know that a pattern relies on a predicate/test for deciding whether
    the binding variables should be extracted from the target operand or not. In addition,
    sometimes we need to refine this predicate by appending to it extra `boolean`
    checks based on the extracted binding variables. We name this a *guarded pattern*.
    In other words, if the predicate evaluates to `true`, then the binding variables
    are extracted and they enter in further `boolean` checks. If these checks are
    evaluated to `true`, we can say that the target operand matches this guarded pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We cover this in *Problem 64*.
  prefs: []
  type: TYPE_NORMAL
- en: Type coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, the `switch` expressions and `switch` statements that use `null`
    and/or pattern labels should be exhaustive. In other words, we must cover all
    the possible values with `switch case` labels.
  prefs: []
  type: TYPE_NORMAL
- en: We cover this in *Problem 66*.
  prefs: []
  type: TYPE_NORMAL
- en: Current status of pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, Java supports type pattern matching for `instanceof` and `switch`,
    and record pattern-destructuring patterns for records (covered in *Chapter 4*).
    These are the final releases in JDK 21.
  prefs: []
  type: TYPE_NORMAL
- en: 58\. Introducing type pattern matching for instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re right…type checking and casting are burdensome to write and read. Moreover,
    those check-cast sequences are error-prone (it is easy to change the checked type
    or the casted type and forget to change the type of the other object). Basically,
    in each conditional statement, we do three steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we do a type check (for instance, `o instanceof File`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we do a type conversion via cast (for instance, `(File) o`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Third, we do a variable assignment (for instance, `File file =`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But, starting with JDK 16 (JEP 394), we can use *type pattern matching for
    instanceof* to perform the previous three steps in one expression. The type pattern
    is the first category of patterns supported by Java. Let’s see the previous code
    rewritten via the *type pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In each `if`-`then` statement, we have a test/predicate to determine the type
    of `Object o`, a cast of `Object o` to `File`, `Path`, or `String`, and a destructuring
    phase for extracting either the length or the size from `Object o`.
  prefs: []
  type: TYPE_NORMAL
- en: The piece of code, (`o instanceof File file`) is not just some syntactic sugar.
    It is not just a convenient shortcut of the old-fashioned code to reduce the ceremony
    of conditional state extraction. This is a *type pattern* in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically, we match the variable `o` against `File file`. More precisely,
    we match the type of `o` against the type `File`. We have that `o` is the *target
    operand* (the argument of the predicate), `instanceof File` is the predicate,
    and the variable `file` is the *pattern* or *binding variable* that is automatically
    created only if `instanceof File` returns `true`. Moreover, `instanceof File file`
    is the *type pattern*, or in short, `File file` is the pattern itself. The following
    figure illustrates this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32.png](img/B19665_02_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.32: Type pattern matching for instanceof'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the type pattern for `instanceof`, there is no need to perform explicit
    `null` checks (exactly as in the case of plain `instanceof`), and no upcasting
    is allowed. Both of the following examples generate a compilation error in JDK
    16-20, but not in JDK 14/15/21 (this is weird indeed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation error points out that the expression type cannot be a subtype
    of pattern type (no upcasting is allowed). However, with plain `instanceof`, this
    works in all JDKs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s talk about the scope of binding variables.
  prefs: []
  type: TYPE_NORMAL
- en: 59\. Handling the scope of a binding variable in type patterns for instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From *Problem 57*, we know the headlines of scoping the binding variables in
    pattern matching. Moreover, we know from the previous problem that in the type
    pattern for `instanceof`, we have a single binding variable. It is time to see
    some practical examples, so let’s quickly crop this snippet from the previous
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The conditional part that starts with the `&&` short-circuit operator is evaluated
    by the compiler only if the `instanceof` operator is evaluated to `true`. This
    means that you cannot use the `||` operator instead of `&&`. For instance, is
    not logical to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, this is perfectly acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also extend the scope of the binding variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we negate the `if`-then statement, the `str` binding variable is available
    in the `else` branch. Following this logic, we can use *early returns* as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to flow scoping, the compiler can set up strict boundaries for the scope
    of binding variables. For instance, in the following code, there is no risk of
    overlapping even if we keep using the same name for the binding variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Here, each `nr` binding variable has a scope that covers only its own branch.
    No overlapping, no conflicts! However, using the same name for the multiple binding
    variables can be a little bit confusing, so it is better to avoid it. For instance,
    we can use `intNr` and `longNr` instead of simple `nr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another confusing scenario that is highly recommended to be avoided implies
    binding variables that hide fields. Check out this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: So, using the same name for binding variables (this is true for any local variable
    as well) and fields is a bad practice that should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JDK 14/15, we cannot reassign binding variables because they are declared
    `final` by default. However, JDK 16+ solved the asymmetries that may occur between
    local and binding variables by removing the `final` modifier. So, starting with
    JDK 16+, we can reassign binding variables as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Even if this is possible, it is highly recommended to avoid such *code smells*
    and keep the world clean and happy by not re-assigning your binding variables.
  prefs: []
  type: TYPE_NORMAL
- en: 60\. Rewriting equals() via type patterns for instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is not mandatory to rely on `instanceof` to implement the `equals()` method,
    but it is a convenient approach to write something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are a fan of the previous approach for implementing `equals()`, then
    you’ll love rewriting it via a type pattern for `instanceof`. Check out the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'If `MyPoint` is generic (`MyPoint<E>`) then simply use a wildcard as follows
    (more details are available in the next problem):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right?! However, pay attention that using `instanceof` to express the
    `equals()` contract imposes the usage of a `final` class of `final equals()`.
    Otherwise, if subclasses are allowed to override `equals()`, then `instanceof`
    may cause transitivity/symmetry bugs. A good approach is to pass `equals()` through
    a dedicated verifier such as equals verifier ([https://github.com/jqno/equalsverifier](https://github.com/jqno/equalsverifier)),
    which is capable of checking the validity of the `equals()` and `hashCode()` contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 61\. Tackling type patterns for instanceof and generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: As we know from *Problem 56*, we can combine `instanceof` with generic types
    via unbounded wildcards, such as our `EnumMap<?, ? extends V>` (or `EnumMap<?,
    ?>`, but not `EnumMap<K, ? extends V>`, `EnumMap<K, ?>`, or `EnumMap<K, V>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This code can be written more concisely via the type pattern for `instanceof`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: In the example based on plain `instanceof`, we can also replace `EnumMap<?,
    ? extends V>` with `Map<?, ? extends V>`. But, as we know from *Problem 53*, this
    is not possible with type patterns because the expression type cannot be a subtype
    of pattern type (upcasting is allowed). However, this is not an issue anymore
    starting with JDK 21.
  prefs: []
  type: TYPE_NORMAL
- en: 62\. Tackling type patterns for instanceof and streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider a `List<Engine>` where `Engine` is an interface implemented
    by several classes such as `HypersonicEngine`, `HighSpeedEngine`, and `RegularEngine`.
    Our goal is to filter this `List` and eliminate all `RegularEngine` classes that
    are electric and cannot pass our autonomy test. So, we can write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'But, starting with JDK 8, we can safely remove from a `List` without using
    an `Iterator` via a `default` method from `java.util.Collection` named `public
    default boolean removeIf(Predicate<? super E> filter)`. If we combine this method
    (and, therefore, the Stream API) with type patterns for `instanceof`, then we
    can simplify the previous code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: So, whenever you have the chance to use type patterns with the Stream API, don’t
    hesitate.
  prefs: []
  type: TYPE_NORMAL
- en: 63\. Introducing type pattern matching for switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 17 (JEP 406) added type pattern matching for `switch` as a preview feature.
    A second preview was available in JDK 18 (JEP 420). The final release is available
    in JDK 21 as JEP 441.
  prefs: []
  type: TYPE_NORMAL
- en: Type pattern matching for `switch` allows the *selector expression* (that is,
    `o` in `switch(o)`) to be of any type not just an `enum` constant, number, or
    string. By “any type,” I mean any type (any object type, `enum` type, array type,
    record type, or sealed type)! The type pattern matching is not limited to a single
    hierarchy as it happens in the case of inheritance polymorphism. The `case` labels
    can have type patterns (referred to as case pattern labels or, simply, pattern
    labels), so the selector expression (`o`) can be matched against a type pattern,
    not only against a constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure identifies the main players of a `switch` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33.png](img/B19665_02_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.33: Type pattern matching for switch'
  prefs: []
  type: TYPE_NORMAL
- en: The `case` for `null` is not mandatory. We have added it just for the sake of
    completeness. On the other hand, the `default` branch is a must, but this topic
    is covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 64\. Adding guarded pattern labels in switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you remember that type patterns for `instanceof` can be refined with extra
    `boolean` checks applied to the binding variables to obtain fine-grained use cases?
    Well, we can do the same for the `switch` expressions that use pattern labels.
    The result is named *guarded pattern labels*. Let’s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Having a `Stove` and a `Chimney`, this `switch` decides where to make a fire
    based on pattern labels. But, what will happen if `Chimney` is electric? Obviously,
    we will have to plug `Chimney` in instead of firing it up. This means that we
    should add a guarded pattern label that helps us to make the difference between
    an electric and non-electric `Chimney`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was easy, wasn’t it? Let’s have another example that starts from
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'For each `Vehicle`, we know the fuel type and how many gallons of fuel fit
    in the tank. Now, we can write a `switch` that can rely on guarded pattern labels
    to try to guess the type of the vehicle based on this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the pattern labels are the same in all cases (`Vehicle v`) and
    the decision is refined via the guarded conditions. The previous examples work
    just fine in JDK 17 and 18, but they don’t work starting with JDK 19+. Because
    the `&&` operator was considered confusing, starting with JDK 19+, we have to
    deal with a refinement syntax. Practically, instead of the `&&` operator, we use
    the new context-specific keyword `when` between the pattern label and the refining
    `boolean` checks. So, in JDK 19+, the previous code becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can find both versions for JDK 17/18, and JDK 19+.
  prefs: []
  type: TYPE_NORMAL
- en: 65\. Dealing with pattern label dominance in switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compiler matches the selector expression against the available pattern
    labels by testing the selector expression against each label starting from top
    to bottom (or, from the first to the last) in the exact order in which we wrote
    them in the `switch` block. This means that the first match wins. Let’s assume
    that we have the following base class (`Pill`) and some pills (`Nurofen`, `Ibuprofen`,
    and `Piafen`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Hierarchically speaking, `Nurofen`, `Ibuprofen`, and `Piafen` are three classes
    placed at the same hierarchical level since all of them have the `Pill` class
    as the base class. In an IS-A inheritance relationship, we say that `Nurofen`
    is a `Pill`, `Ibuprofen` is a `Pill`, and `Piafen` is also a `Pill`. Next, let’s
    use a `switch` to serve our clients the proper headache pill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Calling `headache(new Nurofen())` will match the first pattern label, `Nurofen
    nurofen`. In the same manner, `headache(new Ibuprofen())` matches the second pattern
    label, and `headache(new Piafen())` matches the third one. No matter how we mix
    the order of these label cases, they will work as expected because they are on
    the same level and none of them dominate the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, since people don’t want headaches, they order a lot of Nurofen,
    so we don’t have any anymore. We represent this by removing/comment the corresponding
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: So, what happens when a client wants Nurofen? You’re right … the `default` branch
    will take action since `Ibuprofen` and `Piafen` don’t match the selector expression.
  prefs: []
  type: TYPE_NORMAL
- en: But, what will happen if we modify the `switch` as follows?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `Pill` base class as a pattern label case allows us to remove the
    `default` branch since we cover all possible values (this is covered in detail
    in *Problem 66*). This time, the compiler will raise an error to inform us that
    the `Pill` label case dominates the rest of the label cases. Practically, the
    first label case `Pill pill` dominates all other label cases because every value
    that matches any of the `Nurofen nurofen`, `Ibuprofen ibuprofen`, `Piafen piafen`
    patterns also matches the pattern `Pill pill`. So, `Pill pill` always wins while
    the rest of the label cases are useless. Switching `Pill pill` with `Nurofen nurofen`
    will give a chance to `Nurofen nurofen`, but `Pill pill` will still dominate the
    remaining two. So, we can eliminate the dominance of the base class `Pill` by
    moving its label case to the last position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Now, every pattern label has a chance to win.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have another example that starts from this hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we have seven classes disposed of in a multi-level hierarchy. If
    we exclude the base class `Drink`, we can represent the rest of them in a `switch`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The order of pattern labels is imposed by the class hierarchy and is quite strict,
    but we can make some changes without creating any dominance issues. For instance,
    since `Extra` and `Large` are subclasses of `Medium`, we can switch their positions.
    Some things apply to `Jumbo` and `Huge` since they are both subclasses of `Medium`
    via `Extra`, respectively `Large`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, the compiler evaluates the selection expression by trying
    to match it against this hierarchy via an IS-A inheritance relationship. For instance,
    let’s order a `Jumbo` drink while there are no more `Jumbo` and `Extra` drinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'If we order `Jumbo` (`o` is `Jumbo`), then we will get `Medium`. Why? The compiler
    matches `Jumbo` against `Huge` without success. The same result is obtained while
    matching `Jumbo` against `Large`. However, when it matches `Jumbo` against `Medium`,
    it sees that `Jumbo` is a `Medium` subclass via the `Extra` class. So, since `Jumbo`
    is `Medium`, the compiler chooses the `Medium m` pattern label. At this point,
    `Medium` matches `Jumbo`, `Extra`, and `Medium`. So, soon we will be out of `Medium`
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: This time, any request for `Jumbo`, `Extra`, `Medium`, or `Small` will give
    us a `Small`. I think you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a step further, and analyze this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you spotted the problem? A pattern label case dominates a constant label
    case, so the compiler will complain about the fact that the second case (`case
    0`) is dominated by the first case. This is normal, since 0 is an `Integer` as
    well, so it will match the pattern label. The solution requires switching the
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another case to enforce this type of dominance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the constant is `HULK` and it is dominated by the `Hero h` pattern
    label case. This is normal, since `HULK` is also a Marvel hero, so `Hero h` will
    match all Marvel heroes including `HULK`. Again, the fix relies on switching the
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, finally, let’s tackle this snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'You may think that if we enforce the `Integer i` pattern label with a condition
    that forces `i` to be strictly positive, then the constant label will not be dominated.
    But, this is not true; a guarded pattern label still dominates a constant label.
    The proper order places the constant labels first, followed by guarded pattern
    labels, and finally, by non-guarded pattern labels. The next code fixes the previous
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Okay, I think you get the idea. Feel free to practice all these examples in
    the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 66\. Dealing with completeness (type coverage) in pattern labels for switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, `switch` expressions and `switch` statements that use null and/or
    pattern labels should be exhaustive. In other words, we must cover with explicit
    switch case labels all the possible values. Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'If we continue by adding another vehicle such as `class Truck extends Vehicle
    {}`, then this will be handled by the `default` branch. If we plan to use `Vehicle`
    as an independent class (for instance, to enrich it with methods and functionalities),
    then we will prefer to add a `case Vehicle` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This time, the `Truck` class will match the `case Vehicle` branch. Of course,
    we can add a `case Truck` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vehicle v` pattern is named a *total type pattern*. There are two labels
    that we can use to match all possible values: the total type pattern (for instance,
    a base class or an interface) and the `default` label. Generally speaking, a total
    pattern is a pattern that can be used instead of the `default` label.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we can accommodate all possible values via the total
    pattern or the `default` label but not both. This makes sense since the `whatAmI(Vehicle
    vehicle)` method gets `Vehicle` as an argument. So, in this example, the selector
    expression can be only `Vehicle` or a subclass of `Vehicle`. How about modifying
    this method as `whatAmI(Object o)`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the selector expression can be any type, which means that the total pattern
    `Vehicle v` is not total anymore. While `Vehicle v` becomes an optional ordinary
    pattern, the new total pattern is `case Object obj`. This means that we can cover
    all possible values by adding the `default` label or the `case Object obj` total
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'I think you get the idea! How about using an interface for the base type? For
    instance, here is an example based on the Java built-in `CharSequence` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, the `switch` expression doesn’t cover the `CoolChar` type.
    So, we still need a `default` label or the total pattern, `case CharSequence charseq`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let’s tackle this scenario on the `java.lang.constant.ClassDesc` built-in
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'This code compiles! There is no `default` label and no total pattern but the
    `switch` expression covers all possible values. How so?! This interface is declared
    as sealed via the `sealed` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Sealed interfaces/classes were introduced in JDK 17 (JEP 409) and we will cover
    this topic in *Chapter 8*. However, for now, it is enough to know that sealing
    allows us to have fine-grained control of inheritance so classes and interfaces
    define their permitted subtypes. This means that the compiler can determine all
    possible values in a `switch` expression. Let’s consider a simpler example that
    starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'And, let’s have a `switch` expression covering all possible values for `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is aware that the `Player` interface has only three implementations
    and all of them are covered via pattern labels. We can add a `default` label or
    the total pattern `case Player player`, but you most probably don’t want to do
    that. Imagine that we add a new implementation of the sealed `Player` interface
    named `Golf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: If the `switch` expression has a `default` label, then `Golf` values will be
    handled by this `default` branch. If we have the total pattern `Player player`,
    then this pattern will handle the `Golf` values. On the other hand, if none of
    the `default` labels or total patterns are present, the compiler will immediately
    complain that the `switch` expression doesn’t cover all possible values. So, we
    are immediately informed, and once we add a `case Golf g`, the error disappears.
    This way, we can easily maintain our code and have a guarantee that our `switch`
    expressions are always up to date and cover all possible values. The compiler
    will never miss the chance to inform us when a new implementation of `Player`
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar logic applies to Java enums. Consider the following `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is aware of all the possible values for `PlayerTypes`, so the
    following `switch` expression compiles successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can add a `default` label or the total pattern, `case PlayerTypes
    pt`. But, if we add a new value in the `enum` (for instance, `GOLF`), the compiler
    will delegate the `default` label or the total pattern to handle it. On the other
    hand, if none of these are available, the compiler will immediately complain that
    the `GOLF` value is not covered, so we can add it (`case GOLF g`) and create a
    golf player whenever required.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good! Now, let’s consider the following context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The sealed interface `Sport` allows only two subtypes: `PlayerClub` (a class)
    and `PlayerTypes` (an enum). If we write a `switch` that covers all possible values
    for `Sport`, then it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'We immediately observe that writing case `PlayerTypes p when p == PlayerTypes.TENNIS`
    is not quite neat. What we actually want is `case PlayerTypes.TENNIS` but, until
    JDK 21, this is not possible since qualified enum constants cannot be used in
    `case` labels. However, starting with JDK 21, we can use qualified names of enum
    constants as labels, so we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now you know how to deal with type coverage in `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 67\. Understanding the unconditional patterns and nulls in switch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s imagine that we use JDK 17 and we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the call, `drive(null)`. This call will hit the `Vehicle vehicle` total
    pattern, so even `null` values match total patterns. But, this means that the
    binding variable `vehicle` will also be `null`, which means that this branch is
    prone to `NullPointerException` (for instance, if we call a hypothetical method,
    `vehicle.start()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Because `Vehicle vehicle` matches all possible values, it is known as a total
    pattern but also as an *unconditional pattern* since it matches everything unconditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as we know from *Problem 54*, starting with JDK 17+ (JEP 427), we can
    have a pattern label for `null` itself, so we can handle the previous shortcoming
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, everybody agrees that adding a `case null` between vehicles looks awkward.
    Adding it at the end is not an option since will raise a dominance issue. So,
    starting with JDK 19+, adding this `case null` is no longer needed in this kind
    of scenario. Basically, the idea remains the same meaning that the unconditional
    pattern still only matches `null` values so it will not allow the execution of
    that branch. Actually, when a `null` value occurs, the `switch` expressions will
    throw a `NullPointerException` without even looking at the patterns. So, in JDK
    19+, this code will throw an NPE right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'The NPE message reveals that `vehicle.start()` was never called. The NPE occurred
    much earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: We will expand on this topic later when we will talk about Java records.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That’s all folks! This was a comprehensive chapter that covered four main topics,
    among others: `java.util.Objects`, immutability, `switch` expressions, and pattern
    matching for `instanceof` and `switch` expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  prefs: []
  type: TYPE_IMG
