["```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(1L)).fetchSingle();\n```", "```java\nSaleRecord srNew = new SaleRecord(...);\n```", "```java\nctx.attach(srNew);\n```", "```java\nsrNew.attach(ctx.configuration());\n```", "```java\nSaleRecord srNew = ctx.newRecord(SALE);\n```", "```java\nsrNew.setFiscalYear(…);\n```", "```java\n…\n```", "```java\nsrNew.detach(); // equivalent to srNew.attach(null);\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(1L)).fetchSingle();\n```", "```java\n// or, a little bit more concise\n```", "```java\nSaleRecord sr = ctx.fetchSingle(SALE, SALE.SALE_ID.eq(1L));\n```", "```java\nsr.setFiscalYear(2002);\n```", "```java\nSaleRecord srOriginal = sr.original();\n```", "```java\nint fiscalYear = sr.original(SALE.FISCAL_YEAR);\n```", "```java\nint fiscalYear = (int) sr.original(\"fiscal_year\");\n```", "```java\n<tr>\n```", "```java\n  <td> Product Buy Price:</td>\n```", "```java\n  <td th:text = \"${product.original('buy_price')}\"/></td>     \n```", "```java\n</tr>\n```", "```java\n<tr>\n```", "```java\n  <td> Product MSRP:</td> \n```", "```java\n  <td th:text = \"${product.original('msrp')}\"/></td>      \n```", "```java\n</tr>\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(1L)).fetchSingle();  \n```", "```java\nsr.changed(); // false\n```", "```java\nsr.setFiscalYear(2005);\n```", "```java\nsr.changed(); // true\n```", "```java\nSaleRecord sr = new SaleRecord(null, 2021, 453.2, 1504L, ...);\n```", "```java\nsr.changed(); // true\n```", "```java\nSaleRecord sr = new SaleRecord();\n```", "```java\nsr.setFiscalYear(2021);\n```", "```java\nsr.setSale(4500.25);\n```", "```java\n...\n```", "```java\nsr.changed(); // true\n```", "```java\nboolean changed = sr.changed(SALE.FISCAL_YEAR);\n```", "```java\nboolean changed = sr.changed(\"fiscal_year\");\n```", "```java\nsr.changed(true/false); \n```", "```java\nsr.changed(SALE.FISCAL_YEAR, true/false);\n```", "```java\nsr.changed(\"fiscal_year\", true/false);\n```", "```java\nsr.reset();\n```", "```java\nsr.reset(SALE.FISCAL_YEAR);\n```", "```java\nsr.reset(\"fiscal_year\");\n```", "```java\nsr.refresh();\n```", "```java\nsr.refresh(SALE.FISCAL_YEAR, SALE.SALE_);\n```", "```java\nSaleRecord sr = ctx.newRecord(SALE);\n```", "```java\nsr.setFiscalYear(2021);\n```", "```java\n...\n```", "```java\nsr.insert();\n```", "```java\nSaleRecord sr = new SaleRecord();\n```", "```java\nsr.setFiscalYear(2021);\n```", "```java\n...        \n```", "```java\nctx.attach(sr);\n```", "```java\nsr.insert();   \n```", "```java\nsr.changed(true); \n```", "```java\nsr.changed(SALE.SALE_ID, false); \n```", "```java\nsr.insert();\n```", "```java\nSaleRecord srCopy = sr.copy();        \n```", "```java\nsrCopy.insert();  \n```", "```java\n// or, shortly\n```", "```java\nsr.copy().insert();\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(1L)).fetchSingle();                \n```", "```java\nsr.setFiscalYear(2000);\n```", "```java\nsr.setSale(1111.25);\n```", "```java\nsr.update();\n```", "```java\nUPDATE `classicmodels`.`sale`\n```", "```java\nSET `classicmodels`.`sale`.`fiscal_year` = 2000,\n```", "```java\n    `classicmodels`.`sale`.`sale` = 1111.25\n```", "```java\nWHERE `classicmodels`.`sale`.`sale_id` = 1\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(5L)).fetchSingle();                \n```", "```java\nsr.delete();\n```", "```java\n// MySQL rendered SQL\n```", "```java\nDELETE FROM `classicmodels`.`sale` WHERE `classicmodels`\n```", "```java\n  .`sale`.`sale_id` = 5\n```", "```java\nSaleRecord srNew = ctx.newRecord(SALE);\n```", "```java\nsrNew.setFiscalYear(2000);\n```", "```java\n...\n```", "```java\nsrNew.merge();\n```", "```java\nSaleRecord srFetched = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(1L)).fetchSingle();                \n```", "```java\nsrFetched.setFiscalYear(2005);\n```", "```java\n...\n```", "```java\nsrFetched.merge();\n```", "```java\nSaleRecord srNew = ctx.newRecord(SALE);\n```", "```java\nsrNew.setFiscalYear(2000);\n```", "```java\n...\n```", "```java\nsrNew.store(); // jOOQ render an INSERT\n```", "```java\nSaleRecord srFetched = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(5L)).fetchSingle();                \n```", "```java\nsrFetched.setFiscalYear(2005);\n```", "```java\nsrFetched.changed(SALE.SALE_, true);\n```", "```java\n...\n```", "```java\nsrFetched.store(); // jOOQ render an UPDATE\n```", "```java\nsrFetched.setSaleId(…);\n```", "```java\nsrFetched.store(); // jOOQ render an INSERT\n```", "```java\nDSLContext derivedCtx = ctx.configuration().derive(\n```", "```java\n  new Settings().withUpdatablePrimaryKeys(true)).dsl();\n```", "```java\nSaleRecord sr = derivedCtx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(7L)).fetchSingle(); \n```", "```java\nsr.setSaleId(...);\n```", "```java\nsr.store(); // jOOQ render an UPDATE of primary key        \n```", "```java\n@GetMapping(\"/transactions\")\n```", "```java\npublic String loadAllBankTransactionOfCertainPayment(\n```", "```java\n             SessionStatus sessionStatus, Model model) {\n```", "```java\n  sessionStatus.setComplete();\n```", "```java\n  model.addAttribute(ALL_BANK_TRANSACTION_ATTR,\n```", "```java\n    classicModelsService\n```", "```java\n      .loadAllBankTransactionOfCertainPayment());\n```", "```java\n  return \"transactions\";\n```", "```java\n}\n```", "```java\npublic Result<BankTransactionRecord> \n```", "```java\n      fetchAllBankTransactionOfCertainPayment() {\n```", "```java\n   return ctx.selectFrom(BANK_TRANSACTION)\n```", "```java\n      .where(BANK_TRANSACTION.CUSTOMER_NUMBER.eq(333L)\n```", "```java\n      .and(BANK_TRANSACTION.CHECK_NUMBER.eq(\"NF959653\")))\n```", "```java\n      .fetch();\n```", "```java\n}\n```", "```java\n<tr th:each=\"t : ${all}\">\n```", "```java\n <td><span th:text=\"${t.transactionId}\">ID</span></td> \n```", "```java\n <td><span th:text=\"${t.bankName}\">Bank Name</span></td>\n```", "```java\n ...\n```", "```java\n <td><span th:text=\"${t.status}\">Status</span></td>   \n```", "```java\n</tr>\n```", "```java\n<a href=\"/newbanktransaction\">Insert new bank transaction</a>\n```", "```java\n@GetMapping(\"/newbanktransaction\")\n```", "```java\npublic String newBankTransaction(Model model) {\n```", "```java\nmodel.addAttribute(NEW_BANK_TRANSACTION_ATTR, \n```", "```java\n                        new BankTransactionRecord());\n```", "```java\n  return \"newtransaction\";\n```", "```java\n}\n```", "```java\n@PostMapping(\"/new\")\n```", "```java\npublic String newBankTransaction(\n```", "```java\n  @ModelAttribute BankTransactionRecord btr,\n```", "```java\n  RedirectAttributes redirectAttributes) {\n```", "```java\n  classicModelsService.newBankTransaction(btr);\n```", "```java\n  redirectAttributes.addFlashAttribute(\n```", "```java\n    INSERT_DELETE_OR_UPDATE_BANK_TRANSACTION_ATTR, btr);\n```", "```java\n  return \"redirect:success\";\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic int newBankTransaction(BankTransactionRecord btr) {\n```", "```java\n  ctx.attach(btr);\n```", "```java\n  return btr.insert();\n```", "```java\n}\n```", "```java\n@GetMapping(\"/editbankname/{id}\")\n```", "```java\npublic String loadBankTransaction(\n```", "```java\n       @PathVariable(name = \"id\") Long id, Model model) {\n```", "```java\nmodel.addAttribute(BANK_TRANSACTION_ATTR, \n```", "```java\n    classicModelsService.loadBankTransaction(id));\n```", "```java\n  return \"redirect:/editbankname\";\n```", "```java\n}\n```", "```java\npublic BankTransactionRecord fetchBankTransaction(Long id) {\n```", "```java\n  return ctx.selectFrom(BANK_TRANSACTION)\n```", "```java\n     .where(BANK_TRANSACTION.TRANSACTION_ID.eq(id))\n```", "```java\n     .fetchSingle();\n```", "```java\n}\n```", "```java\n@PostMapping(\"/name\")\n```", "```java\npublic String editBankName(\n```", "```java\n@ModelAttribute(BANK_TRANSACTION_ATTR) \n```", "```java\n                  BankTransactionRecord btr) {\n```", "```java\n   return \"redirect:editbankiban\";\n```", "```java\n}\n```", "```java\n@PostMapping(\"/iban\")\n```", "```java\npublic String editBankIban(\n```", "```java\n   @ModelAttribute(BANK_TRANSACTION_ATTR)  \n```", "```java\n      BankTransactionRecord btr) {\n```", "```java\n   return \"redirect:editcardtype\";\n```", "```java\n}\n```", "```java\n@PostMapping(\"/cardtype\")\n```", "```java\npublic String editCardType(\n```", "```java\n@ModelAttribute(BANK_TRANSACTION_ATTR) \n```", "```java\n      BankTransactionRecord btr) {\n```", "```java\n   return \"redirect:editbanktransfer\";\n```", "```java\n}\n```", "```java\n@PostMapping(\"/transfer\")\n```", "```java\npublic String updateBankTransfer(\n```", "```java\n@ModelAttribute(BANK_TRANSACTION_ATTR) \n```", "```java\n    BankTransactionRecord btr, SessionStatus sessionStatus,\n```", "```java\n    RedirectAttributes redirectAttributes) {\n```", "```java\n  classicModelsService.updateBankTransaction(btr);\n```", "```java\n  redirectAttributes.addFlashAttribute(\n```", "```java\n    INSERT_DELETE_OR_UPDATE_BANK_TRANSACTION_ATTR, btr);\n```", "```java\n  sessionStatus.setComplete();\n```", "```java\n  return \"redirect:success\";\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic int updateBankTransaction(BankTransactionRecord btr) {\n```", "```java\n  return btr.update();\n```", "```java\n}\n```", "```java\n@GetMapping(\"/reset/{page}\")\n```", "```java\n    public String reset(\n```", "```java\n    @PathVariable(name = \"page\") String page, Model model) {\n```", "```java\n  if (model.containsAttribute(BANK_TRANSACTION_ATTR)) {\n```", "```java\n   ((BankTransactionRecord) model.getAttribute(\n```", "```java\n     BANK_TRANSACTION_ATTR)).reset();\n```", "```java\n  }\n```", "```java\n  return \"redirect:/\" + page;\n```", "```java\n}\n```", "```java\n@GetMapping(\"/delete\")\n```", "```java\npublic String deleteBankTransaction(\n```", "```java\n  SessionStatus sessionStatus, Model model,\n```", "```java\n          RedirectAttributes redirectAttributes) {\n```", "```java\n  ...\n```", "```java\nBankTransactionRecord btr = (BankTransactionRecord) \n```", "```java\n    model.getAttribute(BANK_TRANSACTION_ATTR);\n```", "```java\n  classicModelsService.deleteBankTransaction(btr);\n```", "```java\n  sessionStatus.setComplete();\n```", "```java\n  ...\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic int deleteBankTransaction(BankTransactionRecord btr) {\n```", "```java\n  return btr.delete();\n```", "```java\n}\n```", "```java\n@PostMapping(\"/merge\")\n```", "```java\npublic String mergePayment(PaymentRecord pr) {\n```", "```java\n  classicModelsService.mergePayment(pr);\n```", "```java\n  return \"redirect:payments\";\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic int mergePayment(PaymentRecord pr) {\n```", "```java\n   ctx.attach(pr);               \n```", "```java\n   return pr.merge();\n```", "```java\n}\n```", "```java\npublic PaymentRecord fetchPayment(Long nr, String ch) {\n```", "```java\n  return ctx.selectFrom(PAYMENT)\n```", "```java\n    .where(row(PAYMENT.CUSTOMER_NUMBER, PAYMENT.CHECK_NUMBER)\n```", "```java\n    .eq(row(nr, ch)))\n```", "```java\n    .fetchSingle();\n```", "```java\n}\n```", "```java\n@PostMapping(\"/store\")\n```", "```java\npublic String storePayment(SessionStatus sessionStatus,\n```", "```java\n            @ModelAttribute(PAYMENT_ATTR) PaymentRecord pr) {\n```", "```java\n   pr.setCachingDate(LocalDateTime.now());\n```", "```java\n   classicModelsService.storePayment(pr);\n```", "```java\n   sessionStatus.setComplete();\n```", "```java\n   return \"redirect:payments\";\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic int storePayment(PaymentRecord pr) {\n```", "```java\n  ctx.attach(pr);\n```", "```java\n  return pr.store();\n```", "```java\n}\n```", "```java\npublic OfficeRecord fetchOfficeOfDepartment(\n```", "```java\n     DepartmentRecord dr) {\n```", "```java\n  return dr.fetchParent(Keys.DEPARTMENT_OFFICE_FK);\n```", "```java\n  // or, Keys.DEPARTMENT_OFFICE_FK.fetchParent(dr);\n```", "```java\n}\n```", "```java\nSELECT \n```", "```java\n  `classicmodels`.`office`.`office_code`, \n```", "```java\n  ...\n```", "```java\n  `classicmodels`.`office`.`location` \n```", "```java\nFROM \n```", "```java\n  `classicmodels`.`office` \n```", "```java\nWHERE \n```", "```java\n  `classicmodels`.`office`.`office_code` in (?)\n```", "```java\nTable<OfficeRecord> tor = \n```", "```java\n   dr.parent(Keys.DEPARTMENT_OFFICE_FK);\n```", "```java\nTable<OfficeRecord> tor = \n```", "```java\n   Keys.DEPARTMENT_OFFICE_FK.parent(dr);\n```", "```java\npublic Result<EmployeeRecord>\n```", "```java\n         fetchEmployeesOfOffice(OfficeRecord or) {\n```", "```java\n  return or.fetchChildren(Keys.EMPLOYEE_OFFICE_FK);\n```", "```java\n  // or, Keys.EMPLOYEE_OFFICE_FK.fetchChildren(or);\n```", "```java\n}\n```", "```java\nSELECT \n```", "```java\n  `classicmodels`.`employee`.`employee_number`, \n```", "```java\n  ...\n```", "```java\n  `classicmodels`.`employee`.`monthly_bonus` \n```", "```java\nFROM \n```", "```java\n  `classicmodels`.`employee` \n```", "```java\nWHERE\n```", "```java\n  `classicmodels`.`employee`.`office_code` in (?)\n```", "```java\nTable<EmployeeRecord> ter = \n```", "```java\n   or.children(Keys.EMPLOYEE_OFFICE_FK);\n```", "```java\nTable<EmployeeRecord> ter = \n```", "```java\n   Keys.EMPLOYEE_OFFICE_FK.children(or);\n```", "```java\npublic CustomerdetailRecord    \n```", "```java\n      fetchCustomerdetailOfCustomer(CustomerRecord cr) {\n```", "```java\n  return cr.fetchChild(Keys.CUSTOMERDETAIL_CUSTOMER_FK);\n```", "```java\n}\n```", "```java\nSELECT \n```", "```java\n  `classicmodels`.`customerdetail`.`customer_number`, \n```", "```java\n  ...\n```", "```java\n  `classicmodels`.`customerdetail`.`country` \n```", "```java\nFROM \n```", "```java\n  `classicmodels`.`customerdetail` \n```", "```java\nWHERE \n```", "```java\n  `classicmodels`.`customerdetail`.`customer_number` in (?)\n```", "```java\nfor (SaleRecord sale : ctx.fetch(SALE, SALE.SALE_.lt(2000d))){\n```", "```java\n  if (\"Sales Rep\".equals(sale.fetchParent(\n```", "```java\n            Keys.SALE_EMPLOYEE_FK).getJobTitle())) {\n```", "```java\n      sale.delete();\n```", "```java\n  }\n```", "```java\n}\n```", "```java\nList<SaleRecord> sales \n```", "```java\n    = ctx.fetch(SALE, SALE.SALE_.lt(2000d));\n```", "```java\nList<EmployeeRecord> employees \n```", "```java\n    = Keys.SALE_EMPLOYEE_FK.fetchParents(sales);\n```", "```java\nfor (SaleRecord sale : sales) {\n```", "```java\n  for (EmployeeRecord employee : employees) {\n```", "```java\n    if (Objects.equals(sale.getEmployeeNumber(), \n```", "```java\n       employee.getEmployeeNumber()) && \"Sales Rep\".equals(\n```", "```java\n         employee.getJobTitle())) {\n```", "```java\n       sale.delete();\n```", "```java\n       break;\n```", "```java\n    }\n```", "```java\n  }\n```", "```java\n}\n```", "```java\nTable<EmployeeRecord> employeesTable \n```", "```java\n   = Keys.SALE_EMPLOYEE_FK.parents(sales);\n```", "```java\nctx.transaction(configuration -> {\n```", "```java\n  DSL.using(configuration)...\n```", "```java\n  // or, configuration.dsl()...\n```", "```java\n}\n```", "```java\nvar result = ctx.transactionResult(configuration -> {\n```", "```java\n  return DSL.using(configuration)...\n```", "```java\n  // or, return configuration.dsl()...\n```", "```java\n}\n```", "```java\n// affects ctx\n```", "```java\nctx.configuration().set((TransactionProvider) null); \n```", "```java\n// create derived DSLContext\n```", "```java\nctx.configuration().derive((TransactionProvider) null).dsl();\n```", "```java\nctx.transaction(configuration -> {\n```", "```java\n  DSL.using(configuration).delete(SALE) \n```", "```java\n    .where(SALE.SALE_ID.eq(1L)).execute();\n```", "```java\n  DSL.using(configuration).insertInto(TOKEN) \n```", "```java\n    .set(TOKEN.SALE_ID, 1L).set(TOKEN.AMOUNT, 1000d)\n```", "```java\n    .execute();\n```", "```java\n  // at this point transaction should commit, but the error  \n```", "```java\n  // caused by the previous INSERT will lead to rollback\n```", "```java\n});\n```", "```java\nctx.transaction(configuration -> {\n```", "```java\n  try {\n```", "```java\n      // same DMLs as in the previous example\n```", "```java\n  } catch (RuntimeException e) {\n```", "```java\n    System.out.println(\"I've decided that this error \n```", "```java\n                       doesn't require rollback ...\");\n```", "```java\n  }\n```", "```java\n});\n```", "```java\npublic void nestedJOOQTransaction() {\n```", "```java\n  ctx.transaction(outer -> { \n```", "```java\n    DSL.using(outer).delete(SALE) // or, outer.dsl()\n```", "```java\n       .where(SALE.SALE_ID.eq(2L)).execute();\n```", "```java\n    // savepoint created\n```", "```java\n    DSL.using(outer).transaction(inner -> {\n```", "```java\n      DSL.using(inner).insertInto(TOKEN) // or, inner.dsl()\n```", "```java\n        .set(TOKEN.SALE_ID, 1L)                                \n```", "```java\n        .set(TOKEN.AMOUNT, 1000d).execute();\n```", "```java\n    });\n```", "```java\n  });\n```", "```java\n}\n```", "```java\nctx.transaction(outer -> {\n```", "```java\n  try {\n```", "```java\n    DSL.using(outer).delete(SALE)\n```", "```java\n       .where(SALE.SALE_ID.eq(1L)).execute();\n```", "```java\n        // savepoint created\n```", "```java\n        try {\n```", "```java\n          DSL.using(outer)\n```", "```java\n             .transaction(inner -> {\n```", "```java\n               DSL.using(inner).insertInto(TOKEN)\n```", "```java\n                  .set(TOKEN.SALE_ID, 1L)         \n```", "```java\n                  .set(TOKEN.AMOUNT, 1000d).execute();\n```", "```java\n               });\n```", "```java\n         } catch (RuntimeException e) { throw e; }\n```", "```java\n  } catch (RuntimeException e) {\n```", "```java\n    System.out.println(\"I've decided that this error doesn't \n```", "```java\n         require rollback of the outer transaction ...\");\n```", "```java\n    // throw e; // rollback\n```", "```java\n  }\n```", "```java\n});\n```", "```java\n@Configuration\n```", "```java\npublic class JooqConfig {\n```", "```java\n  @Bean\n```", "```java\n  @ConditionalOnMissingBean(org.jooq.Configuration.class)\n```", "```java\n  public DefaultConfiguration jooqConfiguration(\n```", "```java\n          JooqProperties properties, DataSource ds) {\n```", "```java\n    final DefaultConfiguration defaultConfig = \n```", "```java\n      new DefaultConfiguration();\n```", "```java\n    final ConnectionProvider cp = \n```", "```java\n      new DataSourceConnectionProvider(ds);\n```", "```java\n    defaultConfig\n```", "```java\n     .set(properties.determineSqlDialect(ds))\n```", "```java\n     .set(new ThreadLocalTransactionProvider(cp, true));\n```", "```java\n    /* or, as a derived configuration\n```", "```java\n    final org.jooq.Configuration derivedConfig = defaultConfig\n```", "```java\n      .derive(properties.determineSqlDialect(ds))\n```", "```java\n      .derive(new ThreadLocalTransactionProvider(cp, true));\n```", "```java\n    */\n```", "```java\n    return defaultConfig;\n```", "```java\n  }\n```", "```java\n}\n```", "```java\n@Configuration\n```", "```java\npublic class JooqConfig \n```", "```java\n  implements DefaultConfigurationCustomizer {\n```", "```java\n  private final DataSource ds;\n```", "```java\n  public JooqConfig(DataSource ds) {\n```", "```java\n    this.ds = ds;\n```", "```java\n  }\n```", "```java\n  @Override\n```", "```java\n  public void customize(DefaultConfiguration configuration) {\n```", "```java\n    configuration.set(new ThreadLocalTransactionProvider(\n```", "```java\n            new DataSourceConnectionProvider(ds), true));\n```", "```java\n  }\n```", "```java\n}\n```", "```java\n// this transaction commits\n```", "```java\n@Async\n```", "```java\npublic CompletableFuture<Integer> \n```", "```java\n             executeFirstJOOQTransaction() {\n```", "```java\n  return ctx.transactionResultAsync(configuration -> {\n```", "```java\n    int result = 0;\n```", "```java\n    result += DSL.using(configuration).insertInto(TOKEN)\n```", "```java\n      .set(TOKEN.SALE_ID, 1L).set(TOKEN.AMOUNT, 500d)\n```", "```java\n      .execute();\n```", "```java\n    result += DSL.using(configuration).insertInto(TOKEN)\n```", "```java\n      .set(TOKEN.SALE_ID, 1L).set(TOKEN.AMOUNT, 1000d)\n```", "```java\n      .execute();\n```", "```java\n    return result;\n```", "```java\n  }).toCompletableFuture();\n```", "```java\n}\n```", "```java\n// this transaction is roll backed\n```", "```java\n@Async\n```", "```java\npublic CompletableFuture<Integer> \n```", "```java\n          executeSecondJOOQTransaction() {\n```", "```java\n  return ctx.transactionResultAsync(configuration -> {\n```", "```java\n    int result = 0;\n```", "```java\n    result += DSL.using(configuration).delete(SALE)\n```", "```java\n      .where(SALE.SALE_ID.eq(2L)).execute();\n```", "```java\n    result += DSL.using(configuration).insertInto(TOKEN)\n```", "```java\n      .set(TOKEN.SALE_ID, 2L).set(TOKEN.AMOUNT, 1000d)\n```", "```java\n      .execute();\n```", "```java\n    return result;\n```", "```java\n  }).toCompletableFuture();\n```", "```java\n}\n```", "```java\npublic void fetchWithNoTransaction() {\n```", "```java\n   ctx.selectFrom(SALE).fetchAny();\n```", "```java\n   ctx.selectFrom(TOKEN).fetchAny();          \n```", "```java\n}\n```", "```java\n@Transactional(readOnly=true)\n```", "```java\npublic void fetchWithTransaction() {\n```", "```java\n   ctx.selectFrom(SALE).fetchAny();\n```", "```java\n   ctx.selectFrom(TOKEN).fetchAny();          \n```", "```java\n}\n```", "```java\npublic void fetchWithTransaction() {\n```", "```java\n  ctx.transaction(configuration -> {\n```", "```java\n    DSL.using(configuration).selectFrom(SALE).fetchAny();\n```", "```java\n    DSL.using(configuration).selectFrom(TOKEN).fetchAny();\n```", "```java\n    // Implicit commit executed here\n```", "```java\n  });\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic void fetchAndStreamWithTransactional() {\n```", "```java\n  ctx.update(EMPLOYEE).set(EMPLOYEE.SALARY, \n```", "```java\n    EMPLOYEE.SALARY.plus(1000)).execute();   \n```", "```java\n  ctx.selectFrom(EMPLOYEE)\n```", "```java\n     .fetch() // jOOQ fetches the whole result set into memory \n```", "```java\n              // via the connection opened by @Transactional\n```", "```java\n     .stream()// stream over the in-memory result set \n```", "```java\n              // (database connection is active)     \n```", "```java\n     .map()   // ... more time-consuming pipeline operations \n```", "```java\n              // holds the transaction open\n```", "```java\n     .forEach(System.out::println);\n```", "```java\n}\n```", "```java\npublic void fetchAndStreamWithJOOQTransaction() {\n```", "```java\n  Result<EmployeeRecord> result =   \n```", "```java\n    ctx.transactionResult(configuration -> {\n```", "```java\n      DSL.using(configuration).update(EMPLOYEE)\n```", "```java\n         .set(EMPLOYEE.SALARY, EMPLOYEE.SALARY.plus(1000))\n```", "```java\n         .execute();   \n```", "```java\n      return DSL.using(configuration).selectFrom(EMPLOYEE)\n```", "```java\n                .fetch();\n```", "```java\n  });\n```", "```java\n  result.stream() // stream over the in-memory result set \n```", "```java\n                  // (database connection is closed)\n```", "```java\n        .map()    // ... more time-consuming pipeline \n```", "```java\n                  // operations, but the transaction is closed\n```", "```java\n        .forEach(System.out::println);\n```", "```java\n}\n```", "```java\nFlux<?> flux = Flux.from(\n```", "```java\n ctx.transactionPublisher(outer -> Flux.from(\n```", "```java\n  DSL.using(outer).delete(SALE) // or, outer.dsl()\n```", "```java\n                 .where(SALE.SALE_ID.eq(2L)))\n```", "```java\n     .thenMany(Flux.from(\n```", "```java\n     DSL.using(outer).transactionPublisher( // or, outer.dsl()\n```", "```java\n      inner -> Flux.from(\n```", "```java\n      DSL.using(inner).insertInto(TOKEN) // or, inner.dsl()\n```", "```java\n                      .set(TOKEN.SALE_ID, 1L)\n```", "```java\n                      .set(TOKEN.AMOUNT, 1000d)\n```", "```java\n      )))\n```", "```java\n  )));\n```", "```java\nflux.subscribe();\n```", "```java\n@Configuration\n```", "```java\npublic class JooqSetting {\n```", "```java\n  @Bean\n```", "```java\n  public Settings jooqSettings() {\n```", "```java\n    return new Settings()\n```", "```java\n      .withExecuteWithOptimisticLocking(true);             \n```", "```java\n  }\n```", "```java\n}\n```", "```java\nSELECT \n```", "```java\n  `classicmodels`.`payment`.`customer_number`, \n```", "```java\n  ... \n```", "```java\nFROM `classicmodels`.`payment` WHERE \n```", "```java\n  (`classicmodels`.`payment`.`customer_number` = ? AND \n```", "```java\n  `classicmodels`.`payment`.`check_number` = ?) FOR UPDATE\n```", "```java\nCREATE TABLE `payment` (\n```", "```java\n  `customer_number` Bigint NOT NULL,\n```", "```java\n  `check_number` Varchar(50) NOT NULL,\n```", "```java\n  ...\n```", "```java\n  `version` INT NOT NULL DEFAULT 0, \n```", "```java\n  `modified` TIMESTAMP NOT NULL DEFAULT NOW(),\n```", "```java\n  CONSTRAINT `payment_pk` \n```", "```java\n    PRIMARY KEY (`customer_number`,`check_number`),\n```", "```java\n  ...\n```", "```java\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n```", "```java\n<database>\n```", "```java\n  <!-- numeric column for versioned optimistic locking -->\n```", "```java\n  <recordVersionFields>version</recordVersionFields>\n```", "```java\n  <!-- timestamp column for versioned optimistic locking -->\n```", "```java\n  <recordTimestampFields>modified</recordTimestampFields>\n```", "```java\n</database>\n```", "```java\n@Bean // VERSION field (numeric)\n```", "```java\npublic Settings jooqSettings() {\n```", "```java\n  return new Settings()       \n```", "```java\n   .withUpdateRecordVersion(true) // it can be omitted\n```", "```java\n   .withExecuteWithOptimisticLocking(true)\n```", "```java\n   .withExecuteWithOptimisticLockingExcludeUnversioned(true);\n```", "```java\n}\n```", "```java\n@Bean // TIMESTAMP field (timestamp)\n```", "```java\npublic Settings jooqSettings() {\n```", "```java\n  return new Settings()       \n```", "```java\n   .withUpdateRecordTimestamp(true) // it can be omitted \n```", "```java\n   .withExecuteWithOptimisticLocking(true)\n```", "```java\n   .withExecuteWithOptimisticLockingExcludeUnversioned(true); \n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\npublic int storePayment(PaymentRecord pr) {\n```", "```java\n  ctx.attach(pr);       \n```", "```java\n  return pr.store();\n```", "```java\n}\n```", "```java\nCREATE TABLE `payment` (\n```", "```java\n   ...\n```", "```java\n   `version` INT NOT NULL DEFAULT 0, \n```", "```java\n   ...\n```", "```java\n}\n```", "```java\n<database> \n```", "```java\n  <recordVersionFields>version</recordVersionFields>\n```", "```java\n</database>\n```", "```java\n@Bean\n```", "```java\npublic Settings jooqSettings() {\n```", "```java\n return new Settings()                     \n```", "```java\n  .withExecuteWithOptimisticLocking(true)\n```", "```java\n  .withExecuteWithOptimisticLockingExcludeUnversioned(true); \n```", "```java\n}\n```", "```java\nUPDATE \n```", "```java\n  `classicmodels`.`payment` \n```", "```java\nSET \n```", "```java\n  `classicmodels`.`payment`.`invoice_amount` = ?, \n```", "```java\n  `classicmodels`.`payment`.`version` = ? \n```", "```java\nWHERE \n```", "```java\n  (\n```", "```java\n    `classicmodels`.`payment`.`customer_number` = ? \n```", "```java\n    and `classicmodels`.`payment`.`check_number` = ? \n```", "```java\n    and `classicmodels`.`payment`.`version` = ?\n```", "```java\n  )\n```", "```java\n@PostMapping(\"/store\")\n```", "```java\npublic String storePayment(SessionStatus sessionStatus,    \n```", "```java\n  RedirectAttributes redirectAttributes,\n```", "```java\n  @ModelAttribute(PAYMENT_ATTR) PaymentRecord pr, \n```", "```java\n  BindingResult bindingResult) {\n```", "```java\n  if (!bindingResult.hasErrors()) {\n```", "```java\n    try {\n```", "```java\n        classicModelsService.storePayment(pr);\n```", "```java\n        sessionStatus.setComplete();\n```", "```java\n    } catch (org.jooq.exception.DataChangedException e) {\n```", "```java\n        bindingResult.reject(\"\", \n```", "```java\n          \"Another user updated the data.\");\n```", "```java\n    }\n```", "```java\n  }\n```", "```java\n  if (bindingResult.hasErrors()) {\n```", "```java\n      redirectAttributes.addFlashAttribute(\n```", "```java\n        BINDING_RESULT, bindingResult);            \n```", "```java\n  }\n```", "```java\n  return \"redirect:payments\";\n```", "```java\n}\n```", "```java\n@GetMapping(value = \"/refresh\")\n```", "```java\npublic String refreshPayment(Model model) {\n```", "```java\n  if (model.containsAttribute(PAYMENT_ATTR)) {\n```", "```java\n         classicModelsService.refreshPayment(\n```", "```java\n     (PaymentRecord) model.getAttribute(PAYMENT_ATTR));\n```", "```java\n  } \n```", "```java\n  return \"redirect:payments\";\n```", "```java\n}\n```", "```java\npublic void refreshPayment(PaymentRecord pr) {\n```", "```java\n  pr.refresh();\n```", "```java\n}\n```", "```java\n@Transactional\n```", "```java\n@Retryable(\n```", "```java\n  value = org.jooq.exception.DataChangedException.class,\n```", "```java\n  maxAttempts = 2, backoff = @Backoff(delay = 100))\n```", "```java\npublic int storePayment(PaymentRecord pr) {\n```", "```java\n  int stored = 0;\n```", "```java\n  try {\n```", "```java\n      ctx.attach(pr);\n```", "```java\n      stored = pr.store();\n```", "```java\n  } catch (org.jooq.exception.DataChangedException e) {\n```", "```java\n    BigDecimal invoiceAmount = pr.getInvoiceAmount();\n```", "```java\n    pr.refresh();\n```", "```java\n    if (invoiceAmount.doubleValue() > \n```", "```java\n           pr.getInvoiceAmount().doubleValue()) {\n```", "```java\n      pr.setInvoiceAmount(invoiceAmount);\n```", "```java\n      throw e;\n```", "```java\n    }\n```", "```java\n    throw new OptimisticLockingRetryFailed(e.getMessage());\n```", "```java\n  }\n```", "```java\n  return stored;\n```", "```java\n}\n```", "```java\nctx.selectFrom(PRODUCTLINE)\n```", "```java\n   .where(PRODUCTLINE.PRODUCT_LINE.eq(\"Classic Cars\"))\n```", "```java\n   .forUpdate()\n```", "```java\n   .fetchSingle();\n```", "```java\nctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE, \n```", "```java\n     PRODUCT.PRODUCT_LINE, PRODUCT.PRODUCT_NAME, \n```", "```java\n     PRODUCT.PRODUCT_SCALE)\n```", "```java\n   .from(PRODUCTLINE).join(PRODUCT).onKey()\n```", "```java\n   // lock only rows from PRODUCTLINE\n```", "```java\n   .forUpdate().of(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE)\n```", "```java\n   .fetch();\n```", "```java\nctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE, \n```", "```java\n           PRODUCT.PRODUCT_LINE, PRODUCT.PRODUCT_NAME, \n```", "```java\n           PRODUCT.PRODUCT_SCALE)\n```", "```java\n   .from(PRODUCTLINE).join(PRODUCT).onKey()\n```", "```java\n   // lock only rows from PRODUCT\n```", "```java\n   .forUpdate().of(PRODUCT.PRODUCT_NAME)\n```", "```java\n   .fetch();\n```", "```java\nctx.selectFrom(PRODUCT)\n```", "```java\n   .forUpdate() \n```", "```java\n   .noWait() // acquire the lock or fails immediately\n```", "```java\n   .fetch();\n```", "```java\nctx.selectFrom(PRODUCT)\n```", "```java\n   .forUpdate()                           \n```", "```java\n   .wait(15) \n```", "```java\n   .fetch();\n```", "```java\nResult<ProductRecord> products = ctx.selectFrom(PRODUCT)\n```", "```java\n  .where(PRODUCT.PRODUCT_DESCRIPTION.eq(\"PENDING\"))\n```", "```java\n  .orderBy(PRODUCT.PRODUCT_ID).limit(3)\n```", "```java\n  .forUpdate()\n```", "```java\n  .skipLocked()\n```", "```java\n  .fetch();\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .forShare() \n```", "```java\n   .fetchSingle();\n```", "```java\nctx.insertInto(TOKEN)\n```", "```java\n   .set(TOKEN.SALE_ID, sr.getSaleId())\n```", "```java\n   .set(TOKEN.AMOUNT, 1200.5)                            \n```", "```java\n   .execute();\n```", "```java\nctx.update(SALE)\n```", "```java\n   .set(SALE.SALE_, SALE.SALE_.plus(1000))\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .execute();\n```", "```java\nctx.delete(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .execute();\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .forNoKeyUpdate()\n```", "```java\n   .fetchSingle();\n```", "```java\nctx.insertInto(TOKEN)\n```", "```java\n   .set(TOKEN.SALE_ID, sr.getSaleId())\n```", "```java\n   .set(TOKEN.AMOUNT, 1200.5)\n```", "```java\n   .execute();\n```", "```java\nctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .forKeyShare()\n```", "```java\n   .fetchSingle();\n```", "```java\nctx.selectFrom(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .forShare()\n```", "```java\n   .fetchSingle();\n```", "```java\nSaleRecord sr = ctx.selectFrom(SALE)\n```", "```java\n                   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n                   .forKeyShare()\n```", "```java\n                   .fetchSingle();\n```", "```java\nctx.insertInto(TOKEN)\n```", "```java\n   .set(TOKEN.SALE_ID, sr.getSaleId())\n```", "```java\n   .set(TOKEN.AMOUNT, 1200.5)                            \n```", "```java\n   .execute();\n```", "```java\nctx.update(SALE)\n```", "```java\n   .set(SALE.SALE_, SALE.SALE_.plus(1000))\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .execute();\n```", "```java\nctx.update(SALE)\n```", "```java\n   .set(SALE.SALE_ID, SALE.SALE_ID.plus(50))\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .execute(); \n```", "```java\nctx.delete(SALE)\n```", "```java\n   .where(SALE.SALE_ID.eq(2L))\n```", "```java\n   .execute();\n```"]