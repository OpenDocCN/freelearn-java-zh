- en: Java 9 Language Enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gained insight into some exciting new features contained
    in Java 9\. Our focus was on javac, the JDK libraries, and test suites. We learned
    about memory management improvements including memory allocation, heap optimizations,
    and enhanced garbage collection. We also covered changes to the compilation process,
    type testing, annotations, and runtime compiler tests.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers some changes in Java 9 that impact variable handlers, depreciation
    warnings, improvements on Project Coin changes implemented in Java 7, and import
    statement processing. These represent changes to the Java language itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover here are:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import statement depreciation warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Coin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import statement processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with variable handlers [JEP 193]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variable handlers are typed references to variables and are governed by the
    `java.lang.invoke.VarHandle` abstract class. The `VarHandle` method''s signature
    is polymorphic. This provides for great variability in both method signatures
    and return types. Here is a code sample demonstrating how a `VarHandle` might
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The aim of this JEP was to standardize the way in which methods of the following
    classes are invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.concurrent.atomic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.Unsafe`</li>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifically, methods that:'
  prefs: []
  type: TYPE_NORMAL
- en: accessed/mutated object fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: accessed/mutated elements of an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, this JEP resulted in two fence operations for memory ordering
    and object reachability. In the spirit of due diligence, special attention was
    given to ensure the JVM''s safety. It was important to ensure that memory errors
    did not result from these changes. Data integrity, usability, and, of course,
    performance were key components of the aforementioned due diligence and are explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety**: Corrupt memory states must not be possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data integrity**: Ensure access to an object''s field uses identical rules
    used by:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getfield` byte code'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putfield` byte code'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: The benchmark for usability was the `sun.misc.Unsafe` API. The
    goal was to make the new API easier to use than the benchmark.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: There could be no degradation of performance compared to the
    use of the `sun.misc.Unsafe` API. The goal was to outperform that API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, a fence operation is what javac does to force a constraint on memory
    in the form of a barrier instruction. These operations occur before and after
    the barrier instruction, essentially fencing them in.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the AtoMiC Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.concurrent.atomic` package is a collection of 12 sub-classes
    that support operations on single variables that are thread-safe and lock-free.
    In this context, thread-safe refers to code that accesses or mutates a shared
    single variable without impeding on other threads executing on the variable at
    the same time. This superclass was introduced in Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the 12 sub-classes in the AtoMiC Toolkit. The class names,
    as you would expect, are self-descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Atomic subclass** |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicBoolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicInteger` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicIntegerArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicLong` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicLongArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicLongFieldUpdater<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicMarkableReference<V>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicReference<V>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicReferenceArray<E>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicReferenceFieldUpdater<T,V>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.concurrent.atomic.AtomicStampedReference<V>` |'
  prefs: []
  type: TYPE_TB
- en: Volatile variables, fields, and array elements can be asynchronously modified
    by concurrent threads.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the `volatile` keyword is used to inform the javac utility to read
    the value, field, or array element from the main memory and not to cache them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet that demonstrates the use of the volatile keyword for
    an instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the sun.misc.Unsafe class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sun.misc.Unsafe` class, like other `sun` classes, is not officially documented
    or supported. It has been used to circumvent some of Java's built-in memory management
    safety features. While this can be viewed as a window to greater control and flexibility
    in our code, it is a terrible programming practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class had a single private constructor, so an instance of the class could
    not easily be instantiated. So, if we tried to instantiate an instance with `myUnsafe
    = new Unsafe()`, a `SecurityException` would be thrown in most circumstances.
    This somewhat unreachable class has over 100 methods that permitted operations
    on arrays, classes, and objects. Here is a brief sampling of those methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arrays** | **Classes** | **Objects** |'
  prefs: []
  type: TYPE_TB
- en: '| `arrayBaseOffset` | `defineAnonymousClass` | `allocateInstance` |'
  prefs: []
  type: TYPE_TB
- en: '| `arrayIndexScale` | `defineClass` | `objectFieldOffset` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ensureClassInitialized` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `staticFieldOffset` |  |'
  prefs: []
  type: TYPE_TB
- en: 'Here is a secondary grouping of the `sun.misc.Unsafe` class method for information,
    memory, and synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Information** | **Memory** | **Synchronization** |'
  prefs: []
  type: TYPE_TB
- en: '| `addressSize` | `allocateMemory` | `compareAndSwapInt` |'
  prefs: []
  type: TYPE_TB
- en: '| `pageSize` | `copyMemory` | `monitorEnter` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `freeMemory` | `monitorExit` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `getAddress` | `putOrderedEdit` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `getInt` | `tryMonitorEnter` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `putInt` |  |'
  prefs: []
  type: TYPE_TB
- en: The `sun.misc.Unsafe` class was earmarked for removal in Java 9\. There was
    actually some opposition to this decision in the programming industry. To put
    their concerns to rest, the class has been depreciated, but will not be completely
    removed. A special flag can be sent to the JVM to utilize the original API.
  prefs: []
  type: TYPE_NORMAL
- en: Eliding depreciation warnings on import statements [JEP 211]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the more simplistic JEPs for Java 9\. Quite often, when we compile
    our programs, we receive many warnings and errors. The compiler errors must be
    fixed as they are typically syntactical in nature. The warnings, on the other
    hand, should be reviewed and appropriately addressed. Some of the warning messages
    are ignored by developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This JEP provides slight relief in the number of warnings we receive. Specifically,
    depreciation warnings caused by import statements are no longer generated. Prior
    to Java 9, we could suppress deprecated warning messages with the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with Java 9, the compiler will suppress depreciated warnings if one or
    more of the following cases is true:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `@Deprecated` annotation is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `@SuppressWarnings` annotation is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the use of the warning-generating code and the declaration are within the
    ancestor class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the use of the warning-generating code is within an import statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth condition listed was an addition in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Milling Project Coin [JEP 213]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project Coin was a feature set of minor changes introduced in Java 7\. These
    changes are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings in `switch` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary integral literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using underscores in numeric literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing multi-catch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing for more precise re-throwing of exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic instance creation improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition of the `try-with-resources` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements to invoking `varargs` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detailed information can be found in the following Oracle presentation: [http://www.oracle.com/us/technologies/java/project-coin-428201.pdf](http://www.oracle.com/us/technologies/java/project-coin-428201.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: JEP 213 focused on improvements to Project Coin's enhancements. There were five
    such enhancements, each detailed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @SafeVarargs annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java 9, we can use the `@SafeVarargs` annotation with private instance methods.
    When we use this annotation, we are asserting that the method does not contain
    any harmful operations on the `varargs` passed as parameters to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for usage is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Use of the `@SafeVarargs` annotation is restricted to:'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The try-with-resource statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `try-with-resource` statement previously required a new variable to be
    declared for each resource in the statement when a final variable was used. Here
    is the syntax for the `try-with-resource` statement prior to Java 9 (in Java 7
    or 8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a code snippet using the preceding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with Java 9, the `try-with-resource` statement can manage final variables
    without requiring a new variable declaration. So, we can now rewrite the earlier
    code, as shown here in Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `xmlScanner` object reference is contained inside the `try-with-resource`
    statement block, which provides for automatic resource management. The resource
    will automatically be closed as soon as the `try-with-resource` statement block
    is exited.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use a `finally` block as part of the `try-with-resource` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using the diamond operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced in Java 9, the diamond operator can be used with anonymous classes
    if the inferred data type is denotable. When a data type is inferred, it suggests
    that the Java Compiler can determine the data types in a method's invocation.
    This includes the declaration and any included arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The diamond operator is the less-than and greater-than symbol pair (`<>` ).
    It is not new to Java 9; rather, the specific use with anonymous classes is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diamond operator was introduced in Java 7 and made instantiating generic
    classes simpler. Here is a pre-Java 7 example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in Java 7, we could rewrite it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem was that this method could not be used for anonymous classes. Here
    is an example in Java 8 that works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the preceding code works fine, when we change it to use the diamond operator,
    as shown here, a compiler error will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The error results from using the diamond operator with anonymous inner classes.
    Java 9 to the rescue. While the preceding code results in a compile time error
    in Java 8, it works fine in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Discontinuing use of the underscore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The underscore character ( `_` ) can no longer be used as a legal identifier
    name. Earlier attempts to remove the underscore in an identifier name were incomplete.
    The use of such would generate a combination of errors and warnings. With Java
    9, the warnings are now errors. Consider the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, in Java 8, will result in compiler warnings for `int _ =
    319;` and `if ( _ > 300 )` statements. The warning is *as of release 9, '_' is
    a keyword, and may not be used as an identifier*. So, in Java 9, you will not
    be able to use the underscore by itself as a legal identifier.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered bad programming practice to use identifier names that are not
    self-descriptive. So, the use of the underscore character by itself as an identifier
    name should not be a problematic change.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of private interface methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions were a big part of the Java 8 release. As a follow-up to
    that improvement, private methods in interfaces are now feasible. Previously,
    we could not share data between non-abstract methods of an interface. With Java
    9, this data sharing is possible. Interface methods can now be private. Let's
    look at some sample code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first code snippet is how we might code an interface in Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in Java 9, we can rewrite this code. As you can see next, the redundant
    code has been moved into a single private method called `characterTravel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Processing import statements correctly [JEP 216]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP 216 was issued as a fix to javac in regards to how import statements are
    processed. Prior to Java 9, there were instances where the order of import statements
    would impact if the source code was accepted or not.
  prefs: []
  type: TYPE_NORMAL
- en: When we develop applications in Java, we typically add import statements as
    we need them, resulting in an unordered list of import statements. IDEs do a great
    job of color-coding import statements that are not used, as well as informing
    us of import statements we need but that have not been included. It should not
    matter what order the import statements are in; there is no applicable hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: javac compiles classes in two primary steps. Specific to handling import statements,
    these steps are type resolution and member resolution. The type resolution consists
    of a review of the abstract syntax tree to identify declarations of classes and
    interfaces. The member resolution includes determining the class hierarchy and
    individual class variables and members.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Java 9, the order we list import statements in our classes and files will
    no longer impact the compilation process. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, type resolution occurs and results in the following
    realizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SamplePackage.OuterPackage` exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SamplePackage.OuterPackage.Nested` exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SamplePackage.Thing.Innner` exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is member resolution, and this is where the problem existed prior
    to Java 9\. Here is an overview of the sequential steps javac would use to conduct
    the member resolution for our sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: Resolution of `SamplePackage.OuterPackage` begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SamplePackage.OuterPackage.Nested` import is processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolution of the `SamplePackage.Outer.Nested` class begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inner interface is type checked, although, because it is not in scope at
    this point, inner cannot be resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolution of `SamplePackage.Thing` begins. This step includes importing all
    member types of `SamplePackage.Thing` into scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So the error occurs, in our example, because `Inner` is out of scope when resolution
    is attempted. If steps 4 and 5 were swapped, it would not have been a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to the problem, implemented in Java 9, was to break the member
    resolution steps into additional sub-steps. Here are those steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the import statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the hierarchy (class and interfaces).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze class headers and type parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered changes in Java 9 with regards to variable handlers
    and how they relate to the Atomic Toolkit. We also covered depreciation warnings
    and why they are now suppressed under specific circumstances. Five enhancements
    to changes introduced with Java 7 as part of Project Coin were also reviewed.
    Finally, we explored the improvements to import statement processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the structure of a Java module as specified
    by Project Jigsaw. We will take a deep dive into how Project Jigsaw is implemented
    as part of the Java platform. Code snippets from a sample e-commerce application
    are used throughout the chapter to demonstrate Java 9's modular system. Internal
    changes to the Java platform, in regards to the modular system, are also discussed.
  prefs: []
  type: TYPE_NORMAL
