- en: Building a Recommendation Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Millions of people order items from Amazon, where they save money and time.
    Recommendation algorithms are learned from customers, ordering preferences and
    bring them tailored you may also like recommendations, which are suggestions that
    help the customer update their cart or add interesting items to a wishlist for
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Building our own recommendations engine is a learning journey, where we hit
    several objectives along the way. At the problem formulation stage, we learn that
    recommendations are a collaborative filtering machine learning problem. We will
    take advantage of the Spark ML collaborative filtering algorithm to implement
    a recommendations engine that will generate ratings-based recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix is famous for its movies where you might enjoy the recommendation feature.
    Back in 2006, Netflix announced a prize of $1 million for the best enhancement
    over their aging **CineMatch** movie recommendation algorithm. This trendsetting competition
    spawned some of the best advances in machine learning. Working on a treasure trove
    of Netflix-released movie ratings, several crack teams of coders across the world
    battled for the top prize. Their goal—to build an algorithm that would predict
    user ratings (and hence better recommendations) up to 10% better than CineMatch.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, algorithms that make recommendations about **items** to users have
    come a long way. In this chapter, we set out to build a recommendation system
    with Scala and Apache Spark. What problem is this recommendation system going
    to solve? This and other questions are going to be answered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overarching learning objective of this chapter is to implement a recommendations
    engine. The following list is a comprehensive breakdown of individual learning
    objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the ropes of recommendations; recommendation systems are also known
    as **recommender systems**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning by example—understand (with screenshots) that Amazon's on-site recommendations
    are double-edged; they enhance customer satisfaction and ramp up sales revenue
    for Amazon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the plethora of product choices on offer on an online store, customers
    need all the help they can get. In this chapter, we will learn that recommendations
    can help people make these choices better and faster. This is good for customers
    and good for an online retailer that wants to convert prospects to clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next tangible learning objective is understanding which types of recommendations
    are implicit and which ones are not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the different kinds of recommendations and what they can do is
    good. We want to go further by learning what kinds of data do not need many details.
    Why? We want to set up datasets to model a recommendation system and match this
    dataset with a suitable algorithm that only needs a relationship between users
    and products. Nothing more, nothing less. Such an algorithm that fits the bill
    is the collaborative filtering algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What collaborative filtering can achieve is a work in progress. We will only
    learn more about the algorithm if we create custom datasets, build a collaborative
    filtering algorithm trained on the data, and see what the outcome is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn how to leverage the model-based collaborative filtering algorithm
    provided by Spark ML to build a recommendation system. We will learn that our
    implemented recommendation system, like others in its class, helps recommend products
    based on other customers preferences.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the *Problem overviews* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Problem overviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem overviews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will organize this section into overviews on select topics in a sequential
    order. Here are the topics we are going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations on Amazon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation systems, also known as recommender systems or recommendation
    engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Categorizing recommendations, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations for machine learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem formulation for explicit recommendations—the details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weapon sales leads and past sales data—the details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each topic will be reviewed with an explanation. We will start with the first
    topic—*Recommendations on Amazon*.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations on Amazon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic is presented in two parts—a *Brief overview* and a *Detailed overview*.
  prefs: []
  type: TYPE_NORMAL
- en: Brief overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic (details are laid out in the *Detailed overview* section) will lay
    out a roadmap, starting with a generalized understanding of recommendations from
    a non-machine learning perspective. We will show you what recommendations on Amazon
    look like with supporting illustrations. Not only that, we will highlight the
    fact that powerful machine learning algorithms power Amazon's recommendation systems
    to help users make products choices more easily.
  prefs: []
  type: TYPE_NORMAL
- en: The brief overview of this topic is behind us now. Its detailed overview follows.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build a recommendation system, the approach we must take focuses on understanding
    recommendations at a conceptual level. Examples of questions providing insights
    into recommendations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the recommendations?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are two important recommendation types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you are an online retailer looking to make a recommendation engine work
    for you in profitable ways, or someone exploring Spark ML's powerful recommendation
    algorithms from up close, this section will get you started.
  prefs: []
  type: TYPE_NORMAL
- en: We will then zero in on suitable machine learning techniques that we can leverage
    to build a recommendation system.
  prefs: []
  type: TYPE_NORMAL
- en: Jeff Bezos, multi-billion dollar business, [Amazon.com](http://Amazon.com),
    continues to report healthy sales numbers. Recommendation systems have always
    facilitated increasing streams of revenue for Amazon. These systems are backed
    by machine learning recommendation algorithms that help deliver customer-specific
    recommendations in real time. Without question, recommendations are an integral
    part of the Amazon landscape, playing a part in every aspect of a customer's purchase
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two categories of Amazon recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: On-site recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Off-site recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will only focus on on-site recommendations. Both on-site and off-site recommendations
    are big revenue earners for Amazon. Off-site recommendations are not covered in
    this chapter, however, the reader is encouraged to probe this side of Amazon's
    recommendations landscape. We have a question or two regarding off-site recommendations
    in the very last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On-site recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two main flavors of on-site recommendations are readily available by simply
    clicking on the link XYZ''s Amazon.com. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recommended for you, XYZ**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Recommended for you**,** **XYZ** link looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a9f5769-066b-4049-9138-054da4120fef.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe the Recommended for you, XYZ link
  prefs: []
  type: TYPE_NORMAL
- en: It contains Amazon's recommendations of products that it thinks you are likely
    to click on and buy. How did these recommendations come to you? This question
    has a two-part answer. First, recommendation algorithms tracked your browsing
    history. Secondly, this will take you to a page showing a list of products from
    various categories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Your recently viewed items and featured recommendations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another related example of recommendations is shown as follows. These recommendations,
    according to Amazon''s machine learning recommendations system, are in several
    categories, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inspired by your browsing history**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following page is reflective of the Inspired by your browsing history type
    of recommendations. We can see the power of Amazon''s recommendation systems at
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0ca6623-ec07-4e2c-a427-7a3681c16b36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe the items under Inspired by your browsing history link
  prefs: []
  type: TYPE_NORMAL
- en: '**Inspired by your purchases**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, the goal is simple—place a palette of products in front of the
    customer. This makes it easy for the customer to buy a different product, in this
    case, a book that is closely related to books falling under a category of interest.
    How did Amazon come up with the palette of books under the Inspired by your browsing
    history category? The recommendation system brings you products that you showed
    an interest in, at some point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61bce2f3-3e11-49ae-bfb1-1f8bc7a561f8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe the items under Inspired by your purchases link
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequently bought together**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type of recommendation is even more interesting. Say you click on the *Lego
    Mindstorms* book, the one featured in the following screenshot. We are taken to
    a new page that has **Frequently bought together** recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the Frequently bought together recommendation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5ee1f36-d976-49cd-a41b-a9ec8311184c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe the Frequently bought together link
  prefs: []
  type: TYPE_NORMAL
- en: '**Customers who also bought this item**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This type of recommendation is Amazon''s up-sell and cross-sell recommendation
    feature at work. The recommendation system is offering products that other customers
    bought together when they clicked on the *Lego Mindstorm* book you just clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6172b4f2-1ddf-4167-8ff5-5250c21d16ce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe the items under Customer who bought this item also bought link
  prefs: []
  type: TYPE_NORMAL
- en: The next *Problem overviews* section that follows is *Recommendations with machine
    learning*. Recommendations on Amazon are tied to powerful machine learning-based
    recommendation systems. The topic that follows is an attempt at describing a recommendation
    system from a high-level, non-machine learning perspective. Therefore, we want
    to know what a recommendations system looks like at a high-level and the different
    types of recommendations that such a system may or may not handle.
  prefs: []
  type: TYPE_NORMAL
- en: Attaining this level of understanding of recommendations, and recommendation
    systems will pave the way for a further exploration into the realm of recommendations
    as a problem in some subset of the machine learning space.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the flavors of recommendation share the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer satisfaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing sales revenue for Amazon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take up each recommendation flavor in turn. We will take up the most
    important on-site recommendation first, which is the **Recommended for you, XYZ**
    page.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we will step into the next topic, *Recommendation systems*.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous overview topic, we explored the salient aspects of recommendation
    and recommendation systems at Amazon. Let's attempt to bring some of that together
    and put together a definition of recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems can be defined as software applications that draw out
    and learn from data like such as preferences, their actions (clicks, for example),
    browsing history, and generated recommendations, which are products that the system
    determines are appealing to the user in the immediate future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is representative of a typical recommendation system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e61fff20-b59d-49d3-9a25-0980d2c2d1de.png)'
  prefs: []
  type: TYPE_IMG
- en: Recommendation system
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, can be thought of as a recommendation ecosystem,
    where the recommendation system is at the heart of it. This system needs three
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Users**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Products**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactions between users and products where transactions contain feedback
    from users about products**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transaction can be thought of in terms of the following action—a user provides
    a rating for a product. That is not all, though. The nature of the transaction
    implies that the user is providing feedback about the product(s). This explains
    the solid arrow starting from the **Users** box and extending into the **Products**
    box. As is evident from the diagram, the **Recommendations system** generates
    a recommendation after collecting all of the user-product interactions, that is,
    feedback data.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of transactions, which brings us to look at the different
    types of recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Categorizing recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic will draw on from the previous topic. In particular, we made more
    than a mention of user-product interactions or feedback data. Indeed, there can
    be two types of such interactions. User feedback is a better term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the types of user feedback, we can identify two types of recommendations,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type of recommendation follows. We will first explain recommendations using
    feedback of the implicit kind.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good example of such data is implicit information, such as user preferences,
    their clicks, browsing history, purchase history, search terms, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario represents an example of an implicit feedback-based recommendation
    system at work. The key characteristic of such a system is this—what did the user
    do? Some examples of implicit user feedback, in reference to a user on Amazon,
    is—what did the user buy? What book did they click on? What was their search phrase?
    All of these questions bear answers that reflect on a user's **behavior**. That
    said, we will get right down to a problem formulation phase, where we will document
    what is needed to build a recommendation problem with collaborative filtering.
    Whether this recommendation system is implicit or explicit will be decided when
    we get to that point.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a collaborative filtering problem that requires explicit data to model
    the relationship between each user (customer) and product (item). A good example
    of such data is an explicit rating.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations for machine learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the role played by recommendations at Amazon. This gives us a good
    idea of what recommendations are, and what recommendation systems are, from a
    layperson's point of view. We provided examples for each flavor of recommendations.
    Machine learning algorithms generated these Amazon recommendations, and that is
    the common denominator here.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, this topic is presented with the clear purpose of explaining
    the role played by machine learning in the context of recommendations. As always,
    this topic is approached in two parts: a brief overview part giving a summarized
    view of what to expect from the topic, and a detailed overview part. Here is the
    brief overview.'
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recommendations are a collaborative filtering problem in the machine learning
    space. Two underlying principles define how collaborative filtering algorithms
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filtering part is associated with the act of recommending. The algorithm
    makes recommendations happen by ingesting preferences information from many users. A
    simple example will go a long way in illustrating how collaborative filtering
    algorithms work. Imagine that our algorithm is working off of a pool of three
    users (countries) *U1*, *U2*, and *U3*. However trivial this case may be, it will
    explain how collaborative filtering algorithms work. Say, at a recent global air
    show, countries looking for new fighter aircraft were asked to provide ratings
    for three front-line fighter aircraft. The **Rafaele** is a French fighter. The
    **SU-35** is Russian and the **F-35** is American, and arguably the world's foremost
    air-superiority fighter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aircraft-countries tables are listed as follows, which is a recommendation
    algorithm based on collaborative filtering and a user-product matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20ebd7bd-1129-40ff-8920-e4a5da7230ca.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User-product matrix
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the preceding table, each country rated a certain aircraft in slightly
    different ways. India gave all three fighter aircraft reasonably good ratings,
    with the Flanker receiving the highest rating. The second country, Turkey, assigned
    good ratings only to the Rafaele and the F-35, and no rating at all for the SU-35\.
    It is assumed that when no rating is provided that that country received a negative
    rating of –1\. Lastly, Saudi Arabia liked the Rafaele and F-35, whereas they did
    not have anything to say about the SU-35\. There are empty squares in the matrix.
    They are left empty for a reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a collaborative algorithm called **CF**. We want CF to work
    on this matrix with a plan. The first part of the plan is to tell the algorithm
    to find out which users like the same products. The algorithm will get to work
    and make the following observations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'User U1 (India) liked the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product 1 (Rafaele)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product 2 (Flanker)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product 3 (F-35)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User U2 (Turkey) liked the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product 1 (Rafaele)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product 3 (F-35)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User U3 (Saudi Arabia) liked the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product 1 (Rafaele)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithm has a greater mandate. It needs to look closer at the matrix and
    make a recommendation for Saudi Arabia regarding an aircraft.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collaborative filtering algorithm comes up with a recommendation for Saudi
    Arabia with the following reasoning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'India likes all three aircraft (the Rafaele, the Flanker, and the F-35) while
    Turkey like two (the Rafaele and the F-35). Countries that liked the Rafaele **ALSO**
    liked the F-35\. Note the capitalized word ALSO. Based on India and Turkey having
    similar likes, the algorithm decides that Saudi Arabia will like what India and
    Turkey liked—in this case, the F-35. To make sense of the final recommendation,
    we will draw a Venn diagram-like structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69c584e6-1765-45d2-92e8-6c6881abf1e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Venn diagram
  prefs: []
  type: TYPE_NORMAL
- en: We just demonstrated what recommendations can do for us. What we have done so
    far is a step in the right direction regarding implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have not said yet what kind of data that's available in these datasets would
    either qualify them as explicit or implicit. Data in these datasets describe interactions
    between users and products. We have seen evidence of those interactions from the
    preceding discussion. We also went so far as to make a recommendation for Saudi
    Arabia. We predicted what weapons system Saudi Arabia is likely to buy in the
    future. The user-product matrix was our go-to resource for arriving at this recommendation
    for Saudi Arabia. This matrix boasted of one feature—a user-product interaction.
    This is a hard number, and a rating, which makes this data explicit.
  prefs: []
  type: TYPE_NORMAL
- en: This is a collaborative filtering problem that requires implicit data to model
    the relationship between each user (customer) and product (item).
  prefs: []
  type: TYPE_NORMAL
- en: It's time to move on to the next topic, which happens to be a brief overview
    of the formulation of an explicit recommendations problem.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations problem formulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic, as its title suggests, will provide a (recommendation) problem formulation.
    In other words, it would build the contours of a recommendation system based on explicit
    (user) feedback.
  prefs: []
  type: TYPE_NORMAL
- en: The problem formulation topic represents a critical stage in the implementation
    of one type of recommendation system. Coming up next is a topic that deals with
    weapons sales lead data and past weapons sales data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking off from where the previous topic left us, this important talk proposes
    two datasets, a weapon sales leads dataset and a past sales data dataset, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are done with the brief overview of topics we want to cover,
    which we decided are relevant toward the implementation of a recommendation system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far, we have given overviews of topics that are essential to the implementation
    of a recommendations system. These topics were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation problem formulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weapon sales leads and past sales data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations and ML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The detailed overview section for this topic is the most important section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations regarding problem formulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the detailed version of this topic, we will build a narrative (or story),
    in which the following features dominate:'
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding of sales leads and past sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up data that's been built with an understanding of sales leads and past
    sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Where data is concerned, we will compile custom sales leads data and past sales
    data that is related to weapons systems. In this phase, we will take up the formal
    formulation and support descriptions of a recommendation system based on explicit
    feedback from users. Such a formulation is broken down into two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining what explicit feedback is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a narrative (a story) around the recommendation problem involving explicit
    feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kinds of data constitutes explicit feedback? We set out to answer this
    question right away.
  prefs: []
  type: TYPE_NORMAL
- en: Defining explicit feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Explicit feedback, like its implicit counterpart, depends on user preferences.
    The machine learning model we will be building later is based on such explicit
    feedback. The datasets we are about to describe contains explicit feedback. Such
    explicit feedback data is a compilation of user/customer/client preferences concerning
    their choice of some weapon system (the product/item). It turns out that we are
    building a recommendation system that will predict what ratings users might leave
    for products they loved (or not). Indeed, ratings are a great example of feedback.
    We are all familiar with what star ratings look like. We generated the following
    start rating graphic using a little CSS and HTML. This is similar to a **Star
    Rating** seen on restaurant portal [yelp.com](https://www.yelp.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8637f5a4-a8e1-4a96-898c-ee8920e9532f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Restaurant ratings
  prefs: []
  type: TYPE_NORMAL
- en: We will not actually generate a star rating graphic for the impending explicit
    feedback-based recommendation system. However, the point here is that ratings
    have a central place in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building a narrative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Weapons maker X is a weapons manufacturer that caters to the defense needs
    of client nations across the globe. To us, this weapons maker is simply **WMX**.
    Government customer IEX is a typical WMX customer, identified simply as IEX. IEX
    wants to phase out its aging fighter aircraft with modern fifth-generation replacements. IEX
    figures are prominently on WMX''s past sales data records. Therefore, WMX views
    IEX as more than just a prospective client. In this scenario, two kinds of actors
    are evident:'
  prefs: []
  type: TYPE_NORMAL
- en: WMX—supplier of weapons systems products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers like IEX—these are countries that buy X's weapons systems and allocate
    ratings to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have the contours of an interesting use case. Actors 1 and 2 are useless
    without data. We plan on making two datasets available:'
  prefs: []
  type: TYPE_NORMAL
- en: Weapon sales leads—data from a leads campaign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Past weapon sales data—data from the past describing which customer purchased
    what weapons system (the item or product)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before proceeding further with a deeper discussion on the later use case, we
    will take a necessary detour. We want to explain the sales leads part in weapon
    sales leads. What are leads, anyway? What is the role of past sales data? Both
    questions are answered in the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: Sales leads and past sales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A business needs a product or products (or services) to sell and make money,
    of course. A familiar business strategy is a practice of generating sales leads.
    What is a sales lead? A **lead** is like a clue or a break that investigators
    stumble upon in a criminal investigation case. This lead is identifying the helpful
    information that may lead investigators to pursue a certain line of investigation.
    Such a lead, in the hands of a skilled, seasoned investigator might help potentially
    crack the case, nailing the culprit, or getting a fix on a potential suspect.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the criminal investigation analogy back to our sales use case, a sales
    lead is a sort of identifier in the sense that it represents identifying data
    early on in the sales process. Naturally, a lead generates the anticipation that
    a certain person or company will be a potential client down the road. A sales
    lead does not necessarily have to nail down a potential customer. However, a well-planned
    sales lead generation campaign can take advantage of “past sales data” to help
    the business identify a person or other business as a near or long-term prospect.
    A paying customer that shows up in past sales data may point to a future prospective
    client, which may be a repeat paying customer. Therefore, the business is not
    shooting in the dark, as it can use this information to figure out which customer
    to reach out to.
  prefs: []
  type: TYPE_NORMAL
- en: Our detour ends here. Moving into the next phase, we will apply our recently
    acquired knowledge of sales leads and past sales data to actual weapon sales leads
    and past sales data datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Weapon sales leads and past sales data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, download the following files from the `ModernScalaProjects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '`PastWeaponSalesOrders.csv`, compiled from scratch, requiring no citation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponSalesLeads.csv`, compiled from scratch, requiring no citation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PastWeaponSalesOrders.csv` is representative of WMX''s past weapons sales
    data, while `WeaponSalesLeads.csv` of WMX weapons sales leads data. Both datasets
    are designed to build a recommendation engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our weapons corporation WMX stores its past sales data records
    in `PastWeaponSalesOrders.csv`. This dataset''s records are depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2de5d1a3-22c4-4e97-ad0e-a0c1e4abf794.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Past sales data records
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into a description of data in the fields, we need a schema that
    is representative of the fields in this dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b88397e-494c-4eb3-b2e0-4f855bae3a1c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of the field in dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'Seven columns exist, of which the first two columns represent customer data.
    Eight customers are listed in alphabetical order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Australia**—Customer #1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Seychelles**—Customer #2'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fiji**—Customer #3'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Turkey**—Customer #4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Jordan**—Customer #5'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**South Korea**—Customer #6'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Djibouti**—Customer #7'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**India**—Customer #8'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next two columns, **ItemId**, followed by **ItemName**, represent a weapons
    system. The fifth column stores the price in millions of dollars per weapons system
    unit. Each cell of data in the sixth **OrderSize** column represents the number
    of units of a certain weapons system ordered by a certain customer. For example,
    Australia had, sometime in the past, ordered 25 units of **WeaponsSystem217**
    at a price of 2 million dollars per unit.
  prefs: []
  type: TYPE_NORMAL
- en: While both datasets are by no means comprehensive, they are a representative
    sampling, which is enough to create our recommendation system.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are building a sample sales lead prediction model based on past
    sales orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are few sample records from both datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f7a3730-cbfe-4cc5-bd0d-3e97b8fd0ce6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sample datasets
  prefs: []
  type: TYPE_NORMAL
- en: 'Both datasets are ready. We want to know what to make of this data and where
    to go from here. We set about putting together the data with one immediate goal—creating
    a model that would somehow help us make predictions. That goal wasn''t so clear-cut
    then. Now that we have two datasets, we want a clear goal. The key lies in the
    weapons sales leads dataset. What if we want to build a weapons sales lead model
    drawing on data from purchase history? Our past weapons sales dataset represents
    that purchase history. That then brings us to a sharper goal implementing a weapons
    sales prediction rating model. In other words, we want our model to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Predict what recommendation to make for each customer. There are 8 customers,
    ranging from Australia to India. We want our model to only recommend a weapons
    system that is right for a certain customer. The right weapons system for a customer
    is based on what they ordered in the past.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In making a recommendation to each customer, the model is also producing a rating
    that it believes the customer would give a certain product he/she did not purchase
    before a new product or products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s reiterate what both datasets have in common. The first is simple—there''s
    a customer, which in this case is a nation. Then, there is a product an (item),
    which in this case is a weapons system. The first dataset has this much to say:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a nation that ordered a certain number of weapons systems, each such
    system costing a certain unit price in millions of dollars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second dataset doesn't reveal much beyond its stated brief, which is to
    provide a listing of potential prospects. The company manufacturing these systems
    decides that some of these prospects are more than prospects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point we are trying to make here is that even though it is not that apparent,
    it is clear now that the data did not have to reveal many details. The customer
    is a nation that purchased a certain weapons system at a certain price. That's
    it, but that's enough. On the other hand, the weapons sales lead data tells a
    different kind of story, a likely scenario of a future scenario, where a certain
    company, in the company's estimates, is said to be likely to show interest in
    a certain type of weapons system.
  prefs: []
  type: TYPE_NORMAL
- en: We have data about users and products. Not detailed information, but apparently
    enough. This kind of data requires an algorithm that only needs to extract the
    relationship between users and products. It simply needs to see evidence of an
    interaction between the two. Both datasets at hand appear to be a fit for a collaborative
    filtering algorithm. That is why we can, in the next section, initiate a discussion
    on the basic mechanism driving the workings of a collaborative filtering algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are implementation objectives that are required to implement
    the recommendations system:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the past weapons sales order and weapon lead sales datasets from the `ModernScalaProjects` data
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may develop the pipeline in three ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incrementally in your local Spark Shell.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recommended: Flesh out your code in IntelliJ and wire up all necessary dependencies
    in the `build.sbt` file. Set SBT up to generate a fat JAR by wiring in an assembly
    plugin. The resultant self-contained SBT application is then deployed to your
    local spark cluster using `spark-submit`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the application and interpret the results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, *Implementation*, we will document step-by-step instructions
    for implementing the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementation is documented in the following subsections. All code is developed
    in an Intellij code editor. The very first step is to create an empty Scala project
    called `Chapter7`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – creating the Scala project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a Scala project called `Chapter7` with the following artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RecommendationSystem.scala`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecommendationWrapper.scala`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s break down the project''s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.idea`: Generated IntelliJ configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project`: Contains `build.properties` and `plugins.sbt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project`/`assembly.sbt`: This file specifies the `sbt-assembly` plugin needed
    to build a fat JAR for deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/scala`: This is a folder that houses Scala source files in the `com.packt.modern.chapter7`
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`: This is where artifacts of the compile process are stored. The generated
    assembly JAR file goes here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build.sbt`: This is the main SBT configuration file. Spark and its dependencies
    are specified here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we will start developing code in the IntelliJ code editor. We
    will start with the `AirlineWrapper` Scala file and end with the deployment of
    the final application JAR into Spark with `spark-submit`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – creating the AirlineWrapper definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the `trait` definition. The trait will hold the `SparkSession`
    variable, schema definitions for the datasets, and methods to build a dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a schema for past weapon sales orders.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – creating a weapon sales orders schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a schema for the past sales order dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a schema for weapon sales leads.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – creating a weapon sales leads schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a schema definition for the weapon sales lead dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's build a weapon sales order dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – building a weapon sales order dataframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s invoke the `read` method on our `SparkSession` instance and `cache`
    it. We will call this method later from the `RecSystem` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, let''s build a sales leads dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the `trait`. Overall, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Bring in the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Scala object called `RecSystem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going any further, bring in the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this object, start by loading the past sales order data. This will be
    our training data. Load the sales order dataset, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the schema. This is what the schema looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a partial view of a dataframe displaying past weapon sales order data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c435ac9-2ac8-49fc-9eae-a6f8a24af57f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partial view of dataframe displaying past weapon sales order data
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have what we need to create a dataframe of ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all and compile the project at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You are likely to run into the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, place the following statement at the top of the declarations of
    the rating dataframe. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and recompile the project. This time, it compiles just fine. Next, import
    the `Rating` class from the `org.apache.spark.mllib.recommendation` package. This
    transforms the rating dataframe that we obtained previously to its RDD equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following few lines of code are very important. We will be using the ALS
    algorithm from Spark MLlib to create and train a `MatrixFactorizationModel`, which
    takes an `RDD[Rating]` object as input. The ALS train method may require a combination
    of the following training hyperparameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numBlocks`: Preset to `-1` in an auto-configuration setting. This parameter
    is meant to parallelize computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custRank`: The number of features, otherwise known as latent factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterations`: This parameter represents the number of iterations for ALS to
    execute. For a reasonable solution to converge on, this algorithm needs roughly
    20 iterations or less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regParam`: The regularization parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`implicitPrefs`: This hyperparameter is a specifier. It lets us use either
    of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit feedback
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit feedback
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`: This is a hyperparameter connected to an implicit feedback variant
    of the ALS algorithm. Its role is to govern the baseline confidence in preference
    observations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just explained the role played by each parameter needed by the ALS algorithm's
    train method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by bringing in the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's get down to training the matrix factorization model using the ALS
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s train a matrix factorization model given an RDD of ratings by customers
    (users) for certain items (products). Our train method on the ALS algorithm will
    take the following four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Ratings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Lambda value or regularization parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the sales lead file and convert it into a tuple format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will display the new weapon sales lead dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – displaying the weapons sales dataframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we must invoke the `show` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a view of the weapon sales lead dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45ba3943-ccd9-4196-8a5d-9227c6e27df6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: View of weapon sales lead dataframe
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a version of the sales lead dataframe structured as (customer,
    item) tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, let's display the dataframe that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 – displaying the customer-weapons-system dataframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s the `show` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of the new customer-weapons-system dataframe as tuple
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4567169f-8231-466d-aaea-bbb2932e1f14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New customer-weapons-system dataframe as tuple pairs
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will convert the preceding dataframe into an RDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We previously created a `MatrixFactorization` model that we trained with the
    weapons system sales orders dataset. We are in a position to predict how each
    customer country may rate a weapon system in the future. In the next section,
    we will generate predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Step 8 – generating predictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how we will generate predictions. The `predict` method of our model
    is designed to do just that. It will generate a predictions RDD that we call `weaponRecs`.
    It represents the ratings of weapons systems that were not rated by customer nations
    (listed in the past sales order data) previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we will display the final predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Step 9 – displaying predictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how to display the predictions, lined up in tabular format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table displays how each nation is expected to rate a certain
    system in the future, that is, a weapon system that they did not rate earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ed1bc7d-c253-47dd-a12a-40468b258f5c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: System rating by each nation
  prefs: []
  type: TYPE_NORMAL
- en: Our recommendation system proved itself capable of generating future predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we did not say how all of the preceding code is compiled and deployed. We
    will look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps regarding compilation and deployment are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build an assembly JAR file of the recommendation system application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `spark-submit` command to deploy the recommendation system application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will compile the project first.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Invoke the `sbt compile` project at the root folder of your `Chapter7` project.
    You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35dfd742-8525-49cd-84c6-f70d67fa88d6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output on compiling the project
  prefs: []
  type: TYPE_NORMAL
- en: Besides loading `build.sbt`, the compile task is also loading settings from
    `assembly.sbt`, a file we have not talked about yet, but which we will create
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: What is an assembly.sbt file?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have not yet talked about the `assembly.sbt` file. Our scala-based Spark
    application is a Spark job that will be submitted to a (local) Spark cluster as
    a JAR file. This file, apart from Spark libraries, also needs other dependencies
    in it for our recommendation system job to successfully complete. The name fat
    JAR is from all dependencies bundled in one JAR. To build such a fat JAR, we need
    an `sbt-assembly` plugin. This explains the need for creating a new `assembly.sbt`
    and the assembly plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating assembly.sbt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `assembly.sbt` in your IntelliJ project view and save it under
    your `project` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/411d8fd6-ef46-4460-b503-b51a66651f70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating assembly.sbt
  prefs: []
  type: TYPE_NORMAL
- en: What will `assembly.sbt` contain? We will explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Contents of assembly.sbt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Paste the following contents into the newly created `assembly.sbt` (under the
    project folder). The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28902218-14be-4b75-aebf-e2b0879a9ff7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output on placing contents of assembly.sbt
  prefs: []
  type: TYPE_NORMAL
- en: The `sbt-assembly` plugin, version 0.14.7, gives us the ability to run an `sbt-assembly`
    task. With that, we are one step closer to building a fat or Uber JAR. This action
    is documented in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Running the sbt assembly task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Issue the `sbt assembly` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/746b947a-ac7a-4ee5-b873-6a5d21190903.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running the sbt assembly command
  prefs: []
  type: TYPE_NORMAL
- en: This time, the assembly task loads the assembly-plugin in `assembly.sbt`. However,
    further assembly halts because of a common duplicate error. This error arises
    due to several duplicates, multiple copies of dependency files that need removal
    before the assembly task can successfully complete. To address this situation,
    `build.sbt` needs an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the build.sbt file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lines of code need to be added in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee6e63fc-fa9c-45a7-bf8a-d1f84a1da6e5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code lines for upgrading the build.sbt file
  prefs: []
  type: TYPE_NORMAL
- en: To test the effect of your changes, save this and go to the command line to
    reissue the `sbt assembly` task.
  prefs: []
  type: TYPE_NORMAL
- en: Rerunning the assembly command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the assembly task, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/640a521c-e81b-4395-b123-7f583084f6ee.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rerunning the assembly task
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the settings in the `assembly.sbt` file are loaded. The task completes
    successfully. To verify, drill down to the `target` folder. If everything went
    well, you should see a fat JAR, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/790792c9-1c8a-4e73-a453-9dbd891f1461.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output as a JAR file
  prefs: []
  type: TYPE_NORMAL
- en: Our JAR file under the `target` folder is the recommendation system application's
    JAR file that needs to be deployed into Spark. This is documented in the next
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the recommendation application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `spark-submit` command is how we will deploy the application into Spark.
    Here are two formats for the `spark-submit` command. The first one is a long one
    which sets more parameters than the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Leaning on the preceding format, let''s submit our Spark job, supplying various
    parameters to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/add330e9-f59e-4921-be71-832b45c3edc4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Parameters for Spark
  prefs: []
  type: TYPE_NORMAL
- en: 'The different parameters are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98043e56-0ea3-462b-9d98-be3567914ec3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tabular explanation of parameters for Spark Job
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to build an explicit feedback type recommendation system. We
    implemented a predictions model with the Spark MLlib collaborative filtering algorithm
    that learns from past sales data and makes ratings-based recommendations about
    products to customers. The algorithm, as we have come to know, made its tailored
    product predictions on unknown customer-product interactions.
  prefs: []
  type: TYPE_NORMAL
- en: We used Spark's support for recommendations to build a prediction model that
    generated recommendations for unknown customer-product interactions in terms of
    sales leads and past weapons sales data. We leveraged Spark's alternating least
    squares algorithm to implement our collaborative filtering recommendation system.
  prefs: []
  type: TYPE_NORMAL
