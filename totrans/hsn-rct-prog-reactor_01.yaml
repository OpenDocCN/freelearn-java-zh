- en: Getting Started with Reactive Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用反应式流
- en: Over the years, application architecture has evolved. Businesses increasingly
    need to build systems that remain responsive and can scale when required. Systems
    should also be maintainable and quickly releasable. In accordance with these needs,
    we have started to build applications as loosely coupled services. We no longer
    build a system as one big application. Instead, we split systems into multiple
    independent, autonomous services. The objective for such services is to do one
    thing, and do it well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，应用架构已经发展。企业越来越需要构建在需要时可以保持响应性和可扩展性的系统。系统还应易于维护和快速发布。根据这些需求，我们已经开始构建松散耦合的服务应用。我们不再将系统构建为一个庞大的应用程序。相反，我们将系统拆分为多个独立、自主的服务。这些服务的目标是做一件事，并且做好。
- en: In this chapter, we will discuss concerns associated with building such services.
    We will also look at how to address those concerns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论构建此类服务时相关的担忧。我们还将探讨如何解决这些担忧。
- en: Technical requirements
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的GitHub链接为[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01)。
- en: Reactive architecture
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式架构
- en: 'When we start to build microservice architecture, we try to involve different
    services to deliver business solutions. We often build services as traditional
    API models, where each of the services can interact with other services. This
    is referred to as **distributed architecture**. If a distributed architecture
    is designed incorrectly, performance issues surface very quickly. It can be difficult
    to have numerous distributed services that work concurrently to deliver the intended
    performance. Companies that offer services requiring large data exchange (such
    as Netflix, Amazon, or Lightbend) have therefore seen a need for alternative paradigms,
    which can be used for systems with the following characteristics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建微服务架构时，我们试图涉及不同的服务以提供业务解决方案。我们通常将服务构建为传统的API模型，其中每个服务都可以与其他服务交互。这被称为**分布式架构**。如果分布式架构设计不当，性能问题会很快显现出来。要使众多分布式服务同时工作以提供预期的性能可能很困难。因此，提供需要大量数据交换服务（如Netflix、Amazon或Lightbend）的公司已经看到了对替代范例的需求，这些范例可以用于具有以下特性的系统：
- en: Consisting of very loosely coupled components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由非常松散耦合的组件组成
- en: Responding to user inputs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户输入做出响应
- en: Resilient to varying load conditions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够抵御变化的负载条件
- en: Always available
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是可用
- en: 'In order to achieve the preceding characteristics, we need to build event-driven,
    modular services that communicate with each other by using notifications. In turn,
    we can respond to the system''s flow of events. The modular services are more
    scalable, as we can add or remove service instances without halting the complete
    application. The complete architecture will be fault tolerant if we can isolate
    errors and take corrective actions. The preceding four characteristics are the
    basic principles of the **Reactive Manifesto**. The Reactive Manifesto states
    that each reactive system should consist of loosely coupled components that rely
    on asynchronous, message-driven architecture. They must remain responsive to user
    input and isolate failures to individual components. Replication must be done
    in order to respond to varying load conditions. The following is a diagram of
    the Reactive Manifesto:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述特性，我们需要构建事件驱动的、模块化的服务，这些服务通过使用通知相互通信。反过来，我们可以对系统的事件流做出响应。模块化服务更易于扩展，因为我们可以在不停止整个应用程序的情况下添加或删除服务实例。如果我们能够隔离错误并采取纠正措施，完整的架构将具有容错性。上述四个特性是**反应式宣言**的基本原则。反应式宣言指出，每个反应式系统应由松散耦合的组件组成，这些组件依赖于异步、消息驱动的架构。它们必须对用户输入保持响应，并将故障隔离到单个组件。为了应对不同的负载条件，必须进行复制。以下是反应式宣言的示意图：
- en: '![](img/09d66062-f536-4a4c-95e0-6b797161a8a7.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09d66062-f536-4a4c-95e0-6b797161a8a7.jpg)'
- en: The Reactive Manifesto describes a reactive system. It does not required that
    the system be based on reactive programming, or any other reactive library. We
    can build a message-driven, resilient, scalable, and responsive application without
    using a reactive library, but it is easier to build an application based on reactive
    libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式宣言描述了一个响应式系统。它并不要求系统基于响应式编程或任何其他响应式库。我们可以构建一个基于消息驱动、弹性、可扩展和响应的应用程序，而不使用响应式库，但基于响应式库构建应用程序会更简单。
- en: Reactive programming
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: 'Most of us write imperative applications, where statements are required in
    order to change the application state. The code is executed and a final state
    is arrived at. After the state''s computation, the state does not change when
    the underlying factors do. Let''s consider the following code as an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人编写的是命令式应用程序，其中需要语句来改变应用程序状态。代码被执行，最终达到一个状态。在状态计算之后，当底层因素发生变化时，状态不会改变。以下代码作为例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sum is still `15`, even though `value1` has been changed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总和仍然是`15`，尽管`value1`已经改变。
- en: 'On the other hand, reactive programming is about the propagation of change.
    It is also referred to as **declarative programming**, where we express our intent
    and application state as dynamically determined by changes to underlying factors.
    The preceding sum program example, under a reactive paradigm, would behave as
    follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，响应式编程是关于变化的传播。它也被称为**声明式编程**，其中我们表达我们的意图和应用程序状态，这些状态由底层因素的变化动态确定。在响应式范式下，前面的总和程序示例将如下行为：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Consequently, if a program reacts to changes in the underlying factors, it can
    be called reactive. Reactive programs can be built using imperative techniques,
    like callbacks. This may be fine for a program that has a single event. However,
    for applications where hundreds of events are happening, this could easily lead
    to callback hell; we could have numerous callbacks relying on one another, and
    it would be really difficult to figure out which ones were being executed. As
    a result, we require a new set of abstractions that enable us to seamlessly build
    asynchronous, event-driven interactions across a network boundary. There are libraries
    in different imperative languages, like Java, that provide us with these abstractions.
    These libraries are referred to as **Reactive Extensions**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个程序对底层因素的变化做出反应，它可以被称为响应式。响应式程序可以使用命令式技术，如回调来构建。对于只有一个事件的程序来说，这可能没问题。然而，对于有数百个事件发生的应用程序，这很容易导致回调地狱；我们可能有多个相互依赖的回调，很难确定哪些正在执行。因此，我们需要一套新的抽象，使我们能够无缝地在网络边界上构建异步、事件驱动的交互。在Java等不同的命令式语言中，有提供这些抽象的库。这些库被称为**响应式扩展**。
- en: ReactiveX
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveX
- en: 'Reactive Extensions, also known as ReactiveX, enable us to express the asynchronous
    events in an application as a set of observable sequences. Other applications
    can subscribe to these observables, in order to receive notifications of events
    that are occurring. A producer can then push these notification events to a consumer
    as they arrive. Alternatively, if a consumer is slow, it can pull notification
    events according to its own consumption rate. The end-to-end system of a producer
    and its consumers is known as a **pipeline**. It is important to note that pipelines
    are lazy by default and do not materialize until they are subscribed to by a consumer.
    This is very different from eager Java types, like Future, which represent active
    work. The ReactiveX API consists of the following components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式扩展，也称为ReactiveX，使我们能够将应用程序中的异步事件表示为一组可观察序列。其他应用程序可以订阅这些可观察序列，以便接收正在发生的事件的通知。生产者可以随后将这些通知事件推送到消费者。或者，如果消费者速度较慢，它可以根据自己的消费速率拉取通知事件。生产者和其消费者之间的端到端系统被称为**管道**。需要注意的是，管道默认是懒加载的，直到被消费者订阅才会实际化。这与代表主动工作的急切Java类型（如Future）非常不同。ReactiveX
    API由以下组件组成：
- en: '**Observables**: Observables represent the core concept of ReactiveX. They
    represent the sequences of emitted items, and they generate events that are propagated
    to the intended subscribers.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可观察序列**：可观察序列代表了ReactiveX的核心概念。它们代表发出项的序列，并生成传播到预期订阅者的事件。'
- en: '**Observer:** Any application can express its intent for events published by
    an observable by creating an observer and subscribing to the respective observable.
    The intent is expressed in terms of the `OnNext`, `OnCompleted`, and `OnError`
    methods. Each observable sends a stream of events, followed by a completion event,
    which executes these methods.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**观察者**：任何应用程序都可以通过创建观察者并订阅相应的可观察对象来表达其对由可观察对象发布的事件的意图。意图通过`OnNext`、`OnCompleted`和`OnError`方法来表示。每个可观察对象发送一系列事件，然后是一个完成事件，这些事件执行这些方法。'
- en: '**Operators**: Operators enable us to transform, combine, and manipulate the
    sequences of items emitted by observables. The operators on an observable provide
    a new observable, and thus, they can be tied together. They do not work independently
    on the original observable; instead, they work on the observable generated by
    the previous operator to generate a new observable. The complete operator chain
    is lazy. It is not evaluated until an observer is subscribed to it. The complete
    chain is shown as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**操作符**：操作符使我们能够转换、组合和处理由可观察对象发出的项目序列。可观察对象上的操作符提供一个新的可观察对象，因此，它们可以相互连接。它们不会独立于原始可观察对象工作；相反，它们作用于由前一个操作符生成的可观察对象以生成一个新的可观察对象。完整的操作符链是惰性的。它不会在观察者订阅之前进行评估。完整的链如下所示：'
- en: '![](img/1aa05938-c82e-4355-a74f-705c5be58ca7.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1aa05938-c82e-4355-a74f-705c5be58ca7.png)'
- en: ReactiveX provides the architecture design to build reactive applications. Individual
    libraries were built around it in different imperative languages to enable its
    use. These abstractions allow us to build asynchronous, non-blocking applications,
    and provide the additional benefits listed in the following sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveX提供了构建反应式应用程序的架构设计。不同的命令式语言围绕它构建了各个库，以使其可用。这些抽象使我们能够构建异步、非阻塞的应用程序，并提供以下章节中列出的额外好处。
- en: Composite streams
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合流
- en: In software design, **composition** refers to grouping different entities and
    treating each group as a single entity. Additionally, the single entity exhibits
    the same behavior as the type it refers to. ReactiveX streams are composite in
    nature. They make it possible to combine existing data streams, add transformations,
    and generate new data streams. Moreover, all of this can be done in a declarative
    manner, making the overall solution maintainable in the long run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中，**组合**指的是将不同的实体分组，并将每个组视为单个实体。此外，单个实体表现出与其所引用的类型相同的行为。ReactiveX流本质上是组合的。它们使得将现有数据流组合起来、添加转换以及生成新的数据流成为可能。此外，所有这些都可以以声明性方式完成，从而使整体解决方案在长期内可维护。
- en: Flexible operators
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活操作符
- en: The libraries offer a range of operators for all kinds of functions. Each of
    the operators accomplishes its tasks similarly to that of a workstation on an
    assembly line. It takes input from the previous workstation and provides input
    to the next workstation. These operators offer all kinds of data transformation,
    stream orchestration, and error handlers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库提供了一系列适用于各种函数的操作符。每个操作符都像装配线上的工作站一样完成任务。它从前一个工作站接收输入，并向下一个工作站提供输入。这些操作符提供各种数据转换、流编排和错误处理。
- en: ReactiveX makes its easier to build event-based applications. However, the framework
    does not present the ways in which different event-driven applications should
    interact with each other. In a microservice architecture consisting of numerous
    event-driven services, the gains made are often offset by the workarounds required
    for inter-process communication.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveX使构建基于事件的程序变得更加容易。然而，该框架没有展示不同事件驱动应用程序之间应该如何相互交互。在一个由众多事件驱动服务组成的微服务架构中，所获得的收益往往被所需的进程间通信的解决方案所抵消。
- en: Reactive Streams
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactive Streams
- en: 'Reactive Streams is a specification that determines the minimum set of interfaces
    required to build the asynchronous processing of a large volume of unbounded data.
    It is a specification aimed at JVM and JavaScript runtime. The main goal of the
    Reactive Streams specification is to standardize the exchange of stream data across
    an asynchronous boundary of applications. The API consists of the following four
    interfaces:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams是一个规范，它确定了构建大量无界数据异步处理所需的最小接口集。它是一个针对JVM和JavaScript运行时的规范。Reactive
    Streams规范的主要目标是标准化应用程序异步边界之间的流数据交换。API由以下四个接口组成：
- en: '**Publisher**: The publisher is responsible for the generation of an unbounded
    number of asynchronous events and pushing those events to the associated subscribers.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发布者**：发布者负责生成无限数量的异步事件并将这些事件推送到相关的订阅者。'
- en: '**Subscriber**: The subscriber is a consumer of the events published by a publisher.
    The subscriber gets events for subscription, data, completion, and error. It can
    choose to perform actions on any of them.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**订阅者**：订阅者是发布者发布事件的消费者。订阅者可以获得订阅、数据、完成和错误事件。它可以选择对其中任何一个执行操作。'
- en: '**Subscription**: A subscription is a shared context between the publisher
    and subscriber, for the purpose of mediating the data exchange between the two.
    The subscription is available with the subscriber only, and enables it to control
    the flow of events from the publisher. The subscription becomes invalid if there
    is an error or a completion. A subscriber can also cancel the subscriptions, in
    order to close its stream.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**订阅**：订阅是发布者和订阅者之间用于调解两者之间数据交换的共享上下文。订阅仅在订阅者处可用，并使其能够控制来自发布者的事件流。如果发生错误或完成，订阅将无效。订阅者还可以取消订阅，以关闭其流。'
- en: '**Processor**: The processor represents a stage of data processing between
    a subscriber and a publisher. Consequently, it is bound by both of them. The processor
    has to obey the contract between the publisher and the subscriber. If there is
    an error, it must propagate it back to the subscriber.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理器**：处理器代表订阅者和发布者之间数据处理的一个阶段。因此，它被两者所约束。处理器必须遵守发布者和订阅者之间的合同。如果有错误，它必须将其传播回订阅者。'
- en: The Reactive Streams specification is the result of a collaborative effort of
    engineers from Kaazing, Netflix, Pivotal, Red Hat, Twitter, Typesafe, and many
    other companies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams规范是来自Kaazing、Netflix、Pivotal、Red Hat、Twitter、Typesafe和其他许多公司的工程师共同努力的结果。
- en: While there are only four interfaces, there are around 30 rules that govern
    the data exchange between the publisher and the subscriber. These rules are based
    on the two principles covered in the following sections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有四个接口，但大约有30条规则来规范发布者和订阅者之间的数据交换。这些规则基于以下章节中提到的两个原则。
- en: Asynchronous processing
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理
- en: Asynchronous execution refers to the ability to execute tasks without having
    to wait to finish previously executed tasks first. The execution model decouples
    tasks, so that each of them can be performed simultaneously, utilizing the available
    hardware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 异步执行指的是执行任务时无需等待之前执行的任务完成。执行模型解耦任务，使得每个任务都可以同时执行，利用可用的硬件。
- en: The Reactive Streams API delivers events in an asynchronous manner. A publisher
    can generate event data in a synchronous blocking manner. On the other hand, each
    of the on-event handlers can process the events in a synchronously blocking manner.
    However, event publishing must occur asynchronously. It must not be blocked by
    the subscriber while processing events.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams API以异步方式传递事件。发布者可以以同步阻塞方式生成事件数据。另一方面，每个事件处理程序都可以以同步阻塞方式处理事件。然而，事件发布必须异步进行。在处理事件时，它不能被订阅者阻塞。
- en: Subscriber backpressure
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者背压
- en: A subscriber can control events in its queue to avoid any overruns. It can also
    request more events if there is additional capacity. Backpressure enforces the
    publisher to bound the event queues according to the subscriber. Furthermore,
    a subscriber can ask to receive one element at a time, building a stop-and-wait
    protocol. It can also ask for multiple elements. On the other hand, a publisher
    can apply the appropriate buffers to hold non-delivered events, or it can just
    start to drop events if the production rate is more than the consumption rate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者可以控制其队列中的事件以避免任何溢出。如果还有额外容量，它还可以请求更多事件。背压强制发布者根据订阅者限制事件队列。此外，订阅者可以要求一次接收一个元素，构建停止等待协议。它也可以请求多个元素。另一方面，发布者可以应用适当的缓冲区来保存未发送的事件，或者如果生产率超过消费率，它可以直接开始丢弃事件。
- en: It is important to note that the Reactive Streams API is aimed at the flow of
    events between different systems. Unlike ReactiveX, it does not provide any operators
    to perform transformations. The API has been adopted as a part of the `java.util.concurrent.Flow`
    package in JDK 9.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Reactive Streams API旨在不同系统之间的事件流。与ReactiveX不同，它不提供任何执行转换的算子。该API已被采纳为JDK
    9中`java.util.concurrent.Flow`包的一部分。
- en: David Karnok's classification
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: David Karnok 的分类
- en: David Karnok, a veteran of various reactive projects like Rxjava and Reactor,
    has categorized the evolution of reactive libraries into the following generations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: David Karnok，Rxjava 和 Reactor 等各种反应式项目的资深人士，将反应式库的演变划分为以下几代。
- en: Zero generation
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零代
- en: The zero generation revolves around the `java.util.observable` interface and
    the related callbacks. It essentially uses the observable design pattern for reactive
    development. It lacks the necessary support of composition, operators, and backpressure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 零代围绕着 `java.util.observable` 接口和相关回调。它本质上使用可观察设计模式进行反应式开发。它缺乏必要的组合、操作符和背压支持。
- en: First generation
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一代
- en: The first generation represents Erik Mejer's attempt to address reactive issues
    by building Rx.NET. This referred to implementations in the form of the `IObserver`
    and `IObservable` interfaces. The overall design was synchronous and lacked backpressure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一代代表了 Erik Mejer 通过构建 Rx.NET 来解决反应式问题的尝试。这指的是以 `IObserver` 和 `IObservable`
    接口形式实现的实现。整体设计是同步的，缺乏背压。
- en: Second generation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二代
- en: The first generation deficiencies of backpressure and synchronous handling were
    handled in the second generation APIs. This generation refers to the first implementations
    of Reactive Extensions, such as RxJava 1.X and Akka.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二代 API 解决了第一代中背压和同步处理的问题。这一代指的是反应式扩展的第一批实现，如 RxJava 1.X 和 Akka。
- en: Third generation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三代
- en: The third generation refers to the Reactive Streams specification, which enables
    library implementors to be compatible with each other and compose sequences, cancellations,
    and backpressure across boundaries. It also enables an end user to switch between
    implementations at their own will.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三代指的是 Reactive Streams 规范，它使库实现者之间能够相互兼容，并在边界之间组合序列、取消和背压。它还允许最终用户根据自己的意愿在实现之间切换。
- en: Fourth generation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四代
- en: The fourth generation refers to the fact that reactive operators can be combined
    in an external or internal fashion, leading to performance optimization. A fourth
    generation reactive API looks like a third generation, but internally, the operators
    have changed significantly to yield intended benefits. Reactor 3.0 and RxJava
    2.x belong to this generation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第四代指的是反应式操作符可以以外部或内部方式组合，从而实现性能优化。第四代反应式 API 看起来与第三代相似，但内部操作符发生了显著变化，以产生预期的效益。Reactor
    3.0 和 RxJava 2.x 属于这一代。
- en: Fifth generation
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五代
- en: The fifth generation refers to a future work, in which there will be a need
    for bidirectional reactive I/O operations over the streams.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第五代指的是未来的工作，届时将需要在流上进行双向反应式 I/O 操作。
- en: Reactor
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor
- en: Reactor is an implementation completed by the Pivotal Open Source team, conforming
    to the Reactive Streams API. The framework enables us to build reactive applications,
    taking care of backpressure and request handling. The library offers the following
    features.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 是由 Pivotal 开源团队完成的一个实现，符合 Reactive Streams API。该框架使我们能够构建响应式应用程序，负责处理背压和请求处理。该库提供了以下功能。
- en: Infinite data streams
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限数据流
- en: Reactor offers implementations for generating infinite sequences of data. At
    the same time, it offers an API for publishing a single data entry. This is suited
    to the request-response model. Each API offers methods aimed at handling the specific
    data cardinality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了生成无限数据序列的实现。同时，它提供了一个用于发布单个数据条目的 API。这适用于请求-响应模型。每个 API 都提供了旨在处理特定数据基数的方法。
- en: Rather than waiting for the entire data collection to arrive, subscribers to
    each data stream can process items as they arrive. This yields optimized data
    processing, in terms of space and time. The memory requirement is limited to a
    subset of items arriving at the same time, rather than the entire collection.
    In terms of time, results start to arrive as soon as the first element is received,
    rather than waiting for the entire dataset.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是等待整个数据集到达，每个数据流的订阅者可以按数据到达的顺序处理项目。这从空间和时间上优化了数据处理。内存需求限制在同时到达的项目的子集，而不是整个集合。在时间上，结果一旦收到第一个元素就开始到达，而不是等待整个数据集。
- en: Push-pull model
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推拉模型
- en: Reactor is a push-pull system. A fast producer raises events and waits for the
    slower subscriber to pull them. In the case of a slow publisher and a fast subscriber,
    the subscriber waits for events to be pushed from the producer. The Reactive Streams
    API allows this data flow to be dynamic in nature. It only depends on the real-time
    rate of production and the rate of consumption.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor是一个推拉系统。快速的生产者引发事件并等待较慢的订阅者拉取它们。在慢速发布者和快速订阅者的情况下，订阅者等待从生产者那里推送事件。Reactive
    Streams API允许这种数据流在本质上具有动态性。它只依赖于生产的实时速率和消费速率。
- en: Concurrency agnostic
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发无关
- en: The Reactor execution model is a concurrency agnostic. It does not cover how
    different streams should be processed. The library facilitates different execution
    models, which can be used at a developer's discretion. All transformations are
    thread safe. There are various operators that can influence the execution model
    by combining different synchronous streams.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor执行模型是并发无关的。它不涉及不同流应该如何处理。库简化了不同的执行模型，开发者可以根据自己的意愿使用。所有转换都是线程安全的。有各种算子可以通过组合不同的同步流来影响执行模型。
- en: Operator vocabulary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算子词汇表
- en: Reactor provides a wide range of operators. These operators allow us to select,
    filter, transform, and combine streams. The operations are performed as a workstation
    in a pipeline. They can be combined with each other to build high-level, easy-to-reason
    data pipelines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor提供了一系列算子。这些算子允许我们选择、过滤、转换和组合流。操作作为管道中的工作站执行。它们可以组合在一起来构建高级、易于推理的数据管道。
- en: 'Reactor has been adopted in Spring Framework 5.0 to provide reactive features.
    The complete project consists of the following sub-projects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor已被Spring Framework 5.0采用，以提供反应式功能。完整项目包括以下子项目：
- en: '**Reactor-Core**: This project provides the implementation for the Reactive
    Streams API. The project is also the foundation for Spring Framework 5.0 Reactive
    Extensions.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor-Core**：该项目为Reactive Streams API提供实现。该项目也是Spring Framework 5.0反应式扩展的基础。'
- en: '**Reactor-Extra**: This project complements the Reactor-Core project. It provides
    the necessary operators to work on top of the Reactive Streams API.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor-Extra**：该项目补充了Reactor-Core项目。它提供了在Reactive Streams API之上工作的必要算子。'
- en: '**Reactor-Tests**: This project contains utilities for test verification.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor-Tests**：该项目包含测试验证的实用工具。'
- en: '**Reactor-IPC**: This project provides non-blocking, inter-process communication.
    It also provides backpressure-ready network engines for HTTP (including WebSockets),
    TCP, and UDP. The module can also be used to build microservices.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor-IPC**：该项目提供非阻塞的进程间通信。它还提供了为HTTP（包括WebSocket）、TCP和UDP准备的背压就绪网络引擎。该模块也可以用于构建微服务。'
- en: Project setup
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'This book follows a hands-on approach; you will learn Reactor by working with
    examples. This chapter will set up the project that we will use throughout this
    book. Before we can move on, we will have to do some setting up. Please install
    the following items on your machine:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本书采用动手实践的方法；您将通过与示例一起工作来学习Reactor。本章将设置我们将在这本书中使用的项目。在我们继续之前，我们必须做一些设置。请在您的机器上安装以下项目：
- en: '**Java 8**: Reactor works with Java 8 or above. Please download the latest
    update of Java 8 from the official Oracle website at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    At the time of writing, the Java version was `1.8.0_101`. You can check your Java
    version by running the following command:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 8**：Reactor与Java 8或更高版本兼容。请从官方Oracle网站下载Java 8的最新更新，网址为[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)。在撰写本文时，Java版本为`1.8.0_101`。您可以通过运行以下命令来检查您的Java版本：'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**IntelliJ IDEA 2018.1 or above**: We will be using the latest community edition
    of IntelliJ. You can download the latest version from the JetBrains website at
    [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
    We will be using version 2018.1.1.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA 2018.1或更高版本**：我们将使用IntelliJ的最新社区版。您可以从JetBrains网站下载最新版本，网址为[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)。我们将使用版本2018.1.1。'
- en: '**Gradle**: Gradle is a one of the most popular build tools in the JVM ecosystem.
    It is used for dependency management and for running automated tasks. You don''t
    have to install Gradle on your local machine; we will use a Gradle wrapper that
    downloads and installs Gradle for your project. To learn more about Gradle, you
    can refer to the Gradle documentation at [https://docs.gradle.org/current/userguide/userguide.html](https://docs.gradle.org/current/userguide/userguide.html).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gradle**：Gradle 是 JVM 生态系统中最受欢迎的构建工具之一。它用于依赖项管理和运行自动化任务。您不需要在本地机器上安装 Gradle；我们将使用
    Gradle 包装器，它会为您的项目下载和安装 Gradle。要了解更多关于 Gradle 的信息，您可以参考 Gradle 文档[https://docs.gradle.org/current/userguide/userguide.html](https://docs.gradle.org/current/userguide/userguide.html)。'
- en: 'Now that we have all the prerequisites, let''s create a Gradle project by using
    IntelliJ IDEA itself:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有先决条件，让我们通过 IntelliJ IDEA 本身来创建一个 Gradle 项目：
- en: 'Launch IntelliJ IDEA and you will see the following screen, where you can begin
    to create a project:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 IntelliJ IDEA，您将看到以下屏幕，您可以在其中开始创建项目：
- en: '![](img/b81d6ae3-2d6e-4ece-87aa-086a7577f93d.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b81d6ae3-2d6e-4ece-87aa-086a7577f93d.png)'
- en: 'Click on Create New Project to start the process of creating a Java Gradle
    project. You will see a screen for creating a new project. Here, select Gradle
    and Java, as shown in the following screenshot. You will also have to specify
    the Project SDK. Click on the New button to select JDK 8\. Then, click on Next
    to move to the next screen:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建新项目”以开始创建 Java Gradle 项目的流程。您将看到一个创建新项目的屏幕。在此，选择 Gradle 和 Java，如以下截图所示。您还必须指定项目
    SDK。点击“新建”按钮以选择 JDK 8。然后，点击“下一步”以进入下一屏幕：
- en: '![](img/2a5bd061-a0c4-48a5-a4da-d8d9930d3ee0.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a5bd061-a0c4-48a5-a4da-d8d9930d3ee0.png)'
- en: 'Now you will be asked to enter the GroupId and ArtifactId. Click on Next to
    move to the next screen:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您将被要求输入 GroupId 和 ArtifactId。点击“下一步”以进入下一屏幕：
- en: '![](img/218ab741-b398-4a48-859b-e2b3d1b912b3.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/218ab741-b398-4a48-859b-e2b3d1b912b3.png)'
- en: 'The next screen will ask you to specify a few Gradle settings. We will select
    Use auto-import, so that Gradle will automatically add new dependencies when we
    add them to the build file. Click on Next to move to the final screen:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏幕将要求您指定一些 Gradle 设置。我们将选择“使用自动导入”，这样 Gradle 将在我们将新依赖项添加到构建文件时自动添加它们。点击“下一步”以进入最终屏幕：
- en: '![](img/454d0d88-0c2f-456b-930a-44dd3569bb04.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/454d0d88-0c2f-456b-930a-44dd3569bb04.png)'
- en: 'On this screen, you will be asked for the location where you want to create
    the project. Select a convenient directory path for the application. Finally,
    click on Finish to complete the project creation process:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此屏幕上，您将被要求指定您想要创建项目的位置。选择一个方便的应用程序目录路径。最后，点击“完成”以完成项目创建过程：
- en: '![](img/e171409f-1c2b-45ab-9a11-38d35c2f014a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e171409f-1c2b-45ab-9a11-38d35c2f014a.png)'
- en: 'Now that the Java Gradle project has been created, we have to make a couple
    of changes in the Gradle build file, that is, `build.gradle`. Open the `build.gradle`
    file in IDE and change it to match the following contents:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Java Gradle项目已经创建，我们不得不在 Gradle 构建文件`build.gradle`中进行一些更改，即更改以下内容：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding `build.gradle` file, we have done the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`build.gradle`文件中，我们做了以下操作：
- en: Added the `io.spring.dependency-management` plugin. This plugin allows us to
    have a `dependency-management` section, for configuring dependency versions.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了`io.spring.dependency-management`插件。此插件允许我们有一个`dependency-management`部分，用于配置依赖项版本。
- en: Configured the `dependency-management` plugin to download the latest version
    of Reactor. We have used the maven BOM published by the Reactor project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置了`dependency-management`插件以下载 Reactor 的最新版本。我们使用了 Reactor 项目发布的 Maven BOM。
- en: Added the `reactor-core` dependency to the list of project dependencies.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`reactor-core`依赖项添加到项目依赖项列表中。
- en: That's all we need to do to start using Reactor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始使用 Reactor 所需要做的全部事情。
- en: At the time of writing, Bismuth-RELEASE was the latest version of Reactor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Bismuth-RELEASE 是 Reactor 的最新版本。
- en: 'Now, let''s build a simple test case to see how we can work with the Reactor
    API. We will build a simple test case for generating Fibonacci numbers. Wikipedia
    defines Fibonacci numbers as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的测试用例来查看我们如何使用 Reactor API。我们将构建一个生成斐波那契数的简单测试用例。维基百科将斐波那契数定义为如下：
- en: '"In mathematics, the Fibonacci numbers are the numbers in the following integer
    sequence, called the Fibonacci sequence, and characterized by the fact that every
    number after the first two is the sum of the two preceding ones:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “在数学中，斐波那契数列是以下整数序列中的数，称为斐波那契序列，其特征是每个数（从第三个数开始）都是前两个数的和：
- en: 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144, ..."
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144, ...”
- en: 'Let''s build our test for the Fibonacci generation. The test case will start
    to generate a series, from 0 and 1\. It will generate the first 50 Fibonacci numbers,
    and will validate the 50^(th) number as `7778742049`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建用于生成斐波那契数的测试。测试用例将从 0 和 1 开始生成一个序列。它将生成前 50 个斐波那契数，并将第 50 个数验证为 `7778742049`：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The complete code can be found at [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01)找到。
- en: 'In the preceding test case, we are doing the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试用例中，我们执行了以下操作：
- en: We create Fibonacci as `Flux<Long>`, by using the `Flux.generate()` call. The
    API has a `State` and `Sink`. For now, we will leave the Flux API details for
    the next chapter.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用 `Flux.generate()` 调用创建斐波那契数作为 `Flux<Long>`。API 有一个 `State` 和 `Sink`。现在，我们将把
    Flux API 的细节留给下一章。
- en: The API takes a seed as `Tuple [0 , 1]`. It then emits the first argument of
    the pair by using the `Sink.next()` call.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 以 `Tuple [0 , 1]` 作为种子。然后它通过 `Sink.next()` 调用发出对的第一个参数。
- en: The API also generates the next Fibonacci number by aggregating the pair.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 还通过聚合这对数生成下一个斐波那契数。
- en: Next, we select the first 50 Fibonacci numbers by using the `take()` operator.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `take()` 操作符选择前 50 个斐波那契数。
- en: We subscribe to the published numbers, and then append the received number to
    a `List<Long>`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们订阅发布的数字，然后将接收到的数字追加到 `List<Long>` 中。
- en: Finally, we assert the published numbers.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们断言发布的数字。
- en: In the preceding test case, we have used a number of Rector features. We will
    cover each of them in detail in our subsequent chapters. For now, let's execute
    the test case and check that our project is running fine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试用例中，我们使用了多个 Rector 功能。我们将在后续章节中详细介绍每个功能。现在，让我们执行测试用例并检查我们的项目是否运行正常。
- en: 'Running our unit test should give us a green bar, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的单元测试应该会给我们一个绿色的条形，如下所示：
- en: '![](img/737b3e38-51ad-4d4c-9456-5498105fce64.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/737b3e38-51ad-4d4c-9456-5498105fce64.png)'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed the need for a reactive paradigm. We also looked
    at the evolution of the paradigm, from reactive programming to Reactive Extensions
    and then Reactive Streams. Furthermore, we discussed the Reactive Streams specification
    as a specification aimed at JVM for the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了需要反应式范式。我们还探讨了范式的演变，从反应式编程到反应式扩展，再到反应式流。此外，我们讨论了反应式流规范作为针对 JVM 的规范，旨在以下方面：
- en: Processing a potentially unbounded number of elements in a sequence
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理序列中可能无界数量的元素
- en: Asynchronously passing elements between components with mandatory non-blocking
    backpressure
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件之间异步传递具有强制非阻塞背压的元素
- en: At the end of the chapter, we covered Reactor, an implementation by the Pivotal
    team, and built a sample project with it. In the next chapter, we will discuss
    the APIs available in Reactor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们介绍了 Reactor，这是 Pivotal 团队的一个实现，并使用它构建了一个示例项目。在下一章中，我们将讨论 Reactor 中可用的
    API。
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the principles of the Reactive Manifesto?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式宣言的原则是什么？
- en: What are Reactive Extensions?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是反应式扩展？
- en: What does the Reactive Stream specification cater for?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式流规范提供了哪些内容？
- en: What are the principles upon which Reactive Streams are based?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式流基于哪些原则？
- en: What are the salient features of the Reactor Framework?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor 框架的主要特性是什么？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about microservice design, please refer to [https://www.packtpub.com/application-development/reactive-microservice-design-video](https://www.packtpub.com/application-development/reactive-microservice-design-video).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于微服务设计的信息，请参阅[https://www.packtpub.com/application-development/reactive-microservice-design-video](https://www.packtpub.com/application-development/reactive-microservice-design-video)。
- en: The Reactive Streams specification is part of Java 9\. To find out more about
    what is included in the Java Development Kit 9, please refer to [https://www.packtpub.com/application-development/reactive-programming-java-9](https://www.packtpub.com/application-development/reactive-programming-java-9).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactive Streams 规范是 Java 9 的一部分。要了解更多关于 Java 开发工具包 9 中包含的内容，请参阅 [https://www.packtpub.com/application-development/reactive-programming-java-9](https://www.packtpub.com/application-development/reactive-programming-java-9).
