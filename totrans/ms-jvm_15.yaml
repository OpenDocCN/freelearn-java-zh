- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Java Annotation Processor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java注解处理器
- en: In the dynamic landscape of Java programming, the ability to introspect and
    analyze code at runtime has long been facilitated by reflection. While reflection
    offers a powerful mechanism for inspecting and manipulating classes, fields, and
    methods, it comes with its trade-offs, such as performance overhead and the potential
    for runtime errors. Recognizing these challenges, a compelling alternative arises—shifting
    the focus from runtime to build time using Java Annotation Processors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java编程的动态环境中，运行时对代码进行内省和分析的能力长期以来一直由反射提供支持。虽然反射提供了一种强大的机制来检查和操作类、字段和方法，但它也伴随着其权衡，例如性能开销和运行时错误的可能性。认识到这些挑战，一个引人注目的替代方案出现了——通过使用Java注解处理器将焦点从运行时转移到构建时。
- en: This chapter delves into the world of Java Annotation Processors, offering insights
    into their role as a robust tool for harnessing metadata during the compilation
    phase. By doing so, developers can sidestep the pitfalls associated with runtime
    reflection, understanding how to leverage annotation processors for enhanced code
    generation and manipulation. Through practical examples and hands-on exploration,
    you will discover the intricacies of integrating annotation processors into your
    development workflow, ultimately empowering you to optimize your codebase and
    balance flexibility and performance. Join us on this journey to unlock the full
    potential of Java annotation processors and transform how you approach metadata
    processing in your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Java注解处理器的世界，揭示了它们在编译阶段利用元数据方面的作用。通过这样做，开发者可以避免与运行时反射相关的陷阱，了解如何利用注解处理器进行增强的代码生成和操作。通过实际示例和动手探索，你将发现将注解处理器集成到你的开发工作流程中的复杂性，最终使你能够优化你的代码库，平衡灵活性和性能。加入我们，一起探索Java注解处理器的全部潜力，并改变你在项目中处理元数据的方法。
- en: 'In this chapter, we’ll explore the topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Overview of Java Annotation Processor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java注解处理器概述
- en: Exploring Practical Java Annotation Processor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索实用的Java注解处理器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Java 21
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: Git
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-11](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-11)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-11](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-11)
- en: Overview of Java Annotation Processor
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java注解处理器概述
- en: Developers, here we delve into the capabilities and significance of Java Annotation
    Processors. In the ever-evolving realm of Java, efficient and optimized code is
    paramount, and to achieve this, understanding the role of tools such as annotation
    processors becomes crucial. We’ll explore why Java Annotation Processors exist,
    how they differ from the widely used reflection mechanism, and the trade-offs
    in making the right choice for your projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者，在这里我们将深入探讨Java注解处理器的功能和重要性。在Java不断发展的领域中，高效和优化的代码至关重要，为了实现这一点，理解工具如注解处理器的作用变得至关重要。我们将探讨为什么存在Java注解处理器，它们与广泛使用的反射机制有何不同，以及为你的项目做出正确选择时的权衡。
- en: Java Annotation Processors emerged as a powerful tool to address some challenges
    runtime reflection poses. While reflection allows dynamic inspection and manipulation
    of code elements during runtime, it comes with performance overhead and the potential
    for runtime errors. In contrast, annotation processors operate at compile time,
    offering a way to analyze and generate code based on annotations present in the
    source code. This shift from runtime to build time brings significant advantages,
    including improved performance, early error detection, and enhanced code maintainability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java注解处理器作为解决运行时反射带来的某些挑战的有力工具而出现。虽然反射允许在运行时动态检查和操作代码元素，但它伴随着性能开销和运行时错误的可能性。相比之下，注解处理器在编译时运行，提供了一种根据源代码中存在的注解来分析和生成代码的方法。这种从运行时到构建时的转变带来了显著的优势，包括改进的性能、早期错误检测和增强的代码可维护性。
- en: Distinguishing between Java Annotation Processors and reflection is crucial
    for optimizing Java development. Reflection, a dynamic runtime mechanism, provides
    flexibility but incurs a performance cost. In contrast, Java Annotation Processors
    operate during compilation, offering static analysis for optimizations and early
    error detection. This section explores these differences, empowering developers
    to make informed decisions based on their project needs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 区分 Java 注解处理器和反射对于优化 Java 开发至关重要。反射是一种动态运行时机制，提供了灵活性，但会带来性能成本。相比之下，Java 注解处理器在编译时运行，提供了静态分析以进行优化和早期错误检测。本节探讨了这些差异，使开发者能够根据项目需求做出明智的决定。
- en: Let’s delve into a comparative analysis of Java Annotation Processors and reflection.
    While both mechanisms involve annotations for metadata processing, their execution
    times and impacts on performance set them apart. Reflection operates dynamically
    at runtime, allowing for high flexibility but incurring a runtime performance
    cost. In contrast, annotation processors are used during compilation, enabling
    optimizations and catching errors before the code runs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入比较 Java 注解处理器和反射。虽然这两种机制都涉及用于元数据处理注解，但它们的执行时间和对性能的影响使它们有所不同。反射在运行时动态操作，提供了高灵活性，但会带来运行时性能成本。相比之下，注解处理器在编译时使用，允许优化并在代码运行之前捕获错误。
- en: The following table presents a concise comparison between reflection and Java
    Annotation Processors—two pivotal mechanisms in Java development. This comparison
    spans crucial aspects such as execution time, flexibility, performance, error
    detection, code generation capabilities, use cases, debugging implications, and
    overall usability. By juxtaposing these features, developers can gain valuable
    insights into when to leverage reflection’s dynamic runtime capabilities and opt
    for the static, compile-time analysis provided by Java Annotation Processors.
    This table aims to serve as a practical guide, empowering developers to make informed
    decisions based on the specific requirements of their projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下表简要比较了反射和 Java 注解处理器——Java 开发中的两个关键机制。该比较涵盖了关键方面，如执行时间、灵活性、性能、错误检测、代码生成能力、用例、调试影响和整体可用性。通过对比这些特性，开发者可以深入了解何时利用反射的动态运行时能力，并选择
    Java 注解处理器提供的静态、编译时分析。本表旨在作为实用指南，使开发者能够根据项目的具体要求做出明智的决定。
- en: '| **Feature** | **Reflection** | **Java Annotation** **Processors** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **反射** | **Java 注解处理器** |'
- en: '| --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Execution time | Runtime | Compile time |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 执行时间 | 运行时 | 编译时 |'
- en: '| Flexibility | Dynamic; allows runtime code inspection | Static, enforces
    analysis during compilation |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 灵活性 | 动态的；允许运行时代码检查 | 静态的，强制在编译时进行分析 |'
- en: '| Performance | May incur runtime overhead | Improved performance due to compile-time
    optimizations |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 可能产生运行时开销 | 由于编译时优化，性能得到提升 |'
- en: '| Error detection | Runtime errors possible | Early error detection during
    compilation |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 错误检测 | 可能存在运行时错误 | 编译时早期错误检测 |'
- en: '| Code generation | Limited capability for code generation | Robust support
    for code generation and manipulation |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 代码生成 | 代码生成能力有限 | 对代码生成和操作提供强大的支持 |'
- en: '| Use cases | Suitable for dynamic scenarios, e.g., frameworks and libraries
    | Preferred for static analysis, code generation, and project-wide optimizations
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 适用于动态场景，例如框架和库 | 适用于静态分析、代码生成和项目级优化 |'
- en: '| Debugging | May complicate debugging due to its dynamic nature | Compile-time
    analysis aids in cleaner debugging |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 由于其动态特性，可能使调试复杂化 | 编译时分析有助于更清晰的调试 |'
- en: '| Usability | Simple to use for basic introspection | Requires understanding
    of annotation processing and may involve more setup |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 可用性 | 基本反射简单易用 | 需要理解注解处理，可能涉及更多设置 |'
- en: '| Examples | `Class.forName()`, `Method.invoke()` | Frameworks such as Lombok,
    MapStruct, and Android’s Dagger use annotation processors extensively |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | `Class.forName()`、`Method.invoke()` | Lombok、MapStruct 和 Android 的 Dagger
    等框架广泛使用注解处理器 |'
- en: 'Table 11.1: Comparing reflection versus Java Annotation Processor'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1：比较反射与 Java 注解处理器
- en: This table provides a quick overview of the key differences between reflection
    and Java Annotation Processors across various aspects, aiding developers in choosing
    the most suitable approach for their specific use cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此表提供了对反射和Java注解处理器在多个方面关键差异的快速概述，帮助开发者根据他们的特定用例选择最合适的方案。
- en: Delving deeper into the trade-offs between Java Annotation Processors and reflection
    reveals a nuanced balance that developers must carefully consider. Reflection,
    with its dynamic nature, grants unparalleled flexibility by enabling runtime code
    inspection and modification.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨Java注解处理器与反射之间的权衡，揭示了开发者必须仔细考虑的微妙平衡。反射凭借其动态特性，通过允许运行时代码检查和修改，提供了无与伦比的灵活性。
- en: Contrastingly, Java Annotation Processors operate during the compilation phase,
    opting for a static analysis approach. While this sacrifices some runtime flexibility,
    it introduces several advantages. Early error detection becomes a notable benefit,
    as potential issues are identified before the code is executed, reducing the likelihood
    of runtime errors. The trade-off pays dividends in terms of improved performance
    since optimizations can be applied during compilation, resulting in more efficient
    and streamlined code execution. Furthermore, the static nature of annotation processors
    contributes to cleaner and more maintainable codebases, as developers can catch
    and rectify issues at an earlier stage in the development process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Java注解处理器在编译阶段运行，采用静态分析方法。虽然这牺牲了一些运行时灵活性，但它引入了几个优点。早期错误检测成为一项显著的好处，因为潜在的问题在代码执行之前就被识别出来，从而降低了运行时错误的可能性。权衡带来的回报在于改进了性能，因为优化可以在编译期间应用，从而实现更高效和流畅的代码执行。此外，注解处理器的静态特性有助于创建更干净、更易于维护的代码库，因为开发者可以在开发过程的早期阶段捕捉并纠正问题。
- en: Ultimately, the choice between Java Annotation Processors and reflection hinges
    on project requirements and priorities. Developers seeking a dynamic, flexible
    approach may opt for reflection despite the associated runtime costs. Meanwhile,
    those prioritizing early error detection, performance optimization, and maintainability
    may find that the trade-offs of adopting annotation processors align more closely
    with their project goals. Striking the right balance between runtime flexibility
    and static analysis is key to crafting robust, efficient, and maintainable Java
    applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Java注解处理器与反射之间的选择取决于项目需求和优先级。寻求动态、灵活方法的开发者可能会选择反射，尽管这会带来相关的运行时成本。与此同时，那些优先考虑早期错误检测、性能优化和可维护性的开发者可能会发现，采用注解处理器的权衡与他们的项目目标更为契合。在运行时灵活性和静态分析之间找到正确的平衡是构建健壮、高效和可维护的Java应用程序的关键。
- en: 'In the intricate world of frameworks, the Java Annotation Processor emerges
    as a game-changer, offering a paradigm shift in code analysis and generation compared
    to the runtime-centric nature of reflection. This processor operates dynamically
    during the build phase, providing frameworks with a potent toolset for enhanced
    performance, code optimization, and systematic project structuring:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架错综复杂的领域中，Java注解处理器成为了一个颠覆性的创新，与以运行时为中心的反射相比，它为代码分析和生成提供了一种范式转变。此处理器在构建阶段动态运行，为框架提供了一套强大的工具集，用于提高性能、代码优化和系统化项目结构：
- en: '**Load and parse configuration**: During the initial step, the Java Annotation
    Processor meticulously reads annotations and scrutinizes the project’s configuration
    at build time. This early analysis not only identifies annotations but also scans
    classes for relevant metadata, laying the foundation for subsequent processing
    steps.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载和解析配置**：在初始步骤中，Java注解处理器仔细读取注解并在构建时审查项目的配置。这种早期分析不仅识别注解，还扫描类以获取相关元数据，为后续处理步骤奠定基础。'
- en: '**Analyze dependencies**: One of the key strengths lies in the processor’s
    ability to analyze project dependencies based on the loaded classes dynamically.
    By scrutinizing these dependencies, the framework gains valuable insights into
    the components needed for seamless functionality, fostering a more efficient and
    streamlined development process.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析依赖关系**：处理器的一个关键优势在于其能够根据加载的类动态分析项目依赖关系。通过审查这些依赖关系，框架获得了对实现无缝功能所需组件的宝贵见解，从而促进更高效和流畅的开发过程。'
- en: '**Build dependency tree**: Armed with insights into project dependencies, the
    annotation processor constructs a comprehensive dependency tree. Based on loaded
    classes and their interdependencies, this data structure undergoes pre-processing,
    enabling the creation of intricate frameworks. The resulting structures serve
    as a blueprint for the framework’s architecture, ensuring that classes are orchestrated
    coherently and optimally.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建依赖树**：凭借对项目依赖关系的洞察，注解处理器构建了一个全面的依赖树。基于加载的类及其相互依赖关系，这个数据结构经过预处理，使得创建复杂的框架成为可能。这些结构成为框架架构的蓝图，确保类能够协调和优化地运行。'
- en: '**Package application**: After the annotation processor has diligently created
    classes and factored in the necessary libraries, the subsequent step involves
    packaging the application. Following the natural flow of the code, the framework
    compiles and generates bytecode. This process ensures the absence of reflection,
    enhances application robustness, and opens avenues for creating native applications,
    contributing to a more efficient and self-contained end product, as the following
    figure shows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包应用程序**：在注解处理器勤勉地创建类并考虑了必要的库之后，接下来的步骤是打包应用程序。遵循代码的自然流程，框架编译并生成字节码。这个过程确保了没有反射，增强了应用程序的健壮性，并为创建原生应用程序开辟了道路，如图所示，这有助于创建更高效和自包含的最终产品：'
- en: '![Figure 11.1: The Java perspective using Java Annotation Processor](img/B22030_11_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：使用Java注解处理器的Java视角](img/B22030_11_01.jpg)'
- en: 'Figure 11.1: The Java perspective using Java Annotation Processor'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：使用Java注解处理器的Java视角
- en: As we conclude this exploration into Java Annotation Processors, it becomes
    evident that their integration offers a transformative approach to code analysis,
    generation, and project structuring. The dichotomy between the reflection’s runtime
    dynamism and the Annotation Processor’s compile-time prowess reveals a spectrum
    of trade-offs, each catering to specific development needs. We’ve dissected the
    intricacies of annotation processing from a general and framework-centric standpoint,
    shedding light on the advantages and sacrifices inherent in this powerful tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对Java注解处理器的探索告一段落，其集成提供了一种变革性的代码分析、生成和项目结构的方法变得显而易见。反射的运行时动态性和注解处理器编译时能力的对比揭示了各种权衡，每一种都满足特定的开发需求。我们从一般和框架中心的角度剖析了注解处理，揭示了这一强大工具固有的优势和牺牲。
- en: Empowered with insights into the benefits of early error detection, improved
    performance, and cleaner, maintainable code, you are now better equipped to navigate
    the decision-making process in your development projects. Striking a balance between
    the dynamic capabilities of reflection and the performance optimizations afforded
    by annotation processors is key to crafting robust, efficient, and maintainable
    Java applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了早期错误检测的好处、改进的性能以及更干净、可维护的代码之后，您现在更有能力在开发项目中做出决策。在反射的动态能力和注解处理器提供的性能优化之间取得平衡是构建健壮、高效和可维护的Java应用程序的关键。
- en: To solidify your understanding, we encourage you to delve into practical exercises.
    Experiment with incorporating Java Annotation Processors into your projects, explore
    their code generation capabilities, and witness the advantages of compile-time
    analysis firsthand. Engage in the hands-on practice provided, and unlock a new
    dimension of efficiency and reliability in your Java development journey. Let
    the code speak, and may your exploration of Java Annotation Processors lead you
    to innovative and optimized solutions in your projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固您的理解，我们鼓励您深入实践。尝试将Java注解处理器融入您的项目中，探索它们的代码生成能力，并亲身体验编译时分析的优势。参与提供的动手实践，解锁Java开发旅程中效率和可靠性的新维度。让代码说话，愿您对Java注解处理器的探索能引导您在项目中找到创新和优化的解决方案。
- en: Exploring Practical Java Annotation Processor
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索实用的Java注解处理器
- en: In this hands-on segment, we’ll dive into a practical exercise to reinforce
    the concepts we’ve explored regarding Java Annotation Processors. The goal is
    to revisit a previously examined example that utilized reflection, enabling us
    to compare solutions and showcase the distinctive features and advantages of employing
    Java Annotation Processors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动手实践环节，我们将深入一个实际练习，以巩固我们关于Java注解处理器所探讨的概念。目标是回顾一个之前检查过的示例，该示例使用了反射，使我们能够比较解决方案并展示使用Java注解处理器的独特特性和优势。
- en: 'The task at hand involves converting a `Map` instance to an entity instance
    and vice versa, adhering to the specifications outlined in the provided interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当前任务涉及将`Map`实例转换为实体实例，反之亦然，遵循提供的接口中概述的规范：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By revisiting this familiar scenario, you’ll witness firsthand how annotation
    processors can streamline code generation and manipulation during compile time.
    As you undertake the practical exercises, consider the trade-offs, efficiencies,
    and benefits of annotation processors compared to reflection. Let’s dive into
    the code and explore the potential of Java Annotation Processors in this real-world
    example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回顾这个熟悉的场景，你将亲身体验注解处理器如何简化编译时的代码生成和操作。在你进行实际练习时，考虑注解处理器与反射相比的权衡、效率和好处。让我们深入代码，探索Java注解处理器在这个现实世界示例中的潜力。
- en: 'We introduce two additional annotations to augment the functionality in our
    specific context. The `Entity` annotation declares a class is mappable, indicating
    its eligibility for the parsing process. When applied to a class, this annotation
    communicates to the Java Annotation Processor that instances of the class can
    be seamlessly converted to and from `Map<String, Object>`. The added annotation
    enhances the clarity of the mapping process, ensuring effective communication
    between the class and the annotation processor during compilation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了两个额外的注解来增强我们特定上下文的功能。`Entity`注解声明一个类是可映射的，表明其有资格进行解析过程。当应用于一个类时，此注解通知Java注解处理器该类的实例可以无缝地转换为`Map<String,
    Object>`。添加的注解增强了映射过程的清晰度，确保在编译期间类和注解处理器之间进行有效通信：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `@Entity` annotation in Java has three annotations that define its behavior
    and characteristics: `@Documented`, `@Target(ElementType.TYPE)`, and `@Retention(RetentionPolicy.RUNTIME)`.
    The `@Documented` annotation ensures that its usage and presence are documented
    in JavaDocs. The `@Target(ElementType.TYPE)` annotation specifies that the `@Entity`
    annotation can only be applied to class declarations, indicating its role at the
    class level. Finally, the `@Retention(RetentionPolicy.RUNTIME)` annotation signifies
    that this annotation will be retained at runtime, allowing for dynamic access
    and reflection, which is essential for the Java Annotation Processor practice
    discussed in this chapter. Together, these annotations provide a clear framework
    for the `@Entity` annotation, making it well-documented, class-specific, and accessible
    at runtime, which is pivotal for code generation and metadata creation.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的`@Entity`注解有三个注解定义了其行为和特性：`@Documented`、`@Target(ElementType.TYPE)`和`@Retention(RetentionPolicy.RUNTIME)`。`@Documented`注解确保其使用和存在在JavaDocs中得到记录。`@Target(ElementType.TYPE)`注解指定`@Entity`注解只能应用于类声明，表明其在类级别上的角色。最后，`@Retention(RetentionPolicy.RUNTIME)`注解表示此注解将在运行时保留，允许进行动态访问和反射，这对于本章讨论的Java注解处理器实践至关重要。这些注解共同为`@Entity`注解提供了一个清晰的框架，使其文档齐全、类特定且在运行时易于访问，这对于代码生成和元数据创建至关重要。
- en: 'Like the `Entity` annotation, the `Column` annotation extends the customization
    capabilities to the property level. Applied to fields within an annotated class,
    it allows developers to override default property names during the conversion
    process. It becomes precious when dealing with diverse naming conventions, such
    as camel case, snake case, or kebab case, enhancing the adaptability of the class
    to different paradigms:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Entity`注解类似，`Column`注解将定制能力扩展到属性级别。应用于注解类中的字段，它允许开发者在转换过程中覆盖默认属性名称。当处理不同的命名约定时，如驼峰式、蛇形或短横线式，它变得非常宝贵，增强了类对不同范式的适应性：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will kickstart a Maven project that seamlessly incorporates Java and Mustache,
    empowering us to generate maintainable code dynamically during the build process.
    To integrate Mustache templates into our Java project, we’ll add the Mustache
    compiler as a dependency. Update the `pom.xml` file with the following dependency:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个 Maven 项目，该项目无缝地结合了 Java 和 Mustache，使我们能够在构建过程中动态地生成可维护的代码。要将 Mustache
    模板集成到我们的 Java 项目中，我们将 Mustache 编译器作为依赖项添加。使用以下依赖项更新 `pom.xml` 文件：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Mustache is a lightweight and powerful templating engine that developers use
    to generate dynamic content while keeping code logic and presentation separate.
    It provides a flexible and structured way to generate textual output, making it
    ideal for generating code, HTML, or other text-based formats. Mustache templates
    use placeholders, shown by double curly braces like `{{variable}}`. During rendering,
    these placeholders are replaced with real values or content.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache 是一个轻量级且强大的模板引擎，开发者使用它来生成动态内容，同时保持代码逻辑和展示的分离。它提供了一种灵活且结构化的方式来生成文本输出，使其非常适合生成代码、HTML
    或其他基于文本的格式。Mustache 模板使用双大括号 `{{variable}}` 来表示占位符。在渲染过程中，这些占位符会被实际值或内容所替换。
- en: In the context of our Maven project, we are incorporating Mustache to automate
    code generation. Specifically, we use it to create Java classes during the build
    process. By adding the Mustache compiler as a dependency in the project’s `pom.xml`
    file, we seamlessly integrate Mustache into our Java project. This integration
    empowers us to generate maintainable code dynamically, which improves efficiency
    and reduces the risk of human error when manually writing repetitive or boilerplate
    code. Mustache templates provide a structured and clean way to define the structure
    of the generated code, making it easier to maintain and adapt as project requirements
    evolve. Overall, Mustache plays a crucial role in streamlining code generation
    in our Java project, enhancing code quality, and developer productivity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Maven 项目上下文中，我们正在将 Mustache 集成进来以自动化代码生成。具体来说，我们使用它来在构建过程中创建 Java 类。通过在项目的
    `pom.xml` 文件中添加 Mustache 编译器作为依赖项，我们无缝地将 Mustache 集成到我们的 Java 项目中。这种集成使我们能够动态地生成可维护的代码，从而提高效率并减少手动编写重复或模板代码时的人为错误风险。Mustache
    模板提供了一种结构化和清晰的方式来定义生成代码的结构，使其更容易维护和适应项目需求的变化。总的来说，Mustache 在我们的 Java 项目中简化了代码生成流程，提高了代码质量和开发者生产力。
- en: 'In our journey to harness Java Annotation Processors’ power, we now implement
    the `EntityProcessor` class. Extending `AbstractProcessor`, this processor plays
    a crucial role in scanning and processing classes annotated with the `@``Entity`
    annotation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们利用 Java 注解处理器力量的旅途中，我们现在实现了 `EntityProcessor` 类。通过扩展 `AbstractProcessor`，这个处理器在扫描和处理带有
    `@Entity` 注解的类中扮演着至关重要的角色：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s dive into the `process` method, where the magic happens:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入到 `process` 方法，这里是魔法发生的地方：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this method, we initiate the processing of classes annotated with `@Entity`.
    Let’s break down the key components:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们开始处理带有 `@Entity` 注解的类。让我们分解关键组件：
- en: '**Scanning annotated elements**: We start by iterating over the set of **TypeElement**
    instances representing the annotation types (**annotations** parameter).'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扫描注解元素**：我们首先遍历代表注解类型（**annotations** 参数）的 **TypeElement** 实例集合。'
- en: '**Processing annotated elements**: For each annotation type, we use **roundEnv.getElementsAnnotatedWith(annotation)**
    to retrieve all program elements annotated with the specified annotation (in this
    case, **@Entity**).'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理注解元素**：对于每个注解类型，我们使用 **roundEnv.getElementsAnnotatedWith(annotation)**
    来检索所有带有指定注解（在这种情况下为 **@Entity**）的程序元素。'
- en: '**Mapping to ClassAnalyzer**: We convert the annotated elements into a stream
    and map each element to a **ClassAnalyzer** instance. **ClassAnalyzer** is a custom
    class designed to analyze and extract information from the annotated class.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**映射到 ClassAnalyzer**：我们将注解元素转换为流，并将每个元素映射到一个 **ClassAnalyzer** 实例。**ClassAnalyzer**
    是一个自定义类，用于分析和从注解类中提取信息。'
- en: '**Filtering blank results**: We then extract the analysis result from each
    **ClassAnalyzer** instance using **.map(ClassAnalyzer::get)**. After that, we
    filter out any blank or null entries from the list using **.filter(IS_NOT_BLANK)**.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过滤空白结果**：然后，我们使用 **.map(ClassAnalyzer::get)** 从每个 **ClassAnalyzer** 实例中提取分析结果。之后，我们使用
    **.filter(IS_NOT_BLANK)** 从列表中过滤掉任何空白或 null 条目。'
- en: '**Collecting results**: The non-blank results are collected into the **entities**
    list using **.forEach(entities::add)**.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收集结果**：使用**.forEach(entities::add)**将非空结果收集到**entities**列表中。'
- en: '**Further processing logic**: The method serves as a foundation for any additional
    processing logic. Developers can extend this part to include custom actions based
    on the extracted entities.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进一步处理逻辑**：该方法作为任何附加处理逻辑的基础。开发者可以扩展这部分以包括基于提取实体的自定义操作。'
- en: This `process` method forms the core of our annotation processing logic. It
    scans, analyzes, and collects information from classes annotated with `@Entity`,
    providing a flexible and extensible mechanism for code generation and manipulation.
    Let’s continue our exploration and delve into the additional processing steps
    that can be integrated into this method to tailor it to our project’s specific
    requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`process`方法构成了我们注解处理逻辑的核心。它扫描、分析和从带有`@Entity`注解的类中收集信息，提供了一个灵活且可扩展的机制，用于代码生成和操作。让我们继续我们的探索，深入了解可以集成到这个方法中的附加处理步骤，以适应我们项目的特定需求。
- en: 'In the intricate process of analyzing an entity class annotated with `@Entity`,
    `ClassAnalyzer` plays a pivotal role. It scrutinizes each field within the class,
    employing a collaborative effort with `FieldAnalyzer` for a detailed examination:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析带有`@Entity`注解的实体类的复杂过程中，`ClassAnalyzer`扮演着关键角色。它仔细检查类中的每个字段，并与`FieldAnalyzer`协作进行详细检查：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the code is explained in more depth:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码被更深入地解释：
- en: '**Field analysis**: The heart of the **analyze** method lies in extracting
    fields from the given **TypeElement**. Using **processingEnv.getElementUtils()**,
    it retrieves all members of the class and filters them to include only fields
    annotated with **@Column**. **FieldAnalyzer** is instantiated for each field,
    allowing for detailed analysis.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字段分析**：**analyze**方法的核心在于从给定的**TypeElement**中提取字段。使用**processingEnv.getElementUtils()**，它检索类的所有成员，并过滤出仅带有**@Column**注解的字段。为每个字段实例化**FieldAnalyzer**，以便进行详细分析。'
- en: '**FieldAnalyzer collaboration**: The creation of **FieldAnalyzer** for each
    field involves passing the field (**f**), the processing environment (**processingEnv**),
    and the type element of the entity class (**typeElement**). This collaborative
    effort with **FieldAnalyzer** enables an in-depth examination of each field.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**FieldAnalyzer协作**：为每个字段创建**FieldAnalyzer**涉及传递字段（**f**）、处理环境（**processingEnv**）和实体类的类型元素（**typeElement**）。这种与**FieldAnalyzer**的协作努力使得对每个字段进行深入考察成为可能。'
- en: '**Metadata extraction**: The **getMetadata** method is then invoked to obtain
    metadata for the entity class. This metadata likely includes information about
    the class itself and the fields discovered during the analysis.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**元数据提取**：随后调用**getMetadata**方法以获取实体类的元数据。这些元数据可能包括有关类本身以及分析期间发现的字段的信息。'
- en: '**Class creation**: The **createClass** method is called, indicating that the
    Entity class is being generated based on the metadata. This step is crucial for
    code generation and manipulation based on the analyzed class.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类创建**：调用**createClass**方法，表示基于元数据正在生成实体类。这一步对于基于分析过的类的代码生成和操作至关重要。'
- en: '**Logging information**: Logging statements, facilitated by the **LOGGER**
    instance, provide visibility into the discovered fields and their association
    with the class. It aids in tracking and understanding the analysis process.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录信息**：通过**LOGGER**实例提供的日志语句，可以提供对发现字段及其与类的关联的可见性。它有助于跟踪和理解分析过程。'
- en: '**Return statement**: The method concludes by returning the qualified name
    of the analyzed entity class. This information may be useful for further processing
    or reporting.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**返回语句**：该方法通过返回分析过的实体类的限定名称结束。这些信息可能对进一步处理或报告有用。'
- en: This collaborative interaction between `ClassAnalyzer` and `FieldAnalyzer` encapsulates
    the essence of thorough entity class analysis. As part of the broader annotation
    processing framework, it sets the stage for subsequent actions, such as code generation,
    metadata extraction, and logging. As we delve deeper into the book, we’ll uncover
    more intricacies of the analysis process and its impact on the development workflow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassAnalyzer`和`FieldAnalyzer`之间的这种协作交互封装了彻底实体类分析的本质。作为更广泛的注解处理框架的一部分，它为后续操作，如代码生成、元数据提取和日志记录，奠定了基础。随着我们深入本书，我们将揭示分析过程及其对开发工作流程影响的更多复杂性。'
- en: 'In code generation, the choice of tools can significantly impact the maintainability
    and flexibility of the generated code. One standout approach embraced in the entity
    class generation process is the utilization of Mustache templates. Let’s explore
    the virtues of leveraging Mustache for class generation and why it surpasses manual
    text concatenation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码生成过程中，工具的选择可以显著影响生成代码的可维护性和灵活性。在实体类生成过程中，一个突出的方法就是利用 Mustache 模板。让我们来探讨利用
    Mustache 进行类生成的优点以及为什么它优于手动文本连接：
- en: '**Declarative templating**: Mustache provides a declarative and template-based
    approach to code generation. Rather than manually concatenating strings to construct
    classes, developers can define templates using Mustache syntax. This approach
    aligns with a more intuitive and maintainable way of expressing generated code
    structure.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式模板**：Mustache 提供了一种基于声明和模板的代码生成方法。而不是手动连接字符串来构建类，开发者可以使用 Mustache 语法定义模板。这种方法与更直观、更易于维护的表达生成代码结构的方式相一致。'
- en: '**Readability and maintainability**: Mustache templates enhance the readability
    of generated code. By separating the template from the actual code, developers
    can focus on the logical structure of the class without being entangled in intricate
    string concatenation. This separation improves code maintainability and reduces
    the chances of introducing errors during manual text manipulation.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性和可维护性**：Mustache 模板增强了生成代码的可读性。通过将模板与实际代码分离，开发者可以专注于类的逻辑结构，而无需陷入复杂的字符串连接。这种分离提高了代码的可维护性，并减少了在手动文本操作中引入错误的可能性。'
- en: '**Dynamic data binding**: Mustache supports dynamic data binding, allowing
    the injection of data into templates during the generation process. This dynamic
    nature enables the adaptation of generated code based on varying inputs or metadata
    obtained during the analysis phase. In contrast, manual concatenation lacks this
    level of flexibility.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态数据绑定**：Mustache 支持动态数据绑定，允许在生成过程中将数据注入到模板中。这种动态特性使得根据不同的输入或分析阶段获得的元数据来调整生成代码成为可能。相比之下，手动连接缺乏这种灵活性。'
- en: '**Consistency across generations**: Mustache templates provide a standardized
    and consistent approach to code generation. Templates can be reused across different
    entities, ensuring a uniform structure for generated classes. This consistency
    simplifies the maintenance of templates and promotes a cohesive code-generation
    strategy.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成的一致性**：Mustache 模板提供了标准化和一致的代码生成方法。模板可以在不同的实体之间重用，确保生成类的结构一致。这种一致性简化了模板的维护，并促进了统一的代码生成策略。'
- en: '**Seamless integration with Java**: Mustache has robust support for integration
    with Java. By incorporating Mustache into the code generation process, developers
    can seamlessly combine the power of Java logic with the clarity of Mustache templates.
    This synergy results in a more natural and expressive generation workflow.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与 Java 的无缝集成**：Mustache 对 Java 的集成提供了强大的支持。通过将 Mustache 纳入代码生成过程，开发者可以无缝地将
    Java 逻辑的强大功能与 Mustache 模板的清晰性结合起来。这种协同作用产生了一个更自然、更富有表现力的生成工作流程。'
- en: '**Avoidance of string manipulation pitfalls**: Manual string concatenation
    for code generation can introduce pitfalls, such as formatting errors, typos,
    or unintended variations in code structure. Mustache eliminates these risks by
    providing a higher-level abstraction that mitigates the need for meticulous string
    manipulation.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免字符串操作陷阱**：用于代码生成的手动字符串连接可能会引入陷阱，如格式错误、拼写错误或代码结构的不当变化。Mustache 通过提供一种高级抽象来消除这些风险，从而减轻了对细致入微的字符串操作的需求。'
- en: In essence, leveraging Mustache for class generation introduces a paradigm shift
    in the approach to code generation. It promotes clarity, maintainability, and
    flexibility, offering a superior alternative to manual text concatenation’s error-prone
    and cumbersome nature. As we progress in our exploration of annotation processing
    and code generation, the integration of Mustache templates will continue to showcase
    its prowess in enhancing the efficiency and reliability of our development workflow.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，利用 Mustache 进行类生成在代码生成方法上引入了一种范式转变。它促进了清晰性、可维护性和灵活性，为手动文本连接的易出错和繁琐特性提供了一个更优越的替代方案。随着我们进一步探索注解处理和代码生成，Mustache
    模板的集成将继续展示其在提高我们的开发工作流程效率和可靠性方面的能力。
- en: 'The provided Mustache template, combined with `EntityModel` to generate an
    entity class, showcases the elegance and clarity Mustache brings to code generation.
    Let’s delve into the key aspects of this template:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的Mustache模板与`EntityModel`结合生成实体类，展示了Mustache在代码生成中带来的优雅和清晰。让我们深入探讨这个模板的关键方面：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this Mustache template, a Java class implementing the `EntityMetadata` interface
    is dynamically generated. The placeholders `{{packageName}}` and `{{className}}`
    will be replaced during code generation. The class includes a list of `FieldMetadata`
    objects representing entity fields, and the constructor initializes these fields.
    This template streamlines code generation, enhancing clarity and maintainability
    by automating the creation of metadata classes in Java projects. Here, we explain
    the template in more depth:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Mustache模板中，动态生成一个实现`EntityMetadata`接口的Java类。占位符`{{packageName}}`和`{{className}}`将在代码生成过程中被替换。该类包含一个表示实体字段的`FieldMetadata`对象列表，构造函数初始化这些字段。此模板简化了代码生成过程，通过自动化Java项目中元数据类的创建，提高了清晰度和可维护性。以下是对模板的更深入解释：
- en: '**Package declaration**: The **{{packageName}}** placeholder dynamically injects
    the package name obtained from **EntityModel**. It ensures that the generated
    entity class resides in the correct package.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包声明**：**包声明**中的**{{packageName}}**占位符动态注入从**EntityModel**获取的包名。它确保生成的实体类位于正确的包中。'
- en: '**Imports and annotations**: The template includes necessary imports and annotations,
    such as **import java.util.List;**, **import java.util.Map;**, and **@Generated**.
    The **@Generated** annotation includes metadata indicating the generator tool
    and the generation date.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入和注解**：模板包括必要的导入和注解，例如**import java.util.List;**、**import java.util.Map;**和**@Generated**。**@Generated**注解包含指示生成工具和生成日期的元数据。'
- en: '**Class declaration**: The **{{className}}** placeholder injects the name of
    the generated class (**EntityModel#getClassName()**). The class implements the
    **EntityMetadata** interface, ensuring adherence to the specified contract.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类声明**：**{{className}}**占位符注入生成的类名（**EntityModel#getClassName()**）。该类实现了**EntityMetadata**接口，确保遵守指定的契约。'
- en: '**Fields initialization**: The constructor initializes the **fields** list
    with instances of **FieldMetadata**. The list is populated based on the fields
    defined in **EntityModel**. This dynamic initialization ensures that the generated
    class includes metadata for each field.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段初始化**：构造函数使用**FieldMetadata**实例初始化**fields**列表。列表基于**EntityModel**中定义的字段进行填充。这种动态初始化确保生成的类包含每个字段的元数据。'
- en: '**EntityMetadata implementation**: The template implements various methods
    defined in the **EntityMetadata** interface. These methods provide information
    about the entity class, such as its name, class instance, fields, and mappings.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EntityMetadata实现**：模板实现了**EntityMetadata**接口中定义的各种方法。这些方法提供了有关实体类的信息，例如其名称、类实例、字段和映射。'
- en: '**FieldMetadata generation**: The **{{#fields}}** section dynamically generates
    code for each field. It creates instances of the corresponding **FieldMetadata**
    for each field, adding them to the **fields** list during class instantiation.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FieldMetadata生成**：**{{#fields}}**部分动态为每个字段生成代码。它为每个字段创建相应的**FieldMetadata**实例，并在类实例化过程中将它们添加到**fields**列表中。'
- en: '**Date and generator information**: The **@Generated** annotation includes
    information about the generator tool (**EntityMetadata Generator**) and the date
    of generation (**{{now}}**). This metadata aids in tracking the origin and timing
    of the class generation.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期和生成信息**：**@Generated**注解包含有关生成工具（**EntityMetadata Generator**）和生成日期（**{{now}}**）的信息。这些元数据有助于跟踪类生成的来源和时间。'
- en: In essence, Mustache allows for creating a clean and maintainable template where
    placeholders seamlessly integrate with the data provided by `EntityModel`. This
    template-driven approach enhances the readability of the generated code and promotes
    consistency across different entities. As we progress, the flexibility of Mustache
    will continue to shine, allowing for further customization and adaptation to specific
    project requirements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mustache允许创建一个干净且易于维护的模板，其中占位符与`EntityModel`提供的数据无缝集成。这种以模板驱动的做法提高了生成代码的可读性，并促进了不同实体之间的一致性。随着我们的进展，Mustache的灵活性将继续闪耀，允许进行进一步的定制和适应特定项目需求。
- en: 'In the fascinating journey of annotation processing and code generation, the
    pivotal moment arrives when we transform the analyzed entity metadata into tangible
    Java source code. This crucial step is orchestrated by the `createClass` method,
    which seamlessly combines the information from `EntityModel` with the expressive
    power of the Mustache template:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在注解处理和代码生成的迷人旅程中，当我们把分析过的实体元数据转化为实际的 Java 源代码时，关键的瞬间到来了。这一关键步骤由 `createClass`
    方法协调，它无缝地将 `EntityModel` 的信息与 Mustache 模板的表达能力结合起来：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method, `createClass`, is a pivotal component of the Java Annotation Processor,
    responsible for generating source code dynamically. It takes `Element`, which
    represents the annotated class (`entity`), and `EntityModel`, which contains metadata
    for code generation (`metadata`). Utilizing `Filer` from the processing environment,
    it creates `JavaFileObject` for the specified qualified name of the generated
    class. The method then opens a writer for the file and executes the Mustache template
    (`template`) by passing in the writer and the metadata. Ultimately, this process
    ensures the generation of source code for the annotated class with the corresponding
    metadata, contributing to the power and flexibility of the Java Annotation Processor.
    Here, the code is explained in more depth:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法，`createClass`，是 Java 注解处理器的一个关键组件，负责动态生成源代码。它接受 `Element`，代表被注解的类（`entity`），以及包含代码生成元数据的
    `EntityModel`（`metadata`）。利用来自处理环境的 `Filer`，它为生成的类的指定限定名称创建 `JavaFileObject`。然后，该方法为文件打开一个写入器，并通过传递写入器和元数据来执行
    Mustache 模板（`template`）。最终，这个过程确保为带有相应元数据的注解类生成源代码，为 Java 注解处理器的强大和灵活性做出了贡献。在这里，代码被更深入地解释：
- en: '**Acquiring the filer**: We obtain the **Filer** instance from the annotation
    processing environment. **Filer** is our gateway to file creation within the build
    process.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取 filer**：我们从注解处理环境获取 **Filer** 实例。**Filer** 是我们在构建过程中创建文件的门户。'
- en: '**Creating a source file**: The **filer.createSourceFile(metadata.getQualified(),
    entity)** line orchestrates the creation of a new source file. The fully qualified
    name (**metadata.getQualified()**) provides a unique identity for the generated
    class, and the reference to the original **entity** ensures a connection between
    the generated and original entities.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建源文件**：**filer.createSourceFile(metadata.getQualified(), entity)** 这行代码协调创建一个新的源文件。完全限定的名称（**metadata.getQualified()**）为生成的类提供了一个唯一的标识，对原始**实体**的引用确保了生成实体与原始实体之间的连接。'
- en: '**Opening a writer**: The code gracefully opens a writer for the newly created
    source file as we write the generated content. **try (Writer writer = fileObject.openWriter())**
    automatically closes the writer after its scope is executed.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开写入器**：当我们编写生成的内容时，代码优雅地打开一个用于新创建源文件的写入器。**try (Writer writer = fileObject.openWriter())**
    在其作用域执行完毕后自动关闭写入器。'
- en: '**Mustache magic**: The real magic unfolds with **template.execute(writer,
    metadata)**. This line triggers the Mustache engine to interpret the template,
    injecting the data from **EntityModel** (**metadata**) into the placeholders.
    The result is a dynamically generated entity class.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Mustache 魔法**：真正的魔法在 **template.execute(writer, metadata)** 这行代码中展开。这行代码触发了
    Mustache 引擎来解释模板，将 **EntityModel**（**metadata**）中的数据注入到占位符中。结果是动态生成的实体类。'
- en: '**Automatic Resource Management (ARM)**: Thanks to Java’s ARM, the opened writer
    is automatically closed, mitigating the risk of resource leaks and contributing
    to cleaner, more robust code.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动资源管理 (ARM)**：得益于 Java 的 ARM，打开的写入器会自动关闭，从而减轻资源泄露的风险，有助于编写更干净、更健壮的代码。'
- en: This method encapsulates the alchemy of transforming metadata into tangible
    code. The Mustache template acts as a dynamic blueprint, allowing for flexibility
    and maintainability in code generation. As we progress in our exploration, the
    generated entity classes will come to life, reflecting the richness of metadata
    analysis and the efficiency of code generation in our annotation processing adventure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法封装了将元数据转化为可触摸代码的炼金术。Mustache 模板充当一个动态蓝图，允许在代码生成过程中保持灵活性和可维护性。随着我们探索的深入，生成的实体类将变得生动起来，反映了元数据分析的丰富性和我们在注解处理冒险中代码生成的效率。
- en: 'As we venture into the testing phase of our annotation processor, we find ourselves
    at the crossroads of dependency management. We will explore two approaches for
    including the processor in our Maven project: one employs the `provided` scope
    and the other utilizes the `annotationProcessorPaths` configuration within the
    Maven Compiler Plugin.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入注解处理器的测试阶段时，我们发现自己处于依赖管理的十字路口。我们将探讨两种将处理器包含到我们的Maven项目中的方法：一种使用`提供的`作用域，另一种在Maven编译插件中使用`annotationProcessorPaths`配置。
- en: 'The first option is to use the `provided` scope:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是使用`提供的`作用域：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach declares the processor dependent on the `provided` scope. It signifies
    that the processor will be available during compilation but not bundled with the
    final application. It is a suitable choice when the processor’s functionality
    is strictly needed at compile time and not runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法声明处理器依赖于`提供的`作用域。这表示处理器将在编译时可用，但不会包含在最终应用程序中。当处理器功能严格需要编译时而不是运行时，这是一个合适的选择。
- en: 'The second option is to leverage `annotationProcessorPaths`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是利用`annotationProcessorPaths`：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternatively, we can leverage the `annotationProcessorPaths` configuration
    within the Maven Compiler Plugin. This approach provides a more direct integration
    with the compiler, ensuring the processor is available during compilation without
    being included in the final artifact. It offers a more explicit declaration of
    the annotation processor’s role in the compilation workflow.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以利用Maven编译插件中的`annotationProcessorPaths`配置。这种方法提供了与编译器的更直接集成，确保处理器在编译时可用，而不会包含在最终工件中。它提供了对注解处理器在编译工作流程中角色的更明确声明。
- en: 'Please, once you go to this approach, consider the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦你采用这种方法，请考虑以下内容：
- en: Use the **provided** scope when you want the processor for compilation only
    and not as part of the runtime dependencies
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只想让处理器用于编译而不是作为运行时依赖的一部分时，请使用**提供的**作用域。
- en: Utilize **annotationProcessorPaths** when you prefer a configuration-centric
    approach, directly specifying annotation processors for the compiler plugin
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你更喜欢以配置为中心的方法时，直接指定编译插件的注解处理器，请使用**annotationProcessorPaths**。
- en: Now, we dive into a practical example of using our annotation processor by annotating
    a class and witnessing the magic unfold during the build process.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过注解一个类并观察构建过程中的魔法展开来深入了解我们注解处理器的实际应用示例。
- en: 'Consider the following `Animal` class adorned with our custom annotations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下带有我们自定义注解的`Animal`类：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This simple class represents an animal, with annotations indicating the entity
    name and specific details about the fields. At the build time, thanks to our Annotation
    Processor, classes such as `AnimalEntityMetaData`, `AnimalNameFieldMetaData`,
    and `AnimalColorFieldMetaData` are generated based on the annotated class and
    its fields.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的类代表一个动物，通过注释说明了实体名称和关于字段的详细信息。在构建时，得益于我们的注解处理器，基于注解的类及其字段会生成诸如`AnimalEntityMetaData`、`AnimalNameFieldMetaData`和`AnimalColorFieldMetaData`之类的类。
- en: 'Let’s take a closer look at the generated `AnimalEntityMetaData` class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看生成的`AnimalEntityMetaData`类：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class serves as metadata for the `Animal` entity, providing information
    about its name, class, fields, and more. Notably, it includes instances of `FieldMetadata`
    for each field in the `Animal` class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类作为`Animal`实体的元数据，提供了有关其名称、类、字段等信息。值得注意的是，它包括`Animal`类中每个字段的`FieldMetadata`实例。
- en: 'Here, we will look at the generated code in more depth:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将更深入地查看生成的代码：
- en: '**Constructor initialization**: In the constructor, instances of FieldMetadata
    (such as AnimalNameFieldMetaData and AnimalColorFieldMetaData) are added to the
    fields list. This initialization captures the metadata for each field defined
    in the Animal class.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数初始化**：在构造函数中，FieldMetadata的实例（如AnimalNameFieldMetaData和AnimalColorFieldMetaData）被添加到字段列表中。这种初始化捕获了Animal类中定义的每个字段的元数据。'
- en: '**Implementation of EntityMetadata Methods**: The generated class implements
    methods defined in the EntityMetadata interface. These methods enable the retrieval
    of information such as the entity name, class instance, fields, and more.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体元数据方法的实现**：生成的类实现了在实体元数据接口中定义的方法。这些方法使得检索有关实体名称、类实例、字段等信息成为可能。'
- en: '**Annotations for code generation**: The @Generated annotation includes details
    about the generation process, such as the tool used (“EntityMetadata Generator”)
    and the date of generation.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成注解**：`@Generated`注解包含了有关生成过程的信息，例如使用的工具（“EntityMetadata Generator”）和生成日期。'
- en: 'In the target directory at build time, the generated classes are organized,
    showcasing the dynamic nature of code generation. Each field in the original `Animal`
    class contributes to creating a corresponding metadata class as the following
    figure shows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时的目标目录中，生成的类被组织起来，展示了代码生成的动态性。原始`Animal`类中的每个字段都贡献于创建相应的元数据类，如下图所示：
- en: '![Figure 11.2: The classes generated at build time](img/B22030_11_02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：构建时生成的类](img/B22030_11_02.jpg)'
- en: 'Figure 11.2: The classes generated at build time'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：构建时生成的类
- en: In this hands-on exploration of annotation processors, we’ve witnessed the transformative
    capabilities they bring to Java development. The practice code exemplifies how,
    with a sprinkle of annotations, we can orchestrate the generation of intricate
    metadata, propelling our projects to new heights of efficiency and maintainability.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对注解处理器的实际探索中，我们见证了它们为Java开发带来的变革能力。实践代码展示了如何通过添加一些注解，我们可以编排复杂元数据的生成，推动我们的项目达到新的效率和可维护性高度。
- en: 'The annotated `Animal` class served as our canvas, adorned with custom annotations
    such as `@Entity` and `@Id`. As the build process unfolded, our custom annotation
    processor worked diligently behind the scenes, crafting a symphony of metadata
    classes: `AnimalEntityMetaData`, `AnimalNameFieldMetaData`, and `AnimalColorFieldMetaData`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 被注解的`Animal`类是我们的画布，装饰着诸如`@Entity`和`@Id`之类的自定义注解。随着构建过程的展开，我们的自定义注解处理器在幕后勤奋地工作，制作出一曲元数据类的交响乐：`AnimalEntityMetaData`、`AnimalNameFieldMetaData`和`AnimalColorFieldMetaData`。
- en: 'Here is what we unveiled in this process:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们揭露了以下内容：
- en: '**Dynamic metadata generation**: The generated metadata classes dynamically
    adapt to the annotated class’s structure, showcasing annotation processors’ flexibility
    and adaptability.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态元数据生成**：生成的元数据类能够动态地适应被注解类的结构，展示了注解处理器的灵活性和适应性。'
- en: '**Efficient code organization**: Our codebase remains clean and concise by
    automating metadata generation. Boilerplate code is replaced with dynamically
    crafted classes, fostering better organization and readability.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效的代码组织**：通过自动化元数据生成，我们的代码库保持整洁和简洁。样板代码被动态构建的类所取代，促进了更好的组织和可读性。'
- en: '**Build-time magic**: The magic happens at build time. Annotation processors
    provide a robust mechanism to analyze and generate code before the application
    runs, enhancing performance and eliminating runtime reflection costs.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时魔法**：这种魔法发生在构建时。注解处理器提供了一种强大的机制，在应用程序运行之前分析和生成代码，从而提高性能并消除运行时反射成本。'
- en: '**Customization at scale**: Annotations empower developers to convey intent
    and customization preferences. Our annotation processor translates this intent
    into tangible metadata, providing a powerful avenue for large-scale codebase management.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大规模定制**：注解赋予开发者传达意图和定制偏好的能力。我们的注解处理器将这种意图转化为可触摸的元数据，为大规模代码库管理提供了一条强大的途径。'
- en: As we reflect on this practice, we’ve just scratched the surface of the potential
    annotation processors offer. The journey ahead invites us to explore advanced
    scenarios, tackle real-world challenges, and harness the full spectrum of customization
    options. Annotation processors emerge as tools for code generation and catalysts
    for a paradigm shift in how we architect and maintain our Java projects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾这一实践时，我们只是刚刚触及了注解处理器所能提供的潜力。前方的旅程邀请我们探索更高级的场景，应对现实世界的挑战，并充分利用定制选项的全谱。注解处理器成为代码生成工具，并催化了我们在架构和维护Java项目时的范式转变。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In concluding our journey through annotation processors, we’ve explored the
    art of code generation and the elegance they bring to Java development. From annotated
    classes to dynamic metadata, we’ve witnessed the transformative power of automation.
    As we transition to the final considerations, the next chapter serves as a compass,
    guiding us through best practices, potential pitfalls, and strategic insights
    into the broader landscape of Java development.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过注解处理器的旅程中结束之际，我们探讨了代码生成的艺术以及它们为 Java 开发带来的优雅。从注解类到动态元数据，我们见证了自动化的变革力量。随着我们过渡到最终的考虑因素，下一章充当指南针，引导我们了解最佳实践、潜在陷阱以及
    Java 开发更广泛领域的战略洞察。
- en: Our exploration has armed us with the tools to wield annotation processors effectively.
    Join us in the concluding chapter as we distill vital insights and chart a course
    for the future. The final considerations encapsulate the essence of our annotation
    processor odyssey, offering a roadmap for mastering these tools and shaping the
    trajectory of Java development. Let’s embark on this last leg of our journey together.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的探索使我们拥有了有效使用注解处理器的工具。加入我们，在最后一章中，我们将提炼关键见解并规划未来之路。最终的考虑因素概括了我们的注解处理器之旅的精髓，为掌握这些工具和塑造
    Java 开发的轨迹提供了路线图。让我们共同踏上这段旅程的最后一段。
- en: Questions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: What is the primary role of the Java Annotation Processor introduced in this
    chapter?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中介绍的 Java 注解处理器的主要角色是什么？
- en: Dynamic code execution
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态代码执行
- en: Code compilation at runtime
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时代码编译
- en: Metadata analysis and code generation
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元数据分析和代码生成
- en: User interface design
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户界面设计
- en: In the context of Java Annotation Processors, what is the purpose of the **@****SupportedAnnotationTypes**
    annotation?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 注解处理器的上下文中，**@SupportedAnnotationTypes** 注解的目的是什么？
- en: Declaring runtime retention
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明运行时保留
- en: Indicating compiler paths
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示编译器路径
- en: Specifying supported annotations
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定支持的注解
- en: Defining annotation inheritance
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义注解继承
- en: What is the advantage of using Java Annotation Processors over reflection, as
    discussed in the chapter?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中讨论的，使用 Java 注解处理器而不是反射的优势是什么？
- en: Greater runtime flexibility
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更大的运行时灵活性
- en: Improved performance and early error detection
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进性能和早期错误检测
- en: Simplified code inspection
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化的代码检查
- en: Enhanced debugging capabilities
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强的调试能力
- en: Which Maven scope indicates that a dependency should be available only during
    compilation and not included in the runtime dependencies?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Maven 范围表示依赖项仅在编译期间可用，而不包含在运行时依赖项中？
- en: '**compile**'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译**'
- en: '**runtime**'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时**'
- en: '**provided**'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提供**'
- en: '**annotationProcessor**'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注解处理器**'
- en: What is the primary purpose of the Mustache template in the context of the Java
    Annotation Processor practice session?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 注解处理器实践课程中，Mustache 模板的主要目的是什么？
- en: Generating random code snippets
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成随机代码片段
- en: Creating JavaDoc documentation
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 JavaDoc 文档
- en: Enabling code concatenation
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用代码连接
- en: Facilitating maintainable code generation
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 促进可维护的代码生成
- en: Which Maven configuration allows specifying annotation processors directly for
    the Compiler Plugin?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Maven 配置允许直接为编译插件指定注解处理器？
- en: '**<****annotationPaths>**'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<注解路径>**'
- en: '**<****annotationProcessors>**'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<注解处理器>**'
- en: '**<****annotationProcessorPaths>**'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<注解处理器路径>**'
- en: '**<****compilerAnnotations>**'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<编译器注解>**'
- en: Answers
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章问题的答案：
- en: C. Metadata analysis and code generation
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 元数据分析和代码生成
- en: C. Specifying supported annotations
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 指定支持的注解
- en: B. Improved performance and early error detection
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 改进性能和早期错误检测
- en: C. **provided**
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. **提供**
- en: D. Facilitating maintainable code generation
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 促进可维护的代码生成
- en: C. **<annotationProcessorPaths>**
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. **<注解处理器路径>**
