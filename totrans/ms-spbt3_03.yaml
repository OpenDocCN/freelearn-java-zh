- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Reactive REST Development and Asynchronous Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式 REST 开发和异步系统
- en: Up to this chapter, we have built our theoretical base with microservice and
    **Spring Boot 3.0** capabilities. Now, it is time to get our hands dirty. We will
    learn and practice **reactive programming** with Spring Boot 3.0\. We will go
    over the instructions and build our first reactive REST application. We are also
    going to discuss **backpressure** and how it can help our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经利用微服务和 **Spring Boot 3.0** 的功能构建了我们的理论基础。现在，是时候动手实践了。我们将学习并使用 Spring
    Boot 3.0 进行反应式编程。我们将回顾说明并构建我们的第一个反应式 REST 应用程序。我们还将讨论 **背压**以及它如何帮助我们的应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing reactive programming basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程基础知识介绍
- en: Building a reactive REST API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建反应式 REST API
- en: Asynchronous systems and backpressure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步系统和背压
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we are going to need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要以下内容：
- en: '`JAVA_HOME` environment variable is set to the JDK 17 directory and that your
    PATH includes the bin directory of JDK 17'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JAVA_HOME` 环境变量设置为 JDK 17 目录，并且您的 PATH 包含 JDK 17 的 bin 目录'
- en: 'A modern **integrated development environment** (**IDE**): I recommend IntelliJ
    IDEA:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代的 **集成开发环境**（**IDE**）：我推荐 IntelliJ IDEA：
- en: '**Download IntelliJ IDEA**: Visit the JetBrains website and choose the edition
    you prefer (Community or Ultimate).'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载 IntelliJ IDEA**: 访问 JetBrains 网站，选择您喜欢的版本（社区版或终极版）。'
- en: '**Run the installer**: Once downloaded, run the installer and follow the instructions.
    Choose the settings and plugins that suit your needs.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行安装程序**：下载后，运行安装程序并按照说明操作。选择适合您需求的设置和插件。'
- en: '**Launch IntelliJ IDEA**: After installation, open IntelliJ IDEA to configure
    it further as needed and familiarize yourself with the interface.*   **GitHub
    repository**:'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动 IntelliJ IDEA**：安装后，打开 IntelliJ IDEA 并根据需要进一步配置它，熟悉其界面。*   **GitHub 仓库**：'
- en: The code for the *Building a reactive REST API* section is available at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Building_Reactive_REST_API](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Building_Reactive_REST_API)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建反应式 REST API*部分的代码可在[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Building_Reactive_REST_API](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Building_Reactive_REST_API)找到'
- en: The code for the *Asynchronous systems and backpressure* section is available
    at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Implement_back-pressure](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Implement_back-pressure)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步系统和背压*部分的代码可在[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Implement_back-pressure](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Implement_back-pressure)找到'
- en: Please download or clone the code and follow the content through these repositories*   **Curl
    Installation:**
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请下载或克隆代码，并按照这些仓库的内容进行操作*   **Curl 安装：**
- en: Please find the installation packet for your operating system and download the
    related packet from [https://curl.se/download.html](https://curl.se/download.html)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请从[https://curl.se/download.html](https://curl.se/download.html)下载您操作系统的安装包
- en: Follow the instructions to install it on your local machine
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照说明在您的本地机器上安装它
- en: Introduction to reactive programming
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程简介
- en: Speaking of the basics of reactive programming, firstly, I would like to say
    that no solution/approach can fit each need. So, the projects have different problems
    and according to the problem, there are different solutions. One of them is the
    **reactive programming approach**. Here, we are going to learn how to make our
    applications more responsive, efficient, and robust in the face of specific requirements
    such as handling a huge number of requests and providing fast responses. As we
    work through the concepts and practices, you’ll see how this approach can fundamentally
    change the nature of the application you can build – making them fully prepared
    for the challenges posed by real-time user expectations and high data throughput.
    In the following section, we take a look at some of the basics of reactive programming.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到响应式编程的基础，首先，我想说的是，没有任何解决方案/方法可以满足每一个需求。因此，项目有不同的问题，根据问题，有不同的解决方案。其中之一是**响应式编程方法**。在这里，我们将学习如何使我们的应用程序在面对处理大量请求和提供快速响应等特定要求时更加响应迅速、高效和健壮。随着我们深入概念和实践，您将看到这种方法如何从根本上改变您能构建的应用程序的本质——使它们完全准备好应对实时用户期望和高数据吞吐量带来的挑战。在下一节中，我们将探讨响应式编程的一些基础知识。
- en: Introducing reactive programming basics
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍响应式编程基础知识
- en: Let’s start with what reactive programming is. In order to understand it, we
    first need to define its core terminologies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从响应式编程是什么开始。为了理解它，我们首先需要定义其核心术语。
- en: Embracing a new paradigm – asynchronicity and responsiveness
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受新的范式——异步性和响应性
- en: Reactive programming introduces an innovative approach to software development;
    it is to respond asynchronously. Traditional programming events execute one after
    another whereas in reactive programming, lots of events happen in parallel. With
    asynchronicity, your application does not waste time waiting and continues processing
    other tasks. This makes it significantly faster and more responsive.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程引入了一种创新的软件开发方法；它是异步响应。传统的编程事件一个接一个地执行，而在响应式编程中，许多事件是并行发生的。异步性使得您的应用程序不会浪费时间等待，并继续处理其他任务。这使得它显著更快、更响应。
- en: The essence of reactivity – data streams and propagation
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应式的本质——数据流和传播
- en: At its core, reactive programming is really about **data streams** and reacting
    to changes in those streams. Picture a stream of data along the same vein as a
    conveyor belt of information that is always moving forward and changing. Any user
    input, messages, or live data could be this stream. In reactive programming, you
    work with these streams using a concept called **Observables**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，响应式编程实际上关乎**数据流**和对这些流中变化的响应。想象一下，数据流就像一条始终向前移动和变化的信息传送带。任何用户输入、消息或实时数据都可能属于这个流。在响应式编程中，您使用称为**可观察者**的概念来处理这些流。
- en: Observables are like messengers that tell parts of your application when new
    data arrives. They can be transformed, combined, or reacted to as data flows through
    these streams. We’ll see these concepts at work in the following sections. When
    new data arrives or the state of data changes, the relevant parts of the application
    update immediately. This is called the propagation of change, and it always ensures
    that your application reflects the current state of affairs and adjusts and responds
    as necessary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察者就像信使，当新数据到达时，它会通知应用程序的各个部分。随着数据通过这些流流动，它们可以被转换、组合或响应。我们将在以下章节中看到这些概念的应用。当新数据到达或数据状态发生变化时，应用程序的相关部分会立即更新。这被称为变化的传播，它始终确保您的应用程序反映当前的事态，并根据需要调整和响应。
- en: In reactive programming, it is not only about how data has to be handled effectively
    but it’s also about making your applications feel alive and interactive. The application
    we are dealing with would be a live feed of news, updates in social networks,
    or real-time control systems – reactive programming can help you build software
    that keeps up with the pace of information today.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，不仅关乎如何有效地处理数据，还关乎让您的应用程序感觉生动且交互式。我们正在处理的应用程序可能是一个新闻实时流、社交媒体更新或实时控制系统——响应式编程可以帮助您构建能够跟上当今信息节奏的软件。
- en: Later in this article, I will explain the terminology, go a bit more into the
    benefits, and then show how tools such as Spring Boot 3.0 make it easier to build
    those reactive systems. So, whether you’re new to this concept or are looking
    to turn up your skill a notch by better understanding reactive programming, it’s
    a potent multi-tool in your developer’s tool belt. So, let’s move on and I’ll
    show you with this fresh approach how we can revolutionize the way that we think
    about and build software.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的后面部分，我将解释术语，深入探讨一些好处，然后展示如何使用Spring Boot 3.0等工具使构建这些反应式系统更加容易。所以，无论你是这个概念的新手，还是希望通过更好地理解反应式编程来提高自己的技能，它都是你开发者工具箱中的一个强大多用途工具。那么，让我们继续前进，我将通过这种新颖的方法向你展示我们如何革命性地思考并构建软件。
- en: Contrasting paradigms – reactive versus traditional programming
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对比范式 - 反应式编程与传统编程
- en: In order to make it clear, we may compare reactive programming with the traditional
    way of development. When learning software development, we begin by understanding
    flow algorithms. We are all aware of the traditional way, so, this comparison
    will help us to understand the new way. Let’s break down this transition from
    traditional to reactive programming and understand how it changes how our code
    behaves and how our applications perform.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更清晰，我们可以将反应式编程与传统开发方式进行比较。在学习软件开发时，我们首先理解流程算法。我们都很清楚传统方式，因此，这种比较将帮助我们理解新方式。让我们分析从传统到反应式编程的转变，了解它是如何改变我们的代码行为以及我们的应用程序性能的。
- en: In traditional programming, operations are often processed one by one. This
    is called **blocking**. Let’s assume you are in a shopping center and, after you
    pick up your goods, you join a payment queue in front of a cash register. The
    cashier accepts the next customer after the current customer completes the payment.
    This flow is how traditional programming works. When there are lots of customers,
    the solution is to open new cash registers. This way is also scalable but you
    need to increase the number of servers to handle a huge amount of customers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程中，操作通常逐个处理。这被称为**阻塞**。假设你在一个购物中心，在你挑选好商品后，你加入了一个收银台前的付款队列。收银员在当前顾客完成付款后才会接受下一位顾客。这种流程就是传统编程的工作方式。当顾客很多时，解决方案是开设新的收银台。这种方法也是可扩展的，但你需要增加服务器的数量来处理大量的顾客。
- en: Reactive programming introduces a non-blocking model. In this approach, tasks
    are handled as soon as the necessary resources are available, and the application
    can continue doing other things in the meantime. In our previous example, instead
    of waiting in line, the cashier can deal with more than one customer at the same
    time. When one customer tries to find the credit card, the cashier scans the next
    customer’s goods. When the next customer tries to put the goods in the bag, the
    cashier can take the payment from another customer. In reactive programming, these
    processes don’t mix up. This shift to handling multiple tasks is crucial in a
    world where users expect fast and responsive applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程引入了一个非阻塞模型。在这种方法中，任务在必要的资源可用时立即处理，同时应用程序可以在其间继续做其他事情。在我们的前一个例子中，收银员不必排队等待，可以同时处理多个顾客。当一个顾客试图找到信用卡时，收银员可以扫描下一位顾客的商品。当下一位顾客试图把商品放入袋子时，收银员可以从另一位顾客那里收取付款。在反应式编程中，这些过程不会混淆。在用户期望快速响应的应用程序的世界中，这种处理多个任务的变化至关重要。
- en: In summary, the shift from traditional to reactive programming is all about
    making your applications more responsive, efficient, and adaptable. In the next
    section, we will take a look at the terminologies that will help us understand
    reactive programming.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，从传统到反应式编程的转变完全是关于让你的应用程序更加响应、高效和适应。在下一节中，我们将探讨有助于我们理解反应式编程的术语。
- en: Exploring the dictionary of reactive programming
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索反应式编程的词汇表
- en: 'In order to better understand reactive programming, we need to learn the basic
    vocabulary of it. This section is all about defining the terms, in plain English,
    that will allow you to feel comfortable speaking the language of reactivity. We
    will decode some of the most common terms that you are likely to come across in
    the following list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解反应式编程，我们需要学习其基本词汇。本节将用简单的英语定义术语，这将使你能够舒适地使用反应性的语言。我们将解码以下列表中你可能会遇到的一些最常见的术语：
- en: '**Observable**: At its simplest, you can think of an Observable as being like
    a publisher. You can also think of it as a news broadcaster sending out the latest
    news/information. In programming terms, it’s a stream of data or events that you
    want to work with. It can be any number of things, from clicks on a web page to
    incoming data over a network.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察对象**：在最简单的意义上，你可以将可观察对象想象成出版者。你也可以将其想象成发送最新新闻/信息的新闻广播者。在编程术语中，它是你想要处理的数据或事件的流。它可以是从网页上的点击到通过网络传入的数据的任何数量的事物。'
- en: '**Observer**: If the Observable is the broadcaster into whom events are sent,
    then the Observer is the listener or viewer who subscribes and is notified when
    said event occurs. It’s the part of your code that “observes” or “watches” the
    Observable and then reacts to the data or events it emits. Whenever fresh data
    arrives, the Observer responds by updating the user interface, processing the
    data, or performing any other necessary tasks.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：如果可观察对象是发送事件的广播者，那么观察者就是订阅并当事件发生时被通知的听众或观众。它是你的代码中“观察”或“监视”可观察对象并对其发出的数据或事件做出反应的部分。每当有新数据到达时，观察者会通过更新用户界面、处理数据或执行任何其他必要的任务来做出响应。'
- en: '**Subscription**: It’s the link between an Observable and an Observer. When
    an Observer subscribes to an Observable, it starts receiving updates from it.
    Think of this like subscribing to a newsletter or following someone on social
    media – you’re essentially saying, “I’m interested in what you have to say.”'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：这是可观察对象和观察者之间的联系。当观察者订阅可观察对象时，它开始接收来自它的更新。可以将其想象成订阅通讯或关注社交媒体上的某人——你实际上是在说：“我对你说的话感兴趣。”'
- en: '**Subject**: A Subject is a special type of Observable that can act as either
    an Observable or Observer. It allows values and events to be emitted and passed
    along to Observers, as well as listen to Observables by becoming an Observer.
    Think of it more like a team where you’re the manager and you provide updates
    and listen to the people in your team.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：主题是一种特殊的可观察对象，它可以充当可观察对象或观察者。它允许值和事件被发出并传递给观察者，同时也可以通过成为观察者来监听可观察对象。可以将其想象成一个团队，你是经理，你提供更新并倾听团队中的人。'
- en: '**Backpressure**: Think of drinking at a water fountain and the water comes
    out too fast. Backpressure is being able to hold that flow so you can comfortably
    drink without being overwhelmed. In a programming context, backpressure stands
    for the capacity to control the rate at which data flows between two interacting
    components so that the receiving end of a communication channel is not overwhelmed
    by more data than it is able to process. This ensures that the application does
    not become unresponsive and remains stable while processing as much data as possible.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背压**：想象一下在饮水机边喝水，水流得太快。背压就是能够控制这种流动，这样你就可以舒适地喝水而不会被淹没。在编程环境中，背压代表的是控制两个交互组件之间数据流动速率的能力，以便通信通道的接收端不会因为无法处理的数据而超负荷。这确保了应用程序在尽可能处理数据的同时不会变得无响应，并保持稳定。'
- en: '**Asynchronous operations**: In a synchronous world, it’s generally perceived
    that one task has to be completed for another task to start. However, in asynchronous
    operations, several tasks can run simultaneously. This is similar to the nature
    of a kitchen, where it’s possible for the chef to chop vegetables and prepare
    a salad at the same time as he or she waits for the soup to simmer. In programming
    terms, this means that your app can process user input while also carrying out
    calculations and loading data, rather than waiting for each process to finish
    before moving on to the next one.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步操作**：在同步世界中，通常认为一个任务必须完成，另一个任务才能开始。然而，在异步操作中，多个任务可以同时运行。这类似于厨房的性质，厨师可以在等待汤煮沸的同时切菜和准备沙拉。在编程术语中，这意味着你的应用程序可以在处理用户输入的同时执行计算和加载数据，而不是等待每个过程完成后再进行下一个过程。'
- en: These fundamental terms are as important for you before getting started with
    reactive programming on Android as learning the rules of the road is before you
    start driving. They are core to mastering reactive programming and will help you
    not just be introduced to the concept but achieve contextual knowledge of its
    principles, once you start navigating the reactive highways while developing applications.
    As you dive more into these concepts, you will realize that they’re not just theoretical
    concepts but practical tools that will empower you as a developer to create better
    software that is engaging and powerful for its users. After learning all the basic
    terms of reactive programming, we will focus on how to decide to use this approach
    instead of the traditional way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始使用Android进行响应式编程之前，这些基本术语与学习驾驶规则一样重要。它们是掌握响应式编程的核心，并将在您开始开发应用程序时导航响应式高速公路时，不仅帮助您了解概念，还能帮助您获得其原则的情境知识。随着您对这些概念深入了解，您将意识到它们不仅仅是理论概念，而且是实用的工具，将赋予您作为开发者的能力，以创建对用户来说既吸引人又强大的软件。在了解所有响应式编程的基本术语后，我们将关注如何决定使用这种方法而不是传统方式。
- en: Identifying opportunities for reactive programming
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别响应式编程的机会
- en: When it comes to integrating reactive programming into your projects, we should
    know when and where to apply it to enhance our application’s performance and user
    experience. Let’s explore the ideal scenarios for choosing reactivity and how
    to assess its fit for your specific needs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将响应式编程集成到您的项目中时，我们应该知道何时何地应用它以提升我们的应用程序性能和用户体验。让我们探讨选择响应式的理想场景以及如何评估它是否符合您的特定需求。
- en: 'The following are the ideal scenarios for reactivity that indicate when to
    make the shift from traditional to reactive programming:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些理想的响应式编程场景，表明何时从传统编程转向响应式编程：
- en: '**Real-time user interfaces**: If your application displays real-time updates
    (i.e., live sports scores, stock tickers, social media feeds, etc.), then reactive
    programming is a pretty good boost for this application. It takes care to maintain
    the user interface’s fast speed and keep it acting upon changes immediately and
    correctly.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时用户界面**：如果您的应用程序显示实时更新（例如，实时体育比分、股票行情、社交媒体动态等），那么响应式编程对这个应用程序来说是一个相当好的提升。它负责保持用户界面的快速速度，并立即正确地响应变化。'
- en: '**Complex network applications**: Reactive programming proves beneficial in
    managing the applications that require repeated calls to networks, for instance,
    chat apps or online games. With reactive programming, the communication gets managed
    as well as optimized properly so that even during heavy loads, a good flow of
    data can be maintained.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的网络应用程序**：响应式编程在管理需要重复调用网络的程序方面证明是有益的，例如聊天应用或在线游戏。使用响应式编程，通信得到妥善管理以及优化，即使在重负载期间，也能保持良好的数据流。'
- en: '**Microservices architecture**: Reactive programming offers two key benefits
    in performance and resilience to systems built around the microservices architecture.
    Broadly, every service can process requests independently as well as asynchronously,
    which provides higher responsiveness and fault tolerance.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：响应式编程为围绕微服务架构构建的系统提供了两个关键的性能和弹性优势。广泛地说，每个服务都可以独立以及异步地处理请求，这提供了更高的响应性和容错性。'
- en: '**IoT and data streaming**: Consider the scenario where data is being streamed
    continuously from devices or sensors in a reactive system. Asynchronous reactive
    programming would enable good stream management, which enables real-time stream
    processing as well as reacting to incoming data, which are fundamental use cases
    in IoT applications or even in data analytics contexts.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网和数据流**：考虑数据在响应式系统中从设备或传感器连续流出的场景。异步响应式编程将实现良好的流管理，这允许实时流处理以及对传入数据的响应，这是物联网应用或甚至在数据分析环境中的基本用例。'
- en: Having the preceding scenarios understood more clearly, you will be in a better
    position to tell when reactive programming is the best approach for your application.
    It all revolves around matching the needs and challenges of an application with
    what reactivity brings to the table.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在更清楚地理解上述场景后，您将更有能力判断响应式编程是否是您应用程序的最佳方法。这一切都围绕着将应用程序的需求和挑战与响应式编程带来的优势相匹配。
- en: 'To assess the need for reactivity, refer to the following list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估响应式需求，请参考以下列表：
- en: '**Performance requirements**: Think about your application responsiveness and
    speed requirements. Reactive programming is necessary if your users expect applications
    to respond quickly while being more interactive compared to static pages.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能要求**：考虑你的应用程序的响应性和速度要求。如果你的用户期望应用程序快速响应并且比静态页面更具交互性，那么反应式编程是必要的。'
- en: '**Data volume and velocity**: Estimate the degree of data volume and speed
    that your application will have to handle. In applications that involve a large
    volume of data or streaming of data at high velocity, reactivity may introduce
    the robustness and speed that is required.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据量与速度**：估计你的应用程序需要处理的数据量和速度程度。在涉及大量数据或高速数据流的应用中，反应性可能引入所需的鲁棒性和速度。'
- en: '**Complexity of operations**: Scrutinize the complexity of the operations that
    your application is performing. Be it complicated asynchronous task handling or
    complex user interactive dynamics, your reactive applications will provide more
    effective solutions.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作复杂性**：审查你的应用程序正在执行的操作的复杂性。无论是复杂的异步任务处理还是复杂的用户交互动态，你的反应式应用程序将提供更有效的解决方案。'
- en: '**Resource constraints**: Consider the hardware and resources available. With
    reactive programming in relation to resource usage, it may be optimized most reasonably
    in comparison to traditional programming thus it is an appropriate paradigm for
    applications running in resource-constraint environments.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：考虑可用的硬件和资源。与资源使用相关的反应式编程，与传统编程相比，可能更合理地进行优化，因此它是适用于资源受限环境的适当范例。'
- en: We can decide to use or not use reactive programming according to these instances.
    Remember, the whole point is not about using the latest and greatest technology
    but creating a better experience for your users and a more manageable code base
    for your team. Consider whether reactive programming is a good choice for your
    next project given some of these factors and scenarios. In the next section, we
    will see which industries are most likely to choose to use the reactive approach,
    and we will also see the real-world usage of reactive programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据这些实例决定是否使用反应式编程。记住，整个目的不是使用最新和最伟大的技术，而是为你的用户提供更好的体验，并为你的团队创建一个更易于管理的代码库。考虑在考虑这些因素和场景的情况下，反应式编程是否是你下一个项目的合适选择。在下一节中，我们将看到哪些行业最有可能选择使用反应式方法，我们还将看到反应式编程在现实世界中的应用。
- en: Learning from the field – reactive programming in action
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从实践中学习——反应式编程在行动
- en: 'We now know when we might need reactive programming in our projects. While
    we may not know the exact technology stack of every company, we can force our
    brains a little bit and make some predictions by identifying scenarios where reactive
    programming is likely at play and drawing inspiration from confirmed cases of
    its application. These are some platforms that most likely utilize reactive programming:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道在项目中何时可能需要使用反应式编程。虽然我们可能不知道每个公司的确切技术栈，但我们可以通过识别反应式编程可能发挥作用的场景，并从其应用已得到证实的案例中汲取灵感，来稍微强迫我们的大脑做出一些预测。以下是一些很可能使用反应式编程的平台：
- en: '**Streaming platforms such as Netflix**: If you are streaming media in a high
    quality, it means you have a huge volume of data. Millions of clients are expecting
    smooth, uninterrupted service simultaneously. In order to handle this data stream
    and provide uninterrupted services, most media services are using a reactive programming
    approach in their projects.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如Netflix等流媒体平台**：如果你正在以高质量流式传输媒体，这意味着你拥有庞大的数据量。数百万客户端期望同时获得平滑、不间断的服务。为了处理这个数据流并提供不间断的服务，大多数媒体服务在其项目中使用反应式编程方法。'
- en: '**Social media platforms such as LinkedIn and Twitter**: When we talk about
    social media, you can imagine how big the streams they have are. Again, millions
    of users publish, read, and listen at the same time. Uncountable user interactions
    and instant content delivery are the requirements of these projects. So, again,
    the best solution here is reactive programming because these requirements align
    well with the principles of reactive programming.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如领英和推特等社交媒体平台**：当我们谈论社交媒体时，你可以想象他们拥有的流有多大。再次，数百万用户同时发布、阅读和收听。不可计数的用户交互和即时内容交付是这些项目的需求。因此，再次，最好的解决方案是反应式编程，因为这些需求与反应式编程的原则非常吻合。'
- en: 'We have assumed some companies are using reactive programming by considering
    their requirements. However, several organizations have openly shared their successful
    adoption of reactive programming:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过考虑他们的需求，假设一些公司正在使用响应式编程。然而，一些组织已经公开分享了他们成功采用响应式编程的经验：
- en: '**Booking.com**: Known for its global accommodation booking platform, Booking.com
    has implemented Spring WebFlux, enhancing its capability to provide a responsive
    and efficient service.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Booking.com**：以其全球住宿预订平台而闻名，Booking.com 实施了 Spring WebFlux，增强了其提供响应和高效服务的能力。'
- en: '**The Guardian**: The international news organization utilizes Akka and Play
    Framework to manage its real-time news updates and high traffic volumes, ensuring
    users have immediate access to the latest stories.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The Guardian**：这家国际新闻机构利用 Akka 和 Play 框架来管理其实时新闻更新和高流量，确保用户能够立即访问最新故事。'
- en: '**Patreon**: The membership platform uses RxJava to handle intricate financial
    transactions and user interactions, showcasing the ability of reactive programming
    to manage complex, data-intensive tasks.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Patreon**：这个会员平台使用 RxJava 来处理复杂的金融交易和用户交互，展示了响应式编程在管理复杂、数据密集型任务方面的能力。'
- en: These real-world applications reflect how reactive programming is implemented
    across industries. While they are using different frameworks to handle the requirements,
    in the next section, we will focus on how Spring Boot 3.0 will help us implement
    reactive programming.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际应用反映了响应式编程在各个行业中的实现方式。虽然它们使用不同的框架来处理需求，但在下一节中，我们将关注 Spring Boot 3.0 如何帮助我们实现响应式编程。
- en: Leveraging Spring Boot 3.0 for reactive solutions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 Spring Boot 3.0 进行响应式解决方案
- en: When we say Spring Boot, the word “simplicity” rises in our minds out of the
    blue. The same can be said for reactive programming. In this section, first, we
    will go over the key concepts of Spring Boot 3.0 that can help us while engaging
    with reactive programming. Later on, we will see which libraries Spring Boot is
    using for this approach.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到 Spring Boot 时，突然在我们脑海中浮现出的词是“简单”。对于响应式编程来说，也是如此。在本节中，首先，我们将回顾 Spring Boot
    3.0 的关键概念，这些概念可以帮助我们在参与响应式编程时使用。稍后，我们将看到 Spring Boot 为此方法使用了哪些库。
- en: Simplifying reactive development – tools and features in Spring Boot 3.0
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化响应式开发 – Spring Boot 3.0 中的工具和功能
- en: 'As we have seen, Spring Boot 3.0 is designed to simplify the entire development
    process by making it faster and easier to create robust applications. Here’s how
    it enhances reactive programming:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Spring Boot 3.0 通过使其更快、更易于创建健壮的应用程序来简化整个开发过程。以下是它是如何增强响应式编程的：
- en: '**Auto-configuration**: Spring Boot 3.0 auto-configures your application based
    on the dependencies you have added, reducing the need for manual setup and letting
    you focus on writing your business logic.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Auto-configuration**：Spring Boot 3.0 根据你添加的依赖项自动配置你的应用程序，减少了手动设置的需求，让你可以专注于编写业务逻辑。'
- en: '**Standalone**: It allows you to create standalone applications that “just
    run,” simplifying deployment and testing. You don’t need an external server or
    container; your app can run as a simple executable.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Standalone**：它允许你创建“只需运行”的独立应用程序，简化了部署和测试。你不需要外部服务器或容器；你的应用程序可以作为简单的可执行文件运行。'
- en: '**Opinionated defaults**: Spring Boot provides sensible defaults for project
    configurations. This means you spend less time configuring and more time building
    your application with the comfort of following best practices.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Opinionated defaults**：Spring Boot 为项目配置提供了合理的默认值。这意味着你花费在配置上的时间更少，有更多时间按照最佳实践构建你的应用程序。'
- en: '**Community and extensions**: We can get help from a large Spring community
    and find ready-to-use extensions so that we can easily integrate additional functionalities
    into our application, from security to data access, without having to reinvent
    the wheel.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区和扩展**：我们可以从庞大的 Spring 社区中获得帮助，并找到现成的扩展，这样我们就可以轻松地将额外的功能集成到我们的应用程序中，从安全到数据访问，无需重新发明轮子。'
- en: These are common Spring Boot features, which are not specific tools for reactive
    programming. But these help us implement the reactive approach as they help us
    with other frameworks by lowering the entry barrier and reducing boilerplate code.
    Spring Boot 3.0 lets us dive into reactive programming with less overhead and
    more support.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是常见的 Spring Boot 功能，它们不是针对响应式编程的特定工具。但它们帮助我们实现响应式方法，因为它们通过降低入门门槛和减少样板代码来帮助我们使用其他框架。
- en: Building blocks of reactivity – a closer look at WebFlux and Project Reactor
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应式编程的构建块——深入了解WebFlux和Project Reactor
- en: 'The libraries in Spring Boot 3.0 for reactive capabilities are WebFlux and
    Project Reactor. We are going to discuss these components and it will give us
    a solid foundation for building reactive applications here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 3.0中用于响应式能力的库是WebFlux和Project Reactor。我们将讨论这些组件，这将为我们在这里构建响应式应用程序提供一个坚实的基础：
- en: '**WebFlux**: This is the reactive web framework for Spring. It has been designed
    to be used in creating non-blocking, asynchronous web applications that could
    serve a high level of concurrent users effectively. It has been designed to work
    with all the reactive libraries and provides all you need to build a fully reactive
    REST application.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebFlux**：这是Spring的响应式Web框架。它被设计用于创建非阻塞、异步的Web应用程序，能够有效地服务于大量并发用户。它被设计用于与所有响应式库一起工作，并提供构建完全响应式REST应用程序所需的一切。'
- en: '`0` to *N* and `0` or `1` element data streams called Flux and Mono. With Project
    Reactor, you get a powerful toolkit to build, transform, and consume the reactive
    streams of data.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`到`N`个元素的数据流称为Flux和Mono。通过Project Reactor，你获得了一个强大的工具集来构建、转换和消费响应式数据流。'
- en: Together, WebFlux and Project Reactor form the backbone of complete reactive
    programming in Spring Boot. They provide a highly streamlined way of working with
    data streams and events, granting you a uniform model upon which you are able
    to build responsive and resilient applications. Real-time-data-implemented microservices
    or high-loaded applications can take advantage of the capacity that these tools
    offer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: WebFlux和Project Reactor共同构成了Spring Boot中完整响应式编程的骨架。它们提供了一种高度简化的数据处理和事件处理方式，为你提供了一个统一模型，你可以在其上构建响应性和健壮的应用程序。实现了实时数据或高负载应用程序可以利用这些工具提供的容量。
- en: Wrapping up and looking forward
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结与展望
- en: As we wrap up this section on reactive programming, let me summarize what we
    have learned. First, we touched upon the what, why, and how of reactive programming,
    got into the terminology, as well as surveyed some real-world applications. We
    came to know that reactive programming is not just a set of techniques but it’s
    actually a mindset for thinking about software development, where your first priority
    is to be responsive, then resilient, and its focus is on providing a great user
    experience. Finally, we have mentioned how can we use it in Spring Boot 3.0\.
    Now, it is the time for us to get our hands dirty. We’re now empowered with the
    knowledge of reactive programming and the next step is applying that knowledge
    through practice itself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们总结这一节关于响应式编程的内容时，让我总结一下我们学到了什么。首先，我们讨论了响应式编程的“是什么”、“为什么”和“如何”，了解了术语，并对一些实际应用进行了调查。我们了解到，响应式编程不仅仅是一套技术，实际上是一种关于软件开发的思想方式，你的首要任务是保持响应性，然后是健壮性，其重点是提供出色的用户体验。最后，我们提到了如何在Spring
    Boot 3.0中使用它。现在，是我们动手实践的时候了。我们现在拥有了响应式编程的知识，下一步是通过实践本身来应用这些知识。
- en: Remember, though, as you go along that the process of mastering reactive programming
    is an enduring journey. It is one of a lifetime of continued learning, experimenting,
    and embracing growth at every opportunity that presents itself. So, enjoy yourself
    in making your applications more dynamic, more robust, and more user friendly
    with the opportunities that it presents. Cheers to all your success in the reactive
    world!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，然而，随着你的前进，掌握响应式编程的过程是一个持久的旅程。这是终身持续学习、实验和抓住每一个机会实现成长的过程之一。所以，享受使用它提供的机遇来使你的应用程序更加动态、更加健壮和更加用户友好吧。祝你在响应式世界中的所有成功！
- en: Building a reactive REST API
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建响应式REST API
- en: Yes, now we are starting to write our first code in the reactive world with
    Spring Boot 3.0\. We will develop a REST API. As we all know, REST is the most
    used transfer protocol in applications. By this protocol, we can develop platform
    and language-independent applications. Because we can use REST in Java, Python,
    C#, and more, thanks to this protocol, each application can interact with each
    other hassle free. That’s why I have chosen REST API development in this sample.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，现在我们开始用Spring Boot 3.0编写响应式世界的第一段代码了。我们将开发一个REST API。众所周知，REST是应用中最常用的传输协议。通过这个协议，我们可以开发平台和语言无关的应用程序。因为我们可以在Java、Python、C#等多种语言中使用REST，多亏了这个协议，每个应用程序都可以轻松地相互交互。这就是为什么我选择了这个示例中的REST
    API开发。
- en: Firstly, we will initiate our Spring Boot 3.0 project. We will introduce each
    component step by step and we will understand why we are using them. So, let’s
    roll up our sleeves and begin this journey into the reactive world.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将启动我们的 Spring Boot 3.0 项目。我们将逐步介绍每个组件，并了解我们为什么要使用它们。所以，让我们卷起袖子，开始这段进入反应式世界的旅程。
- en: Setting up the development environment
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: This is the first step – we need to be sure we have everything ready to use
    on our local machine. We have already mentioned the fundamental steps in the *Technical
    requirements* section. Here, we will have a quick check and initiate our project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一步——我们需要确保我们已经在本地机器上准备好了一切。我们已经在 *技术要求* 部分中提到了基本步骤。在这里，我们将进行快速检查并启动我们的项目。
- en: Tools and dependencies
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具和依赖项
- en: In order to start development, we will need an IDE. You can choose your favorite
    IDE. Popular choices among Java developers include IntelliJ IDEA, Eclipse, and
    Visual Studio Code. If the IDE has support for Spring Boot, it will make life
    easier for you, with helpful plugins and built-in features to simplify the coding
    experience.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发，我们需要一个 IDE。您可以选择您喜欢的 IDE。Java 开发者中流行的选择包括 IntelliJ IDEA、Eclipse 和 Visual
    Studio Code。如果 IDE 支持 Spring Boot，它将使您的生活更加轻松，通过有用的插件和内置功能简化编码体验。
- en: Next, Java is the most important component of our development environments.
    Spring Boot 3.0 requires at least Java 11, but we will use Java 17\. So, please
    be sure you have Java 17 installed on your development machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Java 是我们开发环境中最重要的一部分。Spring Boot 3.0 至少需要 Java 11，但我们将使用 Java 17。所以，请确保您的开发机器上已安装
    Java 17。
- en: '**Spring Initializr** is our next stop; we mentioned it previously in [*Chapter
    1*](B18400_01.xhtml#_idTextAnchor014). It’s an incredibly handy tool for bootstrapping
    your Spring Boot projects. It is accessible via a web interface or directly through
    your IDE and it allows you to generate a project with the desired dependencies,
    packaging, and Java version, all ready to be imported into your IDE.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Initializr** 是我们的下一个目的地；我们之前在 [*第一章*](B18400_01.xhtml#_idTextAnchor014)
    中提到过它。这是一个启动 Spring Boot 项目的非常方便的工具。它可以通过网页界面或直接通过您的 IDE 访问，并允许您生成具有所需依赖项、打包方式和
    Java 版本的工程，所有这些都已准备好导入到您的 IDE 中。'
- en: Creating a new Spring Boot project
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的 Spring Boot 项目
- en: 'Let’s start by visiting the Spring Initializr ([https://start.spring.io](https://start.spring.io))
    website or accessing it through your IDE. We will select Spring Boot version 3.2.5
    since it is the latest stable version of Spring Boot 3.0 and the Java version
    will be 17\. When you go to the link, you will see a screen like in *Figure 3**.1*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从访问 Spring Initializr ([https://start.spring.io](https://start.spring.io))
    网站或通过您的 IDE 访问它开始。我们将选择 Spring Boot 版本 3.2.5，因为它是 Spring Boot 3.0 的最新稳定版本，Java
    版本将是 17。当您访问链接时，您将看到一个类似于 *图 3.1* 的屏幕：
- en: '![Figure 3.1: Screenshot of the Spring Initializr window](img/B18400_03_01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：Spring Initializr 窗口的截图](img/B18400_03_01.jpg)'
- en: 'Figure 3.1: Screenshot of the Spring Initializr window'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：Spring Initializr 窗口的截图
- en: 'As you can see, a **Spring Initializr** sample project is in the figure. As
    for project metadata, fill in the relevant details such as **Group**, **Artifact**,
    **Name**, and **Description** to personalize your project. For dependencies, please
    choose the keys as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，图中的是一个 **Spring Initializr** 示例项目。至于项目元数据，请填写相关的详细信息，例如 **Group**、**Artifact**、**Name**
    和 **Description** 以个性化您的项目。对于依赖项，请选择以下键：
- en: '**Spring Reactive Web**: This is WebFlux and the most important dependency
    for this project, because our sample will be a reactive application.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Reactive Web**：这是 WebFlux，也是本项目最重要的依赖项，因为我们的示例将是一个反应式应用程序。'
- en: '**Spring Data R2DBC**: We need this to connect a relational database in reactive
    applications.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Data R2DBC**：我们需要这个来在反应式应用程序中连接关系型数据库。'
- en: '**H2 Database**: In our sample project, we are going to use an embedded database
    to reduce our dependency on another database server.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H2 数据库**：在我们的示例项目中，我们将使用嵌入式数据库以减少对我们另一个数据库服务器的依赖。'
- en: Once you’ve made all the selections, click on the **Generate** button to get
    the ready-to-build project. This will download a ZIP file containing a Gradle
    project, depending on your preference. Extract this and import it into your chosen
    IDE. You’re now ready to dive into the actual coding!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您做出了所有选择，请点击 **生成** 按钮以获取准备构建的项目。这将下载一个包含 Gradle 项目的 ZIP 文件，具体取决于您的偏好。解压缩并将其导入到您选择的
    IDE 中。现在您已经准备好深入实际的编码了！
- en: Now, we have completed the first important step. We have a running Spring Boot
    3.0 app on our local machine. In the next section, we will build it tile by tile.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了第一个重要步骤。我们在本地机器上运行了一个Spring Boot 3.0应用。在下一节中，我们将逐步构建它。
- en: Defining the reactive data model
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义响应式数据模型
- en: The data model is the key point for a project. Because the data model is the
    smallest piece of the architectural design of an application, we will decide how
    data is structured, stored, and accessed. In our sample project, we will have
    one `User` entity. We will see how to create it and discuss it, emphasizing the
    simplicity and power of records in Java, and the significance of annotations such
    as `@Table` and `@Id` in linking these structures with the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型是项目的关键点。因为数据模型是应用架构设计的最小部分，我们将决定数据如何被结构化、存储和访问。在我们的示例项目中，我们将有一个`User`实体。我们将看到如何创建它，并讨论它，强调Java中记录的简洁性和强大，以及`@Table`和`@Id`等注解在将这些结构链接到数据库中的重要性。
- en: Creating a user record
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户记录
- en: 'This is a straightforward `User` entity characterized by an ID, a name, and
    an email. Traditionally in Java, we might define this as a class, but with the
    advantage of Java records, we will introduce it as a record:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有ID、姓名和电子邮件的简单`User`实体。在Java中，我们可能会将其定义为一个类，但利用Java记录的优势，我们将以记录的形式引入它：
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This one-line code encapsulates everything our `User` entity is about: its
    fields are immutable, it comes equipped with necessary methods such as `equals()`
    and `hashCode()`, and it’s ready to interact with our database. Let’s break down
    the details.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码封装了我们`User`实体的一切：其字段是不可变的，它配备了必要的如`equals()`和`hashCode()`等方法，并且已经准备好与我们的数据库进行交互。让我们来分解一下这些细节。
- en: Understanding records versus classes
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解记录与类之间的区别
- en: 'At first sight, you can see a major difference between a record and a class;
    it is simplicity. But there are some more differences in the unseen side. Here’s
    why records are often favored over traditional classes in modern Java applications:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可以看到记录与类之间一个主要的不同点；那就是简洁性。但在未看到的方面还有一些其他的不同。这就是为什么在现代Java应用中，记录通常比传统类更受欢迎的原因：
- en: '**Immutability**: The fields of a record are final. This immutable nature is
    a boon in reactive applications where thread safety and predictability are paramount.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：记录的字段是最终的。这种不可变特性在需要线程安全和可预测性的响应式应用中是一大优势。'
- en: '`equals()`, `hashCode()`, and `toString()` methods cut down on repetitive code,
    keeping your models lean and focused.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`、`hashCode()`和`toString()`方法减少了重复代码，使你的模型更加精简和专注。'
- en: '**Clarity**: A record’s structure makes it evident what it represents, fostering
    a code base that’s easier to understand and maintain.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰性**：记录的结构使其所代表的内容一目了然，从而促进了一个更容易理解和维护的代码库。'
- en: Now, we are clear on why we have chosen `record` instead of `class`. Now, let’s
    learn about the annotations in the code snippet in the following section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经清楚为什么选择`record`而不是`class`。接下来，让我们学习下一节代码片段中的注解。
- en: Understanding @Table and @Id annotations
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解@Table和@Id注解
- en: 'When connecting our records to a database, annotations such as `@Table` and
    `@Id` come into play, especially when using Spring Data JPA or R2DBC for relational
    databases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将记录连接到数据库时，诸如`@Table`和`@Id`这样的注解就派上用场，尤其是在使用Spring Data JPA或R2DBC进行关系型数据库操作时：
- en: '`@Table`: This annotation specifies the table name in the database with which
    this entity is associated. In our case, `@Table("users")` indicates that the `User`
    record corresponds to a table named `users` in the database. It’s a critical piece
    of information that **object-relational mapping** (**ORM**) frameworks use to
    map the record to the correct database table.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Table`：这个注解指定了与该实体关联的数据库表名。在我们的例子中，`@Table("users")`表示`User`记录对应于数据库中名为`users`的表。这是ORM框架用来将记录映射到正确数据库表的关键信息。'
- en: '`@Id`: Every table needs a primary key, and the `@Id` annotation helps you
    mark which field in your entity is the primary key. In the `User` record, annotating
    the `id` field with `@Id` tells the ORM framework that this field uniquely identifies
    each user and should be treated as the primary key in the database table.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id`：每个表都需要一个主键，`@Id`注解可以帮助你标记实体中的哪个字段是主键。在`User`记录中，将`id`字段注解为`@Id`告诉ORM框架该字段唯一标识每个用户，应在数据库表中作为主键处理。'
- en: In conclusion, defining our data model is an important step. By using annotations
    such as `@Table` and `@Id`, we make our model ready for efficient interaction
    with the database. This approach makes our code cleaner and more maintainable.
    In the next section, we will be dealing with the database operation part.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，定义我们的数据模型是一个重要的步骤。通过使用`@Table`和`@Id`等注解，我们使我们的模型准备好与数据库进行高效交互。这种方法使我们的代码更干净、更易于维护。在下一节中，我们将处理数据库操作部分。
- en: Implementing the repository layer
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现仓库层
- en: In our reactive user management service, establishing a well-structured repository
    layer is essential. This layer will liaise between our application’s business
    logic and the database, handling all data interactions. In this section, we’ll
    delve into why the H2 database is a prime choice for development purposes, how
    to configure it, and the significance of implementing reactive repositories using
    `R2dbcRepository`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的反应式用户管理服务中，建立一个结构良好的仓库层至关重要。这一层将在应用程序的业务逻辑和数据库之间进行协调，处理所有数据交互。在本节中，我们将深入探讨为什么H2数据库是开发目的的首选，如何配置它，以及使用`R2dbcRepository`实现反应式仓库的重要性。
- en: Choosing the H2 database
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择H2数据库
- en: When developing an application, the H2 database is a good option due to its
    simplicity and ease of use. It’s a lightweight and in-memory database that doesn’t
    require installation or setup, making it ideal for testing and development. The
    database starts and stops with your application, allowing for quick testing without
    affecting any live databases. Additionally, the H2 database is compatible with
    SQL, making it easy to switch to a more permanent database if needed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，H2数据库是一个不错的选择，因为它简单易用。它是一个轻量级和内存数据库，无需安装或设置，非常适合测试和开发。数据库与你的应用程序一起启动和停止，允许快速测试而不影响任何实时数据库。此外，H2数据库与SQL兼容，如果需要，可以轻松切换到更持久的数据库。
- en: Configuring application properties and schema
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置应用程序属性和模式
- en: 'To integrate the H2 database into your Spring Boot application, you’ll need
    to configure the `application.properties` file. Here’s a basic setup:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要将H2数据库集成到你的Spring Boot应用程序中，你需要配置`application.properties`文件。以下是一个基本设置：
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Additionally, we need to define our database schema and initial data in a `schema.sql`
    file located in our resources directory. This SQL script is automatically executed
    when your application starts, setting up your database schema.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要在资源目录中的`schema.sql`文件中定义我们的数据库模式和初始数据。此SQL脚本在应用程序启动时自动执行，设置数据库模式。
- en: An introduction to reactive repositories
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反应式仓库简介
- en: In a traditional Spring application, you might be familiar with JPA and the
    `CrudRepository` interface for managing data operations. However, in the reactive
    world, we use `ReactiveCrudRepository` or `R2dbcRepository`. These interfaces
    are designed to work with reactive types, such as `Mono` and `Flux`. By using
    these interfaces we will ensure that all data operations are non-blocking and
    support backpressure. This shift to reactive types allows our application to handle
    operations asynchronously and efficiently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Spring应用程序中，你可能熟悉JPA和`CrudRepository`接口来管理数据操作。然而，在反应式世界中，我们使用`ReactiveCrudRepository`或`R2dbcRepository`。这些接口旨在与反应式类型，如`Mono`和`Flux`一起工作。通过使用这些接口，我们将确保所有数据操作都是非阻塞的，并支持背压。这种对反应式类型的转变使得我们的应用程序能够异步和高效地处理操作。
- en: Understanding R2dbcRepository
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解R2dbcRepository
- en: '`ReactiveCrudRepository` offers all the standard `Mono` for single results
    or `Flux` for multiple results. This helps us to integrate seamlessly with the
    rest of the reactive infrastructure.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactiveCrudRepository`提供了所有标准的`Mono`用于单个结果或`Flux`用于多个结果。这有助于我们与反应式基础设施无缝集成。'
- en: Creating a user repository
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户仓库
- en: 'Now, let’s define a repository for the User entity. Utilizing the `R2dbcRepository`
    interface, you can create a customized repository that extends its capabilities.
    Here’s what a simple `UserRepository` might look like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为用户实体定义一个仓库。利用`R2dbcRepository`接口，你可以创建一个扩展其功能的自定义仓库。以下是一个简单的`UserRepository`示例：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this snippet, `UserRepository` extends `R2dbcRepository`. The `findByEmail`
    method is a custom query method that returns `Mono<User>`. This method returns
    a single-user result in a reactive wrapper. This method might be used to check
    unique email constraints or retrieve user information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`UserRepository` 扩展了 `R2dbcRepository`。`findByEmail` 方法是一个自定义查询方法，它返回
    `Mono<User>`。此方法在响应式包装器中返回单个用户结果。此方法可能用于检查唯一电子邮件约束或检索用户信息。
- en: By these simple lines, we can implement the repository layer. By choosing the
    H2 database for development, we simplify our setup process and make our development
    cycle faster and more flexible. As we continue to build your user management service,
    remember that each layer, from the data model to the repository, is a part of
    our reactive application. Now, we will see how we can connect the user and repository
    with the controller layer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的代码行，我们可以实现数据访问层。通过选择 H2 数据库进行开发，我们简化了我们的设置过程，并使我们的开发周期更快、更灵活。在我们继续构建用户管理服务时，请记住，从数据模型到数据访问层，每一层都是我们响应式应用程序的一部分。现在，我们将看看我们如何将用户和数据访问层与控制器层连接起来。
- en: Building the reactive REST controller
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建响应式 REST 控制器
- en: The controller layer is the place where we interact with the outside world.
    Our application will handle incoming HTTP requests and respond reactively. Let’s
    dive into how a reactive controller operates and walk through the implementation
    of essential CRUD operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器层是我们与外部世界交互的地方。我们的应用程序将处理传入的 HTTP 请求并以响应式的方式做出响应。让我们深入了解响应式控制器的工作方式，并逐步实现基本的
    CRUD 操作。
- en: Overview of controller structure
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器结构概述
- en: In a Spring Boot application, controllers are the gatekeepers of our API. It
    navigates incoming requests to the appropriate services or actions. In a reactive
    environment, these controllers are designed to work with non-blocking operations
    and handle streams of data efficiently. The `@RestController` annotation is the
    default annotation for RESTful controllers. There is no specific change for reactive
    in this creating a controller.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序中，控制器是我们 API 的守门人。它将传入的请求导航到适当的服务或操作。在响应式环境中，这些控制器被设计为与非阻塞操作一起工作，并有效地处理数据流。`@RestController`
    注解是 RESTful 控制器的默认注解。在创建控制器时，对于响应式并没有特定的更改。
- en: 'Here’s the basic structure of our reactive `UserController`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们响应式 `UserController` 的基本结构：
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this class, `@RestController` marks it as a controller where each method
    returns a domain object, and the client gets it as a JSON object. `@RequestMapping("/users")`
    sets the base path for all routes in the controller. We also inject `UserRepository`
    to interact with the database reactively.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，`@RestController` 将其标记为控制器，其中每个方法都返回一个域对象，客户端以 JSON 对象的形式接收它。`@RequestMapping("/users")`
    为控制器中的所有路由设置基本路径。我们还注入 `UserRepository` 以响应式地与数据库交互。
- en: Implementing CRUD operations
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现CRUD操作
- en: 'CRUD operations form the core functionalities of most APIs, allowing clients
    to create, read, update, and delete resources. Here’s how these operations are
    implemented reactively in `UserController`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 操作构成了大多数 API 的核心功能，允许客户端创建、读取、更新和删除资源。以下是这些操作在 `UserController` 中如何以响应式方式实现的：
- en: '**Create (POST)**: We always use HTTP POST calls for creating a new record:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建 (POST)**：我们始终使用 HTTP POST 调用来创建新记录：'
- en: '[PRE4]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `createUser` method handles POST requests to `/users`, saving a new user
    to the database. Notice the return type is `Mono<User>`, indicating it’s a single
    asynchronous operation.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`createUser` 方法处理对 `/users` 的 POST 请求，将新用户保存到数据库中。注意返回类型是 `Mono<User>`，表示这是一个单个异步操作。'
- en: '**List all users (GET)**: This method is used to list or read the data from
    the application:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出所有用户 (GET)**：此方法用于列出或从应用程序中读取数据：'
- en: '[PRE5]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Delete (DELETE)**: We always use this method when we want to delete a record
    in our applications:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除 (DELETE)**：当我们想要在我们的应用程序中删除记录时，我们始终使用此方法：'
- en: '[PRE6]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `deleteUser` method handles the deletion of a user given their ID. The `Mono<Void>`
    return type indicates an operation that will complete without emitting any data
    (void).
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deleteUser` 方法处理根据其 ID 删除用户。`Mono<Void>` 返回类型表示一个将完成而不发出任何数据（void）的操作。'
- en: With this reactive REST controller, we ensure that every operation is non-blocking
    and scalable. This will allow our API to handle a large number of concurrent users
    and operations. As you can notice, each CRUD operation returns Mono or Flux (a
    single item or a stream). These methods were basic operations and now we will
    see a sample that is a bit more complex in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个响应式 REST 控制器，我们确保每个操作都是非阻塞和可扩展的。这将允许我们的 API 处理大量并发用户和操作。正如你所注意到的，每个 CRUD
    操作都返回 Mono 或 Flux（单个项或流）。这些方法是基本操作，现在我们将在下一节看到一个稍微复杂一些的示例。
- en: Adding advanced Mono operations
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加高级 Mono 操作
- en: Creating a reactive REST API involves more than just implementing the basic
    CRUD operations. It’s about enhancing the functionality to handle real-world scenarios
    efficiently and effectively. Now, assume we have a business requirement to check
    the email uniqueness of the user when creating a new user. Let’s enrich the `createUser`
    method by using advanced Mono operations to ensure email uniqueness and provide
    a more robust error-handling strategy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个响应式 REST API 不仅涉及实现基本的 CRUD 操作。它还关乎增强功能，以高效有效地处理现实世界场景。现在，假设我们有一个业务需求，在创建新用户时检查用户的电子邮件唯一性。让我们通过使用高级
    Mono 操作来丰富 `createUser` 方法，以确保电子邮件唯一性并提供更稳健的错误处理策略。
- en: In order to check email uniqueness, we need to use several reactive operators
    and error handling.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查电子邮件唯一性，我们需要使用几个响应式操作符和错误处理。
- en: 'Here’s the advanced `createUser` method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是高级的 `createUser` 方法：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s learn about the reactive methods in this code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个代码片段中的响应式方法：
- en: '`flatMap()`: Useful for mapping and flattening, `flatMap()` allows you to chain
    asynchronous operations, making it perfect for checking conditions or transforming
    data. In this sample, this operator is used to check whether the email already
    exists. If the email is found, it throws a custom `EmailUniquenessException`.
    This ensures that each email in the system is unique and provides a clear path
    for handling the error.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap()`: 对于映射和扁平化非常有用，`flatMap()` 允许你链式调用异步操作，使其非常适合检查条件或转换数据。在这个示例中，这个操作符用于检查电子邮件是否已存在。如果找到电子邮件，它将抛出一个自定义的
    `EmailUniquenessException`。这确保了系统中每个电子邮件都是唯一的，并为错误处理提供了清晰的路径。'
- en: '`then()`: This is used for chaining another `Mono` and executing it after the
    previous operation completes. In our case, after ensuring the email doesn’t exist,
    `then()` is used to save the new user. It effectively chains the user save operation,
    ensuring it only occurs if the email uniqueness check passes.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then()`: 这用于在之前的操作完成后链式调用另一个 `Mono`。在我们的例子中，在确保电子邮件不存在后，`then()` 用于保存新用户。它有效地链式调用用户保存操作，确保只有在电子邮件唯一性检查通过的情况下才会发生。'
- en: '`map()`: This transforms the data in the stream, often used for converting
    one type to another or wrapping it in another object. In our case, once the user
    is saved, `map()` transforms the saved user into `ResponseEntity` with an `OK`
    status, ready to be returned to the client.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`: 这将转换流中的数据，通常用于将一种类型转换为另一种类型或将其包装在另一个对象中。在我们的例子中，一旦用户被保存，`map()` 将保存的用户转换为带有
    `OK` 状态的 `ResponseEntity`，准备返回给客户端。'
- en: '`doOnNext():` This executes side effects, such as logging or metrics collection,
    without altering the stream. In our case, this operator is used for logging or
    any other side actions you want to perform after the new user is created. It’s
    a way to tap into the stream and perform an action without altering the data flow.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext()`: 这执行副作用，如日志记录或度量收集，而不改变流。在我们的例子中，这个操作符用于日志记录或任何其他你希望在创建新用户后执行的侧操作。这是一种进入流并执行操作而不改变数据流的方式。'
- en: '`onErrorResume()`: This provides a way to recover from errors, allowing you
    to continue the data flow with an alternative `Mono`. This is crucial for error
    handling; this operator catches exceptions and allows you to provide an alternative
    `Mono`. In the case of `EmailUniquenessException`, it returns `ResponseEntity`
    with a conflict status, indicating the email is already in use.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorResume()`: 这提供了一种从错误中恢复的方法，允许你使用一个替代的 `Mono` 继续数据流。这对于错误处理至关重要；这个操作符捕获异常，并允许你提供一个替代的
    `Mono`。在 `EmailUniquenessException` 的情况下，它返回带有冲突状态的 `ResponseEntity`，表示电子邮件已被使用。'
- en: Adding these advanced `Mono` operations into your `createUser` method transforms
    it from a simple save function to a more sophisticated, real-world-ready operation.
    This approach ensures data integrity with the email uniqueness check. It also
    provides clearer communication back to the client about the result of their request,
    whether successful or in error. Now, it is time to run the application and see
    how it looks in the user’s eye.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些高级`Mono`操作添加到`createUser`方法中，将其从简单的保存功能转变为更复杂、适用于现实世界的操作。这种方法确保了通过电子邮件唯一性检查的数据完整性。它还向客户端提供了关于其请求结果（无论成功还是出错）的更清晰的通信。现在，是时候运行应用程序并看看它在用户眼中的样子了。
- en: Running the Spring Boot application with Gradle and Java 17
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gradle和Java 17运行Spring Boot应用程序
- en: With your reactive REST API in place and ready to show its prowess, it’s time
    to run the application using Gradle and Java 17\. Here’s how you can get your
    application up and running in no time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的反应式REST API已经就绪并准备好展示其能力时，是时候使用Gradle和Java 17运行应用程序了。以下是您可以在短时间内使应用程序启动运行的方法。
- en: 'To run a Spring Boot application using Gradle, follow these steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Gradle运行Spring Boot应用程序，请按照以下步骤操作：
- en: Open a terminal or command prompt and change the directory to the root directory
    of your project where the `build.gradle` file is located.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端或命令提示符，并将目录更改为包含`build.gradle`文件的项目的根目录。
- en: 'Execute the Run Command – use the following command to start your application:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行运行命令 – 使用以下命令启动您的应用程序：
- en: '[PRE8]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command initiates the Gradle build process, compiles your Java code, and
    starts the embedded server (typically Tomcat) that comes with Spring Boot.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动Gradle构建过程，编译您的Java代码，并启动Spring Boot附带的嵌入式服务器（通常是Tomcat）。
- en: 'After executing the run command, watch the console for log messages. Spring
    Boot provides detailed logs that can help you understand what’s happening behind
    the scenes. The key things to look for are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行运行命令后，请关注控制台中的日志消息。Spring Boot提供了详细的日志，可以帮助您了解幕后发生的事情。以下是需要关注的关键点：
- en: '**Build success**: Indications that Gradle has successfully built your application'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建成功**：Gradle成功构建应用程序的指示'
- en: '**Application starting**: Messages related to your application context, beans,
    and embedded server starting up'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序启动**：与应用程序上下文、bean和嵌入式服务器启动相关的消息'
- en: '**Running application**: A log entry similar to “Started application in *X*
    seconds” signifies that your application is up and running'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行应用程序**：一个类似于“应用程序在 *X* 秒内启动”的日志条目表明您的应用程序正在运行'
- en: By default, your application will be accessible at `http://localhost:8080`.
    This can be changed in your `application.properties` or `application.yml` file
    if a different port or context path is preferred.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您的应用程序将在`http://localhost:8080`处可用。如果需要不同的端口或上下文路径，可以在`application.properties`或`application.yml`文件中进行更改。
- en: Now that our application is up and running, it’s important to test its functionality.
    Interact with some of the endpoints in your API using cURL commands or whichever
    other tool you would use to make API calls. This interaction will validate whether
    your application is working (i.e., processing requests from the users and responding
    as required).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已经启动并运行，测试其功能很重要。使用cURL命令或其他您用于进行API调用的工具与API中的某些端点进行交互。这种交互将验证您的应用程序是否正在运行（即，处理来自用户的请求并按要求响应）。
- en: Now, our application is running on our local machine. We can create, list, and
    delete users in our embedded database. Also, we can test the reactive abilities.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序正在本地机器上运行。我们可以在嵌入式数据库中创建、列出和删除用户。此外，我们还可以测试其反应式能力。
- en: In the next section, we will test its capabilities and see how the reactive
    approach can help us under concurrent requests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将测试其功能，看看反应式方法如何帮助我们处理并发请求。
- en: Testing is an indispensable part of application development. We need to ensure
    that every component functions as expected and that the entire system operates
    seamlessly. We will cover the unit test part in [*Chapter 6*](B18400_06.xhtml#_idTextAnchor192).
    However, unit tests are not the only way to test our application. We can manually
    test the endpoints of your reactive REST API to verify its functionality. We will
    see how to do this in this section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是应用程序开发不可或缺的一部分。我们需要确保每个组件按预期工作，整个系统运行顺畅。我们将在[*第6章*](B18400_06.xhtml#_idTextAnchor192)中介绍单元测试部分。然而，单元测试并不是测试我们应用程序的唯一方式。我们可以手动测试反应式REST
    API的端点以验证其功能。我们将在本节中看到如何进行此操作。
- en: cURL is a versatile command-line tool used for transferring data with URLs.
    It’s an excellent choice for manually testing HTTP endpoints. By executing cURL
    commands, you can simulate client requests to your application and observe the
    responses, ensuring that each part of your application reacts as expected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: cURL是一个多功能的命令行工具，用于通过URL传输数据。它是手动测试HTTP端点的绝佳选择。通过执行cURL命令，你可以模拟客户端对应用的请求并观察响应，确保应用中的每个部分都按预期反应。
- en: 'Here are cURL scripts and their expected outputs for testing the various endpoints
    of your user management service, including the scenario of an email uniqueness
    violation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于测试用户管理服务各种端点的cURL脚本及其预期输出，包括电子邮件唯一性违规的场景：
- en: '`POST /users`**)**: These are the steps for creating a new user:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /users`**)**: 创建新用户的步骤如下：'
- en: '**Creating a new user**: We will create a single user with this cURL command:'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建新用户**：我们将使用以下cURL命令创建单个用户：'
- en: '[PRE9]'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`GET /users`**)**: This command will list all the users in the system:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /users`**)**: 此命令将列出系统中的所有用户：'
- en: '[PRE10]'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'DELETE /users/{id}1:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'DELETE /users/{id}1:'
- en: '[PRE11]'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By these manual tests, we ensure that the app is working and acting as expected
    in various scenarios. Also, we could test the edge case for email uniqueness.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些手动测试，我们确保应用在各种场景下都能正常工作并按预期行事。此外，我们还可以测试电子邮件唯一性的边缘情况。
- en: Conclusion
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: As we’ve come to the end of the section, let’s take a step back and look at
    our journey. We learned how to build a reactive REST API with Spring Boot 3.0
    – and it’s not all about coding; it’s choosing a modern way of making apps. So,
    in learning reactive programming, you learned how to make quicker, tougher services
    and the capacity to handle a larger load. You went through setting up, making
    a data model, creating a place to store the data reactively, and making a REST
    controller that can do a lot. Finally, we worked on a reactive API example.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着我们进入本节的结尾，让我们回顾一下我们的旅程。我们学习了如何使用Spring Boot 3.0构建反应式REST API——这不仅仅是关于编码；这是选择一种现代的构建应用的方式。因此，在学习反应式编程的过程中，你学会了如何创建更快、更坚韧的服务，以及处理更大负载的能力。你经历了设置、创建数据模型、创建一个用于反应式存储数据的地方，以及创建一个可以执行许多操作的REST控制器。最后，我们进行了一个反应式API示例的工作。
- en: Reactive programming is a big shift. In it, the focus is on data that never
    stops and is asynchronous. If you learn this, you’re ready for modern software
    needs. These are quick reactions, good performance, and great user experiences.
    Reactive programming makes a system work better under pressure, using resources
    well, and also becoming more naturally manageable to handle many tasks at once.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反应式编程是一个巨大的转变。在其中，重点是永不停止且异步的数据。如果你学会了它，你就准备好应对现代软件的需求了。这些是快速反应、良好性能和优秀用户体验。反应式编程使系统在压力下工作得更好，合理利用资源，并且更自然地管理同时处理许多任务。
- en: Keep applying what you have learned about reactive principles and techniques.
    It may be challenging at first, but it will certainly be worth it. Embrace the
    reactive way, and you will create systems that are not only strong but also efficient
    and robust.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 持续应用你所学习的关于反应式原则和技术。一开始可能会有些挑战，但绝对值得。拥抱反应式方式，你将创建出既强大又高效、健壮的系统。
- en: But that’s not all. In the next section, you’ll learn all about asynchronous
    systems and backpressure. We’ll look at how to keep lots of data manageable so
    your app remains stable and quick. Understanding back pressure is key in our high-data
    world with expectations for speed and reliability as well.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但这还不是全部。在下一节中，你将了解所有关于异步系统和背压的内容。我们将探讨如何保持大量数据的管理，以确保你的应用保持稳定和快速。在我们的高数据世界中，理解背压是关键，因为我们对速度和可靠性有很高的期望。
- en: Don’t forget to use the finalized project to get first-hand experience. Check
    out the GitHub repository to get the full code, see how the full system works,
    and start your work from there on.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记使用最终确定的项目来获得第一手经验。查看GitHub仓库以获取完整代码，了解整个系统的运作方式，并从这里开始你的工作。
- en: Asynchronous systems and backpressure
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步系统和背压
- en: In the competitive world, asynchronous communication has become a key element
    in modern web applications because it promises efficiency and scalability. When
    we use the term “asynchronous,” reactive systems come to mind. As we already know,
    the need for an asynchronous system comes from the requirement to handle lots
    of data streams. So, the system should handle these streams and protect itself
    from exhaustion. At this point, the role of backpressure arises.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在竞争激烈的世界中，异步通信已成为现代Web应用的关键元素，因为它承诺了效率和可扩展性。当我们使用“异步”这个词时，就会想到反应式系统。正如我们已经知道的，异步系统的需求来自于处理大量数据流的必要性。因此，系统应该处理这些流并保护自己免于耗尽。在这个时候，背压的作用就显现出来了。
- en: In this section, we will discover what backpressure is and how we can implement
    it in our current sample project.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们将发现什么是背压以及我们如何在当前的示例项目中实现它。
- en: Diving into backpressure
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解背压
- en: We were told that backpressure is a lifesaver mechanism, but we need to clarify
    this. In this section, we are going to discuss what backpressure is, why we need
    it, and how it protects our systems.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们被告知背压是一种救命机制，但我们需要澄清这一点。在本节中，我们将讨论什么是背压，为什么我们需要它，以及它是如何保护我们的系统的。
- en: What is backpressure?
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是背压？
- en: Imagine a situation where there is a high-speed conveyor belt delivering products
    to a packer. If the packer can’t keep up with the speed, the products will pile
    up, and the products will get damaged or lost. Backpressure is a method to control
    the flow of products based on the packer’s capacity. It’s like giving the packer
    a “stop” button to prevent overwhelming scenarios.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下这样的情况：有一个高速传送带将产品运送到包装工那里。如果包装工跟不上速度，产品就会堆积起来，产品可能会损坏或丢失。背压是一种基于包装工能力控制产品流动的方法。这就像给包装工一个“停止”按钮，以防止过度负载的情况发生。
- en: In reactive streams, backpressure is a crucial concept. It allows a data consumer
    (subscriber) to communicate with the data producer (publisher) about the amount
    of data it can handle at a time. This prevents overwhelming scenarios and ensures
    a smooth and manageable data flow.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在反应式流中，背压是一个关键概念。它允许数据消费者（订阅者）与数据生产者（发布者）就一次可以处理的数据量进行通信。这防止了过度负载的情况发生，并确保数据流平稳且可管理。
- en: Why is backpressure necessary?
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么背压是必要的？
- en: 'We define it as a “stop” button, so you can imagine the disaster that may cause
    if we don’t have it. So, without backpressure, systems can run into some of the
    following critical issues:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将其定义为“停止”按钮，所以你可以想象如果没有它可能会造成的灾难。因此，没有背压，系统可能会遇到以下一些关键问题：
- en: '**Memory overruns**: When the incoming data stream is faster than the application
    can process, the server may run out of memory'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存溢出**：当传入的数据流比应用能够处理的速度快时，服务器可能会耗尽内存'
- en: '**Poor performance**: As the system struggles to manage the irregular flow,
    overall performance can decrease, causing slower response times and a poor user
    experience'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能低下**：当系统努力管理不规则的数据流时，整体性能可能会下降，导致响应时间变慢，用户体验变差'
- en: '**System crashes**: In extreme cases, such as unexpected high demand occurs
    on our application, the system may crash'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统崩溃**：在极端情况下，例如我们的应用出现意外的高需求时，系统可能会崩溃'
- en: Backpressure is not just a nice-to-have feature. It’s an inevitable requirement
    for systems if we need to manage unpredicted data streams. In the next section,
    we will discuss how we can use it in the Spring world.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 背压不仅仅是一个锦上添花的特性。如果我们需要管理不可预测的数据流，它对于系统来说是不可避免的必需品。在下一节中，我们将讨论如何在Spring世界中使用它。
- en: Backpressure in Project Reactor
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: Project Reactor中的背压
- en: Project Reactor is a foundational library for reactive programming in the Spring
    ecosystem. It implements backpressure using the reactive streams specification.
    This would mean ensuring the parts of a program that send out data do it in a
    controlled way based on what the parts that receive the data can deal with.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Project Reactor是Spring生态系统中进行反应式编程的基础库。它使用反应式流规范实现背压。这意味着确保程序中发送数据的部分以受控的方式发送，基于接收数据的部分可以处理的内容。
- en: 'In Reactor, as a Flux or Mono typically sends data (data sequences), it doesn’t
    just send all the data at once. Within this pattern, instead, the part that receives
    the data (the subscriber) asks for only as much of that data as it can deal with
    at one time. This asking is done through a method called request(n). Here’s how
    it works:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Request(n)**The subscriber can request a specific number of items. In this
    way, the subscriber informs the producer about its current capacity.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic adjustment**: As the subscriber processes data, it can dynamically
    adjust its requests based on current load, processing speed, and other factors.'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Propagated backpressure**: Backpressure is not just between one producer
    and one consumer, but is used in entire systems to keep a balance.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Project Reactor, developers can build reliable and stable applications
    in which data will be processed in an optimal manner and not overload the system.
    Each component only processes a set of data it can work with, therefore contributing
    to a balanced system.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we’ll be working on the project, we will see how these ideas become translated
    into code and what they boil down to when you bring them to practice.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are going to go through different strategies, take a look at logs and data,
    and observe backpressure, which keeps the system balanced. Remember, understanding
    backpressure is about making systems that can handle data well and stay steady
    and fast.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing backpressure in the project
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Backpressure is like a dance between data senders and receivers. It makes sure
    data doesn’t come too fast or slow. Our goal is to keep the flow of data smooth
    and prevent too much data from causing problems. Let’s look at how we can tell
    when receivers get too much data, what we can do about it, and see how it works.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Detecting overwhelmed consumers
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a perfect situation, data moves smoothly from senders to receivers. But
    sometimes, receivers get more than they can handle. We should detect such cases
    and implement solutions accordingly. There are a few signals, as shown here, that
    we can smell while we monitor the application performance:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Observing latency and throughput**: We can tell something is wrong if it
    takes longer for data to process or if less data is processed over time'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error rates and patterns**: A lot of errors or certain types of errors can
    also show that there’s too much data'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization**: If the consumer is using too much computer power
    or memory, it might be getting too much data'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to detect whether we need backpressure, in the next section,
    we will explore strategies for handling it.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Strategies for handling backpressure
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we know our consumer is struggling, how do we handle it? We can introduce
    some of the different approaches mentioned here:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Buffering**: Temporarily holding data until the consumer is ready. This strategy
    works well if the overload is short-lived or intermittent.'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dropping data**: In some cases, particularly with real-time data, it might
    be acceptable to drop some data to keep up with the flow.'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching**: Accumulating data into larger, less frequent batches can reduce
    overhead and allow consumers to catch up.'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting**: Limiting the rate at which the producer sends data to match
    the consumer’s capacity.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After learning the strategies for handling backpressure, we will implement backpressure
    in our application in the following section.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing backpressure in the project
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s enhance our Spring Boot project to include backpressure handling.
    We’ll focus on a typical scenario: a RESTful service where the consumer is a client
    application requesting a large stream of data. Let’s see how to implement it step
    by step:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Define a logger**: Set up a logging instance to observe how backpressure
    is affecting the data flow:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`getAllUsers` endpoint that logs with more detail:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`/stream` **endpoint**: Implement a new endpoint that introduces backpressure
    through Project Reactor’s built-in mechanisms:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After introducing these changes in our project, we can do a small load test.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First off, I have used this bash script to create a load on the system:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This bash script will create 300 concurrent requests to the URL mentioned in
    the script. We can also use the same script for `URL="http://localhost:8080/users"`
    and make a comparison between response time and system load.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The logs from using the cURL command to create a load on the `/getAllUsers`
    and `/streamUsers` endpoints illustrate how the system performs under stress and
    give insights into how backpressure and asynchronous processing are working. Let’s
    analyze the differences and what they might indicate.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: getAllUsers endpoint logs
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `/getAllUsers` endpoint sends all user data very fast and doesn’t control
    the flow of data. At first, it’s quick (around 226 ms for each request). But when
    more people use it, each request takes longer – even twice as long. This happens
    when systems are very busy and don’t control incoming requests. They keep taking
    in more work, but as they get busier, each task takes longer because the system
    is too busy.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: streamUsers endpoint logs
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `/streamUsers` endpoint has a way to manage data called backpressure, using
    `.onBackpressureBuffer()`. At the start, it handles requests steadily. As it gets
    busier, the time for each request goes up – slower than the `/getAllUsers` endpoint,
    but it still increases. This slower increase is a sign that the system is controlling
    the data flow. It’s adjusting to handle what it can without getting too overwhelmed.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Observations and conclusions
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our local test tells us information even without performance monitoring tools.
    You can see the logs in your local server for both endpoints. These are the observations
    of the logs:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Initial performance**: Both endpoints start with similar processing times
    for streaming users. This shows us both endpoints work pretty much the same under
    normal conditions.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/getAllUsers` endpoint is more rapid. This shows as it becomes overwhelmed
    more quickly. The `/streamUsers` endpoint shows a more gradual increase in time,
    suggesting the backpressure is allowing the system to handle the load more gracefully.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System stress**: This is when we see the response times increasing under
    load. In real-world scenarios, this is an absolute signal that we need to apply
    performance optimizations such as improving database access, increasing server
    resources, or further refining backpressure strategies.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The logs give us a good idea of how the system works under a lot of stress and
    suggests backpressure helps in `/streamUsers`. However, to really understand and
    improve the system, you’d need more detailed information. The slow increase in
    response times when busy is a common sign the system is struggling. This is when
    you might need to make big changes or fine-tune the system.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By carefully using and watching backpressure, we’ve made our project more stable
    and efficient. We’ve learned a lot about how data moves and is controlled. Remember,
    backpressure isn’t a simple fix. It needs careful thought and adjustments to meet
    the changing needs of applications. But with what we’ve learned, we’re ready to
    make sure your applications can handle data well.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), we have dived into the paradigm
    shift towards reactive programming with Spring Boot 3.0\. From developing a fundamental
    understanding of the heart and core of reactive programming in moving ahead to
    prove the importance of these paradigms to make applications more responsive,
    efficient, and robust.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is what we have covered:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Transitioning to reactive programming**: We contrasted reactive and traditional
    programming by shifting to a non-blocking model that solves asynchronously for
    faster and more responsive applications.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building reactive REST APIs**: We have covered the essentials of building
    a reactive REST API, understanding asynchronous systems, and the concept of backpressure
    for executing data flow effectively.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting up for success**: The chapter gave a detailed outline of how to set
    up your development environment, from the installation of Java 17 and IntelliJ
    IDEA all the way through to how to create the reactive data model, how to implement
    the repository layer, and how to build a reactive REST controller using Spring
    Boot 3.0.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Further down the line in [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146), we’ll
    manage data with Spring Data, where I will explore both SQL as well as NoSQL databases.
    We also go into migration as well as consistency of the data, ensuring your applications
    are still hardy and running smoothly. The following chapter will include the *Using
    Spring Data with SQL databases*, *NoSQL databases in Spring Boot*, and *Data migration
    and consistency* sections. The next chapter will dive deeper into issues concerning
    data management inside of the Spring ecosystem and prepare you for the challenges
    of various databases.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we transition from just understanding any reactive paradigm in the development
    of software to actually mastering data management with the power of Spring Boot
    3.0 simplifying and enhancing these processes, do keep what you have learned in
    this chapter in mind. Stay tuned for more insightful discussions and practical
    guides as laid out in the next chapter.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Part 3: Data Management, Testing, and Security'
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part addresses critical components of software development: data management,
    testing, and security. Starting with [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146),
    you’ll get to grips with Spring Data, exploring SQL, NoSQL, and caching techniques.
    [*Chapter 5*](B18400_05.xhtml#_idTextAnchor179) focuses on securing your Spring
    Boot applications, ensuring they are robust against unauthorized access. Finally,
    [*Chapter 6*](B18400_06.xhtml#_idTextAnchor192) introduces advanced testing strategies
    that help validate and improve the reliability of your software. This part is
    crucial for creating well-rounded, secure, and efficiently managed applications.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18400_04.xhtml#_idTextAnchor146), *Spring Data: SQL, NoSQL,
    Cache Abstraction, and Batch Processing*'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18400_05.xhtml#_idTextAnchor179), *Securing Your Spring Boot
    Applications*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18400_06.xhtml#_idTextAnchor192), *Advanced Testing Strategies*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
