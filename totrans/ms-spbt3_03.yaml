- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive REST Development and Asynchronous Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this chapter, we have built our theoretical base with microservice and
    **Spring Boot 3.0** capabilities. Now, it is time to get our hands dirty. We will
    learn and practice **reactive programming** with Spring Boot 3.0\. We will go
    over the instructions and build our first reactive REST application. We are also
    going to discuss **backpressure** and how it can help our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing reactive programming basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a reactive REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous systems and backpressure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JAVA_HOME` environment variable is set to the JDK 17 directory and that your
    PATH includes the bin directory of JDK 17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A modern **integrated development environment** (**IDE**): I recommend IntelliJ
    IDEA:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download IntelliJ IDEA**: Visit the JetBrains website and choose the edition
    you prefer (Community or Ultimate).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run the installer**: Once downloaded, run the installer and follow the instructions.
    Choose the settings and plugins that suit your needs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch IntelliJ IDEA**: After installation, open IntelliJ IDEA to configure
    it further as needed and familiarize yourself with the interface.*   **GitHub
    repository**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for the *Building a reactive REST API* section is available at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Building_Reactive_REST_API](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Building_Reactive_REST_API)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for the *Asynchronous systems and backpressure* section is available
    at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Implement_back-pressure](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-3-Implement_back-pressure)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please download or clone the code and follow the content through these repositories*   **Curl
    Installation:**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please find the installation packet for your operating system and download the
    related packet from [https://curl.se/download.html](https://curl.se/download.html)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the instructions to install it on your local machine
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking of the basics of reactive programming, firstly, I would like to say
    that no solution/approach can fit each need. So, the projects have different problems
    and according to the problem, there are different solutions. One of them is the
    **reactive programming approach**. Here, we are going to learn how to make our
    applications more responsive, efficient, and robust in the face of specific requirements
    such as handling a huge number of requests and providing fast responses. As we
    work through the concepts and practices, you’ll see how this approach can fundamentally
    change the nature of the application you can build – making them fully prepared
    for the challenges posed by real-time user expectations and high data throughput.
    In the following section, we take a look at some of the basics of reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing reactive programming basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with what reactive programming is. In order to understand it, we
    first need to define its core terminologies.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing a new paradigm – asynchronicity and responsiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reactive programming introduces an innovative approach to software development;
    it is to respond asynchronously. Traditional programming events execute one after
    another whereas in reactive programming, lots of events happen in parallel. With
    asynchronicity, your application does not waste time waiting and continues processing
    other tasks. This makes it significantly faster and more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of reactivity – data streams and propagation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At its core, reactive programming is really about **data streams** and reacting
    to changes in those streams. Picture a stream of data along the same vein as a
    conveyor belt of information that is always moving forward and changing. Any user
    input, messages, or live data could be this stream. In reactive programming, you
    work with these streams using a concept called **Observables**.
  prefs: []
  type: TYPE_NORMAL
- en: Observables are like messengers that tell parts of your application when new
    data arrives. They can be transformed, combined, or reacted to as data flows through
    these streams. We’ll see these concepts at work in the following sections. When
    new data arrives or the state of data changes, the relevant parts of the application
    update immediately. This is called the propagation of change, and it always ensures
    that your application reflects the current state of affairs and adjusts and responds
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In reactive programming, it is not only about how data has to be handled effectively
    but it’s also about making your applications feel alive and interactive. The application
    we are dealing with would be a live feed of news, updates in social networks,
    or real-time control systems – reactive programming can help you build software
    that keeps up with the pace of information today.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this article, I will explain the terminology, go a bit more into the
    benefits, and then show how tools such as Spring Boot 3.0 make it easier to build
    those reactive systems. So, whether you’re new to this concept or are looking
    to turn up your skill a notch by better understanding reactive programming, it’s
    a potent multi-tool in your developer’s tool belt. So, let’s move on and I’ll
    show you with this fresh approach how we can revolutionize the way that we think
    about and build software.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting paradigms – reactive versus traditional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to make it clear, we may compare reactive programming with the traditional
    way of development. When learning software development, we begin by understanding
    flow algorithms. We are all aware of the traditional way, so, this comparison
    will help us to understand the new way. Let’s break down this transition from
    traditional to reactive programming and understand how it changes how our code
    behaves and how our applications perform.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional programming, operations are often processed one by one. This
    is called **blocking**. Let’s assume you are in a shopping center and, after you
    pick up your goods, you join a payment queue in front of a cash register. The
    cashier accepts the next customer after the current customer completes the payment.
    This flow is how traditional programming works. When there are lots of customers,
    the solution is to open new cash registers. This way is also scalable but you
    need to increase the number of servers to handle a huge amount of customers.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming introduces a non-blocking model. In this approach, tasks
    are handled as soon as the necessary resources are available, and the application
    can continue doing other things in the meantime. In our previous example, instead
    of waiting in line, the cashier can deal with more than one customer at the same
    time. When one customer tries to find the credit card, the cashier scans the next
    customer’s goods. When the next customer tries to put the goods in the bag, the
    cashier can take the payment from another customer. In reactive programming, these
    processes don’t mix up. This shift to handling multiple tasks is crucial in a
    world where users expect fast and responsive applications.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the shift from traditional to reactive programming is all about
    making your applications more responsive, efficient, and adaptable. In the next
    section, we will take a look at the terminologies that will help us understand
    reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the dictionary of reactive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to better understand reactive programming, we need to learn the basic
    vocabulary of it. This section is all about defining the terms, in plain English,
    that will allow you to feel comfortable speaking the language of reactivity. We
    will decode some of the most common terms that you are likely to come across in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observable**: At its simplest, you can think of an Observable as being like
    a publisher. You can also think of it as a news broadcaster sending out the latest
    news/information. In programming terms, it’s a stream of data or events that you
    want to work with. It can be any number of things, from clicks on a web page to
    incoming data over a network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: If the Observable is the broadcaster into whom events are sent,
    then the Observer is the listener or viewer who subscribes and is notified when
    said event occurs. It’s the part of your code that “observes” or “watches” the
    Observable and then reacts to the data or events it emits. Whenever fresh data
    arrives, the Observer responds by updating the user interface, processing the
    data, or performing any other necessary tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscription**: It’s the link between an Observable and an Observer. When
    an Observer subscribes to an Observable, it starts receiving updates from it.
    Think of this like subscribing to a newsletter or following someone on social
    media – you’re essentially saying, “I’m interested in what you have to say.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject**: A Subject is a special type of Observable that can act as either
    an Observable or Observer. It allows values and events to be emitted and passed
    along to Observers, as well as listen to Observables by becoming an Observer.
    Think of it more like a team where you’re the manager and you provide updates
    and listen to the people in your team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backpressure**: Think of drinking at a water fountain and the water comes
    out too fast. Backpressure is being able to hold that flow so you can comfortably
    drink without being overwhelmed. In a programming context, backpressure stands
    for the capacity to control the rate at which data flows between two interacting
    components so that the receiving end of a communication channel is not overwhelmed
    by more data than it is able to process. This ensures that the application does
    not become unresponsive and remains stable while processing as much data as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous operations**: In a synchronous world, it’s generally perceived
    that one task has to be completed for another task to start. However, in asynchronous
    operations, several tasks can run simultaneously. This is similar to the nature
    of a kitchen, where it’s possible for the chef to chop vegetables and prepare
    a salad at the same time as he or she waits for the soup to simmer. In programming
    terms, this means that your app can process user input while also carrying out
    calculations and loading data, rather than waiting for each process to finish
    before moving on to the next one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These fundamental terms are as important for you before getting started with
    reactive programming on Android as learning the rules of the road is before you
    start driving. They are core to mastering reactive programming and will help you
    not just be introduced to the concept but achieve contextual knowledge of its
    principles, once you start navigating the reactive highways while developing applications.
    As you dive more into these concepts, you will realize that they’re not just theoretical
    concepts but practical tools that will empower you as a developer to create better
    software that is engaging and powerful for its users. After learning all the basic
    terms of reactive programming, we will focus on how to decide to use this approach
    instead of the traditional way.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying opportunities for reactive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to integrating reactive programming into your projects, we should
    know when and where to apply it to enhance our application’s performance and user
    experience. Let’s explore the ideal scenarios for choosing reactivity and how
    to assess its fit for your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the ideal scenarios for reactivity that indicate when to
    make the shift from traditional to reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time user interfaces**: If your application displays real-time updates
    (i.e., live sports scores, stock tickers, social media feeds, etc.), then reactive
    programming is a pretty good boost for this application. It takes care to maintain
    the user interface’s fast speed and keep it acting upon changes immediately and
    correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex network applications**: Reactive programming proves beneficial in
    managing the applications that require repeated calls to networks, for instance,
    chat apps or online games. With reactive programming, the communication gets managed
    as well as optimized properly so that even during heavy loads, a good flow of
    data can be maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices architecture**: Reactive programming offers two key benefits
    in performance and resilience to systems built around the microservices architecture.
    Broadly, every service can process requests independently as well as asynchronously,
    which provides higher responsiveness and fault tolerance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT and data streaming**: Consider the scenario where data is being streamed
    continuously from devices or sensors in a reactive system. Asynchronous reactive
    programming would enable good stream management, which enables real-time stream
    processing as well as reacting to incoming data, which are fundamental use cases
    in IoT applications or even in data analytics contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having the preceding scenarios understood more clearly, you will be in a better
    position to tell when reactive programming is the best approach for your application.
    It all revolves around matching the needs and challenges of an application with
    what reactivity brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assess the need for reactivity, refer to the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance requirements**: Think about your application responsiveness and
    speed requirements. Reactive programming is necessary if your users expect applications
    to respond quickly while being more interactive compared to static pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data volume and velocity**: Estimate the degree of data volume and speed
    that your application will have to handle. In applications that involve a large
    volume of data or streaming of data at high velocity, reactivity may introduce
    the robustness and speed that is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity of operations**: Scrutinize the complexity of the operations that
    your application is performing. Be it complicated asynchronous task handling or
    complex user interactive dynamics, your reactive applications will provide more
    effective solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource constraints**: Consider the hardware and resources available. With
    reactive programming in relation to resource usage, it may be optimized most reasonably
    in comparison to traditional programming thus it is an appropriate paradigm for
    applications running in resource-constraint environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can decide to use or not use reactive programming according to these instances.
    Remember, the whole point is not about using the latest and greatest technology
    but creating a better experience for your users and a more manageable code base
    for your team. Consider whether reactive programming is a good choice for your
    next project given some of these factors and scenarios. In the next section, we
    will see which industries are most likely to choose to use the reactive approach,
    and we will also see the real-world usage of reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Learning from the field – reactive programming in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now know when we might need reactive programming in our projects. While
    we may not know the exact technology stack of every company, we can force our
    brains a little bit and make some predictions by identifying scenarios where reactive
    programming is likely at play and drawing inspiration from confirmed cases of
    its application. These are some platforms that most likely utilize reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streaming platforms such as Netflix**: If you are streaming media in a high
    quality, it means you have a huge volume of data. Millions of clients are expecting
    smooth, uninterrupted service simultaneously. In order to handle this data stream
    and provide uninterrupted services, most media services are using a reactive programming
    approach in their projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social media platforms such as LinkedIn and Twitter**: When we talk about
    social media, you can imagine how big the streams they have are. Again, millions
    of users publish, read, and listen at the same time. Uncountable user interactions
    and instant content delivery are the requirements of these projects. So, again,
    the best solution here is reactive programming because these requirements align
    well with the principles of reactive programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have assumed some companies are using reactive programming by considering
    their requirements. However, several organizations have openly shared their successful
    adoption of reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Booking.com**: Known for its global accommodation booking platform, Booking.com
    has implemented Spring WebFlux, enhancing its capability to provide a responsive
    and efficient service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Guardian**: The international news organization utilizes Akka and Play
    Framework to manage its real-time news updates and high traffic volumes, ensuring
    users have immediate access to the latest stories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patreon**: The membership platform uses RxJava to handle intricate financial
    transactions and user interactions, showcasing the ability of reactive programming
    to manage complex, data-intensive tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These real-world applications reflect how reactive programming is implemented
    across industries. While they are using different frameworks to handle the requirements,
    in the next section, we will focus on how Spring Boot 3.0 will help us implement
    reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Spring Boot 3.0 for reactive solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we say Spring Boot, the word “simplicity” rises in our minds out of the
    blue. The same can be said for reactive programming. In this section, first, we
    will go over the key concepts of Spring Boot 3.0 that can help us while engaging
    with reactive programming. Later on, we will see which libraries Spring Boot is
    using for this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying reactive development – tools and features in Spring Boot 3.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen, Spring Boot 3.0 is designed to simplify the entire development
    process by making it faster and easier to create robust applications. Here’s how
    it enhances reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto-configuration**: Spring Boot 3.0 auto-configures your application based
    on the dependencies you have added, reducing the need for manual setup and letting
    you focus on writing your business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standalone**: It allows you to create standalone applications that “just
    run,” simplifying deployment and testing. You don’t need an external server or
    container; your app can run as a simple executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opinionated defaults**: Spring Boot provides sensible defaults for project
    configurations. This means you spend less time configuring and more time building
    your application with the comfort of following best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community and extensions**: We can get help from a large Spring community
    and find ready-to-use extensions so that we can easily integrate additional functionalities
    into our application, from security to data access, without having to reinvent
    the wheel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are common Spring Boot features, which are not specific tools for reactive
    programming. But these help us implement the reactive approach as they help us
    with other frameworks by lowering the entry barrier and reducing boilerplate code.
    Spring Boot 3.0 lets us dive into reactive programming with less overhead and
    more support.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of reactivity – a closer look at WebFlux and Project Reactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The libraries in Spring Boot 3.0 for reactive capabilities are WebFlux and
    Project Reactor. We are going to discuss these components and it will give us
    a solid foundation for building reactive applications here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WebFlux**: This is the reactive web framework for Spring. It has been designed
    to be used in creating non-blocking, asynchronous web applications that could
    serve a high level of concurrent users effectively. It has been designed to work
    with all the reactive libraries and provides all you need to build a fully reactive
    REST application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` to *N* and `0` or `1` element data streams called Flux and Mono. With Project
    Reactor, you get a powerful toolkit to build, transform, and consume the reactive
    streams of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, WebFlux and Project Reactor form the backbone of complete reactive
    programming in Spring Boot. They provide a highly streamlined way of working with
    data streams and events, granting you a uniform model upon which you are able
    to build responsive and resilient applications. Real-time-data-implemented microservices
    or high-loaded applications can take advantage of the capacity that these tools
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up and looking forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we wrap up this section on reactive programming, let me summarize what we
    have learned. First, we touched upon the what, why, and how of reactive programming,
    got into the terminology, as well as surveyed some real-world applications. We
    came to know that reactive programming is not just a set of techniques but it’s
    actually a mindset for thinking about software development, where your first priority
    is to be responsive, then resilient, and its focus is on providing a great user
    experience. Finally, we have mentioned how can we use it in Spring Boot 3.0\.
    Now, it is the time for us to get our hands dirty. We’re now empowered with the
    knowledge of reactive programming and the next step is applying that knowledge
    through practice itself.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, though, as you go along that the process of mastering reactive programming
    is an enduring journey. It is one of a lifetime of continued learning, experimenting,
    and embracing growth at every opportunity that presents itself. So, enjoy yourself
    in making your applications more dynamic, more robust, and more user friendly
    with the opportunities that it presents. Cheers to all your success in the reactive
    world!
  prefs: []
  type: TYPE_NORMAL
- en: Building a reactive REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, now we are starting to write our first code in the reactive world with
    Spring Boot 3.0\. We will develop a REST API. As we all know, REST is the most
    used transfer protocol in applications. By this protocol, we can develop platform
    and language-independent applications. Because we can use REST in Java, Python,
    C#, and more, thanks to this protocol, each application can interact with each
    other hassle free. That’s why I have chosen REST API development in this sample.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we will initiate our Spring Boot 3.0 project. We will introduce each
    component step by step and we will understand why we are using them. So, let’s
    roll up our sleeves and begin this journey into the reactive world.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the first step – we need to be sure we have everything ready to use
    on our local machine. We have already mentioned the fundamental steps in the *Technical
    requirements* section. Here, we will have a quick check and initiate our project.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to start development, we will need an IDE. You can choose your favorite
    IDE. Popular choices among Java developers include IntelliJ IDEA, Eclipse, and
    Visual Studio Code. If the IDE has support for Spring Boot, it will make life
    easier for you, with helpful plugins and built-in features to simplify the coding
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Java is the most important component of our development environments.
    Spring Boot 3.0 requires at least Java 11, but we will use Java 17\. So, please
    be sure you have Java 17 installed on your development machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Initializr** is our next stop; we mentioned it previously in [*Chapter
    1*](B18400_01.xhtml#_idTextAnchor014). It’s an incredibly handy tool for bootstrapping
    your Spring Boot projects. It is accessible via a web interface or directly through
    your IDE and it allows you to generate a project with the desired dependencies,
    packaging, and Java version, all ready to be imported into your IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Spring Boot project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by visiting the Spring Initializr ([https://start.spring.io](https://start.spring.io))
    website or accessing it through your IDE. We will select Spring Boot version 3.2.5
    since it is the latest stable version of Spring Boot 3.0 and the Java version
    will be 17\. When you go to the link, you will see a screen like in *Figure 3**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Screenshot of the Spring Initializr window](img/B18400_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Screenshot of the Spring Initializr window'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a **Spring Initializr** sample project is in the figure. As
    for project metadata, fill in the relevant details such as **Group**, **Artifact**,
    **Name**, and **Description** to personalize your project. For dependencies, please
    choose the keys as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Reactive Web**: This is WebFlux and the most important dependency
    for this project, because our sample will be a reactive application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Data R2DBC**: We need this to connect a relational database in reactive
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H2 Database**: In our sample project, we are going to use an embedded database
    to reduce our dependency on another database server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve made all the selections, click on the **Generate** button to get
    the ready-to-build project. This will download a ZIP file containing a Gradle
    project, depending on your preference. Extract this and import it into your chosen
    IDE. You’re now ready to dive into the actual coding!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have completed the first important step. We have a running Spring Boot
    3.0 app on our local machine. In the next section, we will build it tile by tile.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the reactive data model
  prefs: []
  type: TYPE_NORMAL
- en: The data model is the key point for a project. Because the data model is the
    smallest piece of the architectural design of an application, we will decide how
    data is structured, stored, and accessed. In our sample project, we will have
    one `User` entity. We will see how to create it and discuss it, emphasizing the
    simplicity and power of records in Java, and the significance of annotations such
    as `@Table` and `@Id` in linking these structures with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a straightforward `User` entity characterized by an ID, a name, and
    an email. Traditionally in Java, we might define this as a class, but with the
    advantage of Java records, we will introduce it as a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-line code encapsulates everything our `User` entity is about: its
    fields are immutable, it comes equipped with necessary methods such as `equals()`
    and `hashCode()`, and it’s ready to interact with our database. Let’s break down
    the details.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding records versus classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At first sight, you can see a major difference between a record and a class;
    it is simplicity. But there are some more differences in the unseen side. Here’s
    why records are often favored over traditional classes in modern Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutability**: The fields of a record are final. This immutable nature is
    a boon in reactive applications where thread safety and predictability are paramount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals()`, `hashCode()`, and `toString()` methods cut down on repetitive code,
    keeping your models lean and focused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clarity**: A record’s structure makes it evident what it represents, fostering
    a code base that’s easier to understand and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we are clear on why we have chosen `record` instead of `class`. Now, let’s
    learn about the annotations in the code snippet in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding @Table and @Id annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When connecting our records to a database, annotations such as `@Table` and
    `@Id` come into play, especially when using Spring Data JPA or R2DBC for relational
    databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Table`: This annotation specifies the table name in the database with which
    this entity is associated. In our case, `@Table("users")` indicates that the `User`
    record corresponds to a table named `users` in the database. It’s a critical piece
    of information that **object-relational mapping** (**ORM**) frameworks use to
    map the record to the correct database table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Id`: Every table needs a primary key, and the `@Id` annotation helps you
    mark which field in your entity is the primary key. In the `User` record, annotating
    the `id` field with `@Id` tells the ORM framework that this field uniquely identifies
    each user and should be treated as the primary key in the database table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, defining our data model is an important step. By using annotations
    such as `@Table` and `@Id`, we make our model ready for efficient interaction
    with the database. This approach makes our code cleaner and more maintainable.
    In the next section, we will be dealing with the database operation part.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our reactive user management service, establishing a well-structured repository
    layer is essential. This layer will liaise between our application’s business
    logic and the database, handling all data interactions. In this section, we’ll
    delve into why the H2 database is a prime choice for development purposes, how
    to configure it, and the significance of implementing reactive repositories using
    `R2dbcRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the H2 database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing an application, the H2 database is a good option due to its
    simplicity and ease of use. It’s a lightweight and in-memory database that doesn’t
    require installation or setup, making it ideal for testing and development. The
    database starts and stops with your application, allowing for quick testing without
    affecting any live databases. Additionally, the H2 database is compatible with
    SQL, making it easy to switch to a more permanent database if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring application properties and schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To integrate the H2 database into your Spring Boot application, you’ll need
    to configure the `application.properties` file. Here’s a basic setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, we need to define our database schema and initial data in a `schema.sql`
    file located in our resources directory. This SQL script is automatically executed
    when your application starts, setting up your database schema.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to reactive repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a traditional Spring application, you might be familiar with JPA and the
    `CrudRepository` interface for managing data operations. However, in the reactive
    world, we use `ReactiveCrudRepository` or `R2dbcRepository`. These interfaces
    are designed to work with reactive types, such as `Mono` and `Flux`. By using
    these interfaces we will ensure that all data operations are non-blocking and
    support backpressure. This shift to reactive types allows our application to handle
    operations asynchronously and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding R2dbcRepository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ReactiveCrudRepository` offers all the standard `Mono` for single results
    or `Flux` for multiple results. This helps us to integrate seamlessly with the
    rest of the reactive infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s define a repository for the User entity. Utilizing the `R2dbcRepository`
    interface, you can create a customized repository that extends its capabilities.
    Here’s what a simple `UserRepository` might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `UserRepository` extends `R2dbcRepository`. The `findByEmail`
    method is a custom query method that returns `Mono<User>`. This method returns
    a single-user result in a reactive wrapper. This method might be used to check
    unique email constraints or retrieve user information.
  prefs: []
  type: TYPE_NORMAL
- en: By these simple lines, we can implement the repository layer. By choosing the
    H2 database for development, we simplify our setup process and make our development
    cycle faster and more flexible. As we continue to build your user management service,
    remember that each layer, from the data model to the repository, is a part of
    our reactive application. Now, we will see how we can connect the user and repository
    with the controller layer.
  prefs: []
  type: TYPE_NORMAL
- en: Building the reactive REST controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controller layer is the place where we interact with the outside world.
    Our application will handle incoming HTTP requests and respond reactively. Let’s
    dive into how a reactive controller operates and walk through the implementation
    of essential CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of controller structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a Spring Boot application, controllers are the gatekeepers of our API. It
    navigates incoming requests to the appropriate services or actions. In a reactive
    environment, these controllers are designed to work with non-blocking operations
    and handle streams of data efficiently. The `@RestController` annotation is the
    default annotation for RESTful controllers. There is no specific change for reactive
    in this creating a controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic structure of our reactive `UserController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this class, `@RestController` marks it as a controller where each method
    returns a domain object, and the client gets it as a JSON object. `@RequestMapping("/users")`
    sets the base path for all routes in the controller. We also inject `UserRepository`
    to interact with the database reactively.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CRUD operations form the core functionalities of most APIs, allowing clients
    to create, read, update, and delete resources. Here’s how these operations are
    implemented reactively in `UserController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create (POST)**: We always use HTTP POST calls for creating a new record:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `createUser` method handles POST requests to `/users`, saving a new user
    to the database. Notice the return type is `Mono<User>`, indicating it’s a single
    asynchronous operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**List all users (GET)**: This method is used to list or read the data from
    the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Delete (DELETE)**: We always use this method when we want to delete a record
    in our applications:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `deleteUser` method handles the deletion of a user given their ID. The `Mono<Void>`
    return type indicates an operation that will complete without emitting any data
    (void).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this reactive REST controller, we ensure that every operation is non-blocking
    and scalable. This will allow our API to handle a large number of concurrent users
    and operations. As you can notice, each CRUD operation returns Mono or Flux (a
    single item or a stream). These methods were basic operations and now we will
    see a sample that is a bit more complex in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding advanced Mono operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a reactive REST API involves more than just implementing the basic
    CRUD operations. It’s about enhancing the functionality to handle real-world scenarios
    efficiently and effectively. Now, assume we have a business requirement to check
    the email uniqueness of the user when creating a new user. Let’s enrich the `createUser`
    method by using advanced Mono operations to ensure email uniqueness and provide
    a more robust error-handling strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In order to check email uniqueness, we need to use several reactive operators
    and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the advanced `createUser` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s learn about the reactive methods in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flatMap()`: Useful for mapping and flattening, `flatMap()` allows you to chain
    asynchronous operations, making it perfect for checking conditions or transforming
    data. In this sample, this operator is used to check whether the email already
    exists. If the email is found, it throws a custom `EmailUniquenessException`.
    This ensures that each email in the system is unique and provides a clear path
    for handling the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`then()`: This is used for chaining another `Mono` and executing it after the
    previous operation completes. In our case, after ensuring the email doesn’t exist,
    `then()` is used to save the new user. It effectively chains the user save operation,
    ensuring it only occurs if the email uniqueness check passes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`: This transforms the data in the stream, often used for converting
    one type to another or wrapping it in another object. In our case, once the user
    is saved, `map()` transforms the saved user into `ResponseEntity` with an `OK`
    status, ready to be returned to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnNext():` This executes side effects, such as logging or metrics collection,
    without altering the stream. In our case, this operator is used for logging or
    any other side actions you want to perform after the new user is created. It’s
    a way to tap into the stream and perform an action without altering the data flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onErrorResume()`: This provides a way to recover from errors, allowing you
    to continue the data flow with an alternative `Mono`. This is crucial for error
    handling; this operator catches exceptions and allows you to provide an alternative
    `Mono`. In the case of `EmailUniquenessException`, it returns `ResponseEntity`
    with a conflict status, indicating the email is already in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding these advanced `Mono` operations into your `createUser` method transforms
    it from a simple save function to a more sophisticated, real-world-ready operation.
    This approach ensures data integrity with the email uniqueness check. It also
    provides clearer communication back to the client about the result of their request,
    whether successful or in error. Now, it is time to run the application and see
    how it looks in the user’s eye.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Spring Boot application with Gradle and Java 17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With your reactive REST API in place and ready to show its prowess, it’s time
    to run the application using Gradle and Java 17\. Here’s how you can get your
    application up and running in no time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a Spring Boot application using Gradle, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal or command prompt and change the directory to the root directory
    of your project where the `build.gradle` file is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the Run Command – use the following command to start your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command initiates the Gradle build process, compiles your Java code, and
    starts the embedded server (typically Tomcat) that comes with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the run command, watch the console for log messages. Spring
    Boot provides detailed logs that can help you understand what’s happening behind
    the scenes. The key things to look for are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build success**: Indications that Gradle has successfully built your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application starting**: Messages related to your application context, beans,
    and embedded server starting up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running application**: A log entry similar to “Started application in *X*
    seconds” signifies that your application is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, your application will be accessible at `http://localhost:8080`.
    This can be changed in your `application.properties` or `application.yml` file
    if a different port or context path is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our application is up and running, it’s important to test its functionality.
    Interact with some of the endpoints in your API using cURL commands or whichever
    other tool you would use to make API calls. This interaction will validate whether
    your application is working (i.e., processing requests from the users and responding
    as required).
  prefs: []
  type: TYPE_NORMAL
- en: Now, our application is running on our local machine. We can create, list, and
    delete users in our embedded database. Also, we can test the reactive abilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will test its capabilities and see how the reactive
    approach can help us under concurrent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an indispensable part of application development. We need to ensure
    that every component functions as expected and that the entire system operates
    seamlessly. We will cover the unit test part in [*Chapter 6*](B18400_06.xhtml#_idTextAnchor192).
    However, unit tests are not the only way to test our application. We can manually
    test the endpoints of your reactive REST API to verify its functionality. We will
    see how to do this in this section.
  prefs: []
  type: TYPE_NORMAL
- en: cURL is a versatile command-line tool used for transferring data with URLs.
    It’s an excellent choice for manually testing HTTP endpoints. By executing cURL
    commands, you can simulate client requests to your application and observe the
    responses, ensuring that each part of your application reacts as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are cURL scripts and their expected outputs for testing the various endpoints
    of your user management service, including the scenario of an email uniqueness
    violation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /users`**)**: These are the steps for creating a new user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a new user**: We will create a single user with this cURL command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`GET /users`**)**: This command will list all the users in the system:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'DELETE /users/{id}1:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: By these manual tests, we ensure that the app is working and acting as expected
    in various scenarios. Also, we could test the edge case for email uniqueness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve come to the end of the section, let’s take a step back and look at
    our journey. We learned how to build a reactive REST API with Spring Boot 3.0
    – and it’s not all about coding; it’s choosing a modern way of making apps. So,
    in learning reactive programming, you learned how to make quicker, tougher services
    and the capacity to handle a larger load. You went through setting up, making
    a data model, creating a place to store the data reactively, and making a REST
    controller that can do a lot. Finally, we worked on a reactive API example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reactive programming is a big shift. In it, the focus is on data that never
    stops and is asynchronous. If you learn this, you’re ready for modern software
    needs. These are quick reactions, good performance, and great user experiences.
    Reactive programming makes a system work better under pressure, using resources
    well, and also becoming more naturally manageable to handle many tasks at once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Keep applying what you have learned about reactive principles and techniques.
    It may be challenging at first, but it will certainly be worth it. Embrace the
    reactive way, and you will create systems that are not only strong but also efficient
    and robust.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But that’s not all. In the next section, you’ll learn all about asynchronous
    systems and backpressure. We’ll look at how to keep lots of data manageable so
    your app remains stable and quick. Understanding back pressure is key in our high-data
    world with expectations for speed and reliability as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don’t forget to use the finalized project to get first-hand experience. Check
    out the GitHub repository to get the full code, see how the full system works,
    and start your work from there on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Asynchronous systems and backpressure
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In the competitive world, asynchronous communication has become a key element
    in modern web applications because it promises efficiency and scalability. When
    we use the term “asynchronous,” reactive systems come to mind. As we already know,
    the need for an asynchronous system comes from the requirement to handle lots
    of data streams. So, the system should handle these streams and protect itself
    from exhaustion. At this point, the role of backpressure arises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we will discover what backpressure is and how we can implement
    it in our current sample project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Diving into backpressure
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: We were told that backpressure is a lifesaver mechanism, but we need to clarify
    this. In this section, we are going to discuss what backpressure is, why we need
    it, and how it protects our systems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is backpressure?
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a situation where there is a high-speed conveyor belt delivering products
    to a packer. If the packer can’t keep up with the speed, the products will pile
    up, and the products will get damaged or lost. Backpressure is a method to control
    the flow of products based on the packer’s capacity. It’s like giving the packer
    a “stop” button to prevent overwhelming scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In reactive streams, backpressure is a crucial concept. It allows a data consumer
    (subscriber) to communicate with the data producer (publisher) about the amount
    of data it can handle at a time. This prevents overwhelming scenarios and ensures
    a smooth and manageable data flow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why is backpressure necessary?
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define it as a “stop” button, so you can imagine the disaster that may cause
    if we don’t have it. So, without backpressure, systems can run into some of the
    following critical issues:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Memory overruns**: When the incoming data stream is faster than the application
    can process, the server may run out of memory'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poor performance**: As the system struggles to manage the irregular flow,
    overall performance can decrease, causing slower response times and a poor user
    experience'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System crashes**: In extreme cases, such as unexpected high demand occurs
    on our application, the system may crash'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Backpressure is not just a nice-to-have feature. It’s an inevitable requirement
    for systems if we need to manage unpredicted data streams. In the next section,
    we will discuss how we can use it in the Spring world.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Backpressure in Project Reactor
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Project Reactor is a foundational library for reactive programming in the Spring
    ecosystem. It implements backpressure using the reactive streams specification.
    This would mean ensuring the parts of a program that send out data do it in a
    controlled way based on what the parts that receive the data can deal with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Reactor, as a Flux or Mono typically sends data (data sequences), it doesn’t
    just send all the data at once. Within this pattern, instead, the part that receives
    the data (the subscriber) asks for only as much of that data as it can deal with
    at one time. This asking is done through a method called request(n). Here’s how
    it works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Request(n)**The subscriber can request a specific number of items. In this
    way, the subscriber informs the producer about its current capacity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic adjustment**: As the subscriber processes data, it can dynamically
    adjust its requests based on current load, processing speed, and other factors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Propagated backpressure**: Backpressure is not just between one producer
    and one consumer, but is used in entire systems to keep a balance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Project Reactor, developers can build reliable and stable applications
    in which data will be processed in an optimal manner and not overload the system.
    Each component only processes a set of data it can work with, therefore contributing
    to a balanced system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we’ll be working on the project, we will see how these ideas become translated
    into code and what they boil down to when you bring them to practice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are going to go through different strategies, take a look at logs and data,
    and observe backpressure, which keeps the system balanced. Remember, understanding
    backpressure is about making systems that can handle data well and stay steady
    and fast.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing backpressure in the project
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Backpressure is like a dance between data senders and receivers. It makes sure
    data doesn’t come too fast or slow. Our goal is to keep the flow of data smooth
    and prevent too much data from causing problems. Let’s look at how we can tell
    when receivers get too much data, what we can do about it, and see how it works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Detecting overwhelmed consumers
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a perfect situation, data moves smoothly from senders to receivers. But
    sometimes, receivers get more than they can handle. We should detect such cases
    and implement solutions accordingly. There are a few signals, as shown here, that
    we can smell while we monitor the application performance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Observing latency and throughput**: We can tell something is wrong if it
    takes longer for data to process or if less data is processed over time'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error rates and patterns**: A lot of errors or certain types of errors can
    also show that there’s too much data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization**: If the consumer is using too much computer power
    or memory, it might be getting too much data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to detect whether we need backpressure, in the next section,
    we will explore strategies for handling it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Strategies for handling backpressure
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we know our consumer is struggling, how do we handle it? We can introduce
    some of the different approaches mentioned here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Buffering**: Temporarily holding data until the consumer is ready. This strategy
    works well if the overload is short-lived or intermittent.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dropping data**: In some cases, particularly with real-time data, it might
    be acceptable to drop some data to keep up with the flow.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching**: Accumulating data into larger, less frequent batches can reduce
    overhead and allow consumers to catch up.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting**: Limiting the rate at which the producer sends data to match
    the consumer’s capacity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After learning the strategies for handling backpressure, we will implement backpressure
    in our application in the following section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing backpressure in the project
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s enhance our Spring Boot project to include backpressure handling.
    We’ll focus on a typical scenario: a RESTful service where the consumer is a client
    application requesting a large stream of data. Let’s see how to implement it step
    by step:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Define a logger**: Set up a logging instance to observe how backpressure
    is affecting the data flow:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`getAllUsers` endpoint that logs with more detail:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`/stream` **endpoint**: Implement a new endpoint that introduces backpressure
    through Project Reactor’s built-in mechanisms:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: After introducing these changes in our project, we can do a small load test.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First off, I have used this bash script to create a load on the system:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This bash script will create 300 concurrent requests to the URL mentioned in
    the script. We can also use the same script for `URL="http://localhost:8080/users"`
    and make a comparison between response time and system load.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The logs from using the cURL command to create a load on the `/getAllUsers`
    and `/streamUsers` endpoints illustrate how the system performs under stress and
    give insights into how backpressure and asynchronous processing are working. Let’s
    analyze the differences and what they might indicate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: getAllUsers endpoint logs
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `/getAllUsers` endpoint sends all user data very fast and doesn’t control
    the flow of data. At first, it’s quick (around 226 ms for each request). But when
    more people use it, each request takes longer – even twice as long. This happens
    when systems are very busy and don’t control incoming requests. They keep taking
    in more work, but as they get busier, each task takes longer because the system
    is too busy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: streamUsers endpoint logs
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `/streamUsers` endpoint has a way to manage data called backpressure, using
    `.onBackpressureBuffer()`. At the start, it handles requests steadily. As it gets
    busier, the time for each request goes up – slower than the `/getAllUsers` endpoint,
    but it still increases. This slower increase is a sign that the system is controlling
    the data flow. It’s adjusting to handle what it can without getting too overwhelmed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Observations and conclusions
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our local test tells us information even without performance monitoring tools.
    You can see the logs in your local server for both endpoints. These are the observations
    of the logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Initial performance**: Both endpoints start with similar processing times
    for streaming users. This shows us both endpoints work pretty much the same under
    normal conditions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/getAllUsers` endpoint is more rapid. This shows as it becomes overwhelmed
    more quickly. The `/streamUsers` endpoint shows a more gradual increase in time,
    suggesting the backpressure is allowing the system to handle the load more gracefully.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System stress**: This is when we see the response times increasing under
    load. In real-world scenarios, this is an absolute signal that we need to apply
    performance optimizations such as improving database access, increasing server
    resources, or further refining backpressure strategies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The logs give us a good idea of how the system works under a lot of stress and
    suggests backpressure helps in `/streamUsers`. However, to really understand and
    improve the system, you’d need more detailed information. The slow increase in
    response times when busy is a common sign the system is struggling. This is when
    you might need to make big changes or fine-tune the system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By carefully using and watching backpressure, we’ve made our project more stable
    and efficient. We’ve learned a lot about how data moves and is controlled. Remember,
    backpressure isn’t a simple fix. It needs careful thought and adjustments to meet
    the changing needs of applications. But with what we’ve learned, we’re ready to
    make sure your applications can handle data well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), we have dived into the paradigm
    shift towards reactive programming with Spring Boot 3.0\. From developing a fundamental
    understanding of the heart and core of reactive programming in moving ahead to
    prove the importance of these paradigms to make applications more responsive,
    efficient, and robust.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is what we have covered:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Transitioning to reactive programming**: We contrasted reactive and traditional
    programming by shifting to a non-blocking model that solves asynchronously for
    faster and more responsive applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building reactive REST APIs**: We have covered the essentials of building
    a reactive REST API, understanding asynchronous systems, and the concept of backpressure
    for executing data flow effectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting up for success**: The chapter gave a detailed outline of how to set
    up your development environment, from the installation of Java 17 and IntelliJ
    IDEA all the way through to how to create the reactive data model, how to implement
    the repository layer, and how to build a reactive REST controller using Spring
    Boot 3.0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Further down the line in [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146), we’ll
    manage data with Spring Data, where I will explore both SQL as well as NoSQL databases.
    We also go into migration as well as consistency of the data, ensuring your applications
    are still hardy and running smoothly. The following chapter will include the *Using
    Spring Data with SQL databases*, *NoSQL databases in Spring Boot*, and *Data migration
    and consistency* sections. The next chapter will dive deeper into issues concerning
    data management inside of the Spring ecosystem and prepare you for the challenges
    of various databases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we transition from just understanding any reactive paradigm in the development
    of software to actually mastering data management with the power of Spring Boot
    3.0 simplifying and enhancing these processes, do keep what you have learned in
    this chapter in mind. Stay tuned for more insightful discussions and practical
    guides as laid out in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Part 3: Data Management, Testing, and Security'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part addresses critical components of software development: data management,
    testing, and security. Starting with [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146),
    you’ll get to grips with Spring Data, exploring SQL, NoSQL, and caching techniques.
    [*Chapter 5*](B18400_05.xhtml#_idTextAnchor179) focuses on securing your Spring
    Boot applications, ensuring they are robust against unauthorized access. Finally,
    [*Chapter 6*](B18400_06.xhtml#_idTextAnchor192) introduces advanced testing strategies
    that help validate and improve the reliability of your software. This part is
    crucial for creating well-rounded, secure, and efficiently managed applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18400_04.xhtml#_idTextAnchor146), *Spring Data: SQL, NoSQL,
    Cache Abstraction, and Batch Processing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18400_05.xhtml#_idTextAnchor179), *Securing Your Spring Boot
    Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18400_06.xhtml#_idTextAnchor192), *Advanced Testing Strategies*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
