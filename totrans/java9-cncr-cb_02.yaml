- en: Basic Thread Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本线程同步
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Synchronizing a method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步方法
- en: Using conditions in synchronized code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同步代码中使用条件
- en: Synchronizing a block of code with a lock
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁同步代码块
- en: Synchronizing data access with read/write locks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读写锁同步数据访问
- en: Using multiple conditions in a lock
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锁中使用多个条件
- en: Advanced locking with the StampedLock class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用StampedLock类的高级锁定
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most common situations in concurrent programming occurs when more
    than one execution thread shares a resource. In a concurrent application, it is
    normal for multiple threads to read or write the same data structure or have access
    to the same file or database connection. These shared resources can provoke error
    situations or data inconsistency, and we have to implement mechanisms to avoid
    these errors. These situations are called **race conditions** and they occur when
    different threads have access to the same shared resource at the same time. Therefore,
    the final result depends on the order of the execution of threads, and most of
    the time, it is incorrect. You can also have problems with change visibility.
    So if a thread changes the value of a shared variable, the changes would only
    be written in the local cache of that thread; other threads will not have access
    to the change (they will only be able to see the old value).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中最常见的情况之一是多个执行线程共享一个资源。在并发应用程序中，多个线程读取或写入相同的数据结构或访问相同的文件或数据库连接是正常的。这些共享资源可能会引发错误情况或数据不一致，我们必须实现机制来避免这些错误。这些情况被称为**竞态条件**，它们发生在不同线程同时访问同一共享资源时。因此，最终结果取决于线程执行的顺序，大多数情况下，结果是错误的。你还会遇到变化可见性的问题。所以如果一个线程改变了共享变量的值，这些更改只会写入该线程的本地缓存；其他线程将无法访问这些更改（它们只能看到旧值）。
- en: The solution for these problems lies in the concept of **critical section**.
    A critical section is a block of code that accesses a shared resource and can't
    be executed by more than one thread at the same time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方案在于**临界区**的概念。临界区是一段访问共享资源的代码块，不能同时被多个线程执行。
- en: 'To help programmers implement critical sections, Java (and almost all programming
    languages) offers synchronization mechanisms. When a thread wants access to a
    critical section, it uses one of these synchronization mechanisms to find out
    whether there is any other thread executing the critical section. If not, the
    thread enters the critical section. If yes, the thread is suspended by the synchronization
    mechanism until the thread that is currently executing the critical section ends
    it. When more than one thread is waiting for a thread to finish the execution
    of a critical section, JVM chooses one of them and the rest wait for their turn.
    This chapter presents a number of recipes that will teach you how to use the two
    basic synchronization mechanisms offered by the Java language:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助程序员实现临界区，Java（以及几乎所有编程语言）提供了同步机制。当一个线程想要访问临界区时，它会使用这些同步机制之一来检查是否有其他线程正在执行临界区。如果没有，线程将进入临界区。如果有，线程将被同步机制挂起，直到当前执行临界区的线程结束。当多个线程都在等待一个线程完成临界区的执行时，JVM会选择其中一个，其余的则等待轮到它们。本章将介绍一些食谱，教你如何使用Java语言提供的两种基本同步机制：
- en: The `synchronized` keyword
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`关键字'
- en: The `Lock` interface and its implementations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口及其实现'
- en: Synchronizing a method
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步方法
- en: In this recipe, you will learn how to use one of the most basic methods of synchronization
    in Java, that is, the use of the `synchronized` keyword to control concurrent
    access to a method or a block of code. All the `synchronized` sentences (used
    on methods or blocks of code) use an object reference. Only one thread can execute
    a method or block of code protected by the same object reference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何使用Java中最基本的同步方法之一，即使用`synchronized`关键字来控制对方法或代码块的并发访问。所有`synchronized`语句（用于方法或代码块）都使用一个对象引用。只有一个线程可以执行由相同对象引用保护的同一个方法或代码块。
- en: When you use the `synchronized` keyword with a method, the object reference
    is implicit. When you use the `synchronized` keyword in one or more methods of
    an object, only one execution thread will have access to all these methods. If
    another thread tries to access any method declared with the `synchronized` keyword
    of the same object, it will be suspended until the first thread finishes the execution
    of the method. In other words, every method declared with the `synchronized` keyword
    is a critical section, and Java only allows the execution of one of the critical
    sections of an object at a time. In this case, the object reference used is the
    `own` object, represented by the `this` keyword. Static methods have a different
    behavior. Only one execution thread will have access to one of the static methods
    declared with the `synchronized` keyword, but a different thread can access other
    non-static methods of an object of that class. You have to be very careful with
    this point because two threads can access two different `synchronized` methods
    if one is static and the other is not. If both methods change the same data, you
    can have data inconsistency errors. In this case, the object reference used is
    the class object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在方法中使用`同步`关键字时，对象引用是隐式的。当您在一个或多个对象的方法中使用`同步`关键字时，只有一个执行线程可以访问所有这些方法。如果另一个线程尝试访问同一对象声明为`同步`关键字的方法，它将被挂起，直到第一个线程完成方法的执行。换句话说，每个声明为`同步`关键字的方法都是一个临界区，Java只允许同时执行一个对象的临界区。在这种情况下，使用的对象引用是`own`对象，由`this`关键字表示。静态方法有不同的行为。只有一个执行线程可以访问声明为`同步`关键字的静态方法，但不同的线程可以访问该类对象的其它非静态方法。您必须非常小心这一点，因为如果一个是静态的而另一个不是，两个线程可以访问两个不同的`同步`方法。如果两个方法更改相同的数据，您可能会遇到数据不一致错误。在这种情况下，使用的对象引用是类对象。
- en: When you use the `synchronized` keyword to protect a block of code, you must
    pass an object reference as a parameter. Normally, you will use the `this` keyword
    to reference the object that executes the method, but you can use other object
    references as well. Normally, these objects will be created exclusively for this
    purpose. You should keep the objects used for synchronization private. For example,
    if you have two independent attributes in a class shared by multiple threads,
    you must synchronize access to each variable; however, it wouldn't be a problem
    if one thread is accessing one of the attributes and the other accessing a different
    attribute at the same time. Take into account that if you use the `own` object
    (represented by the `this` keyword), you might interfere with other synchronized
    code (as mentioned before, the `this` object is used to synchronize the methods
    marked with the `synchronized` keyword).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`同步`关键字保护代码块时，您必须传递一个对象引用作为参数。通常，您将使用`this`关键字来引用执行方法的对象，但您也可以使用其他对象引用。通常，这些对象将专门为此目的创建。您应该将用于同步的对象保持为私有。例如，如果您有一个由多个线程共享的类中的两个独立属性，您必须同步访问每个变量；然而，如果一个线程同时访问一个属性，而另一个线程访问另一个属性，这不会成为问题。请注意，如果您使用`own`对象（由`this`关键字表示），您可能会干扰其他同步代码（如前所述，`this`对象用于同步标记为`同步`关键字的方法）。
- en: 'In this recipe, you will learn how to use the `synchronized` keyword to implement
    an application simulating a parking area, with sensors that detect the following:
    when a car or a motorcycle enters or goes out of the parking area, an object to
    store the statistics of the vehicles being parked, and a mechanism to control
    cash flow. We will implement two versions: one without any synchronization mechanisms,
    where we will see how we obtain incorrect results, and one that works correctly
    as it uses the two variants of the `synchronized` keyword.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用`同步`关键字来实现一个模拟停车场的应用程序，该程序具有以下传感器：当汽车或摩托车进入或离开停车场时，一个用于存储停放车辆统计信息的对象，以及一个控制现金流量的机制。我们将实现两个版本：一个没有同步机制，我们将看到如何得到错误的结果，另一个版本正确工作，因为它使用了`同步`关键字的两个变体。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或NetBeans等不同的IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, create the application without using any synchronization mechanism.
    Create a class named `ParkingCash` with an internal constant and an attribute
    to store the total amount of money earned by providing this parking service:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement a method named `vehiclePay()` that will be called when a vehicle
    (a car or motorcycle) leaves the parking area. It will increase the cash attribute:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, implement a method named `close()` that will write the value of the
    cash attribute in the console and reinitialize it to zero:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a class named `ParkingStats` with three private attributes and the constructor
    that will initialize them:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, implement the methods that will be executed when a car or motorcycle
    enters or leaves the parking area. When a vehicle leaves the parking area, cash
    should be incremented:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, implement two methods to obtain the number of cars and motorcycles
    in the parking area, respectively.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `Sensor` that will simulate the movement of vehicles in
    the parking area. It implements the `Runnable` interface and has a `ParkingStats`
    attribute, which will be initialized in the constructor:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `run()` method. In this method, simulate that two cars and a
    motorcycle arrive in and then leave the parking area. Every sensor will perform
    this action 10 times:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, implement the main method. Create a class named `Main` with the `main()`
    method. It needs `ParkingCash` and `ParkingStats` objects to manage parking:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, create the `Sensor` tasks. Use the `availableProcessors()` method (that
    returns the number of available processors to the JVM, which normally is equal
    to the number of cores in the processor) to calculate the number of sensors our
    parking area will have. Create the corresponding `Thread` objects and store them
    in an array:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then wait for the finalization of the threads using the `join()` method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, write the statistics of `Parking`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our case, we executed the example in a four-core processor, so we will have
    eight `Sensor` tasks. Each task performs 10 iterations, and in each iteration,
    three vehicles enter the parking area and the same three vehicles go out. Therefore,
    each `Sensor` task will simulate 30 vehicles.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, the final stats will show the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: There are no cars in the parking area, which means that all the vehicles that
    came into the parking area have moved out
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight `Sensor` tasks were executed, where each task simulated 30 vehicles and
    each vehicle was charged 2 dollars each; therefore, the total amount of cash earned
    was 480 dollars
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you execute this example, each time you will obtain different results,
    and most of them will be incorrect. The following screenshot shows an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'We had race conditions, and the different shared variables accessed by all
    the threads gave incorrect results. Let''s modify the previous code using the
    synchronized keyword to solve these problems:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the synchronized keyword to the `vehiclePay()` method of the `ParkingCash`
    class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`同步`关键字添加到`ParkingCash`类的`vehiclePay()`方法中：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, add a `synchronized` block of code using the `this` keyword to the `close()`
    method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将使用`this`关键字的`同步`代码块添加到`close()`方法中：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now add two new attributes to the `ParkingStats` class and initialize them
    in the constructor of the class:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向`ParkingStats`类添加两个新的属性，并在类的构造函数中初始化它们：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, modify the methods that increment and decrement the number of cars
    and motorcycles, including the `synchronized` keyword. The `numberCars` attribute
    will be protected by the `controlCars` object, and the `numberMotorcycles` attribute
    will be protected by the `controlMotorcycles` object. You must also synchronize
    the `getNumberCars()` and `getNumberMotorcycles()` methods with the associated
    reference object:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改增加和减少汽车和摩托车数量的方法，包括使用`同步`关键字。`numberCars`属性将由`controlCars`对象保护，而`numberMotorcycles`属性将由`controlMotorcycles`对象保护。您还必须将`getNumberCars()`和`getNumberMotorcycles()`方法与相关引用对象同步：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Execute the example now and see the difference when compared to the previous
    version.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在执行示例，并与之前的版本进行比较，看看差异。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the output of the new version of the example.
    No matter how many times you execute it, you will always obtain the correct result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例的新版本输出。无论您执行多少次，您都将始终获得正确的结果：
- en: '![](img/00015.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: 'Let''s see the different uses of the `synchronized` keyword in the example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看示例中`同步`关键字的用法：
- en: First, we protected the `vehiclePay()` method. If two or more `Sensor` tasks
    call this method at the same time, only one will execute it and the rest will
    wait for their turn; therefore, the final amount will always be correct.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们保护了`vehiclePay()`方法。如果有两个或更多`Sensor`任务同时调用此方法，只有一个会执行它，其余的将等待它们的轮次；因此，最终金额总是正确的。
- en: We used two different objects to control access to the car and motorcycle counters.
    This way, one `Sensor` task can modify the `numberCars` attribute and another
    `Sensor` task can modify the `numberMotorcycles` attribute at the same time; however,
    no two `Sensor` tasks will be able to modify the same attribute at the same time,
    so the final value of the counters will always be correct.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了两个不同的对象来控制对汽车和摩托车计数器的访问。这样，一个`Sensor`任务可以修改`numberCars`属性，另一个`Sensor`任务可以修改`numberMotorcycles`属性，但同时不会有两个`Sensor`任务能够同时修改相同的属性，所以计数器的最终值总是正确的。
- en: Finally, we also synchronized the `getNumberCars()` and `getNumberMotorcycles()`
    methods. Using the `synchronized` keyword, we can guarantee correct access to
    shared data in concurrent applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还同步了`getNumberCars()`和`getNumberMotorcycles()`方法。使用`同步`关键字，我们可以在并发应用程序中保证对共享数据的正确访问。
- en: As mentioned at the introduction of this recipe, only one thread can access
    the methods of an object that uses the `synchronized` keyword in their declaration.
    If thread (A) is executing a `synchronized` method and thread (B) wants to execute
    another `synchronized` method of the same object, it will be blocked until thread
    (A) is finished. But if thread (B) has access to different objects of the same
    class, none of them will be blocked.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如本食谱介绍中所述，只有一个线程可以访问使用`同步`关键字声明的方法的对象。如果线程（A）正在执行`同步`方法，而线程（B）想要执行同一对象的另一个`同步`方法，它将被阻塞，直到线程（A）完成。但如果线程（B）可以访问同一类的不同对象，则它们都不会被阻塞。
- en: When you use the `synchronized` keyword to protect a block of code, you use
    an object as a parameter. JVM guarantees that only one thread can have access
    to all the blocks of code protected with this object (note that we always talk
    about objects, not classes).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`同步`关键字来保护代码块时，您使用一个对象作为参数。JVM保证只有一个线程可以访问由该对象保护的代码块（注意我们总是谈论对象，而不是类）。
- en: 'We used the `TimeUnit` class as well. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`. These indicate the units of time we pass
    to the sleep method. In our case, we let the thread sleep for 50 milliseconds.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`TimeUnit`类。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。这些表示我们传递给sleep方法的单位时间。在我们的例子中，我们让线程休眠50毫秒。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `synchronized` keyword penalizes the performance of the application, so
    you must only use it on methods that modify shared data in a concurrent environment.
    If you have multiple threads calling a `synchronized` method, only one will execute
    them at a time while the others will remain waiting. If the operation doesn't
    use the `synchronized` keyword, all the threads can execute the operation at the
    same time, reducing the total execution time. If you know that a method will not
    be called by more than one thread, don't use the `synchronized` keyword. Anyway,
    if the class is designed for multithreading access, it should always be correct.
    You must promote correctness over performance. Also, you should include documentation
    in methods and classes in relation to their thread safety.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`同步`关键字会惩罚应用程序的性能，因此你只能在并发环境中修改共享数据的方法上使用它。如果有多个线程调用`同步`方法，则一次只有一个线程执行它们，而其他线程将保持等待。如果操作没有使用`同步`关键字，所有线程都可以同时执行该操作，从而减少总执行时间。如果你知道一个方法不会被多个线程调用，不要使用`同步`关键字。无论如何，如果类是为多线程访问设计的，它应该始终是正确的。你必须将正确性置于性能之上。此外，你应该在方法和类中包含有关它们线程安全的文档。'
- en: You can use recursive calls with `synchronized` methods. As the thread has access
    to the `synchronized` methods of an object, you can call other `synchronized`
    methods of that object, including the method that is being executed. It won't
    have to get access to the `synchronized` methods again.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用递归调用与`同步`方法。由于线程可以访问对象的`同步`方法，你可以调用该对象的其他`同步`方法，包括正在执行的方法。它不需要再次获取对`同步`方法的访问。
- en: 'We can use the `synchronized` keyword to protect access to a block of code
    instead of an entire method. We should use the `synchronized` keyword in this
    way to protect access to shared data, leaving the rest of the operations out of
    this block and obtaining better performance of the application. The objective
    is to have the critical section (the block of code that can be accessed only by
    one thread at a time) as short as possible. Also, avoid calling blocking operations
    (for example, I/O operations) inside a critical section. We have used the `synchronized`
    keyword to protect access to the instruction that updates the number of persons
    in the building, leaving out the long operations of the block that don''t use
    shared data. When you use the `synchronized` keyword in this way, you must pass
    an object reference as a parameter. Only one thread can access the `synchronized`
    code (blocks or methods) of this object. Normally, we will use the `this` keyword
    to reference the object that is executing the method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`同步`关键字来保护代码块（而不是整个方法）的访问。我们应该这样使用`同步`关键字来保护对共享数据的访问，将其他操作排除在这个代码块之外，从而获得更好的应用程序性能。目标是使关键部分（一次只能由一个线程访问的代码块）尽可能短。此外，避免在关键部分内部调用阻塞操作（例如，I/O操作）。我们已经使用`同步`关键字来保护更新建筑物中人数的指令的访问，排除了该代码块中不使用共享数据的长时间操作。当你以这种方式使用`同步`关键字时，你必须传递一个对象引用作为参数。只有一个线程可以访问该对象的`同步`代码（代码块或方法）。通常，我们将使用`this`关键字来引用执行方法的对象：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using conditions in synchronized code* recipe in this chapter
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*在同步代码中使用条件*配方
- en: Using conditions in synchronized code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同步代码中使用条件
- en: A classic problem in concurrent programming is the producer-consumer problem.
    We have a data buffer, one or more producers of data that save it in the buffer,
    and one or more consumers of data that take it from the buffer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中的一个经典问题是生产者-消费者问题。我们有一个数据缓冲区，一个或多个生产者将数据保存到缓冲区中，一个或多个消费者从缓冲区中获取数据。
- en: As the buffer is a shared data structure, we have to control access to it using
    a synchronization mechanism, such as the `synchronized` keyword, but here we have
    more limitations. A producer can't save data in the buffer if it's full, and a
    consumer can't take data from the buffer if it's empty.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为缓冲区是一个共享的数据结构，我们必须使用同步机制，例如`同步`关键字来控制对其的访问，但在这里我们有更多的限制。如果缓冲区已满，生产者无法在其中保存数据，如果缓冲区为空，消费者无法从中获取数据。
- en: For these types of situations, Java provides the `wait()`, `notify()`, and `notifyAll()`
    methods implemented in the `Object` class. A thread can call the `wait()` method
    inside a `synchronized` block of code. If it calls the `wait()` method outside
    a `synchronized` block of code, JVM throws an `IllegalMonitorStateException` exception.
    When the thread calls the `wait()` method, JVM puts the thread to sleep and releases
    the object that controls the `synchronized` block of code that it's executing
    and allows other threads to execute other blocks of `synchronized` code protected
    by this object. To wake up the thread, you must call the `notify()` or `notifyAll()`
    methods inside a block of code protected by the same object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的情况，Java 提供了在 `Object` 类中实现的 `wait()`、`notify()` 和 `notifyAll()` 方法。一个线程可以在代码的
    `synchronized` 块中调用 `wait()` 方法。如果它在 `synchronized` 块之外调用 `wait()` 方法，JVM 将抛出
    `IllegalMonitorStateException` 异常。当线程调用 `wait()` 方法时，JVM 将线程置于睡眠状态，并释放控制其正在执行的
    `synchronized` 块的对象，允许其他线程执行由该对象保护的另一个 `synchronized` 代码块。要唤醒线程，必须在由同一对象保护的代码块中调用
    `notify()` 或 `notifyAll()` 方法。
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using the `synchronized` keyword and the `wait()`, `notify()`, and `notifyAll()`
    methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何使用 `synchronized` 关键字和 `wait()`、`notify()`、`notifyAll()` 方法实现生产者-消费者问题。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `EventStorage`. It has two attributes, namely an `int`
    attribute called `maxSize` and a `List<Date>` attribute called `storage`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `EventStorage` 的类。它有两个属性，即一个名为 `maxSize` 的 `int` 属性和一个名为 `storage` 的
    `List<Date>` 属性：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the constructor of the class that initializes the attributes of the
    class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化类的属性：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the `synchronized` method `set()` to store an event in `storage`.
    First, check whether storage is full or not. If it''s full, it calls the `wait()`
    method until it has empty space. At the end of the method, we call the `notify()`
    method to wake up all the threads that are sleeping in the `wait()` method. In
    this case, we will ignore `InterruptedException`. In a real implementation, you
    must think what treatment you must give to them. You can rethrow or transform
    them into a different type of exception of the application:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `synchronized` 方法 `set()` 以将事件存储在 `storage` 中。首先检查存储是否已满。如果已满，它将调用 `wait()`
    方法直到有空闲空间。在方法结束时，我们调用 `notify()` 方法唤醒所有在 `wait()` 方法中睡眠的线程。在这种情况下，我们将忽略 `InterruptedException`。在实际实现中，你必须考虑对这些异常的处理。你可以重新抛出或将它们转换为应用程序的另一种类型的异常：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `synchronized` method `get()` to get an event for storage purposes.
    First, check whether storage has events or not. If it has no events, it calls
    the `wait()` method until it is given some events. At the end of the method, we
    call the `notifyAll()` method to wake up all the threads that are sleeping in
    the `wait()` method. In this case, we will ignore `InterruptedException`. In a
    real implementation, you must think what treatment you must give to them. You
    can rethrow or transform them into a different type of exception of the application:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `synchronized` 方法 `get()` 以获取用于存储的事件。首先检查存储是否有事件。如果没有事件，它将调用 `wait()` 方法直到有事件。在方法结束时，我们调用
    `notifyAll()` 方法唤醒所有在 `wait()` 方法中睡眠的线程。在这种情况下，我们将忽略 `InterruptedException`。在实际实现中，你必须考虑对这些异常的处理。你可以重新抛出或将它们转换为应用程序的另一种类型的异常：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a class named `Producer` and specify that it implements the `Runnable`
    interface. It will implement the producer of the example:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Producer` 的类并指定它实现 `Runnable` 接口。它将实现示例中的生产者：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Declare an `EventStore` object and implement the constructor of the class that
    initializes this object:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `EventStore` 对象并实现类的构造函数以初始化此对象：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the `run()` method that calls the `set()` method of the `EventStorage`
    object 100 times:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `run()` 方法，该方法调用 `EventStorage` 对象的 `set()` 方法 100 次：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a class named `Consumer` and specify that it implements the `Runnable`
    interface. It will implement the consumer of the example:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Consumer` 的类并指定它实现 `Runnable` 接口。它将实现示例中的消费者：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare an `EventStorage` object and implement the constructor of the class
    that initializes this object:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`EventStorage`对象并实现该类的构造函数以初始化此对象：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `run()` method. It calls the `get()` method of the `EventStorage`
    object 100 times:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`run()`方法。它调用`EventStorage`对象的`get()`方法100次：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the main class of the example by implementing a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现一个名为`Main`的类并添加`main()`方法来创建示例的主类：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create an `EventStorage` object:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`EventStorage`对象：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `Producer` object and `Thread` to run it:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Producer`对象和一个`Thread`来运行它：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `Consumer` object and `Thread` to run it:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Consumer`对象和一个`Thread`来运行它：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start both the threads:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动两个线程：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to this example is the `set()` and `get()` methods of the `EventStorage`
    class. First of all, the `set()` method checks whether there is free space in
    the storage attribute. If it's full, it calls the `wait()` method to wait for
    free space. When the other thread calls the `notify()` method, this thread wakes
    up and checks the condition again. The `notify()` method doesn't guarantee that
    the condition is met. This process is repeated until there is free space in storage
    and it can generate a new event and store it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的关键是`EventStorage`类的`set()`和`get()`方法。首先，`set()`方法检查存储属性中是否有空闲空间。如果已满，它调用`wait()`方法等待空闲空间。当其他线程调用`notify()`方法时，此线程会醒来并再次检查条件。`notify()`方法并不保证条件得到满足。这个过程会一直重复，直到存储空间中有空闲空间，可以生成新事件并将其存储。
- en: The behavior of the `get()` method is similar. First, it checks whether there
    are events on the storage attribute. If the `EventStorage` class is empty, it
    calls the `wait()` method to wait for events. When the other thread calls the
    `notify()` method, this thread wakes up and checks the condition again until there
    are some events in storage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法的行为类似。首先，它检查存储属性中是否有事件。如果`EventStorage`类为空，它调用`wait()`方法等待事件。当其他线程调用`notify()`方法时，此线程会醒来并再次检查条件，直到存储中有一些事件。'
- en: You have to keep checking the conditions and calling the `wait()` method in
    a `while` loop. You will not be able to continue until the condition is `true`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在一个`while`循环中不断检查条件并调用`wait()`方法。你将无法继续，直到条件为`true`。
- en: If you run this example, you will find that although the producer and consumer
    are setting and getting events, storage never has the capacity to include more
    than 10 events.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此示例，你会发现尽管生产者和消费者正在设置和获取事件，但存储空间永远不会包含超过10个事件。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are other important uses of the `synchronized` keyword. See the *See also*
    section of this recipes that explain the use of this keyword.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`关键字还有其他重要的用途。请参阅此配方中的*参见*部分，其中解释了该关键字的使用。'
- en: See also
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Synchronizing a method* recipe in this chapter
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*同步方法*配方
- en: Synchronizing a block of code with a lock
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁同步代码块
- en: 'Java provides another mechanism for synchronizing blocks of code. It''s a more
    powerful and flexible mechanism than the `synchronized` keyword. It''s based on
    the `Lock` (of the `java.util.concurrent.locks` package) interface and classes
    that implement it (as `ReentrantLock`). This mechanism presents some advantages,
    which are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了另一种同步代码块的方法。它比`synchronized`关键字更强大、更灵活。它基于`Lock`（`java.util.concurrent.locks`包中的接口）及其实现类（如`ReentrantLock`）。这种机制具有一些优点，如下所述：
- en: It allows you to structure synchronized blocks in a more flexible way. With
    the `synchronized` keyword, you only have control over a synchronized block of
    code in a structured way. However, the `Lock` interface allows you to get more
    complex structures to implement your critical section.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你以更灵活的方式组织同步块。使用`synchronized`关键字，你只能以结构化的方式控制代码中的同步块。然而，`Lock`接口允许你实现更复杂的结构以实现你的临界区。
- en: The `Lock` interface provides additional functionalities over the `synchronized`
    keyword. One of the new functionalities is implemented by the `tryLock()` method.
    This method tries to get control of the lock, and if it can't, because it's used
    by another thread, it returns `false`. With the `synchronized` keyword, if thread
    (A) tries to execute a synchronized block of code when thread (B) is executing
    it, thread (A) is suspended until thread (B) finishes the execution of the synchronized
    block. With lock, you can execute the `tryLock()` method. This method returns
    a `Boolean` value indicating whether there is another thread running the code
    protected by this lock.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ReadWriteLock` interface allows a separation of read and write operations
    with multiple readers and only one modifier.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interface offers better performance than the `synchronized` keyword.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor of the `ReentrantLock` class admits a `boolean` parameter named
    `fair`; this parameter allows you to control its behavior. The `false` value is
    the default value and it's called the **non-fair mode**. In this mode, if some
    threads are waiting for a lock and the lock has to select one of these threads
    to get access to the critical section, it randomly selects anyone of them. The
    `true` value is called the **fair mode**. In this mode, if some threads are waiting
    for a lock and the lock has to select one to get access to a critical section,
    it selects the thread that has been waiting for the longest period of time. Take
    into account that the behavior explained previously is only used in the `lock()`
    and `unlock()` methods. As the `tryLock()` method doesn't put the thread to sleep
    if the `Lock` interface is used, the fair attribute doesn't affect its functionality.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use locks to synchronize a block of code
    and create a critical section using the `Lock` interface and the `ReentrantLock`
    class that implements it, implementing a program that simulates a print queue.
    You will also learn how the fair parameter affects the behavior of `Lock`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `PrintQueue` that will implement the print queue:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare a `Lock` object and initialize it with a new object of the `ReentrantLock`
    class in the constructor. The constructor will receive a `Boolean` parameter we
    will use to specify the fair mode of the `Lock`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the `printJob()` method. It will receive `Object` as a parameter
    and it will not return any value:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the `printJob()` method, get control of the `Lock` object by calling
    the `lock()` method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, include the following code to simulate the process of printing a document:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, free the control of the `Lock` object with the `unlock()` method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, repeat the same process again. The `printJob()` method will help you
    get access to the lock and then free it twice. This strange behavior will allow
    us to see the difference between fair and non-fair mode in a better way. We include
    this piece of code in the `printJob()` method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a class named `Job` and specify that it implements the `Runnable` interface:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Declare an object of the `PrintQueue` class and implement the constructor of
    the class that initializes this object:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Implement the `run()` method. It uses the `PrintQueue` object to send a job
    to print:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the main class of the application by implementing a class named `Main`
    and adding the `main()` method to it:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We are going to test the `PrintQueue` class using a lock with the fair mode
    returning both `true` and `false`. We will use an auxiliary method to implement
    both the tests so the code of the `main()` method is simple:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the `testPrintQueue()` method and create a shared `PrintQueue` object
    inside it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create 10 `Job` objects and 10 threads to run them:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Start the 10 threads:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, wait for the finalization of the 10 threads:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a part of the output of one execution
    of this example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: The key to the example is in the `printJob()` method of the `PrintQueue` class.
    When we want to implement a critical section using locks and guarantee that only
    one execution thread will run a block of code, we have to create a `ReentrantLock`
    object. At the beginning of the critical section, we have to get control of the
    lock using the `lock()` method. When thread (A) calls this method, if no other
    thread has control of the lock, it gives thread (A) control of the lock and returns
    immediately to allow the thread to execute the critical section. Otherwise, if
    there is another, say thread (B), executing the critical section controlled by
    this lock, the `lock()` method puts thread (A) to sleep until thread (B) finishes
    the execution of the critical section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the critical section, we have to use the `unlock()` method to
    free the control of the lock and allow other threads to run the critical section.
    If you don't call the `unlock()` method at the end of the critical section, other
    threads that are waiting for the block will wait forever, causing a deadlock situation.
    If you use try-catch blocks in your critical section, don't forget to put the
    sentence containing the `unlock()` method inside the `finally` section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The other topic we tested in this example was fair mode. We had two critical
    sections in every job. In the previous screenshot, you saw how all the jobs execute
    the second part immediately after the first one. This is the usual case, but there
    are exceptions. This occurs when we have non-fair mode, that is to say, we pass
    a false value to the constructor of the `ReentrantLock` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'On the contrary, when we establish fair mode by passing the true value to the
    constructor of the `Lock` class, the behavior is different. The first thread that
    requests control of the lock is `Thread 0`, then `Thread 1`, and so on. While
    `Thread 0` is running the first block of code protected by the lock, we have nine
    threads waiting to execute the same block of code. When `Thread 0` releases the
    lock, it immediately requests the lock again, so we have 10 threads trying to
    get the lock. As the fair mode is enabled, the `Lock` interface will choose `Thread
    1`, as it''s the thread that has been waiting for more time for the lock. Then,
    it chooses `Thread 2`, then `Thread 3`, and so on. Until all the threads have
    passed the first block protected by the lock, none of them will execute the second
    block protected by the lock. Once all the threads have executed the first block
    of code protected by the lock, then it will be the turn of `Thread 0` again, then
    `Thread 1`, and so on. The following screenshot shows the difference:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Lock` interface (and the `ReentrantLock` class) includes another method
    to get control of the lock. It''s the `tryLock()` method. The biggest difference
    with the `lock()` method is that this method, if the thread that uses it can''t
    get control of the Lock interface, returns immediately and doesn''t put the thread
    to sleep. It returns the `boolean` value `true` if the thread gets control of
    the lock and `false` if not. You can also pass a time value and a `TimeUnit` object
    to indicate the maximum amount of time the thread will wait to get the lock. If
    the time elapses and the thread doesn''t get the lock, the method will return
    the false value. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`; these indicate the units of time we pass to a method.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Take into consideration that it is the responsibility of the programmer to take
    into account the result of this method and act accordingly. If the method returns
    `false`, it's apparent that your program is unable to execute the critical section.
    If it does, you probably will have wrong results in your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The `ReentrantLock` class also allows the use of recursive calls. When a thread
    has control of a lock and makes a recursive call, it continues with the control
    of the lock, so the calling to the `lock()` method will return immediately and
    the thread will continue with the execution of the recursive call. Moreover, we
    can also call other methods. You should call the `unlock()` method as many times
    as you called the `lock()` method in your code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have to be very careful with the use of locks to avoid **deadlocks**. This
    situation occurs when two or more threads are blocked while waiting for locks
    that will never be unlocked. For example, thread (A) locks Lock (X) and thread
    (B) locks Lock (Y). Now, if thread (A) tries to lock Lock (Y) and thread (B) simultaneously
    tries to lock Lock (X), both the threads will be blocked indefinitely because
    they are waiting for locks that will never be liberated. Note that the problem
    occurs because both threads try to get the locks in the opposite order. The Appendix,
    *Concurrent Programming Design*, provides some good tips to design concurrent
    applications adequately and avoid these deadlock problems.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a method* and *Using multiple conditions in a lock* recipes
    in this chapter
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing data access with read/write locks
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most significant improvements offered by locks is the `ReadWriteLock`
    interface and the `ReentrantReadWriteLock` class, the unique class that implements
    that interface. This class has two locks: one for read operations and one for
    write operations. There can be more than one thread using read operations simultaneously,
    but only one thread can use write operations. If a thread is doing a write operation,
    other threads can''t write or read.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a `ReadWriteLock` interface by implementing
    a program that uses it to control access to an object that stores the prices of
    two products.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should read the *Synchronizing a block of code with a lock* recipe to better
    understand this recipe.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `PricesInfo` that stores information about the prices
    of two products:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Declare two `double` attributes named `price1` and `price2`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare a `ReadWriteLock` object called `lock`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the constructor of the class that initializes the three attributes.
    For the `lock` attribute, create a new `ReentrantReadWriteLock` object:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the `getPrice1()` method that returns the value of the `price1` attribute.
    It uses the read lock to control access to the value of this attribute:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `getPrice2()` method that returns the value of the `price2` attribute.
    It uses the read lock to control access to the value of this attribute:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Implement the `setPrices()` method that establishes the values of two attributes.
    It uses the write lock to control access to them. We are going to make the thread
    sleep for 5 seconds. This shows that even though it has the write lock, there
    are no other threads getting the read lock:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a class named `Reader` and specify that it implements the `Runnable`
    interface. This class implements a reader of the values of the `PricesInfo` class
    attribute:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare a `PricesInfo` object and implement the constructor of the class that
    could initialize this object:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement the `run()` method for this class. It reads the value of the two
    prices 10 times:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a class named `Writer` and specify that it implements the `Runnable`
    interface. This class implements a modifier of the values of the `PricesInfo`
    class attribute:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare a `PricesInfo` object and implement the constructor of the class that
    could initialize this object:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Implement the `run()` method. It modifies the value of the two prices that
    are sleeping for 2 seconds between modifications three times:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a `PricesInfo` object:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create five `Reader` objects and five `Thread` objects to execute them:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a `Writer` object and `Thread` to execute it:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Start the threads:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a part of the output of one execution
    of this example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: While the writer has acquired the write lock, none of the reader tasks can read
    the data. You can see some messages of the reader tasks after the `Write Lock
    Acquired` message, but they are instructions that were executed before and not
    shown yet in the console. Once the writer task has released the lock, reader tasks
    gain access to the prices information again and show the new prices.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `ReentrantReadWriteLock` class has two locks:
    one for read operations and one for write operations. The lock used in read operations
    is obtained with the `readLock()` method declared in the `ReadWriteLock` interface.
    This lock is an object that implements the `Lock` interface, so we can use the
    `lock()`, `unlock()`, and `tryLock()` methods. The lock used in write operations
    is obtained with the `writeLock()` method declared in the `ReadWriteLock` interface.
    This lock is also an object that implements the `Lock` interface, so we can use
    the `lock()`, `unlock()`, and `tryLock()` methods. It is the responsibility of
    the programmer to ensure correct use of these locks, using them for the same purposes
    for which they were designed. When you get the read lock of a `Lock` interface,
    you can''t modify the value of the variable. Otherwise, you probably will have
    data errors related to inconsistency.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* recipe in this chapter
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple conditions in a lock
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lock may be associated with one or more conditions. These conditions are declared
    in the `Condition` interface. The purpose of these conditions is to allow threads
    to have control of a lock and check whether a condition is `true` or not. If it's
    `false`, the thread will be suspended until another thread wakes it up. The `Condition`
    interface provides the mechanisms to suspend a thread and wake up a suspended
    thread.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: A classic problem in concurrent programming is the producer-consumer problem.
    We have a data buffer, one or more producers of data that save it in the buffer,
    and one or more consumers of data that take it from the buffer, as explained earlier
    in this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using locks and conditions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should read the *Synchronizing a block of code with a lock* recipe to better
    understand this recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'First, implement a class that will simulate a text file. Create a class named
    `FileMock` with two attributes: a `String` array named content and `int` named
    `index`. They will store the content of the file and the line of the simulated
    file that will be retrieved:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Implement the constructor of the class that initializes the content of the
    file with random characters:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the `hasMoreLines()` method that returns `true` if the file has more
    lines to process or `false` if you have reached the end of the simulated file:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the `getLine()` method that returns the line determined by the index
    attribute and increases its value:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now implement a class named `Buffer` that will implement the buffer shared
    by both the producers and consumers:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This class has six attributes:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A `LinkedList<String>` attribute named `buffer` that will store the shared
    data. For example:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'An `int` type named `maxSize` that will store the length of the buffer. For
    example:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A `ReentrantLock` object called `lock` that will control access to the blocks
    of code that modify the buffer. For example:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Two `Condition` attributes named `lines` and `space`. For example:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A `boolean` type called `pendingLines` that will indicate whether there are
    lines in the buffer. For example:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Implement the constructor of the class. It initializes all the attributes described
    previously:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Implement the `insert()` method. It receives `String` as a parameter and tries
    to store it in the buffer. First, it gets control of the lock. When it has this,
    it checks whether there is empty space in the buffer. If the buffer is full, it
    calls the `await()` method in the `space` condition to wait for free space. The
    thread will be woken up when another thread calls the `signal()` or `signalAll()`
    method in the `space` condition. When this happens, the thread stores the line
    in the buffer and calls the `signallAll()` method over the `lines` condition.
    As we''ll see in a moment, this condition will wake up all the threads that are
    waiting for lines in the buffer. To make the code easier, we ignore the `InterruptedException`
    exception. In real cases, you will probably have to process it:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Implement the `get()` method. It returns the first string stored in the buffer.
    First, it gets control of the lock. When this is done, it checks whether there
    are lines in the buffer. If the buffer is empty, it calls the `await()` method
    in the `lines` condition to wait for lines in the buffer. This thread will be
    woken up when another thread calls the `signal()` or `signalAll()` method in the
    lines condition. When this happens, the method gets the first line in the buffer,
    calls the `signalAll()` method over the `space` condition, and returns `String`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Implement the `setPendingLines()` method that establishes the value of the
    `pendingLines` attribute. It will be called by the producer when it has no more
    lines to produce:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Implement the `hasPendingLines()` method. It returns `true` if there are more
    lines to be processed or `false` otherwise:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now it''s the turn of the producer. Implement a class named `Producer` and
    specify that it implements the `Runnable` interface:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Declare two attributes, namely an object of the `FileMock` class and an object
    of the `Buffer` class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Implement the constructor of the class that initializes both the attributes:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Implement the `run()` method that reads all the lines created in the `FileMock`
    object and use the `insert()` method to store them in the buffer. Once this is
    done, use the `setPendingLines()` method to alert the buffer that it will not
    generate more lines:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next is the consumer''s turn. Implement a class named `Consumer` and specify
    that it implements the `Runnable` interface:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Declare a `Buffer` object and implement the constructor of the class that initializes
    it:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Implement the `run()` method. While the buffer has pending lines, it tries
    to get one line and process it:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Implement the auxiliary method `processLine()`. It only sleeps for 10 milliseconds
    to simulate some kind of processing with the line:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a `FileMock` object:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a `Buffer` object:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create a `Producer` object and `Thread` to run it:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create three `Consumer` objects and three threads to run them:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Start the producer and the three consumers:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How it works...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the `Condition` objects are associated with a lock and are created using
    the `newCondition()` method declared in the `Lock` interface. Before we can do
    any operation with a condition, you have to have control of the lock associated
    with the condition. So operations with conditions must be done in a thread that
    holds the lock with a call to a `lock()` method of a `Lock` object and then frees
    it with an `unlock()` method of the same `Lock` object.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls the `await()` method of a condition, it automatically frees
    the control of the lock so that another thread can get it and either begin the
    execution or another critical section protected by that lock.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls the `signal()` or `signallAll()` methods of a condition,
    one or all of the threads that were waiting for that condition are woken up, but
    this doesn't guarantee that the condition that made them sleep is now `true`.
    So you must put the `await()` calls inside a while loop. You can't leave this
    loop until the condition is `true`. When the condition is `false`, you must call
    `await()` again.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: You must be careful with the use of `await()` and `signal()`. If you call the
    `await()` method in a condition and never call the `signal()` method in the same
    condition, the thread will sleep forever.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: A thread can be interrupted while it is sleeping, after a call to the `await()`
    method, so you have to process the `InterruptedException` exception.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Condition` interface has other versions of the `await()` method, which
    are as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '`await(long time, TimeUnit unit)`: Here, the thread will sleep until:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interrupted
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thread calls the `signal()` or `signalAll()` methods in the condition
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified time passes
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitUninterruptibly()`: The thread will sleep until another thread calls
    the `signal()` or `signalAll()` methods, which can''t be interrupted'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitUntil(Date date)`: The thread will sleep until:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interrupted
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thread calls the `signal()` or `signalAll()` methods in the condition
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified date arrives
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use conditions with the `ReadLock` and `WriteLock` locks of a read/write
    lock.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* and *Synchronizing data access
    with read/write locks* recipes in this chapter
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced locking with the StampedLock class
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StampedLock` class provides a special kind of lock that is different from
    the ones provided by the Lock or `ReadWriteLock` interfaces. In fact, this class
    doesn't implement these interfaces, but the functionality it provides is very
    similar.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The first point to note about this kind of lock is that its main purpose is
    to be a helper class to implement thread-safe components, so its use will not
    be very common in normal applications.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important features of `StampedLock` locks are as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain control of the lock in three different modes:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: In this mode, you get exclusive access to the lock. No other thread
    can have control of the lock in this mode.'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read**: In this mode, you have non-exclusive access to the lock. There can
    be other threads that have access to the lock in this mode or the Optimistic Read
    mode.'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimistic Read**: Here, the thread doesn''t have control over the block.
    Other threads can get control of the lock in write mode. When you get a lock in
    the Optimistic Read mode and you want to access the shared data protected by it,
    you will have to check whether you can access them or not using the `validate()`
    method.'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `StampedLock` class provides methods to:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquire control over the lock in one of the previous modes. If the methods (`readLock()`,
    `writeLock()`, `readLockInterruptibly()`) are unable to get control of the lock,
    the current thread is suspended until it gets the lock.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquire control over the lock in one of the previous modes. If the methods (`tryOptimisticRead()`,
    `tryReadLock()`, `tryWriteLock()`) are unable to get control of the lock, they
    return a special value to indicate this circumstance.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert one mode into another, if possible. If not, the methods (`asReadLock()`,
    `asWriteLock()`, `asReadWriteLock()`) return a special value.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Release the lock.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods return a long value called stamp that we need to use to work
    with the lock. If a method returns zero, it means it tried to get a lock but it
    couldn't.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `StampedLock` lock is not a reentrant lock, such as the `Lock` and `ReadWriteLock`
    interfaces. If you call a method that tries to get the lock again, it may be blocked
    and you'll get a deadlock.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have the notion of ownership. They can be acquired by one thread
    and released by another.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it doesn't have any policy about the next thread that will get control
    of the lock.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the different modes of the `StampedLock`
    class to protect access to a shared data object. We will use a shared object between
    three concurrent tasks to test the three access modes with `StampedLock` (write,
    read, and Optimistic Read).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: First, implement the shared data object. Create a class named `Position` with
    two integer attributes, namely `x` and `y`. You have to include the methods to
    get and set the values of the attributes. Its code is very simple so it is not
    included here.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s implement the `Writer` task. It implements the `Runnable` interface
    and it will have two attributes: a `Position` object named `position` and `StampedLock`
    named `lock`. They will be initialized in the constructor:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Implement the `run()` method. In a loop that we will repeat 10 times, get the
    lock in write mode, change the value of the two attributes of the position object,
    suspend the execution of the thread for a second, release the lock (in the `finally`
    section of a `try...catch...finally` structure to release the lock in any circumstance),
    and suspend the thread for a second:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, implement the `Reader` task to read the values of the shared object.
    Create a class named `Reader` that implements the `Runnable` interface. It will
    have two attributes: a `Position` object named `position` and a `StampedLock`
    object named `lock`. They will be initialized in the constructor of the class:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now implement the `run()` method. In a loop that we will repeat `50` times,
    get control of the lock in read mode, write the values of the position object
    in the console, and suspend the thread for `200` milliseconds. Finally, release
    the lock using the `finally` block of a `try...catch...finally` structure:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, implement the `OptimisticReader` task. The class `OptimisticReader` class
    implements the `Runnable` interface. It will have two attributes: a `Position`
    object named `position` and a `StampledLock` object named `lock`. They will be
    initialized in the constructor of the class:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now implement the `run()` method. First obtain the stamp of the lock in the
    optimistic read mode using the `tryOptimisticRead()` method. Then, repeat the
    loop `100` times. In the loop, validate whether you can access data using the
    `validate()` method. If this method returns true, write the values of the position
    object in the console. Otherwise, write a message in the console and get another
    stamp using the `tryOptimisticRead()` method again. Then, suspend the thread for
    `200` milliseconds:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Finally, implement the `Main` class with the `main()` method. Create a `Position`
    and `StampedLock` object, create three threads--one for each task--start the threads,
    and wait for their finalization:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we tested the three modes you can use with a stamped lock.
    In the `Writer` task, we get the lock with the `writeLock()` method (that acquires
    the lock in write mode). In the `Reader` task, we get the lock with the `readLock()`
    method (that acquires the lock in read mode). Finally, in the `OptimisticRead`
    task, first we use `tryOptimisticRead()` and then we use the `validate()` method
    to check whether we can access data or not.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The first two methods, if they can get control of the lock, wait until they
    get the lock. The `tryOptimisticRead()` method always returns a value. It will
    be `0` if we are unable to use the lock and a value different from `0` if we can
    use it. Remember that in this case, we always need to use the `validate()` method
    to check whether we can really access the data.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: While the `Writer` task has control of the lock, neither `Reader` nor `OptimisticReader`
    can access the values. The `Reader` task is suspended in the `readLock()` method,
    while in `OptimisticReader`, the call to the `validate()` method returns `false`
    and the call to the `tryOptimisticRead()` method returns `0` to indicate that
    the lock is controlled in write mode by another thread. When the `Writertask`
    releases the lock, both `Reader` and `OptimisticReader` tasks will be able to
    access the values of the shared object.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StampedLock` class has other methods that you should know:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`tryReadLock()` and `tryReadLock(long time, TimeUnit unit)`: These methods
    try to acquire the lock in read mode. If they can''t, the first version is returned
    immediately and the second one waits for the amount of time specified in the parameter.
    These methods also return a stamp that must be checked (`stamp != 0`).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryWriteLock()` and `tryWriteLock(long time, TimeUnit unit)`: These methods
    try to acquire the lock in write mode. If they can''t, the first version is returned
    immediately and the second one waits for the amount of time specified in the parameter.
    These methods also return a stamp that must be checked (`stamp != 0`).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isReadLocked()` and `isWriteLocked()`: These methods are returned if the lock
    is currently held in read or write mode, respectively.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryConvertToReadLock(long stamp)`, `tryConvertToWriteLock(long stamp)`, and
    `tryConvertToOptimisticRead(long stamp)`: These methods try to convert the stamp
    passed as a parameter to the mode indicated in the name of the method. If they
    can, they return a new stamp. If not, they return `0`.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock(long stamp)`: This releases the corresponding mode of the lock.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* recipe in this chapter
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
