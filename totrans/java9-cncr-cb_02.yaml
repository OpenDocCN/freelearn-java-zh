- en: Basic Thread Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditions in synchronized code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing a block of code with a lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing data access with read/write locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple conditions in a lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced locking with the StampedLock class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common situations in concurrent programming occurs when more
    than one execution thread shares a resource. In a concurrent application, it is
    normal for multiple threads to read or write the same data structure or have access
    to the same file or database connection. These shared resources can provoke error
    situations or data inconsistency, and we have to implement mechanisms to avoid
    these errors. These situations are called **race conditions** and they occur when
    different threads have access to the same shared resource at the same time. Therefore,
    the final result depends on the order of the execution of threads, and most of
    the time, it is incorrect. You can also have problems with change visibility.
    So if a thread changes the value of a shared variable, the changes would only
    be written in the local cache of that thread; other threads will not have access
    to the change (they will only be able to see the old value).
  prefs: []
  type: TYPE_NORMAL
- en: The solution for these problems lies in the concept of **critical section**.
    A critical section is a block of code that accesses a shared resource and can't
    be executed by more than one thread at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help programmers implement critical sections, Java (and almost all programming
    languages) offers synchronization mechanisms. When a thread wants access to a
    critical section, it uses one of these synchronization mechanisms to find out
    whether there is any other thread executing the critical section. If not, the
    thread enters the critical section. If yes, the thread is suspended by the synchronization
    mechanism until the thread that is currently executing the critical section ends
    it. When more than one thread is waiting for a thread to finish the execution
    of a critical section, JVM chooses one of them and the rest wait for their turn.
    This chapter presents a number of recipes that will teach you how to use the two
    basic synchronization mechanisms offered by the Java language:'
  prefs: []
  type: TYPE_NORMAL
- en: The `synchronized` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interface and its implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use one of the most basic methods of synchronization
    in Java, that is, the use of the `synchronized` keyword to control concurrent
    access to a method or a block of code. All the `synchronized` sentences (used
    on methods or blocks of code) use an object reference. Only one thread can execute
    a method or block of code protected by the same object reference.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `synchronized` keyword with a method, the object reference
    is implicit. When you use the `synchronized` keyword in one or more methods of
    an object, only one execution thread will have access to all these methods. If
    another thread tries to access any method declared with the `synchronized` keyword
    of the same object, it will be suspended until the first thread finishes the execution
    of the method. In other words, every method declared with the `synchronized` keyword
    is a critical section, and Java only allows the execution of one of the critical
    sections of an object at a time. In this case, the object reference used is the
    `own` object, represented by the `this` keyword. Static methods have a different
    behavior. Only one execution thread will have access to one of the static methods
    declared with the `synchronized` keyword, but a different thread can access other
    non-static methods of an object of that class. You have to be very careful with
    this point because two threads can access two different `synchronized` methods
    if one is static and the other is not. If both methods change the same data, you
    can have data inconsistency errors. In this case, the object reference used is
    the class object.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `synchronized` keyword to protect a block of code, you must
    pass an object reference as a parameter. Normally, you will use the `this` keyword
    to reference the object that executes the method, but you can use other object
    references as well. Normally, these objects will be created exclusively for this
    purpose. You should keep the objects used for synchronization private. For example,
    if you have two independent attributes in a class shared by multiple threads,
    you must synchronize access to each variable; however, it wouldn't be a problem
    if one thread is accessing one of the attributes and the other accessing a different
    attribute at the same time. Take into account that if you use the `own` object
    (represented by the `this` keyword), you might interfere with other synchronized
    code (as mentioned before, the `this` object is used to synchronize the methods
    marked with the `synchronized` keyword).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use the `synchronized` keyword to implement
    an application simulating a parking area, with sensors that detect the following:
    when a car or a motorcycle enters or goes out of the parking area, an object to
    store the statistics of the vehicles being parked, and a mechanism to control
    cash flow. We will implement two versions: one without any synchronization mechanisms,
    where we will see how we obtain incorrect results, and one that works correctly
    as it uses the two variants of the `synchronized` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the application without using any synchronization mechanism.
    Create a class named `ParkingCash` with an internal constant and an attribute
    to store the total amount of money earned by providing this parking service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method named `vehiclePay()` that will be called when a vehicle
    (a car or motorcycle) leaves the parking area. It will increase the cash attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement a method named `close()` that will write the value of the
    cash attribute in the console and reinitialize it to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `ParkingStats` with three private attributes and the constructor
    that will initialize them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the methods that will be executed when a car or motorcycle
    enters or leaves the parking area. When a vehicle leaves the parking area, cash
    should be incremented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement two methods to obtain the number of cars and motorcycles
    in the parking area, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `Sensor` that will simulate the movement of vehicles in
    the parking area. It implements the `Runnable` interface and has a `ParkingStats`
    attribute, which will be initialized in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. In this method, simulate that two cars and a
    motorcycle arrive in and then leave the parking area. Every sensor will perform
    this action 10 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the main method. Create a class named `Main` with the `main()`
    method. It needs `ParkingCash` and `ParkingStats` objects to manage parking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `Sensor` tasks. Use the `availableProcessors()` method (that
    returns the number of available processors to the JVM, which normally is equal
    to the number of cores in the processor) to calculate the number of sensors our
    parking area will have. Create the corresponding `Thread` objects and store them
    in an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then wait for the finalization of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the statistics of `Parking`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we executed the example in a four-core processor, so we will have
    eight `Sensor` tasks. Each task performs 10 iterations, and in each iteration,
    three vehicles enter the parking area and the same three vehicles go out. Therefore,
    each `Sensor` task will simulate 30 vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, the final stats will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no cars in the parking area, which means that all the vehicles that
    came into the parking area have moved out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight `Sensor` tasks were executed, where each task simulated 30 vehicles and
    each vehicle was charged 2 dollars each; therefore, the total amount of cash earned
    was 480 dollars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you execute this example, each time you will obtain different results,
    and most of them will be incorrect. The following screenshot shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We had race conditions, and the different shared variables accessed by all
    the threads gave incorrect results. Let''s modify the previous code using the
    synchronized keyword to solve these problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the synchronized keyword to the `vehiclePay()` method of the `ParkingCash`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a `synchronized` block of code using the `this` keyword to the `close()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add two new attributes to the `ParkingStats` class and initialize them
    in the constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify the methods that increment and decrement the number of cars
    and motorcycles, including the `synchronized` keyword. The `numberCars` attribute
    will be protected by the `controlCars` object, and the `numberMotorcycles` attribute
    will be protected by the `controlMotorcycles` object. You must also synchronize
    the `getNumberCars()` and `getNumberMotorcycles()` methods with the associated
    reference object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Execute the example now and see the difference when compared to the previous
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the new version of the example.
    No matter how many times you execute it, you will always obtain the correct result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the different uses of the `synchronized` keyword in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we protected the `vehiclePay()` method. If two or more `Sensor` tasks
    call this method at the same time, only one will execute it and the rest will
    wait for their turn; therefore, the final amount will always be correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used two different objects to control access to the car and motorcycle counters.
    This way, one `Sensor` task can modify the `numberCars` attribute and another
    `Sensor` task can modify the `numberMotorcycles` attribute at the same time; however,
    no two `Sensor` tasks will be able to modify the same attribute at the same time,
    so the final value of the counters will always be correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we also synchronized the `getNumberCars()` and `getNumberMotorcycles()`
    methods. Using the `synchronized` keyword, we can guarantee correct access to
    shared data in concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the introduction of this recipe, only one thread can access
    the methods of an object that uses the `synchronized` keyword in their declaration.
    If thread (A) is executing a `synchronized` method and thread (B) wants to execute
    another `synchronized` method of the same object, it will be blocked until thread
    (A) is finished. But if thread (B) has access to different objects of the same
    class, none of them will be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `synchronized` keyword to protect a block of code, you use
    an object as a parameter. JVM guarantees that only one thread can have access
    to all the blocks of code protected with this object (note that we always talk
    about objects, not classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `TimeUnit` class as well. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`. These indicate the units of time we pass
    to the sleep method. In our case, we let the thread sleep for 50 milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `synchronized` keyword penalizes the performance of the application, so
    you must only use it on methods that modify shared data in a concurrent environment.
    If you have multiple threads calling a `synchronized` method, only one will execute
    them at a time while the others will remain waiting. If the operation doesn't
    use the `synchronized` keyword, all the threads can execute the operation at the
    same time, reducing the total execution time. If you know that a method will not
    be called by more than one thread, don't use the `synchronized` keyword. Anyway,
    if the class is designed for multithreading access, it should always be correct.
    You must promote correctness over performance. Also, you should include documentation
    in methods and classes in relation to their thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: You can use recursive calls with `synchronized` methods. As the thread has access
    to the `synchronized` methods of an object, you can call other `synchronized`
    methods of that object, including the method that is being executed. It won't
    have to get access to the `synchronized` methods again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `synchronized` keyword to protect access to a block of code
    instead of an entire method. We should use the `synchronized` keyword in this
    way to protect access to shared data, leaving the rest of the operations out of
    this block and obtaining better performance of the application. The objective
    is to have the critical section (the block of code that can be accessed only by
    one thread at a time) as short as possible. Also, avoid calling blocking operations
    (for example, I/O operations) inside a critical section. We have used the `synchronized`
    keyword to protect access to the instruction that updates the number of persons
    in the building, leaving out the long operations of the block that don''t use
    shared data. When you use the `synchronized` keyword in this way, you must pass
    an object reference as a parameter. Only one thread can access the `synchronized`
    code (blocks or methods) of this object. Normally, we will use the `this` keyword
    to reference the object that is executing the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using conditions in synchronized code* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditions in synchronized code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classic problem in concurrent programming is the producer-consumer problem.
    We have a data buffer, one or more producers of data that save it in the buffer,
    and one or more consumers of data that take it from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: As the buffer is a shared data structure, we have to control access to it using
    a synchronization mechanism, such as the `synchronized` keyword, but here we have
    more limitations. A producer can't save data in the buffer if it's full, and a
    consumer can't take data from the buffer if it's empty.
  prefs: []
  type: TYPE_NORMAL
- en: For these types of situations, Java provides the `wait()`, `notify()`, and `notifyAll()`
    methods implemented in the `Object` class. A thread can call the `wait()` method
    inside a `synchronized` block of code. If it calls the `wait()` method outside
    a `synchronized` block of code, JVM throws an `IllegalMonitorStateException` exception.
    When the thread calls the `wait()` method, JVM puts the thread to sleep and releases
    the object that controls the `synchronized` block of code that it's executing
    and allows other threads to execute other blocks of `synchronized` code protected
    by this object. To wake up the thread, you must call the `notify()` or `notifyAll()`
    methods inside a block of code protected by the same object.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using the `synchronized` keyword and the `wait()`, `notify()`, and `notifyAll()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `EventStorage`. It has two attributes, namely an `int`
    attribute called `maxSize` and a `List<Date>` attribute called `storage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the attributes of the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `synchronized` method `set()` to store an event in `storage`.
    First, check whether storage is full or not. If it''s full, it calls the `wait()`
    method until it has empty space. At the end of the method, we call the `notify()`
    method to wake up all the threads that are sleeping in the `wait()` method. In
    this case, we will ignore `InterruptedException`. In a real implementation, you
    must think what treatment you must give to them. You can rethrow or transform
    them into a different type of exception of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `synchronized` method `get()` to get an event for storage purposes.
    First, check whether storage has events or not. If it has no events, it calls
    the `wait()` method until it is given some events. At the end of the method, we
    call the `notifyAll()` method to wake up all the threads that are sleeping in
    the `wait()` method. In this case, we will ignore `InterruptedException`. In a
    real implementation, you must think what treatment you must give to them. You
    can rethrow or transform them into a different type of exception of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Producer` and specify that it implements the `Runnable`
    interface. It will implement the producer of the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an `EventStore` object and implement the constructor of the class that
    initializes this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method that calls the `set()` method of the `EventStorage`
    object 100 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Consumer` and specify that it implements the `Runnable`
    interface. It will implement the consumer of the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an `EventStorage` object and implement the constructor of the class
    that initializes this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It calls the `get()` method of the `EventStorage`
    object 100 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the main class of the example by implementing a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `EventStorage` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Producer` object and `Thread` to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Consumer` object and `Thread` to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Start both the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to this example is the `set()` and `get()` methods of the `EventStorage`
    class. First of all, the `set()` method checks whether there is free space in
    the storage attribute. If it's full, it calls the `wait()` method to wait for
    free space. When the other thread calls the `notify()` method, this thread wakes
    up and checks the condition again. The `notify()` method doesn't guarantee that
    the condition is met. This process is repeated until there is free space in storage
    and it can generate a new event and store it.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the `get()` method is similar. First, it checks whether there
    are events on the storage attribute. If the `EventStorage` class is empty, it
    calls the `wait()` method to wait for events. When the other thread calls the
    `notify()` method, this thread wakes up and checks the condition again until there
    are some events in storage.
  prefs: []
  type: TYPE_NORMAL
- en: You have to keep checking the conditions and calling the `wait()` method in
    a `while` loop. You will not be able to continue until the condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this example, you will find that although the producer and consumer
    are setting and getting events, storage never has the capacity to include more
    than 10 events.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other important uses of the `synchronized` keyword. See the *See also*
    section of this recipes that explain the use of this keyword.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a method* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing a block of code with a lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides another mechanism for synchronizing blocks of code. It''s a more
    powerful and flexible mechanism than the `synchronized` keyword. It''s based on
    the `Lock` (of the `java.util.concurrent.locks` package) interface and classes
    that implement it (as `ReentrantLock`). This mechanism presents some advantages,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to structure synchronized blocks in a more flexible way. With
    the `synchronized` keyword, you only have control over a synchronized block of
    code in a structured way. However, the `Lock` interface allows you to get more
    complex structures to implement your critical section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interface provides additional functionalities over the `synchronized`
    keyword. One of the new functionalities is implemented by the `tryLock()` method.
    This method tries to get control of the lock, and if it can't, because it's used
    by another thread, it returns `false`. With the `synchronized` keyword, if thread
    (A) tries to execute a synchronized block of code when thread (B) is executing
    it, thread (A) is suspended until thread (B) finishes the execution of the synchronized
    block. With lock, you can execute the `tryLock()` method. This method returns
    a `Boolean` value indicating whether there is another thread running the code
    protected by this lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ReadWriteLock` interface allows a separation of read and write operations
    with multiple readers and only one modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interface offers better performance than the `synchronized` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor of the `ReentrantLock` class admits a `boolean` parameter named
    `fair`; this parameter allows you to control its behavior. The `false` value is
    the default value and it's called the **non-fair mode**. In this mode, if some
    threads are waiting for a lock and the lock has to select one of these threads
    to get access to the critical section, it randomly selects anyone of them. The
    `true` value is called the **fair mode**. In this mode, if some threads are waiting
    for a lock and the lock has to select one to get access to a critical section,
    it selects the thread that has been waiting for the longest period of time. Take
    into account that the behavior explained previously is only used in the `lock()`
    and `unlock()` methods. As the `tryLock()` method doesn't put the thread to sleep
    if the `Lock` interface is used, the fair attribute doesn't affect its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use locks to synchronize a block of code
    and create a critical section using the `Lock` interface and the `ReentrantLock`
    class that implements it, implementing a program that simulates a print queue.
    You will also learn how the fair parameter affects the behavior of `Lock`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `PrintQueue` that will implement the print queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `Lock` object and initialize it with a new object of the `ReentrantLock`
    class in the constructor. The constructor will receive a `Boolean` parameter we
    will use to specify the fair mode of the `Lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `printJob()` method. It will receive `Object` as a parameter
    and it will not return any value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `printJob()` method, get control of the `Lock` object by calling
    the `lock()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, include the following code to simulate the process of printing a document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, free the control of the `Lock` object with the `unlock()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, repeat the same process again. The `printJob()` method will help you
    get access to the lock and then free it twice. This strange behavior will allow
    us to see the difference between fair and non-fair mode in a better way. We include
    this piece of code in the `printJob()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Job` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an object of the `PrintQueue` class and implement the constructor of
    the class that initializes this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It uses the `PrintQueue` object to send a job
    to print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the main class of the application by implementing a class named `Main`
    and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to test the `PrintQueue` class using a lock with the fair mode
    returning both `true` and `false`. We will use an auxiliary method to implement
    both the tests so the code of the `main()` method is simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `testPrintQueue()` method and create a shared `PrintQueue` object
    inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 10 `Job` objects and 10 threads to run them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the 10 threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, wait for the finalization of the 10 threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a part of the output of one execution
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The key to the example is in the `printJob()` method of the `PrintQueue` class.
    When we want to implement a critical section using locks and guarantee that only
    one execution thread will run a block of code, we have to create a `ReentrantLock`
    object. At the beginning of the critical section, we have to get control of the
    lock using the `lock()` method. When thread (A) calls this method, if no other
    thread has control of the lock, it gives thread (A) control of the lock and returns
    immediately to allow the thread to execute the critical section. Otherwise, if
    there is another, say thread (B), executing the critical section controlled by
    this lock, the `lock()` method puts thread (A) to sleep until thread (B) finishes
    the execution of the critical section.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the critical section, we have to use the `unlock()` method to
    free the control of the lock and allow other threads to run the critical section.
    If you don't call the `unlock()` method at the end of the critical section, other
    threads that are waiting for the block will wait forever, causing a deadlock situation.
    If you use try-catch blocks in your critical section, don't forget to put the
    sentence containing the `unlock()` method inside the `finally` section.
  prefs: []
  type: TYPE_NORMAL
- en: The other topic we tested in this example was fair mode. We had two critical
    sections in every job. In the previous screenshot, you saw how all the jobs execute
    the second part immediately after the first one. This is the usual case, but there
    are exceptions. This occurs when we have non-fair mode, that is to say, we pass
    a false value to the constructor of the `ReentrantLock` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the contrary, when we establish fair mode by passing the true value to the
    constructor of the `Lock` class, the behavior is different. The first thread that
    requests control of the lock is `Thread 0`, then `Thread 1`, and so on. While
    `Thread 0` is running the first block of code protected by the lock, we have nine
    threads waiting to execute the same block of code. When `Thread 0` releases the
    lock, it immediately requests the lock again, so we have 10 threads trying to
    get the lock. As the fair mode is enabled, the `Lock` interface will choose `Thread
    1`, as it''s the thread that has been waiting for more time for the lock. Then,
    it chooses `Thread 2`, then `Thread 3`, and so on. Until all the threads have
    passed the first block protected by the lock, none of them will execute the second
    block protected by the lock. Once all the threads have executed the first block
    of code protected by the lock, then it will be the turn of `Thread 0` again, then
    `Thread 1`, and so on. The following screenshot shows the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Lock` interface (and the `ReentrantLock` class) includes another method
    to get control of the lock. It''s the `tryLock()` method. The biggest difference
    with the `lock()` method is that this method, if the thread that uses it can''t
    get control of the Lock interface, returns immediately and doesn''t put the thread
    to sleep. It returns the `boolean` value `true` if the thread gets control of
    the lock and `false` if not. You can also pass a time value and a `TimeUnit` object
    to indicate the maximum amount of time the thread will wait to get the lock. If
    the time elapses and the thread doesn''t get the lock, the method will return
    the false value. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`; these indicate the units of time we pass to a method.'
  prefs: []
  type: TYPE_NORMAL
- en: Take into consideration that it is the responsibility of the programmer to take
    into account the result of this method and act accordingly. If the method returns
    `false`, it's apparent that your program is unable to execute the critical section.
    If it does, you probably will have wrong results in your application.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReentrantLock` class also allows the use of recursive calls. When a thread
    has control of a lock and makes a recursive call, it continues with the control
    of the lock, so the calling to the `lock()` method will return immediately and
    the thread will continue with the execution of the recursive call. Moreover, we
    can also call other methods. You should call the `unlock()` method as many times
    as you called the `lock()` method in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have to be very careful with the use of locks to avoid **deadlocks**. This
    situation occurs when two or more threads are blocked while waiting for locks
    that will never be unlocked. For example, thread (A) locks Lock (X) and thread
    (B) locks Lock (Y). Now, if thread (A) tries to lock Lock (Y) and thread (B) simultaneously
    tries to lock Lock (X), both the threads will be blocked indefinitely because
    they are waiting for locks that will never be liberated. Note that the problem
    occurs because both threads try to get the locks in the opposite order. The Appendix,
    *Concurrent Programming Design*, provides some good tips to design concurrent
    applications adequately and avoid these deadlock problems.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a method* and *Using multiple conditions in a lock* recipes
    in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing data access with read/write locks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most significant improvements offered by locks is the `ReadWriteLock`
    interface and the `ReentrantReadWriteLock` class, the unique class that implements
    that interface. This class has two locks: one for read operations and one for
    write operations. There can be more than one thread using read operations simultaneously,
    but only one thread can use write operations. If a thread is doing a write operation,
    other threads can''t write or read.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a `ReadWriteLock` interface by implementing
    a program that uses it to control access to an object that stores the prices of
    two products.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should read the *Synchronizing a block of code with a lock* recipe to better
    understand this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `PricesInfo` that stores information about the prices
    of two products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two `double` attributes named `price1` and `price2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `ReadWriteLock` object called `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the three attributes.
    For the `lock` attribute, create a new `ReentrantReadWriteLock` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getPrice1()` method that returns the value of the `price1` attribute.
    It uses the read lock to control access to the value of this attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getPrice2()` method that returns the value of the `price2` attribute.
    It uses the read lock to control access to the value of this attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `setPrices()` method that establishes the values of two attributes.
    It uses the write lock to control access to them. We are going to make the thread
    sleep for 5 seconds. This shows that even though it has the write lock, there
    are no other threads getting the read lock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Reader` and specify that it implements the `Runnable`
    interface. This class implements a reader of the values of the `PricesInfo` class
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `PricesInfo` object and implement the constructor of the class that
    could initialize this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method for this class. It reads the value of the two
    prices 10 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Writer` and specify that it implements the `Runnable`
    interface. This class implements a modifier of the values of the `PricesInfo`
    class attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `PricesInfo` object and implement the constructor of the class that
    could initialize this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It modifies the value of the two prices that
    are sleeping for 2 seconds between modifications three times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `PricesInfo` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five `Reader` objects and five `Thread` objects to execute them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Writer` object and `Thread` to execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a part of the output of one execution
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While the writer has acquired the write lock, none of the reader tasks can read
    the data. You can see some messages of the reader tasks after the `Write Lock
    Acquired` message, but they are instructions that were executed before and not
    shown yet in the console. Once the writer task has released the lock, reader tasks
    gain access to the prices information again and show the new prices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `ReentrantReadWriteLock` class has two locks:
    one for read operations and one for write operations. The lock used in read operations
    is obtained with the `readLock()` method declared in the `ReadWriteLock` interface.
    This lock is an object that implements the `Lock` interface, so we can use the
    `lock()`, `unlock()`, and `tryLock()` methods. The lock used in write operations
    is obtained with the `writeLock()` method declared in the `ReadWriteLock` interface.
    This lock is also an object that implements the `Lock` interface, so we can use
    the `lock()`, `unlock()`, and `tryLock()` methods. It is the responsibility of
    the programmer to ensure correct use of these locks, using them for the same purposes
    for which they were designed. When you get the read lock of a `Lock` interface,
    you can''t modify the value of the variable. Otherwise, you probably will have
    data errors related to inconsistency.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple conditions in a lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lock may be associated with one or more conditions. These conditions are declared
    in the `Condition` interface. The purpose of these conditions is to allow threads
    to have control of a lock and check whether a condition is `true` or not. If it's
    `false`, the thread will be suspended until another thread wakes it up. The `Condition`
    interface provides the mechanisms to suspend a thread and wake up a suspended
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: A classic problem in concurrent programming is the producer-consumer problem.
    We have a data buffer, one or more producers of data that save it in the buffer,
    and one or more consumers of data that take it from the buffer, as explained earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using locks and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should read the *Synchronizing a block of code with a lock* recipe to better
    understand this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, implement a class that will simulate a text file. Create a class named
    `FileMock` with two attributes: a `String` array named content and `int` named
    `index`. They will store the content of the file and the line of the simulated
    file that will be retrieved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the content of the
    file with random characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `hasMoreLines()` method that returns `true` if the file has more
    lines to process or `false` if you have reached the end of the simulated file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getLine()` method that returns the line determined by the index
    attribute and increases its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement a class named `Buffer` that will implement the buffer shared
    by both the producers and consumers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has six attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A `LinkedList<String>` attribute named `buffer` that will store the shared
    data. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'An `int` type named `maxSize` that will store the length of the buffer. For
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ReentrantLock` object called `lock` that will control access to the blocks
    of code that modify the buffer. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Two `Condition` attributes named `lines` and `space`. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A `boolean` type called `pendingLines` that will indicate whether there are
    lines in the buffer. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. It initializes all the attributes described
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `insert()` method. It receives `String` as a parameter and tries
    to store it in the buffer. First, it gets control of the lock. When it has this,
    it checks whether there is empty space in the buffer. If the buffer is full, it
    calls the `await()` method in the `space` condition to wait for free space. The
    thread will be woken up when another thread calls the `signal()` or `signalAll()`
    method in the `space` condition. When this happens, the thread stores the line
    in the buffer and calls the `signallAll()` method over the `lines` condition.
    As we''ll see in a moment, this condition will wake up all the threads that are
    waiting for lines in the buffer. To make the code easier, we ignore the `InterruptedException`
    exception. In real cases, you will probably have to process it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `get()` method. It returns the first string stored in the buffer.
    First, it gets control of the lock. When this is done, it checks whether there
    are lines in the buffer. If the buffer is empty, it calls the `await()` method
    in the `lines` condition to wait for lines in the buffer. This thread will be
    woken up when another thread calls the `signal()` or `signalAll()` method in the
    lines condition. When this happens, the method gets the first line in the buffer,
    calls the `signalAll()` method over the `space` condition, and returns `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `setPendingLines()` method that establishes the value of the
    `pendingLines` attribute. It will be called by the producer when it has no more
    lines to produce:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `hasPendingLines()` method. It returns `true` if there are more
    lines to be processed or `false` otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s the turn of the producer. Implement a class named `Producer` and
    specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two attributes, namely an object of the `FileMock` class and an object
    of the `Buffer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes both the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method that reads all the lines created in the `FileMock`
    object and use the `insert()` method to store them in the buffer. Once this is
    done, use the `setPendingLines()` method to alert the buffer that it will not
    generate more lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the consumer''s turn. Implement a class named `Consumer` and specify
    that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `Buffer` object and implement the constructor of the class that initializes
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. While the buffer has pending lines, it tries
    to get one line and process it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `processLine()`. It only sleeps for 10 milliseconds
    to simulate some kind of processing with the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `FileMock` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Buffer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Producer` object and `Thread` to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three `Consumer` objects and three threads to run them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the producer and the three consumers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the `Condition` objects are associated with a lock and are created using
    the `newCondition()` method declared in the `Lock` interface. Before we can do
    any operation with a condition, you have to have control of the lock associated
    with the condition. So operations with conditions must be done in a thread that
    holds the lock with a call to a `lock()` method of a `Lock` object and then frees
    it with an `unlock()` method of the same `Lock` object.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls the `await()` method of a condition, it automatically frees
    the control of the lock so that another thread can get it and either begin the
    execution or another critical section protected by that lock.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls the `signal()` or `signallAll()` methods of a condition,
    one or all of the threads that were waiting for that condition are woken up, but
    this doesn't guarantee that the condition that made them sleep is now `true`.
    So you must put the `await()` calls inside a while loop. You can't leave this
    loop until the condition is `true`. When the condition is `false`, you must call
    `await()` again.
  prefs: []
  type: TYPE_NORMAL
- en: You must be careful with the use of `await()` and `signal()`. If you call the
    `await()` method in a condition and never call the `signal()` method in the same
    condition, the thread will sleep forever.
  prefs: []
  type: TYPE_NORMAL
- en: A thread can be interrupted while it is sleeping, after a call to the `await()`
    method, so you have to process the `InterruptedException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Condition` interface has other versions of the `await()` method, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await(long time, TimeUnit unit)`: Here, the thread will sleep until:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interrupted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thread calls the `signal()` or `signalAll()` methods in the condition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified time passes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitUninterruptibly()`: The thread will sleep until another thread calls
    the `signal()` or `signalAll()` methods, which can''t be interrupted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitUntil(Date date)`: The thread will sleep until:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interrupted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thread calls the `signal()` or `signalAll()` methods in the condition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified date arrives
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use conditions with the `ReadLock` and `WriteLock` locks of a read/write
    lock.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* and *Synchronizing data access
    with read/write locks* recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced locking with the StampedLock class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StampedLock` class provides a special kind of lock that is different from
    the ones provided by the Lock or `ReadWriteLock` interfaces. In fact, this class
    doesn't implement these interfaces, but the functionality it provides is very
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: The first point to note about this kind of lock is that its main purpose is
    to be a helper class to implement thread-safe components, so its use will not
    be very common in normal applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important features of `StampedLock` locks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain control of the lock in three different modes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: In this mode, you get exclusive access to the lock. No other thread
    can have control of the lock in this mode.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read**: In this mode, you have non-exclusive access to the lock. There can
    be other threads that have access to the lock in this mode or the Optimistic Read
    mode.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimistic Read**: Here, the thread doesn''t have control over the block.
    Other threads can get control of the lock in write mode. When you get a lock in
    the Optimistic Read mode and you want to access the shared data protected by it,
    you will have to check whether you can access them or not using the `validate()`
    method.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `StampedLock` class provides methods to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquire control over the lock in one of the previous modes. If the methods (`readLock()`,
    `writeLock()`, `readLockInterruptibly()`) are unable to get control of the lock,
    the current thread is suspended until it gets the lock.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquire control over the lock in one of the previous modes. If the methods (`tryOptimisticRead()`,
    `tryReadLock()`, `tryWriteLock()`) are unable to get control of the lock, they
    return a special value to indicate this circumstance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert one mode into another, if possible. If not, the methods (`asReadLock()`,
    `asWriteLock()`, `asReadWriteLock()`) return a special value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Release the lock.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods return a long value called stamp that we need to use to work
    with the lock. If a method returns zero, it means it tried to get a lock but it
    couldn't.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `StampedLock` lock is not a reentrant lock, such as the `Lock` and `ReadWriteLock`
    interfaces. If you call a method that tries to get the lock again, it may be blocked
    and you'll get a deadlock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have the notion of ownership. They can be acquired by one thread
    and released by another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it doesn't have any policy about the next thread that will get control
    of the lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the different modes of the `StampedLock`
    class to protect access to a shared data object. We will use a shared object between
    three concurrent tasks to test the three access modes with `StampedLock` (write,
    read, and Optimistic Read).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, implement the shared data object. Create a class named `Position` with
    two integer attributes, namely `x` and `y`. You have to include the methods to
    get and set the values of the attributes. Its code is very simple so it is not
    included here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s implement the `Writer` task. It implements the `Runnable` interface
    and it will have two attributes: a `Position` object named `position` and `StampedLock`
    named `lock`. They will be initialized in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. In a loop that we will repeat 10 times, get the
    lock in write mode, change the value of the two attributes of the position object,
    suspend the execution of the thread for a second, release the lock (in the `finally`
    section of a `try...catch...finally` structure to release the lock in any circumstance),
    and suspend the thread for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `Reader` task to read the values of the shared object.
    Create a class named `Reader` that implements the `Runnable` interface. It will
    have two attributes: a `Position` object named `position` and a `StampedLock`
    object named `lock`. They will be initialized in the constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `run()` method. In a loop that we will repeat `50` times,
    get control of the lock in read mode, write the values of the position object
    in the console, and suspend the thread for `200` milliseconds. Finally, release
    the lock using the `finally` block of a `try...catch...finally` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `OptimisticReader` task. The class `OptimisticReader` class
    implements the `Runnable` interface. It will have two attributes: a `Position`
    object named `position` and a `StampledLock` object named `lock`. They will be
    initialized in the constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `run()` method. First obtain the stamp of the lock in the
    optimistic read mode using the `tryOptimisticRead()` method. Then, repeat the
    loop `100` times. In the loop, validate whether you can access data using the
    `validate()` method. If this method returns true, write the values of the position
    object in the console. Otherwise, write a message in the console and get another
    stamp using the `tryOptimisticRead()` method again. Then, suspend the thread for
    `200` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the `Main` class with the `main()` method. Create a `Position`
    and `StampedLock` object, create three threads--one for each task--start the threads,
    and wait for their finalization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we tested the three modes you can use with a stamped lock.
    In the `Writer` task, we get the lock with the `writeLock()` method (that acquires
    the lock in write mode). In the `Reader` task, we get the lock with the `readLock()`
    method (that acquires the lock in read mode). Finally, in the `OptimisticRead`
    task, first we use `tryOptimisticRead()` and then we use the `validate()` method
    to check whether we can access data or not.
  prefs: []
  type: TYPE_NORMAL
- en: The first two methods, if they can get control of the lock, wait until they
    get the lock. The `tryOptimisticRead()` method always returns a value. It will
    be `0` if we are unable to use the lock and a value different from `0` if we can
    use it. Remember that in this case, we always need to use the `validate()` method
    to check whether we can really access the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While the `Writer` task has control of the lock, neither `Reader` nor `OptimisticReader`
    can access the values. The `Reader` task is suspended in the `readLock()` method,
    while in `OptimisticReader`, the call to the `validate()` method returns `false`
    and the call to the `tryOptimisticRead()` method returns `0` to indicate that
    the lock is controlled in write mode by another thread. When the `Writertask`
    releases the lock, both `Reader` and `OptimisticReader` tasks will be able to
    access the values of the shared object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StampedLock` class has other methods that you should know:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tryReadLock()` and `tryReadLock(long time, TimeUnit unit)`: These methods
    try to acquire the lock in read mode. If they can''t, the first version is returned
    immediately and the second one waits for the amount of time specified in the parameter.
    These methods also return a stamp that must be checked (`stamp != 0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryWriteLock()` and `tryWriteLock(long time, TimeUnit unit)`: These methods
    try to acquire the lock in write mode. If they can''t, the first version is returned
    immediately and the second one waits for the amount of time specified in the parameter.
    These methods also return a stamp that must be checked (`stamp != 0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isReadLocked()` and `isWriteLocked()`: These methods are returned if the lock
    is currently held in read or write mode, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryConvertToReadLock(long stamp)`, `tryConvertToWriteLock(long stamp)`, and
    `tryConvertToOptimisticRead(long stamp)`: These methods try to convert the stamp
    passed as a parameter to the mode indicated in the name of the method. If they
    can, they return a new stamp. If not, they return `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock(long stamp)`: This releases the corresponding mode of the lock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
