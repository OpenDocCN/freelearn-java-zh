<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Managing Processes in Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With a very quick tour through some of the big new features of Java 9, as well as those from a couple of previous releases, let's turn our attention to applying some of these new APIs in a practical manner. We'll start with a simple process manager.</p>
<p class="mce-root">While having your application or utility handle all of your user's concerns internally is usually ideal, occasionally you need to run (or <strong class="calibre8">shell out to</strong>) an external program for a variety of reasons. From the very first days of Java, this was supported by the JDK via the <kbd class="calibre16">Runtime</kbd> class via a variety of APIs. Here is the simplest example:</p>
<pre class="calibre21">    Process p = Runtime.getRuntime().exec("/path/to/program"); </pre>
<p class="mce-root">Once the process has been created, you can track its execution via the <kbd class="calibre16">Process</kbd> class, which has methods such as <kbd class="calibre16">getInputStream()</kbd>, <kbd class="calibre16">getOutputStream()</kbd>, and <kbd class="calibre16">getErrorStream()</kbd>. We have also had rudimentary control over the process via <kbd class="calibre16">destroy()</kbd> and <kbd class="calibre16">waitFor()</kbd>. Java 8 moved things forward by adding <kbd class="calibre16">destroyForcibly()</kbd> and <kbd class="calibre16">waitFor(long, TimeUnit)</kbd>. Starting with Java 9, these capabilities will be expanded. Quoting from the <strong class="calibre8">Java Enhancement Proposal</strong> (<strong class="calibre8">JEP</strong>), we see the following reasons for this new functionality:</p>
<p class="mce-root"><em class="calibre20">Many enterprise applications and containers involve several Java virtual machines and processes and have long-standing needs that include the following:</em></p>
<ul class="calibre13">
<li class="calibre14"><em class="calibre22">The ability to get the pid (or equivalent) of the current Java virtual machine and the pid of processes created with the existing API.</em></li>
<li class="calibre14"><em class="calibre22">The ability to enumerate processes on the system. Information on each process may include its pid, name, state, and perhaps resource usage.</em></li>
<li class="calibre14"><em class="calibre22">The ability to deal with process trees, in particular, some means to destroy a process tree.</em></li>
<li class="calibre14"><em class="calibre22">The ability to deal with hundreds of sub-processes, perhaps multiplexing the output or error streams to avoid creating a thread per sub-process.</em></li>
</ul>
<p class="mce-root">In this chapter, we'll build a simple process manager application, akin to <span class="calibre7">Windows Task Manager</span> or *nix's top. There is, of course, little need for a process manager written in Java, but this will be an excellent avenue for us to explore these new process handling APIs. Additionally, we'll spend some time with other language features and APIs, namely, JavaFX and <kbd class="calibre16">Optional</kbd>.</p>
<p class="mce-root">The following topics are covered in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">Creating the project</li>
<li class="calibre14">Bootstrapping the application</li>
<li class="calibre14">Defining the user interface</li>
<li class="calibre14">Initializing the user interface</li>
<li class="calibre14">Adding menus</li>
<li class="calibre14">Updating the process list</li>
</ul>
<p class="mce-root">With that said, let's get started.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating a project</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Typically speaking, it is much better if a build can be reproduced without requiring the use of a specific IDE or some other proprietary tool. Fortunately, NetBeans offers the ability to create a Maven-based JavaFX project. Click on <span class="calibre7">File</span> | <span class="calibre7">New Project</span> and select <kbd class="calibre16">Maven</kbd>, then <span class="calibre7">JavaFX Application</span>:</p>
<div class="mce-root1"><img class="image-border9" src="Images/cd7f9cac-f8dd-4668-b89c-cb5d902f767e.png"/></div>
<p class="mce-root">Next, perform the following steps:</p>
<ol class="calibre18">
<li class="chapter">Click on <span class="calibre5">Next</span>.</li>
<li class="chapter">Enter <span class="calibre5">Project Name</span> as <kbd class="calibre16">ProcessManager</kbd>.</li>
<li class="chapter">Enter <span class="calibre5">Group ID</span> as <kbd class="calibre16">com.steeplesoft</kbd>.</li>
<li class="chapter">Enter <span class="calibre5">Package</span> as <kbd class="calibre16">com.steeplesoft.processmanager</kbd>.</li>
<li class="chapter">Select <span class="calibre5">Project Location</span>.</li>
<li class="chapter">Click on <span class="calibre5">Finish</span>.</li>
</ol>
<p class="calibre26">Consider the following screenshot as an example:</p>
<div class="mce-root1"><img class="image-border10" src="Images/fa6a4134-f552-4d1e-867a-aa7fd8eb509d.png" width="740" height="512"/></div>
<p class="mce-root">Once the new project has been created, we need to update the Maven <kbd class="calibre16">pom</kbd> to use Java 9:</p>
<pre class="calibre21">    &lt;build&gt; 
      &lt;plugins&gt; 
        &lt;plugin&gt; 
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; 
          &lt;version&gt;3.6.1&lt;/version&gt; 
          &lt;configuration&gt; 
            &lt;source&gt;9&lt;/source&gt; 
            &lt;target&gt;9&lt;/target&gt; 
          &lt;/configuration&gt; 
        &lt;/plugin&gt; 
      &lt;/plugins&gt; 
    &lt;/build&gt; </pre>
<p class="mce-root">Now, with both NetBeans and Maven configured to use Java 9, we're ready to start coding.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Bootstrapping the application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As noted in the introduction, this will be a JavaFX-based application, so we'll start by creating the skeleton for the application. This is a Java 9 application, and we intend to make use of the Java Module System. To do that, we need to create the module definition file, <kbd class="calibre16">module-info.java</kbd>, which resides in the root of our source tree. This being a Maven-based project, that would be <kbd class="calibre16">src/main/java</kbd>:</p>
<pre class="calibre21">    module procman.app { 
      requires javafx.controls; 
      requires javafx.fxml; 
    } </pre>
<p class="mce-root">This small file does a couple of different things. First, it defines a new <kbd class="calibre16">procman.app</kbd> module. Next, it tells the system that this module <kbd class="calibre16">requires</kbd> two JDK modules: <kbd class="calibre16">javafx.controls</kbd> and <kbd class="calibre16">javafx.fxml</kbd>. If we did not specify these two modules, then our system, which we'll see below, would not compile, as the JDK would not make the required classes and packages available to our application. These modules are part of the standard JDK as of Java 9, so that shouldn't be an issue. However, that may change in future versions of Java, and this module declaration will help prevent runtime failures in our application by forcing the host JVM to provide the module or fail to start. It is also possible to build custom Java runtimes via the <strong class="calibre8">J-Link</strong> tool, so missing these modules is still a possibility under Java 9. With our module configured, let's turn to the application.</p>
<div class="packt_infobox">The emerging standard directory layout seems to be something like <kbd class="calibre39">src/main/java/<em class="calibre22">&lt;module1&gt;</em></kbd>, <kbd class="calibre39">src/main/java/<em class="calibre22">&lt;module2&gt;</em></kbd>, and so on. At the time of writing this book, while Maven can be coaxed into such a layout, the plugins themselves, while they do run under Java 9, do not appear to be module-aware enough to allow us to organize our code in such a manner. For that reason, and for the sake of simplicity, we will treat one Maven module as one Java module and maintain the standard source layout for the projects.</div>
<p class="mce-root">The first class we will create is the <kbd class="calibre16">Application</kbd> descendant, which NetBeans created for us. It created the <kbd class="calibre16">Main</kbd> class, which we renamed to <kbd class="calibre16">ProcessManager</kbd>:</p>
<pre class="calibre21">    public class ProcessManager extends Application { 
      @Override 
      public void start(Stage stage) throws Exception { 
        Parent root = FXMLLoader 
         .load(getClass().getResource("/fxml/procman.fxml")); 
         
        Scene scene = new Scene(root); 
        scene.getStylesheets().add("/styles/Styles.css"); 
         
        stage.setTitle("Process Manager"); 
        stage.setScene(scene); 
        stage.show(); 
      } 
 
      public static void main(String[] args) { 
        launch(args); 
      } 
    } </pre>
<p class="mce-root">Our <kbd class="calibre16">ProcessManager</kbd> class extends the JavaFX base class, <kbd class="calibre16">Application</kbd>, which provides a variety of functionality to start and stop the application. We see in the <kbd class="calibre16">main()</kbd> method that we simply delegate to <kbd class="calibre16">Application.launch(String[])</kbd>, which does the heavy lifting for us in starting our new application.</p>
<p class="mce-root">The more interesting part of this class is the <kbd class="calibre16">start()</kbd> method, which is where the JavaFX life cycle calls back into our application, giving us the opportunity to build the user interface, which we'll do next.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining the user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When building the user interface for a JavaFX application, you can do it in one of two ways: code or markup. To keep our code smaller and more readable, we'll build the user interface using FXML--the XML-based language created specifically for JavaFX to express user interfaces. This presents us with another binary choice--do we write the XML by hand, or do we use a graphical tool? Again, the choice is a simple one--we'll use a tool, <strong class="calibre8">Scene Builder</strong>, which is a WYSIWYG tool originally developed by Oracle and now maintained and supported by Gluon. We will, however, also be looking at the XML source so that we can understand what's being done, so if you don't like using a GUI tool, you won't be left out.</p>
<p class="mce-root">Installing and using Scene Builder is, as you would expect, pretty straightforward. It can be downloaded from <a href="http://gluonhq.com/labs/scene-builder/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://gluonhq.com/labs/scene-builder/</span></a>. Once installed, you need to tell NetBeans where to find it, which can be done in the Settings window, under <span class="calibre7">Java</span> | <span class="calibre7">JavaFX</span>, as you can see in the following screenshot:</p>
<div class="mce-root1"><img class="image-border11" src="Images/81811a5e-6f76-48b8-89f6-088e568110ce.png"/></div>
<p class="mce-root">We are now ready to create the FXML file. Under the <kbd class="calibre16">resources</kbd> directory in the Project View, create a new folder called <kbd class="calibre16">fxml</kbd>, and in that folder, create a file called <kbd class="calibre16">procman.fxml</kbd>, as follows:</p>
<pre class="calibre21">    &lt;BorderPane  
        
      fx:controller="com.steeplesoft.procman.Controller"&gt; 
    &lt;/BorderPane&gt; </pre>
<p class="mce-root"><kbd class="calibre16">BorderPane</kbd> is a container that defines five regions--<kbd class="calibre16">top</kbd>, <kbd class="calibre16">bottom</kbd>, <kbd class="calibre16">left</kbd>, <kbd class="calibre16">right</kbd>, and <kbd class="calibre16">center</kbd>, giving us a fairly coarsely-grained control over where on the form the controls should appear. Typically, with <kbd class="calibre16">BorderPane</kbd>, each area uses a nested container to provide the finer-grained control often necessary. For our needs, this level of control will be perfect.</p>
<p class="mce-root">The primary concern of the user interface is the list of processes, so we'll start with the controls for that. From Scene Builder, we want to click on the <kbd class="calibre16">Controls</kbd> section on the accordion on the left, then scroll down to <kbd class="calibre16">TableView</kbd>. Click on this and drag it to the <kbd class="calibre16">CENTER</kbd> region on the form, as shown here in this screenshot from Scene Builder:</p>
<div class="mce-root1"><img class="image-border12" src="Images/d31ced44-1013-43bd-9262-c0709044c806.png" width="600" height="400"/></div>
<p class="mce-root">The resulting FXML should look something like this:</p>
<pre class="calibre21">    &lt;center&gt; 
        &lt;TableView fx:id="processList" 
               BorderPane.alignment="CENTER"&gt; 
        &lt;/TableView&gt; 
    &lt;/center&gt; </pre>
<p class="mce-root">With no components in the other areas, <kbd class="calibre16">TableView</kbd> will expand to fill the window's full area, which is what we want for now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Initializing the user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While the FXML defines the structure of the user interface, we do need some Java code to initialize various elements, respond to actions, and so forth. This class, referred to as the controller, is simply a class that extends <kbd class="calibre16">javafx.fxml.Initializable</kbd>:</p>
<pre class="calibre21">    public class Controller implements Initializable { 
      @FXML 
      private TableView&lt;ProcessHandle&gt; processList; 
      @Override 
      public void initialize(URL url, ResourceBundle rb) { 
      } 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">initialize()</kbd> method comes from the interface, and is used by the JavaFX runtime to initialize the controller when it is created in the call to <kbd class="calibre16">FXMLLoader.load()</kbd> from the preceding <kbd class="calibre16">Application</kbd> class. Note the <kbd class="calibre16">@FXML</kbd> annotation on the instance variable <kbd class="calibre16">processList</kbd>. When JavaFX initializes the controller, before the <kbd class="calibre16">initialize()</kbd> method is called, the system looks for FXML elements that specify an <kbd class="calibre16">fx:id</kbd> attribute, and assigns that reference to the appropriate instance variable in the controller. To complete this connection, we must make one more change to our FXML file:</p>
<pre class="calibre21"><span class="calibre5">    &lt;TableView fx:id=</span>"<span class="calibre5">processList</span>" <span class="calibre5">BorderPane.alignment=</span>"<span class="calibre5">CENTER</span>"<span class="calibre5">&gt;<br class="calibre2"/></span>    ...</pre>
<p class="mce-root">The change can also be made in Scene Builder as seen in this screenshot:</p>
<div class="mce-root1"><img class="image-border13" src="Images/799dc8e9-e32a-4810-8ff6-53b08e4b30ab.png" width="280" height="143"/></div>
<p class="mce-root">The value of the <span class="calibre7">fx:id</span> attribute must match the name of an instance variable that has been annotated with <kbd class="calibre16">@FXML</kbd>. When <kbd class="calibre16">initialize</kbd> is called, <kbd class="calibre16">processList</kbd> will have a valid reference to <kbd class="calibre16">TableView</kbd> that we can manipulate in our Java code.</p>
<p class="mce-root">The value of <span class="calibre7">fx:id</span> can be set via Scene Builder as well. To set the value, click on the control in the form editor, then expand the <span class="calibre7">Code</span> section in the accordion on the right. In the <span class="calibre7">fx:id</span> field, type in the name of the desired variable name.</p>
<p class="mce-root">The final piece of the puzzle is specifying the controller for the FXML file. In the XML source, you can set this via the <kbd class="calibre16">fx:controller</kbd> attribute on the root element of the user interface:</p>
<pre class="calibre21"><span class="calibre5">    &lt;BorderPane  xmlns=</span>"<span class="calibre5">http://javafx.com/javafx/8.0.60</span>"<br class="calibre2"/><span class="calibre5">      xmlns:fx=</span>"<span class="calibre5">http://javafx.com/fxml/1</span>"<span class="calibre5"> <br class="calibre2"/>      fx:controller=</span>"<span class="calibre5">com.steeplesoft.procman.Controller</span>"<span class="calibre5">&gt;</span></pre>
<p class="mce-root">This can also be set via Scene Builder. In the <span class="calibre7">Document</span> section of the accordion on the left, expand the <span class="calibre7">Controller</span> section and enter the desired fully-qualified class name in the <span class="calibre7">Controller class</span> field:</p>
<div class="mce-root1"><img class="image-border14" src="Images/979ca94b-075a-4410-98c2-6aa383bf9217.png" width="281" height="181"/></div>
<p class="mce-root">With those pieces in place, we can begin the work of initializing <kbd class="calibre16">TableView</kbd>, which gets us back to our primary interest, the process handling APIs. Our starting point is <kbd class="calibre16">ProcessHandles.allProcesses()</kbd>. From the Javadoc, you learn that this method returns <strong class="calibre8">a snapshot of all processes visible to the current process</strong>. From each <kbd class="calibre16">ProcessHandle</kbd> in the stream, we can get information about the process ID, its state, children, parents, and so on. Each <kbd class="calibre16">ProcessHandle</kbd> also has a nested object, <kbd class="calibre16">Info</kbd>, that contains a snapshot of information about the process. Since not all information is available across the various supported platforms and it is limited by the privileges of the current process, the properties on the <kbd class="calibre16">Info</kbd> object are the <kbd class="calibre16">Optional&lt;T&gt;</kbd> instances, indicating that the values may or may not be set. It's probably worth the time to take a quick look at what <kbd class="calibre16">Optional&lt;T&gt;</kbd> is.</p>
<p class="mce-root">The Javadoc describes <kbd class="calibre16">Optional&lt;T&gt;</kbd> as a <strong class="calibre8">container object which may or may not contain a non-null value</strong>. Inspired by Scala and Haskell, <kbd class="calibre16">Optional&lt;T&gt;</kbd> was introduced in Java 8 to allow API authors to provide a more null-safe interface. Prior to Java 8, a method on <kbd class="calibre16">ProcessHandle.Info</kbd> may be defined like this:</p>
<pre class="calibre21">    public String command(); </pre>
<p class="mce-root">To consume the API, the developer would likely write something like this:</p>
<pre class="calibre21">    String command = processHandle.info().command(); 
    if (command == null) { 
      command = "&lt;unknown&gt;"; 
    } </pre>
<p class="mce-root">If the developer fails to check for null explicitly, <kbd class="calibre16">NullPointerException</kbd> is almost certain to occur at some point. By using <kbd class="calibre16">Optional&lt;T&gt;</kbd>, the API author signals to the user that the return value may be null and should be handled carefully. The updated code, then, may look like this:</p>
<pre class="calibre21">    String command = processHandle.info().command() 
     .orElse("&lt;unknown&gt;"); </pre>
<p class="mce-root">Now, in one concise line, we can get the value, if it is present, or a default if it is not. The <kbd class="calibre16">ProcessHandle.Info</kbd> API makes extensive use of this construct as we'll see later.</p>
<p class="mce-root">What else does <kbd class="calibre16">Optional</kbd> afford us as developers? There are a number of instance methods that can help clarify null-handling code:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">filter(Predicate&lt;? super T&gt; predicate)</kbd>: With this method, we filter the contents of <kbd class="calibre16">Optional</kbd>. Rather than using an <kbd class="calibre16">if...else</kbd> block, we can pass the <kbd class="calibre16">filter()</kbd> method a <kbd class="calibre16">Predicate</kbd> and do the test inline. A <kbd class="calibre16">Predicate</kbd> is a <kbd class="calibre16">@FunctionalInterface</kbd> that takes an input and returns a Boolean. For example, some uses of the JavaFX <kbd class="calibre16">Dialog</kbd> may return <kbd class="calibre16">Optional&lt;ButtonType&gt;</kbd>. If we wanted to do something <strong class="calibre3">only</strong> if the user clicked a specific button, say, OK, we could filter <kbd class="calibre16">Optional</kbd> like this:</li>
</ul>
<pre class="calibre21">        alert.showAndWait() 
         .filter(b -&gt; b instanceof ButtonType.OK) </pre>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">map(Function&lt;? super T,? extends U&gt; mapper)</kbd>: The <kbd class="calibre16">map</kbd> function allows us to pass the contents of <kbd class="calibre16">Optional</kbd> to a function, which will perform some processing on it, and return it. The return from the function, though, will be wrapped in an <kbd class="calibre16">Optional</kbd>:</li>
</ul>
<pre class="calibre21">        Optional&lt;String&gt; opts = Optional.of("hello"); 
        Optional&lt;String&gt; upper = opts.map(s -&gt;  
         s.toUpperCase()); 
        Optional&lt;Optional&lt;String&gt;&gt; upper2 =  
         opts.map(s -&gt; Optional.of(s.toUpperCase())); </pre>
<p class="calibre26">Note the double wrapping in <kbd class="calibre16">Optional</kbd> for <kbd class="calibre16">upper2</kbd>. If <kbd class="calibre16">Function</kbd> returns <kbd class="calibre16">Optional</kbd>, it will be wrapped in another <kbd class="calibre16">Optional</kbd>, giving us this odd double wrap, which is less than desirable. Fortunately, we have an alternative.</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</kbd>: The <kbd class="calibre16">flatMap</kbd> function combines two functional ideas--maps and flatten. If the result of <kbd class="calibre16">Function</kbd> is an <kbd class="calibre16">Optional</kbd> object, rather than double wrapping the value, it is flattened to a single <kbd class="calibre16">Optional</kbd> object. Revisiting the preceding example, we get this:</li>
</ul>
<pre class="calibre21">        Optional&lt;String&gt; upper3 = opts.flatMap(s -&gt;      
         Optional.of(s.toUpperCase())); </pre>
<p class="calibre26">Note that <kbd class="calibre16">upper3</kbd>, unlike <kbd class="calibre16">upper2</kbd>, is a single <kbd class="calibre16">Optional</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">get()</kbd>: This returns the wrapped value, if present. If there is no value, a <kbd class="calibre16">NoSuchElementException</kbd> error is thrown.</li>
<li class="calibre14"><kbd class="calibre16">ifPresent(Consumer&lt;? super T&gt; action)</kbd>: If the <kbd class="calibre16">Optional</kbd> object contains a value, it is passed to the <kbd class="calibre16">Consumer</kbd>. If there is no value present, nothing happens.</li>
<li class="calibre14"><kbd class="calibre16">ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</kbd>: Like <kbd class="calibre16">ifPresent()</kbd>, this will pass the value to the <kbd class="calibre16">Consumer</kbd> if there is one present. If no value is present, the <kbd class="calibre16">Runnable emptyAction</kbd> is executed.</li>
<li class="calibre14"><kbd class="calibre16">isPresent()</kbd>: This simply returns true if the <kbd class="calibre16">Optional</kbd> object contains a value.</li>
<li class="calibre14"><kbd class="calibre16">or(Supplier&lt;Optional&lt;T&gt;&gt; supplier)</kbd>: If the <kbd class="calibre16">Optional</kbd> object has a value, the <kbd class="calibre16">Optional</kbd> is described. If there is no value present, an <kbd class="calibre16">Optional</kbd> object produced by the <kbd class="calibre16">Supplier</kbd> is returned.</li>
<li class="calibre14"><kbd class="calibre16">orElse(T other)</kbd>: If the <kbd class="calibre16">Optional</kbd> object contains a value, it is returned. If there is no value, <kbd class="calibre16">other</kbd> is returned.</li>
<li class="calibre14"><kbd class="calibre16">orElseGet(Supplier&lt;? extends T&gt; supplier)</kbd>: This works just like <kbd class="calibre16">orElse()</kbd> mentioned earlier, but, if no value is present, the result of the <kbd class="calibre16">Supplier</kbd> is returned.</li>
<li class="calibre14"><kbd class="calibre16">orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</kbd>: If there is a value present, it is returned. If there is no value, the <kbd class="calibre16">Exception</kbd> provided by the <kbd class="calibre16">Supplier</kbd> is thrown.</li>
</ul>
<p class="mce-root"><kbd class="calibre16">Optional</kbd> also has several static methods that facilitate the creation of the <kbd class="calibre16">Optional</kbd> instances, some of which are as follows:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">empty()</kbd>: This returns an empty <kbd class="calibre16">Optional</kbd> object.</li>
<li class="calibre14"><kbd class="calibre16">of(T value)</kbd>: This returns an <kbd class="calibre16">Optional</kbd> object describing the non-null value. If the value is null, a <kbd class="calibre16">NullPointerException</kbd> is thrown.</li>
<li class="calibre14"><kbd class="calibre16">ofNullable(T value)</kbd>: This returns an <kbd class="calibre16">Optional</kbd> object describing the value. If the value is null, an empty <kbd class="calibre16">Optional</kbd> is returned.</li>
</ul>
<p class="mce-root">With that very brief introduction to <kbd class="calibre16">Optional&lt;T&gt;</kbd> under our belts, let's see how its presence affects our application.</p>
<p class="mce-root">Returning our attention to the <kbd class="calibre16">initialize()</kbd> method, then, our first step is to get the list of processes to display. The streams API makes this extremely simple:</p>
<pre class="calibre21">    ProcessHandle.allProcesses() 
     .collect(Collectors.toList()); </pre>
<p class="mce-root">The <kbd class="calibre16">allProcesses()</kbd> method returns <kbd class="calibre16">Stream&lt;ProcessHandle&gt;</kbd>, which allows us to apply the new stream operations to our problem. In this case, we just want to create a <kbd class="calibre16">List</kbd> of all of the <kbd class="calibre16">ProcessHandle</kbd> instances, so we call <kbd class="calibre16">collect()</kbd>, which is a stream operation that takes in a <kbd class="calibre16">Collector</kbd>. There are a number of options from which we could choose, but we want a <kbd class="calibre16">List</kbd>, so we use <kbd class="calibre16">Collectors.toList()</kbd>, which will collect each item in the stream and eventually return a <kbd class="calibre16">List</kbd> when the stream terminates. Note that the parameterized type of <kbd class="calibre16">List</kbd> will match that of <kbd class="calibre16">Stream</kbd>, which is <kbd class="calibre16">ProcessHandle</kbd> in this case.</p>
<p class="mce-root">This one line, then, gets us a <kbd class="calibre16">List&lt;ProcessHandle&gt;</kbd> of every process on the system that the current process can see, but that only gets us halfway. The <kbd class="calibre16">TableView</kbd> API doesn't accept a <kbd class="calibre16">List&lt;T&gt;</kbd>. It only supports <kbd class="calibre16">ObservableList&lt;T&gt;</kbd>, but what is that? Its Javadoc defines it very simply--<em class="calibre20">A list that allows listeners to track changes when they occur</em>. To put it another way, when this list changes, <kbd class="calibre16">TableView</kbd> will be told about it automatically and will redraw itself. Once we associate <kbd class="calibre16">TableView</kbd> with this list, all we have to worry about is the data, and the control will handle the rest. Creating <kbd class="calibre16">ObservableList</kbd> is pretty straightforward:</p>
<pre class="calibre21">    @FXML 
    private TableView&lt;ProcessHandle&gt; processView; 
    final private ObservableList&lt;ProcessHandle&gt; processList =  
      FXCollections.observableArrayList(); 
    // ... 
    processView.setItems(processList);      
    processList.setAll(ProcessHandle.allProcesses() 
     .collect(Collectors.toList())); </pre>
<p class="mce-root">In our case, the <kbd class="calibre16">TableView</kbd> instance is injected by the runtime (included here for clarity), and we create the <kbd class="calibre16">ObservableList</kbd> via <kbd class="calibre16">FXCollections.observableArrayList()</kbd>. In <kbd class="calibre16">initialize()</kbd>, we set the <kbd class="calibre16">ObservableList</kbd> on the <kbd class="calibre16">TableView</kbd> via <kbd class="calibre16">setItems()</kbd>, then populate the <kbd class="calibre16">ObservableList</kbd> via <kbd class="calibre16">setAll()</kbd>. With that, our <kbd class="calibre16">TableView</kbd> has all the data it needs to render itself. Almost. It has the <strong class="calibre8">data</strong> to render, but <strong class="calibre8">how</strong> does it do it? Where does each field of <kbd class="calibre16">ProcessHandle.Info</kbd> go? To answer that, we have to define the columns on the table, and tell each column where to get its data.</p>
<p class="mce-root">To do that, we need to create several <kbd class="calibre16">TableColumn&lt;S,T&gt;</kbd> instances. The <kbd class="calibre16">TableColumn</kbd> is responsible for displaying not only its column heading (as appropriate), but also the value of each cell. However, you have to tell it <strong class="calibre8">how</strong> to display the cell. That is done via a cell value factory. Under Java 7, that API would get us code like this:</p>
<pre class="calibre21">    TableColumn&lt;ProcessHandle, String&gt; commandCol =  
     new TableColumn&lt;&gt;("Command"); 
    commandCol.setCellValueFactory(new  
      Callback&lt;TableColumn.CellDataFeatures&lt;ProcessHandle, String&gt;,  
       ObservableValue&lt;String&gt;&gt;() { 
         public ObservableValue&lt;String&gt; call( 
          TableColumn.CellDataFeatures&lt;ProcessHandle,  
           String&gt; p) { 
             return new SimpleObjectProperty(p.getValue()<br class="calibre2"/>              .info() 
              .command() 
              .map(Controller::afterLast) 
              .orElse("&lt;unknown&gt;")); 
           } 
       }<br class="calibre2"/>    ); </pre>
<p class="mce-root">I'll go ahead and say it for you: that's really ugly. Fortunately, we can put lambdas and type inference to work for us, to make that a lot more pleasant to read:</p>
<pre class="calibre21">    TableColumn&lt;ProcessHandle, String&gt; commandCol =  
     new TableColumn&lt;&gt;("Command"); 
    commandCol.setCellValueFactory(data -&gt;  
     new SimpleObjectProperty(data.getValue().info().command() 
      .map(Controller::afterLast) 
      .orElse("&lt;unknown&gt;"))); </pre>
<p class="mce-root">That's fourteen lines of code replaced by six. Much prettier. Now, we just have to do that five more times, once for each column. As improved as the preceding code may be, there's still quite a bit of repeated code. Again, Java 8 functional interfaces can help us clean the code up a bit more. For each column, we want to specify the header, a width, and what to extract from <kbd class="calibre16">ProcessHandle.Info</kbd>. We can encapsulate that with this method:</p>
<pre class="calibre21">    private &lt;T&gt; TableColumn&lt;ProcessHandle, T&gt;  
      createTableColumn(String header, int width,  
       Function&lt;ProcessHandle, T&gt; function) { 
         TableColumn&lt;ProcessHandle, T&gt; column = 
          new TableColumn&lt;&gt;(header); 
 
         column.setMinWidth(width); 
         column.setCellValueFactory(data -&gt;  
          new SimpleObjectProperty&lt;T&gt;( 
           function.apply(data.getValue()))); 
           return column; 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">Function&lt;T,R&gt;</kbd> interface is <kbd class="calibre16">FunctionalInterface</kbd>, which represents a function that takes in one type, <kbd class="calibre16">T</kbd>, and returns another, <kbd class="calibre16">R</kbd>. In our case, we're defining this method as one that takes as parameters a <kbd class="calibre16">String</kbd>, an <kbd class="calibre16">int</kbd>, and a function that takes in <kbd class="calibre16">ProcessHandle</kbd> and returns a generic type. That may be hard to picture, but with this method defined, we can replace the preceding code and the others like it with calls to this method. The same preceding code can now be condensed to this:</p>
<pre class="calibre21">    createTableColumn("Command", 250,  
      p -&gt; p.info().command() 
      .map(Controller::afterLast) 
      .orElse("&lt;unknown&gt;")) </pre>
<p class="mce-root">Now we just need to add these columns to the control, which we can do with this:</p>
<pre class="calibre21">    processView.getColumns().setAll( 
      createTableColumn("Command", 250,  
      p -&gt; p.info().command() 
       .map(Controller::afterLast) 
       .orElse("&lt;unknown&gt;")), 
      createTableColumn("PID", 75, p -&gt; p.getPid()), 
      createTableColumn("Status", 150,  
       p -&gt; p.isAlive() ? "Running" : "Not Running"), 
      createTableColumn("Owner", 150,  
       p -&gt; p.info().user() 
        .map(Controller::afterLast) 
        .orElse("&lt;unknown&gt;")), 
      createTableColumn("Arguments", 75,  
       p -&gt; p.info().arguments().stream() 
        .map(i -&gt; i.toString()) 
        .collect(Collectors.joining(", ")))); </pre>
<p class="mce-root">Note that every method we're using on <kbd class="calibre16">ProcessHandle.Info</kbd> returns the <kbd class="calibre16">Optional&lt;T&gt;</kbd> we looked at in the preceding code. Since it does this, we have a very nice and clean API to get the information we want (or a reasonable default) without the specter of a <kbd class="calibre16">NullPointerException</kbd> in production.</p>
<p class="mce-root">If we run the application now, we should get something like this:</p>
<div class="mce-root1"><img class="image-border15" src="Images/d410b6b6-9f06-4918-b874-24bfdb36f054.png"/></div>
<p class="mce-root">It's looking good so far, but it's not quite ready yet. We want to be able to start new processes as well as kill existing ones. Both of those will require menus, so we'll add those next.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding menus</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Menus in JavaFX start with a component called <kbd class="calibre16">MenuBar</kbd>. We want this menu to be at the top of the window, of course, so we add the component to the <kbd class="calibre16">top</kbd> section of our <kbd class="calibre16">BorderPane</kbd>. If you use Scene Builder, you will end up with something like this in your FXML file:</p>
<pre class="calibre21">    &lt;MenuBar BorderPane.alignment="CENTER"&gt; 
      &lt;menus&gt; 
        &lt;Menu mnemonicParsing="false" text="File"&gt; 
          &lt;items&gt; 
            &lt;MenuItem mnemonicParsing="false" text="Close" /&gt; 
          &lt;/items&gt; 
        &lt;/Menu&gt; 
        &lt;Menu mnemonicParsing="false" text="Edit"&gt; 
          &lt;items&gt; 
            &lt;MenuItem mnemonicParsing="false" text="Delete" /&gt; 
          &lt;/items&gt; 
        &lt;/Menu&gt; 
        &lt;Menu mnemonicParsing="false" text="Help"&gt; 
          &lt;items&gt; 
            &lt;MenuItem mnemonicParsing="false" text="About" /&gt; 
          &lt;/items&gt; 
        &lt;/Menu&gt; 
      &lt;/menus&gt; 
    &lt;/MenuBar&gt; </pre>
<p class="mce-root">We won't be needing the edit menu, so we can remove that section from the FXML file (or by right-clicking on the second <kbd class="calibre16">Menu</kbd> entry in Scene Builder and clicking on <span class="calibre7">Delete</span>). To create the menu items we do want, we add the appropriate <kbd class="calibre16">MenuItem</kbd> entries to the <kbd class="calibre16">item</kbd> element under the <kbd class="calibre16">File</kbd> element:</p>
<pre class="calibre21">    &lt;Menu mnemonicParsing="true" text="_File"&gt; 
      &lt;items&gt; 
        &lt;MenuItem mnemonicParsing="true"  
          onAction="#runProcessHandler"  
          text="_New Process..." /&gt; 
        &lt;MenuItem mnemonicParsing="true"  
          onAction="#killProcessHandler"  
          text="_Kill Process..." /&gt; 
        &lt;MenuItem mnemonicParsing="true"  
          onAction="#closeApplication"  
          text="_Close" /&gt; 
      &lt;/items&gt; 
    &lt;/Menu&gt; </pre>
<p class="mce-root">Each of these <kbd class="calibre16">MenuItem</kbd> entries has three attributes defined:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">mnemonicParsing</kbd>: This instructs JavaFX to use any letter prefixed with an underscore as a keyboard shortcut</li>
<li class="calibre14"><kbd class="calibre16">onAction</kbd>: This identifies the method on the controller that will be called when <kbd class="calibre16">MenuItem</kbd> is activated/clicked</li>
<li class="calibre14"><kbd class="calibre16">text</kbd>: This defines the label of <kbd class="calibre16">MenuItem</kbd></li>
</ul>
<p class="mce-root">The most interesting part is <kbd class="calibre16">onAction</kbd> and its relationship with the controller. JavaFX, of course, already knows that this form is backed by <kbd class="calibre16">com.steeplesoft.procman. Controller</kbd>, so it will look for a method with the following signature:</p>
<pre class="calibre21">    @FXML 
    public void methodName(ActionEvent event) </pre>
<p class="mce-root"><kbd class="calibre16">ActionEvent</kbd> is a class that is used in a number of scenarios by JavaFX. In our case, we have methods specifically for each menu item, so the event itself isn't too terribly interesting. Let's take a look at each handler, starting with the simplest--<kbd class="calibre16">closeApplication</kbd>:</p>
<pre class="calibre21">    @FXML 
    public void closeApplication(ActionEvent event) { 
      Platform.exit(); 
    } </pre>
<p class="mce-root">There's nothing much to see here; when the menu item is clicked, we exit the application by calling <kbd class="calibre16">Platform.exit()</kbd>.</p>
<p class="mce-root">Next up, let's see how to kill a process:</p>
<pre class="calibre21">    @FXML 
    public void killProcessHandler(final ActionEvent event) { 
      new Alert(Alert.AlertType.CONFIRMATION,  
      "Are you sure you want to kill this process?",  
      ButtonType.YES, ButtonType.NO) 
       .showAndWait() 
       .filter(button -&gt; button == ButtonType.YES) 
       .ifPresent(response -&gt; { 
         ProcessHandle selectedItem =  
          processView.getSelectionModel() <br class="calibre2"/>           .getSelectedItem(); 
         if (selectedItem != null) { 
           selectedItem.destroy(); 
           processListUpdater.updateList(); 
         } 
       }); 
    } </pre>
<p class="mce-root">We have quite a bit going on here. The first thing we do is to create an <kbd class="calibre16">Alert</kbd> box of type <kbd class="calibre16">CONFIRMATION</kbd>, which asks the user to confirm the request. The dialog has two buttons: <kbd class="calibre16">YES</kbd> and <kbd class="calibre16">NO</kbd>. Once the dialog has been created, we call <kbd class="calibre16">showAndWait()</kbd>, which does as its name implies--it shows the dialog and waits for the user's response. It returns <kbd class="calibre16">Optional&lt;ButtonType&gt;</kbd>, which holds the type of the button that the user clicked on, which will either be <kbd class="calibre16">ButtonType.YES</kbd> or <kbd class="calibre16">ButtonType.NO</kbd>, given the type of <kbd class="calibre16">Alert</kbd> box we've created. With <kbd class="calibre16">Optional</kbd>, we can apply <kbd class="calibre16">filter()</kbd> to find only the type of button that we're interested in, which is <kbd class="calibre16">ButtonType.YES</kbd>, the result of which is another <kbd class="calibre16">Optional</kbd>. If the user clicked on yes, <kbd class="calibre16">ifPresent()</kbd> will return true (thanks to our filter), and the lambda we passed in will be executed. Very nice and concise.</p>
<p class="mce-root">The next area of interest is that lambda. Once we've identified <strong class="calibre8">that</strong> the user would like to kill a process, we need to identify <strong class="calibre8">which</strong> process to kill. To do that, we ask <kbd class="calibre16">TableView</kbd> which row is selected via <kbd class="calibre16">TableView.getSelectionModel() .getSelectedItem()</kbd>. We do need to check for null (alas, there's no <kbd class="calibre16">Optional</kbd> here) in the event that the user has not actually selected a row. If it is non-null, we can call <kbd class="calibre16">destroy()</kbd> on the <kbd class="calibre16">ProcessHandle</kbd> the <kbd class="calibre16">TableView</kbd> gives us. We then call <kbd class="calibre16">processListUpdater.updateList()</kbd> to refresh the UI. We'll take a look at that later.</p>
<p class="mce-root">Our final action handler has to run the following command:</p>
<pre class="calibre21">    @FXML 
    public void runProcessHandler(final ActionEvent event) { 
      final TextInputDialog inputDlg = new TextInputDialog(); 
      inputDlg.setTitle("Run command..."); 
      inputDlg.setContentText("Command Line:"); 
      inputDlg.setHeaderText(null); 
      inputDlg.showAndWait().ifPresent(c -&gt; { 
        try { 
          new ProcessBuilder(c).start(); 
        } catch (IOException e) { 
            new Alert(Alert.AlertType.ERROR,  
              "There was an error running your command.") 
              .show(); 
          } 
      }); 
    } </pre>
<p class="mce-root">This is, in many ways, similar to the preceding <kbd class="calibre16">killProcessHandler()</kbd> method--we create a dialog, set some options, call <kbd class="calibre16">showAndWait()</kbd>, then process <kbd class="calibre16">Optional</kbd>. Unfortunately, the dialog doesn't support the builder pattern, meaning we don't have a nice, fluid API to build the dialog, so we do it in several discrete steps. Processing <kbd class="calibre16">Optional</kbd> is also similar. We call <kbd class="calibre16">ifPresent()</kbd> to see if the dialog returned a command line (that is, the user entered some text <strong class="calibre8">and</strong> pressed <span class="calibre7">OK</span>), and pass that to the lambda if present.</p>
<p class="mce-root">Let's take a quick look at the lambda. This is another example of a multiline lambda. Whereas most lambdas we've seen so far have been simple, one-line functions, remember that a lambda <strong class="calibre8">can</strong> span multiple lines. All that needs to be done to support that is to wrap the block in curly braces as we've done, and it's business as usual. Care must be taken with multiline lambdas like this, as any gains in readability and conciseness that lambdas give us can be quickly obscured or erased by a lambda body that grows too large. In those instances, extracting the code out to a method and using a method reference might be the wise thing to do. Ultimately, the decision is yours, but remember the words of Uncle Bob Martin--<em class="calibre20">Clarity is king</em>.</p>
<p class="mce-root">One final item on the topic of menus. To be even more useful, the application should provide a context menu that will allow the user to right-click on a process and kill it from there, as opposed to clicking on the row, moving the mouse to the <kbd class="calibre16">File</kbd> menu, and more. Adding a context menu is a simple operation. All we need to do is modify our <kbd class="calibre16">TableView</kbd> definition in FXML like this:</p>
<pre class="calibre21">    &lt;TableView fx:id="processView" BorderPane.alignment="CENTER"&gt; 
      &lt;contextMenu&gt; 
        &lt;ContextMenu&gt; 
          &lt;items&gt; 
            &lt;MenuItem onAction="#killProcessHandler"  
               text="Kill Process..."/&gt; 
          &lt;/items&gt; 
        &lt;/ContextMenu&gt; 
      &lt;/contextMenu&gt; 
    &lt;/TableView&gt; </pre>
<p class="mce-root">Here, we are adding a <kbd class="calibre16">contextMenu</kbd> child to our <kbd class="calibre16">TableView</kbd>. Much like its sibling, <kbd class="calibre16">MenuBar</kbd>, <kbd class="calibre16">contextMenu</kbd> has an <kbd class="calibre16">items</kbd> child, which, in turn, has 0 or more <kbd class="calibre16">MenuItem</kbd> children. In this case, the <kbd class="calibre16">MenuItem</kbd> for <kbd class="calibre16">Kill Process...</kbd> looks remarkably like that under <kbd class="calibre16">File</kbd>, with the only difference being the <kbd class="calibre16">mnemonicProcessing</kbd> information. We're even reusing the <kbd class="calibre16">ActionEvent</kbd> handler, so there's no extra coding, and the behavior for killing a process is always the same, regardless of which menu item you click on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Updating the process list</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If the application started and showed a list of processes, but never updated that list, it wouldn't be very useful at all. What we then need is a way to update the list periodically, and for that, we'll use a <kbd class="calibre16">Thread</kbd>.</p>
<p class="mce-root">As you may or may not know, a <kbd class="calibre16">Thread</kbd> is roughly a means to run a task in the background (the Javadoc describes it as a <em class="calibre20">thread of execution in a program</em>). A system can be single or multithreaded, depending on the needs and runtime environment of the system. And multithreaded programming is hard to get right. Luckily, our use case here is fairly simple, but we must still exercise caution, or we'll see some really unexpected behavior.</p>
<p class="mce-root">Ordinarily, the advice you would get when creating a <kbd class="calibre16">Thread</kbd> is to implement a <kbd class="calibre16">Runnable</kbd> interface, which you will then pass to the thread's constructor, and that's very good advice, as it makes your class hierarchy much more flexible, since you're not tied to a concrete base class (<kbd class="calibre16">Runnable</kbd> is an <kbd class="calibre16">interface</kbd>). In our case, however, we have a relatively simple system that has little to gain from that approach, so we'll extend <kbd class="calibre16">Thread</kbd> directly and simplify our code a little as well as encapsulating our desired behavior. Let's take a look at our new class:</p>
<pre class="calibre21">    private class ProcessListUpdater extends Thread { 
      private volatile boolean running = true; 
 
      public ProcessListRunnable() { 
        super(); 
        setDaemon(true); 
      } 
 
      public void shutdown() { 
        running = false; 
      } 
 
      @Override 
      public void run() { 
        while (running) { 
          updateList(); 
          try { 
            Thread.sleep(5000); 
          } catch (InterruptedException e) { 
              // Ignored 
            } 
        } 
      }  
 
      public synchronized void updateList() { 
        processList.setAll(ProcessHandle.allProcesses() 
          .collect(Collectors.toList())); 
        processView.sort(); 
      } 
    } </pre>
<p class="mce-root">We have a pretty basic class, which we've given a reasonable and meaningful name that extends <kbd class="calibre16">Thread</kbd>. In the constructor, note that we call <kbd class="calibre16">setDaemon(true)</kbd>. This will allow our application to exit as expected and not block, waiting for the thread to terminate. We've also defined a <kbd class="calibre16">shutdown()</kbd> method, which we'll use from our application to stop the thread.</p>
<div class="packt_infobox">The <kbd class="calibre39">Thread</kbd> class does have various state control methods, such as <kbd class="calibre39">stop()</kbd>, <kbd class="calibre39">suspend()</kbd>, <kbd class="calibre39">resume()</kbd>, and more, but these have all been deprecated as they are considered inherently unsafe. Search for the article, Why are <kbd class="calibre39">Thread.stop</kbd>, <kbd class="calibre39">Thread.suspend</kbd>, and <kbd class="calibre39">Thread.resume</kbd> deprecated? If you would like more details; however, the suggested best practice now is to use a control flag, like we've done with <kbd class="calibre39">running</kbd>, to signal to the <kbd class="calibre39">Thread</kbd> class that it needs to clean up and shut down.</div>
<p class="mce-root">Finally, we have the heart of our <kbd class="calibre16">Thread</kbd> class, <kbd class="calibre16">run()</kbd>, which loops infinitely (or until <kbd class="calibre16">running</kbd> becomes false), sleeping for five seconds after performing its work. The actual work is done in <kbd class="calibre16">updateList()</kbd>, which builds the list of processes, updates <kbd class="calibre16">ObservableList</kbd> we discussed earlier, and then instructs <kbd class="calibre16">TableView</kbd> to re-sort itself, based on the user's sort selection, if any. This is a public method, allowing us to call this at need, as we did in <kbd class="calibre16">killProcessHandler()</kbd>. That leaves us with the following block of code to set it up:</p>
<pre class="calibre21">    @Override 
    public void initialize(URL url, ResourceBundle rb) { 
      processListUpdater = new ProcessListUpdater(); 
      processListUpdater.start(); 
      // ... 
    } </pre>
<p class="mce-root">The following code will shut it down, which we've already seen in <kbd class="calibre16">closeHandler()</kbd>:</p>
<pre class="calibre21">    processListUpdater.shutdown(); </pre>
<p class="mce-root">The eagle-eyed will notice that <kbd class="calibre16">updateList()</kbd> has the <kbd class="calibre16">synchronized</kbd> keyword on it. This is to prevent any sort of race condition that might be caused by calling this method from multiple threads. Imagine the scenario where the user decides to kill a process and clicks on <span class="calibre7">OK</span> on the confirmation dialog at the exact moment the thread wakes up (this type of thing happens more often than you might think). We could conceivably have two threads calling <kbd class="calibre16">updateList()</kbd> at the same time, resulting in the first thread hitting <kbd class="calibre16">processView.sort()</kbd> just as the second is hitting <kbd class="calibre16">processList.setAll()</kbd>. What happens when <kbd class="calibre16">sort()</kbd> is called while another thread is rebuilding the list? It's hard to say for sure, but it could be catastrophic, so we want to disallow that. The <kbd class="calibre16">synchronized</kbd> keyword instructs the JVM to allow only one thread to execute the method at a time, causing all others to queue up, waiting their turn (note that their execution order is non-deterministic, so you can't base any expectations on the order in which threads get to run a <kbd class="calibre16">synchronized</kbd> method). This avoids the potential for a race condition, and ensures that our program doesn't crash.</p>
<p class="mce-root">While appropriate here, care must be taken with <kbd class="calibre16">synchronized</kbd> methods, as acquiring and releasing the locks can be expensive (though much less so with modern JVMs) and, more importantly, it forces threads to run sequentially when they hit this method call, which can cause a very undesirable lag in the application, especially in GUI applications. Keep that in mind when writing your own multithreaded applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With that in place, our application is complete. While not a terribly complex application, it does include several interesting technologies such as JavaFX, Lambdas, Streams, <kbd class="calibre16">ProcessHandle</kbd> plus related classes, and Threads.</p>
<p class="mce-root">In the next chapter, we'll build a simple command-line utility to find duplicate files. Through that, we'll get hands-on experience with the new File I/O APIs, the Java Persistence API (JPA), file hashing, and some more JavaFX.</p>


            </article>

            
        </section>
    </div>



  </body></html>