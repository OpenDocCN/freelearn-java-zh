- en: String Matching Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String matching algorithms are quite common in text-editing programs. These
    kind of programs frequently need to find all occurrences of a pattern in the text,
    where the text is usually the document being edited and the pattern is a word
    supplied by the user. Since text-editing programs aim to be responsive, having
    efficient algorithms to solve the string matching problem is fundamental.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: List common string matching algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve the string matching problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devise a naive algorithm to solve the string matching problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the Boyer-Moore string search algorithm to carry out string search
    in literature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naive Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The string matching problem has two inputs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An array *T[1, 2, ...n]* of length *n*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *array* *P[1, 2, ...m]* of length *m (<= n)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements of `T` and `P` are characters from the same finite alphabet (usually
    called ∑).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we may be searching in binary strings, in which case our alphabet
    is *{0, 1}*, or we may be searching in strings of lowercase letters, in which
    case our alphabet is *{a, b… z}*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents this terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a430fdb-bbbf-4f5c-b989-72740e7d2fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Representation of text array T, pattern array P, and finite alphabet
    ∑'
  prefs: []
  type: TYPE_NORMAL
- en: The character arrays `P` and `T` are usually called "strings of characters".
    We're interested in finding occurrences of pattern `P` in text `T`.
  prefs: []
  type: TYPE_NORMAL
- en: We say that pattern `P` occurs in text `T` if we can align the pattern `P` with
    text `T` so that all characters in `P` match the ones in `T`. When aligning, we
    need to shift pattern `P` zero or more times to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in the string matching problem, we're interested in valid shifts
    with which pattern `P` occurs in text `T`. We say that the pattern `P` occurs
    with a shift *s* in text `T` if the pattern `P` occurs beginning at position `s
    + 1` in text `T`. In other words, we need to shift `P` from the start of text
    `T s` times to the right, in order to find a match. In its essence, the string
    matching problem aims to find all valid shifts with which pattern `P` occurs in
    a given text `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Two common examples, besides text-editing programs, are finding patterns in
    DNA sequences and finding web pages that are relevant to queries in internet search
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've formalized the string matching problem, let's look at the naive algorithm
    to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Naive Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we described the string matching problem, we said that we were interested
    in finding all valid shifts with which pattern `P` occurs in a given text `T`.
    If we translate that notion directly into an algorithm, we're able to arrive at
    the naive string matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the String Matching Algorithm in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to write a code in Java to apply a naive string matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We need to build the naive string matching algorithm. For this algorithm, we
    need to return all valid starting positions (or shifts) in the text `T` in which
    the pattern `P` occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `match()` method of the `NaiveStringMatching` class, which
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'available on GitHub at the following path:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Repeatedly shift pattern `P` along text `T`, matching all the characters in
    it with the characters aligned in `T`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a match occurs, keep track of the index in `T` where it did.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation of the naive string matching algorithm is an almost direct
    translation of the problem statement. We want to go through all possible shifts
    for `P` and check which ones are valid by comparing each element of `P` with the
    corresponding shifted elements of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible solution for this problem is in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.1: Solution to the naive string matching problem. Source class name:
    solution.NaiveStringMatching'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/PmEFws](https://goo.gl/PmEFws) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: Rationalization of the Naive Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The naive search algorithm takes *O((n - m + 1)m)* time, which is a tight bound
    on the worst case. We can imagine a worst case of the naive search algorithm if
    we have a text string with the character a repeating for *n* times, that is, an
    (such as *a5 = "aaaaa"*), and the pattern am (for *m <= n*). In this case, we
    have to execute the inner loop *m* times to validate the shift.
  prefs: []
  type: TYPE_NORMAL
- en: The naive search algorithm can be improved if we know that all characters in
    pattern `P` are different. In this case, whenever we fail validating a shift because
    *P[j]* doesn't match *T[i + j]*, we don't need to backtrack. Instead, we can start
    validating the next shift on *(i + j)*, therefore reducing the running time of
    the algorithm to *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if *P = "abcd"* and *T = "abcaabcd"*, when *i = 0* and *j = 3*,
    we find a mismatch *('a' != 'd')*. Instead of repeating the comparisons for *i
    = 1*, we can start on *i = 3*, because we're sure there's no other a between *i
    = 0* and *i = 3* (remember that all characters of `P` are different). These kinds
    of observations on the pattern `P` are the basis of the Boyer-Moore algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In this first section, we introduced the string matching problem and solved
    it using a naive algorithm. In the following section, we'll introduce a much more
    efficient algorithm to solve this problem—the Boyer-Moore algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with the Boyer-Moore String Searching Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Boyer-Moore string searching algorithm was introduced by Robert S. Boyer
    and J. Strother Moore in 1977, and builds upon the naive search algorithm by intelligently
    skipping certain sections of the text.
  prefs: []
  type: TYPE_NORMAL
- en: One key feature of the algorithm is that it matches the pattern from right to
    left, instead of left to right, using to its advantage a couple of shift rules
    that improve its running time. To understand the effect of these rules, let's
    build the Boyer-Moore algorithm from our naive search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by modifying the matching on the pattern so that it operates from
    right to left. The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.2: Modifying the inner loop from Snippet 5.1 for algorithm to operate
    from right to left C'
  prefs: []
  type: TYPE_NORMAL
- en: Using the naive string matching algorithm as the base, let's look at some rules
    that allow us to intelligently skip certain shifts.
  prefs: []
  type: TYPE_NORMAL
- en: The Bad Character Rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of the bad character rule is to identify mismatches between a character
    in the pattern and a character in the text so that we can safely skip certain
    shifts. To identify the occurrence of a bad character, let''s look at the example
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | 0 | 1 | 2 | 3 | **4** | **5** | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
    | 14 | 15 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| **T** | H | C | B | *B* | **A** | **H** | C | C | A | B | A | H | A | H |
    B | C | C |'
  prefs: []
  type: TYPE_TB
- en: '| **P** | A | B | A | *H* | **A** | **H** |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Identifying bad characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example provided in *Table 5.1*, we successfully matched the suffix
    *AH*, but then arrived at a bad character, since *B != H*. Whenever this happens,
    we''re sure that it will only be possible to find a valid shift starting from
    the next shift that solves this mismatch. This means that we can shift `P` until
    either of the following conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The mismatch is turned into a match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern moves past the mismatched character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can turn a mismatch into a match whenever the pattern has characters to
    the left of the mismatched character that match the character in the text. Otherwise,
    we must move the pattern past the mismatched character. In the example provided
    in *Table 5.1*, we have another *B* at *P[1]*, so we can shift *P* until *P[1]*
    aligns with *T[3]* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| **T** | H | C | B | B | A | H | C | C | A | B | A | H | A | H | B | C | C
    |'
  prefs: []
  type: TYPE_TB
- en: '| **P** |  |  | A | B | A | H | A | *H* |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1.1: Using the bad character rule to skip a shift'
  prefs: []
  type: TYPE_NORMAL
- en: We've safely skipped the check for *1* shift. Now, we have a mismatch right
    in the first character. Let's try to apply the bad character rule. First, let's
    see if we can turn the mismatch into a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, that is not possible because the character *C* is absent from
    *P*. In this case, we shift the pattern past the mismatched character as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| **T** | H | C | B | B | A | H | C | C | **A** | **B** | **A** | **H** | **A**
    | **H** | B | C | C |'
  prefs: []
  type: TYPE_TB
- en: '| **P** |  |  |  |  |  |  |  |  | **A** | **B** | **A** | **H** | **A** | **H**
    |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1.2: Pattern moving past a mismatched character'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully skipped checking five shifts and have arrived at a valid
    shift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bad character rule will help us optimize the naive string matching algorithm,
    but only if we can efficiently find the correct number of times to shift. Let''s
    assume we have access to a two-dimensional array *[1...m][1...e]*, *e* being the
    size of our alphabet. For convenience, let''s call this array left and assume
    that *left[i][j]* gives us the closest index *k* of character *j* in *P* so that
    *k < i*, or is *-1* if character *j* isn''t found to the left of *i* in *P*. If
    we''re able to build such an array, we could improve our naive string search algorithm
    by considering possibly larger skips (given by the information in left). The following
    code snippet shows how we can use the left array to improve our naive string searching
    algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.3: Using the bad character rule to improve our skips'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/cCYnfp](https://goo.gl/cCYnfp) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: We're left to filling in the `left` array, which will be performed in the next
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing the Bad Character Rule'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to preprocess string *P* to build the `left` array that allows us to
    use the bad character rule efficiently. Recall that *left[i][j]* should return
    either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The largest index *k* so that *k <= i* and *P[k] == j*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-1*, if *j* isn''t found in *P*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To build an array that allows us to use the bad character rule efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the commented part of the `match()` method of the class `BadCharacterRule`,
    which is available on GitHub at the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assume that the alphabet of strings *P* and *T* consists only of lowercase letters of
    the English alphabet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Good Suffix Rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The good suffix rule presents a complementary method to enhance our search for
    valid shifts. To identify when the good suffix rule is applicable, let''s look
    at the example given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 | 17 |'
  prefs: []
  type: TYPE_TB
- en: '| **T** | A | A | B | A | B | A | B | A | C | B | A | C | A | B | B | C | A
    | B |'
  prefs: []
  type: TYPE_TB
- en: '| **P** | A | A | C | C | A | C | C | A | C |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: Illustration of the good suffix rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'When found in a situation where we have matched a suffix of *P* but have found
    a mismatch, using the good suffix rule, and considering *t* as the matched suffix,
    we can try to find the next shift that solves the mismatch by carrying out either
    of the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Find another occurrence of *t* to the left in *P*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a prefix of *P* which matches a suffix of *t*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move *P* past *t*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering case 1, we can try to shift *P* by three to align other occurrences
    of *t* in *P* (starting at *P[4]*). As we can see, the letter to the left of that
    occurrence of *t* (in *P[3]*) is *C*, which is exactly the same as the one that
    provoked the mismatch. Therefore, we should always try to find a *t* that is followed,
    on the left, by a character that is different from the one that provoked the mismatch.
    A variant of the good suffix rule which ignores the character on the left of *t*
    is called the weak good suffix rule.
  prefs: []
  type: TYPE_NORMAL
- en: The good suffix rule takes into account that the character on the left of *t*
    is also called the strong good suffix rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can''t find another occurrence of *t* in *P*, the best we can do with
    this rule is to find a prefix of *P* that matches a suffix of *t*, entering case
    2\. *Table 5.3* illustrates this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| **T** | A | *A* | **B** | **A** | **B** | A | B | A | C | B | A |'
  prefs: []
  type: TYPE_TB
- en: '| **P** | A | B | **B** | **A** | **B** |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.3: Finding prefix of P matching the suffix of T'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we found a mismatch at *P[1]*, but we can't find another occurrence
    of *BAB* to the left of it. We can, however, find a prefix of *AB* that matches
    a suffix of *t AB* and shift *P* so that these align.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we can neither find another occurrence nor a prefix of *t*, we're left
    with moving *P* past *t* in *T*.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the good suffix rule also requires some preprocessing
    on *P*. To understand the preprocessing that is necessary, we need to introduce
    the concept of a border and proper prefix and suffix. A prefix of string *S* is
    a substring of *S* that occurs at the beginning of *S*. A proper prefix of string
    *S* is a prefix of *S* that is different than *S* (consider that *S* is always
    a prefix of *S*).
  prefs: []
  type: TYPE_NORMAL
- en: 'A suffix of string *S* is a substring of *S* that occurs at the end of *S*.
    A proper suffix of string *S* is a suffix of *S* that is different from *S* (consider
    that *S* is always a suffix of *S*). A border is a substring of a given string
    that is both a proper prefix and a proper suffix. For example, given the string
    *ccacc*, there are two borders: *c* and *cc. cca* is not a border.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preprocessing step for the good suffix rule is divided into two steps:
    one for case 1 of the rule, and another for case 2.'
  prefs: []
  type: TYPE_NORMAL
- en: In case 1, the matching suffix is a border of a suffix of a pattern. For example,
    if *P = AACCACCAC* and we have *t = AC* (a suffix of *P*), then we need to find
    a suffix of *P* that has *AC* as a prefix (constituting a border of the suffix).
    The string *ACCAC* is a suffix of *P* and has *AC* as a border.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to find the borders of the suffixes of the pattern. But,
    even after finding them, we need to be able to map a given border to the shortest
    suffix that has this border so that we're able to shift accordingly. Moreover,
    to follow the strong good suffix rule, the border cannot be extended to the left
    by the same symbol that caused the mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preprocessing algorithm for case 1 is displayed in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.4: Preprocessing algorithm for Case 1 of the good suffix rule. Source
    class name: GoodSuffixRule'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/WzGuVG](https://goo.gl/WzGuVG) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the preprocessing algorithm for case 1, put some `println`
    statements on the relevant steps of the algorithm and run it using some sample
    input. You can use string `ABBABAB`, whose output is shown in *Table 5.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand what this algorithm produces, let''s look at its output
    for string *ABBABAB*, which is shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| **P** | A | B | B | A | B | A | B |  |'
  prefs: []
  type: TYPE_TB
- en: '| **f** | 5 | 6 | 4 | 5 | 6 | 7 | 7 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| **s** | 0 | 0 | 0 | 0 | 2 | 0 | 4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.4: Output of the preprocessing algorithm for Case 1 of the good suffix
    rule with string ABBABAB'
  prefs: []
  type: TYPE_NORMAL
- en: The widest border of suffix *BABAB*, which starts at *2*, is *BAB*, which starts
    at *4*, and therefore *f[2] = 4*. The widest border of suffix *AB*, which starts
    at *5*, is "", which starts at *7*. Therefore, *f[5] = 7*. The suffix *BABAB*,
    whose widest border is *BAB*, cannot be extended to the left (since *P[1] != P[3]*).
    Therefore, the shift distance of *BAB* is matched and then a mismatch occurs,
    which is *s[4] = 4 - 2 = 2*. The suffix *BABAB* has border *B* as well, which
    also cannot be extended to left, which ensures that *s[6] = 6 - 2 = 4*. The suffix
    *B* beginning at position *6* has border "", beginning at position *7*; therefore,
    *s[7] = 7 - 6 = 1*, which corresponds to the shift distance if nothing has matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case 2, a suffix of the matching suffix of the pattern occurs at the beginning
    of the pattern, which constitutes a border of the pattern. Therefore, the pattern
    can be shifted as far as its widest border allows. What we need to do for the
    preprocessing step for case 2 is to find, for each suffix, the widest border of
    the pattern that is contained in that suffix. We can build upon the *f* array
    that was previously computed to do that. The following snippet illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.5: Preprocessing algorithm for Case 2 of the good suffix rule. Source
    class name: GoodSuffixRule'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/ckoTu6](https://goo.gl/ckoTu6) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: The widest border of the pattern is stored at *f[0]*. The idea of the preprocessing
    algorithm for case 2 is to use that value until the pattern becomes shorter than
    *f[0]*, in which case we go with the next wider border of the pattern *(f[j])*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integrating the good suffix case with the naive search algorithm allows us
    to improve on the skips performed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.6: The Boyer-Moore algorithm using only the good suffix rule. Source
    class name: Goodsuffixrule'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/1uCgeh](https://goo.gl/1uCgeh) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: Application of the Boyer-Moore Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm is typically used with one or both the bad character
    and good suffix rule. When used with both rules, the shift that is to occur is
    the biggest one produced by the rules. The Boyer-Moore algorithm improves the
    naive search algorithm in the average case, but is still *O(nm)* in the worst
    case (that case being the same described in the previous section, that is, a repeated
    group of characters both in the pattern and in the text).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Boyer-Moore Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to write a code in Java to implement the Boyer-Moore algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We need to integrate the bad character rule with the good suffix rule to produce
    the complete Boyer-Moore algorithm. The idea here is to use the rule that gives
    us the better (or biggest) shift in each situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `match()` method of the `BoyerMoore` class, which is available
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'on the following path:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Combine the snippets and change the skip logic to choose the best of both rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following snippet shows how the combined matching can be implemented as
    a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.7: Implementation of the boyer-moore algorithm. Source class: BoyerMoore'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/71mXd6](https://goo.gl/71mXd6) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've introduced the Boyer-Moore algorithm as an improvement
    over the naive search algorithm. By preprocessing the pattern to skip unnecessary
    shifts, we can decrease the average runtime complexity of the string matching
    algorithm. In the following section, we will list some other string matching algorithms,
    listing their applicability, but without going into much detail about their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Other String Matching Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though the Boyer-Moore string search algorithm is the standard benchmark
    for practical string search literature, there are other string matching algorithms
    that are also suitable for different purposes. In this small section, we present
    the following three, which are the most famous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Rabin-Karp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knuth-Morris-Pratt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aho-Corasick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, only give out the implementation of Rabin-Karp.
  prefs: []
  type: TYPE_NORMAL
- en: Rabin-Karp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1987, Richard M. Karp and Michael O. Rabin proposed a string matching algorithm
    that performs well in practice and generalizes string matching against a set of
    patterns. The Rabin-Karp algorithm takes *O(m)* time in its preprocessing stage
    and its worst-case running time is *O((n - m + 1)m)*, similar to Boyer-Moore's.
  prefs: []
  type: TYPE_NORMAL
- en: To better introduce the Rabin-Karp algorithm, let's assume that our alphabet
    ∑ is composed only of decimal digits *(∑ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9})*, so
    that we can view a string of *k* characters as a decimal number with length *k*.
    Therefore, string 12345 corresponds to number 12345\. Given a pattern *P[0...m]*
    and a substring from text *T[i...i + m]*, if we convert both those strings to
    their correspondent decimal number, so that we have numbers *p* and *t[i]*, then
    *p = t[i]* only if *P[0...m] = T[i...i + m]*, and therefore *i* is only a valid
    shift if *p = t[i]*.
  prefs: []
  type: TYPE_NORMAL
- en: If we could compute p in *O(m)* time and all the t[i] values in *O(n - m + 1)*
    time, then we could determine all valid shifts in *O(n)* time by comparing p with
    each of the *t[i]* values. The problem with this is when *p* and *t[i]* are too
    large to work with. If the numbers are too large, then we can work with them modulo
    *q*, for a suitable modulus *q*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's leave the choice of a suitable modulus *q* for later. How we can generalize
    this to work with other alphabets? For example, what if we want to use characters
    that are not decimal digits?
  prefs: []
  type: TYPE_NORMAL
- en: Consider that, in the case of our original alphabet, to convert a string 12345
    into a number, we would perform the operation *10⁴*1+10³*2+10²*3+10¹*4+10⁰*5*.
    If we have a D-ary alphabet *{0, 1… d - 1}*, then we could use the same strategy,
    but replace 10 by *d*. One other consideration to have is that, when we have computed
    *t[i]* and we want to compute *t[i+1]*, then we can simply remove the leftmost
    digit, shift everything to the left, and add the newest digit, that is, *t[i+1]
    = ((t[i] - T[i]*d[m-1])*d + T[i + 1]) % q*.
  prefs: []
  type: TYPE_NORMAL
- en: One final consideration to have is that working with modulo *q* is not perfect.
    *t[i] = p (mod q)* does not imply that *t[i] = p*. But if *t[i] != p* *(mod q)*,
    then *t[i] != p*. We can therefore use this as a fast heuristic test to rule out
    invalid shifts.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Rabin-Karp Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim here is to develop a code in Java for implementing the Rabin-Karp algorithm
    for matching a string from a set of alphabetical characters that have decimal
    digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the text and pattern strings into digits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use if and for loops to calculate the number of matching characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put everything together to implement the Rabin-Karp algorithm. The following
    *Snippet 5.9* shows the pre-compute part of the algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 5.9: Implementation of the Rabin-Karp algorithm. Source class name: RabinKarp'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/w7yzPA](https://goo.gl/w7yzPA) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous implementation, we chose *q* as a large prime number (using
    the `BigInteger` API). We did that so that we have a good hash function and avoided
    the most of false positives from the *p = t[i]* comparison. This is a similar
    technique to the one we saw in the remainder method for hash tables in [Chapter
    3](05da549e-383b-475e-86f2-043f47a226a1.xhtml), *Hash Tables and Binary Search
    Trees*.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being outside the scope of this book, the Rabin-Karp algorithm generalizes
    well to having a set of patterns to be found in the same text. For that purpose,
    it is frequently used in plagiarism detection.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth–Morris–Pratt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Knuth-Morris-Pratt** (**KMP**) algorithm is a single-pattern string searching
    algorithm conceived by Donald Knuth and Vaughan Pratt in 1970, and independently
    by James H. Morris, being jointly published by the three in 1977\. When compared
    to the Boyer-Moore algorithm, KMP employs the observation that, when a mismatch
    occurs, the pattern embodies sufficient information to determine where the next
    match could begin.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to Boyer-Moore in the sense that it efficiently skips unnecessary
    comparisons. The KMP algorithm has a running time of *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Aho–Corasick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Aho-Corasick algorithm is a string searching algorithm invented by Alfred
    V. Aho and Margaret J. Corasick. Similar to the extended version of the Rabin-Karp
    algorithm, it is capable of matching elements of a dictionary (set of words) within
    an input text. The idea behind it is to build a finite state machine that enables
    matching all strings of the dictionary simultaneously. The algorithm is linear
    in the length of the strings, plus the length of the searched text, plus the number
    of output matches. If *n* is the length of the searched text, *m* is the sum of
    the length of all words in the dictionary, and *z* is the total number of occurrences
    of words in the text.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the time complexity of the Aho-Corasick algorithm is *O(n + m + z)*.
    In this small section, we've looked at three other famous string matching algorithms.
    Without going into much detail about them, we've seen their applicability on different
    problems other than the one the Boyer-Moore algorithm solves. In particular, we've
    noted that there are algorithms specialized for the finding of a set of patterns
    in a text.
  prefs: []
  type: TYPE_NORMAL
- en: In 1979, Zvi Galil introduced an important optimization, called the Galil rule, that
    speeds up the comparisons done at each shift by skipping sections that are known
    to match. Using the Galil rule, the Boyer-Moore algorithm achieves linear time
    complexity in the worst case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced the string matching problem. We've started
    from the naive search algorithm and improved it by using the rules introduced
    by Boyer and Moore. We've seen how these rules improve the average runtime complexity
    of our algorithm. We've also explored some other string matching algorithms without going
    into too much detail about them. In the next chapter, we will be exploring graphs and
    their applications
  prefs: []
  type: TYPE_NORMAL
