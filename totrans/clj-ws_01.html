<html><head></head><body>
		<div>
			<div id="_idContainer012" class="Content">
			</div>
		</div>
		<div id="_idContainer013" class="Content">
			<h1 id="_idParaDest-11"><a id="_idTextAnchor012"/>1. Hello REPL!</h1>
		</div>
		<div id="_idContainer016" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we explain the basics of creating Clojure programs. We start by getting you familiar with the <strong class="bold">Read Eval Print Loop</strong> (<strong class="bold">REPL</strong>), where most of the experimentation happens when writing code. The REPL also allows you to explore code and documentation by yourself, so it is an excellent place to start. After the quick dive in the REPL, we describe in more detail how to read and understand simple Lisp and Clojure code, which syntax can sometimes appear unsettling. We then explore fundamental operators and functions in Clojure, which enable you to write and run simple Clojure programs or scripts.</p>
			<p class="callout">By the end of this chapter, you will be able to use the REPL and work with functions in Clojure.</p>
			<h1 id="_idParaDest-12"><a id="_idTextAnchor013"/>Introduction</h1>
			<p>Have you ever ended up entangled in the "spaghetti code" of an object-oriented application? Many experienced programmers would say yes, and at some point in their journey or career would reconsider the foundation of their programs. They might look for a simpler, better alternative to object-oriented programming, and Clojure is an appealing choice. It is a functional, concise, and elegant language of the Lisp family. Its core is small, and its syntax minimal. It shines because of its simplicity, which takes a trained eye to notice and ultimately understand. Employing Clojure's more sophisticated building blocks will allow you to design and build sturdier applications.</p>
			<p>Whether you are a seasoned programmer or a novice, hobbyist or professional, C# wizard or Haskell ninja, learning a new programming language is challenging. It is, however, a highly rewarding experience that will make you an overall better programmer. In this book, you will learn by doing and will ramp up your skills quickly.</p>
			<p>Clojure is an excellent choice of programming language to learn today. It will allow you to work efficiently using a technology built to last. Clojure can be used to program pretty much anything: from full-blown client-server applications to simple scripts or big data processing jobs. By the end of this book, you will have written a modern web application using Clojure and ClojureScript and will have all the cards in your hand to start writing your own!</p>
			<h1 id="_idParaDest-13"><a id="_idTextAnchor014"/>REPL Basics</h1>
			<p>Welcome to the Clojure <strong class="bold">Read Eval Print Loop</strong> (<strong class="bold">REPL</strong>), a command-line interface that we can use to interact with a running Clojure program. REPL, in the sense that it <strong class="bold">reads</strong> the user's input (where the user is you, the programmer), <strong class="bold">evaluates</strong> the input by instantly compiling and executing the code, and <strong class="bold">prints</strong> (that is, displays) the result to the user. The read-eval-print three-step process repeats over and over again (<strong class="bold">loop</strong>) until you exit the program.</p>
			<p>The dynamism provided by the REPL allows you to discover and experiment with a tight feedback loop: your code is evaluated instantly, and you can adjust it until you get it right. Many other programming languages provide interactive shells (notably, other dynamic languages such as Ruby or Python), but in Clojure, the REPL plays an exceptional and essential role in the life of the developer. It is often integrated with the code editor and the line between editing, browsing, and executing code blurs toward a malleable development environment similar to Smalltalk. But let's start with the basics.</p>
			<p>Throughout these exercises, you may notice some mentions of Java (for example, in the stack trace in the second exercise). This is because Clojure is implemented in Java and runs in the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). Clojure can, therefore, benefit from a mature ecosystem (a battle-tested, widely deployed execution platform and a plethora of libraries) while still being a cutting-edge technology. Clojure is designed to be a hosted language, and another implementation, called ClojureScript, allows you to execute Clojure code on any JavaScript runtime (for example, a web browser or Node.js). This hosted-language implementation choice allows for a smaller community of functional programmers to strive in an industry dominated by Java, .NET Core, and JavaScript technologies. Welcome to the Clojure party, where we're all having our cake and eating it too.</p>
			<h2 id="_idParaDest-14"><a id="_idTextAnchor015"/>Exercise 1.01: Your First Dance</h2>
			<p>In this exercise, we will perform some basic operations in the REPL. Let's get started:</p>
			<ol>
				<li>Open Terminal and type <strong class="source-inline">clj</strong>. This will start a Clojure REPL:<p class="source-code">$ clj</p><p>The output is as follows:</p><p class="source-code">Clojure 1.10.1</p><p class="source-code">user=&gt;</p><p>The first line is your version of Clojure, which in this example is <strong class="source-inline">1.10.1</strong>. Don't worry if your version is different—the exercises we will go through together should be compatible with any version of Clojure.</p><p>The second line displays the namespace we are currently in (<strong class="source-inline">user</strong>) and prompts for your input. A namespace is a group of things (such as functions) that belong together. Everything you create here will be in the <strong class="source-inline">user</strong> namespace by default. The <strong class="source-inline">user</strong> namespace can be considered your playground.</p><p>Your REPL is ready to <strong class="bold">read</strong>.</p></li>
				<li>Let's try to evaluate an expression:<p class="source-code">user=&gt; "Hello REPL!"</p><p>The output is as follows:</p><p class="source-code">"Hello REPL!"</p><p>In Clojure, <em class="italic">literal</em> strings are created with double quotes, <strong class="source-inline">""</strong>. A literal is a notation for representing a fixed value in source code.</p></li>
				<li>Let's see what happens if we type in multiple strings:<p class="source-code">user=&gt; "Hello" "Again"</p><p>The output is as follows:</p><p class="source-code">"Hello"</p><p class="source-code">"Again"</p><p>We have just evaluated two expressions sequentially, and each result is printed onto separate lines.</p></li>
				<li>Now, let's try a bit of arithmetic, for example, <strong class="source-inline">1 + 2</strong>:<p class="source-code">user=&gt; 1 + 2</p><p>The output is as follows:</p><p class="source-code">1</p><p class="source-code">#object[clojure.core$_PLUS_ 0xe8df99a "clojure.core$_PLUS_@e8df99a"]</p><p class="source-code">2</p><p>The output is not exactly what we expected. Clojure evaluated the three components, that is, <strong class="source-inline">1</strong>, <strong class="source-inline">+</strong>, and <strong class="source-inline">2</strong>, <em class="italic">separately</em>. Evaluating <strong class="source-inline">+</strong> looks strange because the <strong class="source-inline">+</strong> symbol is bound to a function.</p><p class="callout-heading">Note</p><p class="callout">A function is a unit of code that performs a specific task. We don't need to know more for now except that functions can be called (or invoked) and can take some parameters. A function's argument is a term that's used to design the value of a parameter, but those terms are often used interchangeably.</p><p>To add those numbers, we need to call the <strong class="source-inline">+</strong> function with the arguments <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong>.</p></li>
				<li>Call the <strong class="source-inline">+</strong> function with the arguments <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong> as follows:<p class="source-code">user=&gt; (+ 1 2)</p><p>The output is as follows:</p><p class="source-code">3</p><p>You will soon discover that many basic operations that are usually part of a programming language syntax, such as addition, multiplication, comparison, and so on, are just simple functions in Clojure.</p></li>
				<li>Let's try a few more examples of basic arithmetic. You can even try to pass more than two arguments to the following functions, so adding 1 + 2 + 3 together would look like <strong class="source-inline">(+ 1 2 3)</strong>:<p class="source-code">user=&gt; (+ 1 2 3)</p><p class="source-code">6</p></li>
				<li>The other basic arithmetic operators are used in a similar way. Try and type the following expressions:<p class="source-code">user=&gt; (- 3 2)</p><p class="source-code">1</p><p class="source-code">user=&gt; (* 3 4 1)</p><p class="source-code">12</p><p class="source-code">user=&gt; (/ 9 3)</p><p class="source-code">3</p><p>After typing in the preceding examples, you should try a few more by yourself – the REPL is here to be experimented with.</p></li>
				<li>You should now be familiar enough with the REPL to ask the following question:<p class="source-code">user=&gt; (println "Would you like to dance?")</p><p class="source-code">Would you like to dance?</p><p class="source-code">nil</p><p>Don't take it personally – <strong class="source-inline">nil</strong> was the value that was returned by the <strong class="source-inline">println</strong> function. The text that was printed by the function was merely a <em class="italic">side effect</em> of this function. </p><p><strong class="source-inline">nil</strong> is the Clojure equivalent of "null," or "nothing"; that is, the absence of meaningful value. <strong class="source-inline">print</strong> (without a new line) and <strong class="source-inline">println</strong> (with a new line) are used to print objects to the standard output, and they return <strong class="source-inline">nil</strong> once they are done.</p></li>
				<li>Now, we can combine those operations and print the result of a simple addition:<p class="source-code">user=&gt; (println (+ 1 2))</p><p class="source-code">3</p><p class="source-code">nil</p><p>A value of <strong class="source-inline">3</strong> was printed and the value of <strong class="source-inline">nil</strong> was returned by this expression.</p><p>Notice how we have nested those <em class="italic">forms</em> (or <em class="italic">expressions</em>). This is how we chain functions in Clojure:</p><p class="source-code">user=&gt; (* 2 (+ 1 2))</p><p class="source-code">6</p></li>
				<li>Exit the REPL by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em>. The function to exit is <strong class="source-inline">System/exit</strong>, which takes the exit code as a parameter. Therefore, you can also type the following:<p class="source-code">user=&gt; (System/exit 0)</p></li>
			</ol>
			<p>In this exercise, we discovered the REPL and called Clojure functions to print and perform basic arithmetic operations.</p>
			<h2 id="_idParaDest-15"><a id="_idTextAnchor016"/>Exercise 1.02: Getting around in the REPL</h2>
			<p>In this exercise, we will introduce a few navigational key bindings and commands to help you use and survive the REPL. Let's get started:</p>
			<ol>
				<li value="1">Start by opening the REPL again.</li>
				<li>Notice how you can navigate the history of what was typed earlier and in previous sessions by pressing <em class="italic">Ctrl</em> + <em class="italic">P</em> (or the <em class="italic">UP</em> arrow) and <em class="italic">Ctrl</em> + <em class="italic">N</em> (or the <em class="italic">DOWN</em> arrow).</li>
				<li>You can also search (case-sensitive) through the history of the commands you have entered: press <em class="italic">Ctrl</em> + <em class="italic">R</em> and then <strong class="source-inline">Hello</strong>, which should bring back the <strong class="source-inline">Hello</strong> <strong class="source-inline">Again</strong> expression we typed earlier. If you press <em class="italic">Ctrl</em> + <em class="italic">R</em> a second time, it will cycle through the matches of the search and bring back the very first command: <strong class="source-inline">Hello REPL!</strong>. If you press <em class="italic">Enter</em>, it will bring the expression back to the current prompt. Press <em class="italic">Enter</em> again and it will evaluate it.</li>
				<li>Now, evaluate the following expression, which <em class="italic">increments</em> (adds 1 to) the number 10:<p class="source-code">user=&gt; (inc 10)</p><p class="source-code">11</p><p>The returned value is 11, which is indeed 10 + 1.</p></li>
				<li><strong class="source-inline">*1</strong> is a special variable that is bound to the result of the last expression that was evaluated in the REPL. You can evaluate its value by simply typing it like this:<p class="source-code">user=&gt; *1</p><p class="source-code">11</p><p>Similarly, <strong class="source-inline">*2</strong> and <strong class="source-inline">*3</strong> are variables bound to the second and third most recent values of that REPL session, respectively.</p></li>
				<li>You can also reuse those special variable values within other expressions. See if you can follow and type this sequence of commands:<p class="source-code">user=&gt; (inc 10)</p><p class="source-code">11</p><p class="source-code">user=&gt; *1</p><p class="source-code">11</p><p class="source-code">user=&gt; (inc *1)</p><p class="source-code">12</p><p class="source-code">user=&gt; (inc *1)</p><p class="source-code">13</p><p class="source-code">user=&gt; (inc *2)</p><p class="source-code">13</p><p class="source-code">user=&gt; (inc *1)</p><p class="source-code">14</p><p>Notice how the values of <strong class="source-inline">*1</strong> and <strong class="source-inline">*2</strong> change as new expressions are evaluated. When the REPL is crowded with text, press <em class="italic">Ctrl</em> + <em class="italic">L</em> to clear the screen. </p></li>
				<li>Another useful variable that's available in the REPL is <strong class="source-inline">*e</strong>, which contains the result of the last exception. At the moment, it should be <strong class="source-inline">nil</strong> unless you generated an error earlier. Let's trigger an exception voluntarily by dividing by zero:<p class="source-code">user=&gt; (/ 1 0)</p><p class="source-code">Execution error (ArithmeticException) at user/eval71 (REPL:1).</p><p class="source-code">Divide by zero</p><p>Evaluating <strong class="source-inline">*e</strong> should contain details about the exception, including the stack trace:</p><p class="source-code">user=&gt; *e</p><p class="source-code">#error {</p><p class="source-code"> :cause "Divide by zero"</p><p class="source-code"> :via</p><p class="source-code"> [{:type java.lang.ArithmeticException</p><p class="source-code">   :message "Divide by zero"</p><p class="source-code">   :at [clojure.lang.Numbers divide "Numbers.java" 188]}]</p><p class="source-code"> :trace</p><p class="source-code"> [[clojure.lang.Numbers divide "Numbers.java" 188]</p><p class="source-code">  [clojure.lang.Numbers divide "Numbers.java" 3901]</p><p class="source-code">  [user$eval1 invokeStatic "NO_SOURCE_FILE" 1]</p><p class="source-code">  [user$eval1 invoke "NO_SOURCE_FILE" 1]</p><p class="source-code">  [clojure.lang.Compiler eval "Compiler.java" 7177]</p><p class="source-code">  [clojure.lang.Compiler eval "Compiler.java" 7132]</p><p class="source-code">  [clojure.core$eval invokeStatic "core.clj" 3214]</p><p class="source-code">  [clojure.core$eval invoke "core.clj" 3210]</p><p class="source-code">  [clojure.main$repl$read_eval_print__9086$fn__9089 invoke "main.clj" 437]</p><p class="source-code">  [clojure.main$repl$read_eval_print__9086 invoke "main.clj" 437]</p><p class="source-code">  [clojure.main$repl$fn__9095 invoke "main.clj" 458]</p><p class="source-code">  [clojure.main$repl invokeStatic "main.clj" 458]</p><p class="source-code">  [clojure.main$repl_opt invokeStatic "main.clj" 522]</p><p class="source-code">  [clojure.main$main invokeStatic "main.clj" 667]</p><p class="source-code">  [clojure.main$main doInvoke "main.clj" 616]</p><p class="source-code">  [clojure.lang.RestFn invoke "RestFn.java" 397]</p><p class="source-code">  [clojure.lang.AFn applyToHelper "AFn.java" 152]</p><p class="source-code">  [clojure.lang.RestFn applyTo "RestFn.java" 132]</p><p class="source-code">  [clojure.lang.Var applyTo "Var.java" 705]</p><p class="source-code">  [clojure.main main "main.java" 40]]}</p><p class="callout-heading">Note</p><p class="callout">Different Clojure implementations may have a slightly different behavior. For example, if you tried to divide by 0 in a ClojureScript REPL, it will not throw an exception and instead return the "infinity value":</p><p class="callout"><strong class="source-inline">cljs.user=&gt; (/ 1 0)</strong></p><p class="callout"><strong class="source-inline">##Inf</strong></p><p class="callout">This is to stay consistent with the host platform: the literal number 0 is implemented as an integer in Java (and Clojure) but as a floating-point number in JavaScript (and ClojureScript). The IEEE Standard for Floating-Point Arithmetic (IEEE 754) specifies that division by 0 should return +/- infinity.</p></li>
				<li>The <strong class="source-inline">doc</strong>, <strong class="source-inline">find-doc</strong>, and <strong class="source-inline">apropos</strong> functions are essential REPL tools for browsing through documentation. Given that you know the name of the function you want to use, you can read its documentation with <strong class="source-inline">doc</strong>. Let's see how it works in practice. Start by typing <strong class="source-inline">(doc str)</strong> to read more about the <strong class="source-inline">str</strong> function:<p class="source-code">user=&gt; (doc str)</p><p class="source-code">-------------------------</p><p class="source-code">clojure.core/str</p><p class="source-code">([] [x] [x &amp; ys])</p><p class="source-code">  With no args, returns the empty string. With one arg x, returns</p><p class="source-code">  x.toString().  (str nil) returns the empty string. With more than</p><p class="source-code">  one arg, returns the concatenation of the str values of the args.</p><p class="source-code">nil</p><p><strong class="source-inline">doc</strong> prints the fully qualified name of the function (including the namespace) on the first line, the possible sets of parameters (or "arities") on the next line, and finally the description.</p><p>This function's fully qualified name is <strong class="source-inline">clojure.core/str</strong>, which means that it is in the <strong class="source-inline">clojure.core</strong> namespace. Things defined in <strong class="source-inline">clojure.core</strong> are available to your current namespace by default, without you explicitly having to require them. This is because they are fundamental components for building your programs, and it would be tedious to have to use their full name every time.</p></li>
				<li>Let's try to use the <strong class="source-inline">str</strong> function. As the documentation explains, we can pass it multiple arguments:<p class="source-code">user=&gt; (str "I" "will" "be" "concatenated") (clojure.core/str "This" " works " "too")</p><p class="source-code">"Iwillbeconcatenated"</p><p class="source-code">"This works too"</p></li>
				<li>Let's inspect the documentation of the <strong class="source-inline">doc</strong> function:<p class="source-code">user=&gt; (doc doc)</p><p class="source-code">-------------------------</p><p class="source-code">clojure.repl/doc</p><p class="source-code">([name])</p><p class="source-code">Macro</p><p class="source-code">  Prints documentation for a var or special form given its name,</p><p class="source-code">   or for a spec if given a keyword</p><p class="source-code">nil</p><p>This function is in the <strong class="source-inline">clojure.repl</strong> namespace, which is also available by default in your REPL environment.</p></li>
				<li>You can also look at the documentation of a namespace. As its documentation suggests, your final program would typically not use the helpers in the <strong class="source-inline">clojure.repl</strong> namespace (for instance, <strong class="source-inline">doc</strong>, <strong class="source-inline">find-doc</strong>, and <strong class="source-inline">apropos</strong>):<p class="source-code">user=&gt; (doc clojure.repl)</p><p class="source-code">-------------------------</p><p class="source-code">clojure.repl</p><p class="source-code">  Utilities meant to be used interactively at the REPL</p><p class="source-code">nil</p></li>
				<li>When you don't know the name of the function, but you have an idea of what the description or name may contain, you can search for it with the <strong class="source-inline">find-doc</strong> helper. Let's try and search for the <strong class="source-inline">modulus</strong> operator:<p class="source-code">user=&gt; (find-doc "modulus")</p><p class="source-code">nil</p></li>
				<li>No luck, but there's a catch: <strong class="source-inline">find-doc</strong> is case-sensitive, but the good news is that we can use a regular expression with the <strong class="source-inline">i</strong> modifier to ignore the case:<p class="source-code">user=&gt; (find-doc #"(?i)modulus")</p><p class="source-code">-------------------------</p><p class="source-code">clojure.core/mod</p><p class="source-code">([num div])</p><p class="source-code">  Modulus of num and div. Truncates toward negative infinity.</p><p class="source-code">nil</p><p>You don't need to know more about regular expressions for now – you don't even have to use them, but it can be useful to ignore the case when searching for a function. You can write them with the <strong class="source-inline">#"(?i)text"</strong> syntax, where <strong class="source-inline">text</strong> is anything you want to search for.</p><p>The function we were looking for was <strong class="source-inline">clojure.core/mod</strong>.</p></li>
				<li>Let's make sure it works according to its documentation:<p class="source-code">user=&gt; (mod 7 3)</p><p class="source-code">1</p></li>
				<li>Use the <strong class="source-inline">apropos</strong> function to search for functions by name, thereby yielding a more succinct output. Say we were looking for a function that transforms the case of a given string of characters:<p class="source-code">user=&gt; (apropos "case")</p><p class="source-code">(clojure.core/case clojure.string/lower-case clojure.string/upper-case) </p><p class="source-code">user=&gt; (clojure.string/upper-case "Shout, shout, let it all out")</p><p class="source-code">"SHOUT, SHOUT, LET IT ALL OUT"</p><p>Please note that this function is in the <strong class="source-inline">clojure.string</strong> namespace, which is not referred to by default. You will need to use its full name until we learn how to import and refer symbols from other namespaces.</p></li>
			</ol>
			<h2 id="_idParaDest-16"><a id="_idTextAnchor017"/>Activity 1.01: Performing Basic Operations</h2>
			<p>In this activity, we will print messages and perform some basic arithmetic operations in the Clojure REPL.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Open the REPL.</li>
				<li>Print the message "<strong class="source-inline">I am not afraid of parentheses</strong>" to motivate yourself.</li>
				<li>Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to the following <strong class="source-inline">infix</strong> notation: (1 + 2 + 3) * (10 - 3). You should obtain the following result:<p class="source-code">42</p></li>
				<li>Print the message "<strong class="source-inline">Well done</strong>!" to congratulate yourself.</li>
				<li>Exit the REPL.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 678.</p></li>
			</ol>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>Evaluation of Clojure Code</h1>
			<p>Clojure is a dialect of Lisp, a high-level programming language that was designed by John McCarthy and first appeared in 1958. One of the most distinctive features of Lisp and its derivatives, or "dialects," is the use of data structures to write the source code of programs. The unusual number of parentheses in our Clojure programs is a manifestation of this as parentheses are used to create lists.</p>
			<p>Here, we will focus on the building blocks of Clojure programs, that is, <em class="italic">forms and expressions, </em>and briefly look at how expressions are evaluated.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The terms "expression" and "form" are often used interchangeably; however, according to the Clojure documentation, an expression is a form type: <em class="italic">"Every form not handled specially by a special form or macro is considered by the compiler to be an expression, which is evaluated to yield a value."</em></p>
			<p>We have seen how literals are valid syntax and evaluate to themselves, for example:</p>
			<p class="source-code">user=&gt; "Hello"</p>
			<p class="source-code">"Hello"</p>
			<p class="source-code">user=&gt; 1 2 3</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">3</p>
			<p>We have also learned how to invoke functions by using parentheses:</p>
			<p class="source-code">user=&gt; (+ 1 2 3)</p>
			<p class="source-code">6</p>
			<p>It is worth noting at this point that comments can be written with "<strong class="source-inline">;</strong>" at the beginning of a line. Any line starting with "<strong class="source-inline">;</strong>" will not be evaluated:</p>
			<p class="source-code">user=&gt; ; This is a comment</p>
			<p class="source-code">user=&gt; ; This line is not evaluated</p>
			<p>Functions are invoked according to the following structure:</p>
			<p class="source-code">; (operator operand-1 operand-2 operand-3 …)</p>
			<p class="source-code">; for example:</p>
			<p class="source-code">user=&gt; (* 2 3 4)</p>
			<p class="source-code">24</p>
			<p>Take note of the following from the preceding example:</p>
			<ul>
				<li>The list, denoted by opening and closing parenthesis, <strong class="source-inline">()</strong>, is evaluated to a function call (or invocation).</li>
				<li>When evaluated, the <strong class="source-inline">*</strong> symbol resolves to the function that implements the multiplication.</li>
				<li><strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and <strong class="source-inline">4</strong> are evaluated to themselves and passed as arguments to the function.</li>
			</ul>
			<p>Consider the expression you wrote in <em class="italic">Activity 1.01</em>, <em class="italic">Performing Basic Operations</em>: <strong class="source-inline">(* (+ 1 2 3) (- 10 3))</strong>. It can also help to visualize the expression as a tree:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B14502_01_01.jpg" alt="Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))</p>
			<p>Evaluating this expression consists of reducing the tree, starting with the offshoots (the innermost lists): <strong class="source-inline">(* (+ 1 2 3) (- 10 3))</strong> becomes <strong class="source-inline">(* 6 7)</strong>, which becomes <strong class="source-inline">42</strong>. </p>
			<p>The term <strong class="bold">s-expression</strong> (or symbolic expression) is often used to designate those types of expressions. You may come across it again, so it is good to know that an s-expression is a data notation for writing data structures and code with lists, as we demonstrated previously.</p>
			<p>So far, we have only used literal scalar types as operands to our operators, which hold one value, such as numbers, strings, Booleans, and so on. We've only used lists to invoke functions and not to represent data. Let's try to create a list that represents data but not "code":</p>
			<p class="source-code">user=&gt; (1 2 3)</p>
			<p class="source-code">Execution error (ClassCastException) at user/eval255 (REPL:1).</p>
			<p class="source-code">java.lang.Long cannot be cast to clojure.lang.IFn</p>
			<p>An exception was thrown because the first item of the list (the operator) was not a function.</p>
			<p>There is a special syntax to prevent the list from being considered as the invocation of a function: the quote. Creating a literal list is done by adding a quotation <strong class="source-inline">'</strong>, in front of it, so let's try again:</p>
			<p class="source-code">user=&gt; '(1 2 3)</p>
			<p class="source-code">(1 2 3)</p>
			<p class="source-code">user=&gt; '("a" "b" "c" "d")</p>
			<p class="source-code">("a" "b" "c" "d")</p>
			<p>Great! By preventing the evaluation of the form, we can now write a literal representation of lists. </p>
			<p>This concept will help us get ready for what we are going to cover next. It is, however, fascinating to notice at this point that Clojure code is made up of data structures, and our programs can generate those same data structures. "Code is data" is a famous saying in the Lisp world, and a powerful concept that allows your program to generate code (known as <strong class="bold">meta-programming</strong>). If you are new to this concept, it is worth pausing for a minute to think and admire the sheer beauty of it. We will explain meta-programming techniques in detail later when explaining <em class="italic">macros</em> in <em class="italic">Chapter 11</em>, <em class="italic">Macros</em>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Basic Special Forms</h1>
			<p>So far, we have been writing code that complies with the simplest rules of evaluating Clojure code, but there are some behaviors that cannot simply be encoded with normal functions. For example, arguments that have been passed to a function will always be resolved or evaluated, but what if we do not want to evaluate all the operands of an operator? That is when special forms come into play. They can have different evaluation rules for functions when the source code is read by Clojure. For example, the special form <strong class="source-inline">if</strong>, may not evaluate one of its arguments, depending on the result of the first argument.</p>
			<p>There are a few other special forms that we will go through in this section:</p>
			<ul>
				<li><strong class="source-inline">when</strong>, which can be used when we are only interested in the case of a condition being <em class="italic">truthy</em> (a value is <em class="italic">truthy</em> when considered true in the context of a Boolean expression).</li>
				<li><strong class="source-inline">do</strong>, which can be used to execute a series of expressions and return the value of the last expression.</li>
				<li><strong class="source-inline">def</strong> and <strong class="source-inline">let</strong>, which are special forms that are used to create global and local bindings.</li>
				<li><strong class="source-inline">fn</strong> and <strong class="source-inline">defn</strong>, which are special forms that are used to create functions.</li>
			</ul>
			<p>All these special forms have special evaluation rules, all of which we will discover by working through the following three exercises.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>Exercise 1.03: Working with if, do, and when</h2>
			<p>In this exercise, we will evaluate expressions using the <strong class="source-inline">if</strong>, <strong class="source-inline">do</strong>, and <strong class="source-inline">when</strong> forms. Let's get started:</p>
			<ol>
				<li value="1">Start your REPL and type in the following expression:<p class="source-code">user=&gt; (if true "Yes" "No")</p><p class="source-code">"Yes"</p></li>
				<li>The special form <strong class="source-inline">if</strong>, evaluates its first argument. If its value is truthful, it will evaluate argument <strong class="source-inline">2</strong>, otherwise (<strong class="source-inline">else</strong>), it will evaluate argument 3. It will never evaluate both arguments 2 and 3.</li>
				<li>We can nest expressions and start doing more interesting things:<p class="source-code">user=&gt; (if false (+ 3 4) (rand))</p><p class="source-code">0.4833142431072903</p><p>In this case, the computation of <strong class="source-inline">(+ 3 4)</strong> will not be executed, and only a random number (between 0 and 1) will be returned by the <strong class="source-inline">rand</strong> function.</p></li>
				<li>But what if we wanted to do more than one thing in our branch of the condition? We could wrap our operation with <strong class="source-inline">do</strong>. Let's see how <strong class="source-inline">do</strong> works:<p class="source-code">user=&gt; (doc do)</p><p class="source-code">-------------------------</p><p class="source-code">do</p><p class="source-code">  (do exprs*)</p><p class="source-code">Special Form</p><p class="source-code">  Evaluates the expressions in order and returns the value of</p><p class="source-code">  the last. If no expressions are supplied, returns nil.</p><p class="source-code">  Please see http://clojure.org/special_forms#do</p><p class="source-code">  Evaluates the expressions in order and returns the value of</p><p class="source-code">  the last. If no expressions are supplied, returns nil.</p><p class="source-code">nil</p></li>
				<li>To use the special form, <strong class="source-inline">do</strong> type the following expression:<p class="source-code">user=&gt; (do (* 3 4) (/ 8 4) (+ 1 1))</p><p class="source-code">2</p><p>All the expressions before the final <strong class="source-inline">(+ 1 1)</strong> expression were evaluated, but only the value of the last one is returned. This does not look very useful with expressions that don't alter the state of the world, and so it would typically be used for side effects such as logging or any other kind of I/O (filesystem access, database query, network request, and so on).</p><p>You don't have to take my word for it, so let's experiment with the side effect of printing to the Terminal:</p><p class="source-code">user=&gt; (do (println "A proof that this is executed") (println "And this   too"))</p><p class="source-code">A proof that this is executed</p><p class="source-code">And this too</p><p class="source-code">nil</p></li>
				<li>Finally, we can combine the use of <strong class="source-inline">if</strong> and <strong class="source-inline">do</strong> to execute multiple operations in a conditional branching:<p class="source-code">user=&gt; (if true (do (println "Calculating a random number...") (rand)) (+ 1   2))</p><p class="source-code">Calculating a random number...</p><p class="source-code">0.8340057877906916</p></li>
				<li>Technically, you could also omit the third argument. Bring back the previous expression in the REPL and remove the last expression, that is, <strong class="source-inline">(+ 1 2)</strong>:<p class="source-code">user=&gt; (if true (do (println "Calculating a random number...") (rand)))</p><p class="source-code">Calculating a random number...</p><p class="source-code">0.5451384920081613</p><p class="source-code">user=&gt; (if false (println "Not going to happen"))</p><p class="source-code">nil</p><p>We have a better construct available for this case: the <strong class="source-inline">when</strong> operator. Instead of combining <strong class="source-inline">if</strong> and <strong class="source-inline">do</strong>, when you are only interested in doing work in one branch of the conditional execution, use <strong class="source-inline">when</strong>.</p></li>
				<li>Type the following expression to use <strong class="source-inline">when</strong> instead of a combination of <strong class="source-inline">if</strong> and <strong class="source-inline">do</strong>:<p class="source-code">user=&gt; (when true (println "First argument") (println "Second argument")   "And the last is returned")</p><p class="source-code">First argument</p><p class="source-code">Second argument</p><p class="source-code">"And the last is returned"</p></li>
			</ol>
			<p>By completing this exercise, we have demonstrated the usage of the special forms known as <strong class="source-inline">if</strong>, <strong class="source-inline">do</strong>, and <strong class="source-inline">when</strong>. We can now write expressions that contain multiple statements, as well as conditional expressions.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Bindings</h2>
			<p>In Clojure, we use the term <em class="italic">bindings</em> rather than <em class="italic">variables</em> and <em class="italic">assignments</em> because we tend to bind a value to a symbol only once. Under the hood, Clojure creates <em class="italic">variables</em> and so you may encounter this term, but it would be preferable if you don't think of them as classic <em class="italic">variables </em>or values that can change. We won't use the term variable anymore in this chapter as it can be confusing. You can use <strong class="source-inline">d<a id="_idTextAnchor022"/>ef</strong> to define global bindings and <strong class="source-inline">let</strong> for local bindings.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor023"/>Exercise 1.04: Using def and let</h2>
			<p>In this exercise, we will demonstrate the usage of the <strong class="source-inline">def</strong> and <strong class="source-inline">let</strong> keywords, which are used to create bindings. Let's get started:</p>
			<ol>
				<li value="1">The special form <strong class="source-inline">def</strong> allows you to bind a value to a symbol. In the REPL, type the following expression to bind the value <strong class="source-inline">10</strong> to the <strong class="source-inline">x</strong> symbol:<p class="source-code">user=&gt; (def x 10)</p><p class="source-code">#'user/x</p><p class="callout-heading">Note</p><p class="callout">When the REPL returns <strong class="source-inline">#'user/x</strong>, it is returning a reference to the var you have just created. The user part indicates the namespace where the var is defined. The <strong class="source-inline">#'</strong> prefix is a way of quoting the var so that we see the symbol and not the value of the symbol.</p></li>
				<li>Evaluate the expression, <strong class="source-inline">x</strong>, which will resolve the <strong class="source-inline">x</strong> symbol to its value:<p class="source-code">user=&gt; x</p><p class="source-code">10</p></li>
				<li>Technically, you can change the binding, which is fine when experimenting in the REPL:<p class="source-code">user=&gt; (def x 20)</p><p class="source-code">#'user/x</p><p class="source-code">user=&gt; x</p><p class="source-code">20</p><p>It is, however, not recommended in your programs because it can make it hard to read and complicate its maintenance. For now, it would be better if you just consider such a binding as a <em class="italic">constant.</em></p></li>
				<li>You can use the <strong class="source-inline">x</strong> symbol within another expression:<p class="source-code">user=&gt; (inc x)</p><p class="source-code">21</p><p class="source-code">user=&gt; x</p><p class="source-code">20</p></li>
				<li>Wherever <strong class="source-inline">def</strong> is invoked, it will bind the value to the symbol in the current namespace. We could try to define a local binding in a <strong class="source-inline">do</strong> block and see what happens: <p class="source-code">user=&gt; x</p><p class="source-code">20</p><p class="source-code">user=&gt; (do (def x 42))</p><p class="source-code">#'user/x</p><p class="source-code">user=&gt; x</p><p class="source-code">42</p><p>The bindings that are created by <strong class="source-inline">def</strong> have an indefinite scope (or dynamic scope) and can be considered as "global." They are automatically namespaced, which is a useful trait to avoid clashing with existing names. </p></li>
				<li>If we want to have a binding available only to a local scope or lexical scope, we can use the special form <strong class="source-inline">let</strong>. Type the following expression to create a lexical binding of the <strong class="source-inline">y</strong> symbol:<p class="source-code">user=&gt; (let [y 3] (println y) (* 10 y))</p><p class="source-code">3</p><p class="source-code">30</p><p><strong class="source-inline">let</strong> takes a "vector" as a parameter to create the local bindings, and then a series of expressions that will be evaluated like they are in a <strong class="source-inline">do</strong> block.</p><p class="callout-heading">Note</p><p class="callout">A vector is similar to a list, in the sense that they both are a sequential collection of values. Their underlying data structure is different, and we will shed light on this in <em class="italic">Chapter 2</em>, <em class="italic">Data Types and Immutability</em>. For now, you just need to know that vectors can be created with square brackets, for example, <strong class="source-inline">[1 2 3 4]</strong>.</p></li>
				<li>Evaluate the <strong class="source-inline">y</strong> symbol:<p class="source-code">user=&gt; y</p><p class="source-code">Syntax error compiling at (REPL:0:0).</p><p class="source-code">Unable to resolve symbol: y in this context</p><p>An error is thrown, that is, <strong class="source-inline">Unable to resolve symbol: y in this context</strong>, because we are now outside of the <strong class="source-inline">let</strong> block.</p></li>
				<li>Type the following expression to create a lexical binding of <strong class="source-inline">x</strong> to the value <strong class="source-inline">3</strong>, and see how it affects the indefinite (global) binding of <strong class="source-inline">x</strong> that we created in <em class="italic">step 4</em>:<p class="source-code">user=&gt; (let [x 3] (println x))</p><p class="source-code">3</p><p class="source-code">nil</p><p class="source-code">user=&gt; x</p><p class="source-code">42</p><p>Printing <strong class="source-inline">x</strong> yields the value <strong class="source-inline">3</strong>, which means that the "global" <strong class="source-inline">x</strong> symbol was temporarily overridden or "shadowed" by the lexical context in which <strong class="source-inline">println</strong> was invoked.</p></li>
				<li>You can create multiple local bindings at once with <strong class="source-inline">let</strong> by passing an even number of items in the vector. Type the following expression to bind <strong class="source-inline">x</strong> to <strong class="source-inline">10</strong> and <strong class="source-inline">y</strong> to <strong class="source-inline">20</strong>:<p class="source-code">user=&gt; (let [x 10 y 20]  (str "x is " x " and y is " y))</p><p class="source-code">"x is 10 and y is 20"</p></li>
				<li>Combine the concepts of this section and write the following expressions:<p class="source-code">user=&gt; (def message "Let's add them all!")</p><p class="source-code">#'user/message</p><p class="source-code">user=&gt; (let [x (* 10 3)</p><p class="source-code">             y 20</p><p class="source-code">             z 100]</p><p class="source-code">              (println message)</p><p class="source-code">              (+ x y z))</p><p class="source-code">Let's add them all!</p><p class="source-code">150</p></li>
			</ol>
			<p>The expression spans over multiple lines to improve readability.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Exercise 1.05: Creating Simple Functions with fn and defn</h2>
			<p>The special form that's used to define functions is <strong class="source-inline">fn</strong>. Let's jump right into it by creating our first function:</p>
			<ol>
				<li value="1">Type the following expression in your REPL:<p class="source-code">user=&gt; (fn [])</p><p class="source-code">#object[user$eval196$fn__197 0x3f0846c6 "user$eval196$fn__197@3f0846c6"]</p><p>We have just created the simplest anonymous function, which takes no parameters and does nothing, and we returned an object, which is our function with no name.</p></li>
				<li>Create a function that takes a parameter named <strong class="source-inline">x</strong> and return its square value (multiply it by itself):<p class="source-code">user=&gt; (fn [x] (* x x))</p><p class="source-code">#object[user$eval227$fn__228 0x68b6f0d6 "user$eval227$fn__228@68b6f0d6"]</p></li>
				<li>Remember that, in Clojure, the first item of an expression will be invoked, so we can call our anonymous function by wrapping it with parentheses and providing an argument as the second item of the expression:<p class="source-code">user=&gt; ((fn [x] (* x x)) 2)</p><p class="source-code">4</p><p>Now this is great, but not very convenient. If we wanted our function to be reusable or testable, it would be better for it to have a name. We can create a symbol in the namespace and bind it to the function.</p></li>
				<li>Use <strong class="source-inline">def</strong> to bind the function returned by the special form, <strong class="source-inline">fn</strong>, to the <strong class="source-inline">square</strong> symbol:<p class="source-code">user=&gt; (def square (fn [x] (* x x)))</p><p class="source-code">#'user/square</p></li>
				<li>Invoke your newly created function to make sure that it works:<p class="source-code">user=&gt; (square 2)</p><p class="source-code">4</p><p class="source-code">user=&gt; (square *1)</p><p class="source-code">16</p><p class="source-code">user=&gt; (square *1)</p><p class="source-code">256</p></li>
				<li>This pattern of combining <strong class="source-inline">def</strong> and <strong class="source-inline">fn</strong> is so common that a built-in <em class="italic">macro</em> was born out of necessity: <strong class="source-inline">defn</strong>. Recreate the square function with <strong class="source-inline">defn</strong> instead of <strong class="source-inline">def</strong> and <strong class="source-inline">fn</strong>:<p class="source-code">user=&gt; (defn square [x] (* x x))</p><p class="source-code">#'user/square</p><p class="source-code">user=&gt; (square 10)</p><p class="source-code">100</p><p>Did you notice that the <strong class="source-inline">x</strong> argument was passed in a vector? We have already learned that vectors are collections, and so we can add more than one symbol to the argument's vector. The values that are passed when calling the function will be bound to the symbols provided in the vector during the function's definition.</p></li>
				<li>Functions can take multiple arguments, and their bodies can be composed of multiple expressions (such as an implicit <strong class="source-inline">do</strong> block). Create a function with the name <strong class="source-inline">meditate</strong> that takes two arguments: a string, <strong class="source-inline">s</strong>, and a Boolean, <strong class="source-inline">calm</strong>. The function will print an introductory message and return a transformation of <strong class="source-inline">s</strong> based on <strong class="source-inline">calm</strong>:<p class="source-code">user=&gt;</p><p class="source-code">(defn meditate [s calm]</p><p class="source-code">  (println "Clojure Meditate v1.0")</p><p class="source-code">  (if calm</p><p class="source-code">    (clojure.string/capitalize s)</p><p class="source-code">    (str (clojure.string/upper-case s) "!")))</p><p class="callout-heading">Note</p><p class="callout">Editing multiline expressions in the REPL can be cumbersome. As we start creating lengthier functions and expressions that span multiple lines, it would be preferable to have a window of your favorite editor open next to your REPL window. Keep those windows side by side, edit the code in your editor, copy it to your clipboard, and paste it into your REPL.</p><p>The function body contains two main expressions, the first of which is a side effect with <strong class="source-inline">println</strong> and the second of which is the <strong class="source-inline">if</strong> block, which will determine the return value. If <strong class="source-inline">calm</strong> is <strong class="source-inline">true</strong>, it will politely return the string capitalized (with the first character converted into uppercase), otherwise it will shout and return the string with all its characters to uppercase, ending with an exclamation mark.</p></li>
				<li>Let's try and make sure that our function works as intended:<p class="source-code">user=&gt; (meditate "in calmness lies true pleasure" true)</p><p class="source-code">Clojure Meditate v1.0</p><p class="source-code">"In calmness lies true pleasure"</p><p class="source-code">user=&gt; (meditate "in calmness lies true pleasure" false)</p><p class="source-code">Clojure Meditate v1.0</p><p class="source-code">"IN CALMNESS LIES TRUE PLEASURE!"</p></li>
				<li>If we call the function with only the first parameter, it will throw an exception. This is because the parameters that we have defined are required:<p class="source-code">user=&gt; (meditate "in calmness lies true pleasure")</p><p class="source-code">Execution error (ArityException) at user/eval365 (REPL:1).</p><p class="source-code">Wrong number of args (1) passed to: user/meditate</p><p>One last thing to end our initial tour of these functions is the <strong class="source-inline">doc-string</strong> parameter. When provided to <strong class="source-inline">defn</strong>, it will allow you to add a description of your function.</p></li>
				<li>Add documentation to your <strong class="source-inline">square</strong> function by adding a doc-string just before the function arguments:<p class="source-code">user=&gt;</p><p class="source-code">(defn square</p><p class="source-code">  "Returns the product of the number `x` with itself"</p><p class="source-code">  [x]</p><p class="source-code">  (* x x))</p><p class="source-code">#'user/square</p><p>The doc-string is not only useful when browsing a project's source code – it also makes it available to the <strong class="source-inline">doc</strong> function.</p></li>
				<li>Look up the documentation of your <strong class="source-inline">square</strong> function with <strong class="source-inline">doc</strong>:<p class="source-code">user=&gt; (doc square)</p><p class="source-code">-------------------------</p><p class="source-code">user/square</p><p class="source-code">([x])</p><p class="source-code">  Returns the product of the number `x` with itself</p><p class="source-code">nil</p><p>It is important to remember that the doc-string needs to come before the function arguments. If it comes after, the string will be evaluated sequentially as part of the function body and won't throw an error. It is valid syntax, but it will not be available in the <strong class="source-inline">doc</strong> helper and other development tools.</p><p>It is good practice to document the arguments with backticks, <strong class="source-inline">`</strong>, like we did with <strong class="source-inline">`x`</strong>, so that development tools (such as the IDE) can recognize them.</p></li>
			</ol>
			<p>We will take a deeper dive into functions in <em class="italic">Chapter 3</em>, <em class="italic">Functions in Depth</em>, but these few basic principles will get you a long way in terms of writing functions.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/>Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level</h2>
			<p>Carbon dioxide (CO2) is an important heat-trapping (greenhouse) gas, currently rising and threatening life as we know it on our planet. We would like to predict future levels of CO2 in the atmosphere based on historical data provided by <strong class="bold">National Oceanic and Atmospheric Administration</strong> (<strong class="bold">NOAA</strong>):</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B14502_01_02.jpg" alt="Figure 1.2: CO2 parts per million (ppm) over the years&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: CO2 parts per million (ppm) over the years</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding chart was taken from <a href="https://packt.live/35kUI7L">https://packt.live/35kUI7L</a> and the data was taken from NOAA.</p>
			<p>We will use the year 2006 as a starting point with a CO2 level of 382 ppm and calculate the estimate using a simplified (and optimistic) linear function, as follows: <em class="italic">Estimate = 382 + ((Year - 2006) * 2)</em>.</p>
			<p>Create a function called <strong class="source-inline">co2-estimate</strong> that takes one integer parameter called <strong class="source-inline">year</strong> and returns the estimated level of CO2 ppm for that year.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Open your favorite editor and a REPL window next to it.</li>
				<li>In your editor, define two constants, <strong class="source-inline">base-co2</strong> and <strong class="source-inline">base-year</strong>, with the values 382 and 2006, respectively.</li>
				<li>In your editor, write the code to define the <strong class="source-inline">co2-estimate</strong> function without forgetting to document it with the doc-string parameter.</li>
				<li>You may be tempted to write the function body in a single line but nesting a lot of function calls decreases the readability of the code. It is also easier to reason about each step of the process by decomposing them in a <strong class="source-inline">let</strong> block. Write the body of the function using <strong class="source-inline">let</strong> to define the local binding <strong class="source-inline">year-diff</strong>, which is the subtraction of 2006 from the <strong class="source-inline">year</strong> parameter.</li>
				<li>Test your function by evaluating <strong class="source-inline">(co2-estimate 2050)</strong>. You should get <strong class="source-inline">470</strong> as the result.</li>
				<li>Look up the documentation of your function with <strong class="source-inline">doc</strong> and make sure that it has been defined correctly.</li>
			</ol>
			<p>The following is the expected output:</p>
			<p class="source-code">user=&gt; (doc co2-estimate)</p>
			<p class="source-code">user/co2-estimate</p>
			<p class="source-code">([year])</p>
			<p class="source-code">  Returns a (conservative) year's estimate of carbon dioxide parts per million in     the atmosphere</p>
			<p class="source-code">nil</p>
			<p class="source-code">user=&gt; (co2-estimate 2006)</p>
			<p class="source-code">382</p>
			<p class="source-code">user=&gt; (co2-estimate 2020)</p>
			<p class="source-code">410</p>
			<p class="source-code">user=&gt; (co2-estimate 2050)</p>
			<p class="source-code">470</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 679.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor026"/>Truthiness, nil, and equality</h1>
			<p>Up until now, we have been using conditional expressions intuitively, possibly on the basis of how they usually work with other programming languages. In this final section, we will review and explain Boolean expressions and the related comparison functions in detail, starting with <strong class="source-inline">nil</strong> and truthiness in Clojure.</p>
			<p><strong class="source-inline">nil</strong> is a value that represents the absence of value. It is also often called <strong class="source-inline">NULL</strong> in other programming languages. Representing the absence of value is useful because it means that something is missing.</p>
			<p>In Clojure, <strong class="source-inline">nil</strong> is "falsey," which means that <strong class="source-inline">nil</strong> behaves like <strong class="source-inline">false</strong> when evaluated in a Boolean expression.</p>
			<p><strong class="source-inline">false</strong> and <strong class="source-inline">nil</strong> are the only values that are treated as <em class="italic">falsey</em> in Clojure; everything else is truthy. This simple rule is a blessing (especially if you are coming from a language such as JavaScript) and makes our code more readable and less error-prone. Perhaps it's just that Clojure was not out yet when Oscar Wilde wrote, "The truth is rarely pure and never simple."</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/>Exercise 1.06: The Truth Is Simple</h2>
			<p>In this exercise, we will demonstrate how to work with Boolean values in conditional expressions. We will also see how to play around with the logical operators in conditional expressions. Let's get started:</p>
			<ol>
				<li value="1">Let's start by verifying that <strong class="source-inline">nil</strong> and <strong class="source-inline">false</strong> are indeed <strong class="source-inline">falsey</strong>:<p class="source-code">user=&gt; (if nil "Truthy" "Falsey")</p><p class="source-code">"Falsey"</p><p class="source-code">user=&gt; (if false "Truthy" "Falsey")</p><p class="source-code">"Falsey"</p></li>
				<li>In other programming languages, it is common for more values to resolve to <strong class="source-inline">false</strong> in Boolean expressions. But in Clojure, remember that only <strong class="source-inline">nil</strong> and <strong class="source-inline">false</strong> are <em class="italic">falsey</em>. Let's try a few examples:<p class="source-code">user=&gt; (if 0 "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p><p class="source-code">user=&gt; (if -1 "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p><p class="source-code">user=&gt; (if '() "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p><p class="source-code">user=&gt; (if [] "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p><p class="source-code">user=&gt; (if "false" "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p><p class="source-code">user=&gt; (if "" "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p><p class="source-code">user=&gt; (if "The truth might not be pure but is simple" "Truthy" "Falsey")</p><p class="source-code">"Truthy"</p></li>
				<li>If we want to know whether something is exactly <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, and not just <strong class="source-inline">truthy</strong> or <strong class="source-inline">falsey</strong>, we can use the <strong class="source-inline">true?</strong> and <strong class="source-inline">false?</strong> functions:<p class="source-code">user=&gt; (true? 1)</p><p class="source-code">false</p><p class="source-code">user=&gt; (if (true? 1) "Yes" "No")</p><p class="source-code">"No"</p><p class="source-code">user=&gt; (true? "true")</p><p class="source-code">false</p><p class="source-code">user=&gt; (true? true)</p><p class="source-code">true</p><p class="source-code">user=&gt; (false? nil)</p><p class="source-code">false</p><p class="source-code">user=&gt; (false? false)</p><p class="source-code">true</p><p>The <strong class="source-inline">?</strong> character has no special behavior – it is just a naming convention for functions that return a Boolean value.</p></li>
				<li>Similarly, if we want to know that something is <strong class="source-inline">nil</strong> and not just <strong class="source-inline">falsey</strong>, we can use the <strong class="source-inline">nil?</strong> function:<p class="source-code">user=&gt; (nil? false)</p><p class="source-code">false</p><p class="source-code">user=&gt; (nil? nil)</p><p class="source-code">true</p><p class="source-code">user=&gt; (nil? (println "Hello"))</p><p class="source-code">Hello</p><p class="source-code">true</p><p>Remember that <strong class="source-inline">println</strong> returns <strong class="source-inline">nil</strong>, and so the last piece of output in the preceding code is <strong class="source-inline">true</strong>.</p><p>Boolean expressions become interesting when they are composed together. Clojure provides the usual suspects, that is, <strong class="source-inline">and</strong> and <strong class="source-inline">or</strong>. At this point, we are only interested in <em class="italic">logical</em> <strong class="source-inline">and</strong> and <em class="italic">logical</em> <strong class="source-inline">or</strong>. If you are looking to play around with <strong class="source-inline">bitwise</strong> operators, you can easily find them with the <strong class="source-inline">(find-doc "bit-")</strong> command.</p><p><strong class="source-inline">and</strong> returns the first <em class="italic">falsey</em> value that it encounters (from left to right) and will not evaluate the rest of the expression when that is the case. When all the values passed to <strong class="source-inline">and</strong> are <em class="italic">truthy</em>, <strong class="source-inline">and</strong> will return the last value.</p></li>
				<li>Experiment with the <strong class="source-inline">and</strong> function by passing a mix of <em class="italic">truthy</em> and <em class="italic">falsey</em> values to observe the return value that's been generated:<p class="source-code">user=&gt; (and "Hello")</p><p class="source-code">"Hello"</p><p class="source-code">user=&gt; (and "Hello" "Then" "Goodbye")</p><p class="source-code">"Goodbye"</p><p class="source-code">user=&gt; (and false "Hello" "Goodbye")</p><p class="source-code">false</p></li>
				<li>Let's use <strong class="source-inline">println</strong> and make sure that not all the expressions are evaluated:<p class="source-code">user=&gt; (and (println "Hello") (println "Goodbye"))</p><p class="source-code">Hello</p><p class="source-code">nil</p><p><strong class="source-inline">and</strong> evaluated the first expression, which printed <strong class="source-inline">Hello</strong> and returned <strong class="source-inline">nil</strong>, which is <em class="italic">falsey</em>. Therefore, the second expression was not evaluated, and <strong class="source-inline">Goodbye</strong> was not printed.</p><p><strong class="source-inline">or</strong> works in a similar fashion: it will return the first <em class="italic">truthy</em> value that it comes across and it will not evaluate the rest of the expression when that is the case. When all the values that are passed to <strong class="source-inline">or</strong> are <em class="italic">falsey</em>, <strong class="source-inline">or</strong> will return the last value.</p></li>
				<li>Experiment with the <strong class="source-inline">or</strong> function by passing a mix of <em class="italic">truthy</em> and <em class="italic">falsey</em> values to observe the return value that's generated:<p class="source-code">user=&gt; (or "Hello")</p><p class="source-code">"Hello"</p><p class="source-code">user=&gt; (or "Hello" "Then" "Goodbye")</p><p class="source-code">"Hello"</p><p class="source-code">user=&gt; (or false "Then" "Goodbye")</p><p class="source-code">"Then"</p></li>
				<li>Once again, we can use <strong class="source-inline">println</strong> to make sure that the expressions are not all evaluated:<p class="source-code">user=&gt; (or true (println "Hello"))</p><p class="source-code">true</p><p><strong class="source-inline">or</strong> evaluated the first expression <strong class="source-inline">true</strong> and returned it. Therefore, the second expression was not evaluated, and <strong class="source-inline">Hello</strong> was not printed.</p></li>
			</ol>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor028"/>Equality and Comparisons</h2>
			<p>In most imperative programming languages, the <strong class="source-inline">=</strong> symbol is used for variable assignments. As we've seen already, in Clojure, we have <strong class="source-inline">def</strong> and <strong class="source-inline">let</strong> to bind names with values. The <strong class="source-inline">=</strong> symbol is a function for equality and will return <strong class="source-inline">true</strong> if all its arguments are equal. As you may have guessed by now, the other common comparison functions are implemented as functions. <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&gt;=</strong>, <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&lt;=</strong>, and <strong class="source-inline">=</strong> are not special syntax and you may have developed the intuition for using them already.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor029"/>Exercise 1.07: Comparing Values</h2>
			<p>In this final exercise, we will go through the different ways of comparing values in Clojure. Let's get started:</p>
			<ol>
				<li value="1">First, start your REPL if it is not running yet.</li>
				<li>Type the following expressions to compare two numbers:<p class="source-code">user=&gt; (= 1 1)</p><p class="source-code">true</p><p class="source-code">user=&gt; (= 1 2)</p><p class="source-code">false</p></li>
				<li>You can pass multiple arguments to the <strong class="source-inline">=</strong> operator:<p class="source-code">user=&gt; (= 1 1 1)</p><p class="source-code">true</p><p class="source-code">user=&gt; (= 1 1 1 -1)</p><p class="source-code">false</p><p>In that case, even though the first three arguments are equal, the last one isn't, so the <strong class="source-inline">=</strong> function returns <strong class="source-inline">false</strong>.</p></li>
				<li>The <strong class="source-inline">=</strong> operator is not only used to compare numbers, but other types as well. Evaluate some of the following expressions:<p class="source-code">user=&gt; (= nil nil)</p><p class="source-code">true</p><p class="source-code">user=&gt; (= false nil)</p><p class="source-code">false</p><p class="source-code">user=&gt; (= "hello" "hello" (clojure.string/reverse "olleh"))</p><p class="source-code">true</p><p class="source-code">user=&gt; (= [1 2 3] [1 2 3])</p><p class="source-code">true</p><p class="callout-heading">Note</p><p class="callout">In Java or other object-oriented programming languages, comparing things usually checks whether they are the exact same instance of an object stored in memory, that is, their identity. However, comparisons in Clojure are made by equality rather than identity. Comparing values is generally more useful, and Clojure makes it convenient, but if you ever wanted to compare identities, you could do so by using the <strong class="source-inline">identical?</strong> function.</p></li>
				<li>Maybe more surprisingly, but sequences of different types can be considered equal as well:<p class="source-code">user=&gt; (= '(1 2 3) [1 2 3])</p><p class="source-code">true</p><p>The list <strong class="source-inline">1</strong> <strong class="source-inline">2</strong> <strong class="source-inline">3</strong> is equivalent to the vector <strong class="source-inline">1</strong> <strong class="source-inline">2</strong> <strong class="source-inline">3</strong> . Collections and sequences are powerful Clojure abstractions that will be presented in <em class="italic">Chapter 2</em>, <em class="italic">Data Types and Immutability</em>.</p></li>
				<li>It is worth mentioning that the <strong class="source-inline">=</strong> function can also take one argument, in which case it will always return <strong class="source-inline">true</strong>:<p class="source-code">user=&gt; (= 1)</p><p class="source-code">true</p><p class="source-code">user=&gt; (= "I will not reason and compare: my business is to create.")</p><p class="source-code">true</p><p>The other comparison operators, that is, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&gt;=</strong>, <strong class="source-inline">&lt;</strong>, and <strong class="source-inline">&lt;=</strong>, can only be used with numbers. Let's start with <strong class="source-inline">&lt;</strong> and <strong class="source-inline">&gt;</strong>.</p></li>
				<li><strong class="source-inline">&lt;</strong> returns <strong class="source-inline">true</strong> if all its arguments are in a strictly increasing order. Try to evaluate the following expressions:<p class="source-code">user=&gt; (&lt; 1 2)</p><p class="source-code">true</p><p class="source-code">user=&gt; (&lt; 1 10 100 1000)</p><p class="source-code">true</p><p class="source-code">user=&gt; (&lt; 1 10 10 100)</p><p class="source-code">false</p><p class="source-code">user=&gt; (&lt; 3 2 3)</p><p class="source-code">false</p><p class="source-code">user=&gt; (&lt; -1 0 1)</p><p class="source-code">true</p><p>Notice that <strong class="source-inline">10</strong> followed by <strong class="source-inline">10</strong> is not strictly increasing.</p></li>
				<li><strong class="source-inline">&lt;=</strong> is similar, but adjacent arguments can be equal:<p class="source-code">user=&gt; (&lt;= 1 10 10 100)</p><p class="source-code">true</p><p class="source-code">user=&gt; (&lt;= 1 1 1)</p><p class="source-code">true</p><p class="source-code">user=&gt; (&lt;= 1 2 3)</p><p class="source-code">true</p></li>
				<li><strong class="source-inline">&gt;</strong> and <strong class="source-inline">&gt;=</strong> have a similar behavior and return <strong class="source-inline">true</strong> when their arguments are in a decreasing order. <strong class="source-inline">&gt;=</strong> allows adjacent arguments to be equal:<p class="source-code">user=&gt; (&gt; 3 2 1)</p><p class="source-code">true</p><p class="source-code">user=&gt; (&gt; 3 2 2)</p><p class="source-code">false</p><p class="source-code">user=&gt; (&gt;= 3 2 2)</p><p class="source-code">true</p></li>
				<li>Finally, the <strong class="source-inline">not</strong> operator is a useful function that returns <strong class="source-inline">true</strong> when its argument is <em class="italic">falsey</em> (<strong class="source-inline">nil</strong> or <strong class="source-inline">false</strong>), and <strong class="source-inline">false</strong> otherwise. Let's try an example:<p class="source-code">user=&gt; (not true)</p><p class="source-code">false</p><p class="source-code">user=&gt; (not nil)</p><p class="source-code">true</p><p class="source-code">user=&gt; (not (&lt; 1 2))</p><p class="source-code">false</p><p class="source-code">user=&gt; (not (= 1 1))</p><p class="source-code">false</p><p>To put things together, let's consider the following JavaScript code:</p><p class="source-code">let x = 50;</p><p class="source-code">if (x &gt;= 1 &amp;&amp; x &lt;= 100 || x % 100 == 0) {</p><p class="source-code">  console.log("Valid");</p><p class="source-code">} else {</p><p class="source-code">  console.log("Invalid");</p><p class="source-code">}</p><p>This code snippet prints <strong class="source-inline">Valid</strong> when a number, <strong class="source-inline">x</strong>, is included between 1 and 100 or if <strong class="source-inline">x</strong> is a multiple of 100. Otherwise, it prints <strong class="source-inline">Invalid</strong>.</p><p>If we wanted to translate this to Clojure code, we would write the following:</p><p class="source-code">(let [x 50]</p><p class="source-code">  (if (or (&lt;= 1 x 100) (= 0 (mod x 100)))</p><p class="source-code">    (println "Valid")</p><p class="source-code">    (println "Invalid")))</p><p>We may have a few more parentheses in the Clojure code, but you could argue that Clojure is more readable than the imperative JavaScript code. It contains less specific syntax, and we don't need to think about operator precedence.</p><p>If we wanted to transform the JavaScript code using an "inline if," we would introduce new syntax with <strong class="source-inline">?</strong> and <strong class="source-inline">:</strong>, as follows:</p><p class="source-code">let x = 50;</p><p class="source-code">console.log(x &gt;= 0 &amp;&amp; x &lt;= 100 || x % 100 == 0 ? "Valid" : "Invalid");</p><p>The Clojure code would become the following:</p><p class="source-code">(let [x 50]</p><p class="source-code">  (println (if (or (&lt;= 1 x 100) (= 0 (mod x 100))) "Valid" "Invalid")))</p></li>
			</ol>
			<p>Notice that there is no new syntax, and nothing new to learn. You already know how to read lists, and that is all you will (almost) ever need.</p>
			<p>This simple example demonstrates the great flexibility of <strong class="source-inline">lists</strong>: the building blocks of Clojure and other Lisp languages.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor030"/>Activity 1.03: The meditate Function v2.0</h2>
			<p>In this activity, we will improve the <strong class="source-inline">meditate</strong> function we wrote in <em class="italic">Exercise 1.05</em>, <em class="italic">Creating Simple Functions with fn and defn</em>, by replacing the <strong class="source-inline">calm</strong> Boolean argument with <strong class="source-inline">calmness-level</strong>. The function will print a transformation of the string passed as a second argument based on the calmness level. The specifications of the function are as follows:</p>
			<ul>
				<li><strong class="source-inline">calmness-level</strong> is a number between <strong class="source-inline">1</strong> and <strong class="source-inline">10</strong>, but we will not check the input for errors.</li>
				<li>If the calmness level is strictly inferior to <strong class="source-inline">5</strong>, we consider the user to be angry. The function should return the <strong class="source-inline">s</strong> string transformed to uppercase concatenated with the string "<strong class="source-inline">, I TELL YA!</strong>".</li>
				<li>If the calmness level is between <strong class="source-inline">5</strong> and <strong class="source-inline">9</strong>, we consider the user to be calm and relaxed. The function should return the <strong class="source-inline">s</strong> string with only its first letter capitalized.</li>
				<li>If the calmness level is <strong class="source-inline">10</strong>, the user has reached nirvana, and is being possessed by the Clojure gods. In its trance, the user channels the incomprehensible language of those divine entities. The function should return the <strong class="source-inline">s</strong> string in reverse.<p class="callout-heading">Hint</p><p class="callout">Use the <strong class="source-inline">str</strong> function to concatenate a string and <strong class="source-inline">clojure.string/reverse</strong> to reverse a string. If you are not sure how to use them, you can look up their documentation with <strong class="source-inline">doc</strong> (for example, <strong class="source-inline">(doc clojure.string/reverse)</strong>).</p></li>
			</ul>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Open your favorite editor and a REPL window next to it.</li>
				<li>In your editor, define a function with the name <strong class="source-inline">meditate</strong>, taking two arguments, <strong class="source-inline">calmness-level</strong> and <strong class="source-inline">s</strong>, without forgetting to write its documentation.</li>
				<li>In the function body, start by writing an expression that prints the string, <strong class="source-inline">Clojure Meditate v2.0</strong>.</li>
				<li>Following the specification, write the first condition to test whether the calmness level is strictly inferior to <strong class="source-inline">5</strong>. Write the first branch of the conditional expression (the <strong class="source-inline">then</strong>).</li>
				<li>Write the second condition, which should be nested in the second branch of the first condition (the <strong class="source-inline">else</strong>).</li>
				<li>Write the third condition, which should be nested in the second branch of the second condition. It will check that <strong class="source-inline">calmness-level</strong> is exactly <strong class="source-inline">10</strong> and return the reverse of the <strong class="source-inline">s</strong> string when that is the case.</li>
				<li>Test your function by passing a string with different levels of calmness. The output should be similar to the following:<p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 1)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">"WHAT WE DO NOW ECHOES IN ETERNITY, I TELL YA!"</p><p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 6)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">"What we do now echoes in eternity"</p><p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 10)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">"ytinrete ni seohce won od ew tahw"</p><p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 50)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">nil</p></li>
				<li>If you have been using the <strong class="source-inline">and</strong> operator to find whether a number was between two other numbers, rewrite your function to remove it and only use the <strong class="source-inline">&lt;=</strong> operator. Remember that <strong class="source-inline">&lt;=</strong> can take more than two arguments.</li>
				<li>Look up the <strong class="source-inline">cond</strong> operator in the documentation and rewrite your function to replace the nested conditions with <strong class="source-inline">cond</strong>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 680.</p></li>
			</ol>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor031"/>Summary</h1>
			<p>In this chapter, we discovered how to use the REPL and its helpers. You are now able to search and discover new functions and look up their documentation interactively in the REPL. We learned how Clojure code is evaluated, as well as how to use and create functions, bindings, conditionals, and comparisons. These allow you to create simple programs and scripts.</p>
			<p>In the next chapter, we will look at data types, including collections, and the concept of immutability.</p>
		</div>
		<div>
			<div id="_idContainer017" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer018" class="Content">
			</div>
		</div>
	</body></html>