["```java\ndef foo(x: Int): Option[Int] =\n  if (x < 0) None\n  else Some(math.sqrt(x))\n```", "```java\ndef foo(x: Int): Either[???, Int] =\n  if (x < 0) Left(???)\n  else Right(math.sqrt(x))\n```", "```java\ndef foo(x: Int): Either[String, Int] =\n  if (x < 0) Left(\"Can't take square root of a negative value\")\n  else Right(math.sqrt(x))\n```", "```java\ndef handle(request: Request): Response = {\n  val posts: List[Post] = allPosts()\n  respond(posts)\n}\n```", "```java\ntype Request\ntype Response\ntype Post\n\ndef allPosts(): List[Post]\n\ndef respond[A](a: A): Response\n```", "```java\ndef handle(request: Request): Response = {\n  val userToken: Token = request.token\n  val authenticated: Boolean = authenticate(userToken)\n\n  if (authenticated) {\n    val posts: List[Post] = allPosts()\n    respond(posts)\n  }\n  else respond(\"You are not authorized to perform this action\")\n}\n```", "```java\ntype Token\ntype Request <: { def token: Token }\n\ndef authenticate(token: Token): Boolean\n```", "```java\ndef allPosts(): Future[List[Post]]\n\ndef authenticate(token: Token): Future[Boolean]\n\ndef handle(request: Request): Future[Response] =\n  for {\n    authenticated <- authenticate(request.token)\n    response <- \n```", "```java\n      if (authenticated) allPosts.map(respond)\n      else Future { respond(\"You are not authorized to perform this\n      action\") }\n  } yield response\n```", "```java\nif (authenticated) allPosts.map(respond)\nelse Future { respond(\"You are not authorized to perform this action\") }\n```", "```java\ndef allPosts(): Future[Either[String, List[Post]]]\n\ndef authenticate(token: Token): Future[Either[String, Boolean]]\n```", "```java\nfor {\n  authenticated <- authenticate(request.token)\n  response <- \n    if (authenticated) allPosts.map(respond)\n    else Future { Left(\"You are not authorized to perform this action\") }\n} yield response\n```", "```java\nauthenticate(request.token).flatMap { authenticated =>\n  if (authenticated) allPosts.map(respond)\n  else Future { Left(\"You are not authorized to perform this action\") }\n}\n```", "```java\ndef handle(request: Request): Future[Either[String, Response]] =\n  authenticate(request.token).flatMap {\n    case Right(authenticated) if authenticated =>\n      allPosts.map { eitherPosts =>\n        eitherPosts.map(respond)\n      }\n\n    case Right(authenticated) if !authenticated =>\n      Future { Left(\"You are not authorized to perform this action\") }\n\n    case Left(error) => Future(Left(error))\n  }\n```", "```java\ndef flatMap[AA >: A, D](f: B => EitherT[F, AA, D])(implicit F: Monad[F]): EitherT[F, AA, D] =\n  EitherT(F.flatMap(value) {\n    case l @ Left(_) => F.pure(l.rightCast)\n    case Right(b) => f(b).value\n  })\n\n```", "```java\ndef handle(request: Request): EitherT[Future, String, Response] =\n  for {\n    authenticated <- authenticate(request.token)\n      .ensure(\"You are not authorized to perform this action\")(identity)\n    posts <- allPosts()\n    response = respond(posts)\n  } yield response\n```", "```java\ntype Config\ntype Ef[A] = ReaderT[EitherT[Future, String, ?], Config, A]\n```", "```java\naddCompilerPlugin(\"org.spire-math\" %% \"kind-projector\" % \"0.9.4\")\n```", "```java\nConfig => Future[Either[String, A]]\n```", "```java\ntrait Capabilities[F[_]] {\n  def resource[A](name: String): F[A]\n  def notify(target: String, text: String): F[Unit]\n}\n```", "```java\nName,Price\nBread,2\nButter,4\nCabbage,3\nWater,2\n```", "```java\ndef income[F[_]](implicit M: Monad[F], C: Capabilities[F]): F[Unit] =\n  for {\n    contents <- C.resource(\"sales.csv\")\n    total = contents\n      .split(\"\\n\").toList.tail // Collection of lines, drop the CSV header\n      .map { _.split(\",\").toList match // List[Double] - prices of each\n       of the entries\n        { case name :: price :: Nil => price.toDouble }\n      }\n      .sum\n    _ <- C.notify(\"admin@shop.com\", s\"Total income made today: $total\")\n  } yield ()\n```", "```java\nimport scala.concurrent.{ Future, Await }\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration.Duration\n\nimport cats._, cats.implicits._\n\n/*...*/\nAwait.result(income[Future], Duration.Inf) // Block so that the application does not exit prematurely\n```", "```java\nimplicit val capabilities: Capabilities[Future] = new Capabilities[Future] {\n  import java.io.File\n  import org.apache.commons.io.FileUtils\n\n  def resource(name: String): Future[String] =\n    Future { FileUtils.readFileToString(new File(name)) }\n\n  def notify(target: String, text: String): Future[Unit] =\n    Future { println(s\"Notifying $target: $text\") }\n}\n```", "```java\nNotifying admin@shop.com: Total income made today: 11.0\n```", "```java\nimplicit val anotherEnvironmentCapabilities: Capabilities[Future] = new Capabilities[Future] {\n  def resource(name: String): Future[String] = ???\n  def notify(target: String, text: String): Future[Unit] = ???\n}\n```", "```java\nimplicit val logMonad: Monad[Future] = new Monad[Future] {\n  def flatMap[A, B](fa: Future[A])(f: (A) â‡’ Future[B]): Future[B] =\n    fa.flatMap { x =>\n      println(s\"Trace of the Future's result: $x\")\n      f(x) }\n```", "```java\nAwait.result(income[Future](logMonad, capabilities), Duration.Inf) // Block so that the application does not exit prematurely\n```", "```java\ntrait Capabilities {\n  def resource(name: String): String\n  def notify(target: String, text: String): Unit\n}\n\ndef income(c: Capabilities): Unit = {\n  val contents = c.resource(\"sales.csv\")\n  val total = contents\n    .split(\"\\n\").toList.tail // Collection of lines, drop the CSV header\n    .map { _.split(\",\").toList match // List[Double] - prices of each of the entries\n      { case name :: price :: Nil => price.toDouble }\n    }\n    .sum\n  c.notify(\"admin@shop.com\", s\"Total income made today: $total\")\n}\n```", "```java\nsql\"\"\"select * from customers where id = $id\"\"\")\n```", "```java\nsql\"\"\"select * from customers where id = $id\"\"\")\n  .query[User].unique.transact(tr)\n```", "```java\nval list: List[Any] = List(0, 2.0, \"3\", Fraction(4, 2))\n```", "```java\ncase class Fraction(numerator: Int, denominator: Int)\n```", "```java\nval sum = list.map {\n  case x: Int => x.toDouble\n  case x: Double => x\n  case x: String => x.toDouble\n  case Fraction(n, d) => n / d.toDouble\n}.sum\n```", "```java\nval sum = list.map {\n  case x: Int => x.toDouble\n  case x: Double => x\n  case x: String => x.toDouble\n  // case Fraction(n, d) => n / d.toDouble\n}.sum\n```", "```java\npackage jvm\n/*...*/\nsealed trait HList {\n  def :::[H](h: H): H ::: this.type = jvm.:::(h, this)\n}\ncase class :::[+H, +T <: HList](head: H, tail: T) extends HList {\n  override def toString() = s\"$head ::: $tail\"\n}\ntrait HNil extends HList\ncase object HNil extends HNil\n\n```", "```java\nval hlist: String ::: Int ::: Fraction ::: HNil =\n  \"1\" ::: 2 ::: Fraction(3, 4) ::: HNil\n```", "```java\nString ::: Int ::: Fraction ::: HNil\n```", "```java\n:::[String, :::[Int, :::[Fraction, HNil]]]\n```", "```java\ndef sumSimple[L <: HList](hlist: L)(implicit m: MapToDouble[L]): Double\n```", "```java\ndef sumSimple[L <: HList](hlist: L)(implicit m: MapToDouble[L]): Double = {\n  val mapped: m.Result = m.map(hlist)\n  def loop(l: HList): Double = l match {\n    case :::(h: Double, t) => h + loop(t)\n    case HNil => 0\n  }\n  loop(mapped)\n}\n```", "```java\ndef sum[L <: HList, LR <: HList](hlist: L)(implicit m: MapToDouble.Aux[L, LR], s: Sum[LR]): Double =\n  s.sum(m.map(hlist))\n```", "```java\nString ::: Int ::: Fraction ::: HNil\n```", "```java\nDouble ::: Double ::: Double ::: HNil\n```", "```java\ntrait MapToDouble[L <: HList] {\n  type Result <: HList\n  def map(l: L): Result\n}\n```", "```java\ntype L = String ::: Int ::: Fraction ::: HNil\nval mapper: MapToDouble[L] = implicitly[MapToDouble[L]]\n```", "```java\ntrait MapToDoubleNoAux[L <: HList, Result <: HList] {\n  def map(l: L): Result\n}\n```", "```java\ntype In = String ::: Int ::: Fraction ::: HNil\ntype Out = Double ::: Double ::: Double ::: HNil\nval mapper: MapToDoubleNoAux[In, Out] = implicitly[MapToDoubleNoAux[In, Out]]\n```", "```java\nobject MapToDouble {\n  type Aux[L <: HList, LR <: HList] = MapToDouble[L] { type Result = LR }\n  /*...*/\n}\n```", "```java\ndef sum[L <: HList, LR <: HList](hlist: L)(implicit m: MapToDouble.Aux[L, LR], s: Sum[LR]): Double\n```", "```java\nval s = sum(hlist)\nprintln(s\"Sum of $hlist is $s\")\n```", "```java\nSum of 1 ::: 2 ::: Fraction(3,4) ::: HNil is 3.75\n```", "```java\nobject MapToDouble {\n  type Aux[L <: HList, LR <: HList] = MapToDouble[L] { type Result = LR }\n  def apply[L <: HList](implicit m: MapToDouble[L]) = m\n\n  implicit def hcons[H, T <: HList, TR <: HList](implicit\n    td: ToDouble[H]\n  , md: MapToDouble.Aux[T, TR]\n  ): Aux[H ::: T, Double ::: TR]\n\n  implicit def hnil[H <: HNil]: MapToDouble.Aux[H, HNil]\n}\n```", "```java\nimplicit def hnil[H <: HNil]: MapToDouble.Aux[H, HNil] = new MapToDouble[H] {\n\n  type Result = HNil\n  def map(h: H) = HNil\n}\n```", "```java\ntrait ToDouble[T] {\n  def toDouble(t: T): Double\n}\n```", "```java\nimplicit def hcons[H, T <: HList, TR <: HList](implicit\n  td: ToDouble[H]\n, md: MapToDouble.Aux[T, TR]\n): Aux[H ::: T, Double ::: TR] = new MapToDouble[H ::: T] {\n\n  type Result = Double ::: TR\n  def map(l: H ::: T): Double ::: TR =\n    td.toDouble(l.head) ::: md.map(l.tail)\n}\n```", "```java\ntrait Sum[L] {\n  def sum(l: L): Double\n}\n\nobject Sum {\n  def apply[L <: HList](implicit s: Sum[L]) = s\n\n  implicit def hcons[T <: HList](implicit st: Sum[T]): Sum[Double ::: T] =\n    { (l: Double ::: T) => l.head + st.sum(l.tail) }\n\n  implicit def hnil[H <: HNil]: Sum[H] =\n    { (x: HNil) => 0 }\n}\n```", "```java\ntrait ToDouble[T] {\n  def toDouble(t: T): Double\n}\n\nobject ToDouble {\n  def apply[T](implicit t: ToDouble[T]) = t\n\n  implicit def double: ToDouble[Double] = identity\n  implicit def int : ToDouble[Int ] = _.toDouble\n  implicit def string: ToDouble[String] = _.toDouble\n\n  implicit def fraction: ToDouble[Fraction] =\n    f => f.numerator / f.denominator.toDouble\n}\n```", "```java\nimplicit def double: ToDouble[Double] = identity\nimplicit def int : ToDouble[Int ] = _.toDouble\nimplicit def string: ToDouble[String] = _.toDouble\n\n// implicit def fraction: ToDouble[Fraction] =\n// f => f.numerator / f.denominator.toDouble\n```", "```java\nimplicitly[MapToDouble[String ::: Int ::: Fraction ::: HNil]]\nimplicitly[MapToDouble[Int ::: Fraction ::: HNil]]\nimplicitly[MapToDouble[Fraction ::: HNil]]\nimplicitly[ToDouble[Fraction]]\n```"]