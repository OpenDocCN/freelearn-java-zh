<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor220"/>7</h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor221"/>Remember-me Services</h1>
<p>In this chapter, we’ll add the ability for an application to remember a user even after their session has expired and the browser is closed. The following topics will be covered in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Discussing what <span class="No-Break"><strong class="bold">remember-me</strong></span><span class="No-Break"> is</span></li>
<li>Learning how to use the token-based <span class="No-Break">remember-me feature</span></li>
<li>Discussing how secure remember-me is, and various ways of making it <span class="No-Break">more secure</span></li>
<li>Enabling the persistent-based remember-me feature, and how to handle additional considerations for <span class="No-Break">using it</span></li>
<li>Presenting the overall <span class="No-Break">remember-me architecture</span></li>
<li>Learning how to create a custom remember-me implementation that is restricted to the user’s <span class="No-Break">IP address</span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/WEEx2"><span class="No-Break">https://packt.link/WEEx2</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor222"/><a id="_idTextAnchor223"/>What is remember-me?</h1>
<p>A convenient feature to offer frequent<a id="_idIndexMarker429"/> users of a website is the remember-me feature. This feature allows a user to elect to be remembered even after their browser is closed. In Spring Security, this is implemented through<a id="_idIndexMarker430"/> the use of a remember-me <strong class="bold">cookie</strong> that is stored in the user’s browser. If Spring Security recognizes that the user is presenting a remember-me cookie, then the user will automatically be logged into the application, and will not need to enter a username <span class="No-Break">or password.</span></p>
<p class="callout-heading">What is a cookie<a id="_idTextAnchor224"/>?</p>
<p class="callout">A cookie is a way<a id="_idIndexMarker431"/> for a client (that is, a web browser) to persist the state. For more information<a id="_idIndexMarker432"/> about cookies, refer to additional online resources, such as <span class="No-Break">Wikipedia (</span><a href="https://en.wikipedia.org/wiki/HTTP_cookie"><span class="No-Break">https://en.wikipedia.org/wiki/HTTP_cookie</span></a><span class="No-Break">).</span></p>
<p>Spring Security provides the following two different strategies that we will discuss in <span class="No-Break">this chapter:</span></p>
<ul>
<li>The first is the token-based remember-me feature, which relies on a <span class="No-Break">cryptographic signature</span></li>
<li>The second method, the <strong class="source-inline">persistent-based remember-me</strong> feature, requires a datastore (<span class="No-Break">a database)</span></li>
</ul>
<p>As we previously mentioned, we will discuss<a id="_idIndexMarker433"/> these strategies in much greater detail throughout this chapter. The remember-me feature must be explicitly configured in order to enable it. Let’s start by trying the token-based remember-me feature and see ho<a id="_idTextAnchor225"/>w it affects the flow of the <span class="No-Break">login experie<a id="_idTextAnchor226"/>nce.</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor227"/>Dependencies</h2>
<p>The token-based remember-me section<a id="_idIndexMarker434"/> does not need any additional dependencies other than the basic setup from <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>. However, you will want to ensure you include the following additional dependencies in your <strong class="source-inline">build.gradle</strong> file if you are leveraging the persistent-based remember-me feature. We have already included these dependencies in the chapter’s sample, so there is no need to update the <span class="No-Break">sample application:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
    // JPA / ORM / Hibernate:
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    // H2 db
    implementation 'com.h2database:h2'
...
}</pre> <h2 id="_idParaDest-161"><a id="_idTextAnchor228"/>The token-based remember-me feature</h2>
<p>Spring Security provides<a id="_idIndexMarker435"/> two different implementations<a id="_idIndexMarker436"/> of the remember-me feat<a id="_idTextAnchor229"/>ure. We will start by exploring how to set up token-based <span class="No-Break">remember-me se<a id="_idTextAnchor230"/>rvices.</span></p>
<h3>Configuring the token-based remember-me feature</h3>
<p>Completing this exercise will allow us to provide<a id="_idIndexMarker437"/> a simple and secure method to keep users logged in for extended periods of time. To start, perform the <span class="No-Break">following steps:</span></p>
<ol>
<li>Modify the <strong class="source-inline">SecurityConfig.java</strong> configuration file and add the <span class="No-Break"><strong class="source-inline">rememberMe</strong></span><span class="No-Break"> method.</span><p class="list-inset">Take a look at the following <span class="No-Break">code snippet:</span></p><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
...
    // Remember Me
    http.rememberMe(httpSecurityRememberMeConfigurer -&gt;
        httpSecurityRememberMeConfigurer.key("jbcpCalendar"));
...
}</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.00-calendar</strong></span><span class="No-Break">.</span></p>
<ol>
<li value="2">If we try running the application<a id="_idIndexMarker438"/> now, we’ll see nothing different in the flow. This is because we also need to add a field to the login form that allows the user to opt for this functionality. Edit the <strong class="source-inline">login.xhtml</strong> file and add a checkbox, as shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
//src/main/resources/templates/login.xhtml
&lt;div class="mb-3"&gt;
    &lt;label class="form-label" for="password"&gt;Password&lt;/label&gt;
    &lt;input class="form-control" id="password" name="password"
           type="password"/&gt;
&lt;/div&gt;
&lt;div class="mb-3"&gt;
    &lt;label for="remember-me"&gt;Remember Me?&lt;/label&gt;
    &lt;input type="checkbox" id="remember-me" name="remember-me" th:checked="true" /&gt;
&lt;/div&gt;
&lt;div class="mb-3"&gt;
    &lt;input class="btn btn-primary" id="submit" name="submit" type="submit"
           value="Login"/&gt;
&lt;/div&gt;</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.01-calendar</strong></span><span class="No-Break">.</span></p>
<ol>
<li value="3">When we next log in, if the remember-me box is selected, a remember-me cookie is set in the <span class="No-Break">user’s browser.</span><p class="list-inset">Spring Security understands that it should remember the user by inspecting the <strong class="source-inline">remember-me</strong> <span class="No-Break">HTTP parameter.</span></p></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">In Spring Security 4.x and after, the default remember-me form field is <strong class="source-inline">remember-me</strong>. This can be overridden with the <span class="No-Break"><strong class="source-inline">rememberMeParameter</strong></span><span class="No-Break"> method.</span></p>
<ol>
<li value="4">If the user then closes<a id="_idIndexMarker439"/> their browser and reopens it to an authenticated page on the JBCP calendar website, they won’t be presented with the login page a second time. Try it yourself now—log in with the remember-me option selected, bookmark the home page, then restart the browser and access the home page. You’ll see that you’re immediately logged in successfully without needing to supply your login credentials again. If this appears to be happening to you, it means that your browser or a browser plugin is restoring <span class="No-Break">the session.</span></li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">Try closing the tab first and then close <span class="No-Break">the browser.</span></p>
<p class="list-inset">One more effective solution is to use Chrome developer tools to remove the <strong class="source-inline">JSESSIONID</strong> cookie. This can often save time and annoyance during the development and verification of this type of feature on <span class="No-Break">your site.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 7.1 – Exploring the remember-me cookie" height="301" src="image/B21757_07_1.jpg" width="1532"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Exploring the remember-me cookie</p>
<p class="list-inset">After logging in and selecting <strong class="source-inline">remember-me</strong>, you should<a id="_idIndexMarker440"/> see two cookies have been set, <strong class="source-inline">JSESSIONID</strong> and <strong class="source-inline">remember-me</strong>, as shown in <span class="No-Break">the screenshot.</span></p>
<h3>How the token-based remember-me feature works</h3>
<p>The remember-me feature<a id="_idIndexMarker441"/> sets a cookie in the user’s browser containing a Base64-encoded string with the <span class="No-Break">following pieces:</span></p>
<ul>
<li><span class="No-Break">The username</span></li>
<li>An <span class="No-Break">expiration date/time</span></li>
<li>An SHA-256 hash value of the <strong class="source-inline">expiration</strong> date/time, <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, and the <strong class="source-inline">key</strong> attribute of the <span class="No-Break"><strong class="source-inline">rememb<a id="_idTextAnchor231"/>erMe</strong></span><span class="No-Break"> method</span></li>
</ul>
<p>These are combined into a single cookie value that is stored in the browser for later use. The cookie is composed <span class="No-Break">as follows:</span></p>
<pre class="source-code">
base64(username + ":" + expirationTime + ":" + algorithmName + ":"
algorithmHex(username + ":" + expirationTime + ":" password + ":" + key))
username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token
algorithmName:     The algorithm used to generate and to verify the remember-me token</pre> <p>In the upcoming section, we’ll explore the SHA-256 algorithm in conjunction with <span class="No-Break">Spring Security.</span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor232"/>SHA-256 Algorithm</h1>
<p>By default, this implementation<a id="_idIndexMarker442"/> uses the SHA-256 algorithm to encode the token signature. To verify the token signature, the algorithm retrieved from <strong class="source-inline">algorithmName</strong> is parsed and used. If <strong class="source-inline">algorithmName</strong> is not present, the default matching algorithm will be used, which is <strong class="source-inline">SHA-256</strong>. You can specify different algorithms for signature encoding and for signature matching; this allows users to safely upgrade to a different encoding algorithm while still being able to verify old ones if <strong class="source-inline">algorithmName</strong> is not present. To do that, you can specify your customized <strong class="source-inline">TokenBasedRememberMeServices</strong> as a bean and use it in <span class="No-Break">the configuration:</span></p>
<pre class="source-code">
@Bean
SecurityFilterChain securityFilterChain(HttpSecurity http, RememberMeServices rememberMeServices) throws Exception {
    http
          .authorizeHttpRequests((authorize) -&gt; authorize
                .anyRequest().authenticated()
          )
          .rememberMe((remember) -&gt; remember
                .rememberMeServices(rememberMeServices)
          );
    return http.build();
}
@Bean
RememberMeServices rememberMeServices(UserDetailsService userDetailsService) {
    RememberMeTokenAlgorithm encodingAlgorithm = RememberMeTokenAlgorithm.SHA256;
    TokenBasedRememberMeServices rememberMe = new TokenBasedRememberMeServices(myKey, userDetailsService, encodingAlgorithm);
    rememberMe.setMatchingAlgorithm(RememberMeTokenAlgorithm.MD5);
    return rememberMe;
}</pre> <p>To recap, we’ve covered<a id="_idIndexMarker443"/> the SHA-256 algorithm, and in the next section, we’ll delve into the <span class="No-Break">remember-me signature.</span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor233"/>Remember-me signature</h2>
<p>We can see how <strong class="source-inline">SHA-256</strong> can ensure<a id="_idIndexMarker444"/> that we have downloaded<a id="_idIndexMarker445"/> the correct file, but how does this apply to Spring Security’s remember-me service? Much like the file we downloaded, the cookie is untrusted, but we can trust it if we can validate the signature that originated from our application. When a request comes in with the remember-me cookie, its contents are extracted, and the expected signature is compared to the signature found in <span class="No-Break">the cookie.</span></p>
<p>The steps in calculating the expected signature are illustrated in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 7.2 – SHA-256 Hash-Based Token Approach" height="256" src="image/B21757_07_2.jpg" width="765"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – SHA-256 Hash-Based Token Approach</p>
<p>The remember-me cookie contains the <strong class="source-inline">username</strong>, <strong class="source-inline">expiration</strong>, and <strong class="source-inline">signature</strong>. Spring Security will extract the <strong class="source-inline">username</strong> and <strong class="source-inline">expiration</strong> from the cookie. It will then utilize the <strong class="source-inline">username</strong> from the cookie to look up the <strong class="source-inline">password</strong> using <strong class="source-inline">UserDetailsService</strong>. The <strong class="source-inline">key</strong> is already known because it was provided using the <strong class="source-inline">rememberMe</strong> method. Now that all of the arguments are known, Spring Security can calculate the expected signature using the <strong class="source-inline">username</strong>, <strong class="source-inline">expiration</strong>, <strong class="source-inline">password</strong>, and <strong class="source-inline">key</strong>. It then compares the <strong class="source-inline">expected</strong> <strong class="source-inline">signature</strong> against the <span class="No-Break">cookie’s </span><span class="No-Break"><strong class="source-inline">signature</strong></span><span class="No-Break">.</span></p>
<p>If the two signatures match, we can trust that the <strong class="source-inline">username</strong> and <strong class="source-inline">expiration</strong> date are valid. Forging a <strong class="source-inline">signature</strong> is next to impossible without knowing the remember-me key (which only the application knows) and the user’s password (which only this user knows). This means that if the signatures match and the token is not expired, the user can be <span class="No-Break">logged in.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You have anticipated that if the user changes their username or password, any remember-me token set will no longer be valid. Make sure that you provide appropriate messaging to users if you allow them to change these bits of their account. Later in this chapter, we will look at an alternative remember-me implementation that is reliant only on the username and not on <span class="No-Break">the password.</span></p>
<p>Note that it is still possible to differentiate<a id="_idIndexMarker446"/> between users who have been<a id="_idIndexMarker447"/> authenticated with a remember-me cookie and users who have presented the username and password (or equivalent) credentials. We’ll experiment with this shortly when we investigate the security of the <span class="No-Break">remember-me feature.</span></p>
<h3>Token-based remember-me configuration directives</h3>
<p>The following two configuration<a id="_idIndexMarker448"/> changes are commonly made to alter the default behavior of the <span class="No-Break">remember-me functionality:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Attribute</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">key</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This defines a unique key used when producing the remember-me <span class="No-Break">cookie’s signature.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">tokenValiditySeconds</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This defines the length of time (in seconds). The remember-me cookie will be considered valid for authentication. It is also used to set the cookie <span class="No-Break">expiration timestamp.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.3 – The main configuration of the remember-me cookie</p>
<p>As you may infer from the discussion of how the cookie contents are hashed, the <strong class="source-inline">key</strong> attribute is critical for the security of the remember-me feature. Make sure that the key you choose is likely to be unique to your application and long enough so that it can’t be <span class="No-Break">easily guessed.</span></p>
<p>Keeping in mind the purpose of this book, we’ve kept the <strong class="source-inline">key</strong> values relatively simple, but if you’re using remember-me in your application, it’s suggested that your key contains the unique name of your application and is at least 36 random characters long. Password generator tools (search <strong class="source-inline">online password generator</strong> on Google) are a great way to get a pseudo-random mix of alphanumeric and special characters to compose your remember-me key. For applications that exist in multiple environments (such as development, test, and production), the remember-me cookie value should include this fact as well. This will prevent remember-me cookies from inadvertently being used in the wrong environment <span class="No-Break">during testing!</span></p>
<p>An example key value in a production application might be similar to <span class="No-Break">the following:</span></p>
<pre class="source-code">
prodJbcpCalendar-rmkey- YWRtaW4xJTQwZXhhbXBsZS5jb206MTY5ODc2MTM 2ODgwNjpTSEEyNTY6YzE5ZjE2YzliN2U2ZjA xZGMyMjdkMWJmN2JlYWQzNGRhYWJiMGFmNDliMDE0ZGY5MTg4YjIzYzM1YjQzZmMzNw</pre> <p>The <strong class="source-inline">tokenValiditySeconds</strong> method is used to set the number of seconds after which the remember-me token will not be accepted for the automatic login function, even if it is otherwise a valid token. The same attribute is also used to set the maximum lifetime of the remember-me cookie<a id="_idIndexMarker449"/> on the <span class="No-Break">user’s browser.</span></p>
<p class="callout-heading">Configuration of the remember-me session cookies</p>
<p class="callout">If <strong class="source-inline">tokenValiditySeconds</strong> is set to <strong class="source-inline">-1</strong>, the login cookie will be set to a session cookie, which does not persist after the browser is closed by the user. The token will be valid (assuming the user doesn’t close the browser) for a non-configurable length of two weeks. Don’t confuse this with the cookie that stores your user’s session ID—they’re two different things with <span class="No-Break">similar names!</span></p>
<p>You may have noticed that we listed very few attributes. Don’t worry, we will spend time<a id="_idTextAnchor234"/> covering some of the other configuration attributes throughout <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor235"/>Is remember-me secure?</h1>
<p>Any feature related to security<a id="_idIndexMarker450"/> that has been added for user convenience has the potential to expose our carefully protected site to a security risk. The remember-me feature, in its default form, runs the risk of the user’s cookie being intercepted and reused by a malicious user. The following diagram illustrates how this <span class="No-Break">might happen:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 7.3 –Remember-me session cookie replay attack" height="614" src="image/B21757_07_3.jpg" width="1308"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 –Remember-me session cookie replay attack</p>
<p>The use of <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) (covered in the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional Reference Material</em>) and other network<a id="_idIndexMarker451"/> security techniques can mitigate<a id="_idIndexMarker452"/> this type of attack, but be aware<a id="_idIndexMarker453"/> that there are other techniques, such as <strong class="bold">Cross-Site Scripting </strong>(<strong class="bold">XSS</strong>), that can steal or compromise a remembered user session. While convenient for the user, we don’t want to risk financial <a id="_idIndexMarker454"/>or other personal information being inadvertently changed or possibly stolen if the remembered session <span class="No-Break">is misused.</span></p>
<p class="callout-heading">Important <a id="_idTextAnchor236"/>note</p>
<p class="callout">Although we don’t cover malicious user behavior in detail in this book, when implementing any secured system, it is important to understand the techniques employed by users who may be trying to hack your customers or employees. XSS is one such technique, but many others exist. It’s highly recommended<a id="_idIndexMarker455"/> that you review the <em class="italic">OWASP Top Ten</em> article (<a href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>) for a good list, and also pick up a web application security reference book in which many of the techniques demonstrated are illustrated to apply to <span class="No-Break">any technology.</span></p>
<p>One common approach for maintaining the balance between convenience and security is identifying the functional locations on the site where personal or sensitive information could be present. You can then use the <strong class="source-inline">fullyAuthenticated</strong> expression to ensure these locations are protected using an authorization that checks not just the user’s role, but that they have been authenticated<a id="_idIndexMarker456"/> with a full username and password. We will explor<a id="_idTextAnchor237"/>e this feature in greater detail in the <span class="No-Break">next section.</span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor238"/>Authorization rules for remember-me</h2>
<p>We’ll fully explore the advanced<a id="_idIndexMarker457"/> authorization <a id="_idIndexMarker458"/>techniques later in <a href="B21757_11.xhtml#_idTextAnchor332"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Fine-Grained Access Control</em>, however, it’s important to realize that it’s possible to differentiate access rules based on whether or not an authenticated session <span class="No-Break">was remembered.</span></p>
<p>Let’s assume we want to limit users trying to access the <strong class="source-inline">H2 admin</strong> console to administrators who have been authenticated using a username and password. This is similar to the behavior found in other major consumer-focused commerce sites, which restrict access to the elevated portions of the site until a password is entered. Keep in mind that every site is different, so don’t blindly apply such rules to your secure site. For our sample application, we’ll concentrate on protecting the H2 database console. Update the <strong class="source-inline">SecurityConfig.java</strong> file to use the <strong class="source-inline">fullyAuthenticated</strong> keyword, which ensures that remembered users who try to access the H2 database are denied access. This is shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
...
@Bean
public SecurityFilterChain filterChain(HttpSecurity http, PersistentTokenRepository persistentTokenRepository) throws Exception {
    http.authorizeHttpRequests( authz -&gt; authz
                .requestMatchers("/webjars/**").permitAll()
                .requestMatchers("/css/**").permitAll()
                .requestMatchers("/favicon.ico").permitAll()
                // H2 console:
                .requestMatchers("/admin/h2/**")
                .access(new WebExpressionAuthorizationManager("isFullyAuthenticated() and hasRole('ADMIN')"))
...
    // Remember Me
    http.rememberMe(httpSecurityRememberMeConfigurer -&gt; httpSecurityRememberMeConfigurer
        .key("jbcpCalendar").tokenRepository(persistentTokenRepository));
...
}</pre> <p>The existing rules<a id="_idIndexMarker459"/> remain unchanged. We’ve added a rule that requires<a id="_idIndexMarker460"/> requests for account information to have the appropriate <strong class="source-inline">GrantedAuthority</strong> of <strong class="source-inline">ROLE_ADMIN</strong>, and that the user is fully authenticated; that is, during this authenticated session, they have presented a username and password<a id="_idIndexMarker461"/> or other suitable credentials. Note the syntax of the <strong class="bold">Spring Expression Language</strong> (<strong class="bold">SpEL</strong>) logical operators here—<strong class="source-inline">AND</strong>, <strong class="source-inline">OR</strong>, and <strong class="source-inline">NOT</strong> are used for logical operators in <strong class="source-inline">SpEL</strong>. This was thoughtful of the <strong class="source-inline">SpEL</strong> designers, as the <strong class="source-inline">&amp;&amp;</strong> operator would be awkward to represent in XML, even though the preceding example uses <span class="No-Break">Java-based configuration!</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.02-calendar</strong></span><span class="No-Break">.</span></p>
<p>Go ahead and log in with the username <strong class="source-inline">admin1@example.com</strong> and the password <strong class="source-inline">admin1</strong>, ensuring you select the remember-me feature. Access the H2 database console and you will see that the access is granted. Now, delete the <strong class="source-inline">JSESSIONID</strong> cookie (or close the tab and then all of the browser instances), and ensure that access is still granted to the <strong class="bold">All </strong><span class="No-Break"><strong class="bold">Events</strong></span><span class="No-Break"> page.</span></p>
<p>Now, navigate to the H2 console and observe that the access <span class="No-Break">is denied.</span></p>
<p>This approach combines<a id="_idIndexMarker462"/> the usability enhancements of the remember-me feature<a id="_idIndexMarker463"/> with an additional level of security by requiring a user to present a full set of credentials to access sensitive information. Throughout the rest of the chapter, we will explore <a id="_idTextAnchor239"/>other ways of making the remember-me feature<a id="_idTextAnchor240"/> <span class="No-Break">more secure.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor241"/>Persistent remember-me</h2>
<p>Spring Security provides the capability to alter the method for validating the remember-me cookie by leveraging different implementations of the <strong class="source-inline">RememberMeServices</strong> interface. In this section, we will discuss how we can use persistent remember-me tokens using a database, and how this can increase the security of <span class="No-Break">our application.</span></p>
<h3>Using the persistent-based remember-me feature</h3>
<p>Modifying our remember-me configuration<a id="_idIndexMarker464"/> at this point to persist to the database is surprisingly trivial. The Spring Security configuration parser will recognize a new <strong class="source-inline">tokenRepository</strong> method on the <strong class="source-inline">rememberMe</strong> method, and simply switch implementation classes for <strong class="source-inline">RememberMeServices</strong>. Let’s now review the ste<a id="_idTextAnchor242"/>ps required to <span class="No-Break">ac<a id="_idTextAnchor243"/>complish this.</span></p>
<h3>Adding SQL to create the remember-me schema</h3>
<p>We have placed the SQL file<a id="_idIndexMarker465"/> containing the expected<a id="_idIndexMarker466"/> schema in our <strong class="source-inline">src/main/resources</strong> folder in the same place we did in <a href="B21757_03.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Custom Authentication</em>. You can view the schema definition in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/resources/schema.sql
create table persistent_logins
(
    username  varchar_ignorecase(50) not null,
    series    varchar(64) primary key,
    token     varchar(64) not null,
    last_used timesta<a id="_idTextAnchor244"/><a id="_idTextAnchor245"/>mp   not null
);</pre> <h3>Initializing the data source with the remember-me schema</h3>
<p>Spring Data will automatically initialize<a id="_idIndexMarker467"/> the embedded <a id="_idIndexMarker468"/>database with <strong class="source-inline">schema.sql</strong>, as described in the preceding section. Note, however, that with <strong class="bold">Jakarta Persistence API</strong> (<strong class="bold">JPA</strong>), in order for the schema to be created<a id="_idIndexMarker469"/> and the <strong class="source-inline">data.sql</strong> file used to seed the database, we must ensure data source initialization is deferred <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/application.yml
spring:
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    show-sql: false
    hibernate:
      ddl-auto: create-drop
    defer-datasource-initialization: true</pre> <p>After reviewing the persistent-based remember-me functionality, specifically using a database, the next section will cover the configuration of this feature <span class="No-Break">with JPA.</span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor246"/>Configuring the persistent-based remember-me feature</h1>
<p>Finally, we’ll need to make some brief<a id="_idIndexMarker470"/> configuration changes to the <strong class="source-inline">rememberMe</strong> declaration to point it to the data source we’re using, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityC onfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http, PersistentTokenRepository persistentTokenRepository) throws Exception {
    http.authorizeRequests( authz -&gt; authz
    ...
    // Remember Me
    http.rememberMe(httpSecurityRememberMeConfigurer -&gt; httpSecurityRememberMeConfigurer
          .key("jbcpCalendar").tokenRepository(persistentTokenRepository));
    return http.build();
}
@Bean
public PersistentTokenRepository persistentTokenRepository(DataSource dataSource) {
    JdbcTokenRepositoryImpl db = new JdbcTokenRepositoryImpl();
    db.setDataSource(dataSource);
    return db;
}</pre> <p>This is all we need to do to switch<a id="_idIndexMarker471"/> over to using persistent-based remember-me authentication. Go ahead and start up the application and give it a try. From a user standpoint, we do not notice any differences, but we know that the implementation<a id="_idIndexMarker472"/> backing this feature <span class="No-Break">has changed.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.03-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor247"/>How does the persistent-based remember-me feature work?</h2>
<p>Instead of validating a signature present<a id="_idIndexMarker473"/> in the cookie, the persistent-based remember-me service validates if the token exists in a database. Each persistent remember-me cookie consists of <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Series identifier</strong>: This identifies the initial login<a id="_idIndexMarker474"/> of a user and remains consistent each time the user is automatically logged in to the <span class="No-Break">original session</span></li>
<li><strong class="bold">Token value</strong>: A unique value that changes each time<a id="_idIndexMarker475"/> a user is authenticated using the <span class="No-Break">remember-me feature</span></li>
</ul>
<p>Take a look at the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 7.4 – Exploring the persistent-based remember-me feature" height="700" src="image/B21757_07_4.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Exploring the persistent-based remember-me feature</p>
<p>When the remember-me cookie is submitted, Spring Security will use an <strong class="source-inline">o.s.s.web.authentication.rememberme.PersistentTokenRepository</strong> implementation to look up the expected token value and expiration using the submitted series identifier. It will then compare the token value in the cookie to the expected token value. If the token is not expired and the two tokens match, the user is considered authenticated. A new remember-me cookie with the same series identifier, a new token value, and an updated expiration date will <span class="No-Break">be generated.</span></p>
<p>If the series token submitted<a id="_idIndexMarker476"/> is found in the database, but the tokens do not match, it can be assumed that someone stole the remember-me cookie. In this case, Spring Security will terminate this series of remember-me tokens and warn the user that their login has <span class="No-Break">been compromised.</span></p>
<p>The persisted tokens can be found in the database and viewed with the H2 console, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 7.5 – Getting the persisted token from the database" height="317" src="image/B21757_07_5.jpg" width="831"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Getting the persisted token from the database</p>
<p>After gaining an understanding of how the persistent-based remember-me feature<a id="_idIndexMarker477"/> operates in this chapter, we will delve into the JPA-based <strong class="source-inline">PersistentTokenRepository</strong> in the <span class="No-Break">subsequent section.</span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor248"/>JPA-based PersistentTokenRepository</h2>
<p>As we have seen in the earlier<a id="_idIndexMarker478"/> chapters, using a Spring Data<a id="_idIndexMarker479"/> project for our database mapping can greatly simplify our work. So, to keep things <a id="_idIndexMarker480"/>consistent, we are going to refactor our <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) <strong class="source-inline">PersistentTokenRepository</strong> interface, which uses <strong class="source-inline">JdbcTokenRepositoryImpl</strong>, to one that is JPA-based. We will do so by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>First, let’s create a domain object to hold the persistent logins, as shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/ PersistentLogin.java
@Entity
@Table(name = "persistent_logins")
public class PersistentLogin implements Serializable {
    @Id
    private String series;
    private String username;
    private String token;
    private Date lastUsed;
    public PersistentLogin(){}
    public PersistentLogin(PersistentRememberMeToken token){
        this.series = token.getSeries();
        this.username = token.getUsername();
        this.token = token.getTokenValue();
        this.lastUsed = token.getDate();
    }
// getters/setters omitted for brevity
}</pre></li> <li>Next, we need<a id="_idIndexMarker481"/> to create<a id="_idIndexMarker482"/> an <strong class="source-inline">o.s.d.jpa.repository.JpaRepository </strong>repository instance, as shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/repository/ RememberMeTokenRepository.java
import java.util.Date;
import java.util.List;
import com.packtpub.springsecurity.domain.PersistentLogin;
import org.springframework.data.jpa.repository.JpaRepository;
public interface RememberMeTokenRepository extends JpaRepository&lt;PersistentLogin, String&gt; {
    PersistentLogin findBySeries(String series);
    List&lt;PersistentLogin&gt; findByUsername(String username);
    Iterable&lt;PersistentLogin&gt; findByLastUsedAfter(Date expiration);
}</pre></li> <li>Now, we need to create<a id="_idIndexMarker483"/> a custom <strong class="source-inline">PersistentTokenRepository</strong> interface to replace<a id="_idIndexMarker484"/> the <strong class="source-inline">Jdbc</strong> implementation. We have four methods we must override, but the code should look fairly familiar as we will be using JPA for all of <span class="No-Break">the operations:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/authentication/rememberme/JpaPersistentTokenRepository.java:
public class JpaPersistentTokenRepository implements PersistentTokenRepository {
    private final RememberMeTokenRepository rememberMeTokenRepository;
    public JpaPersistentTokenRepository(RememberMeTokenRepository rememberMeTokenRepository) {
        this.rememberMeTokenRepository = rememberMeTokenRepository;
    }
    @Override
    public void createNewToken(PersistentRememberMeToken token) {
        PersistentLogin newToken = new PersistentLogin(token);
        this.rememberMeTokenRepository.save(newToken);
    }
    @Override
    public void updateToken(String series, String tokenValue, Date lastUsed) {
        PersistentLogin token = this.rememberMeTokenRepository.findBySeries(series);
        if (token != null) {
            token.setToken(tokenValue);
            token.setLastUsed(lastUsed);
            this.rememberMeTokenRepository.save(token);
        }
    }
    @Override
    public PersistentRememberMeToken getTokenForSeries(String seriesId) {
        PersistentLogin token = this.rememberMeTokenRepository.findBySeries(seriesId);
        if(token == null){
            return null;
        } else {
            return new PersistentRememberMeToken(token.getUsername(),
                    token.getSeries(),
                    token.getToken(),
                    token.getLastUsed());
        }
    }
    @Override
    public void removeUserTokens(String username) {
        List&lt;PersistentLogin&gt; tokens = this.rememberMeTokenRepository.findByUsername(username);
        this.rememberMeTokenRepository.deleteAll(tokens);
    }
}</pre></li> <li>Now, we need to make<a id="_idIndexMarker485"/> a few changes<a id="_idIndexMarker486"/> in the <strong class="source-inline">SecurityConfig.java</strong> file to declare the new <strong class="source-inline">PersistentTokenTokenRepository</strong> interface, but the rest of the configuration from the last section does not change, as shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
/src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public PersistentTokenRepository persistentTokenRepository(
       RememberMeTokenRepository rmtr) {
    return new JpaPersistentTokenRepository(rmtr);
}</pre></li> <li>This is all we need to do to switch JDBC to JPA persistent-based remember-me authentication. Go ahead and start up the application and give it a try. From a user standpoint, we do not notice any differences, but we know that the implementation backing<a id="_idIndexMarker487"/> this feature<a id="_idIndexMarker488"/> <span class="No-Break">has changed.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.04-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor249"/>Custom RememberMeServices</h2>
<p>Up to this point, we have used<a id="_idIndexMarker489"/> a fairly simple<a id="_idIndexMarker490"/> implementation of <strong class="source-inline">PersistentTokenRepository</strong>. We have used a JDBC-backed and JPA-backed implementation. This provided limited control over the cookie persistence; if we want more control, we wrap our <strong class="source-inline">PersistentTokenRepository</strong> interface in <strong class="source-inline">RememberMeServices</strong>. Spring Security has a slightly modified version, as previously described, called <strong class="source-inline">PersistentTokenBasedRememberMeServices</strong>, which we can wrap our custom <strong class="source-inline">PersistentTokenRepository</strong> interface in and use in our <span class="No-Break">remember-me service.</span></p>
<p>In the following section, we are going to wrap our existing <strong class="source-inline">PersistentTokenRepository</strong> interface with <strong class="source-inline">PersistentTokenBasedRememberMeServices</strong> and use the <strong class="source-inline">rememberMeServices</strong> method to wire it into our <span class="No-Break">remember-me declaration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
       PersistentTokenRepository persistentTokenRepository, RememberMeServices rememberMeServices) throws Exception {
    http.authorizeHttpRequests( authz -&gt; authz
                .requestMatchers("/webjars/**").permitAll()
…
    // Remember Me
    http.rememberMe(httpSecurityRememberMeConfigurer -&gt; httpSecurityRememberMeConfigurer
          .key("jbcpCalendar")
          .rememberMeServices(rememberMeServices)
          .tokenRepository(persistentTokenRepository));
    return http.build();
}
@Bean
public RememberMeServices rememberMeServices (PersistentTokenRepository ptr, UserDetailsService  userDetailsService){
    PersistentTokenBasedRememberMeServices rememberMeServices = new
          PersistentTokenBasedRememberMeServices("jbcpCalendar",
          userDetailsService, ptr);
    rememberMeServices.setAlwaysRemember(true);
    return rememberMeServices;
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.05-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor250"/>Are database-backed persistent tokens more secure?</h2>
<p>Just like <strong class="source-inline">TokenBasedRememberMeServices</strong>, persistent tokens <a id="_idIndexMarker491"/>may be compromised <a id="_idIndexMarker492"/>by cookie theft or other man-in-the-middle techniques. The use of SSL, as covered in the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional Reference Material</em> can circumvent man-in-the-middle techniques. If you<a id="_idIndexMarker493"/> are using a <strong class="bold">Servlet 5.0</strong> environment (that is, Tomcat 10+), Spring Security will mark the cookie as <strong class="source-inline">HttpOnly</strong>, which will help to mitigate against the cookie being stolen in the event of an XSS vulnerability in the application. To learn more about the <strong class="source-inline">HttpOnly</strong> attribute, refer to the external resource on cookies provided earlier in <span class="No-Break">the chapter.</span></p>
<p>One of the advantages of using the persistent-based remember-me feature is that we can detect whether the cookie is compromised. If the correct series token and an incorrect token are presented, we know that any remember-me feature using that series token should be considered compromised, and we should terminate any sessions associated with it. Since the validation<a id="_idIndexMarker494"/> is stateful, we can also termina<a id="_idTextAnchor251"/>te<a id="_idIndexMarker495"/> the specific remember-me feature wi<a id="_idTextAnchor252"/>thout needing to change the <span class="No-Break">user’s password.</span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor253"/>Cleaning up the expired remember-me sessions</h2>
<p>The downside of using the persistent-based remember-me feature<a id="_idIndexMarker496"/> is that there is no built-in support<a id="_idIndexMarker497"/> for cleaning up the expired sessions. To do this, we need to implement a background process that cleans up the expired sessions. We have included code in the chapter’s sample code to perform <span class="No-Break">the cleanup.</span></p>
<p>For conciseness, we display a version that does not do validation or error handling in the following code snippet. You can view the full version in the sample code of <span class="No-Break">this chapter:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/authentication/rememberme/ JpaTokenRepositoryCleaner.java
public class JpaTokenRepositoryCleaner implements Runnable {
    private Logger logger = LoggerFactory.getLogger(getClass());
    private final RememberMeTokenRepository rememberMeTokenRepository;
    private final long tokenValidityInMs;
    public JpaTokenRepositoryCleaner(RememberMeTokenRepository rememberMeTokenRepository,
                                     long tokenValidityInMs) {
        if (rememberMeTokenRepository == null) {
            throw new IllegalArgumentException("jdbcOperations cannot be null");
        }
        if (tokenValidityInMs &lt; 1) {
            throw new IllegalArgumentException("tokenValidityInMs must be greater than 0. Got " + tokenValidityInMs);
        }
        this.rememberMeTokenRepository = rememberMeTokenRepository;
        this.tokenValidityInMs = tokenValidityInMs;
    }
    public void run() {
        long expiredInMs = System.currentTimeMillis() - tokenValidityInMs;
        logger.info("Searching for persistent logins older than {}ms", tokenValidityInMs);
        try {
            Iterable&lt;PersistentLogin&gt; expired = rememberMeTokenRepository.findByLastUsedAfter(new Date(expiredInMs));
            for(PersistentLogin pl: expired){
                logger.info("*** Removing persistent login for {} ***", pl.getUsername());
                rememberMeTokenRepository.delete(pl);
            }
        } catch(Throwable t) {
            logger.error("**** Could not clean up expired persistent remember me tokens. ***", t);
        }
    }
}</pre> <p>The sample code for this chapter<a id="_idIndexMarker498"/> also includes a simple Spring<a id="_idIndexMarker499"/> configuration that will execute the cleaner every ten minutes. If you are unfamiliar with Spring’s task abstraction and want to learn it, then you may<a id="_idIndexMarker500"/> want to read more about it at <a href="https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml">https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml</a>. You can find the relevant configuration in the following code snippet. For clarity, we are putting this scheduler in the <span class="No-Break"><strong class="source-inline">JavaConfig.java</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ JavaConfig.java@Configuration
@Configuration
@EnableScheduling
public class JavaConfig {
    private RememberMeTokenRepository rememberMeTokenRepository;
    public JavaConfig(RememberMeTokenRepository rememberMeTokenRepository) {
       this.rememberMeTokenRepository = rememberMeTokenRepository;
    }
    @Scheduled(fixedRate = 600_000)
    public void tokenRepositoryCleaner(){
       Thread trct = new Thread(
             new JpaTokenRepositoryCleaner(
                   rememberMeTokenRepository,
                   100_000L));
       trct.start();
    }
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Keep in mind that this configuration is not cluster aware. Therefore, if this is deployed to a cluster, the cleaner<a id="_idIndexMarker501"/> will execute once for every <strong class="bold">Java Virtual Machine (JVM)</strong> that the application is <span class="No-Break">deployed to.</span></p>
<p>Start up the application and give the updates a try. The configuration that was provided will ensure that the cleaner is executed every ten minutes. You may want to change the cleaner task to run more frequently and clean up the more recently used remember-me tokens by modifying the <strong class="source-inline">@Scheduled</strong> declaration. You can then create a few remember-me tokens and see that they get deleted<a id="_idIndexMarker502"/> by querying for them in the H2 <span class="No-Break">database</span><span class="No-Break"><a id="_idIndexMarker503"/></span><span class="No-Break"> console.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.06-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor254"/>The remember-me architecture</h1>
<p>We have gone over<a id="_idIndexMarker504"/> the basic architecture of both <strong class="source-inline">TokenBasedRememberMeServices</strong> and <strong class="source-inline">PersistentTokenBasedRememberMeServices</strong>, but we have not described the overall architecture. Let’s see how all of the remember-me pieces <span class="No-Break">fit together.</span></p>
<p>The following diagram illustrates the different components involved in the process of validating a token-based <span class="No-Break"><strong class="source-inline">remember-me</strong></span><span class="No-Break"> token:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 7.6 – The remember-me architecture" height="878" src="image/B21757_07_6.jpg" width="1147"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The remember-me architecture</p>
<p>As with any of the Spring Security filters, <strong class="source-inline">RememberMeAuthenticationFilter</strong> is invoked from within <strong class="source-inline">FilterChainProxy</strong>. The job of <strong class="source-inline">RememberMeAuthenticationFilter</strong> is to inspect the request, and if it is of interest, an action is taken. The <strong class="source-inline">RememberMeAuthenticationFilter</strong> interface will use the <strong class="source-inline">RememberMeServices</strong> implementation to determine whether the user is already logged in. The <strong class="source-inline">RememberMeServices</strong> interface does this by inspecting the HTTP request for a remember-me cookie that is then validated using either the token-ba<a id="_idTextAnchor255"/>sed validation or the persistent-based<a id="_idIndexMarker505"/> validation we previously discussed.<a id="_idTextAnchor256"/> If the token checks out, the user will be <span class="No-Break">logged in.</span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor257"/>Remember-me and the user life cycle</h2>
<p>The implementation <a id="_idIndexMarker506"/>of <strong class="source-inline">RememberMeServices</strong> is invoked at several points in the user life cycle (the life cycle of an authenticated user’s session). To assist you in your understanding of the remember-me functionality, it can be helpful to be aware of the points in time when remember-me services are informed of life <span class="No-Break">cycle functions:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Action</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">What </strong><span class="No-Break"><strong class="bold">should happen?</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">The RememberMeServices </strong><span class="No-Break"><strong class="bold">method invoked</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Successful login</span></p>
</td>
<td class="No-Table-Style">
<p>The implementation sets a remember-me cookie (if the <strong class="source-inline">form</strong> parameter has <span class="No-Break">been sent)</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">loginSuccess</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Failed login</span></p>
</td>
<td class="No-Table-Style">
<p>The implementation should cancel the cookie if <span class="No-Break">it’s present</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">loginFailed</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">User logout</span></p>
</td>
<td class="No-Table-Style">
<p>The implementation should cancel the cookie if <span class="No-Break">it’s present</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Logout</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.8 – Remember-me life cycle events</p>
<p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline">logout</strong> method is not present on the <strong class="source-inline">RememberMeServices</strong> interface. Instead, each <strong class="source-inline">RememberMeServices</strong> implementation also implements the <strong class="source-inline">LogoutHandler</strong> interface, which contains the <strong class="source-inline">logout</strong> method. By implementing the <strong class="source-inline">LogoutHandler</strong> interface, each <strong class="source-inline">RememberMeServices</strong> implementation can perform the necessary cleanup when the user <span class="No-Break">logs out.</span></p>
<p>Knowing where and how <strong class="source-inline">RememberMeServices</strong> ties into the user’s life cycle will be important when we begin to create custom authentication handlers because we need to ensure that any authentication<a id="_idIndexMarker507"/> processor treats <strong class="source-inline">RememberMeServices</strong> consistently to preserve the usefulness and security of <span class="No-Break">this functionality.</span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor258"/>Restricting the remember-me feature to an IP address</h2>
<p>Let’s put our understanding<a id="_idIndexMarker508"/> of the remember-me architecture<a id="_idIndexMarker509"/> to use. A common requirement is that any remember-me token should be tied to the IP address of the user who created it. This adds additional security to the remember-me feature. To do this, we only need to implement a custom <strong class="source-inline">PersistentTokenRepository</strong> interface. The configuration changes that we will make will illustrate how to configure a custom <strong class="source-inline">RememberMeServices</strong>. Throughout this section, we will take a look at <strong class="source-inline">IpAwarePersistentTokenRepository</strong>, which is included in the chapter’s source code. The <strong class="source-inline">IpAwarePersistenTokenRepository</strong> interface ensures that the series identifier is internally combined with the current user’s IP address, and the series identifier includes only the identifier externally. This means that whenever a token is looked up or saved, the current IP address is used to look up or persist the token. In the following code snippets, you can see how <strong class="source-inline">IpAwarePersistentTokenRepository</strong> works. If you want to dig in even deeper, we encourage you to view the source code included in <span class="No-Break">the chapter.</span></p>
<p>The trick to looking<a id="_idIndexMarker510"/> up the IP address is using <strong class="source-inline">RequestContextHolder</strong> of Spring<a id="_idIndexMarker511"/> Security. The relevant code is <span class="No-Break">as follows:</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">It should be noted that to use <strong class="source-inline">RequestContextHolder</strong>, you need to ensure you have set up your <strong class="source-inline">web.xml</strong> file to use <strong class="source-inline">RequestContextListener</strong>. We have already performed this setup for our sample code. However, this can be useful when utilizing the example code in an external application. Refer to the Javadoc of <strong class="source-inline">IpAwarePersistentTokenRepository</strong> for details on how to set <span class="No-Break">this up.</span></p>
<p>Take a look at the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/authentication/rememberme/ IpAwarePersistentTokenRepository.java
private String ipSeries(String series) {
    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
    if (attributes == null) {
        throw new IllegalStateException("RequestContextHolder.getRequestAttributes() cannot be null");
    }
    String remoteAddr = attributes.getRequest().getRemoteAddr();
    logger.debug("Remote address is {}", remoteAddr);
    return series + remoteAddr;
}</pre> <p>We can build on this method<a id="_idIndexMarker512"/> to force tokens that are saved to include<a id="_idIndexMarker513"/> the IP address in the series identifier, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@Override
public void createNewToken(PersistentRememberMeToken token) {
    String ipSeries = ipSeries(token.getSeries());
    PersistentRememberMeToken ipToken = tokenWithSeries(token, ipSeries);
    this.delegateRepository.createNewToken(ipToken);
}</pre> <p>You can see that we first created a new series with the IP address concatenated <span class="No-Break">to it.</span></p>
<p>The <strong class="source-inline">tokenWithSeries</strong> method is just a helper that creates a new token with all of the same values, except a new series. We then submit the new token with a series identifier, which includes the IP address, to <strong class="source-inline">delegateRepository</strong>, which is the original implementation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">PersistentTokenRepository</strong></span><span class="No-Break">.</span></p>
<p>Whenever the tokens are looked up, we require that the current user’s IP address is appended to the series identifier. This means that there is no way for a user to obtain a token for a user with a different <span class="No-Break">IP address:</span></p>
<pre class="source-code">
@Override
public PersistentRememberMeToken getTokenForSeries(String seriesId) {
    String ipSeries = ipSeries(seriesId);
    PersistentRememberMeToken ipToken = delegateRepository.getTokenForSeries(ipSeries);
    return tokenWithSeries(ipToken, seriesId);
}</pre> <p>The remainder of the code<a id="_idIndexMarker514"/> is quite similar. Internally, we construct<a id="_idIndexMarker515"/> the series identifier to be appended to the IP address, and externally, we present only the original series identifier. By doing this, we enforce the constraint that only the user who created the remember-me token can <span class="No-Break">use it.</span></p>
<p>Let’s review the Spring configuration included in this chapter’s sample code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">IpAwarePersistent</strong></span><strong class="source-inline">
TokenRepository</strong>. In the following code snippet, we first create <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">IpAwarePersistent</strong></span><strong class="source-inline">
TokenRepository</strong> declaration that wraps a new <strong class="source-inline">JpaPersistentTokenRepository</strong> declaration. We then initialize a <strong class="source-inline">RequestContextFilter</strong> class by instantiating an <span class="No-Break"><strong class="source-inline">OrderedRequestContextFilter</strong></span><span class="No-Break"> interface:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public RememberMeServices rememberMeServices(PersistentTokenRepository ptr, UserDetailsService userDetailsService) {
    PersistentTokenBasedRememberMeServices rememberMeServices = new
          PersistentTokenBasedRememberMeServices("jbcpCalendar",
          userDetailsService, ptr);
    rememberMeServices.setAlwaysRemember(true);
    return rememberMeServices;
}
@Bean
public IpAwarePersistentTokenRepository tokenRepository(RememberMeTokenRepository rmtr) {
    return new IpAwarePersistentTokenRepository(new JpaPersistentTokenRepository(rmtr));
}
@Bean
public OrderedRequestContextFilter requestContextFilter() {
    return new OrderedRequestContextFilter();
}</pre> <p>Now, go ahead and start up the application. You can use the second computer along with a plugin, such as Firebug, to manipulate your remember-me cookie. If you try to use the remember-me cookie from one computer on another computer, Spring Security will now ignore the remember-me request and delete the <span class="No-Break">associated cookie.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.07-calendar</strong></span><span class="No-Break">.</span></p>
<p>Note that the IP-based remember-me tokens may behave unexpectedly if the user is behind a shared or load-balanced<a id="_idIndexMarker516"/> network infrastructure, such as a multi <strong class="bold">Wide-Area Network (WAN)</strong> corporate environment. In most scenarios, however, the addition of an IP address<a id="_idIndexMarker517"/> to the remember-me function<a id="_idIndexMarker518"/> provides an additional, welcome layer of security to a helpful <span class="No-Break">user feature.</span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor259"/>Custom cookie and HTTP parameter names</h1>
<p>Curious users may wonder<a id="_idIndexMarker519"/> whether the expected <a id="_idIndexMarker520"/>value of the remember-me form field checkbox to be remember-me, or the cookie name to be remember-me, can be changed to obscure the use of Spring Security. This change can be made in one of two locations. Take a look at the <span class="No-Break">following steps:</span></p>
<ol>
<li>We can simply define more properties to change the checkbox and cookie names in <strong class="source-inline">RememberMeServices</strong> <strong class="source-inline">bean</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public RememberMeServices rememberMeServices(PersistentTokenRepository ptr, UserDetailsService userDetailsService) {
    PersistentTokenBasedRememberMeServices rememberMeServices = new
          PersistentTokenBasedRememberMeServices("jbcpCalendar",
          userDetailsService, ptr);
    rememberMeServices.setAlwaysRemember(true);
    rememberMeServices.setParameter("obscure-remember-me");
    rememberMeServices.setCookieName("obscure-remember-me");
    return rememberMeServices;
}</pre></li> <li>Don’t forget to change the <strong class="source-inline">login.xhtml</strong> page to set the name of the <strong class="source-inline">checkbox form field</strong> and to match the parameter value we declared. Go ahead and make the updates to <strong class="source-inline">login.xhtml</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/resources/templates/login.xhtml
&lt;div class="mb-3"&gt;
    &lt;label for="remember-me"&gt;Remember Me?&lt;/label&gt;
    &lt;input type="checkbox" id="remember-me" name="obscure-remember-me" th:checked="true" /&gt;
&lt;/div&gt;</pre></li> <li>We’d encourage you to experiment<a id="_idIndexMarker521"/> here to ensure you understand how these settings<a id="_idIndexMarker522"/> are related. Go ahead and start up the application and give it <span class="No-Break">a try.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter07.08-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor260"/>Summary</h1>
<p>This chapter explained and demonstrated the use of the remember-me feature in Spring Security. We started with the most basic setup and learned how to gradually make the feature more secure. Specifically, we learned about a token-based remember-me service and how to configure it. We also explore how persistent-based remember-me services can provide additional security, how they work, and the additional considerations necessary when <span class="No-Break">using them.</span></p>
<p>We also covered the creation of a custom remember-me implementation that restricts the remember-me token to a specific IP address. We saw various other ways to make the remember-me feature <span class="No-Break">more secure.</span></p>
<p>Up next is <strong class="bold">certificate-based authentication</strong>, and we will discuss how to use trusted client-side certificates to <span class="No-Break">perform authentication.</span></p>
</div>
</div></body></html>