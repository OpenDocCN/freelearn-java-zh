- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mapping between Boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we’ve discussed the web, application, domain, and
    persistence layers and what each of those layers contributes to implementing a
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: We have, however, barely touched on the dreaded and omnipresent topic of mapping
    between the models of each layer. I bet you’ve had a discussion at some point
    about whether to use the same model in two layers in order to avoid implementing
    a mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument might have gone something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro-mapping developer:'
  prefs: []
  type: TYPE_NORMAL
- en: “*If we don’t map between layers, we have to use the same model in both layers,
    which means that the layers will be* *tightly coupled!*”
  prefs: []
  type: TYPE_NORMAL
- en: 'Contra-mapping developer:'
  prefs: []
  type: TYPE_NORMAL
- en: “*But if we do map between layers, we produce a lot of boilerplate code, which
    is overkill for many use cases since they’re only doing CRUD and have the same
    model across* *layers anyways!*”
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case in discussions such as this, there’s truth to both sides
    of the argument. Let’s discuss some mapping strategies with their pros and cons
    and see whether we can help these developers make a decision.
  prefs: []
  type: TYPE_NORMAL
- en: The “No Mapping” strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first strategy is actually not mapping at all.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – If the port interfaces use the domain model as the input and
    output model, we can choose not to map between layers](img/Figure_09.1._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – If the port interfaces use the domain model as the input and output
    model, we can choose not to map between layers
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.1* shows the components that are relevant for the *Send Money*
    use case from our BuckPal example application.'
  prefs: []
  type: TYPE_NORMAL
- en: In the web layer, the web controller calls the `SendMoneyUseCase` interface
    to execute the use case. This interface takes an `Account` object as an argument.
    This means that both the web and application layers need access to the `Account`
    class – both are using the same model.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of the application, we have the same relationship between
    the persistence and application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Since all layers use the same model, we don’t need to implement mapping between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: But what are the consequences of this design?
  prefs: []
  type: TYPE_NORMAL
- en: The web and persistence layers may have special requirements for their models.
    If our web layer exposes its model via REST, for instance, the model classes might
    need some annotations that define how to serialize certain fields into JSON. The
    same is true for the persistence layer if we’re using an **object-relational mapping**
    (**ORM**) framework, which might require some annotations that define the database
    mapping. The framework might also require the class to follow a certain contract.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, all of those special requirements have to be dealt with in the
    `Account` domain model class, even though the domain and application layers are
    not interested in them. This violates the Single Responsibility Principle since
    the `Account` class has to be changed for reasons related to the web, application,
    and persistence layers.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the technical requirements, each layer might require certain custom
    fields on the `Account` class. This might lead to a fragmented domain model with
    certain fields only relevant in one layer.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean, though, that we should never, ever implement a “no mapping”
    strategy? Certainly not. Even though it might feel dirty, a “no mapping” strategy
    can be perfectly valid.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a simple CRUD use case. Do we really need to map the same fields from
    the web model into the domain model and from the domain model into the persistence
    model? I’d say we don’t.
  prefs: []
  type: TYPE_NORMAL
- en: And what about those JSON or ORM annotations on the domain model? Do they really
    bother us? Even if we have to change an annotation or two in the domain model
    if something changes in the persistence layer, so what?
  prefs: []
  type: TYPE_NORMAL
- en: As long as all layers need exactly the same information in exactly the same
    structure, a “no mapping” strategy is a perfectly valid option.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we’re dealing with web or persistence issues in the application or
    domain layer (aside from annotations, perhaps), however, we should move to another
    mapping strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lesson for the two developers from the introduction here: even though
    we have decided on a certain mapping strategy in the past, we can change it later.'
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, many use cases start their life as simple CRUD use cases.
    Later, they might grow into a full-fledged business use case with rich behavior
    and validations that justify a more expensive mapping strategy. Or they might
    forever keep their CRUD status, in which case, we’re glad that we haven’t invested
    in a different mapping strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The “Two-Way” mapping strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mapping strategy where each layer has its own model is what I call the “Two-Way”
    mapping strategy, as outlined in *Figure 9**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – With each adapter having its own model, the adapters are responsible
    for mapping their model into the domain model and back](img/Figure_09.2._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – With each adapter having its own model, the adapters are responsible
    for mapping their model into the domain model and back
  prefs: []
  type: TYPE_NORMAL
- en: Each layer has its own model, which may have a structure that is completely
    different from the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: The web layer maps the web model into the input model that is expected by the
    incoming ports. It also maps domain objects returned by the incoming ports back
    into the web model.
  prefs: []
  type: TYPE_NORMAL
- en: The persistence layer is responsible for a similar mapping between the domain
    model, which is used by the outgoing ports, and the persistence model.
  prefs: []
  type: TYPE_NORMAL
- en: Both layers map in two directions, hence the name “Two-Way” mapping.
  prefs: []
  type: TYPE_NORMAL
- en: With each layer having its own model, it can modify its own model without affecting
    the other layers (as long as the contents are unchanged). The web model can have
    a structure that allows for optimal presentation of the data. The domain model
    can have a structure that best allows for implementing the use cases. And the
    persistence model can have the structure needed by an OR-mapper for persisting
    objects to a database.
  prefs: []
  type: TYPE_NORMAL
- en: This mapping strategy also leads to a clean domain model that is not dirtied
    by web or persistence concerns. It does not contain JSON or ORM mapping annotations.
    The Single Responsibility Principle is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another bonus of “Two-Way” mapping is that, after the “No Mapping” strategy,
    it’s conceptually the simplest mapping strategy. The mapping responsibilities
    are clear: the outer layers/adapters map into the model of the inner layers and
    back. The inner layers only know their own model and can concentrate on the domain
    logic instead of mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: As with every mapping strategy, the “Two-Way” mapping also has its drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it usually ends up in a lot of boilerplate code. Even if we use
    one of the many mapping frameworks out there to reduce the amount of code, implementing
    the mapping between models usually takes up a good portion of our time. This is
    partly due to the fact that debugging mapping logic is a pain – especially when
    using a mapping framework that hides its inner workings behind a layer of generic
    code and reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential drawback is that the incoming and outgoing ports use domain
    objects as input parameters and return values. The adapters map these into their
    own model, but this still creates more coupling between the layers than if we
    introduce a dedicated “transport model” as in the “full” mapping strategy we’re
    going to discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the “No Mapping” strategy, the “Two-Way” mapping strategy is not a
    silver bullet. In many projects, however, this kind of mapping is considered a
    holy law that we have to comply with throughout the whole code base, even for
    the simplest CRUD use cases. This unnecessarily slows down development.
  prefs: []
  type: TYPE_NORMAL
- en: No single mapping strategy should be considered an iron law. Instead, we should
    decide for each use case.
  prefs: []
  type: TYPE_NORMAL
- en: The “Full” mapping strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another mapping strategy is what I call the “Full” mapping strategy, as outlined
    in *Figure 9**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – With each operation requiring its own model, the web adapter
    and application layer each map their model into the model expected by the operation
    they want to execute](img/Figure_09.3._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – With each operation requiring its own model, the web adapter and
    application layer each map their model into the model expected by the operation
    they want to execute
  prefs: []
  type: TYPE_NORMAL
- en: This mapping strategy introduces a separate input and output model per operation.
    Instead of using the domain model to communicate across layer boundaries, we use
    a model specific to each operation, such as `SendMoneyCommand`, which acts as
    an input model to the `SendMoneyUseCase` port in the figure. We can call those
    models “commands,” “requests,” or similar.
  prefs: []
  type: TYPE_NORMAL
- en: The web layer is responsible for mapping its input into the command object of
    the application layer. Such a command makes the interface to the application layer
    very explicit, with little room for interpretation. Each use case has its own
    command with its own fields and validations. There’s no guessing involved as to
    which fields should be filled and which fields would be better left empty since
    they would otherwise trigger a validation we don’t want for our current use case.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer is then responsible for mapping the command object into
    whatever it needs to modify the domain model according to the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, mapping from one layer into many different commands requires even
    more mapping code than mapping between a single web model and a domain model.
    This mapping, however, is significantly easier to implement and maintain than
    a mapping that has to handle the needs of many use cases instead of only one.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t advocate this mapping strategy as a global pattern. It plays out its
    advantages best between the web layer (or any other incoming adapter) and the
    application layer to clearly demarcate the state-modifying use cases of the application.
    I would not use it between the application and persistence layers due to the mapping
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, I would restrict this kind of mapping to the input model of operations
    and simply use a domain object as the output model. `SendMoneyUseCase` might then
    return an `Account` object with the updated balance, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the mapping strategies can and should be mixed. No single mapping
    strategy needs to be a global rule across all layers.
  prefs: []
  type: TYPE_NORMAL
- en: The “One-Way” mapping strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is yet another mapping strategy with another set of pros and cons: the
    “One-Way” strategy visualized in *Figure 9**.4*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – With the domain model and the adapter models implementing the
    same “state” interface, each layer only needs to map objects it receives from
    other layers one way](img/Figure_09.4._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – With the domain model and the adapter models implementing the same
    “state” interface, each layer only needs to map objects it receives from other
    layers one way
  prefs: []
  type: TYPE_NORMAL
- en: In this strategy, the models in all layers implement the same interface, which
    encapsulates the state of the domain model by providing getter methods on the
    relevant attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The domain model itself can implement a rich behavior, which we can access from
    our services within the application layer. If we want to pass a domain object
    to the outer layers, we can do so without mapping since the domain object implements
    the state interface expected by the incoming and outgoing ports.
  prefs: []
  type: TYPE_NORMAL
- en: The outer layers can then decide whether they can work with the interface or
    whether they need to map it into their own model. They cannot inadvertently modify
    the state of the domain object since the modifying behavior is not exposed by
    the state interface.
  prefs: []
  type: TYPE_NORMAL
- en: Objects we pass from an outer layer into the application layer also implement
    this state interface. The application layer then has to map it into the real domain
    model in order to get access to its behavior. This mapping plays well with the
    **Domain-Driven Design** concept of a factory. A factory in terms of DDD is responsible
    for reconstituting a domain object from a certain state, which is exactly what
    we’re doing.[1](#footnote-032)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-032-backlink) Factory*: Domain Driven Design* by Eric Evans,
    Addison-Wesley, 2004, p. 158.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapping responsibility is clear: if a layer receives an object from another
    layer, we map it into something the layer can work with. Thus, each layer only
    maps one way, making this a “One-Way” mapping strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: With the mapping distributed across layers, however, this strategy is conceptually
    more difficult than the other strategies.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy plays out its strength best if the models across the layers are
    similar. For read-only operations, for instance, the web layer then might not
    need to map into its own model at all since the state interface provides all the
    information it needs.
  prefs: []
  type: TYPE_NORMAL
- en: When to use which mapping strategy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the million-dollar question, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the usual, dissatisfying *it depends*.
  prefs: []
  type: TYPE_NORMAL
- en: Since each mapping strategy has different advantages and disadvantages, we should
    resist the urge to define a single strategy as a hard-and-fast global rule for
    the whole code base. This goes against our instincts, as it feels untidy to mix
    patterns within the same code base. But knowingly choosing a pattern that is not
    the best pattern for a certain job, just to serve our sense of tidiness, is irresponsible,
    plain and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as software evolves over time, the strategy that was the best for the
    job yesterday might not still be the best for the job today. Instead of starting
    with a fixed mapping strategy and keeping it over time – no matter what – we might
    start with a simple strategy that allows us to quickly evolve the code and later
    move to a more complex one that helps us to better decouple the layers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to decide which strategy to use when, we need to agree upon a set of
    guidelines within the team. These guidelines should answer the question of which
    mapping strategy should be the first choice in which situation. They should also
    answer *why* they are the first choice so that we’re able to evaluate whether
    those reasons still apply after some time.
  prefs: []
  type: TYPE_NORMAL
- en: We might, for example, define different mapping guidelines to modifying use
    cases than we do to queries. Also, we might want to use different mapping strategies
    between the web and application layers and between the application and persistence
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guidelines for these situations might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: If we’re working on a modifying use case, the “Full” mapping strategy is the
    first choice between the web and application layer, in order to decouple the use
    cases from one another. This gives us clear per-use-case validation rules and
    we don’t have to deal with fields we don’t need in a certain use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we’re working on a modifying use case, the “No Mapping” strategy is the first
    choice between the application and persistence layer in order to be able to quickly
    evolve the code without mapping overhead. As soon as we have to deal with persistence
    issues in the application layer, however, we move to a “Two-Way” mapping strategy
    to keep persistence issues in the persistence layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we’re working on a query, the “No Mapping” strategy is the first choice between
    the web and application layer and between the application and persistence layer
    in order to be able to quickly evolve the code without mapping overhead. As soon
    as we have to deal with web or persistence issues in the application layer, however,
    we move to a “Two-Way” mapping strategy between the web and application layer
    or the application layer and persistence layer, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to successfully apply guidelines like these, they must be present in
    the minds of the developers. So, the guidelines should be discussed and revised
    continuously as a team effort.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incoming and outgoing ports act as gatekeepers between the layers of our application.
    They define how the layers communicate with each other, and how we map models
    across layers.
  prefs: []
  type: TYPE_NORMAL
- en: With narrow ports in place for each use case, we can choose different mapping
    strategies for different use cases, and even evolve them over time without affecting
    other use cases, thus selecting the best strategy for a certain situation at a
    certain time.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a different mapping strategy for each use case is harder and requires
    more communication than simply using the same mapping strategy for all situations,
    but it will reward the team with a code base that does just what it needs to do
    and is easier to maintain, as long as the mapping guidelines are known.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know which components make up our application and how they communicate,
    we can explore how to assemble a working application out of the different components.
  prefs: []
  type: TYPE_NORMAL
