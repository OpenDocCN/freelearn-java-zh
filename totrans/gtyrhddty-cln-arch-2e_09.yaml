- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Mapping between Boundaries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界之间的映射
- en: In the previous chapters, we’ve discussed the web, application, domain, and
    persistence layers and what each of those layers contributes to implementing a
    use case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了网络、应用、领域和持久层以及每个层对实现用例的贡献。
- en: We have, however, barely touched on the dreaded and omnipresent topic of mapping
    between the models of each layer. I bet you’ve had a discussion at some point
    about whether to use the same model in two layers in order to avoid implementing
    a mapper.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们几乎还没有触及到令人恐惧且无处不在的主题，即层之间模型之间的映射。我敢打赌，你可能在某个时候讨论过是否在两层中使用相同的模型以避免实现映射器。
- en: 'The argument might have gone something like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 争论可能如下进行：
- en: 'Pro-mapping developer:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 支持映射的开发者：
- en: “*If we don’t map between layers, we have to use the same model in both layers,
    which means that the layers will be* *tightly coupled!*”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “*如果我们不在层之间进行映射，我们不得不在两层中使用相同的模型，这意味着层将* *紧密耦合!*”
- en: 'Contra-mapping developer:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 反对映射的开发者：
- en: “*But if we do map between layers, we produce a lot of boilerplate code, which
    is overkill for many use cases since they’re only doing CRUD and have the same
    model across* *layers anyways!*”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “*但是如果我们确实在层之间进行映射，我们将产生大量的样板代码，这对于许多用例来说都是过度的，因为它们只进行CRUD操作，并且层之间已经使用相同的模型了!*”
- en: As is often the case in discussions such as this, there’s truth to both sides
    of the argument. Let’s discuss some mapping strategies with their pros and cons
    and see whether we can help these developers make a decision.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类讨论中，通常双方的观点都有一定的真实性。让我们讨论一些映射策略及其优缺点，看看我们是否可以帮助这些开发者做出决定。
- en: The “No Mapping” strategy
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “无映射”策略
- en: The first strategy is actually not mapping at all.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略实际上根本不进行映射。
- en: '![Figure 9.1 – If the port interfaces use the domain model as the input and
    output model, we can choose not to map between layers](img/Figure_09.1._B19916.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 如果端口接口使用领域模型作为输入和输出模型，我们可以选择不在层之间进行映射](img/Figure_09.1._B19916.jpg)'
- en: Figure 9.1 – If the port interfaces use the domain model as the input and output
    model, we can choose not to map between layers
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 如果端口接口使用领域模型作为输入和输出模型，我们可以选择不在层之间进行映射
- en: '*Figure 9**.1* shows the components that are relevant for the *Send Money*
    use case from our BuckPal example application.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.1*显示了与我们BuckPal示例应用中的“发送金钱”用例相关的组件。'
- en: In the web layer, the web controller calls the `SendMoneyUseCase` interface
    to execute the use case. This interface takes an `Account` object as an argument.
    This means that both the web and application layers need access to the `Account`
    class – both are using the same model.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络层，网络控制器调用`SendMoneyUseCase`接口来执行用例。此接口接受一个`Account`对象作为参数。这意味着网络层和应用层都需要访问`Account`类——它们都在使用相同的模型。
- en: On the other side of the application, we have the same relationship between
    the persistence and application layer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的反面，我们也有持久层和应用层之间相同的关系。
- en: Since all layers use the same model, we don’t need to implement mapping between
    them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有层都使用相同的模型，我们不需要在它们之间实现映射。
- en: But what are the consequences of this design?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种设计的后果是什么？
- en: The web and persistence layers may have special requirements for their models.
    If our web layer exposes its model via REST, for instance, the model classes might
    need some annotations that define how to serialize certain fields into JSON. The
    same is true for the persistence layer if we’re using an **object-relational mapping**
    (**ORM**) framework, which might require some annotations that define the database
    mapping. The framework might also require the class to follow a certain contract.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层和持久层可能对其模型有特殊要求。例如，如果我们的网络层通过REST公开其模型，模型类可能需要一些注解来定义如何将某些字段序列化为JSON。如果我们在使用**对象关系映射**（**ORM**）框架时也是如此，这可能会要求一些注解来定义数据库映射。框架还可能要求类遵循某种契约。
- en: In the example, all of those special requirements have to be dealt with in the
    `Account` domain model class, even though the domain and application layers are
    not interested in them. This violates the Single Responsibility Principle since
    the `Account` class has to be changed for reasons related to the web, application,
    and persistence layers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，所有那些特殊要求都必须在`Account`领域模型类中处理，即使领域层和应用层对它们不感兴趣。这违反了单一职责原则，因为`Account`类必须因为与网络、应用和持久层相关的原因而更改。
- en: Aside from the technical requirements, each layer might require certain custom
    fields on the `Account` class. This might lead to a fragmented domain model with
    certain fields only relevant in one layer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术要求之外，每一层可能还需要在`Account`类上某些自定义字段。这可能导致领域模型碎片化，某些字段仅在某一层中相关。
- en: Does this mean, though, that we should never, ever implement a “no mapping”
    strategy? Certainly not. Even though it might feel dirty, a “no mapping” strategy
    can be perfectly valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这难道意味着我们永远不应该实施“无映射”策略吗？当然不是。尽管这可能感觉有些不妥，但“无映射”策略可以完全有效。
- en: Consider a simple CRUD use case. Do we really need to map the same fields from
    the web model into the domain model and from the domain model into the persistence
    model? I’d say we don’t.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的CRUD用例。我们真的需要将相同的字段从网络模型映射到领域模型，再从领域模型映射到持久化模型吗？我认为我们不需要。
- en: And what about those JSON or ORM annotations on the domain model? Do they really
    bother us? Even if we have to change an annotation or two in the domain model
    if something changes in the persistence layer, so what?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么那些在领域模型上的JSON或ORM注解呢？它们真的会困扰我们吗？即使我们必须在持久化层发生变化时更改领域模型中的一个或两个注解，那又如何呢？
- en: As long as all layers need exactly the same information in exactly the same
    structure, a “no mapping” strategy is a perfectly valid option.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有层都需要在完全相同的结构中精确地获取相同的信息，那么“无映射”策略就是一个完全有效的选择。
- en: As soon as we’re dealing with web or persistence issues in the application or
    domain layer (aside from annotations, perhaps), however, we should move to another
    mapping strategy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们在应用或领域层（除了注解之外）处理网络或持久化问题，我们应转向另一种映射策略。
- en: 'There is a lesson for the two developers from the introduction here: even though
    we have decided on a certain mapping strategy in the past, we can change it later.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里引入的教训对两位开发者来说很重要：尽管我们过去决定了一种特定的映射策略，但我们可以在以后更改它。
- en: In my experience, many use cases start their life as simple CRUD use cases.
    Later, they might grow into a full-fledged business use case with rich behavior
    and validations that justify a more expensive mapping strategy. Or they might
    forever keep their CRUD status, in which case, we’re glad that we haven’t invested
    in a different mapping strategy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，许多用例最初都是简单的CRUD用例。后来，它们可能发展成为具有丰富行为和验证的完整业务用例，这证明了更昂贵的映射策略的合理性。或者它们可能永远保持CRUD状态，在这种情况下，我们很高兴我们没有投资于不同的映射策略。
- en: The “Two-Way” mapping strategy
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “双向”映射策略
- en: A mapping strategy where each layer has its own model is what I call the “Two-Way”
    mapping strategy, as outlined in *Figure 9**.2*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都有自己的模型，这种映射策略我称之为“双向”映射策略，如*图9.2*所示。2*。
- en: '![Figure 9.2 – With each adapter having its own model, the adapters are responsible
    for mapping their model into the domain model and back](img/Figure_09.2._B19916.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 每个适配器都有自己的模型，适配器负责将模型映射到领域模型并返回](img/Figure_09.2._B19916.jpg)'
- en: Figure 9.2 – With each adapter having its own model, the adapters are responsible
    for mapping their model into the domain model and back
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 每个适配器都有自己的模型，适配器负责将模型映射到领域模型，并返回
- en: Each layer has its own model, which may have a structure that is completely
    different from the domain model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都有自己的模型，其结构可能与领域模型完全不同。
- en: The web layer maps the web model into the input model that is expected by the
    incoming ports. It also maps domain objects returned by the incoming ports back
    into the web model.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层将网络模型映射到入站端口期望的输入模型。它还将入站端口返回的领域对象映射回网络模型。
- en: The persistence layer is responsible for a similar mapping between the domain
    model, which is used by the outgoing ports, and the persistence model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化层负责在用于出站端口的领域模型和持久化模型之间进行类似的映射。
- en: Both layers map in two directions, hence the name “Two-Way” mapping.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两个层都进行双向映射，因此命名为“双向”映射。
- en: With each layer having its own model, it can modify its own model without affecting
    the other layers (as long as the contents are unchanged). The web model can have
    a structure that allows for optimal presentation of the data. The domain model
    can have a structure that best allows for implementing the use cases. And the
    persistence model can have the structure needed by an OR-mapper for persisting
    objects to a database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每一层都有自己的模型，它可以修改自己的模型而不影响其他层（只要内容没有改变）。网络模型可以有一个结构，允许最佳地展示数据。领域模型可以有一个结构，最好地实现用例。持久性模型可以有一个结构，满足ORM映射器将对象持久化到数据库所需的结构。
- en: This mapping strategy also leads to a clean domain model that is not dirtied
    by web or persistence concerns. It does not contain JSON or ORM mapping annotations.
    The Single Responsibility Principle is satisfied.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射策略还导致了一个干净的领域模型，它不会受到网络或持久性问题的污染。它不包含JSON或ORM映射注解。满足了单一职责原则。
- en: 'Another bonus of “Two-Way” mapping is that, after the “No Mapping” strategy,
    it’s conceptually the simplest mapping strategy. The mapping responsibilities
    are clear: the outer layers/adapters map into the model of the inner layers and
    back. The inner layers only know their own model and can concentrate on the domain
    logic instead of mapping.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “双向”映射的另一个优点是，在“无映射”策略之后，它在概念上是最简单的映射策略。映射责任是清晰的：外层/适配器映射到内层模型的模型，并返回。内层只知道自己的模型，可以专注于领域逻辑而不是映射。
- en: As with every mapping strategy, the “Two-Way” mapping also has its drawbacks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与每种映射策略一样，“双向”映射也有其缺点。
- en: First of all, it usually ends up in a lot of boilerplate code. Even if we use
    one of the many mapping frameworks out there to reduce the amount of code, implementing
    the mapping between models usually takes up a good portion of our time. This is
    partly due to the fact that debugging mapping logic is a pain – especially when
    using a mapping framework that hides its inner workings behind a layer of generic
    code and reflection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它通常会导致大量的样板代码。即使我们使用许多映射框架之一来减少代码量，实现模型之间的映射通常也会占用我们大量的时间。这部分原因是调试映射逻辑很痛苦——尤其是在使用一个隐藏其内部工作原理在通用代码和反射层之后的映射框架时。
- en: Another potential drawback is that the incoming and outgoing ports use domain
    objects as input parameters and return values. The adapters map these into their
    own model, but this still creates more coupling between the layers than if we
    introduce a dedicated “transport model” as in the “full” mapping strategy we’re
    going to discuss next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的缺点是，传入和传出的端口使用领域对象作为输入参数和返回值。适配器将这些映射到它们自己的模型，但这仍然比我们引入一个专门的“传输模型”（如我们接下来要讨论的“完全”映射策略）创建了更多的层间耦合。
- en: Just like the “No Mapping” strategy, the “Two-Way” mapping strategy is not a
    silver bullet. In many projects, however, this kind of mapping is considered a
    holy law that we have to comply with throughout the whole code base, even for
    the simplest CRUD use cases. This unnecessarily slows down development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“无映射”策略一样，“双向”映射策略也不是万能的。然而，在许多项目中，这种映射被认为是一条神圣的法律，我们必须在整个代码库中遵守，即使是对于最简单的CRUD用例。这无必要地减慢了开发速度。
- en: No single mapping strategy should be considered an iron law. Instead, we should
    decide for each use case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该将任何单一的映射策略视为铁律。相反，我们应该为每个用例做出决定。
- en: The “Full” mapping strategy
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “完全”映射策略
- en: Another mapping strategy is what I call the “Full” mapping strategy, as outlined
    in *Figure 9**.3*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种映射策略是我所说的“完全”映射策略，如*图9.3*所示。
- en: '![Figure 9.3 – With each operation requiring its own model, the web adapter
    and application layer each map their model into the model expected by the operation
    they want to execute](img/Figure_09.3._B19916.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 每个操作都需要自己的模型，网络适配器和应用层将各自的模型映射到它们想要执行的操作所期望的模型](img/Figure_09.3._B19916.jpg)'
- en: Figure 9.3 – With each operation requiring its own model, the web adapter and
    application layer each map their model into the model expected by the operation
    they want to execute
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 每个操作都需要自己的模型，网络适配器和应用层将各自的模型映射到它们想要执行的操作所期望的模型
- en: This mapping strategy introduces a separate input and output model per operation.
    Instead of using the domain model to communicate across layer boundaries, we use
    a model specific to each operation, such as `SendMoneyCommand`, which acts as
    an input model to the `SendMoneyUseCase` port in the figure. We can call those
    models “commands,” “requests,” or similar.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射策略为每个操作引入了一个单独的输入和输出模型。我们不是使用域模型在层边界之间进行通信，而是使用针对每个操作的特定模型，例如`SendMoneyCommand`，它在图中充当`SendMoneyUseCase`端口的输入模型。我们可以将这些模型称为“命令”、“请求”或类似名称。
- en: The web layer is responsible for mapping its input into the command object of
    the application layer. Such a command makes the interface to the application layer
    very explicit, with little room for interpretation. Each use case has its own
    command with its own fields and validations. There’s no guessing involved as to
    which fields should be filled and which fields would be better left empty since
    they would otherwise trigger a validation we don’t want for our current use case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层负责将其输入映射到应用层的命令对象。这样的命令使得应用层的接口非常明确，几乎没有解释的空间。每个用例都有自己的命令，具有自己的字段和验证。我们不需要猜测哪些字段应该填写，哪些字段最好留空，因为它们可能会触发我们不希望针对当前用例的验证。
- en: The application layer is then responsible for mapping the command object into
    whatever it needs to modify the domain model according to the use case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用层负责将命令对象映射到根据用例需要修改域模型所需的内容。
- en: Naturally, mapping from one layer into many different commands requires even
    more mapping code than mapping between a single web model and a domain model.
    This mapping, however, is significantly easier to implement and maintain than
    a mapping that has to handle the needs of many use cases instead of only one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，从一层映射到多个不同的命令需要比从单个网络模型到域模型之间的映射更多的映射代码。然而，这种映射比必须处理多个用例需求而不是单个用例的映射要容易实现和维护得多。
- en: I don’t advocate this mapping strategy as a global pattern. It plays out its
    advantages best between the web layer (or any other incoming adapter) and the
    application layer to clearly demarcate the state-modifying use cases of the application.
    I would not use it between the application and persistence layers due to the mapping
    overhead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我不主张将这种映射策略作为全局模式。它在网络层（或任何其他传入适配器）和应用层之间发挥其优势，以清楚地界定应用的状态修改用例。由于映射开销，我不会在应用层和持久层之间使用它。
- en: Usually, I would restrict this kind of mapping to the input model of operations
    and simply use a domain object as the output model. `SendMoneyUseCase` might then
    return an `Account` object with the updated balance, for instance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我会将这种类型的映射限制在操作的输入模型上，并简单地使用域对象作为输出模型。例如，`SendMoneyUseCase`可能会返回一个带有更新后余额的`Account`对象。
- en: This shows that the mapping strategies can and should be mixed. No single mapping
    strategy needs to be a global rule across all layers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明映射策略可以并且应该混合使用。不需要任何单一的映射策略成为所有层级的全局规则。
- en: The “One-Way” mapping strategy
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “单向”映射策略
- en: 'There is yet another mapping strategy with another set of pros and cons: the
    “One-Way” strategy visualized in *Figure 9**.4*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种映射策略，它有一套自己的优缺点：即*图9.4*中展示的“单向”策略。
- en: '![Figure 9.4 – With the domain model and the adapter models implementing the
    same “state” interface, each layer only needs to map objects it receives from
    other layers one way](img/Figure_09.4._B19916.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 域模型和适配器模型实现相同的“状态”接口，每个层只需要映射从其他层接收到的对象一次](img/Figure_09.4._B19916.jpg)'
- en: Figure 9.4 – With the domain model and the adapter models implementing the same
    “state” interface, each layer only needs to map objects it receives from other
    layers one way
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 域模型和适配器模型实现相同的“状态”接口，每个层只需要映射从其他层接收到的对象一次
- en: In this strategy, the models in all layers implement the same interface, which
    encapsulates the state of the domain model by providing getter methods on the
    relevant attributes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种策略中，所有层的模型实现相同的接口，通过在相关属性上提供getter方法来封装域模型的状态。
- en: The domain model itself can implement a rich behavior, which we can access from
    our services within the application layer. If we want to pass a domain object
    to the outer layers, we can do so without mapping since the domain object implements
    the state interface expected by the incoming and outgoing ports.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型本身可以实现丰富的行为，我们可以从应用层的服务中访问这些行为。如果我们想将领域对象传递到外层，我们可以这样做，无需映射，因为领域对象实现了传入和传出端口所期望的状态接口。
- en: The outer layers can then decide whether they can work with the interface or
    whether they need to map it into their own model. They cannot inadvertently modify
    the state of the domain object since the modifying behavior is not exposed by
    the state interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 外层可以决定它们是否可以使用该接口，或者是否需要将其映射到自己的模型。由于修改行为没有通过状态接口暴露，它们不能无意中修改领域对象的状态。
- en: Objects we pass from an outer layer into the application layer also implement
    this state interface. The application layer then has to map it into the real domain
    model in order to get access to its behavior. This mapping plays well with the
    **Domain-Driven Design** concept of a factory. A factory in terms of DDD is responsible
    for reconstituting a domain object from a certain state, which is exactly what
    we’re doing.[1](#footnote-032)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从外层传递到应用层的对象也实现了这个状态接口。然后应用层必须将其映射到真实领域模型，以便访问其行为。这种映射与**领域驱动设计**中的工厂概念相得益彰。在领域驱动设计（DDD）中，工厂负责从某种状态重新构建领域对象，这正是我们所做的。[1](#footnote-032)
- en: '[1](#footnote-032-backlink) Factory*: Domain Driven Design* by Eric Evans,
    Addison-Wesley, 2004, p. 158.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-032-backlink) 工厂：*领域驱动设计*，作者埃里克·埃文斯，Addison-Wesley，2004年，第158页。'
- en: 'The mapping responsibility is clear: if a layer receives an object from another
    layer, we map it into something the layer can work with. Thus, each layer only
    maps one way, making this a “One-Way” mapping strategy.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 映射责任是明确的：如果一个层从另一个层接收对象，我们就将其映射为该层可以处理的东西。因此，每个层只映射一个方向，这使得这是一个“单向”映射策略。
- en: With the mapping distributed across layers, however, this strategy is conceptually
    more difficult than the other strategies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着映射在层之间分布，这个策略在概念上比其他策略更难。
- en: This strategy plays out its strength best if the models across the layers are
    similar. For read-only operations, for instance, the web layer then might not
    need to map into its own model at all since the state interface provides all the
    information it needs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果层之间的模型相似，这种策略最能发挥其优势。例如，对于只读操作，Web层可能根本不需要映射到自己的模型，因为状态接口提供了它所需的所有信息。
- en: When to use which mapping strategy?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用哪种映射策略？
- en: This is the million-dollar question, isn’t it?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个价值百万的问题，不是吗？
- en: The answer is the usual, dissatisfying *it depends*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是通常令人不满意的“这取决于”。
- en: Since each mapping strategy has different advantages and disadvantages, we should
    resist the urge to define a single strategy as a hard-and-fast global rule for
    the whole code base. This goes against our instincts, as it feels untidy to mix
    patterns within the same code base. But knowingly choosing a pattern that is not
    the best pattern for a certain job, just to serve our sense of tidiness, is irresponsible,
    plain and simple.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种映射策略都有不同的优缺点，我们应抵制将单一策略定义为整个代码库的硬性全局规则的冲动。这与我们的直觉相悖，因为它感觉在同一个代码库中混合模式是不整洁的。但为了满足我们对整洁的感觉，明知不是最适合某个工作的模式，却选择它，这是不负责任的，简单明了。
- en: Also, as software evolves over time, the strategy that was the best for the
    job yesterday might not still be the best for the job today. Instead of starting
    with a fixed mapping strategy and keeping it over time – no matter what – we might
    start with a simple strategy that allows us to quickly evolve the code and later
    move to a more complex one that helps us to better decouple the layers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着软件随时间演变，昨天最适合工作的策略可能今天不再是最适合的。我们可能不是从固定的映射策略开始并保持它——无论发生什么——而是从一个简单的策略开始，这个策略允许我们快速演进代码，然后转向一个更复杂的策略，帮助我们更好地解耦层。
- en: In order to decide which strategy to use when, we need to agree upon a set of
    guidelines within the team. These guidelines should answer the question of which
    mapping strategy should be the first choice in which situation. They should also
    answer *why* they are the first choice so that we’re able to evaluate whether
    those reasons still apply after some time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定何时使用哪种策略，我们需要在团队内部达成一套指导原则。这些指导原则应该回答在何种情况下哪种映射策略应该是首选，以及为什么它们是首选，这样我们才能评估这些原因在一段时间后是否仍然适用。
- en: We might, for example, define different mapping guidelines to modifying use
    cases than we do to queries. Also, we might want to use different mapping strategies
    between the web and application layers and between the application and persistence
    layers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能为修改用例定义不同的映射指南，而不是为查询定义。我们可能还希望在Web层和应用层之间以及应用层和持久层之间使用不同的映射策略。
- en: 'Guidelines for these situations might look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况的指导原则可能看起来是这样的：
- en: If we’re working on a modifying use case, the “Full” mapping strategy is the
    first choice between the web and application layer, in order to decouple the use
    cases from one another. This gives us clear per-use-case validation rules and
    we don’t have to deal with fields we don’t need in a certain use case.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个修改用例，那么在Web层和应用层之间，“完整”映射策略是首选，以便将用例彼此解耦。这为我们提供了清晰的每个用例验证规则，我们不必处理某个用例中不需要的字段。
- en: If we’re working on a modifying use case, the “No Mapping” strategy is the first
    choice between the application and persistence layer in order to be able to quickly
    evolve the code without mapping overhead. As soon as we have to deal with persistence
    issues in the application layer, however, we move to a “Two-Way” mapping strategy
    to keep persistence issues in the persistence layer.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个修改用例，那么在应用层和持久层之间，“无映射”策略是首选，以便能够快速进化代码而不需要映射开销。然而，一旦我们必须在应用层处理持久性问题，我们就转向“双向”映射策略以保持持久性问题在持久层。
- en: If we’re working on a query, the “No Mapping” strategy is the first choice between
    the web and application layer and between the application and persistence layer
    in order to be able to quickly evolve the code without mapping overhead. As soon
    as we have to deal with web or persistence issues in the application layer, however,
    we move to a “Two-Way” mapping strategy between the web and application layer
    or the application layer and persistence layer, respectively.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个查询，那么在Web层和应用层之间以及应用层和持久层之间，“无映射”策略是首选，以便能够快速进化代码而不需要映射开销。然而，一旦我们必须在应用层处理Web或持久性问题，我们就转向Web层和应用层或应用层和持久层之间的“双向”映射策略。
- en: In order to successfully apply guidelines like these, they must be present in
    the minds of the developers. So, the guidelines should be discussed and revised
    continuously as a team effort.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功应用这样的指南，它们必须存在于开发者的脑海中。因此，这些指南应该作为一个团队的努力持续讨论和修订。
- en: How does this help me build maintainable software?
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Incoming and outgoing ports act as gatekeepers between the layers of our application.
    They define how the layers communicate with each other, and how we map models
    across layers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进出端口充当我们应用程序各层之间的守门人。它们定义了层与层之间如何相互通信，以及我们如何在不同层之间映射模型。
- en: With narrow ports in place for each use case, we can choose different mapping
    strategies for different use cases, and even evolve them over time without affecting
    other use cases, thus selecting the best strategy for a certain situation at a
    certain time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个用例设置狭窄的端口，我们可以为不同的用例选择不同的映射策略，甚至随着时间的推移进行进化，而不影响其他用例，从而在某个特定时间选择某种特定情况的最佳策略。
- en: Selecting a different mapping strategy for each use case is harder and requires
    more communication than simply using the same mapping strategy for all situations,
    but it will reward the team with a code base that does just what it needs to do
    and is easier to maintain, as long as the mapping guidelines are known.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个用例选择不同的映射策略比简单地使用相同的映射策略更困难，需要更多的沟通，但只要映射指南是已知的，它将使团队能够获得一个只做它需要做的事情且更容易维护的代码库。
- en: Now that we know which components make up our application and how they communicate,
    we can explore how to assemble a working application out of the different components.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了构成我们应用程序的组件以及它们如何通信，我们可以探索如何将不同的组件组装成一个可工作的应用程序。
