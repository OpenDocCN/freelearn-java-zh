<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">REST API Security</h1>
                </header>
            
            <article>
                
<p>Spring Security can be used to secure REST APIs. This chapter begins with the introduction of some of the important concepts in regard to REST and the JWT.</p>
<p>The chapter then introduces OAuth concepts and by using hands-on coding examples, explains simple and advanced REST API security utilizing the Spring Security and Spring Boot modules in the Spring Framework.</p>
<p>We will be using the OAuth protocol in our examples to secure exposed REST API's utilizing Spring Security features to the fullest. We will be using the JWT to exchange claims between the server and client.</p>
<p>In this chapter, we will cover the following concepts:</p>
<ul>
<li>Modern application architecture</li>
<li>Reactive REST API</li>
<li>Simple REST API security</li>
<li>Advanced REST API security</li>
<li>Spring Security OAuth project</li>
<li>OAuth2 and Spring WebFlux</li>
<li>Spring Boot and OAuth2</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Important concepts</h1>
                </header>
            
            <article>
                
<p>Before getting into coding, we need to be conversant with some important concepts. This section is aimed at introducing you to some of these concepts in detail.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST</h1>
                </header>
            
            <article>
                
<p><strong>Representational State Transfer</strong><span> (<strong>REST</strong>)</span> is an architectural style presented by Roy Fielding in the year 2000 for developing web services. It is built on top of the well-known <strong>Hypertext Transfer Protocol</strong> (<strong>HTTP</strong>) and can transfer data in multiple formats, the most common being <span><strong>JavaScript Object Notation</strong> (</span><strong>JSON</strong>) and <span><strong>eXtensible Markup Language</strong> (</span><strong>XML</strong>). The status of a request in REST is indicated using standard HTTP status code (200: OK, 404: Page not found!, and so on). Being based on HTTP, security is taken care of using the already familiar <span><strong>Secure Sockets Layer</strong> (</span><strong>SSL</strong>) and <span><strong>Transport Layer Security</strong> </span>(<strong>TLS</strong>).</p>
<p>While writing such web services, you are free to use any programming language (Java, .NET, and so on) that is capable of making web requests based on HTTP (which is a de facto standard that every language supports). You have a number of well-known frameworks, using which developing RESTful APIs on the server side is quite easy and simple. Also, on the client side, there are a number of frameworks that make invoking RESTful APIs and handling responses straightforward and easy.</p>
<p>Since REST works on internet protocol, the caching of a web service response can be achieved quite easily by supplying appropriate HTTP headers (Cache-Control, Expires, and so on). The HTTP methods <kbd>PUT</kbd> and <kbd>DELETE</kbd> are not cacheable in any scenario. The following table summarizes the use of HTTP methods:</p>
<p class="mce-root"/>
<div>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 162px">
<p><strong>HTTP method</strong></p>
</td>
<td style="width: 412px">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 162px">
<p><kbd>GET</kbd></p>
</td>
<td style="width: 412px">
<p>Retrieves a resource</p>
</td>
</tr>
<tr>
<td style="width: 162px">
<p><kbd>POST</kbd></p>
</td>
<td style="width: 412px">
<p>Creates a new resource</p>
</td>
</tr>
<tr>
<td style="width: 162px">
<p><kbd>PUT</kbd></p>
</td>
<td style="width: 412px">
<p>Updates an existing resource</p>
</td>
</tr>
<tr>
<td style="width: 162px">
<p><kbd>DELETE</kbd></p>
</td>
<td style="width: 412px">
<p>Deletes an existing resource</p>
</td>
</tr>
<tr>
<td style="width: 162px">
<p><kbd>PATCH</kbd></p>
</td>
<td style="width: 412px">
<p>Makes a partial update to a resource</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 1: HTTP method usage</div>
<p>A REST API request/response (data sent over the wire) can be compressed by specifying appropriate HTTP headers, similar to caching. The HTTP header, Accept-Encoding, is sent by the client to the server, to let the server know the compression algorithms it <span>can</span><span> </span><span>understand. The server successfully compresses a response and puts out another HTTP header, Content-Encoding, letting the client know which algorithm has to be used to decompress.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON Web Token (JWT)</h1>
                </header>
            
            <article>
                
<p><q>"JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties."</q></p>
<div class="CDPAlignRight CDPAlign"><em>- <a href="https://jwt.io/">https://jwt.io/</a></em></div>
<p>In the past, the stateless nature of HTTP was circumvented in a web application (most of them are stateful in nature) by associating each request with a session ID created on the server and then stored by the client using cookies. Each request sends the cookie (session ID) in the form of an HTTP header, which gets validated by the server, and a state (a user session) is associated with each request. In modern applications (we will cover this in a bit more detail in the next section), a server-side session ID is replaced with the JWT. The following diagram shows the workings of the JWT:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f181c449-77aa-498b-a77a-2104f1bb75ad.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1: Workings of the JWT in modern applications</div>
<p>The web server, in this case, doesn't create a user session and the user session management capability needed for a stateful application is offloaded to other mechanisms.</p>
<p class="mce-root"/>
<p>In the world of the Spring Framework, the Spring Session module can be employed to externalize the session from the web server to a central persistence store (Redis, Couchbase, and so on). Every request containing a valid token (JWT) is validated against this external store of authenticity and validity. After successful authentication, applications can generate a valid token and send it as a response to the client. The client can then store this token in any client storage mechanism it uses (sessionStorage, localStorage, cookies, and so on, in a browser). Using Spring Security, we can validate this token to ascertain the authenticity and validity of the user and then do whatever is required. We have a dedicated example in a subsequent section (Simple REST API security) of this chapter, which uses a basic authentication mechanism and, if successful, creates the JWT. Subsequent requests use the token in the HTTP header, which gets validated on the server to give access to other secured resources.</p>
<p>The following points highlight some of the advantages of using the JWT:</p>
<ul>
<li style="font-weight: 400"><strong>Better performance</strong>: Each request, when reaching the server, has to check the authenticity of the token send. The authenticity of the JWT can be checked locally and doesn't require an external call (say, to a database). This local validation is performant and reduces the overall response time for a request.</li>
<li style="font-weight: 400"><strong>Simplicity</strong>: JWT is easy and simple to implement. Also, it is a well established format in the industry for tokens. There are a number of well-known libraries which can be used to easily work with the JWT.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structure of a token</h1>
                </header>
            
            <article>
                
<p>Unlike common security mechanisms, such as encryption, obscuring, and hiding, the JWT doesn't encrypt or hide the data contained within. But, <span>it does the destination system to check whether the token is from an authentic source. The structure of the JWT consists of a header, payload, and a signature. As mentioned, rather than encryption, the data contained within the JWT is encoded and then signed. Encoding does the job of transforming the data in a way that is acceptable by a variety of parties and signing allows us to check for its authenticity and, in fact, its origin:</span></p>
<pre>JWT = header.payload.signature</pre>
<p>Let's go into more detail about each of the components constituting the token.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Header</h1>
                </header>
            
            <article>
                
<p>This is a JSON object and takes the following format. It gives information on how the signature should be computed:</p>
<pre>{<br/> "alg": "HS256",<br/> "typ": "JWT"<br/>}</pre>
<p>The value of <kbd>typ</kbd> specifies type of the object, and in this case, it is the <kbd>JWT</kbd>. The value of <kbd>alg</kbd> specifies the algorithm used to create the signature, and in this case it is <kbd>HMAC-SHA256</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload</h1>
                </header>
            
            <article>
                
<p>The payload forms the actual data (also known as a <strong>claim</strong>) stored in the JWT. According to your application's requirements, you can put any number of claims into your JWT payload component. There are some predefined claims, such as <kbd>iss</kbd> (issuer), <kbd>sub</kbd> (subject), <kbd>exp</kbd> (expiration time), <kbd>iat</kbd> (issued at), and so on, that can be used, but all of these are optional:</p>
<pre>{<br/> "sub": "1234567890",<br/> "username": "Test User",<br/> "iat": 1516239022<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Signature</h1>
                </header>
            
            <article>
                
<p>The signature is formed as follows:</p>
<ol>
<li style="font-weight: 400">The <kbd>header</kbd> is <kbd>base64</kbd> encoded: <kbd>base64(header)</kbd>.</li>
<li style="font-weight: 400">The <kbd>payload</kbd> is <kbd>base64</kbd> encoded: <kbd>base64(payload)</kbd>.</li>
<li style="font-weight: 400">Now join the values in <em>Step 1</em> and <em>Step 2</em> with a <kbd>"."</kbd> in the middle:</li>
</ol>
<pre style="padding-left: 60px">base64UrlEncode(header) + "." +base64UrlEncode(payload)</pre>
<ol start="4">
<li style="font-weight: 400">Now, the signature is attained by hashing, using the algorithm specified in the header, the value attained in <em>Step 3</em>, and then appending it with the secret text (say <kbd>packtpub</kbd>) of your choice:</li>
</ol>
<pre style="padding-left: 60px">HMACSHA256(<br/>  base64UrlEncode(header) + "." +<br/>  base64UrlEncode(payload),<br/>  packtpub<br/>)</pre>
<p style="padding-left: 60px">The final JWT is as shown here:</p>
<pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlRlc3QgVXNlciIsImlhdCI6MTUxNjIzOTAyMn0.yzBMVScwv9Ln4vYafpTuaSGa6mUbpwCg84VOhVTQKBg</pre>
<p>The website <a href="https://jwt.io/">https://jwt.io/</a> is a place I always visit for any of my JWT needs. The sample data used in this example is from that site:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e508052-e050-47bd-8b70-db78d22598e2.png" style="width:61.75em;height:36.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2: Screen grab from https://jwt.io/</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modern application architecture</h1>
                </header>
            
            <article>
                
<p>Frontends of most modern applications are not built using server-side web application frameworks, such as Spring MVC, <strong>Java Server Faces</strong> (<strong>JSF</strong>), and so on. Infact, many are built using full-fledged client-side frameworks, such as React (to be full-fledged, it has to be combined with other libraries), Angular, and so on. The previous statement doesn't mean in any way that there is no place for such server-side web application frameworks. According to the application you are building, there are specific places for each of these frameworks.</p>
<p class="mce-root"/>
<p>When using client-side frameworks, the client code (HTML, JS, CSS, and so on) in general is not secured. However, the data required to render these dynamic pages is secured behind a RESTful endpoint.</p>
<p>To secure a RESTful backend, the JWT is used to exchange claims between the server and the client. The JWT enables the stateless exchange of tokens between the two parties and takes away the burden of session management (no more sticky sessions or session replication between multiple server nodes) by the server. This enables the application to scale horizontally in a cost-effective manner:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/841b4165-d61d-41e8-89ec-89647e225641.png" style="width:29.67em;height:37.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3: API-based modern application architecture</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOFEA</h1>
                </header>
            
            <article>
                
<p><strong>Service-Oriented Front-End Architecture</strong> (<strong>SOFEA</strong>) is of the architectural style which had gained popularity in the past when <strong>S</strong><span><strong>ervice Oriented Architecture</strong> </span>(<strong>SOA</strong>) and was becoming common in many enterprises. In modern days, SOA is more of less with microservices-based architecture and the backend is reduced to a bunch of RESTful endpoints. The client on the other hand is becoming thicker and uses client-side MVC frameworks such as Angular and React, just to name a couple. However, the core concept of SOFEA, in which backend is just endpoints and frontend (UI) becoming thicker is something everyone considers in modern age web application development. </p>
<p>Some of the advantages of SOFEA are as follows:</p>
<ul>
<li style="font-weight: 400">The client in this is thicker (similar to thick client applications) as against thin client web applications that we have seen in the past. After initial view/rendering of pages, all the assets are downloaded from server and resides/caches on the client (browser). Thereafter, the server is contacted only for data when required by the client through XHR (Ajax) calls.</li>
<li style="font-weight: 400">After the client code is downloaded, only data flows from the server to the client, as opposed to presentation code (HTML, JavaScript, and so on), better utilizing the bandwidth. As there is less data being transferred, response times are faster, making applications perform better.</li>
<li style="font-weight: 400">Any number of clients can be written utilizing the same RESTful server endpoints, reusing APIs to the fullest.</li>
<li style="font-weight: 400">These endpoints can externalize a session (in the Spring Framework, there is a module called <strong>Spring Session</strong>, which can be used to achieve this technical capability), thus easily achieving the horizontal scalability of the server.</li>
<li style="font-weight: 400">Better role segregation of team members in a project with APIs managed by a team and UI code managed by a different team.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive REST API</h1>
                </header>
            
            <article>
                
<p>In the <a href="5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml">Chapter 4</a>, <em>Authentication Using CAS and JAAS</em>, we went through the reactive Spring WebFlux web application framework in detail. We also looked into a lot of the reactive programming support provided by the Spring Framework and other Spring modules. Knowingly or unknowingly, we created a reactive REST API in the previous chapter's example sections. We used a handler and router mechanism for creating a RESTful application and also secured it using the <em>BASIC</em> authentication mechanism.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We saw the workings of <kbd>WebClient</kbd> (a reactive way of calling REST APIs, as opposed to using a blocking <kbd>RestTemplate</kbd>) and <kbd>WebTestClient</kbd> (a reactive way of writing test cases). We also saw the workings of Spring Data in a reactive way using MongoDB as the persistent store.</p>
<p>We will not go through these aspects here; we will only mention that, if you wish, you can make yourself comfortable with this topic by going through the section in <a href="5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml">Chapter 4</a>, <em><span>Authentication Using CAS and JAAS</span></em>. In this chapter, we will cover where we left off from the previous chapter by getting to REST API security using the JWT, and then going through REST API security using OAuth (implementing a custom provider as opposed to using public providers, such as Google, Facebook, and so on).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple REST API security</h1>
                </header>
            
            <article>
                
<p>We will use the example that we created in <a href="df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml">Chapter 5</a>, <em><span>Integrating with Spring WebFlux</span></em> (<em>spring-boot-spring-webflux</em>) and expand on it by doing the following:</p>
<ul>
<li style="font-weight: 400">Bringing the JWT support to the already existing Spring WebFlux application secured using basic authentication.</li>
<li style="font-weight: 400">Creating a new controller (<kbd>path /auth/**</kbd>) that will have new endpoints, using which you can authenticate the user.</li>
<li style="font-weight: 400">Using basic <span>authentication</span> or the auth REST endpoint, we will generate the JWT on the server and send it as a response to the client. Subsequent calls from the client to access secured REST APIs can be achieved by using the JWT supplied as a HTTP header (authorization, bearer token).</li>
</ul>
<p>We won't be able to go into each and every detail of this project (we have a more important topic that we need to cover in this chapter within the stipulated page count). However, while going through the example, important code snippets will be listed down and explained in detail to some extent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security configuration</h1>
                </header>
            
            <article>
                
<p>In the Spring Security configuration, we tweak the <kbd>springSecurityFilterChain</kbd> bean, as shown in the following code snippet:</p>
<pre>@Bean<br/>public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http){<br/>    AuthenticationWebFilter authenticationJWT = new AuthenticationWebFilter(new     <br/>    UserDetailsRepositoryReactiveAuthenticationManager(userDetailsRepository()));<br/>    authenticationJWT.setAuthenticationSuccessHandler(new         <br/>                                                    JWTAuthSuccessHandler());<br/>    http.csrf().disable();<br/>    http<br/>      .authorizeExchange()<br/>      .pathMatchers(WHITELISTED_AUTH_URLS)<br/>      .permitAll()<br/>      .and()<br/>      .addFilterAt(authenticationJWT, SecurityWebFiltersOrder.FIRST)<br/>      .authorizeExchange()<br/>      .pathMatchers(HttpMethod.GET, "/api/movie/**").hasRole("USER")<br/>      .pathMatchers(HttpMethod.POST, "/api/movie/**").hasRole("ADMIN")<br/>      .anyExchange().authenticated()<br/>      .and()<br/>      .addFilterAt(new JWTAuthWebFilter(), SecurityWebFiltersOrder.HTTP_BASIC);<br/>    return http.build();<br/>}</pre>
<p>As you can see, we have a new <kbd>AuthenticationWebFilter</kbd> and a <kbd>AuthenticationSuccessHandler</kbd> configured. We also have a new <kbd>JWTAuthWebFilter</kbd> class for handling the JWT-based authentication configured.</p>
<p>We will be using <kbd>ReactiveUserDetailsService</kbd> with hardcoded user credentials for testing, as shown in the following code snippet:</p>
<pre>@Bean<br/>public MapReactiveUserDetailsService userDetailsRepository() {<br/>    UserDetails user = User.withUsername("user").password("    <br/>        {noop}password").roles("USER").build();<br/>    UserDetails admin = User.withUsername("admin").password("<br/>        {noop}password").roles("USER","ADMIN").build();<br/>    return new MapReactiveUserDetailsService(user, admin);<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication success handler</h1>
                </header>
            
            <article>
                
<p>We set up a custom <kbd>AuthenticationSuccessHandler</kbd> (the source code for this class is shown next) in our Spring Security configuration class. On successful authentication, it will generate the JWT and also set a HTTP <span>response</span><span> </span><span>header:</span></p>
<ul>
<li><strong>Header name</strong>: <kbd>Authorization</kbd></li>
<li><strong>Header value</strong>: <kbd>Bearer JWT</kbd></li>
</ul>
<p>Let's take a look at the following code:</p>
<pre>public class JWTAuthSuccessHandler implements ServerAuthenticationSuccessHandler{<br/>    @Override<br/>    public Mono&lt;Void&gt; onAuthenticationSuccess(WebFilterExchange     <br/>            webFilterExchange, Authentication authentication) {<br/>        ServerWebExchange exchange = webFilterExchange.getExchange();<br/>        exchange.getResponse()<br/>            .getHeaders()<br/>            .add(HttpHeaders.AUTHORIZATION, <br/>                    getHttpAuthHeaderValue(authentication));<br/>        return webFilterExchange.getChain().filter(exchange);<br/>    }<br/>    private static String getHttpAuthHeaderValue(Authentication authentication){<br/>        return String.join(" ","Bearer",tokenFromAuthentication(authentication));<br/>    }<br/>    private static String tokenFromAuthentication(Authentication authentication){<br/>        return new JWTUtil().generateToken(<br/>            authentication.getName(),<br/>            authentication.getAuthorities());<br/>    }<br/>}</pre>
<p>The <kbd>JWTUtil</kbd> class contains a number of utility methods dealing with the JWTs, such as the generation of tokens, verification of tokens, and so on. The <kbd>generateToken</kbd> method in the <kbd>JWTUtil</kbd> class is as shown here:</p>
<pre>public static String generateToken(String subjectName, Collection&lt;? extends             GrantedAuthority&gt; authorities) {<br/>    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()<br/>        .subject(subjectName)<br/>        .issuer("javacodebook.com")<br/>        .expirationTime(new Date(new Date().getTime() + 30 * 1000))<br/>        .claim("auths", authorities.parallelStream().map(auth -&gt;                             (GrantedAuthority) auth).map(a -&gt;                                 <br/>            a.getAuthority()).collect(Collectors.joining(",")))<br/>        .build();<br/>    SignedJWT signedJWT = new SignedJWT(new JWSHeader(JWSAlgorithm.HS256),         claimsSet);<br/>    try {<br/>        signedJWT.sign(JWTUtil.getJWTSigner());<br/>    } catch (JOSEException e) {<br/>        e.printStackTrace();<br/>    }<br/>    return signedJWT.serialize();<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom WebFilter namely JWTAuthWebFilter</h1>
                </header>
            
            <article>
                
<p>Our custom <kbd>WebFilter</kbd>, named <kbd>JWTAuthWebFilter</kbd>, is entrusted with converting the JWT token <span>received</span><span> in</span><span>to appropriate classes that the Spring Security understands. It makes use of a converter named</span> <kbd>JWTAuthConverter</kbd><span>, which does a number of things, as follows:</span></p>
<ul>
<li style="font-weight: 400">Gets the authorization <kbd>payload</kbd></li>
<li style="font-weight: 400">Extracts the token by discarding the <kbd>Bearer</kbd> string</li>
<li style="font-weight: 400">Verifies the token</li>
<li style="font-weight: 400">Creates a <kbd>UsernamePasswordAuthenticationToken</kbd> class understood by Spring Security</li>
</ul>
<p>The code snippet below shows the <kbd>JWTAuthWebFilter</kbd> class and its important method which does operations listed above.</p>
<pre>public class JWTAuthConverter implements Function&lt;ServerWebExchange,             <br/>        Mono&lt;Authentication&gt;&gt; {<br/>    @Override<br/>    public Mono&lt;Authentication&gt; apply(ServerWebExchange serverWebExchange) {<br/>        return Mono.justOrEmpty(serverWebExchange)<br/>            .map(JWTUtil::getAuthorizationPayload)<br/>            .filter(Objects::nonNull)<br/>            .filter(JWTUtil.matchBearerLength())<br/>            .map(JWTUtil.getBearerValue())<br/>            .filter(token -&gt; !token.isEmpty())<br/>            .map(JWTUtil::verifySignedJWT)<br/>            .map(JWTUtil::getUsernamePasswordAuthenticationToken)<br/>            .filter(Objects::nonNull);<br/>    }<br/>}</pre>
<p>After this conversion, it does the actual authentication using Spring Security, which sets <kbd>SecurityContext</kbd> in the application, as shown in the following code snippet:</p>
<pre>@Override<br/>public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {<br/>    return this.getAuthMatcher().matches(exchange)<br/>        .filter(matchResult -&gt; matchResult.isMatch())<br/>        .flatMap(matchResult -&gt; this.jwtAuthConverter.apply(exchange))<br/>        .switchIfEmpty(chain.filter(exchange).then(Mono.empty()))<br/>        .flatMap(token -&gt; authenticate(exchange, chain, token));<br/>}<br/>//..more methods<br/>private Mono&lt;Void&gt; authenticate(ServerWebExchange exchange,<br/>                              WebFilterChain chain, Authentication token) {<br/>    WebFilterExchange webFilterExchange = new WebFilterExchange(exchange, chain);<br/>    return this.reactiveAuthManager.authenticate(token)<br/>      .flatMap(authentication -&gt; onAuthSuccess(authentication, <br/>          webFilterExchange));<br/>}<br/>private Mono&lt;Void&gt; onAuthSuccess(Authentication authentication, WebFilterExchange <br/>        webFilterExchange) {<br/>    ServerWebExchange exchange = webFilterExchange.getExchange();<br/>    SecurityContextImpl securityContext = new SecurityContextImpl();<br/>    securityContext.setAuthentication(authentication);<br/>    return this.securityContextRepository.save(exchange, securityContext)<br/>        .then(this.authSuccessHandler<br/>        .onAuthenticationSuccess(webFilterExchange, authentication))<br/>        .subscriberContext(ReactiveSecurityContextHolder.withSecurityContext(<br/>            Mono.just(securityContext)));<br/>}</pre>
<p>The <kbd>JWTAuthWebFilter</kbd> class filter method does the necessary conversions and then the <kbd>authenticate</kbd> method does the actual authentication, and finally calls the <kbd>onAuthSuccess</kbd> method.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New controller classes</h1>
                </header>
            
            <article>
                
<p>We have two controllers, namely <kbd>DefaultController</kbd> (mapped to the <kbd>/</kbd> and <kbd>/login</kbd> paths) and <kbd>AuthController</kbd> (mapped to the <kbd>/auth</kbd> main route and <kbd>/token</kbd> sub-route). The <kbd>/auth/token</kbd> <span>path</span><span> </span><span>can be used to retrieve the token, which can be used for a subsequent API call (</span><kbd>Bearer &lt;Token&gt;</kbd><span>). The code snippet for</span> <kbd>AuthController</kbd> <span>is as shown here:</span></p>
<pre>@RestController<br/>@RequestMapping(path = "/auth", produces = { APPLICATION_JSON_UTF8_VALUE })<br/>public class AuthController {<br/><br/>    @Autowired<br/>    private MapReactiveUserDetailsService userDetailsRepository;<br/>        @RequestMapping(method = POST, value = "/token")<br/>        @CrossOrigin("*")<br/>        public Mono&lt;ResponseEntity&lt;JWTAuthResponse&gt;&gt; token(@RequestBody     <br/>                JWTAuthRequest jwtAuthRequest) throws AuthenticationException {<br/>            String username =  jwtAuthRequest.getUsername();<br/>            String password =  jwtAuthRequest.getPassword();<br/>            return userDetailsRepository.findByUsername(username)<br/>               .map(user -&gt; ok().contentType(APPLICATION_JSON_UTF8).body(<br/>                 new JWTAuthResponse(JWTUtil.generateToken(user.getUsername(),                  user.getAuthorities()), user.getUsername())))<br/>                 .defaultIfEmpty(notFound().build());<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application and testing</h1>
                </header>
            
            <article>
                
<p>Run the application using the Spring Boot command shown below:</p>
<pre>mvn spring-boot:run</pre>
<p>I will be using Postman to execute the REST endpoints.</p>
<p>You can get hold of the token, to include it in subsequent calls, by employing two methods as detailed below:</p>
<ul>
<li style="font-weight: 400">If you access any route using basic authentication credentials, in the response header, you should get the token. I will be using the <kbd>/login</kbd> path with <span class="packt_screen">Basic Auth</span> (authorization header) to get the token, as shown here:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d417a89e-0a43-4612-964b-8d12a8c02328.png" style="width:53.58em;height:40.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4: Getting token using Basic Auth in Postman</div>
<ul>
<li>Access the <kbd>/auth/token</kbd> endpoint with <span class="packt_screen">Basic Auth</span> credentials supplied in the form of JSON (using the <kbd>JWTAuthRequest</kbd> class), as shown here, in Postman:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b601600b-0c3b-4c15-8c9a-9414f2a45049.png" style="width:57.25em;height:37.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5: Getting token using /auth/token endpoint using Basic Auth credentials in JSON</div>
<p>Using the token retrieved, call the movie endpoint, as shown here, using Postman:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/967a0611-eeb5-44d1-91ad-c9373acbc3cb.png" style="width:51.17em;height:37.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6: Retrieving movie listing using a JWT token in Postman</div>
<p>This completes the example that we were building. In this example, we secured the REST APIs by making use of JWT and validated them using Spring Security. As mentioned, this is a basic way in which you can secure your REST APIs using Spring Security with JWTs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced REST API security</h1>
                </header>
            
            <article>
                
<p>REST APIs can be secured by another mechanism in your web application, OAuth.</p>
<p>OAuth is an authorization framework that allows other applications with the right credentials access to partial/limited user profile details stored on platforms such as Google and Facebook. The authentication part is delegated to these services and if successful, appropriate grants are given to the calling client/application, which can be used to get access to secured resources (in our case RESTful APIs).</p>
<p>We have seen OAuth security using a public authentication provider in <a href="69913c59-1186-44b2-8707-dceca721e206.xhtml">Chapter 3</a>, <em>Authentication Using CAS and JAAS</em> (in the <em>OAuth 2 and OpenID connect</em> section). However, we need not use these public providers; you have the choice of using your own. We will cover one such example in this chapter, where we will be using our own authentication provider and securing our Spring Boot-based reactive REST endpoints.</p>
<p>Before getting into the example, we need to understand a bit more about OAuth, and also need to understand its various components. We already went through a lot of the details of OAuth in <a href="https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=30&amp;action=edit#post_28">Chapter 3</a><span>, </span><em>Authentication Using CAS and JAAS</em>. We will add to those details in this section and then go through the code example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth2 roles</h1>
                </header>
            
            <article>
                
<p>OAuth stipulates four roles for users and applications. The interactions between these roles are shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6d946741-9ac2-4e7f-8504-a46b832ebb27.png" style="width:46.42em;height:35.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 7: OAuth role interaction</div>
<p>We will look into each of these OAuth roles in some detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource owner</h1>
                </header>
            
            <article>
                
<p>This is the user who owns the protected resource that is needed by the consuming client application. If we take Facebook or Google as the authentication provider, the resource owner is the actual user who has data saved on these platforms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource server</h1>
                </header>
            
            <article>
                
<p>This is the server that has the secured resources in the form of<span> </span><span>hosted</span> APIs. If we take Google or Facebook as an example, they hold the profile information, as well as other information, in the form of APIs. If the client application successfully authenticates (using the credentials provided by the user) and then the user grants appropriate permissions, they can get access to this information through their exposed APIs<span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client</h1>
                </header>
            
            <article>
                
<p>This is the application that to access the secured resources available on the resource server. If the user is successfully authenticated and the <span>client</span><span> </span>application is given permission by the user to access the right information, the client application can retrieve the data<span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization server</h1>
                </header>
            
            <article>
                
<p>This is the server that authenticates and authorizes client applications to access the secured resources owned by the resource owner and on the resource server. It is not uncommon to see the same server performing both roles.</p>
<p>To participate in OAuth, your application has to first register with the service provider (Google , Facebook, and so on) against which you plan to authenticate by providing the application name, application URL, and callback URL. Successful registration of your application with the service provider gives you two values unique to your application: <kbd>client application_id</kbd> and <kbd>client_secret</kbd>. <kbd>client_id</kbd> can be exposed publicly but <kbd>client_secret</kbd> is kept hidden (private). Both these values are needed whenever you access the service provider. The following diagram shows the interactions between these roles:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5115c019-94ee-4e31-abfd-1458d4305577.png" style="width:40.17em;height:32.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 8: OAuth role interaction</div>
<p>The steps in the preceding diagram are covered in detail here:</p>
<ol>
<li style="font-weight: 400">The client application requests the resource owner to give them authorization to access the secured resources</li>
<li style="font-weight: 400">If the resource owner authorizes this, the authorization grant is sent to the client application </li>
<li style="font-weight: 400">The client application asks for a token, using the grant provided by the resource owner along with authentication credentials from the authorization server</li>
<li style="font-weight: 400">If the credentials and grant from the client application are valid, the authorization server issues an Access Token to the client application</li>
<li style="font-weight: 400">The client application accesses the protected resources on the resource server using the Access Token provided</li>
<li style="font-weight: 400">If the Access Token sent by the client application is valid, the resource server gives access to the secured resources</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization grant types</h1>
                </header>
            
            <article>
                
<p>As shown in the diagram, for the client to start calling APIs, it needs to obtain an authorization grant in the form of an Access Token. OAuth provides four grant types, which can be used according to different application requirements. The as to which authorization grant type to use is left with the client application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization code flow</h1>
                </header>
            
            <article>
                
<p>This a is very commonly used grant type and works on redirection at the server. It is highly suitable for server-side applications where the source code is hosted on the server and nothing is available on the client. The following diagram explains the authorization code grant type flow:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54908998-f191-4a15-bc07-7a7469a08aa6.png" style="width:34.50em;height:33.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9: Authorization code flow</div>
<p>The steps in the preceding diagram are explained in detail here:</p>
<ol>
<li style="font-weight: 400">The resource owner of the secured resource is presented with a screen in the browser to authorize the request. Here is a sample authorization link: <kbd>https://&lt;DOMAIN&gt;/oauth/authorize?response_type=code&amp;client_id=&lt;CLIENT_ID&gt;&amp;redirect_uri=&lt;CALLBACK_URL&gt;&amp;scope=&lt;SCOPE&gt;</kbd>.</li>
</ol>
<p style="padding-left: 60px">These are the important query parameters <span>in the previous link</span>:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li style="font-weight: 400"><kbd>client_id</kbd>: The client application ID that we got while registering the application with the service provider</li>
<li style="font-weight: 400"><kbd>redirect_uri</kbd>: After successful authorization, the server redirects to this URL supplied</li>
<li style="font-weight: 400"><kbd>response_type</kbd>: A very important parameter the client uses to ask the server for the authorization code</li>
<li style="font-weight: 400"><kbd>scope</kbd>: Specifies the level of access that it requires</li>
</ul>
</li>
</ul>
<ol start="2">
<li style="font-weight: 400">If the resource owner (user) allows this, they click on the authorize link, which is sent to the authorization server.</li>
<li style="font-weight: 400">If the authorization request sent to the authorization server is validated and found to be successful, the client receives the authorization code grant from the authorization server appended as a query parameter in the callback URL (&lt;<kbd>CALLBACK_URL&gt;?code=&lt;AUTHORIZATION_CODE&gt;</kbd>) specified in <kbd>Step 1</kbd>.</li>
<li style="font-weight: 400">Using the authorization grant, the client application requests an Access Token from the authorization server (<kbd>https://&lt;DOMAIN&gt;/oauth/token?client_id=&lt;CLIENT_ID&gt;&amp;client_secret=&lt;CLIENT_SECRET&gt;&amp;grant_type=authorization_code&amp;code=&lt;AUTHORIZATION_CODE&gt;&amp;redirect_uri=CALLBACK_URL</kbd>).</li>
</ol>
<p style="padding-left: 60px">In this URL, the client application's <kbd>client_secret</kbd> also has to be passed, along with the <kbd>grant_type</kbd> parameter, which states that the code passed is the authorization code.</p>
<ol start="5">
<li style="font-weight: 400">The authorization server validates the credentials and authorization grant and sends the Access Token to the client application, preferably in the form of JSON.</li>
<li style="font-weight: 400">The client application calls the protected resource on the resource server using the Access Token received in <em>Step 5</em>.</li>
<li style="font-weight: 400">If the Access Token supplied in <em>Step 5</em> is valid, the resource server gives access to the secured resource.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit flow</h1>
                </header>
            
            <article>
                
<p>This is commonly used in mobile and web applications, and also works based on redirection. The following diagram explains the implicit code grant type flow:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8da3f363-ff0a-4d4a-9058-9247f0dc33e3.png" style="width:36.42em;height:35.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10: Implicit flow</div>
<p>The steps in the preceding diagram are explained in detail here:</p>
<ol>
<li style="font-weight: 400">The resource owner is presented with a screen (browser) to authorize the request. Here is an example authorization link: <kbd>https://&lt;DOMAIN&gt;/oauth/authorize?response_type=token&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=&lt;SCOPE&gt;</kbd>.</li>
</ol>
<p style="padding-left: 60px">It is important to note that the <kbd>response_type</kbd> specified in the previous link is <kbd>token</kbd>. This indicates the server should give the Access Token (this is one of the main differences from the authorization code flow grant type discussed in the previous section).</p>
<ol start="2">
<li style="font-weight: 400">If the resource owner (user) allows this, they click on the authorize link, which is sent to the authorization server.</li>
<li style="font-weight: 400">The user-agent (browser or mobile app) receives the Access Token in the <kbd>CALLBACK_URL</kbd> specified (<span><kbd>https://&lt;CALLBACK_URL&gt;#token=&lt;ACCESS_TOKEN&gt;</kbd>)</span>.</li>
<li style="font-weight: 400">The user-agent goes to the specified <kbd>CALLBACK_URL</kbd>, retaining the Access Token.</li>
<li style="font-weight: 400">The client application opens the web page (using any mechanism), which extracts the Access Token from the <kbd>CALLBACK_URL</kbd>.</li>
<li style="font-weight: 400">The client application now has access to the Access Token.</li>
<li style="font-weight: 400">The client application calls the secured API using the Access Token.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client credentials</h1>
                </header>
            
            <article>
                
<p>This is one the simplest grant to implement. The client application sends credentials (the client's service account), along with <kbd>client_ID</kbd> and <kbd>client_secret,</kbd> to the authorization server. If the supplied values are valid, the authorization server sends the Access Token, which can be used to get access to the secured resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource owner password credentials</h1>
                </header>
            
            <article>
                
<p>Again, this is another simple type that can be easily used, but it is considered the most insecure of all. In this grant type, the resource owner (user) has to key their credentials directly into the client application interface (remember, the client application has access to the resource owner's credentials). The credentials are then used by the client application to send to the authorization server to get the Access Token. This grant type only works if the resource owner fully trusts the application through which they give their credentials to the service provider, as these credentials pass through the application server<span> </span><span>of the client application</span> (they can therefore be stored, if the client application decides to)<span>.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Access Token and Refresh Token</h1>
                </header>
            
            <article>
                
<p>The Access Token can be used by the client application to retrieve information from the resource server for a stipulated time for which the token is deemed valid. After this, the server will reject the request with the appropriate HTTP response error code.</p>
<p>Along with the Access Token, OAuth allows the authorization server to also send another token, the Refresh Token. When the Access Token expires, the client application can use this second token to request the authorization server to provide a new Access Token.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security OAuth project</h1>
                </header>
            
            <article>
                
<p>Currently in the Spring ecosystem, OAuth support has spread to a number of projects, including Spring Security Cloud, Spring Security OAuth, Spring Boot, and the edition of Spring Security (5.x+). This has created a lot of confusion within the community and no single source of ownership. The approach taken by the Spring team is to consolidate this and start maintaining everything regarding to OAuth with Spring Security. Important components that are part of OAuth, namely the authorization server, the resource server, and next-level support for OAuth2, as well as OpenID Connect 1.0, are expected to be added to Spring Security by the end of 2018. The Spring Security roadmap clearly states that by mid-2018, support for the resource server would be added, and the<span> </span><span>authorization server</span> by the end of 2018<span>.</span></p>
<p>The Spring Security OAuth project, as it stands at the time of writing this book, is in maintenance mode. This means that there will be a release for bug/security fixes, along with minor features. No major features are planned to be added to this project going forward.</p>
<p>The full OAuth2 feature matrix available in various Spring projects can be found at <a href="https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix">https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix</a>.</p>
<p>At the time of writing this book, most of the features that we require to implement OAuth is available as part Spring Security OAuth project, which is in maintenance mode.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth2 and Spring WebFlux</h1>
                </header>
            
            <article>
                
<p>Full-fledged OAuth2 support for a Spring WebFlux application is not available in Spring Security at the time of writing this book. However, there is a community urgency around this and many things are slowly and steadily getting into Spring Security in this regard. Many examples are also getting baked into the Spring Security project that show OAuth2 with Spring WebFlux. In the <a href="df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml">Chapter 5</a>, <em>Integrating with Spring WebFlux</em>, we saw one such example in detail. As of writing this book, Spring Security OAuth2 has a hard dependency on Spring MVC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Boot and OAuth2</h1>
                </header>
            
            <article>
                
<p>As of writing this book, Spring Boot has announced that it is dropping support for the Spring Security OAuth module. Instead, it will from now on with the Spring Security 5.x OAuth2 login features.</p>
<p>A new module named Spring Security OAuth Boot 2 Autoconfig (its dependency in pom.xml is as shown in the following code snippet), ported from Spring Boot 1.5.x, can be used to integrate Spring Security with Spring Boot:</p>
<pre>&lt;dependency&gt;<br/> &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;<br/> &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>The project source code can be found at <a href="https://github.com/spring-projects/spring-security-oauth2-boot">https://github.com/spring-projects/spring-security-oauth2-boot</a>). The full documentation for this module can be found at <a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/">https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample project</h1>
                </header>
            
            <article>
                
<p>In our sample project, we will set up our own authorization server, against which we will authorize the APIs exposed through our resource server. We have movie APIs exposed on our resource server, and the client application will authenticate with the application (the client application is Spring Security protected) and then try accessing one of the movie APIs, at which point the OAuth flow will kick in. After a successful authorization check with the authorization server, the client will be given access to the requested movie APIs.</p>
<p class="mce-root"/>
<p>We will have a parent project containing three Spring Boot projects: <kbd>oauth-authorization-server</kbd>, <kbd>oauth-resource-server</kbd>, and <kbd>oauth-client-app</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a82e06b-986d-4bde-8d68-05c3fd9afa17.png" style="width:56.67em;height:32.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 11: Project structure in IntelliJ</div>
<p>We will now look at each of the individual Spring Boot projects in the subsequent sections. The full source code is available on the book's GitHub page under the <kbd>spring-boot-spring-security-oauth</kbd><span> </span><span>project</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization server</h1>
                </header>
            
            <article>
                
<p>This is a conventional Spring Boot project, which implements the authorization server OAuth role.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependencies</h1>
                </header>
            
            <article>
                
<p>The main dependencies to be included in the Spring Boot project's <kbd>pom.xml</kbd> file are as shown in the following code snippet:</p>
<pre>&lt;!--Spring Boot--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;!--OAuth--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;<br/>  &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;!--JWT--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;<br/>  &lt;version&gt;1.0.9.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Boot run class</h1>
                </header>
            
            <article>
                
<p>There is nothing special in this Spring Boot <kbd>run</kbd> class, as shown in the following code snippet:</p>
<pre>@SpringBootApplication<br/>public class OAuthAuthorizationServerRun extends SpringBootServletInitializer {<br/>  public static void main(String[] args) {<br/>      SpringApplication.run(OAuthAuthorizationServerRun.class, args);<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security config</h1>
                </header>
            
            <article>
                
<p>The Spring Security config class extends <kbd>WebSecurityConfigurerAdapter</kbd>. We will override three methods, as shown in the following code snippet:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {<br/>  @Autowired<br/>  private BCryptPasswordEncoder passwordEncoder;<br/>  @Autowired<br/>  public void globalUserDetails(final AuthenticationManagerBuilder auth) throws <br/>        Exception {<br/>      auth<br/>          .inMemoryAuthentication()<br/>          .withUser("user").password(passwordEncoder.encode("password"))<br/>          .roles("USER")<br/>          .and()<br/>          .withUser("admin").password(passwordEncoder.encode("password"))<br/>          .roles("USER", "ADMIN");<br/>  }<br/>  //...<br/>}</pre>
<p>We <kbd>autowire</kbd> the password encoder. We then override the following methods: <kbd>globalUserDetails</kbd>, <kbd>authenticationManagerBean</kbd>, and <kbd>configure</kbd>. There isn't anything special to mention here. We define two users, managed in-memory (user and admin).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization server config</h1>
                </header>
            
            <article>
                
<p>This is the the most important in this Spring Boot project, where we will set up the authorization server configuration. We will use a new annotation, <kbd>@EnableAuthorizationServer</kbd>. Our configuration class will extend <kbd>AuthorizationServerConfigurerAdapter</kbd>. We will be using the JWT token store and will also showcase a token enhancer, using which you can enhance your JWT token with more claims, if deemed necessary for your application. The most important method in this configuration class is extracted as the following code snippet:</p>
<pre>@Override<br/>public void configure(final ClientDetailsServiceConfigurer clients) throws <br/>        Exception {<br/>  clients.inMemory()<br/>     .withClient("oAuthClientAppID")<br/>     .secret(passwordEncoder().encode("secret"))<br/>     .authorizedGrantTypes("password", "authorization_code", "refresh_token")<br/>     .scopes("movie", "read", "write")<br/>     .accessTokenValiditySeconds(3600)<br/>     .refreshTokenValiditySeconds(2592000)<br/>     .redirectUris("http://localhost:8080/movie/", <br/>        "http://localhost:8080/movie/index");<br/>}</pre>
<p>This is where we set up the client-related OAuth configuration. We set up just one client, and we use the in-memory option to make the example simpler to understand. Throughout the application, we will be using <kbd>BCrypt</kbd> as our password encoder. The client ID for our client app is <kbd>oAuthClientAppID</kbd> and the client secret is <kbd>secret</kbd>. We set up three grant types and while accessing the client, we need to specify the necessary scopes (movie, read, and write). After successful execution, the authorization server will redirect you to the specified URL (<kbd>http://localhost:8080/movie/</kbd> or <kbd>http://localhost:8080/movie/index</kbd>). If the URL is not correctly specified by the client, the server will throw an error.</p>
<p>The JWT token store and enhancer-related methods are as shown in the following code snippet:</p>
<pre>@Bean<br/>@Primary<br/>public DefaultTokenServices tokenServices() {<br/>  final DefaultTokenServices defaultTokenServices = new DefaultTokenServices();<br/>  defaultTokenServices.setTokenStore(tokenStore());<br/>  defaultTokenServices.setSupportRefreshToken(true);<br/>  return defaultTokenServices;<br/>}<br/>@Override<br/>public void configure(final AuthorizationServerEndpointsConfigurer endpoints) <br/>    throws Exception {<br/>  final TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();<br/>  tokenEnhancerChain.setTokenEnhancers(Arrays.asList(tokenEnhancer(), <br/>    accessTokenConverter()));<br/>  endpoints.tokenStore(tokenStore()).tokenEnhancer(tokenEnhancerChain)<br/>    .authenticationManager(authenticationManager);<br/>}<br/>@Bean<br/>public TokenStore tokenStore() {<br/>  return new JwtTokenStore(accessTokenConverter());<br/>}<br/>@Bean<br/>public JwtAccessTokenConverter accessTokenConverter() {<br/>  final JwtAccessTokenConverter converter = new JwtAccessTokenConverter();<br/>  converter.setSigningKey("secret");<br/>  return converter;<br/>}<br/>@Bean<br/>public TokenEnhancer tokenEnhancer() {<br/>  return new CustomTokenEnhancer();<br/>}</pre>
<p>In this code, we specify the token store, which will be used in the <kbd>tokenStore</kbd> method, and we also declare a <kbd>tokenEnhancer</kbd> bean. To showcase the token enhancer, we will be using a custom class named <kbd>CustomTokenEnhancer</kbd>; the class is as shown in the following code snippet:</p>
<pre>public class CustomTokenEnhancer implements TokenEnhancer {<br/>  @Override<br/>  public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, <br/>    OAuth2Authentication authentication) {<br/>      final Map&lt;String, Object&gt; additionalInfo = new HashMap&lt;&gt;();<br/>      additionalInfo.put("principalinfo", <br/>        authentication.getPrincipal().toString());<br/>      ((DefaultOAuth2AccessToken)accessToken)<br/>        .setAdditionalInformation(additionalInfo);<br/>      return accessToken;<br/>  }<br/>}</pre>
<p>The custom token <kbd>enhancer</kbd> class implements <kbd>TokenEnhancer</kbd>. We just add new information (<kbd>principalinfo</kbd>) into the JWT token that contains the <kbd>toString</kbd> version of the <kbd>principal</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application properties</h1>
                </header>
            
            <article>
                
<p>Since we are running all three servers locally, we have to specify different ports. Also, it's important that the authorization server runs on a different context path. The following code snippet shows what we have in our <kbd>application.properties</kbd> file:</p>
<pre>server.servlet.context-path=/oauth-server<br/>server.port=8082</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Being a Spring Boot project, it can be run by executing the <kbd>mvn spring-boot:run</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource server</h1>
                </header>
            
            <article>
                
<p>This is a conventional Spring Boot project, which implements the resource server OAuth role.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependencies</h1>
                </header>
            
            <article>
                
<p>There isn't anything new that we are going to add in our <kbd>pom.xml</kbd>. The same dependencies that we had in our authorization server project apply here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Boot run class</h1>
                </header>
            
            <article>
                
<p>This is a typical Spring Boot <kbd>run</kbd> class, into which we put the <kbd>@SpringBootApplication</kbd> annotation, which does all the magic behind the scenes. Again, nothing specific in our Spring Boot run class applies to this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource server config</h1>
                </header>
            
            <article>
                
<p>This is the main resource server configuration class, where we annotate it with the <kbd>@EnableResourceServer</kbd> annotation and extend it from <kbd>ResourceServerConfigurerAdapter</kbd>, as shown in the following code snippet:</p>
<pre>@Configuration<br/>@EnableResourceServer<br/>public class ResourceServerConfig extends ResourceServerConfigurerAdapter {<br/>  @Autowired<br/>  private CustomAccessTokenConverter customAccessTokenConverter;<br/>  @Override<br/>  public void configure(final HttpSecurity http) throws Exception {<br/>      http.sessionManagement()<br/>        .sessionCreationPolicy(SessionCreationPolicy.ALWAY)<br/>        .and()<br/>        .authorizeRequests().anyRequest().permitAll();<br/>  }<br/>  @Override<br/>  public void configure(final ResourceServerSecurityConfigurer config) {<br/>      config.tokenServices(tokenServices());<br/>  }<br/>  @Bean<br/>  public TokenStore tokenStore() {<br/>      return new JwtTokenStore(accessTokenConverter());<br/>  }<br/>  @Bean<br/>  public JwtAccessTokenConverter accessTokenConverter() {<br/>      final JwtAccessTokenConverter converter = new JwtAccessTokenConverter();<br/>      converter.setAccessTokenConverter(customAccessTokenConverter);<br/>      converter.setSigningKey("secret");<br/>      converter.setVerifierKey("secret");<br/>      return converter;<br/>  }<br/>  @Bean<br/>  @Primary<br/>  public DefaultTokenServices tokenServices() {<br/>      final DefaultTokenServices defaultTokenServices = <br/>        new DefaultTokenServices();<br/>      defaultTokenServices.setTokenStore(tokenStore());<br/>      return defaultTokenServices;<br/>  }<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security config</h1>
                </header>
            
            <article>
                
<p>Being the resource server, we are enabling global method security so that every method exposing an API is secured, as shown in the following code snippet:</p>
<pre>@Configuration<br/>@EnableGlobalMethodSecurity(prePostEnabled = true)<br/>public class SpringSecurityConfig extends GlobalMethodSecurityConfiguration {<br/>  @Override<br/>  protected MethodSecurityExpressionHandler createExpressionHandler() {<br/>      return new OAuth2MethodSecurityExpressionHandler();<br/>  }<br/>}</pre>
<p>Here, we are using <kbd>OAuth2MethodSecurityExpressionHandler</kbd> as the method security exception handler so that we can use annotations, as follows:</p>
<pre>@PreAuthorize("#oauth2.hasScope('movie') and #oauth2.hasScope('read')")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC config class</h1>
                </header>
            
            <article>
                
<p>We have seen Spring MVC configuration in detail in previous chapters. In our example, it's a very basic Spring MVC <kbd>config</kbd> class in which <kbd>@EnableWebMvc</kbd> is used and implements <kbd>WebMvcConfigurer</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controller class</h1>
                </header>
            
            <article>
                
<p>We have one controller class, which exposes just one method (we can extend it further to expose more APIs). This method lists all the movies in the hardcoded movie list under a URL, <kbd>/movie</kbd>, as shown in the following code snippet:</p>
<pre>@RestController<br/>public class MovieController {<br/>   @RequestMapping(value = "/movie", method = RequestMethod.GET)<br/>   @ResponseBody<br/>   @PreAuthorize("#oauth2.hasScope('movie') and #oauth2.hasScope('read')")<br/>   public Movie[] getMovies() {<br/>      initIt();//Movie list initialization<br/>      return movies;<br/>   }<br/>   //…<br/>}</pre>
<p>We are using a <kbd>Movie</kbd> model class utilizing all the features of the <kbd>lombok</kbd> library, as shown in the following code snippet:</p>
<pre>@Data<br/>@ToString<br/>@Builder<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>public class Movie {<br/>  private Long id;<br/>  private String title;<br/>  private String genre;<br/>}</pre>
<p>It has three attributes and the annotations will do all the magic and keep the model concise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application properties</h1>
                </header>
            
            <article>
                
<p>Similar to the authorization server, <kbd>application.properties</kbd> just has the context path and port assigned.</p>
<p>Being a Spring Boot project, it can be run by executing the <kbd>mvn spring-boot:run</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client application</h1>
                </header>
            
            <article>
                
<p>This is a conventional Spring Boot project, which implements the client OAuth role.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependencies</h1>
                </header>
            
            <article>
                
<p>In our Spring Boot <kbd>pom.xml</kbd> file, new Maven dependencies for <kbd>Thymeleaf</kbd> and for the <kbd>lombok</kbd> library are added. The rest are all typical of a Spring Boot <kbd>pom.xml</kbd> file, which you are now conversant with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Boot class</h1>
                </header>
            
            <article>
                
<p>In our example Spring Boot <kbd>run</kbd> class, there isn't anything worth mentioning. It is a simple class containing <span>the</span><span> </span><span>all-important</span> <kbd>main</kbd> <span>method and the </span><kbd>@SpringBootApplication</kbd> <span>annotation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth client config</h1>
                </header>
            
            <article>
                
<p>This is the main configuration class in the client application, which is annotated with <kbd>@EnableOAuth2Client</kbd>, as shown in the following code snippet:</p>
<pre>@Configuration<br/>@EnableOAuth2Client<br/>public class OAuthClientConfig {<br/>  @Autowired<br/>  private OAuth2ClientContext oauth2ClientContext;<br/><br/>  @Autowired<br/>  @Qualifier("movieAppClientDetails")<br/>  private OAuth2ProtectedResourceDetails movieAppClientDetails;<br/><br/>  @ConfigurationProperties(prefix = "security.oauth2.client.movie-app-client")<br/>  @Bean<br/>  public OAuth2ProtectedResourceDetails movieAppClientDetails() {<br/>      return new AuthorizationCodeResourceDetails();<br/>  }<br/>  @Bean<br/>  public BCryptPasswordEncoder passwordEncoder() {<br/>      return new BCryptPasswordEncoder();<br/>  }<br/>  @Bean<br/>  public OAuth2RestTemplate movieAppRestTemplate() {<br/>      return new OAuth2RestTemplate(movieAppClientDetails, oauth2ClientContext);<br/>  }<br/>}</pre>
<p>The important aspect to look at in this class is that we initialize the OAuth2 REST template by providing the client details, which are configured in the <kbd>application.yml</kbd> file.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security config</h1>
                </header>
            
            <article>
                
<p>In the Spring Security <kbd>config</kbd> class, we set up the user credentials (in-memory) that can be used to log in to the application and can access secured resources. In the <kbd>configure</kbd> method, some of the resources are marked as secured and some as unsecured.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controller classes</h1>
                </header>
            
            <article>
                
<p>We have two controller classes, <kbd>SecuredController</kbd> and <kbd>NonSecuredController</kbd>. As the name suggests, one is for declared secured routes and the other for unsecured routes. The <kbd>main</kbd> method in the secured controller that we are interested is shown in the following code snippet:</p>
<pre>@RequestMapping(value = "/movie/index", method = RequestMethod.GET)<br/>@ResponseBody<br/>public Movie[] index() {<br/>  Movie[] movies = movieAppRestTemplate<br/>    .getForObject(movieApiBaseUri, Movie[].class);<br/>  return movies;<br/>}</pre>
<p>We copied the <kbd>model</kbd> class used in the resource server project into the client application project as well. In an ideal scenario, all this common stuff would be converted into reusable JARs and set up as a dependency to both the projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Templates</h1>
                </header>
            
            <article>
                
<p>The templates are quite straightforward. The root context of the application redirects the user to an unsecured page. We have our own custom login page and after a successful login, the user is navigated to a secured page containing a link to the secured OAuth-backed movie listing API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application properties</h1>
                </header>
            
            <article>
                
<p>In this project, we are using <kbd>application.yml</kbd> files and the code is as follows:</p>
<pre>server:<br/>  port: 8080<br/>spring:<br/>  thymeleaf:<br/>    cache: false<br/>security:<br/>  oauth2:<br/>    client:<br/>      movie-app-client:<br/>        client-id: oAuthClientAppID<br/>        client-secret: secret<br/>        user-authorization-uri: http://localhost:8082/oauth-server/oauth/authorize<br/>        access-token-uri: http://localhost:8082/oauth-server/oauth/token<br/>        scope: read, write, movie<br/>        pre-established-redirect-uri: http://localhost:8080/movie/index<br/>movie:<br/>  base-uri: http://localhost:8081/oauth-resource/movie</pre>
<p>The very important aspect of this YML file is the <kbd>movie-app-client</kbd> properties setup. Again, being a Spring Boot project, it can be run by executing the <kbd>mvn spring-boot:run</kbd> command.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the project</h1>
                </header>
            
            <article>
                
<p>Start all the projects individually using the Spring Boot <span><kbd>mvn spring-boot:run</kbd></span><span> command. I am using Spring Dashboard in IntelliJ, where I can launch all the projects, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f21f02f6-d40c-4e79-a32c-324886db5c03.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 12: Spring Dashboard in IntelliJ</div>
<p>Navigate to <kbd>http://localhost:8080</kbd> and you will be redirected to the unsecured page of the client application, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d35a94e3-cbdb-4023-9afd-1e6a48b46cfc.png" style="width:40.50em;height:15.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 13: Unsecured page of client app</div>
<p>Click on the link, and you will be taken to the custom login page, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88846da5-d718-452c-9193-ea3637bd0b20.png" style="width:39.00em;height:25.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 14: Custom login page of client app</div>
<p>Enter the username/password as required on the page; then, clicking on <span class="packt_screen">Log In</span> will take you to the secured page, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e0fe14e3-c9f7-45a3-8341-763f88434956.png" style="width:40.25em;height:17.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 15: Secured page in client app</div>
<p>Click on the movie API link, and you will be taken to the OAuth flow and then to the authorization server default login page to enter credentials, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6dea5c50-4ea6-4b8e-9507-b3105e8ac5e3.png" style="width:55.17em;height:15.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 16: Authorization server login page</div>
<p>Enter the username/password (we have kept that as user/password) and click on the <span class="packt_screen">Login</span> button. You will be taken to the <span>authorization</span> page, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0889860-4aef-44de-bb61-3bd099664046.png" style="width:56.17em;height:18.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 17: <span>Authorization</span> page on authorization server</div>
<p>Click on <span class="packt_screen">Authorize</span> and you will be taken back to the client application page, which displays all the movies from the resource server, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/68d63f0a-c1a8-460b-8739-1fa9ae252fbd.png" style="width:47.75em;height:27.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 18: Movie listing page in the client app displaying a movie API exposed on resource server</div>
<p>With this, we have completed our sample application, in which we have implemented all the roles that are part of OAuth.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started this chapter by introducing you to some of the important concepts that are needed to follow along with it. We then covered the important characteristics needed in a modern web application. We quickly covered an architecture called <strong>SOFEA</strong>, which aptly covers how we would like to build modern applications. We then got our hands dirty by implementing security for REST APIs in the simplest of ways.</p>
<p>In the following section, we covered how we can secure a REST API in a more advanced fashion employing OAuth, using a JWT. We started this section by introducing many concepts in regards to OAuth and finally concluded the chapter with a full-fledged sample project that uses OAuth and JWT.</p>
<p>After reading this chapter, you should have a clear understanding of REST, OAuth, and JWT. You should also be comfortable with using Spring Security in the next chapter, to secure the RESTful endpoints exposed in your application.</p>


            </article>

            
        </section>
    </body></html>