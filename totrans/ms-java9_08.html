<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Microbenchmarking Applications with JMH</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we took an in-depth review of <strong>garbage collection</strong> to include an object life cycle, garbage collection algorithms, garbage collection options, and methods related to garbage collection. We took a brief look at upgrades to garbage collection in Java 8 and focused on changes with the new Java 9 platform. Our exploration of garbage collection in Java 9 included looks at default garbage collection, depreciated garbage collection combinations, unified garbage collection logging, and garbage collection issues that persist, even after Java 9.</p>
<p>In this chapter, we will look at how to write performance tests using the <strong>Java Microbenchmark Harness</strong> (<strong>JMH</strong>), a Java harness library for writing benchmarks for the <strong>Java Virtual Machine</strong> (<strong>JVM</strong>). We will use Maven along with JMH to help illustrate the power of microbenchmarking with the new Java 9 platform.</p>
<p>Specifically, we will cover the following topics:</p>
<ul>
<li>Microbenchmarking overview</li>
<li>Microbenchmarking with Maven</li>
<li>Benchmarking options</li>
<li>Techniques for avoiding microbenchmarking pitfalls</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microbenchmarking overview</h1>
                </header>
            
            <article>
                
<p>Microbenchmarking is used to test the performance of a system. This differs from macrobenchmarking which runs tests on different platforms for efficiency comparison and subsequent analysis. With microbenchmarking, we typically target a specific slice of code on one system such as a method or loop. The primary purpose of microbenchmarking is to identify optimization opportunities in our code.</p>
<p>There are multiple approaches to benchmarking and we will focus on using the JMH tool. So, why benchmark at all? Developers do not always concern themselves with performance issues unless performance is a stated requirement. This can lead to post-deployment surprises that could have been avoided if microbenchmarking was conducted as part of the development process.</p>
<p>Microbenchmarking takes place across several phases of a process. As shown in the following diagram, the process involves design, implementation, execution, analysis, and enhancement:</p>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="301" src="assets/b4195464-132a-4f2d-9e1b-db9f7b2feb54.png"/></div>
<p>In the <strong>Design</strong> phase, we determine our goals and design our microbenchmark accordingly. In the <strong>Implement</strong> phase, we are writing the microbenchmark and then, in the <strong>Execution</strong> phase, we actually run the test. With microbenchmarking results in hand, we interpret and analyze the results in the <strong>Analysis</strong> phase. This leads to code improvements in the <strong>Enhancement</strong> phase. Once our code has been updated, we redesign the microbenchmarking test, adjust the implementation, or go straight to the <strong>Execution</strong> phase. This is a cyclical process that continues until we have achieved the performance optimization we identified in our goals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Approach to using JMH</h1>
                </header>
            
            <article>
                
<p>Oracle's documentation indicates that the most ideal JMH use case is to use a Maven project that is dependent on the application's JAR files. They further recommend that microbenchmarking take place via the command-line and not from within an <strong>Integrated Development Environment</strong> (<strong>IDE</strong>), as that could impact the results.</p>
<div class="packt_infobox">Maven, also referred to as Apache Maven, is a project management and comprehension tool that we can use to manage our application project build, reporting, and documentation.</div>
<p>To use JMH, we will use bytecode processors (annotations) to generate the benchmark code. We use Maven archetypes to enable JMH.</p>
<p>In order to test the JMH, we require an IDE with support for Maven and Java 9. If you do not yet have Java 9 or an IDE with Java 9 support, you can follow the steps in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Java 9 and Eclipse with Java 9 support</h1>
                </header>
            
            <article>
                
<p>You can download and install Java 9 from the JDK 9 early access builds page--<a href="http://jdk.java.net/9/">http://jdk.java.net/9/</a>.<a href="http://jdk.java.net/9/"/></p>
<p>Once you have Java 9 installed, download the latest version of Eclipse. At the time of writing this book, that was Oxygen. Here is the relevant link--<a href="https://www.eclipse.org/downloads/">https://www.eclipse.org/downloads/</a>.<a href="https://www.eclipse.org/downloads/"/></p>
<p>The next step is to enable Java 9 support in your IDE. Launch Eclipse Oxygen and select <span class="packt_screen">Help</span> | <span class="packt_screen">Eclipse Marketplace...</span> , as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/57fba344-7e48-458d-a6d1-dda6a55edaf0.png"/></div>
<p>With the <span class="packt_screen">Eclipse Marketplace</span> dialog window present search for <kbd>Java 9 support</kbd> using the search box. As you can see in the following screenshot, you will be presented with an <span class="packt_screen">Install</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img height="451" width="447" src="assets/aa53fca7-c6c1-4575-8b6b-9be25d3353b0.png"/></div>
<p>During the installation process, you will be required to accept the license agreement and, upon completion, you will be required to restart Eclipse.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hands-on experiment</h1>
                </header>
            
            <article>
                
<p>Now that we have Eclipse updated to support Java 9, you can run a quick test to determine if JMH is working on your development computer. Start by creating a new Maven project as illustrated in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="432" width="474" src="assets/ef583a68-d03f-4ab7-beaa-73a9aad3cbda.png"/></div>
<p>Next, we need to add a dependency. We can do this by editing the <kbd>pom.xml</kbd> file directly with the following code:</p>
<pre>    &lt;dependency&gt;<br/>      &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;<br/>      &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;<br/>      &lt;version&gt;0.1&lt;/version&gt;<br/>    &lt;/dependency&gt;</pre>
<p>Alternatively, we can use the dependencies tab to enter the data in a dialog window, as shown in the following screenshot. Using this form updates the <kbd>pom.xml</kbd> file with the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/40fdc0e6-c674-4137-b7ca-6fb8cfe3a06b.png"/></div>
<p>Next, we need to write a class that contains a JMH method. This is just as an initial test to confirm our recently updated development environment. Here is sample code you can use for your test:</p>
<pre>    package com.packt.benchmark.test.com.packt.benchmark.test;<br/><br/>    import org.open.jdk.jmh.Main;<br/><br/>    public class Test <br/>    {<br/><br/>      public static void main(String[] args)<br/>      {<br/>        Main.main(args);<br/>      }<br/>    }</pre>
<p>We can now compile and run our very simple test program. The results are provided in the Console tab, or the actual console if you are using the command-line. Here is what you will see:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e8cab196-ef67-4976-b5df-2ea9829c0fd2.png"/></div>
<p>You can see that the program worked sufficiently to let us know that JMH is working. Of course, there was, as the output indicates, no benchmarks set up. We will take care of that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microbenchmarking with Maven</h1>
                </header>
            
            <article>
                
<p>One approach to getting started with JMH is to use the JMH Maven archetype. The first step is to create a new JMH project. At our system's command prompt, we will enter the <kbd>mvn</kbd> command followed by a long set of parameters to create a new Java project and the necessary Maven <kbd>pom.xml</kbd> file:</p>
<pre><strong>mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh -java-benchmark-archetype -DgroupId=com.packt -DartifactId=chapter8-benchmark -Dversion=1.0</strong></pre>
<p>Once you enter the <kbd>mvn</kbd> command and the preceding detailed parameters, you will see the results reported to you via the Terminal. Depending on your level of use, you might see a large number of downloads from <a href="https://repo.maven.apache.org/maven2/org/apache/mave/plugins">https://repo.maven.apache.org/maven2/org/apache/mave/plugins</a> and other similar repository sites.</p>
<p>You will also see an information section that informs you about the project build process:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f523348a-c1d0-4a77-816c-53dfa4edf109.png"/></div>
<p>There will likely be additional plugin and other resources downloaded from the <a href="https://repo.maven.apache.org">https://repo.maven.apache.org</a> repositories. Then, you will see an informational feedback component that lets you know the project is being generated in batch mode:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eb375a4a-2307-4397-82fc-97e86c026674.png"/></div>
<p>Finally, you will be presented with a set of parameters and a note that your project build was successful. As you can see with the following example, the process took less than 21 seconds to complete:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e44a677c-bc89-4081-9c7f-134ec33d5f7f.png"/></div>
<p>A folder will be created based on the parameter we included in the <kbd>-DartifactId</kbd> option. In our example, we used <kbd>-DartifactId=chapter8-benchmark</kbd>, and Maven created a <kbd>chapter8-benchmark</kbd> project folder:</p>
<div class="CDPAlignCenter CDPAlign"><img height="239" width="464" src="assets/ef150f8f-97fa-4661-bf78-43fdc0a036bf.png"/></div>
<p>You will see that Maven created the <kbd>pom.xml</kbd> file as well as a source (<kbd>src</kbd>) folder. In that folder, under the subdirectory structure of <kbd>C:\chapter8-benchmark\src\main\java\com\packt</kbd>, is the <kbd>MyBenchmark.java</kbd> file. Maven created a benchmark class for us:</p>
<div class="CDPAlignCenter CDPAlign"><img height="208" width="455" src="assets/161210fe-69e3-49fa-a255-659cd554024a.png"/></div>
<p>Here are the contents of the <kbd>MyBenchmark.java</kbd> class created by the JMH Maven project creation process:</p>
<pre class="mce-root">    /*<br/>     * Copyright (c) 2014, Oracle America, Inc.<br/>     * All rights reserved.<br/>     *<br/>     * Redistribution and use in source and binary forms, with or <br/>       without<br/>     * modification, are permitted provided that the following <br/>       conditions are met:<br/>     *<br/>     * * Redistributions of source code must retain the above<br/>         copyright notice,<br/>     * this list of conditions and the following disclaimer.<br/>     *<br/>     * * Redistributions in binary form must reproduce the above <br/>         copyright<br/>     * notice, this list of conditions and the following<br/>       disclaimer in the<br/>     * documentation and/or other materials provided with the <br/>       distribution.<br/>     *<br/>     * * Neither the name of Oracle nor the names of its <br/>         contributors may be used<br/>     * to endorse or promote products derived from this software <br/>       without<br/>     * specific prior written permission.<br/>     *<br/>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND <br/>       CONTRIBUTORS "AS IS"<br/>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT <br/>       LIMITED TO, THE<br/>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A <br/>       PARTICULAR PURPOSE<br/>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR <br/>       CONTRIBUTORS BE<br/>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, <br/>       EXEMPLARY, <br/>       OR<br/>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, <br/>       PROCUREMENT OF<br/>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;<br/>       OR BUSINESS<br/>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, <br/>       WHETHER IN<br/>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR <br/>       OTHERWISE)<br/>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF <br/>       ADVISED OF<br/>     * THE POSSIBILITY OF SUCH DAMAGE.<br/>     */<br/><br/>    package com.packt;<br/><br/>    import org.openjdk.jmh.annotations.Benchmark;<br/><br/>    public class MyBenchmark <br/>    {<br/>      @Benchmark<br/>      public void testMethod() <br/>      {<br/><br/>        // This is a demo/sample template for building your JMH <br/>           benchmarks. <br/>        //Edit as needed.<br/>        // Put your benchmark code here.<br/>      }<br/>    }</pre>
<p>Our next step is to modify the <kbd>testMethod()</kbd> so that there is something to test. Here is the modified method we will use for the benchmark test:</p>
<pre>    @Benchmark<br/>    public void testMethod() <br/>    {<br/>      int total = 0;<br/>      for (int i=0; i&lt;100000; i++)<br/>      {<br/>        total = total + (i * 2 );<br/>      }<br/>      System.out.println("Total: " + total);<br/>    }</pre>
<p>With our code edited, we will navigate back to the project folder, <kbd>C:\chapter8-benchmark</kbd>, in our example, and execute <kbd>mvn clean install</kbd> at the command prompt.</p>
<p>You will see several repository downloads, source compilations, plugin installations and, finally the Build Success indicator, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/efd78607-4338-489f-a4d2-2f5accb102b0.png"/></div>
<p>You will now see <kbd>.classpath</kbd> and <kbd>.project</kbd> files as well as a new <kbd>.settings</kbd> and target subfolders in the project directory:</p>
<div class="CDPAlignCenter CDPAlign"><img height="275" width="401" src="assets/cce6a92e-c716-4967-b577-c2bf09048e07.png"/></div>
<p>If you navigate to the <kbd>\target</kbd> subfolder, you will see that our <kbd>benchmarks.jar</kbd> file was created. This JAR contains what we need to run our benchmarks.</p>
<p>We can update our <kbd>MyBenchmark.java</kbd> file in an IDE, such as Eclipse. Then, we can execute <kbd>mvn clean install</kbd> again to overwrite our files. After the initial time, our builds will be much faster, as nothing will need to be downloaded. Here is a look at the output from the build process other than the first time:</p>
<div class="CDPAlignCenter CDPAlign"><img height="575" width="465" src="assets/b0d5ac8e-d935-41c3-b15f-8be1b18fed82.png"/></div>
<p>Our last step is to run the benchmark tool. We can do that with the following command--<kbd>java -jar benchmarks.jar</kbd>. Even for small benchmarks on simplistic code, as with our example, the benchmarks could take some time to run. There will likely be several iterations including warmups to provide a more concise and valid set of benchmark results.</p>
<p>Our benchmark results are provided here. As you can see, the test ran for 8 minutes and 8 seconds:</p>
<div class="CDPAlignCenter CDPAlign"><img height="233" width="514" src="assets/50446f86-6bbe-4c87-a0b7-7db91e1bf3ee.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benchmarking options</h1>
                </header>
            
            <article>
                
<p>In the previous section, you learned how to run a benchmark test. In this section, we will look at the following configurable options for running our benchmarks:</p>
<ul>
<li>Modes</li>
<li>Time units</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modes</h1>
                </header>
            
            <article>
                
<p>The output of our benchmark results, from the previous section, included a <strong>Mode</strong> column that had the value of <strong>thrpt</strong> which is short for <strong>throughput</strong>. This is the default mode and there are an additional four modes. All JMH benchmark modes are listed and described as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Mode</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>All</td>
<td>Measures all other modes inclusively.</td>
</tr>
<tr>
<td>Average</td>
<td>This mode measures the average time for a single benchmark to run.</td>
</tr>
<tr>
<td>Sample Time</td>
<td>This mode measures the benchmark execution time and includes min and max times.</td>
</tr>
<tr>
<td>Single Shot Time</td>
<td>With this mode, there is no JVM warm up and the test is to determine how long a single benchmark method takes to run.</td>
</tr>
<tr>
<td>Throughput</td>
<td>This is the default mode and measures the number of operations per second the benchmark could be run.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>To dictate which benchmark mode to use, you will modify your <kbd>@Benchmark</kbd> line of code to one of the following:</p>
<pre>    @Benchmark @BenchmarkMode(Mode.All)<br/>    @Benchmark @BenchmarkMode(Mode.Average)<br/>    @Benchmark @BenchmarkMode(Mode.SamplmeTime)<br/>    @Benchmark @BenchmarkMode(Mode.SingleShotTime)<br/>    @Benchmark @BenchmarkMode(Mode.Throughput)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time units</h1>
                </header>
            
            <article>
                
<p>In order to gain greater fidelity in benchmark output, we can designate a specific unit of time, listed here from shortest to longest:</p>
<ul>
<li><kbd>NANOSECONDS</kbd></li>
<li><kbd>MICROSECONDS</kbd></li>
<li><kbd>MILLISECONDS</kbd></li>
<li><kbd>SECONDS</kbd></li>
<li><kbd>MINUTES</kbd></li>
<li><kbd>HOURS</kbd></li>
<li><kbd>DAYS</kbd></li>
</ul>
<p>In order to make this designation, we simply add the following code to our <kbd>@Benchmark</kbd> line:</p>
<pre>    @Benchmark @BenchmarkMode(Mode.Average) <br/>    @OutputTimeUnit(TimeUnit.NANOSECONDS)</pre>
<p>In the preceding example, we have designated the average mode and nanoseconds as the time unit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Techniques for avoiding microbenchmarking pitfalls</h1>
                </header>
            
            <article>
                
<p>Microbenchmarking is not something that every developer will have to worry about, but for those that do, there are several pitfalls that you should be aware of. In this section we will review the most common pitfalls and suggest strategies for avoiding them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Power management</h1>
                </header>
            
            <article>
                
<p>There are many subsystems that can be used to help you manage the balance between power and performance (that is, <kbd>cpufreq</kbd>). These systems can alter the state of time during benchmarks.</p>
<p>There are two suggested strategies to this pitfall:</p>
<ul>
<li>Disable any power management systems before running tests</li>
<li>Run the benchmarks for longer periods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OS schedulers</h1>
                </header>
            
            <article>
                
<p>Operating system schedulers, such as Solaris schedulers, help determine which software processes gain access to a system's resources. Use of these schedulers can result in unreliable benchmarking results.</p>
<p>There are two suggested strategies to this pitfall:</p>
<ul>
<li>Refine your system scheduling policies</li>
<li>Run the benchmarks for longer periods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time sharing</h1>
                </header>
            
            <article>
                
<p>Time-sharing systems are used to help balance system resources. Use of these systems often results in irregular gaps between a thread's start and stop time. Also, CPU load will not be uniform and our benchmarking data will not be as useful to us.</p>
<p>There are two suggested strategies to avoid this pitfall:</p>
<ul>
<li>Test all code before running benchmarks to ensure things work as they should</li>
<li>Use JMH to measure only after all threads have started or all threads have stopped</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Eliminating dead-code and constant folding</h1>
                </header>
            
            <article>
                
<p>Dead-code and constant folding are often referred to as redundant code and our modern compilers are pretty good at eliminating them. An example of dead-code is code that will never be reached. Consider the following example:</p>
<pre>    . . . <br/><br/>    int value = 10;<br/><br/>    if (value != null)<br/>    {<br/>      System.out.println("The value is " + value + ".");<br/>    } else <br/>      {<br/>         System.out.println("The value is null."); // This is<br/>         a line of Dead-Code<br/>    }<br/><br/>    . . . </pre>
<p>In our preceding example, the line identified as dead-code is never reached since the variable value will never be equal to null. It is set to <kbd>10</kbd> immediately before the conditional <kbd>if</kbd> statement evaluates the variable.</p>
<p>The problem is that benchmarking code can sometimes be removed in the attempt to eliminate dead-code.</p>
<p>Constant folding is the compiler operation that occurs when compile-time constraints are replaced with actual results. The compiler performs constant folding to remove any redundant runtime computations. In the following example, we have a <kbd>final int</kbd> followed by a second <kbd>int</kbd> based on a mathematical calculation involving the first <kbd>int</kbd>:</p>
<pre>    . . . <br/><br/>    static final int value = 10;<br/><br/>    int newValue = 319 * value;<br/><br/>    . . . </pre>
<p>The constant folding operation would convert the two lines of the preceding code to the following:</p>
<pre>    int newValue = 3190;</pre>
<p>There is one suggested strategy to this pitfall:</p>
<ul>
<li>Use the JMH API support to ensure your benchmarking code is not eliminated</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Run-to-run variance</h1>
                </header>
            
            <article>
                
<p>There are a plethora of issues that can drastically impact the run-to-run variance in benchmarking.</p>
<p>There are two suggested strategies to this pitfall:</p>
<ul>
<li>Run the JVM multiple times within every subsystem</li>
<li>Use multiple JMH folks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cache capacity</h1>
                </header>
            
            <article>
                
<p><strong>Dynamic randomly accessed memory</strong> (<strong>DRAM</strong>) is very slow. This can result in very different performance results during benchmarking.</p>
<p>There are two suggested strategies to this pitfall:</p>
<ul>
<li>Run multiple benchmarks with varying problem sets. Keep track of your memory footprint during tests.</li>
<li>Use the <kbd>@State</kbd> annotation to dictate the JMH state. This annotation is sued to define the instance's scope. There are three states:
<ul>
<li><kbd>Scope.Benchmark</kbd>: The instance is shared across all threads that are running the same test.</li>
<li><kbd>Scope.Group</kbd>: One instance is allocated per thread group.</li>
<li><kbd>Scope.Thread</kbd>: Each thread will have its own instance. This is the default state.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we <span>learned</span> that <span>the JMH is a Java harness library for writing benchmarks for the JVM. We experimented <span>with writing performance tests using</span> Maven along with JMH to help illustrate the procedures of microbenchmarking with the new Java 9 platform. We started with a</span> <span>microbenchmarking overview, then dove deep into</span> <span>microbenchmarking with Maven, reviewed</span> <span>benchmarking options, and concluded with a few t</span><span>echniques for avoiding microbenchmarking pitfalls.</span></p>
<p>In the next chapter, we will learn to write an application that is managing other processes and utilizes the modern process management API of the Java 9 platform.</p>


            </article>

            
        </section>
    </body></html>