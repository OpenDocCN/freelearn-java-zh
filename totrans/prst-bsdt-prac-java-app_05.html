<html><head></head><body>
		<div id="_idContainer044">
			<h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor093"/>5</h1>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor094"/>Jakarta EE and JPA – State of Affairs</h1>
			<p><a id="_idTextAnchor095"/>Java, both in language and platform, has improved significantly in enabling an effective developer experience and creating highly performant stateful applications. Remarkable improvements become evident when examining the evolution of Java database integration <a id="_idIndexMarker149"/>capabilities and developer experience: look back to the introduction of <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) in 1997 <a id="_idIndexMarker150"/>with the <strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>) <strong class="source-inline">1.1</strong> and compare it with the most modern experience offered by <strong class="bold">Jakarta Enterprise Edition</strong> (<strong class="bold">Jakarta </strong><span class="No-Break"><strong class="bold">EE</strong></span><span class="No-Break">), </span><span class="No-Break"><strong class="bold">MicroProfile</strong></span><span class="No-Break"><a id="_idTextAnchor096"/>.</span></p>
			<p>This chapter <a id="_idIndexMarker151"/>presents an introduction and overview of the present and future of the main enablers of Java’s evolution and constant growth—Jakarta EE, formerly Java EE, and Eclipse MicroProfile. From one side, the Eclipse Foundation and Jakarta EE target enterprise organizations’ need for stability and reliability. Conversely, there’s Eclipse MicroProfile, with fast interactions and constant innovation. In parallel, the Jakarta EE platform keeps evolving and adopting comprehensive MicroProfile technologies. All this is happening as you read, so it’s time to finally comprehend what’s happening in the open community and what to expect from a data <span class="No-Break">solution perspective<a id="_idTextAnchor097"/>.</span></p>
			<p>Java engineers seeking to deliver scalable enterprise solutions that smoothly enable distributed architectures mostly rely on a platform that can support cloud-native and traditional solutions. In the corporate world, given the long-term adoption of Java, there’s a frequent requirement for flexible technologies that can bring the best out of existing technologies and infrastructure without giving up on the opportunity of delivering new cloud-native solutions. In this context, the Jakarta EE platform is a <span class="No-Break">great choice.</span></p>
			<p>The specification of Jakarta EE is huge and impacts the whole Java community; it is essential to highlight that if you’re using Spring, Micronaut, or Quarkus, you’re using Jakarta EE even indirectly. In this chapter, we’ll check the specifications that Jakarta <span class="No-Break">EE covers.</span></p>
			<p>We’ll cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Jakarta <span class="No-Break">EE overview</span></li>
				<li>Framework unveiled—reflection versus <span class="No-Break">reflectionless solutions</span></li>
				<li><strong class="bold">Java Persistence API</strong> (<strong class="bold">JPA</strong>) state <span class="No-Break">of affairs</span></li>
				<li>The power <a id="_idIndexMarker152"/>of JPA with Quarkus and Panache <span class="No-Break">cloud-native runtimes</span></li>
				<li>General JPA-related <span class="No-Break">performance considerati<a id="_idTextAnchor098"/>ons</span></li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>For this chapter, you will need <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Git</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li>Any <span class="No-Break">preferred IDE</span></li>
			</ul>
			<p>The code for this chapter can be found in the following <span class="No-Break">GitHub repository:</span></p>
			<p><a href="https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter﻿-05"><span class="No-Break">https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter<span id="_idTextAnchor100"/>-05</span></a></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor101"/>Jakarta EE overview</h1>
			<p>At the heart of Jakarta EE lies its collection of specifications, each addressing specific aspects <a id="_idIndexMarker153"/>of enterprise architecture. These specifications, commonly <a id="_idIndexMarker154"/>called the “EE specifications,” are designed to cover various use cases encountered in enterprise application development. They provide standardized approaches and guidelines for implementing key functionalities, ensuring interoperability and portability across <span class="No-Break">different implementations.</span></p>
			<p>The Jakarta EE specifications cater to a broad spectrum of enterprise architecture needs, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Web applications</strong>: The Jakarta Servlet specification provides a platform-independent <a id="_idIndexMarker155"/>API for building web applications. It defines how web requests and responses are handled, allowing developers to create dynamic, interactive, secure <span class="No-Break">web-based solutions.</span></li>
				<li><strong class="bold">Enterprise integration</strong>: The <strong class="bold">Jakarta Messaging</strong> (<strong class="bold">JMS</strong>) specification provides a <a id="_idIndexMarker156"/>messaging system <a id="_idIndexMarker157"/>enabling seamless communication between distributed application components. It ensures a reliable and asynchronous exchange of information, facilitating integration across <span class="No-Break">disparate systems.</span></li>
				<li><strong class="bold">Persistence</strong>: The JPA specification simplifies database <a id="_idIndexMarker158"/>access and manipulation by providing an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) framework. It allows developers <a id="_idIndexMarker159"/>to interact with relational <a id="_idIndexMarker160"/>databases using Java objects, abstracting the underlying SQL operations. We can include the Jakarta Bean <a id="_idIndexMarker161"/>Validation specification to define constraints on Java driven by annotations; further more, new specifications are coming to support NoSQL and <strong class="bold">domain-driven design</strong> (<span class="No-Break"><strong class="bold">DDD</strong></span><span class="No-Break">) repositories.</span></li>
				<li><strong class="bold">Dependency injection (DI)</strong>: The Jakarta <strong class="bold">Contexts Dependency Injection</strong> (<strong class="bold">CDI</strong>) specification <a id="_idIndexMarker162"/>facilitates loose <a id="_idIndexMarker163"/>coupling and promotes modular <a id="_idIndexMarker164"/>development by managing object creation, wiring, and life cycle management. It enables the easy integration of different components within an application, enhancing maintainability <span class="No-Break">and testability.</span></li>
				<li><strong class="bold">Security</strong>: The <a id="_idIndexMarker165"/>Jakarta Security specification offers a comprehensive set of APIs and services for securing enterprise applications. It provides authentication, authorization, and data protection mechanisms, helping developers build secure applications and protect <span class="No-Break">sensitive information.</span></li>
				<li><strong class="bold">RESTful web services</strong>: The <strong class="bold">Jakarta RESTful Web Services</strong> (<strong class="bold">JAX-RS</strong>) specification <a id="_idIndexMarker166"/>simplifies <a id="_idIndexMarker167"/>the development of web <a id="_idIndexMarker168"/>services using the <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) architectural style. It provides a set of annotations and APIs for building scalable, lightweight, and interoperable <span class="No-Break">web APIs.</span></li>
			</ul>
			<p>The following diagram shows an overview of Jakarta EE 10 API, where you see the huge number of specifications that can help you as a software engineer; another area of <a id="_idIndexMarker169"/>the diagram is related to profiles. Currently, there are three profiles that you can use based on <span class="No-Break">your needs:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 5.1 ﻿– Jakarta EE 10 specification" src="image/Figure_5.01_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Jakarta EE 10 specification</p>
			<p>These are just a few examples of the extensive specifications available in Jakarta EE. Each specification addresses specific requirements, ensuring developers have the tools and guidelines to tackle various enterprise <span class="No-Break">architecture challenges.</span></p>
			<p>By adhering to Jakarta EE specifications, developers can create portable applications across <a id="_idIndexMarker170"/>different application servers and vendors, allowing flexibility and scalability. The specifications foster interoperability and compatibility, enabling seamless integration with other systems <span class="No-Break">and services.</span></p>
			<p>Those specifications will help you with modern concepts, approaches, and architectural models. In the Jakarta EE 10 API, we have the CDI Lite specification, where the goal is to reduce reflection, but what is wrong with reflection? In the next section, let’s talk about <a id="_idTextAnchor102"/>this in <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor103"/>Framework unveiled – reflection versus reflectionless solutions</h1>
			<p>Java frameworks are crucial in simplifying and accelerating application development <a id="_idIndexMarker171"/>by providing reusable components, predefined structures, and standard methodologies. These frameworks <a id="_idIndexMarker172"/>encapsulate common functionalities and design patterns, allowing developers to focus on business logic rather than low-level <span class="No-Break">implementation details.</span></p>
			<p>One fundamental concept in Java programming and many Java frameworks is reflection. Reflection enables a program to examine and modify its structure and behavior at runtime dynamically. It provides a mechanism for inspecting and manipulating classes, interfaces, methods, and fields, even if they are unknown at <span class="No-Break">compile time.</span></p>
			<p>Reflection is essential to developers for several reasons. Here, we list some <span class="No-Break">of these:</span></p>
			<ul>
				<li><strong class="bold">Dynamic code execution</strong>: Reflection allows developers to instantiate classes, invoke <a id="_idIndexMarker173"/>methods, and access fields at runtime. This flexibility enables the creation of flexible, extensible, and customizable applications. For example, frameworks such as Spring and Hibernate heavily rely on reflection to dynamically create and wire dependencies, perform data mapping, and handle various aspects of <span class="No-Break">application behavior.</span></li>
				<li><strong class="bold">Metadata extraction</strong>: Reflection enables the extraction of metadata associated <a id="_idIndexMarker174"/>with classes, methods, and fields. This metadata may include information such as annotations, modifiers, generic types, and method signatures. By analyzing this metadata, developers can implement advanced application functionalities and behavior. For instance, frameworks such as JUnit use reflection to discover and execute test cases based <span class="No-Break">on annotations.</span></li>
				<li><strong class="bold">Frameworks and annotations</strong>: Java frameworks often utilize annotations, markers <a id="_idIndexMarker175"/>added to classes, methods, or fields to provide additional information or configure specific behaviors. Frameworks such as Spring, JPA, and Java Servlet extensively use annotations and reflection to simplify configuration and customization. Reflection allows frameworks to scan and process these annotations <a id="_idIndexMarker176"/>at runtime, enabling automatic configuration, DI, and <strong class="bold">Aspect-Oriented </strong><span class="No-Break"><strong class="bold">Programming</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AOP</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>However, while reflection offers excellent flexibility and power, it can impact the performance <a id="_idIndexMarker177"/>of Java applications <a id="_idIndexMarker178"/>during startup. The process of introspecting classes and loading metadata dynamically can introduce significant overhead, especially in serverless or cloud-native environments where fast startup times <span class="No-Break">are crucial.</span></p>
			<p class="callout-heading">Why does this matter? Native compilation for Java applications</p>
			<p class="callout">A great <a id="_idIndexMarker179"/>example is the creation of natively executable Java applications, where developers use <strong class="bold">Java virtual machines</strong> (<strong class="bold">JVMs</strong>) such as GraalVM (Oracle) and Mandrel (Red Hat) to compile these applications and generate native binaries. This process, based on <strong class="bold">ahead-of-time</strong> (<strong class="bold">AOT</strong>) compilation, results <a id="_idIndexMarker180"/>in the inability to use some behaviors during runtime—including reflection. The AOT compiler does static code analysis during build time to create a native executable, which means that all processing done via dynamic loading (such as reflection, the <strong class="bold">Java Native Interface</strong> (<strong class="bold">JNI</strong>), or proxies) represents potential issues for this <span class="No-Break">use case.</span></p>
			<p>To address this issue, frameworks such as Quarkus and Micronaut have adopted an alternative <a id="_idIndexMarker181"/>approach known as the <strong class="bold">build-time</strong> or <strong class="bold">compile-time</strong> approach. Instead <a id="_idIndexMarker182"/>of relying on <em class="italic">runtime</em> reflection, these frameworks leverage annotations to capture necessary metadata <em class="italic">during the build process</em>. Doing so eliminates costly reflection operations at runtime and delivers faster startup times and <span class="No-Break">improved performance.</span></p>
			<p>The next diagram illustrates how both approaches work, where with reflection Java reads the <a id="_idIndexMarker183"/>annotations and any <a id="_idIndexMarker184"/>metadata in real time, generating more flexibility and pluggability on reading time; this demands more memory and warmup time. We can read this information at the build time, where we get a better warmup and save more memory at the start; however, we lose our flexibility with reflection. As usual, this is a point of <span class="No-Break">trade-off analysis:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure 5.2 ﻿– Reading Java annotations ﻿at runtime versus build time" src="image/Figure_5.02_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Reading Java annotations at runtime versus build time</p>
			<p>Reflection is a powerful mechanism in Java programming and frameworks. It enables dynamic code execution, metadata extraction, and the utilization of annotations for configuration and customization. While reflection can impact startup performance in specific scenarios, frameworks such as Quarkus and Micronaut have introduced build-time reflection as a solution, allowing developers to leverage the benefits of annotations without sacrificing performance. This approach, enabled by CDI Lite, promotes efficient usage of Java in serverless and <span class="No-Break">cloud-native environments.</span></p>
			<p class="callout-heading">Jakarta EE platform constant evolution – CDI Lite</p>
			<p class="callout">Based on the needs and impacts highlighted so far, the Jakarta EE platform released as version 10 has changes to the CDI specification that accommodate many behaviors helpful for this scenario. The CDI Lite specification brings behaviors needed by these frameworks and aims to provide a lightweight version of CDI. CDI Lite leverages <em class="italic">compile-time reflection</em> to eliminate the runtime overhead associated with full CDI implementations, making it suitable for resource-constrained environments and <span class="No-Break">serverless architectures.</span></p>
			<p>Developers can choose between frameworks that employ reflection or follow a reflectionless approach when developing Java applications. This comparison table will explore <a id="_idIndexMarker185"/>critical aspects such as <a id="_idIndexMarker186"/>annotation reading, warmup flexibility, and encapsulation in these two Java frameworks. Understanding the trade-offs and advantages of each approach can help developers make informed decisions based on their project requirements and <span class="No-Break">development preferences.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Reflection</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Reflectionless</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Read <span class="No-Break">Java annotations</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Real-time</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Build time</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Warmup (extra time required by the framework <span class="No-Break">on startup)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It has a <span class="No-Break">slow startup</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It has a <span class="No-Break">faster startup</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Flexibility</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Pluggability in <span class="No-Break">real time</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Limitation by <span class="No-Break">build time</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Encapsulation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Strong encapsulation</span></p>
						</td>
						<td class="No-Table-Style">
							<p>More limitations at the <span class="No-Break">Java encapsulation</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Reflection versus reflectionless solution</p>
			<p>When we talk about the application, we’re not sure about the architecture style, such as <a id="_idIndexMarker187"/>microservices or monolith, or whether <a id="_idIndexMarker188"/>we’ll use a real-time or build-time Java application; however, for the majority of the solutions, we’ll use any persistence engine. Let’s now discuss in more detail the most mature Jakarta persistence <span class="No-Break">specification: JPA<a id="_idTextAnchor104"/>.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor105"/>JPA state of affairs</h1>
			<p>JPA is a crucial Jakarta EE specification and the most mature data specification for enterprise applications. It provides a standardized and robust approach to ORM in Java, enabling developers to interact seamlessly with <span class="No-Break">relational databases.</span></p>
			<p>When working <a id="_idIndexMarker189"/>with the integration between Java applications and relational databases, several aspects need to be taken into consideration, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Configuration management</strong>: How the configurations are externalized in order to <a id="_idIndexMarker190"/>be easily yet securely changed based on the environment in which it is being deployed (dev, prod, and <span class="No-Break">so on).</span></li>
				<li><strong class="bold">Connection handling</strong>: Improper handling of connections with the database <a id="_idIndexMarker191"/>may lead to extra processing time, as it is expensive. This need is related to the requirement of managing open, close, and track connections with the database in order to use resources effectively and avoid having too many open and idle connections or not enough connections available to <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Mapping classes to database tables</strong>: As <a id="_idIndexMarker192"/>we saw in previous chapters, mapping objects may be implemented in multiple ways and provide a higher or lower level of flexibility <span class="No-Break">and abstraction.</span></li>
				<li><strong class="bold">Mapping the relation between classes</strong>: OOP brings concepts such as hierarchy, which <a id="_idIndexMarker193"/>is not available in a relational database schema. Depending on the way these classes are configured, data management can have higher complexity and <span class="No-Break">maintenance costs.</span></li>
				<li><strong class="bold">Transaction management</strong>: Managing <a id="_idIndexMarker194"/>transactions and assuring atomicity and rollbacks at the <span class="No-Break">application layer.</span></li>
				<li><strong class="bold">Code generation</strong>: Developers can either write pure SQL queries or rely on abstractions <a id="_idIndexMarker195"/>to speed up the development time. Currently, some frameworks can abstract most basic CRUD queries. Unfortunately, if misused, code generation may lead to slow queries and restrictions on the proper usage of <span class="No-Break">private methods.</span></li>
				<li><strong class="bold">Fetching strategies</strong>: Allows the retrieval of data in ways to take the best advantage <a id="_idIndexMarker196"/>of memory consumption, and when properly used, brings performance improvements as data will only be fetched from the database when needed. This is related to the well-known lazy/eager fetching modes available, for example, <span class="No-Break">on Hibernate.</span></li>
				<li><strong class="bold">Decoupling business logic from technical aspects</strong>: Based on their goals, a developer <a id="_idIndexMarker197"/>can create extremely flexible and customized code (for example, using JDBC) in exchange for negatively impacting code coupling between the data persistence layer and the business <span class="No-Break">logic layer.</span></li>
			</ul>
			<p>Considering these <a id="_idIndexMarker198"/>recurrent needs of Java developers and the possibility to create reproducible good practices that could be easily and largely adopted, the JPA specification has evolved since <span class="No-Break">its creation.</span></p>
			<p>The following diagram shows the ecosystem of JPA as the most mature persistence specification in the Jakarta EE world; several vendors and frameworks use it, and we can also apply several persistence patterns such as Active Record, Repository, <span class="No-Break">and Mapper:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer042">
					<img alt="Figure 5.3 ﻿– JPA timeline and landscape" src="image/Figure_5.03_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – JPA timeline and landscape</p>
			<p>When combined <a id="_idIndexMarker199"/>with frameworks such as Spring and Quarkus, JPA offers the flexibility to implement different design approaches, including Active Record, Mapper, and Repository patterns. Let’s delve into these design approaches and explore how JPA can operate by reading annotations using reflection or at <a id="_idTextAnchor106"/><span class="No-Break">build time.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor107"/>JPA and database mapping patterns</h2>
			<p>When working with JPA, developers mostly adopt three design options: Active Record, Mapper, and Repository. Notice that due to JPA capabilities such as mapping entities and <a id="_idIndexMarker200"/>their relationships to each other, abstractions for basic database operations, and exception-handling mechanisms, adopting the patterns becomes simpler. Let’s take a closer look <span class="No-Break">at this:</span></p>
			<ul>
				<li><strong class="bold">Active Record with JPA</strong>: In this <a id="_idIndexMarker201"/>approach, the domain model class encapsulates the persistence logic, following the Active Record pattern. It simplifies database operations as the domain classes are active participants and are responsible for handling CRUD operations and <span class="No-Break">relationships directly.</span></li>
			</ul>
			<p>When relying on JPA, it is possible to annotate a domain class with JPA annotations such as <strong class="source-inline">@Entity</strong> to mark it as a persistent entity. The domain class can <a id="_idIndexMarker202"/>also be annotated with <strong class="source-inline">@Table</strong>, which will define which is the corresponding database table that should be mapped to this entity. These annotations’ metadata enables JPA to map the object attributes to the respective <span class="No-Break">database columns.</span></p>
			<ul>
				<li><strong class="bold">Mapper</strong>: According to the Mapper pattern, the domain model and the persistence <a id="_idIndexMarker203"/>logic should be separated with the help of new and dedicated <span class="No-Break">mapper classes.</span></li>
			</ul>
			<p>JPA, in combination with frameworks such as Spring and Quarkus, allows developers to configure and manage these mappers. The mappers handle the conversion between the domain objects and the database tables, abstracting the persistence details from the domain model. JPA’s <strong class="source-inline">EntityManager</strong> and <strong class="source-inline">EntityManagerFactory</strong> classes provide the necessary APIs to perform database operations, while the mapper classes facilitate the mapping between the database and the <span class="No-Break">domain model.</span></p>
			<ul>
				<li><strong class="bold">Repositories</strong>: The Repository pattern suggests introducing a layer of abstraction <a id="_idIndexMarker204"/>between the application domain layers and the data <span class="No-Break">access layer.</span></li>
			</ul>
			<p>When developing with JPA, developers can define repository interfaces that act as contracts specifying the available CRUD operations and queries. JPA’s <strong class="source-inline">EntityManager</strong> class is the underlying mechanism for executing queries and managing transactions, enabling efficient and scalable <span class="No-Break">data access.</span></p>
			<p>Frameworks such as Spring Data JPA and Quarkus support repositories and can automatically generate the necessary implementation code based on the <span class="No-Break">defined interfaces.</span></p>
			<p>When considering the usage of frameworks to implement patterns, we should be aware of the pros and cons. We will delve into a detailed code example, but before that, let’s check the items to be <span class="No-Break">aware of.</span></p>
			<p>Based on the application use case and requirements, it would be recommended to know what happens under the covers and what limitations your application will inherit from the framework you are choosing. When using Active Record with Panache and Quarkus, for instance, your entity might be extending the <strong class="source-inline">PanacheEntity</strong> class. With Repository, it might be extending <strong class="source-inline">JpaRepository</strong>, a generic Spring Data JPA interface. By knowing the chosen framework implementation details, you can better identify where you are opting to tightly couple your application code with the framework, by using exclusive annotations or dependencies. You’d be <a id="_idIndexMarker205"/>aware whether and if so, to what extent there will be a violation of the principle of <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>), or for instance, the extra effort that will be needed in case of the need of migration to a different <span class="No-Break">persistence framework.</span></p>
			<p>The pros and cons we learned about in <span class="No-Break"><em class="italic">Chapter</em></span><span class="No-Break"> 4</span> apply here as well: Active Record will be less complex than Repository, whereas adopting Repository can result in better SoC <a id="_idIndexMarker206"/>than Active Record, resulting in enhanced maintainability <span class="No-Break">and testability.</span></p>
			<p>We’ll delve into a comprehensive code sample to clarify the trade-offs between choosing the convenience offered by frameworks versus adhering to well-known codi<a id="_idTextAnchor108"/>ng <span class="No-Break">best practices.</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor109"/>The power of JPA with Quarkus and Panache cloud-native runtimes</h1>
			<p>To demonstrate how modern persistence frameworks enable developers to rely on their knowledge <a id="_idIndexMarker207"/>of JPA, let’s take a look at Quarkus and Panache, and the <a id="_idIndexMarker208"/>experience of developing cloud-native Java services with accelerated development speed. Within this context, we’ll evaluate key aspects of design pattern implementation, automatically generated persistence code, and some potential drawbacks to take into consideration when designing <span class="No-Break">a solution.</span></p>
			<p>You can either follow along or create a brand-new project to try the following code. If you haven’t used Quarkus and Panache yet, you may notice quite a difference in the development experience of a lightweight runtime compared to traditional application servers, and the simplicity of coding straightforward CRUD scenarios <span class="No-Break">with Panache.</span></p>
			<p>Details on how to create the project can be found in the project’s repository: <a href="https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md">https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md</a>. Now, let’s dive <span class="No-Break">into it.</span></p>
			<p>The microservice <a id="_idIndexMarker209"/>we’re about to see will be used to manage <em class="italic">books</em> and <em class="italic">magazines</em>, and we’ll <a id="_idIndexMarker210"/>explore two different database design patterns using JPA: Reposit<a id="_idTextAnchor110"/>ory and <span class="No-Break">Active Record.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor111"/>Setting up the new service</h2>
			<p>As we will rely on features for persistence and REST endpoints (easily generated through the Quarkus starter page), the project needs dependencies to handle such capabilities. Interestingly, much of the hard work will be automatically generated by <a id="_idIndexMarker211"/>the frameworks, which in turn, are actually based on well-known specifications and technologies such as RESTEasy, JSON-B, Hibernate ORM, Hibernate Validator, Panache, <span class="No-Break">and JDBC.</span></p>
			<p>The underlying storage will be handled by H2, an in-memory data storage, which should be useful for learning purposes as it doesn’t require installation of external databases or usage of Docker to bootstrap one database instance. However, remember that H2 is not recommended for <span class="No-Break">production usage.</span></p>
			<p>The first difference shows up in the Quarkus project’s configuration (<strong class="source-inline">src/main/resources/application.properties</strong>), as developers can rely on a single properties configuration file to have <strong class="source-inline">h2</strong> as the database kind and <strong class="source-inline">memory</strong> as the JDBC URL. This approach enables changes to the underlying database technology without any code modification (for example, from H2 to PostgreSQL, MariaDB, <span class="No-Break">or others).</span></p>
			<p>Another positive aspect is that this configuration style relies on the Eclipse MicroProfile Configuration specification, which has out-of-the-box support for overwriting the application’s properties based on the environment in which the application is running—in other words, this is how sensible data (such as the username and password) within production environments can remain confidential and not be configured directly at the <span class="No-Break">application level.</span></p>
			<p>The property configuration could be set up <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
quarkus.datasource.db-kind=h2quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:mem:default
quarkus.datasource.jdbc.max-size=13
quarkus.hibernate-
  orm.dialect=org.hibernate.dialect.H2Dialect
quarkus.hibernate-orm.database.generation=create
quarkus.hib<a id="_idTextAnchor112"/>ernate-orm.log.sql=true</pre>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor113"/>Persistent entities and database operations</h2>
			<p>With the foundation ready to go, the project’s entities are created next. We’ll start by checking the <a id="_idIndexMarker212"/>two patterns from this moment forward, where you can observe the <strong class="source-inline">Book</strong> entity is implemented using Active Record, and <strong class="source-inline">Magazine</strong> using the <span class="No-Break">Repository pattern.</span></p>
			<p>The <strong class="source-inline">Book</strong> class is <a id="_idIndexMarker213"/>represented as follows. Note that even though it brings the <strong class="source-inline">@Entity</strong> annotation, there are no additional attribute-level annotations. Also, the <strong class="source-inline">Book</strong> entity “knows” its database operations, including, for instance, how to search for books by name and <span class="No-Break">book release:</span></p>
			<pre class="source-code">
@Entitypublic class Book extends PanacheEntity {
    public String name;
    public int release;
    public int edition;
    public static List&lt;Book&gt; findByName(String name) {
        return list("name", name);
    }
    public static List&lt;Book&gt; findByRelease(int year) {
        return list("release", year);
    }
}</pre>
			<p>As you’ll see next, the <strong class="source-inline">Magazine</strong> class uses classic JPA annotations such as <strong class="source-inline">@Entity</strong> and <strong class="source-inline">@id</strong> (so far, nothing new under the sun). The reason why the <strong class="source-inline">Book</strong> entity does <a id="_idIndexMarker214"/>not require an <strong class="source-inline">@id</strong> annotation is that it inherits <a id="_idIndexMarker215"/>such capability from the class it extends, <strong class="source-inline">PanacheEntity</strong>. <strong class="source-inline">PanacheEntity</strong> handles several operations, through heritage, including the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> attribute:</span></p>
			<pre class="source-code">
@Entitypublic class Magazine {
    @Id
    @GeneratedValue
    public Long id;
    public String name;
    public int release;
    public int edition;
}</pre>
			<p>Differently from the class being implemented with Active Record where the database operation will be at the entity itself, the <strong class="source-inline">Magazine</strong> class requires an additional class to do such data manipulation—a <strong class="source-inline">Repository</strong> class. The <strong class="source-inline">MagazineRepository</strong> class has to implement the essential database procedures, plus the queries (such as <strong class="source-inline">find by release and name</strong>, as available in the <strong class="source-inline">Book</strong> class). As we are using the <strong class="source-inline">PanacheRepository</strong> class, we can save some time on the basic operations as they will be automatically generated by Panache <span class="No-Break">later on.</span></p>
			<p>The <strong class="source-inline">MagazineRepository</strong> code is <span class="No-Break">presented here:</span></p>
			<pre class="source-code">
@ApplicationScopedpublic class MagazineRepository implements
  PanacheRepository&lt;Magazine&gt; {
    public List&lt;Magazine&gt; findByName(String name) {
        return list("name", name);
    }
    public List&lt;Magazine&gt; findByRelease(int year) {
        return lis<a id="_idTextAnchor114"/>t("release", year);
    }
}</pre>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor115"/>Exposing REST endpoints for data manipulation</h2>
			<p>Finally, to manipulate data through the classes we’ve checked so far, the application exposes REST APIs. The endpoints are <strong class="source-inline">BookResource</strong> and <strong class="source-inline">MagazineResource</strong>, which should <a id="_idIndexMarker216"/>expose the same database operations for <strong class="source-inline">Book</strong> and <strong class="source-inline">Magazine</strong> so that we can evaluate the differences in the usage of each approach. The first difference that can be mentioned is that, while we don’t need to inject anything in order to use the <strong class="source-inline">BookResource</strong> endpoint, to manipulate the <strong class="source-inline">Magazine</strong> entity, the developer must inject the respective <span class="No-Break"><strong class="source-inline">repository</strong></span><span class="No-Break"> class.</span></p>
			<p>First, observe how the <strong class="source-inline">BookResource</strong> endpoint allows interactions with <strong class="source-inline">Book</strong>, the entity implemented with Active Record. You’ll notice as a negative aspect the fact that there is a tighter coupling between the endpoint and the Active Record. As a positive point, notice how it allows the app to be simpler, with <span class="No-Break">fewer layers.</span></p>
			<p>The <strong class="source-inline">BookResource</strong> class includes <span class="No-Break">the following:</span></p>
			<ul>
				<li>Three <strong class="source-inline">GET</strong> endpoints: <strong class="source-inline">findAll</strong>, <strong class="source-inline">findByName</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">findByYear</strong></span></li>
				<li>One <strong class="source-inline">POST</strong> and one <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> method</span></li>
			</ul>
			<p>The code is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
@Path("/library")@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class BookResource {
    @GET
    public List&lt;Book&gt; findAll() {
        return Book.listAll();
    }
    @GET
    @Path("name/{name}")
    public List&lt;Book&gt; findByName(@PathParam("name") String
      name) {
        return Book.findByName(name);
    }
    @GET
    @Path("release/{year}")
    public List&lt;Book&gt; findByYear(@PathParam("year") int
      year) {
        return Book.findByRelease(year);
    }
    @POST
@Transactional
    public Book insert(Book book) {
        book.persist();
        return book;
    }
    @DELETE
    @Path("{id}")
    @Transactional
    public void delete(@PathParam("id") Long id) {
        Book.deleteById(id);
    }
}</pre>
			<p>In the preceding code, observe that the <strong class="source-inline">Book</strong> entity already offers the methods that execute operations against <span class="No-Break">the database.</span></p>
			<p>Now, let’s move on to the <strong class="source-inline">MagazineResource</strong> endpoint, which covers the Repository pattern. Observe that even though this is a simple example project, it will increase the <a id="_idIndexMarker217"/>complexity of the business requirements and time with the erosion of architecture in real life. It reminds us of <a href="B19375_04.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, where we covered more about the layers and their trade-offs, so the same layer that can help us, in isolation, break what into pieces might impact more complex code. As the application expands and incorporates additional layers such as the service layer, or as it adopts a hexagonal model, it becomes crucial to carefully analyze the trade-offs and pay close attention to the design of <span class="No-Break">persistence layers.</span></p>
			<p>Here is the implementation of the <span class="No-Break"><strong class="source-inline">MagazineResource</strong></span><span class="No-Break"> endpoint:</span></p>
			<pre class="source-code">
@Path("/magazines")@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class MagazineResource {
    @Inject
    MagazineRepository repository;
    @GET
    public List&lt;Magazine&gt; findAll() {
        return repository.listAll();
    }
    @GET
    @Path("name/{name}")
    public List&lt;Magazine&gt; findByName(@PathParam("name")
      String name) {
        return repository.findByName(name);
    }
    @GET
    @Path("release/{year}")
    public List&lt;Magazine&gt; findByYear(@PathParam("year") int
      year) {
        return repository.findByRelease(year);
    }
    @POST
    @Transactional
    public Magazine insert(Magazine magazine) {
        this.repository.persist(magazine);
        return magazine;
    }
    @DELETE
    @Path("{id}")
    @Transactional
    public void delete(@PathParam("id") Long id) {
        repository.deleteById(id);
    }
}</pre>
			<p>Key points <a id="_idIndexMarker218"/>to observe in the preceding class are set <span class="No-Break">out here:</span></p>
			<ul>
				<li>The developer is required to inject an instance of the <span class="No-Break"><strong class="source-inline">MagazineRepository</strong></span><span class="No-Break"> endpoint</span></li>
				<li>The developer must implement the class and the methods that are needed, obtaining a greater level of control and customization of the underlying implementation, plus code with better SoC between the domain entity and the <span class="No-Break">database integration</span></li>
			</ul>
			<p>At this point, the application is ready, and all operations are ready to be accessed via REST and by correctly manipulating data through the methods defined by the developer and provid<a id="_idTextAnchor116"/>ed out of the box <span class="No-Break">by Panache.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor117"/>Even faster development speed – automatic endpoint generation</h2>
			<p>Panache allows <a id="_idIndexMarker219"/>even more development speed for standard scenarios, combining the benefits of Active Record we’ve seen with the automatic generation of REST endpoints. The following capabilities are offered by the <strong class="source-inline">quarkus-hibernate-orm-rest-data-panache</strong> Quarkus extension, instead of the previously used <span class="No-Break"><strong class="source-inline">quarkus-hibernate-orm-panache</strong></span><span class="No-Break"> extension.</span></p>
			<p>The speed at which a developer can deliver a completely usable CRUD service is extremely noticeable when compared to the previous approach, and even more so if compared to traditional EE application servers. With the following steps, a developer should be able to create a whole CRUD for <em class="italic">newsletters</em> in just a <span class="No-Break">few minutes.</span></p>
			<p>Taking into consideration the existing project, a new <strong class="source-inline">Newsletter</strong> class could be created <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@Entitypublic class Newsletter extends PanacheEntity {
   public String author;
   public String headline;
}</pre>
			<p>It relies on <a id="_idIndexMarker220"/>the Active Record implementation as well. On top of that, it combines Quarkus and Panache capabilities for automatically generating REST endpoints based on <span class="No-Break">Panache entities.</span></p>
			<p>To achieve the same results as the examples covered before, the following REST operations should <span class="No-Break">be available:</span></p>
			<ul>
				<li>Three <strong class="source-inline">GET</strong> resources: <strong class="source-inline">findAll</strong>, <strong class="source-inline">findById</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">getCount</strong></span></li>
				<li><strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>, to enable inserting, updating, and deleting <span class="No-Break">newsletters, respectively</span></li>
			</ul>
			<p>To achieve this objective, all that is needed is a new interface that extends the <strong class="source-inline">PanacheEntityResource</strong> interface. The interface indicates the Panache entity that is the <strong class="source-inline">id</strong> <span class="No-Break">attribute type:</span></p>
			<pre class="source-code">
import io.quarkus.hibernate.orm.rest.data.panache.PanacheEntityResource;public interface NewsletterResource extends PanacheEntityResource&lt;Newsletter, Long&gt; {
}</pre>
			<p>And that’s all! If running Quarkus using dev mode, the developer should already be able to validate the results simply by refreshing the page and checking the <strong class="source-inline">swagger-ui</strong> page and the new endpoints, as <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 5.4 ﻿– New endpoints automatically generated by Panache" src="image/Figure_5.04_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – New endpoints automatically generated by Panache</p>
			<p>Now, be aware that when choosing to go down this route, all the attributes are configured as public attributes. And here’s your trade-off when using such an approach: unless you add extra code to be able to handle the usage of private attributes, you will opt for development speed in exchange for completely giving up on <a id="_idIndexMarker221"/>encapsulation, no access control, increased code coupling (as changes to the class may result in potential changes to other classes), and limited control and data integrity (the attribute can be <span class="No-Break">directly modified).</span></p>
			<p>You may think it is as simple as configuring the attributes as private and adding public getters and setters. True—this is mostly the same. But you would lack encapsulation in the very same way (as the setter is still public) with “dumb” getters and setters. Plus, that is exactly what Panache (in the current version at the time of writing) does under the covers: it generates <strong class="source-inline">getter</strong> and <strong class="source-inline">setter</strong> attributes and rewrites every usage of these attributes to the respective <strong class="source-inline">getter</strong> and <span class="No-Break"><strong class="source-inline">setter</strong></span><span class="No-Break"> attribute.</span></p>
			<p>Panache is very powerful and allows developers to also be more efficient when writing queries, where it would be possible—for example—to use code such as <strong class="source-inline">Newsletter.find("order by author")</strong>, or <strong class="source-inline">Newletter.find("author = ?1 and headline = ?2", "karina", "Java lives!")</strong>, or, even better, <span class="No-Break"><strong class="source-inline">Newsletter.find("author", "karina")</strong></span><span class="No-Break">.</span></p>
			<p>You have seen the amazing experience Java developers can get from modern runtime technologies and how effective it can be to create from scratch a completely new stateful <a id="_idIndexMarker222"/>service while relying on existing knowledge of JPA. Next, we’ll slightly shift to another topic, highlighting considerations on concerns commonly faced by most developers and architects who have ever worked with J<a id="_idTextAnchor118"/>PA: performance <span class="No-Break">and scalability.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor119"/>General JPA-related performance considerations</h1>
			<p>The following considerations apply not only to Panache but also to JPA-based applications <a id="_idIndexMarker223"/>in general. To help identify or go through the performance tuning process, you can always rely on the framework capabilities of outputting the DDLs being executed (database SQL operations) and the database operations statistics. Hibernate, for example, offers several configuration parameters such as <strong class="source-inline">show_sql</strong>, <strong class="source-inline">generate_statistics</strong>, <strong class="source-inline">jdbc.batch_size</strong>, <strong class="source-inline">default_batch_fetch_size</strong>, and <strong class="source-inline">cache.use_query_cache</strong>. In the following paragraphs, you’ll find considerations revolving around such configurations. For now, check here how some configuration could be applied to the sample Quarkus application example we just created. These properties allow the logging of DDLs <span class="No-Break">and statistics:</span></p>
			<pre class="source-code">
quarkus.hibernate-orm.log.sql=truequarkus.hibernate-orm.statistics=true
quarkus.hibernate-orm.metrics.enabled=true
quarkus.log.level=DEBUG</pre>
			<p>Note that verbose logging configuration should not be used in production as it directly impacts application performance; plus, the application log categories can be configured individually to output only what you need. As an example, the preceding statistics configuration can help you identify slow execution DDLs. See one example of information you can obtain for each <span class="No-Break">database operation:</span></p>
			<p><strong class="source-inline">2023-06-19 02:10:25,402 DEBUG [org.hib.sta.int.StatisticsImpl] (executor-thread-1) HHH000117: HQL: SELECT COUNT(*) FROM dev.a4j.mastering.data.Newsletter, time: 1ms, </strong><span class="No-Break"><strong class="source-inline">rows: 1</strong></span></p>
			<p>If you are worried about performance, certify your code (either due to mapping or query parsing) is not <em class="italic">automatically generating slow-performing SQL queries</em> under the covers, <em class="italic">fetching unnecessary information</em> when not needed, or <em class="italic">automatically generating too many queries</em> instead of running a better-suited <span class="No-Break">single one.</span></p>
			<p>Other than the persistence-related Java code itself, it is also possible to fine-tune your JPA data source connection by setting the number of connections to be opened by the application during startup, the connection pool size (so that open connections can be reused), and how you want the application (via your framework and class of choice) to identify and clean idle or <span class="No-Break">unclosed connections.</span></p>
			<p>Another <a id="_idIndexMarker224"/>item to consider is batch operations. Let’s say each newsletter can contain several articles, and an author can create a new newsletter along with 50 articles, all at once. In this case, instead of going back and forth between the application and the database 51 times to create all articles and the newsletter, it would be possible to do it only once to execute all operations. The same applies to <span class="No-Break">querying data.</span></p>
			<p>For applications with an intensive number of queries, focus on creating specific SQL queries that can perform better, and if the app requires several query executions, it is recommended to fine-tune the batch-and-fetch size on the application configuration. JDBC batch operations are a good approach to defining how many operations can be executed in a single <span class="No-Break">database roundtrip.</span></p>
			<p>For applications with an intensive number of inserts, it is also possible to use bulk inserts, making sure to avoid long-running transactions or spending extra time each time the “flush” operation occurs (as <strong class="source-inline">EntityManager</strong> will have to handle the insert of a large set of objects at once). As applied to most fine-tuning configurations, the best way to evaluate which would be the best configuration to set on each application is to execute load tests and compare results. Still ,in the context of querying data, remember that caching frequently used queries helps reduce the number of database hits and <span class="No-Break">improves performance.</span></p>
			<p>In regard to caching in the JPA context, there are two types of cache: first- and second-level cache. The first-level cache relates to the objects contained within the <strong class="source-inline">EntityManager</strong> cache (session cache). It allows the app to save time when accessing objects that were recently accessed or manipulated within <span class="No-Break">a session.</span></p>
			<p>When working with distributed applications scaled up to many running instances, it may be beneficial to consider a second-level cache that allows the usage of a shared cache. Remember that caching features are not recommended for 100% of scenarios, because even though it may lead to significantly better performance, it will demand a good understanding of how to fine-tune the <span class="No-Break">caching solution.</span></p>
			<p>Finally, fine-tuning a cache solution means providing proper cache invalidation (to make sure the cache data is aligned with the underlying database’s current data), proper cache synchronization (as there may be multiple cache provider instances), eviction policies, and more. In scenarios where there is real-time or up-to-date data, take into consideration the challenges of cache usage and the introduced possibility of <span class="No-Break">data staleness.</span></p>
			<p>This brings <a id="_idIndexMarker225"/>us to the end of our Quarkus and JPA journey, where we have seen both Active Record and Repository patterns with JPA. We can see how easy Active Record can be, but at the same time, my entity knows and executes database operations. Thus, it has two responsibilities. This is fine when we talk about a redirect or any integral functions that do not require a <a id="_idTextAnchor120"/>huge demand of <span class="No-Break">business complexity.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor121"/>Summary</h1>
			<p>In conclusion, Jakarta EE is a robust platform that provides a comprehensive set of specifications, APIs, and tools for developing enterprise applications. Within the persistence layer, Jakarta EE shines with its mature JPA specification, which offers a standardized approach to ORM. With JPA, developers can leverage design patterns such as Active Record and Repository to simplify and streamline their data <span class="No-Break">access operations.</span></p>
			<p>When combined with the Quarkus framework, JPA in Jakarta EE demonstrates its capabilities in practice. Quarkus, known for its fast startup time and efficient resource utilization, enhances the development experience by seamlessly integrating with JPA. Developers can leverage the Active Record pattern, allowing their domain model classes to handle persistence operations directly. Alternatively, they can adopt the Repository pattern, which introduces an abstraction layer for flexible and scalable data access. By leveraging JPA within Quarkus, developers can efficiently interact with relational databases, ensure data integrity, and achieve optimal performance in their Jakarta <span class="No-Break">EE applications.</span></p>
			<p>Overall, with its mature JPA specification, Jakarta EE, in conjunction with the Quarkus framework, empowers developers to build robust and efficient persistence layers. The combination of Jakarta EE’s standardized approach to persistence and Quarkus’ streamlined development experience opens up a world of possibilities for creating scalable and high-performing enterprise applications. But how about NoSQL? Does Jakarta EE have support for it? Yes, it does; the following chapter will cover how to handle several NoSQL database types such as key-value, document, and graph <span class="No-Break">with Java.</span></p>
		</div>
	</body></html>