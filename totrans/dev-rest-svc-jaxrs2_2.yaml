- en: Chapter 2. WebSockets and Server-sent Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：WebSocket 和服务器发送事件
- en: With the advancements in web architecture and emerging platforms, which can
    provide real-time or near real-time information, the necessity of having an effective
    way of communicating these updates to clients caused the urge of introducing new
    programming models and new standards that make use of this real-time information
    easier for the consumer side of the system, also known as clients (mostly web
    browsers).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络架构的进步和新兴平台的涌现，这些平台可以提供实时或近实时信息，因此有必要有一种有效的方法将更新传达给客户端，这促使引入新的编程模型和新标准，使系统消费者端（也称为客户端，主要是网络浏览器）更容易利用这些实时信息。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: The programming models and solutions that can be used to address near real-time
    update transfer to clients
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于解决向客户端传输近实时更新的编程模型和解决方案
- en: Using Server-sent Events (SSE)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器发送事件（SSE）
- en: Using WebSockets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WebSocket
- en: Different snippets are included in this chapter but complete samples which shows
    these snippet in actions are included as part of the book's source code download
    bundle.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含不同的代码片段，但完整的示例，展示了这些片段在实际操作中的使用，作为本书源代码下载包的一部分。
- en: The programming models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程模型
- en: In this section we will cover the different programming models that emerged
    to address the near real-time updating of the client view based on the updates
    that are produced by the server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍针对基于服务器生成的更新来处理客户端视图近实时更新的不同编程模型。
- en: Polling
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询
- en: As mentioned before, HTTP, which is the foundation of communication over the
    Internet, uses a simple request/response model in which a request either timeouts
    or get a response back from the server. The response can be the actual response
    the request was intended for or it can be an error message, underneath one of
    the standard error status codes. The client always initiates the communication;
    the server cannot initiate a communication channel without receiving a request
    from a client to send back a response.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，HTTP，作为互联网通信的基础，使用简单的请求/响应模型，其中请求要么超时，要么从服务器收到响应。响应可以是请求所期望的实际响应，也可以是错误消息，位于标准错误状态代码之下。客户端始终是通信的发起者；服务器不能在没有收到客户端请求发送响应的情况下发起通信通道。
- en: So, basically, to update the client it is required to check for the new updates
    on the server and if an update is available the client can react to the update
    and, for example, change a text to denote that a book that was not available is
    available for borrowing now or a show a new image, or to perform any other action
    that maps to the response received from the server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，要更新客户端，就需要检查服务器上的新更新，如果可用，客户端可以响应更新，例如，更改文本以表示之前不可用的书籍现在可以借阅，或者显示新的图像，或者执行任何其他与从服务器收到的响应相对应的操作。
- en: 'Sending periodical requests to a server to check for updates is called **polling**.
    It does not scale to hundreds of thousands of clients and thus it cannot be an
    effective programming model to handle the massive client numbers of today''s applications.
    In the polling model the response does not necessarily includes updates generated
    in the server but rather it may just be a `200 OK` response without any particular
    updates for the client to use. In this model, tens of requests may receive nothing
    but `200 OK` without any meaningful update for the client, which means these tens
    wasted the resources in vain. Of course, this model is useful if the number of
    clients is limited and if severe compatibility issues exist that prevent the clients
    to update to newer versions, for example, very old browsers. The following diagram
    shows the polling model:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 向服务器发送周期性请求以检查更新被称为**轮询**。这种方法无法扩展到数十万个客户端，因此它不能成为处理当今应用程序大量客户端的有效编程模型。在轮询模型中，响应不一定包括服务器生成的更新，而可能只是没有特定更新的`200
    OK`响应。在这个模型中，数十个请求可能什么也收不到，只是收到`200 OK`，没有任何有意义的更新供客户端使用，这意味着这些请求白白浪费了资源。当然，如果客户端数量有限，并且存在严重的兼容性问题，例如非常旧的浏览器，那么这种模型是有用的。以下图表显示了轮询模型：
- en: '![Polling](img/8125ENT_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![轮询](img/8125ENT_02_01.jpg)'
- en: 'The polling-based model is enriched with JavaScript in the client side; the
    browsers, to update the view without changing the page and thus list available
    books in a library application, can change without the user refreshing the page.
    The following code snippet shows the server side of a polling pair written in
    Java:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于轮询的模型在客户端通过JavaScript得到增强；浏览器可以在不改变页面内容的情况下更新视图，从而在图书馆应用程序中列出可用的书籍，而无需用户刷新页面。以下代码片段展示了用Java编写的轮询对的服务器端：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding sample does not use JSON for data format or any of the new Async
    functionalities introduced in Java EE 7 and Servlet 3.1 which are discussed in
    [Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent Events
    in Detail"), *Understanding WebSockets and Server-sent Events in Detail* and [Chapter
    4](ch04.html "Chapter 4. JSON and Asynchronous Processing"), *JSON and Asynchronous
    Processing*, but rather shows how the basics work. The Servlet writes the current
    date on the response for any `GET` request. The servlet is mapped to `PollingServlet`
    path in the `web.xml` file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例没有使用JSON作为数据格式，也没有使用Java EE 7和Servlet 3.1中引入的新异步功能，这些功能在[第3章](ch03.html
    "第3章。详细理解WebSocket和服务器端事件")、*详细理解WebSocket和服务器端事件*和[第4章](ch04.html "第4章。JSON和异步处理")、*JSON和异步处理*中进行了讨论，而是展示了基本的工作原理。Servlet为任何`GET`请求写入当前日期。servlet在`web.xml`文件中映射到`PollingServlet`路径。
- en: The following code snippet shows how we can use JavaScript to perform a request
    in the background, get the response, and update content of a `div` element of
    the HTML page by manipulating the equivalent DOM tree element.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何使用JavaScript在后台执行请求，获取响应，并通过操作等效的DOM树元素来更新HTML页面中`div`元素的内容。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The HTML page in the preceding snippet is the simplest possible form; it does
    not check whether the response for each request is `OK` neither does it check
    whether the code is being executed in IE or a non-IE browser for the sake of simplicity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的HTML页面是最简单的形式；它既不检查每个请求的响应是否为`OK`，也不检查代码是否在IE或非IE浏览器中执行，以简化处理。
- en: Now, the `startUpdating` function is invoked when the page is loaded, the function
    sends a request to the Servlet shown before and invokes the `updateDiv` function
    to update the GUI and then schedule another invocation of it after 5 seconds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当页面加载时，会调用`startUpdating`函数，该函数向之前显示的Servlet发送请求，并调用`updateDiv`函数来更新GUI，然后在5秒后再次调度它的调用。
- en: 'The limitations of the polling model can be summarized as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询模型的局限性可以总结如下：
- en: It is the client that performs polling and there is no service pushing involved
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是客户端执行轮询，没有服务推送的参与
- en: It is resource-consuming as many requests will result in a response that does
    not have any effective update for the client
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于许多请求会导致没有对客户端有效的更新的响应，因此它消耗资源较多。
- en: Long intervals between requests may yield an outdated client view while short
    intervals overload the servers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求之间的长时间间隔可能会导致客户端视图过时，而短时间间隔会超载服务器
- en: Long polling
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长轮询
- en: With the limitation of the polling model in mind, a new programming model emerged
    in which a request either timeouts or carries back useful updates to the client.
    In this model a request is sent to the server and the request is set to a timeout
    after a very long time so that the cost of handshake and request initiation reduces
    as much as possible by a reduction in the number of requests and responses in
    a fixed period of time. A response is only sent back if there are some updates
    in the server, which the client should receive. When such an update becomes available
    in the server, the server sends back the response with the update and client initiates
    another request after consuming the update it received. The benefit of this model
    is fewer numbers of requests compared to polling, which reduces the resource consumption
    and increases the scalability. The following diagram shows the **long polling**
    model.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到轮询模型的局限性，出现了一种新的编程模型，其中请求要么超时，要么将有用的更新返回给客户端。在这个模型中，请求被发送到服务器，并在非常长的时间后设置超时，这样通过减少固定时间段内的请求数量和响应数量，尽可能减少握手和请求发起的成本。只有当服务器有更新时，才会发送响应，客户端应该接收这些更新。当这种更新在服务器上可用时，服务器会发送带有更新的响应，客户端在消耗了接收到的更新后，会发起另一个请求。这种模型的优点是请求数量比轮询少，这减少了资源消耗并提高了可扩展性。以下图表展示了**长轮询**模型。
- en: '![Long polling](img/8125ENT_02_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![长轮询](img/8125ENT_02_02.jpg)'
- en: Long polling clients and XMLHttpRequest
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长轮询客户端和 XMLHttpRequest
- en: The `XMLHttpRequest` object is available as part of the JavaScript in-browser
    API to facilitate the interaction of the JavaScript part of a web page with the
    web server. It can be used to send a request to the server and receive the response
    without refreshing the page after the page is loaded; for example, to update the
    list of available books after the `available.html` page is loaded.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 对象作为 JavaScript 浏览器 API 的一部分可用，以促进网页的 JavaScript 部分与 Web 服务器的交互。它可以用来向服务器发送请求并接收响应，而无需在页面加载后刷新页面；例如，在
    `available.html` 页面加载后更新可用的书籍列表。'
- en: The functionality of the `XMLHttpRequest` object is categorized in events, methods,
    and properties. The important properties, events, and important methods are discussed
    shortly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 对象的功能分为事件、方法和属性。以下将简要讨论重要的属性、事件和重要方法。'
- en: The values of properties change when an event is fired and when methods are
    invocated. Checking the property values makes it possible to evaluate the current
    state of the `XMLHttpRequest` object or to handle the response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被触发或方法被调用时，属性的值会发生变化。检查属性值可以评估 `XMLHttpRequest` 对象的当前状态或处理响应。
- en: '`readyState`: Stores the current state of the ongoing request. The table after
    the list shows different values of the `readyState` attribute.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyState`: 存储正在进行中的请求的当前状态。列表之后的表格显示了 `readyState` 属性的不同值。'
- en: '`responseText`: Returns the response text.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseText`: 返回响应文本。'
- en: '`responseXML`: Returns a DOM object representing the response data. The assumption
    is that the response text is a valid XML document. The XML document can be traversed
    using standard DOM parser methods.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseXML`: 返回一个表示响应数据的 DOM 对象。假设响应文本是有效的 XML 文档。可以使用标准的 DOM 解析器方法遍历 XML
    文档。'
- en: '`status`: Shows the status code of the request; for example, `200`, `404`,
    and so on.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 显示请求的状态码；例如，`200`，`404` 等。'
- en: '`statusText`: Human readable text equivalent of request status code. For example
    `"OK"`, `"Not Found"`, and so on.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusText`: 请求状态码的易读文本等效。例如 `"OK"`，`"Not Found"` 等。'
- en: '| The readyState value and textual equivalent | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `readyState` 值和文本等效 | 描述 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` (`UNINITIALIZED`) | The `XMLHttpRequest` object is created, but not opened.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `0` (`UNINITIALIZED`) | `XMLHttpRequest` 对象已创建，但尚未打开。|'
- en: '| `1` (`LOADING`) | The `XMLHttpRequest` object is created, the open method
    is called but no request is sent. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `1` (`LOADING`) | `XMLHttpRequest` 对象已创建，已调用 open 方法，但尚未发送请求。|'
- en: '| `2` (`LOADED`) | The send method is called, no response yet. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `2` (`LOADED`) | 调用了发送方法，但尚未收到响应。|'
- en: '| `3` (`INTERACTIVE`) | The send method is called, some data was received but
    the response is not concluded yet. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `3` (`INTERACTIVE`) | 调用了发送方法，已收到一些数据，但响应尚未结束。|'
- en: '| `4` (`COMPLETED`) | Response is concluded and the entire message is received.
    Message content is available in the `responseBody` and `responseText` properties.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `4` (`COMPLETED`) | 响应已结束，已接收到整个消息。消息内容可在 `responseBody` 和 `responseText`
    属性中找到。|'
- en: Each event can have an associated method, which is invoked when the event is
    fired. The sample code afterward shows how these events can be used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都可以关联一个方法，当事件被触发时，该方法会被调用。随后的示例代码展示了如何使用这些事件。
- en: '`onreadystatechange`: This event is fired when the state of a request initiated
    by this `XMLHttpRequest` instance is changed. The state change is communicated
    via the `readyState` property.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onreadystatechange`: 当由该 `XMLHttpRequest` 实例发起的请求状态改变时，会触发此事件。状态改变通过 `readyState`
    属性进行通信。'
- en: '`ontimeout`: This event is fired when a request initiated with this `XMLHttpRequest`
    instance is timed out.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ontimeout`: 当使用该 `XMLHttpRequest` 实例发起的请求超时时，会触发此事件。'
- en: After invocation of each method the value of the relevant properties will change.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用每个方法后，相关属性的值将发生变化。
- en: '`abort`: This aborts the current request of the `XMLHttpRequest` instance.
    The `readyState` value is set to `0`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort`: 取消 `XMLHttpRequest` 实例的当前请求。`readyState` 值设置为 `0`。'
- en: '`open`: This prepares a request by setting the method, URL and security credentials.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`: 通过设置方法、URL 和安全凭据来准备请求。'
- en: '`send`: This sends the request that is prepared by the `open` method.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`: 通过 `open` 方法发送准备好的请求。'
- en: Chunked transfer encoding
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分块传输编码
- en: Another possible way of using the long polling model is to use the message body
    streaming to send chunks of data and update events, when those chunks are available
    in the server and ready to be consumed by the developer. In the message body streaming
    model the server does not close the response but rather keeps it open and sends
    the update events to client as they are produced in the server. The message body
    streaming involves using the chunked transfer encoding which is a `HTTP/1.1` feature.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用长轮询模型的另一种可能方式是使用消息体流来发送数据块和更新事件，当这些块在服务器上可用并准备好由开发者消费时。在消息体流模型中，服务器不会关闭响应，而是保持其打开状态，并将更新事件发送给客户端，就像它们在服务器中产生时一样。消息体流涉及使用分块传输编码，这是一个
    `HTTP/1.1` 功能。
- en: The chunked transfer encoding can be used to send many chunks of data as part
    of the response body, which is opened as a stream. The chunks can be JavaScript
    tags which are loaded in the hidden `iframe` and executed in the order of arrival.
    The execution of arriving scripts can cause the view to update or to trigger any
    other action that is required. The following diagram shows the long polling in
    action.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 分块传输编码可以用来发送多个数据块作为响应体的一部分，这些数据块以流的形式打开。这些块可以是 JavaScript 标签，它们在隐藏的 `iframe`
    中加载并按到达顺序执行。到达的脚本的执行可以导致视图更新或触发任何其他所需操作。以下图显示了长轮询的实际操作。
- en: '![Chunked transfer encoding](img/8125ENT_02_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![分块传输编码](img/8125ENT_02_03.jpg)'
- en: In the preceding diagram the client sent a request along with the `client_id`
    value to the server and the server started sending chunks of responses when some
    updates are available to be sent to the client. The updates are sent as JavaScript
    tags which are then executed in the client's browser to update the GUI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，客户端发送了一个包含 `client_id` 值的请求到服务器，当有更新可供发送给客户端时，服务器开始发送响应块。这些更新以 JavaScript
    标签的形式发送，然后在客户端的浏览器中执行以更新 GUI。
- en: 'The limitations of the long polling model can be summarized as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 长轮询模型的局限性可以概括如下：
- en: One-way communication
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向通信
- en: No standard data format or message format when used in chunked transfer encoding
    mode
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分块传输编码模式下使用时没有标准的数据格式或消息格式
- en: One response per request when no `iframe` technique is used
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不使用 `iframe` 技术时，每个请求只有一个响应
- en: Each connection initiation has an initiation cost
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接的初始化都有一个初始化成本
- en: No caching between the clients and server, which impacts server performance
    instead of reading content from the cache
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器之间没有缓存，这影响了服务器性能而不是从缓存中读取内容
- en: Emerging standards
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新兴标准
- en: With the emergence of requirements and solutions for those requirements, standards
    emerged to ensure compatibility between different the layers, applications, and
    components that form a solution; asynchronous communication, and especially event
    propagation between clients and servers, is one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对那些需求及其解决方案的出现，标准出现了以确保不同层、应用程序和组件之间的兼容性；异步通信，尤其是客户端和服务器之间的事件传播，就是其中之一。
- en: Server-sent Events
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器发送事件
- en: '**Server-sent Events** (**SSE**), or sometimes simply referred to as **EventSource**
    , is an HTML5 browser API that makes event pushing between server and client available
    to web application developers. The SSE component provides a structured mechanism
    for having a capability similar to long polling without some of the long polling
    drawbacks. As it is an HTML5 component, the browser should support HTML5 SSE to
    be able to take advantage of this API.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器发送事件** (**SSE**)，有时简称为 **EventSource**，是一个 HTML5 浏览器 API，它使服务器和客户端之间的事件推送对
    Web 应用程序开发者可用。SSE 组件提供了一个结构化的机制，具有类似于长轮询的功能，但没有长轮询的一些缺点。由于它是一个 HTML5 组件，浏览器应该支持
    HTML5 SSE 才能利用此 API。'
- en: The SSE kernel includes `EventSource` and `Event`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 内核包括 `EventSource` 和 `Event`。
- en: '`EventSource` is the API that provides the client with the means of subscribing
    to an event source, which can be a Servlet or anything of that sort. After subscription,
    which is nothing more than opening the connection to the URL, events are sent
    to the client in the order that they are produced and in the client the event
    listener can react to the events, for example by updating a chat window, changing
    a graph, or updating the list of available books to borrow or list people that
    are interested in the subject that the event URL is meant for.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`是提供客户端订阅事件源的API，这可能是一个Servlet或类似的东西。订阅后，这仅仅是打开到URL的连接，事件以它们产生的顺序发送到客户端，在客户端，事件监听器可以响应这些事件，例如通过更新聊天窗口、更改图表或更新可借阅的书籍列表或列出对事件URL所针对的主题感兴趣的人。'
- en: The SSE anatomy
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSE的解剖结构
- en: 'Before we go deep into the API and see how the API works, it is good to look
    more closely at the characteristics of SSE and how SSE works. The following diagram
    shows SSE in action, which closely resembles the chunked encoding diagram shown
    in the preceding section. The question may a rise: what makes SSE better than
    long polling if both of them work similarly when it comes to request, response,
    and message content?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入API并了解API的工作原理之前，仔细研究SSE的特点以及SSE是如何工作的，这是很好的。以下图表显示了SSE的实际应用，这与前一部分中显示的块编码图表非常相似。可能会有人问：如果两者在请求、响应和消息内容方面工作方式相似，那么是什么使得SSE比长轮询更好？
- en: '![The SSE anatomy](img/8125ENT_02_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![SSE的解剖结构](img/8125ENT_02_04.jpg)'
- en: With SSE the events are plain text messages sent from the server to the clients
    after the client opens the initial request meaning that it does not require to
    be a collection of JavaScript tags that need to be executed in the client side
    to update something but rather it can be data that can be consumed in the client
    side by the event listener and event listener can interpret and react to the received
    event.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSE，事件是服务器发送到客户端的纯文本消息，这意味着它不需要是一个需要在客户端执行的JavaScript标签集合，以更新某些内容，而更可以是客户端的事件监听器可以消费的数据，事件监听器可以解释并响应接收到的事件。
- en: 'The second difference is the message format; SSE defines a message format for
    the events that are sent from the server to the clients. The message format is
    composed of a plain text line-separated stream of characters. Lines that carry
    the message body or data start with `data:` and lines that carry some **Quality
    of Service** (**QoS**) directives start with the QoS attribute name followed by
    a colon and then the QoS attribute''s value, `directive: value`. The standard
    format makes it possible to develop generic libraries around SSE to make software
    development easier. The following snippet shows a sample message that can indicate
    a new dot in a graph. When the client receives the message it can draw the new
    dot on the graph to show a change in the data the graph is being constructed from.
    The following sample data shows a multiline message in which each line is separated
    from the next using `\n` and end of message is marked with `\n\n`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个区别是消息格式；SSE定义了从服务器发送到客户端的事件的消息格式。消息格式由一个由换行符分隔的纯文本字符流组成。以`data:`开头的行携带消息体或数据，而以QoS属性名称后跟冒号然后是QoS属性值`directive:
    value`开头的行携带一些**服务质量**（**QoS**）指令。标准格式使得围绕SSE开发通用库成为可能，从而简化软件开发。以下代码片段显示了一个可以指示图中新点的示例消息。当客户端收到消息时，它可以在图上绘制新点以显示从图中构建的数据的变化。以下示例数据显示了一个多行消息，其中每行使用`\n`与下一行分隔，消息的结束用`\n\n`标记。'
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is possible to develop the server component of a SSE solution using a servlet
    and the client side can be developed using either JavaScript or Java API. The
    Java API to consume SSE events is part of the Java EE 7 provided by means of JAX-RS
    2.0\. The next two sections go into details of the client side API and also the
    server side component of the solution, which is a servlet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用servlet开发SSE解决方案的服务器组件，而客户端可以使用JavaScript或Java API进行开发。用于消费SSE事件的Java API是Java
    EE 7的一部分，通过JAX-RS 2.0提供。接下来的两个部分将详细介绍客户端API以及解决方案的服务器端组件，后者是一个servlet。
- en: As mentioned earlier, in addition to the actual message or message body each
    SSE message can carry some directive, which instructs the browser or SSE-compatible
    client on some of the QoS attributes of the interaction. Some of these QoS directives
    are discussed next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除了实际的消息或消息体之外，每个SSE消息还可以携带一些指令，这些指令指示浏览器或SSE兼容客户端在交互的一些QoS（服务质量）属性。以下将讨论一些这些QoS指令。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reference implementation of JAX-RS 2.0 is done under the Jersey 2.0 project.
    The Jersey project is located at [http://jersey.java.net/](http://jersey.java.net/
    ) with extensive documentation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.0的参考实现是在Jersey 2.0项目中完成的。Jersey项目位于[http://jersey.java.net/](http://jersey.java.net/)，拥有详尽的文档。
- en: Associating an ID with an event
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ID与事件关联
- en: Each SSE message can have a message identifier, which can be used for a variety
    of purposes; one use of the message ID standard usage is to keep track of the
    messages that the client has received. When a message ID is used in SSE, the client
    can supply the last message ID as one of the connection parameters to instruct
    the server to resume form and specific message onward. Of course the server should
    implement proper the procedure for resuming a communication from where a client
    requests it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SSE消息都可以有一个消息标识符，它可以用于各种目的；消息ID标准用法之一是跟踪客户端已接收的消息。当在SSE中使用消息ID时，客户端可以将最后一条消息ID作为连接参数之一，指示服务器从该消息开始继续。当然，服务器应该实现适当的程序来从客户端请求的位置恢复通信。
- en: 'An example message format with message ID can be as shown in the following
    code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 带有消息ID的示例消息格式如下代码片段所示：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Connection loss and reconnecting retries
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接丢失和重新连接重试
- en: 'Browsers that support SSE, which are listed early in this section, can try
    reconnecting to the server in case the connection between browser and server is
    severed. The default retry interval is `3000` milliseconds but it can be adjusted
    by including the `retry` directive in the messages that the server sends to the
    client. For example, to increase the retry interval to `5000` milliseconds the
    SSE message that the server sends can be similar to the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 支持SSE的浏览器（本节开头列出），在浏览器和服务器之间的连接被切断的情况下，可以尝试重新连接到服务器。默认的重试间隔是`3000`毫秒，但可以通过在服务器发送给客户端的消息中包含`retry`指令来调整。例如，要将重试间隔增加到`5000`毫秒，服务器发送的SSE消息可以类似于以下代码片段：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Associating event names with events
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将事件名称与事件关联
- en: 'Another SSE directive is the event name. Each event source can generate more
    than one type of event and the client can decide how to consume each event type
    based on what event type it subscribes to. The following snippet shows how event
    name directives incorporate into the message:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个SSE指令是事件名称。每个事件源可以生成多种类型的事件，客户端可以根据它订阅的事件类型来决定如何消费每种事件类型。以下代码片段显示了事件名称指令如何结合到消息中：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Server-sent Events and JavaScript
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器发送事件和JavaScript
- en: 'The major SSE API that is considered the foundation of SSE in the client side
    for JavaScript developers is the `EventSource` interface. The `EventSource` interface
    contains a fair number of functions and attributes but the most important ones
    are listed as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是JavaScript开发者客户端SSE（服务器发送事件）基础的SSE API是`EventSource`接口。`EventSource`接口包含相当数量的函数和属性，但最重要的如下列所示：
- en: '**The addEventListener function**: To add an event listener to handle the incoming
    events based on event type.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**addEventListener函数**：用于添加事件监听器以处理基于事件类型传入的事件。'
- en: '**The removeEventListener event function**: To remove an already registered
    listener.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**removeEventListener事件函数**：用于移除已注册的监听器。'
- en: '**The onmessage event function**: It is invoked on message arrival. There is
    no custom event handling available when using the `onmessage` method. Listeners
    manage the custom event handling.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onmessage事件函数**：在消息到达时被调用。使用`onmessage`方法时没有可用的自定义事件处理。监听器管理自定义事件处理。'
- en: '**The onerror event function**: It is invoked when something goes wrong with
    the connection.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onerror事件函数**：在连接出现问题时被调用。'
- en: '**The onopen event function**: It is invoked when a connection is opened.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onopen事件函数**：在连接打开时被调用。'
- en: '**The close function**: It is invoked when a connection is closed.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**close函数**：在连接关闭时被调用。'
- en: The following snippet shows how to subscribe for different event types omitted
    by one source. The snippet assumes that the incoming messages are JSON-formatted
    messages. The `'bookavailable'` listener uses a simple JSON parser to parse the
    incoming JSON and then will use that to update the GUI while the `'newbookadded'`
    listener uses the reviver function to filter out and selectively process the JSON
    pairs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段显示了如何订阅来自一个源省略的不同事件类型。该片段假设传入的消息是JSON格式的消息。`'bookavailable'`监听器使用简单的JSON解析器解析传入的JSON，然后使用它来更新GUI，而`'newbookadded'`监听器使用reviver函数过滤并选择性地处理JSON对。
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before we move to WebSockets as another emerging technology let''s take a look
    at the following paired server and client, which are written as a Java EE Servlet
    and JavaScript to see how SSE works:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向WebSocket作为另一种新兴技术之前，让我们看看以下配对的客户端和服务器，它们被编写为Java EE Servlet和JavaScript，以了解SSE是如何工作的：
- en: 'Servlet''s `processRequest` function look like the following snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet的`processRequest`函数看起来如下所示的片段：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding Servlet writes out the current date every one second and, if the
    browser hits the Servlet's URL, the output should be similar to the following
    figure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Servlet每秒写入当前日期，如果浏览器访问Servlet的URL，输出应该类似于以下图示。
- en: '![Server-sent Events and JavaScript](img/8125ENT_02_05.png.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![服务器发送事件和JavaScript](img/8125ENT_02_05.png.jpg)'
- en: 'And the JSP page in the same web application look like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同一Web应用程序中的JSP页面看起来如下所示：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Checking the JSP page''s URL will show an output similar to the following screenshot.
    As you can see, the Servlet''s output messages are shown with formatting as it
    is specified in the JavaScript code in the JSP page:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查JSP页面的URL将显示类似于以下截图的输出。如您所见，Servlet的输出消息以JSP页面中JavaScript代码中指定的格式显示：
- en: '![Server-sent Events and JavaScript](img/8125ENT_02_06.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![服务器发送事件和JavaScript](img/8125ENT_02_06.png.jpg)'
- en: More complete and advanced examples are included in [Chapter 3](ch03.html "Chapter 3. Understanding
    WebSockets and Server-sent Events in Detail"), *Understanding WebSockets and Server-sent
    Events in Detail* and [Chapter 5](ch05.html "Chapter 5. RESTful Web Services by
    Example"), *RESTful Web Services by Example*. The complete code for the preceding
    example is included in the book's code bundle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。详细理解WebSocket和服务器发送事件")、“详细理解WebSocket和服务器发送事件”和[第5章](ch05.html
    "第5章。通过示例理解RESTful Web服务")、“通过示例理解RESTful Web服务”中包含了更完整和高级的示例。前述示例的完整代码包含在本书的代码包中。
- en: WebSockets
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket
- en: The WebSockets component of HTML5 adds a brand new method for interaction between
    clients and servers to address the scalability and flexibility required for modern
    web-scale applications by introducing a full duplex event-based communication
    channel between clients and servers. After being initiated by the client, the
    server can send binary and textual data concerning the client over the channel
    and the client can, without reinitiating a connection, send messages to the server.
    The event source and event subscription model discussed in the *Server-sent Events*
    section is available in WebSockets as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的WebSocket组件通过在客户端和服务器之间引入一个全双工的事件通信通道，为现代Web规模应用所需的可扩展性和灵活性提供了一种全新的交互方法。一旦客户端发起，服务器就可以通过该通道发送关于客户端的二进制和文本数据，而客户端也可以在不重新初始化连接的情况下向服务器发送消息。在“服务器发送事件”部分讨论的事件源和事件订阅模型同样适用于WebSocket。
- en: WebSocket handshake
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebSocket握手
- en: There is an optional handshake request-response devised to let the applications
    switch to WebSockets when required. In a sample scenario shown below, the client
    requests the protocol upgrade to WebSockets by sending the upgrade request header
    to the server. If the server supports the upgrade the response will include the
    protocol upgrade as shown afterward.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可选的手动握手请求-响应机制，以便在需要时让应用程序切换到WebSocket。在下面的示例场景中，客户端通过向服务器发送升级请求头来请求协议升级到WebSocket。如果服务器支持升级，响应将包括后续显示的协议升级。
- en: 'The client request to upgrade to WebSockets looks as shown in the following
    code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求升级到WebSocket看起来如下所示的代码片段：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the server response handshake can look as shown in the following snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应握手可以看起来如下所示的片段：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the handshake is completed the communication between the client and server
    occurs over a bidirectional socket. The WebSockets wire level communication protocol
    is different than HTTP wire protocol and because of that it is possible that intermediate
    servers like proxy servers or cache servers are not capable or intercepting and
    processing the WebSockets messages as they do with HTTP messages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手完成后，客户端和服务器之间的通信将通过双向套接字进行。WebSocket的底层通信协议与HTTP底层协议不同，因此，中间服务器，如代理服务器或缓存服务器可能无法像处理HTTP消息那样拦截和处理WebSocket消息。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent
    Events in Detail"), *Understanding WebSockets and Server-sent Events in Detail*
    in the WebSockets section you can learn more details on the WebSockets client
    and server implementation along with details on protocol upgrade. [Chapter 5](ch05.html
    "Chapter 5. RESTful Web Services by Example"), *RESTful Web Services by Example*,
    includes complete sample applications that further dive into using WebSockets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 详细了解WebSocket和服务器端事件")，*详细了解WebSocket和服务器端事件*的WebSocket部分，你可以了解更多关于WebSocket客户端和服务器实现以及协议升级的细节。[第5章](ch05.html
    "第5章. 通过示例了解RESTful Web服务")，*通过示例了解RESTful Web服务*包括完整的示例应用程序，进一步深入使用WebSocket。
- en: Browser and JavaScript support for WebSockets
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器和JavaScript对WebSocket的支持
- en: 'New versions of major web browsers support WebSockets and using WebSockets
    in the client side just involves creating a WebSockets object and then setting
    different listeners and event handlers for different events. The following list
    shows the important functions and attributes of the `WebSocket` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 新版的主要网络浏览器支持WebSocket，在客户端使用WebSocket只需创建一个WebSocket对象，然后为不同的事件设置不同的监听器和事件处理器。以下列表显示了`WebSocket`类的关键函数和属性：
- en: '**The constructor**: To initialize the `WebSocket` object, the resource URL
    is enough to be passed to the `WebSocket` constructor'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：为了初始化`WebSocket`对象，只需将资源URL传递给`WebSocket`构造函数即可。'
- en: '**The send function**: The `send` function can be used to send a message to
    the server''s specified URL during the object construction.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**send函数**：在对象构造期间，可以使用`send`函数向服务器指定的URL发送消息。'
- en: '**The onopen event function**: This function is invoked when the connection
    is created. The `onopen` handles the `open` event type.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onopen事件函数**：当连接创建时，该函数被调用。`onopen`处理`open`事件类型。'
- en: '**The onclose event function**: The function is invoked when the connection
    is being closed. The `onclose` handles the `close` event type.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onclose事件函数**：当连接正在关闭时，该函数被调用。`onclose`处理`close`事件类型。'
- en: '**The onmessage event function**: When a new message arrives, the `onmessage`
    function is invoked to handle the `message` event.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onmessage事件函数**：当收到新消息时，`onmessage`函数被调用以处理`message`事件。'
- en: '**The onerror event function**: The function is invoked to handle the `error`
    event when an error in the communication channel occurs.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onerror事件函数**：当通信通道发生错误时，该函数被调用以处理`error`事件。'
- en: '**The close function**: To close the communication socket and end the interaction
    between the client and the server.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**close函数**：用于关闭通信套接字并结束客户端与服务器之间的交互。'
- en: 'A very basic example of using the JavaScript WebSocket API is shown below:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了使用JavaScript WebSocket API的一个非常基础的示例：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An example server-side component, a WebSockets endpoint, is shown in the following
    code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面代码片段展示了示例服务器端组件，一个WebSocket端点：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Details of how the implementation of a WebSockets endpoint looks is included
    in [Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent
    Events in Detail"), *Understanding WebSockets and Server-sent Events in Detail*
    and [Chapter 5](ch05.html "Chapter 5. RESTful Web Services by Example"), *RESTful
    Web Services by Example*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket端点实现细节的详细信息包含在[第3章](ch03.html "第3章. 详细了解WebSocket和服务器端事件")，*详细了解WebSocket和服务器端事件*以及[第5章](ch05.html
    "第5章. 通过示例了解RESTful Web服务")，*通过示例了解RESTful Web服务*中。
- en: Java EE and the emerging standards
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE和新兴标准
- en: Java EE has always been an adopter of emerging standards and features and capabilities,
    which were required by the Java EE community. Starting from Java EE 6, Java EE
    spec leads focused their attention on the emerging standards and in Java EE 7
    full support for HTML5, SSE and WebSockets is included in the spec; thus any Java
    EE application server can host a WebSockets, SSE, and HTML5-oriented application
    without any compatibility issue at the server side.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 一直是一个新兴标准和功能以及能力的采纳者，这些标准和能力是 Java EE 社区所需求的。从 Java EE 6 开始，Java EE
    规范领导者将他们的注意力集中在新兴标准上，在 Java EE 7 中，规范中包括了 HTML5、SSE 和 WebSocket 的全面支持；因此，任何 Java
    EE 应用服务器都可以托管一个 WebSocket、SSE 和 HTML5 面向的应用程序，而不会在服务器端出现任何兼容性问题。
- en: Java EE and Server-sent Events
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java EE 和服务器端事件
- en: For the SSE, which is an HTML5 browser API component, the server side can be
    a Servlet that produces SSE messages according to the SSE message format or it
    can be a SSE resource which is POJO annotated with `@Path`. In the client side,
    JavaScript can be used as the standard in-browser API to consume the SSE events
    or it can be developed using the SSE client side API introduced in Jersey 2.0
    if a Java-based client is required.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SSE，这是一个 HTML5 浏览器 API 组件，服务器端可以是生成 SSE 消息的 Servlet，或者它可以是注解了 `@Path` 的 SSE
    资源，即 POJO。在客户端，可以使用 JavaScript 作为标准浏览器 API 来消费 SSE 事件，或者如果需要基于 Java 的客户端，可以使用
    Jersey 2.0 中引入的 SSE 客户端 API 来开发。
- en: 'The following table shows the important classes and interfaces that are entry
    points to SSE APIs included in Jersey 2.0:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了包含在 Jersey 2.0 中的 SSE API 的重要类和接口，它们是 SSE API 的入口点：
- en: '| Class | Description |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Broadcaster` | Used for broadcasting SSE to multiple `EventChannel` instances.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `Broadcaster` | 用于向多个 `EventChannel` 实例广播 SSE。|'
- en: '| `OutboundEvent` | This is the outgoing event class to send the Server-sent
    Events. An `OutboundEvent` can have id, name, date, and comment associated with
    it. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `OutboundEvent` | 这是发送服务器端事件的输出事件类。一个 `OutboundEvent` 可以与 id、name、date 和
    comment 关联。|'
- en: '| `EventChannel` | This is the outgoing event message channel. When returned
    from resource method, the underlying connection is kept open and the application
    is able to send events. One instance of this class corresponds with exactly one
    HTTP connection. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `EventChannel` | 这是输出事件消息通道。当从资源方法返回时，底层连接保持打开状态，应用程序能够发送事件。这个类的实例与一个精确的
    HTTP 连接相对应。|'
- en: '| `EventSource` | This is the client for reading and processing Server-sent
    `InboundEvents` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `EventSource` | 这是读取和处理服务器端 `InboundEvents` 的客户端。|'
- en: '| `InboundEvent` | This represents an incoming event. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `InboundEvent` | 这代表一个传入的事件。|'
- en: '| `ClientFactory` | This is the main entry point to the client API used to
    bootstrap client instances. For example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ClientFactory` | 这是客户端 API 的主要入口点，用于启动客户端实例。例如：'
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Client` | Client is the main entry point to the fluent API used to build
    and execute client requests in order to consume responses returned.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Client` | 客户端是构建和执行客户端请求以消费返回响应的流畅 API 的主要入口点。|'
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ResourceConfig` | This encapsulates the configuration for configuring a
    web application. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `ResourceConfig` | 这封装了配置一个 Web 应用程序的配置。|'
- en: 'The following table shows important annotations included in Java EE 7 and used
    throughout this book for developing SSE applications:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了包含在 Java EE 7 中并用于本书中开发 SSE 应用程序的重要注解：
- en: '| Annotation | Description |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 描述 |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Path` | To annotate a POJO with the resource path it represent. For example
    `@Path("books")` or to annotate a sub-resource which is a method in the annotated
    class. For example `getBook` with related parameters for that method along with
    validation expression for the method parameters. For example:`@Path("{id: ^\d{9}[\d&#124;X]$}")``getBook(@PathParam("id")
    String isbn10)` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `@Path` | 用于注解一个 POJO，表示其资源路径。例如 `@Path("books")` 或注解一个子资源，该子资源是注解类中的方法。例如
    `getBook`，包括与该方法相关联的参数以及方法参数的验证表达式。例如:`@Path("{id: ^\d{9}[\d&#124;X]$}")` `getBook(@PathParam("id")
    String isbn10)` |'
- en: '| `@Produces` | To specify the type of output that the resource produces or
    in a narrower scope the type of output that a method in a resource produces. For
    example: `@Produces(MediaType.APPLICATION_JSON)` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `@Produces` | 用于指定资源产生的输出类型，或者在更窄的范围内，指定资源中方法产生的输出类型。例如：`@Produces(MediaType.APPLICATION_JSON)`
    |'
- en: '| `@Consumes` | To specify the type of input that the resource consumes or
    in a narrower scope the type of input that a method in a resource consumes. For
    example: `@Consumes (MediaType.APPLICATION_JSON)` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `@Consumes` | 用于指定资源消费的类型，或在更窄的范围内，指定资源中方法消费的类型。例如：`@Consumes (MediaType.APPLICATION_JSON)`
    |'
- en: '| `@GET@POST@DELETE` | To map the HTTP methods to methods in the resource representing
    class. For example `@GET` can be placed on the `getBook` method |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `@GET@POST@DELETE` | 将 HTTP 方法映射到表示类的资源中的方法。例如，`@GET` 可以放置在 `getBook` 方法上
    |'
- en: '| `@PathParam` | To specify the mapping between the query parameter''s name
    and method. For example: `getBook(@PathParam("id") String isbn10)` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `@PathParam` | 用于指定查询参数名称与方法之间的映射。例如：`getBook(@PathParam("id") String isbn10)`
    |'
- en: '| `@ApplicationPath` | Identifies the application path that serves as the base
    URI for all resource URIs provided by `@Path`. For example, `@ApplicationPath("library")`
    for the library application. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `@ApplicationPath` | 识别应用程序路径，该路径作为由 `@Path` 提供的所有资源 URI 的基本 URI。例如，对于图书馆应用程序，使用
    `@ApplicationPath("library")`。 |'
- en: '| `@Context` | This can be used to inject contextual objects such as `UriInfo`,
    which provides contextual request-specific information about the request URI.
    For example:`getBook(@Context UriInfo uriInfo)` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `@Context` | 这可以用来注入上下文对象，如 `UriInfo`，它提供了关于请求 URI 的特定请求上下文信息。例如：`getBook(@Context
    UriInfo uriInfo)` |'
- en: '[Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent
    Events in Detail"), *Understanding WebSockets and Server-sent Events in Detail*,
    is dedicated to annotations; it explains how to use these annotations and more
    advanced features of Server-sent Events and [Chapter 5](ch05.html "Chapter 5. RESTful
    Web Services by Example"), *RESTful Web Services by Example*, includes complete
    examples of how Server-sent Events and WebSockets work in real use cases.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。详细理解 WebSocket 和服务器发送事件"), *详细理解 WebSocket 和服务器发送事件*，专门介绍注解；它解释了如何使用这些注解以及服务器发送事件和
    [第 5 章](ch05.html "第 5 章。通过示例理解 RESTful Web 服务"), *通过示例理解 RESTful Web 服务*，包括在真实用例中如何使用服务器发送事件和
    WebSocket 的完整示例。'
- en: Java EE and WebSockets
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java EE 和 WebSocket
- en: 'In Java EE 7, there is a new JSR to support WebSockets in Java EE container.
    JSR-356 defines the requirements and the API that a Java EE application server
    provides to develop WebSockets-based applications. The important annotations provided
    for WebSockets development are included in the following table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 7 中，有一个新的 JSR 支持在 Java EE 容器中实现 WebSocket。JSR-356 定义了 Java EE 应用服务器为开发基于
    WebSocket 的应用程序提供的规范和 API。以下表格中包含了用于 WebSocket 开发的重要注解：
- en: '| Annotation | Description |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 描述 |'
- en: '| --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@ClientEndpoint` | A class-level annotation that is used to denote that
    a POJO is a WebSocket client for instructing the server to deploy it as a managed
    component of that type. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `@ClientEndpoint` | 一个类级别的注解，用于表示一个 POJO 是一个 WebSocket 客户端，指示服务器将其部署为该类型的托管组件。
    |'
- en: '| `@OnClose` | A method-level annotation to decorate a Java method that requires
    to be called when a WebSocket session is closing. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `@OnClose` | 一个方法级别的注解，用于装饰一个 Java 方法，当 WebSocket 会话关闭时需要被调用。 |'
- en: '| `@OnError` | A method-level annotation to decorate a Java method that requires
    to be called in order to handle connection errors. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `@OnError` | 一个方法级别的注解，用于装饰一个 Java 方法，需要被调用以处理连接错误。 |'
- en: '| `@OnMessage` | A method-level annotation to mark a Java method as WebSocket
    message receiver. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `@OnMessage` | 一个方法级别的注解，用于标记一个 Java 方法作为 WebSocket 消息接收器。 |'
- en: '| `@OnOpen` | A method level annotation to decorate a Java method that should
    be called when a new WebSocket session is open. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `@OnOpen` | 一个方法级别的注解，用于装饰一个 Java 方法，当新的 WebSocket 会话打开时应该被调用。 |'
- en: '| `@PathParam` | To specify the mapping between the query parameter''s name
    and method. For example:`getBook(@PathParam("id") String isbn10)` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `@PathParam` | 用于指定查询参数名称与方法之间的映射。例如：`getBook(@PathParam("id") String isbn10)`
    |'
- en: '| `@ServerEndpoint` | A class-level annotation that declares the class it decorates
    is a WebSocket endpoint that will be deployed and made available in the URI-space
    of a WebSocket server. For example:`@ServerEndpoint("/books "); public class Books
    {…}` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `@ServerEndpoint` | 一个类级别的注解，声明它所装饰的类是一个 WebSocket 端点，该端点将被部署并在 WebSocket
    服务器的 URI 空间中可用。例如：`@ServerEndpoint("/books "); public class Books {…}` |'
- en: 'The following table shows the important classes and interfaces that are used
    throughout the book when WebSockets is discussed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了在讨论 WebSocket 时，整本书中使用的的重要类和接口：
- en: '| Class | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Encode(and subintefaces and subclasses)` | Defines how to map a WebSocket
    message to a Java object. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Encode(and subintefaces and subclasses)` | 定义如何将WebSocket消息映射到Java对象。 |'
- en: '| `Decoder(and subintefaces and subclasses)` | Defines how to map a Java object
    to a WebSocket message. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `Decoder(and subintefaces and subclasses)` | 定义如何将Java对象映射到WebSocket消息。 |'
- en: '| `Session` | A WebSocket session represents a conversation between two WebSocket
    endpoints. As soon as the WebSocket handshake completes successfully, the WebSocket
    implementation provides the endpoint with an open WebSocket session. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `Session` | 一个WebSocket会话代表两个WebSocket端点之间的对话。一旦WebSocket握手成功完成，WebSocket实现就会为端点提供一个打开的WebSocket会话。
    |'
- en: Comparison and use cases of different programming models and standards
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同编程模型和标准的比较与用例
- en: 'The following table shows a comparison and conclusion of how the three major
    techniques and standards described in this chapter compare to each other:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了本章中描述的三大技术和标准之间的比较和结论：
- en: '| Subject | SSE | WebSockets | Long polling |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 主题 | SSE | WebSockets | 长轮询 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Error handling | Build-in support for error handling | Build-in support for
    error handling | Almost no error handling in case of chunked transfer |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 错误处理 | 内建错误处理支持 | 内建错误处理支持 | 在分块传输的情况下几乎没有任何错误处理 |'
- en: '| Performance | Usually results are better than long polling and inferior to
    WebSockets | Best performance result compared to the other two solutions | Small
    CPU resource but idle process/thread per client connection, limits scalability
    and extensive memory usage |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 通常结果比长轮询好，但比WebSocket差 | 与其他两种解决方案相比，性能最佳结果 | 小型CPU资源，但每个客户端连接都有一个空闲的进程/线程，限制了可扩展性和内存使用
    |'
- en: '| Browser support1,2 | Firefox, Chrome, Safari, Opera | For RFC 6455: IE 10,
    Firefox 11, Chrome 16, Safari 6, Opera 12.10 | All current browsers support this
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器支持1,2 | Firefox, Chrome, Safari, Opera | 对于RFC 6455：IE 10, Firefox 11,
    Chrome 16, Safari 6, Opera 12.10 | 所有当前浏览器都支持此功能 |'
- en: '| Browser performance | Built-in support in browser, small amount of resources
    | Built-in support in browser, small amount of resources | Complicated to get
    the performance right specially with lots of JavaScripts and possible memory leaks
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器性能 | 浏览器内建支持，资源占用少 | 浏览器内建支持，资源占用少 | 特别是在有很多JavaScript和可能的内存泄漏时，获取正确的性能比较复杂
    |'
- en: '| Communication channel | HTTP unidirectional | WebSockets bidirectional |
    HTTP unidirectional |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 通信通道 | 单向HTTP | 双向WebSocket | 单向HTTP |'
- en: '| Implementation complexity | Easy | Requires server with WebSockets support
    | Easiest |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 实现复杂性 | 简单 | 需要支持WebSocket的服务器 | 最简单 |'
- en: For more details visit [http://en.wikipedia.org/wiki/WebSocket#Browser_support](http://en.wikipedia.org/wiki/WebSocket#Browser_support)
    and [http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers](http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情请访问[http://en.wikipedia.org/wiki/WebSocket#Browser_support](http://en.wikipedia.org/wiki/WebSocket#Browser_support)和[http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers](http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers)。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reading the *Memory leak patterns in JavaScript* article available at [http://www.ibm.com/developerworks/web/library/wa-memleak/](http://www.ibm.com/developerworks/web/library/wa-memleak/)
    is recommended to avoid JavaScript memory leaks pitfalls.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 建议阅读[http://www.ibm.com/developerworks/web/library/wa-memleak/](http://www.ibm.com/developerworks/web/library/wa-memleak/)上的*JavaScript内存泄漏模式*文章，以避免JavaScript内存泄漏的陷阱。
- en: 'The following list shows which types of use case match with one of the programming
    models and standards:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了哪些类型的用例与一种编程模型和标准相匹配：
- en: 'Long polling: When compatibility is an issue and browsers are not up-to-date
    (usually for enterprise users who stick with approved versions of software for
    many years)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长轮询：当兼容性是一个问题，并且浏览器没有更新（通常适用于坚持使用多年软件批准版本的企业的用户）
- en: '**SSE**: When the communication is one way and server requires sending events
    to browser so browser can update some GUI elements. It provides error handling
    and structured message format advantage over long polling. Sample use cases include:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSE**: 当通信是单向的，服务器需要向浏览器发送事件以便浏览器更新一些GUI元素时。它提供了比长轮询更优越的错误处理和结构化消息格式。以下是一些示例用例：'
- en: A chart that updates in real-time
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时更新的图表
- en: A newsreader that shows the latest headlines
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示最新头条的新闻播报器
- en: Stock tickers reader
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票行情阅读器
- en: 'WebSockets: When full duplex, bi-directional communication is required between
    the client and the server. Some sample applications are as follows:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSockets：当客户端和服务器之间需要全双工、双向通信时。以下是一些示例应用：
- en: A chat application
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天应用
- en: A real-time interactive multiuser charting and drawing application
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时交互式多用户图表和绘图应用
- en: Multiuser browser-based games
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多用户基于浏览器的游戏
- en: 'WebSockets provide all benefits and advantages of SSE with some disadvantages
    that are listed as follows:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSockets提供了SSE的所有优点和优势，但也存在以下缺点：
- en: The wire protocol is different so some intermediate servers, such as proxy servers,
    may not be able to intercept and interpret the messages.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输协议不同，因此一些中间服务器，如代理服务器，可能无法拦截和解释消息。
- en: If a browser does not support WebSockets there is no way to make the browser
    handle the communication while in the case of SSE the browser can use JavaScript
    libraries to handle SSE communication, polyfilling the browser. For example, **Remy
    Polyfill**.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果浏览器不支持WebSockets，则无法使浏览器处理通信，而在SSE的情况下，浏览器可以使用JavaScript库来处理SSE通信，通过polyfill来弥补浏览器的不足。例如，**Remy
    Polyfill**。
- en: Lack of support for event ID.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏对事件ID的支持。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A good write-up to further understand the Polifill can be found at [http://remysharp.com/2010/10/08/what-is-a-polyfill/](http://remysharp.com/2010/10/08/what-is-a-polyfill/).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://remysharp.com/2010/10/08/what-is-a-polyfill/](http://remysharp.com/2010/10/08/what-is-a-polyfill/)找到一篇很好的文章，进一步了解Polifill。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was the opening door to the whole world of asynchronous Web by
    introducing the fundamental concepts involving in web architecture and going forward
    with the evolution of the basic request response model to polling, long polling,
    Server-sent Event, and WebSockets.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过介绍涉及网络架构的基本概念，并随着基本请求/响应模型从轮询、长轮询、服务器发送事件（Server-sent Event）到WebSockets的演变，为异步Web世界的整个领域打开了大门。
- en: In the next chapter WebSockets and Server-sent Events are covered in details.
    [Chapter 5](ch05.html "Chapter 5. RESTful Web Services by Example"), *RESTful
    Web Services by Example*, has complete sample application developed using WebSockets
    and Server-sent Events.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将详细介绍WebSockets和服务器发送事件。[第5章](ch05.html "第5章。通过示例学习RESTful Web服务")，《通过示例学习RESTful
    Web服务》，包含使用WebSockets和服务器发送事件开发的完整示例应用。
