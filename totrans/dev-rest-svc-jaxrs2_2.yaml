- en: Chapter 2. WebSockets and Server-sent Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advancements in web architecture and emerging platforms, which can
    provide real-time or near real-time information, the necessity of having an effective
    way of communicating these updates to clients caused the urge of introducing new
    programming models and new standards that make use of this real-time information
    easier for the consumer side of the system, also known as clients (mostly web
    browsers).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The programming models and solutions that can be used to address near real-time
    update transfer to clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Server-sent Events (SSE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different snippets are included in this chapter but complete samples which shows
    these snippet in actions are included as part of the book's source code download
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: The programming models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will cover the different programming models that emerged
    to address the near real-time updating of the client view based on the updates
    that are produced by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Polling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, HTTP, which is the foundation of communication over the
    Internet, uses a simple request/response model in which a request either timeouts
    or get a response back from the server. The response can be the actual response
    the request was intended for or it can be an error message, underneath one of
    the standard error status codes. The client always initiates the communication;
    the server cannot initiate a communication channel without receiving a request
    from a client to send back a response.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, to update the client it is required to check for the new updates
    on the server and if an update is available the client can react to the update
    and, for example, change a text to denote that a book that was not available is
    available for borrowing now or a show a new image, or to perform any other action
    that maps to the response received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending periodical requests to a server to check for updates is called **polling**.
    It does not scale to hundreds of thousands of clients and thus it cannot be an
    effective programming model to handle the massive client numbers of today''s applications.
    In the polling model the response does not necessarily includes updates generated
    in the server but rather it may just be a `200 OK` response without any particular
    updates for the client to use. In this model, tens of requests may receive nothing
    but `200 OK` without any meaningful update for the client, which means these tens
    wasted the resources in vain. Of course, this model is useful if the number of
    clients is limited and if severe compatibility issues exist that prevent the clients
    to update to newer versions, for example, very old browsers. The following diagram
    shows the polling model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polling](img/8125ENT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The polling-based model is enriched with JavaScript in the client side; the
    browsers, to update the view without changing the page and thus list available
    books in a library application, can change without the user refreshing the page.
    The following code snippet shows the server side of a polling pair written in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample does not use JSON for data format or any of the new Async
    functionalities introduced in Java EE 7 and Servlet 3.1 which are discussed in
    [Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent Events
    in Detail"), *Understanding WebSockets and Server-sent Events in Detail* and [Chapter
    4](ch04.html "Chapter 4. JSON and Asynchronous Processing"), *JSON and Asynchronous
    Processing*, but rather shows how the basics work. The Servlet writes the current
    date on the response for any `GET` request. The servlet is mapped to `PollingServlet`
    path in the `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows how we can use JavaScript to perform a request
    in the background, get the response, and update content of a `div` element of
    the HTML page by manipulating the equivalent DOM tree element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The HTML page in the preceding snippet is the simplest possible form; it does
    not check whether the response for each request is `OK` neither does it check
    whether the code is being executed in IE or a non-IE browser for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `startUpdating` function is invoked when the page is loaded, the function
    sends a request to the Servlet shown before and invokes the `updateDiv` function
    to update the GUI and then schedule another invocation of it after 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The limitations of the polling model can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is the client that performs polling and there is no service pushing involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is resource-consuming as many requests will result in a response that does
    not have any effective update for the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long intervals between requests may yield an outdated client view while short
    intervals overload the servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long polling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the limitation of the polling model in mind, a new programming model emerged
    in which a request either timeouts or carries back useful updates to the client.
    In this model a request is sent to the server and the request is set to a timeout
    after a very long time so that the cost of handshake and request initiation reduces
    as much as possible by a reduction in the number of requests and responses in
    a fixed period of time. A response is only sent back if there are some updates
    in the server, which the client should receive. When such an update becomes available
    in the server, the server sends back the response with the update and client initiates
    another request after consuming the update it received. The benefit of this model
    is fewer numbers of requests compared to polling, which reduces the resource consumption
    and increases the scalability. The following diagram shows the **long polling**
    model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Long polling](img/8125ENT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Long polling clients and XMLHttpRequest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `XMLHttpRequest` object is available as part of the JavaScript in-browser
    API to facilitate the interaction of the JavaScript part of a web page with the
    web server. It can be used to send a request to the server and receive the response
    without refreshing the page after the page is loaded; for example, to update the
    list of available books after the `available.html` page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality of the `XMLHttpRequest` object is categorized in events, methods,
    and properties. The important properties, events, and important methods are discussed
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The values of properties change when an event is fired and when methods are
    invocated. Checking the property values makes it possible to evaluate the current
    state of the `XMLHttpRequest` object or to handle the response.
  prefs: []
  type: TYPE_NORMAL
- en: '`readyState`: Stores the current state of the ongoing request. The table after
    the list shows different values of the `readyState` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseText`: Returns the response text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseXML`: Returns a DOM object representing the response data. The assumption
    is that the response text is a valid XML document. The XML document can be traversed
    using standard DOM parser methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: Shows the status code of the request; for example, `200`, `404`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statusText`: Human readable text equivalent of request status code. For example
    `"OK"`, `"Not Found"`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| The readyState value and textual equivalent | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` (`UNINITIALIZED`) | The `XMLHttpRequest` object is created, but not opened.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1` (`LOADING`) | The `XMLHttpRequest` object is created, the open method
    is called but no request is sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `2` (`LOADED`) | The send method is called, no response yet. |'
  prefs: []
  type: TYPE_TB
- en: '| `3` (`INTERACTIVE`) | The send method is called, some data was received but
    the response is not concluded yet. |'
  prefs: []
  type: TYPE_TB
- en: '| `4` (`COMPLETED`) | Response is concluded and the entire message is received.
    Message content is available in the `responseBody` and `responseText` properties.
    |'
  prefs: []
  type: TYPE_TB
- en: Each event can have an associated method, which is invoked when the event is
    fired. The sample code afterward shows how these events can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '`onreadystatechange`: This event is fired when the state of a request initiated
    by this `XMLHttpRequest` instance is changed. The state change is communicated
    via the `readyState` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ontimeout`: This event is fired when a request initiated with this `XMLHttpRequest`
    instance is timed out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After invocation of each method the value of the relevant properties will change.
  prefs: []
  type: TYPE_NORMAL
- en: '`abort`: This aborts the current request of the `XMLHttpRequest` instance.
    The `readyState` value is set to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: This prepares a request by setting the method, URL and security credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send`: This sends the request that is prepared by the `open` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunked transfer encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another possible way of using the long polling model is to use the message body
    streaming to send chunks of data and update events, when those chunks are available
    in the server and ready to be consumed by the developer. In the message body streaming
    model the server does not close the response but rather keeps it open and sends
    the update events to client as they are produced in the server. The message body
    streaming involves using the chunked transfer encoding which is a `HTTP/1.1` feature.
  prefs: []
  type: TYPE_NORMAL
- en: The chunked transfer encoding can be used to send many chunks of data as part
    of the response body, which is opened as a stream. The chunks can be JavaScript
    tags which are loaded in the hidden `iframe` and executed in the order of arrival.
    The execution of arriving scripts can cause the view to update or to trigger any
    other action that is required. The following diagram shows the long polling in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Chunked transfer encoding](img/8125ENT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram the client sent a request along with the `client_id`
    value to the server and the server started sending chunks of responses when some
    updates are available to be sent to the client. The updates are sent as JavaScript
    tags which are then executed in the client's browser to update the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The limitations of the long polling model can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One-way communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No standard data format or message format when used in chunked transfer encoding
    mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One response per request when no `iframe` technique is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each connection initiation has an initiation cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No caching between the clients and server, which impacts server performance
    instead of reading content from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the emergence of requirements and solutions for those requirements, standards
    emerged to ensure compatibility between different the layers, applications, and
    components that form a solution; asynchronous communication, and especially event
    propagation between clients and servers, is one.
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Server-sent Events** (**SSE**), or sometimes simply referred to as **EventSource**
    , is an HTML5 browser API that makes event pushing between server and client available
    to web application developers. The SSE component provides a structured mechanism
    for having a capability similar to long polling without some of the long polling
    drawbacks. As it is an HTML5 component, the browser should support HTML5 SSE to
    be able to take advantage of this API.'
  prefs: []
  type: TYPE_NORMAL
- en: The SSE kernel includes `EventSource` and `Event`.
  prefs: []
  type: TYPE_NORMAL
- en: '`EventSource` is the API that provides the client with the means of subscribing
    to an event source, which can be a Servlet or anything of that sort. After subscription,
    which is nothing more than opening the connection to the URL, events are sent
    to the client in the order that they are produced and in the client the event
    listener can react to the events, for example by updating a chat window, changing
    a graph, or updating the list of available books to borrow or list people that
    are interested in the subject that the event URL is meant for.'
  prefs: []
  type: TYPE_NORMAL
- en: The SSE anatomy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we go deep into the API and see how the API works, it is good to look
    more closely at the characteristics of SSE and how SSE works. The following diagram
    shows SSE in action, which closely resembles the chunked encoding diagram shown
    in the preceding section. The question may a rise: what makes SSE better than
    long polling if both of them work similarly when it comes to request, response,
    and message content?'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SSE anatomy](img/8125ENT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With SSE the events are plain text messages sent from the server to the clients
    after the client opens the initial request meaning that it does not require to
    be a collection of JavaScript tags that need to be executed in the client side
    to update something but rather it can be data that can be consumed in the client
    side by the event listener and event listener can interpret and react to the received
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is the message format; SSE defines a message format for
    the events that are sent from the server to the clients. The message format is
    composed of a plain text line-separated stream of characters. Lines that carry
    the message body or data start with `data:` and lines that carry some **Quality
    of Service** (**QoS**) directives start with the QoS attribute name followed by
    a colon and then the QoS attribute''s value, `directive: value`. The standard
    format makes it possible to develop generic libraries around SSE to make software
    development easier. The following snippet shows a sample message that can indicate
    a new dot in a graph. When the client receives the message it can draw the new
    dot on the graph to show a change in the data the graph is being constructed from.
    The following sample data shows a multiline message in which each line is separated
    from the next using `\n` and end of message is marked with `\n\n`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to develop the server component of a SSE solution using a servlet
    and the client side can be developed using either JavaScript or Java API. The
    Java API to consume SSE events is part of the Java EE 7 provided by means of JAX-RS
    2.0\. The next two sections go into details of the client side API and also the
    server side component of the solution, which is a servlet.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, in addition to the actual message or message body each
    SSE message can carry some directive, which instructs the browser or SSE-compatible
    client on some of the QoS attributes of the interaction. Some of these QoS directives
    are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reference implementation of JAX-RS 2.0 is done under the Jersey 2.0 project.
    The Jersey project is located at [http://jersey.java.net/](http://jersey.java.net/
    ) with extensive documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Associating an ID with an event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each SSE message can have a message identifier, which can be used for a variety
    of purposes; one use of the message ID standard usage is to keep track of the
    messages that the client has received. When a message ID is used in SSE, the client
    can supply the last message ID as one of the connection parameters to instruct
    the server to resume form and specific message onward. Of course the server should
    implement proper the procedure for resuming a communication from where a client
    requests it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example message format with message ID can be as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Connection loss and reconnecting retries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Browsers that support SSE, which are listed early in this section, can try
    reconnecting to the server in case the connection between browser and server is
    severed. The default retry interval is `3000` milliseconds but it can be adjusted
    by including the `retry` directive in the messages that the server sends to the
    client. For example, to increase the retry interval to `5000` milliseconds the
    SSE message that the server sends can be similar to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Associating event names with events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another SSE directive is the event name. Each event source can generate more
    than one type of event and the client can decide how to consume each event type
    based on what event type it subscribes to. The following snippet shows how event
    name directives incorporate into the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Server-sent Events and JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The major SSE API that is considered the foundation of SSE in the client side
    for JavaScript developers is the `EventSource` interface. The `EventSource` interface
    contains a fair number of functions and attributes but the most important ones
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The addEventListener function**: To add an event listener to handle the incoming
    events based on event type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The removeEventListener event function**: To remove an already registered
    listener.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onmessage event function**: It is invoked on message arrival. There is
    no custom event handling available when using the `onmessage` method. Listeners
    manage the custom event handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onerror event function**: It is invoked when something goes wrong with
    the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onopen event function**: It is invoked when a connection is opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The close function**: It is invoked when a connection is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following snippet shows how to subscribe for different event types omitted
    by one source. The snippet assumes that the incoming messages are JSON-formatted
    messages. The `'bookavailable'` listener uses a simple JSON parser to parse the
    incoming JSON and then will use that to update the GUI while the `'newbookadded'`
    listener uses the reviver function to filter out and selectively process the JSON
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move to WebSockets as another emerging technology let''s take a look
    at the following paired server and client, which are written as a Java EE Servlet
    and JavaScript to see how SSE works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Servlet''s `processRequest` function look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Servlet writes out the current date every one second and, if the
    browser hits the Servlet's URL, the output should be similar to the following
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-sent Events and JavaScript](img/8125ENT_02_05.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the JSP page in the same web application look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the JSP page''s URL will show an output similar to the following screenshot.
    As you can see, the Servlet''s output messages are shown with formatting as it
    is specified in the JavaScript code in the JSP page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-sent Events and JavaScript](img/8125ENT_02_06.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More complete and advanced examples are included in [Chapter 3](ch03.html "Chapter 3. Understanding
    WebSockets and Server-sent Events in Detail"), *Understanding WebSockets and Server-sent
    Events in Detail* and [Chapter 5](ch05.html "Chapter 5. RESTful Web Services by
    Example"), *RESTful Web Services by Example*. The complete code for the preceding
    example is included in the book's code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WebSockets component of HTML5 adds a brand new method for interaction between
    clients and servers to address the scalability and flexibility required for modern
    web-scale applications by introducing a full duplex event-based communication
    channel between clients and servers. After being initiated by the client, the
    server can send binary and textual data concerning the client over the channel
    and the client can, without reinitiating a connection, send messages to the server.
    The event source and event subscription model discussed in the *Server-sent Events*
    section is available in WebSockets as well.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket handshake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an optional handshake request-response devised to let the applications
    switch to WebSockets when required. In a sample scenario shown below, the client
    requests the protocol upgrade to WebSockets by sending the upgrade request header
    to the server. If the server supports the upgrade the response will include the
    protocol upgrade as shown afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client request to upgrade to WebSockets looks as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the server response handshake can look as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After the handshake is completed the communication between the client and server
    occurs over a bidirectional socket. The WebSockets wire level communication protocol
    is different than HTTP wire protocol and because of that it is possible that intermediate
    servers like proxy servers or cache servers are not capable or intercepting and
    processing the WebSockets messages as they do with HTTP messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent
    Events in Detail"), *Understanding WebSockets and Server-sent Events in Detail*
    in the WebSockets section you can learn more details on the WebSockets client
    and server implementation along with details on protocol upgrade. [Chapter 5](ch05.html
    "Chapter 5. RESTful Web Services by Example"), *RESTful Web Services by Example*,
    includes complete sample applications that further dive into using WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Browser and JavaScript support for WebSockets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New versions of major web browsers support WebSockets and using WebSockets
    in the client side just involves creating a WebSockets object and then setting
    different listeners and event handlers for different events. The following list
    shows the important functions and attributes of the `WebSocket` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The constructor**: To initialize the `WebSocket` object, the resource URL
    is enough to be passed to the `WebSocket` constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The send function**: The `send` function can be used to send a message to
    the server''s specified URL during the object construction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onopen event function**: This function is invoked when the connection
    is created. The `onopen` handles the `open` event type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onclose event function**: The function is invoked when the connection
    is being closed. The `onclose` handles the `close` event type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onmessage event function**: When a new message arrives, the `onmessage`
    function is invoked to handle the `message` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onerror event function**: The function is invoked to handle the `error`
    event when an error in the communication channel occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The close function**: To close the communication socket and end the interaction
    between the client and the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A very basic example of using the JavaScript WebSocket API is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An example server-side component, a WebSockets endpoint, is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Details of how the implementation of a WebSockets endpoint looks is included
    in [Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent
    Events in Detail"), *Understanding WebSockets and Server-sent Events in Detail*
    and [Chapter 5](ch05.html "Chapter 5. RESTful Web Services by Example"), *RESTful
    Web Services by Example*.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE and the emerging standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE has always been an adopter of emerging standards and features and capabilities,
    which were required by the Java EE community. Starting from Java EE 6, Java EE
    spec leads focused their attention on the emerging standards and in Java EE 7
    full support for HTML5, SSE and WebSockets is included in the spec; thus any Java
    EE application server can host a WebSockets, SSE, and HTML5-oriented application
    without any compatibility issue at the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE and Server-sent Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the SSE, which is an HTML5 browser API component, the server side can be
    a Servlet that produces SSE messages according to the SSE message format or it
    can be a SSE resource which is POJO annotated with `@Path`. In the client side,
    JavaScript can be used as the standard in-browser API to consume the SSE events
    or it can be developed using the SSE client side API introduced in Jersey 2.0
    if a Java-based client is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the important classes and interfaces that are entry
    points to SSE APIs included in Jersey 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Broadcaster` | Used for broadcasting SSE to multiple `EventChannel` instances.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OutboundEvent` | This is the outgoing event class to send the Server-sent
    Events. An `OutboundEvent` can have id, name, date, and comment associated with
    it. |'
  prefs: []
  type: TYPE_TB
- en: '| `EventChannel` | This is the outgoing event message channel. When returned
    from resource method, the underlying connection is kept open and the application
    is able to send events. One instance of this class corresponds with exactly one
    HTTP connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `EventSource` | This is the client for reading and processing Server-sent
    `InboundEvents` |'
  prefs: []
  type: TYPE_TB
- en: '| `InboundEvent` | This represents an incoming event. |'
  prefs: []
  type: TYPE_TB
- en: '| `ClientFactory` | This is the main entry point to the client API used to
    bootstrap client instances. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Client` | Client is the main entry point to the fluent API used to build
    and execute client requests in order to consume responses returned.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ResourceConfig` | This encapsulates the configuration for configuring a
    web application. |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows important annotations included in Java EE 7 and used
    throughout this book for developing SSE applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Path` | To annotate a POJO with the resource path it represent. For example
    `@Path("books")` or to annotate a sub-resource which is a method in the annotated
    class. For example `getBook` with related parameters for that method along with
    validation expression for the method parameters. For example:`@Path("{id: ^\d{9}[\d&#124;X]$}")``getBook(@PathParam("id")
    String isbn10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Produces` | To specify the type of output that the resource produces or
    in a narrower scope the type of output that a method in a resource produces. For
    example: `@Produces(MediaType.APPLICATION_JSON)` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Consumes` | To specify the type of input that the resource consumes or
    in a narrower scope the type of input that a method in a resource consumes. For
    example: `@Consumes (MediaType.APPLICATION_JSON)` |'
  prefs: []
  type: TYPE_TB
- en: '| `@GET@POST@DELETE` | To map the HTTP methods to methods in the resource representing
    class. For example `@GET` can be placed on the `getBook` method |'
  prefs: []
  type: TYPE_TB
- en: '| `@PathParam` | To specify the mapping between the query parameter''s name
    and method. For example: `getBook(@PathParam("id") String isbn10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `@ApplicationPath` | Identifies the application path that serves as the base
    URI for all resource URIs provided by `@Path`. For example, `@ApplicationPath("library")`
    for the library application. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Context` | This can be used to inject contextual objects such as `UriInfo`,
    which provides contextual request-specific information about the request URI.
    For example:`getBook(@Context UriInfo uriInfo)` |'
  prefs: []
  type: TYPE_TB
- en: '[Chapter 3](ch03.html "Chapter 3. Understanding WebSockets and Server-sent
    Events in Detail"), *Understanding WebSockets and Server-sent Events in Detail*,
    is dedicated to annotations; it explains how to use these annotations and more
    advanced features of Server-sent Events and [Chapter 5](ch05.html "Chapter 5. RESTful
    Web Services by Example"), *RESTful Web Services by Example*, includes complete
    examples of how Server-sent Events and WebSockets work in real use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Java EE and WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java EE 7, there is a new JSR to support WebSockets in Java EE container.
    JSR-356 defines the requirements and the API that a Java EE application server
    provides to develop WebSockets-based applications. The important annotations provided
    for WebSockets development are included in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@ClientEndpoint` | A class-level annotation that is used to denote that
    a POJO is a WebSocket client for instructing the server to deploy it as a managed
    component of that type. |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnClose` | A method-level annotation to decorate a Java method that requires
    to be called when a WebSocket session is closing. |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnError` | A method-level annotation to decorate a Java method that requires
    to be called in order to handle connection errors. |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnMessage` | A method-level annotation to mark a Java method as WebSocket
    message receiver. |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnOpen` | A method level annotation to decorate a Java method that should
    be called when a new WebSocket session is open. |'
  prefs: []
  type: TYPE_TB
- en: '| `@PathParam` | To specify the mapping between the query parameter''s name
    and method. For example:`getBook(@PathParam("id") String isbn10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `@ServerEndpoint` | A class-level annotation that declares the class it decorates
    is a WebSocket endpoint that will be deployed and made available in the URI-space
    of a WebSocket server. For example:`@ServerEndpoint("/books "); public class Books
    {…}` |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows the important classes and interfaces that are used
    throughout the book when WebSockets is discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Encode(and subintefaces and subclasses)` | Defines how to map a WebSocket
    message to a Java object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Decoder(and subintefaces and subclasses)` | Defines how to map a Java object
    to a WebSocket message. |'
  prefs: []
  type: TYPE_TB
- en: '| `Session` | A WebSocket session represents a conversation between two WebSocket
    endpoints. As soon as the WebSocket handshake completes successfully, the WebSocket
    implementation provides the endpoint with an open WebSocket session. |'
  prefs: []
  type: TYPE_TB
- en: Comparison and use cases of different programming models and standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows a comparison and conclusion of how the three major
    techniques and standards described in this chapter compare to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Subject | SSE | WebSockets | Long polling |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Error handling | Build-in support for error handling | Build-in support for
    error handling | Almost no error handling in case of chunked transfer |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Usually results are better than long polling and inferior to
    WebSockets | Best performance result compared to the other two solutions | Small
    CPU resource but idle process/thread per client connection, limits scalability
    and extensive memory usage |'
  prefs: []
  type: TYPE_TB
- en: '| Browser support1,2 | Firefox, Chrome, Safari, Opera | For RFC 6455: IE 10,
    Firefox 11, Chrome 16, Safari 6, Opera 12.10 | All current browsers support this
    |'
  prefs: []
  type: TYPE_TB
- en: '| Browser performance | Built-in support in browser, small amount of resources
    | Built-in support in browser, small amount of resources | Complicated to get
    the performance right specially with lots of JavaScripts and possible memory leaks
    |'
  prefs: []
  type: TYPE_TB
- en: '| Communication channel | HTTP unidirectional | WebSockets bidirectional |
    HTTP unidirectional |'
  prefs: []
  type: TYPE_TB
- en: '| Implementation complexity | Easy | Requires server with WebSockets support
    | Easiest |'
  prefs: []
  type: TYPE_TB
- en: For more details visit [http://en.wikipedia.org/wiki/WebSocket#Browser_support](http://en.wikipedia.org/wiki/WebSocket#Browser_support)
    and [http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers](http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading the *Memory leak patterns in JavaScript* article available at [http://www.ibm.com/developerworks/web/library/wa-memleak/](http://www.ibm.com/developerworks/web/library/wa-memleak/)
    is recommended to avoid JavaScript memory leaks pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows which types of use case match with one of the programming
    models and standards:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Long polling: When compatibility is an issue and browsers are not up-to-date
    (usually for enterprise users who stick with approved versions of software for
    many years)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSE**: When the communication is one way and server requires sending events
    to browser so browser can update some GUI elements. It provides error handling
    and structured message format advantage over long polling. Sample use cases include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chart that updates in real-time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A newsreader that shows the latest headlines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stock tickers reader
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WebSockets: When full duplex, bi-directional communication is required between
    the client and the server. Some sample applications are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chat application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-time interactive multiuser charting and drawing application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiuser browser-based games
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WebSockets provide all benefits and advantages of SSE with some disadvantages
    that are listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wire protocol is different so some intermediate servers, such as proxy servers,
    may not be able to intercept and interpret the messages.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a browser does not support WebSockets there is no way to make the browser
    handle the communication while in the case of SSE the browser can use JavaScript
    libraries to handle SSE communication, polyfilling the browser. For example, **Remy
    Polyfill**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of support for event ID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good write-up to further understand the Polifill can be found at [http://remysharp.com/2010/10/08/what-is-a-polyfill/](http://remysharp.com/2010/10/08/what-is-a-polyfill/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was the opening door to the whole world of asynchronous Web by
    introducing the fundamental concepts involving in web architecture and going forward
    with the evolution of the basic request response model to polling, long polling,
    Server-sent Event, and WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter WebSockets and Server-sent Events are covered in details.
    [Chapter 5](ch05.html "Chapter 5. RESTful Web Services by Example"), *RESTful
    Web Services by Example*, has complete sample application developed using WebSockets
    and Server-sent Events.
  prefs: []
  type: TYPE_NORMAL
