<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;JUnit 4 &#x2013; a Total Recall"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. JUnit 4 – a Total Recall</h1></div></div></div><p class="calibre9">This chapter covers the unit testing concept, the JUnit 4 framework, the Eclipse setup, and the advanced features of JUnit 4. In JUnit 4, you will be introduced to the JUnit framework briefly to get you up and running. We will discuss the concept surrounding JUnit essentials, annotations, assertion, the <code class="literal">@RunWith</code> annotation, and exception handling so that you have an adequate background on how JUnit 4 works. Advanced readers can skip to the next section.</p><p class="calibre9">In JUnit 4++, we will explore the advanced topics of JUnit 4 and deep dive into parameterized tests, Hamcrest matchers and <code class="literal">assertThat</code>, the assumption, theory, timeout, categories, rules, test suites, and tests order.</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;JUnit 4 &#x2013; a Total Recall">
<div class="book" title="Defining unit testing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec09" class="calibre1"/>Defining unit testing</h1></div></div></div><p class="calibre9">A test is an assessment <a id="id0" class="calibre1"/>of our knowledge, a proof of concept, or an examination of data. A <a id="id1" class="calibre1"/>class test is an examination of our knowledge to ascertain whether we can go to the next level. For software, it is the validation of functional and nonfunctional requirements before it is shipped to a customer.</p><p class="calibre9">Unit testing code means<a id="id2" class="calibre1"/> validation or performing the sanity check of code. Sanity check is<a id="id3" class="calibre1"/> a basic test to quickly evaluate whether the result of a calculation can possibly be true. It is a simple check to see whether the produced material is coherent.</p><p class="calibre9">It's a common practice to unit test the code using print statements in the main method or by executing the application. Neither of them is the correct approach. Mixing up production code with tests is not a good practice. Testing logic in the production code is a code smell, though it doesn't break the code under the test. However, this increases the complexity of the code and can create severe maintenance problem or cause system failure if anything gets misconfigured. Print statements or logging statements are executed in the production system and print unnecessary information. They increase execution time and reduce code readability. Also, junk logging information can hide a real problem, for instance, you may overlook a critical deadlock or a hung thread warning because of excessive logging of junk.</p><p class="calibre9">Unit testing<a id="id4" class="calibre1"/> is a common practice in <span class="strong"><strong class="calibre10">test-driven development</strong></span> (<span class="strong"><strong class="calibre10">TDD</strong></span>). TDD <a id="id5" class="calibre1"/>is an evolutionary development approach. It offers test-first development where the production code is written only to satisfy a test, and the code is refactored to improve its quality. In TDD, unit tests drive the design. You write code to satisfy a failing test, so it limits the code you write to only what is needed. The tests provide a fast, automated regression for refactoring and new enhancements.</p><p class="calibre9">Kent Beck is the originator of Extreme Programming and TDD. He has authored many books and papers.</p><p class="calibre9">Generally, all tests are included in the same project but under a different directory/folder. Thus, a <code class="literal">org.packt.Bar.java</code> class will have a <code class="literal">org.packt.BarTest.java</code> test. These will be in the same package (<code class="literal">org.packt</code>) but will be organized in the: <code class="literal">src/org/foo/Bar.java</code> and <code class="literal">test/org/foo/BarTest.java</code> directories, respectively.</p><p class="calibre9">Our customers do not execute the unit tests, so we don't deliver the test source folder to them. Having the code and test in the same package allows the test to access protected and default methods/properties. This is particularly useful while working with the legacy code.</p><p class="calibre9">Java code can be unit tested using a code-driven unit testing framework. The following are a few of the available <a id="id6" class="calibre1"/>code-driven unit testing frameworks for Java:</p><div class="book"><ul class="itemizedlist"><li class="listitem">SpryTest</li><li class="listitem">Jtest</li><li class="listitem">JUnit</li><li class="listitem">TestNG</li></ul></div><p class="calibre9">JUnit is the most popular and widely used unit testing framework for Java. We will explore JUnit 4 in the next section.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with JUnit 4"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Working with JUnit 4</h1></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre10">JUnit</strong></span> is a<a id="id7" class="calibre1"/> unit testing framework for Java. It allows developers to unit test the code elegantly. Apparently, TestNG is cleaner than JUnit, but JUnit is far more popular than TestNG. JUnit has a better mocking framework support such as Mockito, which offers a custom JUnit 4 runner.</p><p class="calibre9">The latest version of JUnit (4.11) can be<a id="id8" class="calibre1"/> downloaded from <a class="calibre1" href="https://github.com/junit-team/junit/wiki/Download-and-Install">https://github.com/junit-team/junit/wiki/Download-and-Install</a>.</p><p class="calibre9">JUnit 4 is an annotation-based, flexible framework. Its predecessor has many downsides. The following are the advantages of JUnit 4 over its predecessor:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Instead of inheriting<a id="id9" class="calibre1"/> from <code class="literal">junit.framework.Testcase</code>, any class can be a test class</li><li class="listitem">The <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods are replaced by the <code class="literal">@before</code> and <code class="literal">@after</code> annotations</li><li class="listitem">Any public method annotated as <code class="literal">@test</code> can be a test method</li></ul></div><p class="calibre9">In this chapter, we will use <a id="id10" class="calibre1"/>
<span class="strong"><strong class="calibre10">Eclipse</strong></span> to execute the JUnit tests; in the following chapters, we will be using <span class="strong"><strong class="calibre10">Ant</strong></span>, <span class="strong"><strong class="calibre10">Maven</strong></span>, and <span class="strong"><strong class="calibre10">Gradle</strong></span> to execute tools. Eclipse is<a id="id11" class="calibre1"/> an integrated development environment, and can be used to develop applications in Java. It can be downloaded from <a class="calibre1" href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a>. As of today, the latest IDE version<a id="id12" class="calibre1"/> is KEPLER (4.3).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre9">Since 2006, Eclipse releases a project annually. It started with the name <span class="strong"><strong class="calibre10">Callisto</strong></span> (starts with a C). Lexicographically, Eclipse project names go like C, E, G, H, I, J, K, and L.</p><p class="calibre9">In 2014, they will release the <span class="strong"><strong class="calibre10">Luna</strong></span><a id="id13" class="calibre1"/> (which starts with L) version. Between 2006 and now, they released <span class="strong"><strong class="calibre10">Europa</strong></span><a id="id14" class="calibre1"/> (E), <span class="strong"><strong class="calibre10">Ganymede</strong></span> <a id="id15" class="calibre1"/>(G), <span class="strong"><strong class="calibre10">Galileo</strong></span><a id="id16" class="calibre1"/> (G), <span class="strong"><strong class="calibre10">Helios</strong></span><a id="id17" class="calibre1"/> (H), <span class="strong"><strong class="calibre10">Indigo</strong></span> <a id="id18" class="calibre1"/>(I), <span class="strong"><strong class="calibre10">Juno</strong></span><a id="id19" class="calibre1"/> (J), and <span class="strong"><strong class="calibre10">Kepler</strong></span> (K).</p></div><p class="calibre9">In the following section, we will set up Eclipse and execute our first JUnit test.</p></div>

<div class="book" title="Working with JUnit 4">
<div class="book" title="Setting up Eclipse"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Setting up Eclipse</h2></div></div></div><p class="calibre9">You can skip this section if you know how to install Eclipse and add JUnit JAR to the <code class="literal">classpath</code> project. The following <a id="id20" class="calibre1"/>are the steps to set up Eclipse:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Visit <a class="calibre1" href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a>. From the dropdown, select the operating system—<span class="strong"><strong class="calibre10">Windows</strong></span>, <span class="strong"><strong class="calibre10">Mac</strong></span>, or <span class="strong"><strong class="calibre10">Linux</strong></span>—and then click on the hardware architecture <a id="id21" class="calibre1"/>hyperlink, that is, <span class="strong"><strong class="calibre10">32 Bit</strong></span> or <span class="strong"><strong class="calibre10">64 Bit</strong></span>, and download the binary, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00002.jpeg" alt="Setting up Eclipse" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">Extract the binary and launch Eclipse, for example, click on <code class="literal">Eclipse.exe</code> in Windows to launch Eclipse.</li><li class="listitem" value="3">Create a new workspace (for example, in Windows, enter <code class="literal">C:\dev\junit</code> or in Linux or Mac enter <code class="literal">/user/local/junit</code>; Eclipse will create the directories). Once the <a id="id22" class="calibre1"/>workspace is open, press <span class="strong"><em class="calibre11">Ctrl</em></span> + <span class="strong"><em class="calibre11">N</em></span> or navigate to <span class="strong"><strong class="calibre10">File</strong></span> | <span class="strong"><strong class="calibre10">New</strong></span>; it will open a wizard. Select <span class="strong"><strong class="calibre10">Java Project</strong></span> and click on <span class="strong"><strong class="calibre10">Next</strong></span>. Enter <code class="literal">JUnitTests</code> as the project name and click on <span class="strong"><strong class="calibre10">Finish</strong></span>. This will create a Java project named <code class="literal">JUnitTests</code>.</li><li class="listitem" value="4">Download the <code class="literal">junit.jar</code> and <code class="literal">hamcrest-core.jar</code> packages from <a class="calibre1" href="https://github.com/junit-team/junit/wiki/Download-and-Install">https://github.com/junit-team/junit/wiki/Download-and-Install</a> and copy the jars to the <code class="literal">JUnitTests</code> project folder.</li><li class="listitem" value="5">You can add the JAR to the <code class="literal">classpath</code> project in two ways; either right-click on both JAR, select <span class="strong"><strong class="calibre10">Build Path</strong></span>, and then click on <span class="strong"><strong class="calibre10">Add to build path</strong></span>. Or, right-click on the project <a id="id23" class="calibre1"/>and select the <span class="strong"><strong class="calibre10">Properties</strong></span> menu item. Click on <span class="strong"><strong class="calibre10">Java build path</strong></span> on the left-hand side and open the <span class="strong"><strong class="calibre10">Libraries</strong></span> tab. Then, click on the <span class="strong"><strong class="calibre10">Add JARs...</strong></span> button, and it will open a pop-up window. Expand the <span class="strong"><strong class="calibre10">JUnitTests</strong></span> project from the pop up, select the two JAR (<code class="literal">junit.jar</code> and <code class="literal">hamcrest-core.jar</code>), and add them to <span class="strong"><strong class="calibre10">Libraries</strong></span>. We are now ready with the Eclipse setup.</li></ol><div class="calibre17"/></div></div></div>

<div class="book" title="Working with JUnit 4">
<div class="book" title="Running the first unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Running the first unit test</h2></div></div></div><p class="calibre9">JUnit 4 is an annotation-based framework. It doesn't force you to extend the <code class="literal">TestCase</code> class. Any Java class can <a id="id24" class="calibre1"/>act as a test. In this section, we will uncover the JUnit 4 annotations, assertions, and exceptions.</p><p class="calibre9">We will examine the annotations before writing our first test.</p><div class="book" title="Exploring annotations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Exploring annotations</h3></div></div></div><p class="calibre9">The <code class="literal">@Test</code> annotation<a id="id25" class="calibre1"/> represents a test. Any <code class="literal">public</code> method can be annotated with the<code class="literal">@Test</code> annotation with <code class="literal">@Test</code> to make it a test method. There's no need to start the method name with test.</p><p class="calibre9">We need data to verify a piece of code. For example, if a method takes a list of students and sorts them based on the marks obtained, then we have to build a list of students to test the method. This is called data setup. To perform the data setup, JUnit 3 defines a <code class="literal">setUp()</code>method in the <code class="literal">TestCase</code> class. A test class can override the <code class="literal">setUp()</code> method. The method signature is as follows:</p><div class="informalexample"><pre class="programlisting">protected void setUp() throws Exception</pre></div><p class="calibre9">JUnit 4 provides a <code class="literal">@Before</code> annotation. If we annotate any <code class="literal">public void</code> method of any name with <a id="id26" class="calibre1"/>
<code class="literal">@Before</code>, then that method gets executed before every test execution.</p><p class="calibre9">Similarly, any method annotated with <code class="literal">@After</code> gets executed after each test method execution. JUnit 3 has a <code class="literal">tearDown()</code> method for this purpose.</p><p class="calibre9">JUnit 4 provides two more annotations: <code class="literal">@BeforeClass</code><a id="id27" class="calibre1"/> and <a id="id28" class="calibre1"/>
<code class="literal">@AfterClass</code>. They are executed only once per test class. The <code class="literal">@BeforeClass</code> and <code class="literal">@AfterClass</code> annotations can be used with any public static void methods. The <code class="literal">@BeforeClass</code> annotation<a id="id29" class="calibre1"/> is executed before the first test and<a id="id30" class="calibre1"/> the <code class="literal">@AfterClass</code> annotation is executed after the last test. The following example explains the annotation usage and the execution sequence of the annotated methods.</p><p class="calibre9">Let's write our first test by<a id="id31" class="calibre1"/> performing the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We will create a test class under a test source package. Create a <span class="strong"><strong class="calibre10">Source folder</strong></span> named <code class="literal">test</code> and create a <code class="literal">SanityTest.java</code> Java class under package <code class="literal">com.packtpub.junit.recap</code>.<div class="mediaobject"><img src="../images/00003.jpeg" alt="Exploring annotations" class="calibre12"/></div><p class="calibre16"> </p><p class="calibre15">It is a good practice to create test classes with a <code class="literal">Test</code> suffix. So, a <code class="literal">MyClass</code> class will have a <code class="literal">MyClassTest</code> test class. Some code coverage tools ignore tests if they don't end with a <code class="literal">Test</code> suffix.</p></li><li class="listitem" value="2">Add the following <a id="id32" class="calibre1"/>code to the <code class="literal">SanityTest</code> class:<div class="informalexample"><pre class="programlisting">import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class SanityTest {
  
  @BeforeClass
  <span class="strong"><strong class="calibre10">public static void beforeClass() {</strong></span>
    <span class="strong"><strong class="calibre10">System.out.println("***Before Class is invoked");</strong></span>
  }

  @Before
  public void before() {
    System.out.println("____________________");
    System.out.println("\t Before is invoked");
  }
  @After
  public void after() {
    System.out.println("\t After is invoked");
    System.out.println("=================");
  }
  
  @Test
  public void someTest() {
    System.out.println("\t\t someTest is invoked");
  }
  
  @Test
  public void someTest2() {
    System.out.println("\t\t someTest2 is invoked");
  }
  
  
  @AfterClass
  <span class="strong"><strong class="calibre10">public static void afterClass() {</strong></span>
    <span class="strong"><strong class="calibre10">System.out.println("***After Class is invoked");</strong></span>
  }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre9">
<span class="strong"><strong class="calibre10">Downloading the example code</strong></span>
</p><p class="calibre9">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre15">In the preceding class, we created<a id="id33" class="calibre1"/> six methods. Two test methods are annotated with <code class="literal">@Test</code>. Note that two methods (<code class="literal">beforeClass</code> and <code class="literal">afterClass</code>) are <code class="literal">static</code> and the other four are nonstatic. A static method annotated with <code class="literal">@BeforeClass</code> is invoked only once, that is, before the test class is instantiated, and <code class="literal">@AfterClass</code> is invoked after the class is done with all the execution.</p></li><li class="listitem" value="3">Run the test. Press <span class="strong"><em class="calibre11">Alt</em></span> + <span class="strong"><em class="calibre11">Shift</em></span> + <span class="strong"><em class="calibre11">X</em></span> and <span class="strong"><em class="calibre11">T</em></span> or navigate to <span class="strong"><strong class="calibre10">Run</strong></span> | <span class="strong"><strong class="calibre10">Run As</strong></span> | <span class="strong"><strong class="calibre10">JUnit Test</strong></span>. You will see the following console (<code class="literal">System.out.println</code>) output:<div class="mediaobject"><img src="../images/00004.jpeg" alt="Exploring annotations" class="calibre12"/></div><p class="calibre16"> </p><p class="calibre15">Check whether the <code class="literal">before</code> and <code class="literal">after</code> methods are executed before and after every test run. However, the order of the test method execution may vary. In some runs, <code class="literal">someTest</code> may be executed before <code class="literal">someTest2</code> or vice versa. The <code class="literal">afterClass</code> and <code class="literal">beforeClass</code> methods are executed only once.</p></li></ol><div class="calibre17"/></div><p class="calibre9">Congratulations! We successfully<a id="id34" class="calibre1"/> ran our first JUnit 4 test.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre9">
<code class="literal">@Before</code> and <code class="literal">@After</code> can be applied to any <code class="literal">public void</code> methods. <code class="literal">@AfterClass</code> and <code class="literal">@BeforeClass</code> can be applied to only <code class="literal">public static void</code> methods.</p></div></div><div class="book" title="Verifying test conditions with Assertion"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Verifying test conditions with Assertion</h3></div></div></div><p class="calibre9">Assertion is a tool (a predicate) used to <a id="id35" class="calibre1"/>verify a programming assumption (expectation) with an actual outcome of a<a id="id36" class="calibre1"/> program implementation; for example, a programmer can expect that the addition of two positive numbers will result in a positive number. So, he or she can write a program to add two numbers and assert the expected result with the actual result.</p><p class="calibre9">The <code class="literal">org.junit.Assert</code> package provides static overloaded methods to assert expected and actual values for all primitive types, objects, and arrays.</p><p class="calibre9">The following are the useful assert methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">assertTrue(condition)</code><a id="id37" class="calibre1"/> or <code class="literal">assertTrue(failure message, condition)</code>: If the <a id="id38" class="calibre1"/>condition becomes false, the assertion fails and <code class="literal">AssertionError</code> is thrown. When a failure message is passed, the failure message is thrown.</li><li class="listitem"><code class="literal">assertFalse(condition)</code> or <code class="literal">assertFalse(failure message, condition)</code>: If the<a id="id39" class="calibre1"/> condition becomes true, the <a id="id40" class="calibre1"/>assertion fails and <code class="literal">AssertionError</code> is thrown.</li><li class="listitem"><code class="literal">assertNull</code>: This checks whether the object<a id="id41" class="calibre1"/> is null, otherwise throws <code class="literal">AssertionError</code> if the argument is not null.</li><li class="listitem"><code class="literal">assertNotNull</code>: This checks whether<a id="id42" class="calibre1"/> the argument is not null; otherwise, it throws <code class="literal">AssertionError</code>.</li><li class="listitem"><code class="literal">assertEquals(string message, object expected, object actual)</code>, or <code class="literal">assertEquals(object expected, object actual)</code>, or <code class="literal">assertEquals(primitive expected, primitive actual)</code>: This method exhibits an<a id="id43" class="calibre1"/> interesting <a id="id44" class="calibre1"/>behavior if primitive values are passed and then the values are compared. If objects are<a id="id45" class="calibre1"/> passed, then the <code class="literal">equals()</code> method is invoked. Moreover, if the actual value doesn't match the expected value, <code class="literal">AssertionError</code> is thrown.</li><li class="listitem"><code class="literal">assertSame(object expected, object actual)</code>: This supports only objects and checks the object <a id="id46" class="calibre1"/>reference using the == operator. If two different objects are passed, then <code class="literal">AssertionError</code> is thrown.</li><li class="listitem"><code class="literal">assertNotSame</code>: This is just the opposite <a id="id47" class="calibre1"/>of <code class="literal">assertSame</code>. It fails <a id="id48" class="calibre1"/>when the two argument references are the same.<div class="note" title="Note"><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre9">Sometimes <code class="literal">double</code> can lead to surprising results due to the representation that Java uses to store doubles. Any operation on a double value can lead to an unexpected result. Assert doesn't rely on double comparison; so, <code class="literal">assertEquals(double expected, double actual)</code> is deprecated.</p><p class="calibre9">Declare a <code class="literal">double</code> variable <code class="literal">sum = .999+ .98</code>. The <code class="literal">sum</code> variable should add the values and store 1.98, but when you print the value in your machine, you will get <code class="literal">1.9889999999999999</code> as the output. So, if you assert <code class="literal">sum</code> with a <code class="literal">double</code> value 1.98, the test will fail.</p><p class="calibre9">The <code class="literal">assert</code> method provides an overloaded method for the <code class="literal">double</code> value assertion, that is, <code class="literal">assertEquals(double expected, double actual, double delta)</code>. During comparison, if the difference between the expected and the actual value is less than the delta value, the result is considered passed.</p><p class="calibre9">For monetary calculations, it is recommended to use <code class="literal">BigDecimal</code> instead of doubles.</p></div></li></ul></div><p class="calibre9">We will use<a id="id49" class="calibre1"/> the <code class="literal">assert</code> methods in the test <a id="id50" class="calibre1"/>as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a <code class="literal">AssertTest</code> test class under <code class="literal">com.packtpub.junit.recap</code>. Add the following lines to the class:<div class="informalexample"><pre class="programlisting">package com.packtpub.junit.recap;

import org.junit.Assert;
import org.junit.Test;

public class AssertTest {

  @Test
  public void assertTrueAndFalseTest() throws Exception {
    Assert.assertTrue(true);
    Assert.assertFalse(false);
  }
  
  @Test
  public void assertNullAndNotNullTest() throws Exception {
    Object myObject = null;
    Assert.assertNull(myObject);
    
    myObject = new String("Some value");
    Assert.assertNotNull(myObject);
  }
}</pre></div><p class="calibre15">In the preceding code, <code class="literal">assertTrueAndFalseTest</code> sends <code class="literal">true</code> to <code class="literal">assertTrue</code> and <code class="literal">false</code> to <code class="literal">assertFalse</code>. So, the test should not fail.</p><p class="calibre15">In <code class="literal">assertNullAndNotNullTest</code>, we are passing <code class="literal">null</code> to <code class="literal">assertNull</code> and a non-null <code class="literal">String</code> to <code class="literal">assertNotNull</code>; so, this test should not fail.</p><p class="calibre15">Run the tests. They should be green.</p></li><li class="listitem" value="2">We will examine <code class="literal">assertEquals</code> and add the following test and static<a id="id51" class="calibre1"/> import the <code class="literal">assertEquals</code> method:<div class="informalexample"><pre class="programlisting">  import static org.junit.Assert.<span class="strong"><strong class="calibre10">assertEquals</strong></span>;

  @Test
  public void assertEqualsTest() throws Exception {
    Integer i = new Integer("5");
    Integer j = new Integer("5");;
    assertEquals(i,j);
  }</pre></div><p class="calibre15">In the preceding code, we defined two <code class="literal">Integer</code> objects, <code class="literal">i</code> and <code class="literal">j</code>, and they are initialized with 5. Now, when we pass them to <code class="literal">assertEquals</code>, the test passes, as the <code class="literal">assertEquals</code> method calls <code class="literal">i.equals(j)</code> and not <code class="literal">i == j</code>. Hence, only the values are compared, not the references.</p><p class="calibre15">The <code class="literal">assertEquals</code> method works on all primitive types and objects. To verify a double value, either use the overloaded <code class="literal">assertEquals(actual, expected, delta)</code> method or just use <code class="literal">BigDecimal</code> instead of using <code class="literal">Double</code>.</p></li><li class="listitem" value="3">Add a test to verify<a id="id52" class="calibre1"/> the <code class="literal">assertNotSame</code> behavior and static import the <a id="id53" class="calibre1"/><code class="literal">assertNotSame</code> method:<div class="informalexample"><pre class="programlisting">   import static org.junit.Assert.<span class="strong"><strong class="calibre10">assertNotSame</strong></span>;
  @Test
  public void assertNotSameTest() throws Exception {
    Integer i = new Integer("5");
    Integer j = new Integer("5");;
    assertNotSame(i , j);
  }</pre></div><p class="calibre15">The <code class="literal">assertNotSame</code> method fails only when the expected object and the actual object refers to the same memory location. Here, <code class="literal">i</code> and <code class="literal">j</code> hold the same value but the memory references are different.</p></li><li class="listitem" value="4">Add a test to verify the <code class="literal">assertSame</code> behavior and static import the <code class="literal">assertSame</code> method:<div class="informalexample"><pre class="programlisting">  import static org.junit.Assert.<span class="strong"><strong class="calibre10">assertSame</strong></span>;
  @Test
  public void assertSameTest() throws Exception {
    Integer i = new Integer("5");
    Integer j = i;
    assertSame(i,j);
  }</pre></div><p class="calibre15">The <code class="literal">assertSame</code> method passes only when the expected object and the actual object refer to the same memory location. Here, <code class="literal">i</code> and <code class="literal">j</code> hold the same value and refer to the same location.</p></li></ol><div class="calibre17"/></div></div></div></div>

<div class="book" title="Working with JUnit 4">
<div class="book" title="Working with exception handling"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>Working with exception handling</h2></div></div></div><p class="calibre9">To test an error condition, exception handling feature is important. For example, an API needs three objects; if any<a id="id54" class="calibre1"/> argument is null, then the API should throw an exception. This can be easily tested. If the API doesn't throw an exception, the test will fail.</p><p class="calibre9">The <code class="literal">@Test</code> annotation takes the <code class="literal">expected=&lt;&lt;Exception class name&gt;&gt;.class</code> argument.</p><p class="calibre9">If the expected exception class <a id="id55" class="calibre1"/>doesn't match the exception thrown from the code, the test fails. Consider the following code:</p><div class="informalexample"><pre class="programlisting">      @Test(expected=RuntimeException.class)
  public void exception() {
    throw new RuntimeException();
  }</pre></div><p class="calibre9">This is only one solution. There are several other methods that are generally considered to be better solutions. Utilizing <code class="literal">@Rule</code> in JUnit 4.8+ and assigning <code class="literal">ExpectedException</code> is a stronger solution because you can inspect the message as well as the type. We have covered <code class="literal">@Rule</code> in the <span class="strong"><em class="calibre11">Working with JUnit 4++ section</em></span> of this chapter.</p></div></div>

<div class="book" title="Working with JUnit 4">
<div class="book" title="Exploring the @RunWith annotation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec10" class="calibre1"/>Exploring the @RunWith annotation</h2></div></div></div><p class="calibre9">Test runners execute the JUnit tests. Eclipse has a built-in native graphical runner. JUnit 4 provides tools to define the suite to be run and to display its results.</p><p class="calibre9">When a class is annotated with <code class="literal">@RunWith</code> or the class extends a class annotated with <code class="literal">@RunWith</code>, JUnit will invoke the<a id="id56" class="calibre1"/> class that it references to run the tests on that class, instead of using the built-in runner. The <code class="literal">@RunWith</code> annotation is used to change the nature of the test class. It can be used to run a test as a parameterized test or even a Spring test, or it can be a Mockito runner to initialize the mock objects annotated with a <code class="literal">@Mock</code> annotation.</p><p class="calibre9">The <code class="literal">@RunWith</code> annotation<a id="id57" class="calibre1"/> takes an argument. The argument must be a class extended from <code class="literal">org.junit.runner.Runner</code>.</p><p class="calibre9">
<code class="literal">JUnit4.class</code> is an example of a runner. This class aliases the current default JUnit 4 class runner.</p><p class="calibre9">
<code class="literal">Suite</code> is a standard runner that allows us to build a suite that contains tests from many packages. The following is an example of <code class="literal">@RunWith</code>:</p><div class="informalexample"><pre class="programlisting">@RunWith(Suite.class)
public class Assumption {
   
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with JUnit 4++"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Working with JUnit 4++</h1></div></div></div><p class="calibre9">This section explores the advanced features of the JUnit 4 framework and includes the following topics: parameterized test, Hamcrest matchers and assertThat, assumption, theory, timeout, categories, rules, test suites, and tests order.</p></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Ignoring a test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec11" class="calibre1"/>Ignoring a test</h2></div></div></div><p class="calibre9">Suppose a failing test blocks you to check-in a mission critical code, and you come to know that the owner of the code is on a vacation. What do you do? You try to fix the test or just comment out or delete<a id="id58" class="calibre1"/> the test to proceed with your check-in (committing files to a source control such as SVN), or you wait until the test is fixed.</p><p class="calibre9">Sometimes we comment out tests<a id="id59" class="calibre1"/> because the feature is not developed. JUnit came up with a solution for this. Instead of commenting a test, we can just ignore it by annotating the test method with <code class="literal">@Ignore</code>. Commenting out a test or code is bad as it does nothing but increases the code size and reduces its readability. Also, when you comment out a test, then the test report doesn't tell you anything about the commented-out test; however, if you ignore a test, then the test report will tell you that something needs to be fixed as some tests are ignored. So, you can keep track of the ignored test.</p><p class="calibre9">Use <code class="literal">@Ignore("Reason: why do you want to ignore?")</code>. Giving a proper description explains the intention behind ignoring the test. The following is an example of, where a test method is ignored <a id="id60" class="calibre1"/>because the holiday calculation is not<a id="id61" class="calibre1"/> working:</p><div class="informalexample"><pre class="programlisting">@Test
@Ignore("John's holiday stuff failing")
public void when_today_is_holiday_then_stop_alarm() {
}</pre></div><p class="calibre9">The following is a screenshot from Eclipse:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Ignoring a test" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">You can place the <code class="literal">@Ignore</code> annotation on a test class, effectively ignoring all the contained tests.</p></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Executing tests in order"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec12" class="calibre1"/>Executing tests in order</h2></div></div></div><p class="calibre9">JUnit was designed to allow execution in a random order, but typically they are executed in a linear fashion and the order is not guaranteed. The JUnit runner depends on reflection to execute the tests. Usually, the test execution order doesn't vary from run to run; actually, the randomness<a id="id62" class="calibre1"/> is environment-specific and varies from JVM to JVM. So, it's better that you never assume they'll be executed in the same order and depend on other tests, but sometimes we need to depend on the order.</p><p class="calibre9">For example, when you<a id="id63" class="calibre1"/> want to write slow tests to insert a row into a database, then first update the row and finally delete the row. Here, unless the insert function is executed, delete or update functions cannot run.</p><p class="calibre9">JUnit 4.11 provides us with an <code class="literal">@FixMethodOrder</code> annotation to specify the execution order. It takes <code class="literal">enum MethodSorters</code>.</p><p class="calibre9">To change the execution order, annotate<a id="id64" class="calibre1"/> your test<a id="id65" class="calibre1"/> class using <code class="literal">@FixMethodOrder</code> and specify one of the following available <code class="literal">enum MethodSorters</code> constant:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">MethodSorters.JVM</code>: This leaves the test<a id="id66" class="calibre1"/> methods in the order returned by the JVM. This order may vary from run to run.</li><li class="listitem"><code class="literal">MethodSorters.NAME_ASCENDING</code>: This sorts the<a id="id67" class="calibre1"/> test methods by the method name in the lexicographic order.</li><li class="listitem"><code class="literal">MethodSorters.DEFAULT</code>: This is the default <a id="id68" class="calibre1"/>value that doesn't guarantee the execution order.</li></ul></div><p class="calibre9">We will write a few tests to verify this behavior.</p><p class="calibre9">Add a <code class="literal">TestExecutionOrder</code> test and create tests, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public class TestExecutionOrder {
  @Test   public void edit() throws Exception {
    System.out.println("edit executed");
  }
  @Test   public void create() throws Exception {
    System.out.println("create executed");
  }
  @Test   public void remove() throws Exception {
    System.out.println("remove executed");
  }  
}</pre></div><p class="calibre9">Run the tests. The execution order may vary, but if we annotate the class with <code class="literal">@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code>, the tests will be executed in the ascending order as follows:</p><div class="informalexample"><pre class="programlisting">@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class TestExecutionOrder { … }</pre></div><p class="calibre9">The following Eclipse screenshot displays the test execution in the ascending order:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Executing tests in order" class="calibre12"/></div><p class="calibre13"> </p></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Learning assumptions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec13" class="calibre1"/>Learning assumptions</h2></div></div></div><p class="calibre9">In multisite projects, sporadically, a date or time zone tests fail in a local CI server but run fine in other servers in a different time zone. We can choose to not run those automatic tests in our local server.</p><p class="calibre9">Sometimes our tests fail<a id="id69" class="calibre1"/> due to a bug in a third-party code or external software, but we know that after some specific build or version, the bug will be fixed. Should we comment out the code and wait until the build is available?</p><p class="calibre9">In many projects, <span class="strong"><strong class="calibre10">Jenkins</strong></span> <a id="id70" class="calibre1"/>(for test automation) and <span class="strong"><strong class="calibre10">SONAR</strong></span> <a id="id71" class="calibre1"/>(for code-quality metrics) run in a server. It has been observed that due to low resources, the automatic tests run forever when SONAR is processing and the tests run simultaneously.</p><p class="calibre9">JUnit has the answer to all these issues. It recommends using an <code class="literal">org.junit.Assume</code> class.</p><p class="calibre9">Like <code class="literal">Assert</code>, <code class="literal">Assume</code> offers many static methods, such as <code class="literal">assumeTrue(condition)</code>, <code class="literal">assumeFalse(condition)</code>, <code class="literal">assumeNotNull(condition)</code>, and <code class="literal">assumeThat(condition)</code>. Before executing a test, we can check our assumption using the <code class="literal">assumeXXX</code> methods. If our assumption fails, then the <code class="literal">assumeXXX</code> methods throw <code class="literal">AssumptionViolatedException</code>, and the JUnit runner ignores the tests with failing assumptions.</p><p class="calibre9">So, basically, if our assumption is not true, the tests are just ignored. We can assume that the tests are run in the EST time zone; if the tests are run somewhere else, they will be ignored automatically. Similarly, we can assume that the third-party code version is higher than the build/version 123; if the build version is lower, the tests will be ignored.</p><p class="calibre9">Let's write the code to validate our assumption about <code class="literal">Assume</code>.</p><p class="calibre9">Here, we will try to solve the SONAR server issue. We will assume that SONAR is not running. If SONAR runs during the test execution, the assumption will fail and the tests will be ignored.</p><p class="calibre9">Create an <code class="literal">Assumption</code> test class. The following is the body of the class:</p><div class="informalexample"><pre class="programlisting">public class Assumption {
   
  boolean isSonarRunning = false;
  @Test 
  public void very_critical_test() throws Exception {
    isSonarRunning = true;
    Assume.assumeFalse(isSonarRunning);
    assertTrue(true);
  }
  
}</pre></div><p class="calibre9">Here, for simplicity, we added a <code class="literal">isSonarRunning</code> variable to replicate a SONAR server facade. In the actual code, we can call an API to get the value. We will set the variable to <code class="literal">false</code>. Then, in the test, we will<a id="id72" class="calibre1"/> reset the value to <code class="literal">true</code>. This means SONAR is running. So, our assumption that SONAR is not running is false; hence, the test will be ignored.</p><p class="calibre9">The following screenshot shows that the test is ignored. We didn't annotate the test using <code class="literal">@Ignore</code>:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Learning assumptions" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">When we change the value of the <code class="literal">isSonarRunning</code> variable to <code class="literal">false,</code> as given in the following code snippet, the test will be executed:</p><div class="informalexample"><pre class="programlisting">public void very_critical_test() throws Exception {
    isSonarRunning = false;
    Assume.assumeFalse(isSonarRunning);
    assertTrue(true);
}</pre></div><p class="calibre9">Continuous integration tools such as Jenkins can run multiple tools such as Sonar to acquire code-quality metrics. It's always a good practice to have a build pipeline where the code quality is only checked after the tests pass. This prevents the CPU-intensive tasks from occurring at the same time.</p><p class="calibre9">Assumption is also<a id="id73" class="calibre1"/> used in the <code class="literal">@Before</code> methods, but be careful not to overuse it. Assumption is good for use with TDD where one writes pretests ahead of time.</p></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Exploring the test suite"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec14" class="calibre1"/>Exploring the test suite</h2></div></div></div><p class="calibre9">To run multiple test cases, JUnit 4 provides <code class="literal">Suite.class</code> and the <code class="literal">@Suite.SuiteClasses</code> annotation. This annotation<a id="id74" class="calibre1"/> takes an array (comma separated) of test classes.</p><p class="calibre9">Create a <code class="literal">TestSuite</code> class and annotate<a id="id75" class="calibre1"/> the class with <code class="literal">@RunWith(Suite.class)</code>. This annotation will force Eclipse to use the suite runner.</p><p class="calibre9">Next, annotate the class with <code class="literal">@Suite.SuiteClasses({ AssertTest.class, TestExecutionOrder.class, Assumption.class })</code> and pass comma-separated test class names.</p><p class="calibre9">The following is the code snippet:</p><div class="informalexample"><pre class="programlisting">import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ AssertTest.class, TestExecutionOrder.class,Assumption.class })
public class TestSuite {

}</pre></div><p class="calibre9">During execution, the suite will execute all the tests. The following is a screenshot of the suite run. Check whether it runs seven tests out of the three test fixtures: <code class="literal">AssertTest</code>, <code class="literal">TestExecutionOrder</code>, and <code class="literal">Assumption</code>.</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Exploring the test suite" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">A test suite is created for group-related tests such as a group of data access, API usage tests, or a group of<a id="id76" class="calibre1"/> input validation<a id="id77" class="calibre1"/> logic tests.</p></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Asserting with assertThat"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec15" class="calibre1"/>Asserting with assertThat</h2></div></div></div><p class="calibre9">Joe Walnes created the <code class="literal">assertThat(Object actual, Matcher matcher)</code> method. General consensus is that <code class="literal">assertThat</code> is readable and more useful than <code class="literal">assertEquals</code>. The syntax of the <code class="literal">assertThat</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">  public static void assertThat(Object actual, Matcher matcher</pre></div><p class="calibre9">Here, <code class="literal">Object</code> is the actual value received and <code class="literal">Matcher</code> is an implementation of the <code class="literal">org.hamcrest.Matcher</code> interface. This interface comes from a separate library called <code class="literal">hamcrest.jar</code>.</p><p class="calibre9">A matcher enables a partial or an exact match for an expectation, whereas <code class="literal">assertEquals</code> uses an exact match. <code class="literal">Matcher</code> provides utility methods such as <code class="literal">is</code>, <code class="literal">either</code>, <code class="literal">or</code>, <code class="literal">not</code> , and <code class="literal">hasItem</code>. The <code class="literal">Matcher</code> methods use the <span class="strong"><strong class="calibre10">builder pattern</strong></span><a id="id78" class="calibre1"/> so that we can combine one or more matchers to build a composite matcher chain. Just like <code class="literal">StringBuilder</code>, it builds a string in multiple steps.</p><p class="calibre9">The following are a few <a id="id79" class="calibre1"/>examples of matchers and <code class="literal">assertThat</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">assertThat(calculatedTax, is(not(thirtyPercent)) );</code></li><li class="listitem"><code class="literal">assertThat(phdStudentList, hasItem(DrJohn) );</code></li><li class="listitem"><code class="literal">assertThat(manchesterUnitedClub, both( is(EPL_Champion)).and(is(UEFA_Champions_League_Champion)) );</code></li></ul></div><p class="calibre9">The preceding examples are more English than a JUnit test code. So, anyone can understand the intent of the code and test, and a matcher improves readability.</p><p class="calibre9">Hamcrest provides a utility matcher class called <code class="literal">org.hamcrest.CoreMatchers</code>.</p><p class="calibre9">A few utility methods of <code class="literal">CoreMatchers</code> are <code class="literal">allOf</code>, <code class="literal">anyOf</code>, <code class="literal">both</code>, <code class="literal">either</code>, <code class="literal">describedAs</code>, <code class="literal">everyItem</code>, <code class="literal">is</code>, <code class="literal">isA</code>, <code class="literal">anything</code>, <code class="literal">hasItem</code>, <code class="literal">hasItems</code>, <code class="literal">equalTo</code>, <code class="literal">any</code>, <code class="literal">instanceOf</code>, <code class="literal">not</code>, <code class="literal">nullValue</code>, <code class="literal">notNullValue</code>, <code class="literal">sameInstance</code>, <code class="literal">theInstance</code> ,<code class="literal">startsWith</code>, <code class="literal">endsWith</code>, and <code class="literal">containsString</code>. All these methods return a matcher.</p><p class="calibre9">We worked with <code class="literal">assertEquals</code>; so, let's start with <code class="literal">equalTo</code>. The <code class="literal">equalTo</code> method is equivalent to <code class="literal">assertEquals</code>.</p><div class="book" title="Comparing matchers – equalTo, is, and not"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Comparing matchers – equalTo, is, and not</h3></div></div></div><p class="calibre9">Create a <code class="literal">AssertThatTest.java</code> JUnit test and static import <code class="literal">org.hamcrest.CoreMatchers.*;</code> as follows:</p><div class="informalexample"><pre class="programlisting">import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

import org.junit.Test;

public class AssertThatTest {

  @Test
  public void verify_Matcher() throws Exception {
    int age = 30;
    assertThat(age, equalTo(30));
    assertThat(age, is(30));
    
    assertThat(age, not(equalTo(33)));
    assertThat(age, is(not(33)));
  }
}</pre></div><p class="calibre9">Set the <code class="literal">age</code> variable to <code class="literal">30</code> and then likewise for <code class="literal">assertEquals</code> and call <code class="literal">equalTo</code>, which here is <code class="literal">Matcher</code>. The <code class="literal">equalTo</code> method <a id="id80" class="calibre1"/>takes a value. If the <code class="literal">Matcher</code> value doesn't match the actual value, then <code class="literal">assertThat</code> throws an <code class="literal">AssertionError</code> exception.</p><p class="calibre9">Set the <code class="literal">age</code> variable value to <code class="literal">29</code> and rerun the test. The following error will occur:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Comparing matchers – equalTo, is, and not" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The <code class="literal">is(a)</code> attribute takes a value and returns a Boolean and behaves similar to <code class="literal">equalTo(a)</code>. The <code class="literal">is(a)</code> attribute is the same as <code class="literal">is(equalTo(a))</code>.</p><p class="calibre9">The <code class="literal">not</code> attribute takes a<a id="id81" class="calibre1"/> value or a matcher. In the preceding code, we used <code class="literal">assertThat(age, is(not(33)));</code>. This expression is nothing but <code class="literal">age is not 33</code> and is more readable than the <code class="literal">assert</code> methods.</p></div><div class="book" title="Working with compound value matchers – either, both, anyOf, allOf, and not"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>Working with compound value matchers – either, both, anyOf, allOf, and not</h3></div></div></div><p class="calibre9">In this section, we will use <code class="literal">either</code>, <code class="literal">both</code>, <code class="literal">anyOf</code>, <code class="literal">allOf</code>, and <code class="literal">not</code>. Add the following test to the <code class="literal">AssertThatTest.java</code> file:</p><div class="informalexample"><pre class="programlisting">@Test
  public void verify_multiple_values() throws Exception {
        
    double marks = 100.00;
    assertThat(marks, either(is(100.00)).or(is(90.9)));
    
    assertThat(marks, both(not(99.99)).and(not(60.00)));
    
    assertThat(marks, anyOf(is(100.00),is(1.00),is(55.00),is(88.00),is(67.8)));
    
    assertThat(marks, not(anyOf(is(0.00),is(200.00))));
    
    assertThat(marks, not(allOf(is(1.00),is(100.00), is(30.00))));
  }</pre></div><p class="calibre9">In the preceding example, a <code class="literal">marks</code> double variable is initialized with a value of <code class="literal">100.00</code>. This variable value is asserted with an <code class="literal">either</code> matcher.</p><p class="calibre9">Basically, using <code class="literal">either</code>, we can compare two values against an actual or calculated value. If any of them match, then the assertion is passed. If none of them match, then <code class="literal">AssertionError</code> is thrown.</p><p class="calibre9">The <code class="literal">either(Matcher)</code> method<a id="id82" class="calibre1"/> takes a matcher and returns a <code class="literal">CombinableEitherMatcher</code> class. The <code class="literal">CombinableEitherMatcher</code> class has a <code class="literal">or(Matcher other)</code> method so that <code class="literal">either</code> and <code class="literal">or</code> can be combined.</p><p class="calibre9">The <code class="literal">or(Matcher other)</code> method is translated to <code class="literal">return (new CombinableMatcher(first)).or(other);</code> and finally to <code class="literal">new CombinableMatcher(new AnyOf(templatedListWith(other)));</code>.</p><p class="calibre9">Using <code class="literal">both</code>, we can compare two values against an actual or calculated value. If any of them don't match, then the <code class="literal">AssertionError</code> exception is thrown. If both of them match, then the assertion is passed.</p><p class="calibre9">A numeric value such as a math score cannot be equal to both 60 and 80. However, we can negate the expression. If the math score is 80, then using the <code class="literal">both</code> matcher we can write the expression as <code class="literal">assertThat (mathScore , both (not(60)). and(not (90)))</code>.</p><p class="calibre9">The <code class="literal">anyOf</code> matcher<a id="id83" class="calibre1"/> is more like <code class="literal">either</code> with multiple values. Using <code class="literal">anyOf</code>, we can compare multiple values against an actual or calculated value. If any of them match, then the assertion is passed. If none of them match, then the <code class="literal">AssertionError</code> exception is thrown.</p><p class="calibre9">The <code class="literal">allOf</code> matcher is more<a id="id84" class="calibre1"/> like <code class="literal">both</code> with multiple <a id="id85" class="calibre1"/>values. Using <code class="literal">allOf</code>, we can<a id="id86" class="calibre1"/> compare multiple values against an actual or calculated value. If any of them don't match, then the <code class="literal">AssertionError</code> exception is thrown. Similar to <code class="literal">both</code>, we can use <code class="literal">allOf</code> along with <code class="literal">not</code> to check whether a value does or doesn't belong to a set.</p><p class="calibre9">In the preceding example, using <code class="literal">allOf</code> and <code class="literal">not</code>, we checked whether the <code class="literal">marks</code> attribute is not <code class="literal">1</code>, <code class="literal">100</code>, or <code class="literal">30</code>.</p></div><div class="book" title="Working with collection matchers – hasItem and hasItems"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Working with collection matchers – hasItem and hasItems</h3></div></div></div><p class="calibre9">In the previous section, we asserted a value against multiple values. In this section, we will assert a collection of values against a value or numerous values.</p><p class="calibre9">Consider the following example. A salary list is populated with three values: <code class="literal">50.00</code>, <code class="literal">200.00</code>, and <code class="literal">500.00</code>. Use <code class="literal">hasItem</code><a id="id87" class="calibre1"/> to check whether a value exists in a collection, and use<a id="id88" class="calibre1"/> <code class="literal">hasItems</code> to check whether multiple values exist in a collection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">   @Test
  public void verify_collection_values() throws Exception {
        
    List&lt;Double&gt; salary =Arrays.asList(50.0, 200.0, 500.0);
    
    assertThat(salary, hasItem(50.00));
    assertThat(salary, hasItems(50.00, 200.00));
        assertThat(salary, not(hasItem(1.00)));
  }</pre></div><p class="calibre9">The <code class="literal">hasItem</code> matcher has two <a id="id89" class="calibre1"/>versions: one takes a value and the other takes a matcher. So, we can check a value in a collection using <code class="literal">hasItem</code>, or check whether a value doesn't exist in a collection using <code class="literal">not</code> and <code class="literal">hasItem</code>. The <code class="literal">hasItems</code> matcher<a id="id90" class="calibre1"/> operates on a set of values.</p></div><div class="book" title="Exploring string matchers – startsWith, endsWith, and containsString"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>Exploring string matchers – startsWith, endsWith, and containsString</h3></div></div></div><p class="calibre9">In this section, we will explore the string matchers. <code class="literal">CoreMatchers</code> has three built-in string matcher methods. In the following example, a <code class="literal">String</code> variable name is assigned a value and then we assert that the name starts with a specific value, contains a value, and ends with a value:</p><div class="informalexample"><pre class="programlisting">@Test
  public void verify_Strings() throws Exception {
    String name = "John Jr Dale";
    assertThat(name, startsWith("John"));
    assertThat(name, endsWith("Dale"));
    assertThat(name, containsString("Jr"));
  }</pre></div><p class="calibre9">The <code class="literal">startsWith</code> matcher operates on string only. It checks <a id="id91" class="calibre1"/>whether the string starts with the given string. The <code class="literal">endsWith</code> matcher<a id="id92" class="calibre1"/> checks whether <a id="id93" class="calibre1"/>the string ends with the given string. The <code class="literal">containsString</code> matcher <a id="id94" class="calibre1"/>checks <a id="id95" class="calibre1"/>whether the string contains another string.</p><p class="calibre9">Sometimes, a method calls to return a JSON response. Using <code class="literal">containsString</code>, a specific value can be asserted.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre9">Note that <code class="literal">startsWith</code>, <code class="literal">endsWith</code>, and <code class="literal">containsStrings</code> are not the only string matchers. Other built-in matchers such as <code class="literal">both</code>, <code class="literal">either</code>, <code class="literal">anyOf</code>, and so on, can be applied to a <code class="literal">String</code> object.</p></div></div><div class="book" title="Exploring built-in matchers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec07" class="calibre1"/>Exploring built-in matchers</h3></div></div></div><p class="calibre9">
<code class="literal">JUnitMatchers</code> has built-in matcher <a id="id96" class="calibre1"/>methods, but all of these methods are deprecated. Use Hamcrest matchers instead of using <code class="literal">JUnitMatchers</code>.</p></div><div class="book" title="Building a custom matcher"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec08" class="calibre1"/>Building a custom matcher</h3></div></div></div><p class="calibre9">We can build our own matchers to use in <code class="literal">assertThat</code>. How about building a <code class="literal">matcher</code> that will compare two <a id="id97" class="calibre1"/>values and return <code class="literal">true</code> only if the actual object is less than or equal to the expected value?</p><p class="calibre9">Call it a <code class="literal">lessThanOrEqual</code> matcher. It should be allowed to use with any object that can be compared so that we can use an <code class="literal">Integer</code> or <code class="literal">Double</code> or <code class="literal">String</code> type or any custom class that implements the <code class="literal">Comparable</code> interface.</p><p class="calibre9">For example, <code class="literal">assertThat(100, lessThanOrEqual(200))</code> should pass, but <code class="literal">assertThat(100, lessThanOrEqual(50))</code> should fail and <code class="literal">assertThat("john123", lessThanOrEqual("john123"))</code> should pass, but <code class="literal">assertThat("john123", lessThanOrEqual("john12"))</code> should fail.</p><p class="calibre9">Follow the ensuing steps to build the <code class="literal">lessThanOrEqual</code> matcher:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a <code class="literal">LessThanOrEqual</code> class under the <code class="literal">com.packtpub.junit.recap</code> package.</li><li class="listitem" value="2">To build a custom matcher, a class should implement the <code class="literal">Matcher</code> interface. However, Hamcrest recommends extending <code class="literal">org.hamcrest.BaseMatcher</code> rather than implementing the <code class="literal">Matcher</code> interface. So, we will extend <code class="literal">BaseMatcher</code>. The <code class="literal">BaseMatcher</code> class is an abstract class, and it doesn't implement <code class="literal">describeTo(Description description)</code> and <code class="literal">matches(Object t)</code>.<p class="calibre15">The <code class="literal">public boolean matches(Object obj)</code> method is invoked by <code class="literal">assertThat</code>. If this method returns <code class="literal">false</code>, then an <code class="literal">AssertionError</code> exception is thrown.</p><p class="calibre15">The <code class="literal">public void describeTo(Description description)</code> method is invoked when <code class="literal">matches(Object obj)</code> returns <code class="literal">false</code>. This method builds the description of an expectation.</p><p class="calibre15">The following code snippet explains how <code class="literal">assertThat</code> works:</p><div class="informalexample"><pre class="programlisting">  if(!matcher.matches(actual)){
         Description description = new StringDescription();
         description.appendText(reason).appendText("\nExpected: ).appendDescriptionOf(matcher).appendText("\n   but: ");
           
         matcher.describeMismatch(actual, description);
         throw new AssertionError(description.toString());
  }</pre></div><p class="calibre15">Note that when <code class="literal">matcher.matches()</code> returns <code class="literal">false</code>, the description is built from the actual value and the matcher. The <a id="id98" class="calibre1"/>
<code class="literal">appendDescriptionOf()</code> method calls<a id="id99" class="calibre1"/> the <code class="literal">describeTo()</code> method of the matcher to build the error message.</p><p class="calibre15">Finally, <code class="literal">matcher.describeMismatch(actual, description)</code> appends the string <code class="literal">but: was &lt;&lt;actual&gt;&gt;</code>.</p></li><li class="listitem" value="3">The <code class="literal">lessThanOrEqual</code> class needs to compare two objects, so the <code class="literal">Matcher</code> class should be operated on the <code class="literal">Comparable</code> objects. Create a generic class that operates with any type that implements the <code class="literal">Comparable</code> interface, as follows:<div class="informalexample"><pre class="programlisting">public class LessThanOrEqual&lt;T extends Comparable&lt;T&gt;&gt; extends BaseMatcher&lt;Comparable&lt;T&gt;&gt; {

}</pre></div></li><li class="listitem" value="4">Now we need to implement the <code class="literal">describeTo</code> and <code class="literal">matches</code> methods. The <code class="literal">assertThat</code> method will pass the actual value to the matcher's <code class="literal">matches(Object o)</code> method, and <code class="literal">lessThanOrEqual</code> will accept a value to compare with the actual. So, in the <code class="literal">matches</code> method, we need two comparable objects: one passed <a id="id100" class="calibre1"/>as a parameter and the other passed to a matcher object. The expected value is passed during the <code class="literal">matcher</code> object instantiation as follows:<div class="informalexample"><pre class="programlisting">assertThat (actual, matcher(expectedValue)).</pre></div><p class="calibre15">We will store the <code class="literal">expectedValue</code> during the <code class="literal">Matcher</code> object creation and use it in the <code class="literal">matches()</code> method to compare the <code class="literal">expectedValue</code> with the <code class="literal">actual</code> as follows:</p><div class="informalexample"><pre class="programlisting">public class LessThanOrEqual&lt;T extends Comparable&lt;T&gt;&gt; extends BaseMatcher&lt;Comparable&lt;T&gt;&gt; {
  private final Comparable&lt;T&gt; expectedValue;
  
  public LessThanOrEqual(T expectedValue) {
   this.expectedValue = expectedValue;
  }


  @Override
  public void describeTo(Description description) {
    description.appendText(" less than or equal(&lt;=) "+expectedValue);
  }


  @Override
  public boolean matches(Object t) {
    int compareTo = expectedValue.compareTo((T)t);
    return compareTo &gt; -1;
  }
}</pre></div><p class="calibre15">The preceding <code class="literal">LessThanOrEqual</code> class should return <code class="literal">true</code> only if <code class="literal">expectedValue.compareTo(actual) &gt;= 0</code> and then the <code class="literal">describeTo()</code> method appends the string <code class="literal">"less than or equals (&lt;=) "+ expectedValue</code> text to the <code class="literal">description,</code> so that if the assertion fails, then the "<code class="literal">less than or equals (&lt;=) "+ expectedValue</code> message will be shown.</p></li><li class="listitem" value="5">The <code class="literal">assertThat</code> method takes a matcher but <code class="literal">new LessThanOrEqual(expectedValue)</code> doesn't look good. We will create a <code class="literal">static</code> method in the <code class="literal">LessThanOrEqual</code> class to create a new object of <code class="literal">LessThanOrEqual</code>. Call this method from the <code class="literal">assertThat</code> method as follows:<div class="informalexample"><pre class="programlisting">  @Factory
  public static&lt;T extends Comparable&lt;T&gt;&gt;  Matcher&lt;T&gt;        
    lessThanOrEqual(T t) {
    return new LessThanOrEqual(t);
    }</pre></div><p class="calibre15">The <code class="literal">@Factory</code> annotation isn't necessary but needed for a Hamcrest tool. When we create many custom matchers, then it becomes annoying to import them all individually. Hamcrest ships with a <code class="literal">org.hamcrest.generator.config.XmlConfigurator</code> command-line tool that picks up predicates<a id="id101" class="calibre1"/> annotated with the <code class="literal">@Factory</code> annotation and collects them in a <code class="literal">Matcher</code> class for easy importing.</p></li><li class="listitem" value="6">Static import the <code class="literal">LessThanOrEqual</code> class and add a test to <code class="literal">AssertThatTest.java</code> to validate the custom matcher, as shown in the following code:<div class="informalexample"><pre class="programlisting">   @Test
  public void lessthanOrEquals_custom_matcher() throws Exception
  {
    int actualGoalScored = 2;
    assertThat(actualGoalScored, lessThanOrEqual(4));
    assertThat(actualGoalScored, lessThanOrEqual(2));
    
    double originalPI = 3.14;
    assertThat(originalPI, lessThanOrEqual(9.00));

    String authorName = "Sujoy";
    assertThat(authorName, lessThanOrEqual("Zachary"));
  }</pre></div><p class="calibre15">This test should pass.</p></li><li class="listitem" value="7">How about testing the code with a greater value? In Java, <code class="literal">Integer.MAX_VALUE</code> holds the maximum integer value and <code class="literal">Integer.MIN_VALUE</code> holds the minimum integer value. If we expect that the maximum value<a id="id102" class="calibre1"/> will be greater than or equal to the minimum value, then the assertion should fail. Consider the following code snippet:<div class="informalexample"><pre class="programlisting">    int maxInt = Integer.MAX_VALUE;
    assertThat(maxInt, lessThanOrEqual(Integer.MIN_VALUE));</pre></div><p class="calibre15">This will throw the following error:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Building a custom matcher" class="calibre12"/></div><p class="calibre16"> </p></li></ol><div class="calibre17"/></div></div></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Creating parameterized tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec16" class="calibre1"/>Creating parameterized tests</h2></div></div></div><p class="calibre9">Parameterized tests are used for multiple iterations over a single input to stress the object in test. The primary reason is to reduce the amount of test code.</p><p class="calibre9">In TDD, the code is written to satisfy a failing test. The production code logic is built from a set of test cases and different input values. For example, if we need to build a class that will return the factorial of a number, then we will pass different sets of data and verify that our implementation<a id="id103" class="calibre1"/> passes the validation.</p><p class="calibre9">We know that the factorial of 0 is 1, the factorial of 1 is 1, the factorial of 2 is 2, the factorial of 3 is 6, the factorial of 4 is 24, and so on.</p><p class="calibre9">So, if we write tests such as <code class="literal">factorial_of_1_is_1</code> and <code class="literal">factorial_of_4_is_24</code>, then the test class will be polluted very easily. How many methods will we write?</p><p class="calibre9">We can create two arrays: one with the expected values and the other with the original numbers. Then, we can loop through the arrays and assert the result. We don't have to do this because the JUnit 4 framework provides us with a similar solution. It gives us a <code class="literal">Parameterized</code> runner.</p><p class="calibre9">We read about the <code class="literal">@RunWith</code> annotation in the preceding section. <code class="literal">Parameterized</code> is a special type of runner and can be used with the <code class="literal">@RunWith</code> annotation.</p><p class="calibre9">Parameterized comes with two flavors: constructor and method.</p><div class="book" title="Working with parameterized constructors"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec09" class="calibre1"/>Working with parameterized constructors</h3></div></div></div><p class="calibre9">Perform the <a id="id104" class="calibre1"/>following steps to <a id="id105" class="calibre1"/>build a parameterized test <a id="id106" class="calibre1"/>with a constructor:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a source folder <code class="literal">src</code> and add a <code class="literal">Factorial.java</code> class under <code class="literal">src/ com.packtpub.junit.recap</code>.</li><li class="listitem" value="2">Implement the factorial algorithm. Add the following code to the <code class="literal">Factorial.java</code> class:<div class="informalexample"><pre class="programlisting">package com.packtpub.junit.recap;

public class Factorial {

  public long factorial(long number) {
    if(number == 0) {
      return 1;
    }
    
    return number*factorial(number-1);
  }
}</pre></div></li><li class="listitem" value="3">Add a <code class="literal">ParameterizedFactorialTest.java</code> test under <code class="literal">test/ com.packtpub.junit.recap</code> and annotate the class with <code class="literal">@RunWith(Parameterized.class)</code> as follows:<div class="informalexample"><pre class="programlisting">import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

@RunWith(Parameterized.class)
public class ParameterizedFactorialTest {

}</pre></div></li><li class="listitem" value="4">Add a method to create a dataset for factorial algorithm. The method should return <code class="literal">Collection</code> of the <code class="literal">Object[]</code> method. We need a collection of two dimensional arrays to hold the numbers and factorial values. To define the data parameters, annotate the method with <code class="literal">@Parameters</code>.<p class="calibre15">The following code snippet defines a <code class="literal">@parameters</code> method <code class="literal">factorialData()</code>:</p><div class="informalexample"><pre class="programlisting">  @Parameters
  public static Collection&lt;Object[]&gt; factorialData() {
    return Arrays.asList(new Object[][] {
      
      { 0, 1 }, { 1, 1 }, { 2, 2 }, { 3, 6 }, { 4, 24 }, { 5, 120 },{ 6, 720 }  
    });
  }</pre></div><p class="calibre15">Check whether the arrays hold the number and the expected factorial result (0's factorial is 1, 5's factorial is 120, and so on).</p></li><li class="listitem" value="5">The <code class="literal">Parameterized</code> runner needs a constructor to pass the collection of data. For each row in the<a id="id107" class="calibre1"/> collection, the 0<sup class="calibre18">th</sup> array element<a id="id108" class="calibre1"/> will be passed as the 1<sup class="calibre18">st</sup> constructor argument, the next index will be passed <a id="id109" class="calibre1"/>as 2<sup class="calibre18">nd</sup> argument, and so on, as follows:<div class="informalexample"><pre class="programlisting">    private int number;
    private int expectedResult;

    public ParameterizedFactorialTest(int input, int expected) {
        number= input;
        expectedResult= expected;
    }</pre></div><p class="calibre15">In the test class, we added two members to hold the number and the expected factorial value. In the constructor, set these values. The <code class="literal">Parameterized</code> runner will loop through the data collection (annotated with a <code class="literal">@Parameters</code> annotation) and pass the values to the constructor.</p><p class="calibre15">For example, it will pass 0 as input and 1 as expected, then 1 as input and 1 as expected, and so on.</p></li><li class="listitem" value="6">Now, we need to add a test method to assert the number and the factorial as follows:<div class="informalexample"><pre class="programlisting">   @Test
  public void factorial() throws Exception {
    Factorial fact = new Factorial();
    assertEquals(fact.factorial(number),expectedResult);
  }</pre></div><p class="calibre15">We created a <code class="literal">Factorial</code> object and passed the number to get the actual result and then asserted the actual value with <code class="literal">expectedResult</code>. Here, the runner will create seven instances of the test class and execute the test method.</p><p class="calibre15">The following screenshot<a id="id110" class="calibre1"/> shows the result of the test run taken from Eclipse:</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Working with parameterized constructors" class="calibre12"/></div><p class="calibre16"> </p><p class="calibre15">Note that the seven tests<a id="id111" class="calibre1"/> run and the tests names are [0] factorial[0], [1] factorial[1], and so on till [6].</p><div class="note" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre9">If the dataset returns an empty collection, the test doesn't fail; actually, nothing happens.</p><p class="calibre9">If the number of parameters <a id="id112" class="calibre1"/>in the object array and the constructor argument don't match, then a <code class="literal">java.lang.IllegalArgumentException: wrong number of arguments</code> exception is thrown. For example, { 0, 1, 3 } will throw an exception as 3 arguments are passed, but constructor can accept only 2.</p><p class="calibre9">If the constructor is not defined but the data set contains a value, then the <code class="literal">java.lang.IllegalArgumentException: wrong number of arguments</code> exception is thrown.</p></div></li></ol><div class="calibre17"/></div></div><div class="book" title="Working with parameterized methods"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec10" class="calibre1"/>Working with parameterized methods</h3></div></div></div><p class="calibre9">We learned about the parameterized constructor; now we will run the parameterized test excluding the constructor. Follow the ensuing steps<a id="id113" class="calibre1"/> to run the test using the <code class="literal">@Parameter</code> annotation:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add a <code class="literal">ParameterizeParamFactorialTest.java</code> test class.</li><li class="listitem" value="2">Copy the content from<a id="id114" class="calibre1"/> the constructor test and delete the constructor. Change the class members to public, as follows:<div class="informalexample"><pre class="programlisting">@RunWith(Parameterized.class)
public class ParameterizeParamFactorialTest {

  @Parameters
  public static Collection&lt;Object[]&gt; factorialData() {
    return Arrays.asList(new Object[][] {
      
      { 0, 1 }, { 1, 1 }, { 2, 2 }, { 3, 6 }, { 4, 24 }, { 5, 120 },{ 6, 720 }  
    });
  }
  
  public int number;
  public int expectedResult;

  
  @Test
  public void factorial() throws Exception {
    Factorial fact = new Factorial();
  assertEquals(fact.factorial(number),expectedResult);
  }
}</pre></div></li><li class="listitem" value="3">If we run the test, it will fail as<a id="id115" class="calibre1"/> the reflection process won't find the matching constructor. JUnit provides an annotation to loop through the dataset and set the values to the class members. <code class="literal">@Parameter(value=index)</code> takes a value. The value is the array index of the data collection object array. Make sure that the <code class="literal">number</code> and <code class="literal">expectedResult</code> variables are <code class="literal">public</code>; otherwise, the security exception will be thrown. Annotate them with the following parameters:<div class="informalexample"><pre class="programlisting">    @Parameter(value=0)
    public int number;
    @Parameter(value=1)
    public int expectedResult;</pre></div><p class="calibre15">Here, for each row in the data collection, the <code class="literal">number</code> variable will hold the 0<sup class="calibre18">th</sup> index of the array and the <code class="literal">expectedResult</code> variable will hold the 1<sup class="calibre18">st</sup> index.</p></li><li class="listitem" value="4">Run the test; seven tests will be executed.</li></ol><div class="calibre17"/></div></div><div class="book" title="Giving a name"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec11" class="calibre1"/>Giving a name</h3></div></div></div><p class="calibre9">In the constructor example, we found that the test names are assigned with indexes such as [0], [1], and so on. So, if a test fails, then it is not easy to identify the data. To identify an individual test case in a<a id="id116" class="calibre1"/> parameterized test, a name is required. The <code class="literal">@Parameters</code> annotation allows placeholders that are replaced at runtime, and we can use them. The following are the placeholders:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">{index}</code>: This represents the current parameter index</li><li class="listitem"><code class="literal">{0}, {1},…</code>: This represents the first, second, and so on, parameter values</li></ul></div><p class="calibre9">The following code snippet annotates the dataset with the name placeholders:</p><div class="informalexample"><pre class="programlisting">  @Parameters(name = "{index}: factorial({0})={1}")
    public static Collection&lt;Object[]&gt; factorialData() {
      return Arrays.asList(new Object[][] {
      
        { 0, 1 }, { 1, 1 }, { 2, 2 }, { 3, 6 }, { 4, 24 }, { 5, 120 },{ 6, 720 }  
      });
    }</pre></div><p class="calibre9">Eclipse has a bug that chops off the name.</p></div></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Working with timeouts"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch01lvl2sec17" class="calibre1"/>Working with timeouts</h2></div></div></div><p class="calibre9">JUnit tests are automated to get quick feedback after a change in the code. If a test runs for a long time, it violates<a id="id117" class="calibre1"/> the quick feedback principle. JUnit provides a timeout value (in milliseconds) in the <code class="literal">@Test</code> annotation to make sure<a id="id118" class="calibre1"/> that if a test runs longer than the specified value, the test fails.</p><p class="calibre9">The following is an example of a timeout:</p><div class="informalexample"><pre class="programlisting">  @Test(timeout=10)
  public void forEver() throws Exception {
    Thread.sleep(100000);
  }</pre></div><p class="calibre9">Here, the test will fail automatically after 10 milliseconds. The following is an Eclipse screenshot that shows the error:</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Working with timeouts" class="calibre12"/></div><p class="calibre13"> </p></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Exploring JUnit theories"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch01lvl2sec18" class="calibre1"/>Exploring JUnit theories</h2></div></div></div><p class="calibre9">A theory is a kind of a JUnit test but different from the typical example-based JUnit tests, where we assert a specific data set and expect a specific outcome. JUnit theories are an alternative to JUnit's parameterized tests. A JUnit theory<a id="id119" class="calibre1"/> encapsulates the tester's understanding of an object's universal behavior. This means whatever a theory asserts is expected to be true for all data sets. Theories are useful for finding bugs in boundary-value cases.</p><p class="calibre9">Parameterized tests allow us to write flexible data-driven tests and separate data from the test methods. Theories are similar to parameterized tests—both allow us to specify the test data outside of the test case.</p><p class="calibre9">Parameterized tests are good but they have the following drawbacks:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Parameters are declared<a id="id120" class="calibre1"/> as member variables. They pollute the test class and unnecessarily make the system complex.</li><li class="listitem">Parameters need to be passed to the single constructor or variables need to be annotated, simply making the class incomprehensible.</li><li class="listitem">Test data cannot be externalized.</li></ul></div><p class="calibre9">Theory comes up with many annotations and a runner class. Let's examine the important annotations and classes in theory, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">@Theory</code>: Like <code class="literal">@Test</code>, this<a id="id121" class="calibre1"/> annotation identifies a<a id="id122" class="calibre1"/> theory test to<a id="id123" class="calibre1"/> run. The <code class="literal">@Test</code> annotation doesn't work with a theory runner.</li><li class="listitem"><code class="literal">@DataPoint</code>: This annotation<a id="id124" class="calibre1"/> identifies a single<a id="id125" class="calibre1"/> set of test data (similar to <code class="literal">@Parameters</code>), that is, either a static variable or a method.</li><li class="listitem"><code class="literal">@DataPoints</code>: This annotation<a id="id126" class="calibre1"/> identifies multiple sets of test<a id="id127" class="calibre1"/> data, generally<a id="id128" class="calibre1"/> an array.</li><li class="listitem"><code class="literal">@ParametersSuppliedBy</code>: This annotation<a id="id129" class="calibre1"/> provides the parameters<a id="id130" class="calibre1"/> to the test cases.</li><li class="listitem"><code class="literal">Theories</code>: This annotation<a id="id131" class="calibre1"/> is a JUnit runner for<a id="id132" class="calibre1"/> the theory-based test cases and <a id="id133" class="calibre1"/>extends <code class="literal">org.junit.runners.BlockJUnit4ClassRunner</code>.</li><li class="listitem"><code class="literal">ParameterSupplier</code>: This is an abstract<a id="id134" class="calibre1"/> class that gives us the<a id="id135" class="calibre1"/> handle on the parameters that we can supply to the test case.</li></ul></div><p class="calibre9">We will start with a simple<a id="id136" class="calibre1"/> theory and then explore more. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a <code class="literal">MyTheoryTest.java</code> class and annotate the class with <code class="literal">@RunWith(Theories.class)</code>. To run a theory, this special runner is required. Consider the following code:<div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class MyTheoryTest {

}</pre></div></li><li class="listitem" value="2">Now run the test. It will fail with the <code class="literal">java.lang.Exception: No runnable methods</code> error because no theory is defined yet. Like the <code class="literal">@Test</code> annotation, we will define a method and annotate it with <code class="literal">@Theory</code> as follows:<div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class MyTheoryTest {
  
  @Theory
  public void sanity() {
    System.out.println("Sanity check");
  }
}</pre></div><p class="calibre15">Run the theory, and it will be executed with no error. So, our theory setup is ready.</p></li><li class="listitem" value="3">Define a <code class="literal">public static</code> <code class="literal">String</code> with a <code class="literal">name</code> variable and annotate this variable with <code class="literal">@DataPoint</code>. Now execute the test, nothing special happens. If a theory method (annotated with <code class="literal">@Theory</code>) takes an argument and a variable annotated <a id="id137" class="calibre1"/>with <code class="literal">@DataPoint</code> matches the type, then the variable is passed to the theory during execution. So, change the <code class="literal">sanity</code> method and add a <code class="literal">String</code> argument to pass <code class="literal">@DataPoint to the sanity()</code> method, as follows:<div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class MyTheoryTest {
  @DataPoint public static String name ="Jack";
  
  @Theory
  public void sanity(String aName) {
    System.out.println("Sanity check "+aName);
  }
}</pre></div><p class="calibre15">Now run the theory. It will pass the <code class="literal">@DataPoint</code> name to the <code class="literal">sanity(String aName)</code> method during execution and the name will be printed to the console.</p></li><li class="listitem" value="4">Now, add another static <code class="literal">@DataPoint</code>, call it <code class="literal">mike</code>, and rename the <code class="literal">name</code> variable to <code class="literal">jack</code>, as follows:<div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class MyTheoryTest {
  @DataPoint public static String jack ="Jack";
  @DataPoint public static String mike ="Mike";
  
  @Theory
  public void sanity(String aName) {
    System.out.println("Sanity check "+aName);
  }
}</pre></div><p class="calibre15">During theory execution, both the <code class="literal">@DataPoint</code> variables will be passed to the <code class="literal">sanity(String aName)</code> method. The output will be as follows:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Exploring JUnit theories" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="5">Now, slightly modify the <code class="literal">sanity()</code> method—rename the <code class="literal">aName</code> argument to <code class="literal">firstName</code> and add a second <code class="literal">String</code> argument, <code class="literal">lastName</code>. So now the <code class="literal">sanity</code> method takes the <code class="literal">String</code> arguments, <code class="literal">fistName</code> and <code class="literal">lastName</code>. Print these variables using the<a id="id138" class="calibre1"/> following code:<div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class MyTheoryTest {
  @DataPoint public static String jack ="Jack";
  @DataPoint public static String mike ="Mike";
  
  @Theory
  public void sanity(String firstName, String lastName) {
    System.out.println("Sanity check "+firstName+", "+lastName);
  }
}</pre></div><p class="calibre15">When executed, the output will be as follows:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Exploring JUnit theories" class="calibre12"/></div><p class="calibre16"> </p><p class="calibre15">So, 2 x 2 = 4 combinations are used. When the multiple <code class="literal">@DataPoint</code> annotations are defined in a test, the theories apply to all possible well-typed combinations of data points for the test arguments.</p></li><li class="listitem" value="6">So far we have only examined single-dimension variables. The <code class="literal">@DataPoints</code> annotation is used to provide a set of data. Add a static <code class="literal">char</code> array to hold the character variables and add a <code class="literal">Theory</code> method to accept two characters. It will execute the theory with 9 (3 ^ 2) possible combinations as follows:<div class="informalexample"><pre class="programlisting">  @DataPoints  public static char[] chars = 
          new char[] {'A', 'B', 'C'};
  @Theory
  public void build(char c, char d) {
    System.out.println(c+" "+d);
  }</pre></div><p class="calibre15">The following is the output:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Exploring JUnit theories" class="calibre12"/></div><p class="calibre16"> </p></li></ol><div class="calibre17"/></div><div class="book" title="Externalizing data using @ParametersSuppliedBy and ParameterSupplier"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec12" class="calibre1"/>Externalizing data using @ParametersSuppliedBy and ParameterSupplier</h3></div></div></div><p class="calibre9">So far, we have covered how to set up test data using <code class="literal">@DataPoint</code> and <code class="literal">@DataPoints</code>. Now, we will use external classes to supply data in our tests using<a id="id139" class="calibre1"/> <code class="literal">@ParametersSuppliedBy</code> and <code class="literal">ParameterSupplier</code>. To do this, <a id="id140" class="calibre1"/>perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create an <code class="literal">Adder.java</code> class. This class will have two overloaded <code class="literal">add()</code> methods to add numbers <a id="id141" class="calibre1"/>and strings. We will unit test the methods using theory.<p class="calibre15">The following is the <code class="literal">Adder</code> class:</p><div class="informalexample"><pre class="programlisting">  public class Adder {
  
    public Object add(Number a, Number b) {
      return a.doubleValue()+b.doubleValue();
    }
  
    public Object add(String a, String b) {
      return a+b;
    }
  }</pre></div></li><li class="listitem" value="2">Create an <code class="literal">ExternalTheoryTest.java</code> theory as follows:<div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class ExternalTheoryTest {

}</pre></div></li><li class="listitem" value="3">We will not use <code class="literal">@DataPoints</code> to create data. Instead, we will create a separate class to supply<a id="id142" class="calibre1"/> numbers to validate the <code class="literal">add</code> operation. JUnit provides a <code class="literal">ParameterSupplier</code> class for this purpose. <code class="literal">ParameterSupplier</code> is<a id="id143" class="calibre1"/> an abstract class, and it forces you to define a method as follows:<div class="informalexample"><pre class="programlisting">public abstract List&lt;PotentialAssignment&gt; getValueSources(ParameterSignature parametersignature);</pre></div><p class="calibre15">
<code class="literal">PotentialAssignment</code><a id="id144" class="calibre1"/> is an abstract class that JUnit theories use to provide test data to test methods in a consistent manner. It has a static <code class="literal">forValue</code> method that you can use to get an instance of <code class="literal">PotentialAssignment</code>.</p><p class="calibre15">Create a <code class="literal">NumberSupplier</code> class to supply different types of numbers: <code class="literal">float</code>, <code class="literal">int</code>, <code class="literal">double</code>, <code class="literal">long</code>, and so on. Extend the <code class="literal">ParameterSupplier</code> class as follows:</p><div class="informalexample"><pre class="programlisting">  import org.junit.experimental.theories.ParameterSignature;
  import org.junit.experimental.theories.ParameterSupplier;
  import org.junit.experimental.theories.PotentialAssignment;

  public  class NumberSupplier extends ParameterSupplier {
    @Override
      public List&lt;PotentialAssignment&gt;       
      getValueSources(ParameterSignature sig) {
        List&lt;PotentialAssignment&gt; list = new ArrayList&lt;PotentialAssignment&gt;();
        list.add(PotentialAssignment.forValue("long", 2L));
        list.add(PotentialAssignment.forValue("float", 5.00f));
        list.add(PotentialAssignment.forValue("double", 89d));
        return list;
  }

};</pre></div><p class="calibre15">Check whether the overridden method creates a list of <code class="literal">PotentialAssignment</code> values of <a id="id145" class="calibre1"/>different numbers.</p></li><li class="listitem" value="4">Now, modify the theory to<a id="id146" class="calibre1"/> add two numbers. Add a theory method as follows:<div class="informalexample"><pre class="programlisting">import org.junit.experimental.theories.ParametersSuppliedBy;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.runner.RunWith;

@RunWith(Theories.class)
public class ExternalTheoryTest {

  @Theory
  public void adds_numbers(
  @ParametersSuppliedBy(NumberSupplier.class) Number num1,
  @ParametersSuppliedBy(NumberSupplier.class) Number num2) 
  {
    System.out.println(num1 + " and " + num2);
  }

}</pre></div><p class="calibre15">Check the <code class="literal">adds_numbers</code> method; two <code class="literal">Number</code> arguments <code class="literal">num1</code> and <code class="literal">num2</code> are annotated with <code class="literal">@ParametersSuppliedBy(NumberSupplier.class)</code>.</p><p class="calibre15">When this theory is executed, the <code class="literal">NumberSupplier</code> class will pass a list.</p></li><li class="listitem" value="5">Execute the theory; it will print the following result:<div class="mediaobject"><img src="../images/00016.jpeg" alt="Externalizing data using @ParametersSuppliedBy and ParameterSupplier" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="6">Now, we can check our <code class="literal">Adder</code> functionality. Modify the theory to assert the result.<p class="calibre15">Create an instance of the <code class="literal">Adder</code> class and call the <code class="literal">add</code> method by passing <code class="literal">num1</code> and <code class="literal">num2</code>. Add the two numbers and <code class="literal">assert</code> the value with the results of <code class="literal">Adder</code>.</p><p class="calibre15">The <code class="literal">assertEquals(double, double)</code> method is deprecated as the double value calculation results in an unpredictable result. So, the <code class="literal">assert</code> class adds another version<a id="id147" class="calibre1"/> of <code class="literal">assertEquals</code> for <code class="literal">doubles</code>; it takes three arguments: actual, expected, and a delta. If the difference between the <code class="literal">actual</code> and the <code class="literal">expected</code> value is greater than or equal to delta, then the assertion passes as follows:</p><div class="informalexample"><pre class="programlisting">@RunWith(Theories.class)
public class ExternalTheoryTest {

  @Theory
  public void adds_numbers(
  @ParametersSuppliedBy(NumberSupplier.class) Number num1,
  @ParametersSuppliedBy(NumberSupplier.class) Number num2) {
    Adder anAdder = new Adder();
    double expectedSum = num1.doubleValue()+num2.doubleValue();
    double actualResult = (Double)anAdder.add(num1, num2);
    assertEquals(actualResult, expectedSum, 0.01);
  }

}</pre></div><p class="calibre15">The <code class="literal">Adder</code> class has an <code class="literal">add</code> method for <code class="literal">String</code>. Create a <code class="literal">StringSupplier</code> class to supply <code class="literal">String</code> values to our theory and modify the theory class to<a id="id148" class="calibre1"/> verify the <code class="literal">add (String, String)</code> method behavior. You can assert the <code class="literal">Strings</code> as follows:</p><div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="literal">String expected = str1+str2;</code></li><li class="listitem"><code class="literal">assertEquals(expected, actual);</code></li></ul></div><p class="calibre15">Here, <code class="literal">str1</code> and <code class="literal">str2</code> are the two method arguments of the theory.</p></li></ol><div class="calibre17"/></div></div></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Dealing with JUnit rules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch01lvl2sec19" class="calibre1"/>Dealing with JUnit rules</h2></div></div></div><p class="calibre9">Rules allow very flexible addition<a id="id149" class="calibre1"/> or redefinition of the behavior of each test method in a test class. Rules are like<a id="id150" class="calibre1"/> <span class="strong"><strong class="calibre10">Aspect Oriented Programming</strong></span> (<span class="strong"><strong class="calibre10">AOP</strong></span>); we can do useful things before and/or after the actual test execution. You can find more information about AOP at <a class="calibre1" href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a>.</p><p class="calibre9">We can use the inbuilt rules or define our custom rule.</p><p class="calibre9">In this section, we will look at the inbuilt rules and create our custom Verifier and WatchMan rule.</p><div class="book" title="Playing with the timeout rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec13" class="calibre1"/>Playing with the timeout rule</h3></div></div></div><p class="calibre9">The timeout rule applies the<a id="id151" class="calibre1"/> same timeout to all the test methods in a class. Earlier, we used the timeout in the <code class="literal">@Test</code> annotation <a id="id152" class="calibre1"/>as follows:</p><div class="informalexample"><pre class="programlisting">@Test(timeout=10)</pre></div><p class="calibre9">The following is the syntax of the timeout rule:</p><div class="informalexample"><pre class="programlisting">import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.Timeout;

public class TimeoutTest {
    
    @Rule
    public Timeout globalTimeout =  new Timeout(20);
    
    @Test
    public void testInfiniteLoop1() throws InterruptedException{
      Thread.sleep(30);
    }
    
    @Test
    public void testInfiniteLoop2() throws InterruptedException{
      Thread.sleep(30);
    }
    
}</pre></div><p class="calibre9">When we run this test, it times out<a id="id153" class="calibre1"/> after 20 milliseconds. Note that the timeout is applied globally to all methods.</p></div><div class="book" title="Working with the ExpectedException rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec14" class="calibre1"/>Working with the ExpectedException rule</h3></div></div></div><p class="calibre9">The <code class="literal">ExpectedException</code> rule is an important rule for handling exceptions. It allows you to assert the expected exception type <a id="id154" class="calibre1"/>and the exception message, for example, your code may throw a generic exception (such as <code class="literal">IllegalStateException</code>) for all <a id="id155" class="calibre1"/>failure conditions, but you can assert the generic exception message to verify the exact cause.</p><p class="calibre9">Earlier, we used <code class="literal">@Test(expected=Exception class)</code> to test the error conditions.</p><p class="calibre9">The <code class="literal">ExpectedException</code> rule allows in-test specification of expected exception types and messages.</p><p class="calibre9">The following code snippet explains how an exception rule can be used to verify the exception class and the exception message:</p><div class="informalexample"><pre class="programlisting">public class ExpectedExceptionRuleTest {

   @Rule
    public ExpectedException thrown= ExpectedException.none();

    @Test
    public void throwsNothing() {

    }

    @Test
    public void throwsNullPointerException() {
      thrown.expect(NullPointerException.class);
      throw new NullPointerException();
    }

    @Test
    public void throwsIllegalStateExceptionWithMessage() {
      thrown.expect(IllegalStateException.class);
      thrown.expectMessage("Is this a legal state?");
     
      throw new IllegalStateException("Is this a legal state?");
    }
}</pre></div><p class="calibre9">The <code class="literal">expect</code> object sets the expected exception class and <code class="literal">expectMessage</code> sets the expected message in the exception. If the<a id="id156" class="calibre1"/> message or exception class<a id="id157" class="calibre1"/> doesn't match the rule's expectation, the test fails. The <code class="literal">ExpectedException</code> object thrown is reset on each test.</p></div><div class="book" title="Unfolding the TemporaryFolder rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec15" class="calibre1"/>Unfolding the TemporaryFolder rule</h3></div></div></div><p class="calibre9">The <code class="literal">TemporaryFolder</code> rule allows the creation of files and folders that are guaranteed to be deleted when the test method<a id="id158" class="calibre1"/> finishes (whether it passes or fails). Consider <a id="id159" class="calibre1"/>the following code:</p><div class="informalexample"><pre class="programlisting">@Rule
  public TemporaryFolder folder = new TemporaryFolder();

  @Test
  public void testUsingTempFolder() throws IOException {
    File createdFile = folder.newFile("myfile.txt");
    File createdFolder = folder.newFolder("mysubfolder");
    
  }</pre></div></div><div class="book" title="Exploring the ErrorCollector rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec16" class="calibre1"/>Exploring the ErrorCollector rule</h3></div></div></div><p class="calibre9">The <code class="literal">ErrorCollector</code> rule allows the <a id="id160" class="calibre1"/>execution of a test to continue after the first problem is found (for example, to collect all the incorrect rows in a table<a id="id161" class="calibre1"/> and report them all at once) as follows:</p><div class="informalexample"><pre class="programlisting">import org.junit.rules.ErrorCollector;
import static org.hamcrest.CoreMatchers.equalTo;

public class ErrorCollectorTest {

   @Rule
   public ErrorCollector collector = new ErrorCollector();
    
   @Test
   public void fails_after_execution() {
   collector.checkThat("a", equalTo("b"));
   collector.checkThat(1, equalTo(2));
   collector.checkThat("ae", equalTo("g"));
   }
}</pre></div><p class="calibre9">In this example, none of the verification passes but the test still finishes its execution, and at the end, notifies all errors.</p><p class="calibre9">The following is the log—the arrows<a id="id162" class="calibre1"/> indicate the errors—and also note<a id="id163" class="calibre1"/> that only one test method is being executed but Eclipse indicates three failures:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Exploring the ErrorCollector rule" class="calibre12"/></div><p class="calibre13"> </p></div><div class="book" title="Working with the Verifier rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec17" class="calibre1"/>Working with the Verifier rule</h3></div></div></div><p class="calibre9">Verifier is a base class of <code class="literal">ErrorCollector</code>, which can otherwise turn passing tests into failing tests if a <a id="id164" class="calibre1"/>verification check fails. The following <a id="id165" class="calibre1"/>example demonstrates the <code class="literal">Verifier</code> rule:</p><div class="informalexample"><pre class="programlisting">public class VerifierRuleTest {
  private String errorMsg = null;

  @Rule
  public TestRule rule = new Verifier() {
    protected void verify() {
      assertNull("ErrorMsg should be null after each test execution",errorMsg);
    }
  };
  
  
  @Test
  public void testName() throws Exception {
    errorMsg = "Giving a value";
  }
}</pre></div><p class="calibre9">Verifier's <code class="literal">verify</code> method is executed after each test execution. If the <code class="literal">verify</code> method defines any assertions, and that assertion fails, then the test is marked as failed.</p><p class="calibre9">In the preceding example, the test should not fail as the test method doesn't perform any comparison; however, it still fails. It fails because the Verifier rule checks that after every test execution, the <code class="literal">errorMsg</code> string should be set as null, but the test method sets the value to <code class="literal">Giving a value</code>; hence, the verification fails.</p></div><div class="book" title="Learning the TestWatcher rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec18" class="calibre1"/>Learning the TestWatcher rule</h3></div></div></div><p class="calibre9">
<code class="literal">TestWatcher</code> (and the deprecated <code class="literal">TestWatchman</code>) are base classes for rules that take note of the testing action, without<a id="id166" class="calibre1"/> modifying it. Consider the<a id="id167" class="calibre1"/> following code:</p><div class="informalexample"><pre class="programlisting">@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class TestWatcherTest {

  private static String dog = "";

    @Rule
    public TestWatcher watchman = new TestWatcher() {
      @Override
      public Statement apply(Statement base, Description description) {
        return super.apply(base, description);
      }

      @Override
      protected void succeeded(Description description) {
        dog += description.getDisplayName() + " " + "success!\n";
      }

      @Override
      protected void failed(Throwable e, Description description) {
        dog += description.getDisplayName() + " " + e.getClass().getSimpleName() + "\n";
      }

      @Override
      protected void starting(Description description) {
        super.starting(description);
      }

      @Override
      protected void finished(Description description) {
        super.finished(description);
      }
    };

    @Test
    public void red_test() {
      fail();
    }

    @Test
    public void green() {
    }
  
    @AfterClass
    public static void afterClass() {
      System.out.println(dog);
    }
}</pre></div><p class="calibre9">We created a <code class="literal">TestWatcher</code> class to listen to <a id="id168" class="calibre1"/>every test execution, collected the<a id="id169" class="calibre1"/> failure, and success instances, and at the end, printed the result in the <code class="literal">afterClass()</code> method.</p><p class="calibre9">The following is the<a id="id170" class="calibre1"/> error shown on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre10">green(com.packtpub.junit.recap.rule.TestWatcherTest) success!</strong></span>
<span class="strong"><strong class="calibre10">red_test(com.packtpub.junit.recap.rule.TestWatcherTest) AssertionError</strong></span>
</pre></div></div><div class="book" title="Working with the TestName rule"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec19" class="calibre1"/>Working with the TestName rule</h3></div></div></div><p class="calibre9">The <code class="literal">TestName</code> rule makes the current test name available inside test methods. The <code class="literal">TestName</code> rule can be used in<a id="id171" class="calibre1"/> conjunction with the <code class="literal">TestWatcher</code> rule to <a id="id172" class="calibre1"/>make a unit testing framework compile a unit testing report.</p><p class="calibre9">The following test snippet shows that the test name is asserted inside the test:</p><div class="informalexample"><pre class="programlisting">public class TestNameRuleTest {

  @Rule
    public TestName name = new TestName();
    
    @Test
    public void testA() {
      assertEquals("testA", name.getMethodName());
    }
    
    @Test
    public void testB() {
      assertEquals("testB", name.getMethodName());
    }
}</pre></div><p class="calibre9">The following section uses the <code class="literal">TestName</code> rule to get the method name before test execution.</p></div><div class="book" title="Handling external resources"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec20" class="calibre1"/>Handling external resources</h3></div></div></div><p class="calibre9">Sometimes JUnit tests need to communicate with external resources such as files or databases or server sockets. Dealing <a id="id173" class="calibre1"/>with external resources is always messy because you need to set up state and tear it down later. The <code class="literal">ExternalResource</code> rule provides a mechanism that makes resource handling a bit more convenient.</p><p class="calibre9">Previously, when you had to create files in a test case or work with server sockets, you had to set up a temporary directory, or open a socket in a <code class="literal">@Before</code> method and later delete the file or close the server in an <code class="literal">@After</code> method. But now, JUnit provides a simple AOP-like mechanism called the <code class="literal">ExternalResource</code> rule that makes this setup and cleanup work the responsibility of the resource.</p><p class="calibre9">The following example demonstrates the <code class="literal">ExternalResource</code> capabilities. The <code class="literal">Resource</code> class represents an external resource and prints the output in the console:</p><div class="informalexample"><pre class="programlisting">class Resource{
  public void open() {
    System.out.println("Opened");
  }
  
  public void close() {
    System.out.println("Closed");
  }
  
  public double get() {
    return Math.random();
  }
}</pre></div><p class="calibre9">The following test class<a id="id174" class="calibre1"/> creates <code class="literal">ExternalResource</code> and handles the resource lifecycle:</p><div class="informalexample"><pre class="programlisting">public class ExternalResourceTest {
  Resource resource;
  <span class="strong"><strong class="calibre10">public @Rule TestName name = new TestName();</strong></span>

  <span class="strong"><strong class="calibre10">public @Rule ExternalResource rule = new ExternalResource()</strong></span> {
    @Override protected void before() throws Throwable {
      resource = new Resource();
      resource.open();
      System.out.println(<span class="strong"><strong class="calibre10">name.getMethodName()</strong></span>);
    }
    
    @Override protected void after()  {
      resource.close();
      System.out.println("\n");
    }
  };
  
  @Test
  public void someTest() throws Exception {
    System.out.println(resource.get());
  }
  
  @Test
  public void someTest2() throws Exception {
    System.out.println(resource.get());
  }
}</pre></div><p class="calibre9">The anonymous <code class="literal">ExternalResource</code> class overrides the <code class="literal">before</code> and <code class="literal">after</code> methods of the <code class="literal">ExternalResource</code> class. In the <code class="literal">before</code> method, it starts<a id="id175" class="calibre1"/> the resource and prints the test method name using the <code class="literal">TestName</code> rule. In the <code class="literal">after</code> method, it just closes the resource.</p><p class="calibre9">The following is the test run output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre10">Opened</strong></span>
<span class="strong"><strong class="calibre10">someTest2</strong></span>
<span class="strong"><strong class="calibre10">0.5872875884671511</strong></span>
<span class="strong"><strong class="calibre10">Closed</strong></span>

<span class="strong"><strong class="calibre10">Opened</strong></span>
<span class="strong"><strong class="calibre10">someTest</strong></span>
<span class="strong"><strong class="calibre10">0.395586457988541</strong></span>
<span class="strong"><strong class="calibre10">Closed</strong></span>
</pre></div><p class="calibre9">Note that the resource is opened before test execution and closed after the test. The test name is printed using the <code class="literal">TestName</code> rule.</p></div></div></div>

<div class="book" title="Working with JUnit 4++">
<div class="book" title="Exploring JUnit categories"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_10"><a id="ch01lvl2sec20" class="calibre1"/>Exploring JUnit categories</h2></div></div></div><p class="calibre9">The <code class="literal">Categories</code> runner runs <a id="id176" class="calibre1"/>only the classes and methods that are annotated with either the category given with the <code class="literal">@IncludeCategory</code> annotation or a subtype of that category. Either classes or interfaces can be used as categories. Subtyping works, so if you use <code class="literal">@IncludeCategory(SuperClass.class)</code>, a test marked <code class="literal">@Category({SubClass.class})</code> will be run.</p><p class="calibre9">We can exclude categories by using the <code class="literal">@ExcludeCategory</code> annotation.</p><p class="calibre9">We can define two interfaces using the following code:</p><div class="informalexample"><pre class="programlisting">public interface SmartTests { /* category marker */ }
public interface CrazyTests { /* category marker */ }

public class SomeTest {
  @Test
  public void a() {
    fail();
  }

  @Category(CrazyTests.class)
  @Test
  public void b() {
  }
}

@Category({CrazyTests.class, SmartTests.class})
public class OtherTest {
  @Test
  public void c() {

  }
}

@RunWith(Categories.class)
@IncludeCategory(CrazyTests.class)
@SuiteClasses( { SomeTest.class, OtherTest.class }) // Note that Categories is a kind of Suite
public class CrazyTestSuite {
  // Will run SomeTest.b and OtherTest.c, but not SomeTest.a
}

@RunWith(Categories.class)
@IncludeCategory(CrazyTests.class)
@ExcludeCategory(SmartTests.class)
@SuiteClasses( { SomeTest.class, OtherTest.class }) 
public class CrazyTestSuite {
  // Will run SomeTest.b, but not SomeTest.a or OtherTest.c
}</pre></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This JUnit refresher chapter covers both the basic and advanced usage of JUnit.</p><p class="calibre9">The basic section covers the annotation based on JUnit 4 testing, assertion, the @RunWith annotation, exception handling, and the Eclipse setup for running the JUnit tests.</p><p class="calibre9">The advanced section covers parameterized tests, matchers and <code class="literal">assertThat</code>, a custom <code class="literal">lessThanOrEqual()</code> matcher, assumption, theory, a custom NumberSupplier class, timeout, categories, TestName, ExpectedException, TemporaryFolder, ErrorCollector, Verifier and TestWatcher rules, test suites, and executing tests in order.</p><p class="calibre9">By now, you will be able to write and execute JUnit 4 tests and be familiar with the advanced concepts of JUnit 4.</p><p class="calibre9">
<a class="calibre1" title="Chapter 2. Automating JUnit Tests" href="part0018_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre11">Automating JUnit Tests</em></span>, focuses on getting you quickly started with project-building tools and test automation. It provides an overview of continuous integration, explores the incremental Gradle build and Maven build lifecycle, Ant scripting, and Jenkins automation using Gradle, Maven, and Ant scripts.</p></div></body></html>