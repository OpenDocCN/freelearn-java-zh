- en: Integrating Legacy APIs with the Proxy Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a new API is very often a pleasant experience for developers. Without
    any legacy code, we engineers can choose our tooling, think through the design
    process to ensure an enjoyable end user experience, build on top of a serverless
    platform, and all of the other best practices learned through the ages. However,
    companies and bosses task many engineers with taking a legacy API and supporting,
    maintaining, or porting it to a new architecture. Given an already deployed production
    API that sees constant usage, porting to a serverless system can be akin to changing
    the engine of a race car while in the middle of a race.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this complicated task can be made much simpler nowadays using the
    proxy pattern, the idea of which has been around for many years as a software
    pattern. If the name isn't clear enough, the main ideas are that a layer sits
    in between the client and backend system, which acts as a proxy, shuffling data
    to and from the backend service on behalf of the client. Inserting this proxy
    in between the two actors (client and server) makes it possible to transform request
    data from the client before it's sent to the server, as well as transform the
    payload from the server before it's delivered to the client. In this manner, one
    may mimic the exact behavior of a legacy API without any changes needed on the
    client side. This design allows for a graceful transition from a legacy API backend
    to a newer backend system without the fear of breaking existing clients or requiring
    them to update their application.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you can expect to learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the proxy pattern and how it works for migrating API backends
    or updating the request/response payloads for existing APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options for implementing the proxy pattern, including AWS API Gateway and custom
    serverless functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming requests/responses to an existing API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating existing APIs to a serverless backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS API Gateway introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Gateway from Amazon Web Services is a fantastic tool with a slew of features
    that significantly simplifies implementation of an API proxy pattern. Later on
    in the chapter, we'll discuss strategies when building on a different cloud provider;
    however, if you're like me and use AWS consistently, API Gateway can make your
    life much more comfortable. Personally, I feel that it's an underrated tool, which
    can do a lot more than HTTP requests to Lambda functions as we saw in [Chapter
    2](svrls-dsnptn-bstprac_ch02.html), *Three-Tier Web Application Using REST* and
    [Chapter 3](svrls-dsnptn-bstprac_ch03.html), *Three-Tier Web Application Pattern
    with GraphQL*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question may be, *What is API Gateway and what does it do?* Rather
    than answer this myself, I''ll defer to the technical documentation at [http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html](http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html),
    which does a good job of describing Gateway at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Amazon API Gateway is an AWS service that enables developers to create, publish,
    maintain, monitor, and secure APIs at any scale. You can create APIs that access
    AWS or other web services, as well as data stored in the AWS Cloud."'
  prefs: []
  type: TYPE_NORMAL
- en: 'API Gateway provides you with a publicly accessible HTTPS URL. Requests that
    hit this endpoint may do a variety of things including, but not limited to, the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Call a Lambda function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a mock endpoint build with templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy requests to a different HTTP endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A* *Three-Tier Web Application
    Using REST* and [Chapter 3](svrls-dsnptn-bstprac_ch03.html), *A* *Three-Tier Web
    Application Pattern with GraphQL*, we used API Gateway to expose an HTTPS endpoint
    that would invoke our Lambda functions containing application logic. HTTP payload
    data, including headers and query parameters, would be pulled in from the HTTPS
    request and sent to Lambda. Our Lambda functions also control the response payload
    by returning a JSON-encodable data structure as well as appropriate HTTP status
    codes and headers. Managing the actual HTTP response from Lambda is known as a
    **proxy integration**, not to be confused with the proxy pattern we will work
    on in this chapter. I bring this up to add clarity to what we've done and what
    we'll be doing for this pattern with API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: In most of the subsequent examples, we will not be using the Lambda proxy integration.
    While this means more configuration will work on our behalf, it also means we
    will be able to control the request/response payloads to our liking. When building
    a brand new Serverless API with API Gateway and AWS Lambda, Lambda proxy integration
    should be precisely what you need since it's easy to control requests and responses
    from your API definition and application code, respectively. However, when setting
    up the proxy pattern for an existing HTTP backend, it's common to need more control
    over transforming response data before it's sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being the ingestion point for web requests and sending those
    requests somewhere else, API Gateway provides quite a bit more functionality,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic API documentation generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting/throttling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining multiple stages or environments with their variables that can be passed
    to downstream systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personally speaking, the more I learn about the capabilities of API Gateway,
    the more ideas I come up with for possible applications and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: There are other services that provide similar functionality. If you prefer to
    build on something other than AWS, have a look at **Apigee** ([https://apigee.com/api-management/](https://apigee.com/api-management/))
    or **Kong** ([https://getkong.org/](https://getkong.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Simple proxy to a legacy API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first example, we'll go through the steps to set up a simple integration
    with an existing API. What is neat about API Gateway is that it's possible to
    go a very long way on the path to replacing current application code without writing
    any code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, we'll use a publicly available fake API called `JsonPlaceholder`,
    pretending for our purposes that it's a legacy API that we'd like to replace: [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this type of replacement warrants plenty of thought and careful planning.
    Authentication, rate limiting, DNS entries, and the like are all factors that
    much be thought through carefully before embarking on such a project. Still, with
    all of the issues that one should consider, there are many tools and options to
    make this pattern a real possibility for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a pass-through proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step one on our journey will be to work through the steps of setting up a new
    API in API Gateway that will pass requests and responses to and from `JsonPlaceholder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the AWS console, create a new API, shown as follows. I''ll call this
    one `JsonProxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5040d3c5-6ded-4cc7-94d2-085f11ccfc3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have our API, we can start filling it in and adding endpoints and behavior.
    In my experience, most AWS services have essential concepts that one should understand
    well before building something of significance. API Gateway is no different in
    this regard. The good news is that it's not incredibly difficult to understand
    these concepts in API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two concepts we''ll be working with when using API Gateway are resources
    and methods. The mental model is situation simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource**: API endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: HTTP method that lives under a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSONPlaceholder` provides API endpoints for a few different API resources,
    posts, comments, albums, and so on. To begin, we''ll create a new API Gateway
    resource for `/posts`. This endpoint, on our unique URL, will proxy to [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    It should be noted that we could set up an endpoint on our API Gateway deployment
    named something other than `/posts`. That is, it''s possible to create a resource
    named `/all_posts`, which would then proxy to [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console, we set this up in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Actions button → Create Resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Resource Name to be posts
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure Configure as proxy resource is not checked
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Create Resource button
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the newly created `/posts` resource is selected/highlighted in the list
    of resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Actions button → Create Method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select GET and click the confirmation checkbox button
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, set the options as shown in the following screenshot
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the Endpoint URL is pointing to [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the Save button; take a look at the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d95aed31-20f8-4855-ba1b-71efb41ed4ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot may look quite confusing. I''ll admit, I didn''t understand
    many details of this part of API Gateway for quite a long time until I went through
    this exercise that we''re going through now. We''ll go through the details of
    the Method Execution screen in detail, but first, let''s deploy our new API and
    test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2136a688-883c-42d5-ab37-2b1bf7b52e89.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying a pass-through proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we''ve merely defined our API''s skeleton and straightforward
    structure, with a single endpoint of `/posts`. There is no URL for us to query
    to test. For that, we''ll need to deploy our API:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Actions button → Deploy API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Deploy API screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New stage
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `dev` for the stage name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Deploy button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After deployment, the console will take you to the dev Stage Editor screen.
    Here, you''ll notice many other types of features that you can update. For example,
    it''s possible to turn on/off API throttling, set stage variables, and so on.
    For our purposes, we''re all done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89145268-abb3-45e4-b1e6-72355575afef.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice a URL highlighted at the top of this screen. This custom URL is
    unique to this deployment and may be used to hit our API. Expanding the dev stage
    on the left-hand side will show you the single URL endpoint we defined in the
    prior Resources section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we load up our custom URL in the browser or hit that URL with cURL,
    we can see the data pulled from the `JSONPlaceholder` endpoint of `/posts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have now is our very own HTTPS URL, which doesn''t do much, but it''s
    still quite remarkable. We have not written a single line of application code
    in any sort of programming language, and have set up a proxy to return results
    from an existing legacy API. You may think this isn''t very useful right now.
    You wouldn''t be wrong, necessarily. However, even with a simple integration like
    this, we can already begin to take advantage of some API Gateway features such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated API documentation generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated SDK generation in multiple languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is merely the first step. In the next section, we will dive into the details
    of starting to transform our API Gateway API to turn it into something completely
    different using the same data source.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming responses from a modern API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll walk through a scenario where we have an existing API interface
    that we need to support, but would like to change the backend implementation entirely.
    This scenario is common and one I've dealt with personally. Existing clients point
    to a particular set of API endpoints. Breaking a public API that many developers
    depend on isn't something anyone wants to do. But, when that API is built on top
    of hard-to-maintain or poorly performing code, how does one iterate without requiring
    hundreds or thousands of developers to update their mobile, web, or GUI applications?
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I will walk through the steps necessary to take a pretend legacy
    API and reimplement it using our modern API. `JSONPlaceholder` will play the part
    of our new, modern, scalable, and performant RESTful API. The single URL we will
    reimplement with the proxy pattern is `https://$HOSTNAME/get_comments_by_post_id`.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine the type of data this endpoint returns. Thinking back to our
    discussion on REST APIs, it's evident that this legacy pattern is not RESTful
    for a variety of reasons. With an API structure such as this, you can bet that
    the rest of the API design will need some work and may not be the easiest to work
    with as an end user. Our shiny new RESTful API (`JSONPlaceholder`) is much more
    to our liking and one that we'd like to advertise and have developers adopt rather
    than the previous old structure. How can we support existing clients with the
    same input and output payloads by using our new RESTful API?
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway can help us out in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Method execution flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Method Execution screenshot shown in the *Setting up a pass-through proxy* section
    will come into play now. You may refer back to that screenshot as we walk through
    the four different parts. It also may be easier to look at the following diagram,
    which represents the same request/response flow but is a bit simpler to digest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8c521b0-35db-4e38-a981-2ee660098568.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For every API Gateway resource/method combination, there are four steps that
    we may configure. It all starts with the client on the far left of this diagram.
    This **client** icon represents the user who is calling our API. After a series
    of steps, an HTTP response is created, and the client receives some payload. Working
    with API Gateway means configuring some or all of these stages to control the
    HTTP request and the HTTP response. Sitting right in the middle of this flow is
    the **Integration Type**, which, as mentioned earlier, may be a variety of things,
    including an AWS Lambda function or existing HTTP endpoint. The two steps that
    precede the execution of the integration (**Method Request** and **Integration
    Request**) are responsible for working with the HTTP request. The work that these
    two stages perform may include:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming input data (that is, POST payload)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting and transforming headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once this work is done, the Integration Request will pass data (which may or
    may not be transformed from the original input payload) to the Integration Type.
    The Integration Type returns some data, hands it off to the Integration Response,
    and finally Method Response. As the other two sections worked on the request payload,
    these two sections (Integration Response and Method Response) operate on the response
    payload. Actions we may perform here include:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the HTTP body/payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming/adding HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling HTTP status codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the AWS console screenshot in the *Setting up a pass-through proxy* section,
    the client is represented on the far left as a vertically oriented rectangle. On
    the far right of the same screenshot is the endpoint that we configured this API
    to talk with, [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    Again, in other cases, that integration endpoint may be a Lambda function, mock
    integration, or any of the other supported backend systems for API Gateway. In
    our example for this chapter, it will always be our existing `JSONPlaceholder`
    API. Following the arrows in the Method Execution screen on the AWS console you
    can see how a request from clients flows in the order described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: Method Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our configured integration endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many options and a huge number of permutations with this flow of
    data. We can''t go through every one obviously, but we''ll work primarily with
    Integration Request and Integration Response for this example. Our tasks will
    involve:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new resources for the three separate legacy API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `GET` methods on those three resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each resource/method combination, map query parameters from the request
    to our new API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each resource/method combination, set up an Integration Response Body Mapping
    Template to transform the JSON payload from our new API to the structure expected
    of the legacy API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API to integrate with has the URL structure of [https://jsonplaceholder.typicode.com/comments?postId=1](https://jsonplaceholder.typicode.com/comments?postId=1).
    As a reminder, this is the endpoint URL for our HTTP Integration Type. With a
    URL structure like that, it''s clear what is going on and what the return data
    should be. This request fetches comments for a given `postId`, which are passed
    along as a `GET` argument. Additionally, this modern API returns an array of comment
    resources with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume for the sake of this example that our legacy system has an analogous
    API but with a different URL structure, `GET` argument to filter the comments
    and representation of the comment resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://$HOSTNAME/get_comments_by_post_id?post_id=1`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our job here is to support this legacy URL pattern and payload using the modern-day
    RESTful API (`JSONPlaceholder`) as the data source. Fortunately, all of the data
    we need to support we have in our new API, so our job will be to have API Gateway
    perform the translation of the payload before it's sent out to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new resource and method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create a new API Gateway resource and method for the `get_comments_by_post_id`
    endpoint. The steps are the same as the prior section. The only differences will
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint we'll talk to will be [https://jsonplaceholder.typicode.com/comments](https://jsonplaceholder.typicode.com/comments)
    rather than the `/posts` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to map query parameters from the initial client request to the desired
    query parameters to the backend API that provides the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After setting up this new resource and method, it should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9b798d0-bedc-4c27-b3e4-c1587caef4ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up Integration Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to set up API Gateway so that it passes the expected `GET` arguments
    from the request to our backend. API Gateway allows for controlling the query
    parameter mapping in the *Method Request* and *Integration Request* sections.
    In the Method Execution screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Method Request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on URL Query String Parameters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add query string parameter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Put in `post_id`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave required and caching unchecked
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back on the Method Execution screen, click on Integration Request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand URL Query String Parameters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add query string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Put in `postId` for Name and `method.request.querystring.post_id` for Mapped
    from
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What we've done here is tell API Gateway to expect a `GET` argument named `post_id`,
    which is the old parameter we need to support. From there, Gateway will extract
    this `post_id` attribute and inject it into the Integration Request. The value
    for `post_id` is accessible in `method.request.querystring.post_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding a new query string named `postId` and with a value of `method.request.querystring.post_id`,
    we''re simply passing that value along to the new RESTful API, but using the new
    parameter name of `postId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d51b0241-b5e5-408a-86d4-56eafdfdf868.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To test these changes, we need to deploy the API. In the console, in the Resources
    section, select the Actions button and click Deploy API. Deploy this to our single
    `dev` stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4543ff55-21af-4f56-ab43-71608b098ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can hit our new API and see the results using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Integration Response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the URL and query parameter mapping working, it''s time to
    begin transforming the response generated from our new API. Since the old JSON
    structure is different, we''ll use Gateway''s Body Mapping Templates to take the
    output from the JSON response and rewrite it. API Gateway uses the Velocity Template
    language and system to perform this work. If you''ve ever done web programming
    with a modern-day web framework, you''ve undoubtedly worked with a templating
    library. There are many. Velocity isn''t magic; it serves the same purpose as
    any other templating system: taking some marked up template in a particular syntax
    along with some contextual data and rendering an output string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Method Execution screen, click on Integration Response. Where we are
    at this point in the request/response cycle is after the backend integration has
    generated a response, just before the system starts sending the data back to the
    client. At this stage, we''ll configure the Integration Response to rewrite the
    output to the client using two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON response from our backend (`JSONPlaceholder`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A body mapping template, which is written using the Velocity Template language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, it's possible to set up different body mapping templates based
    on HTTP response codes and content/type. For simplicity, we'll just be dealing
    with HTTP 200 and a single Integration Response, response code, and content/type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Integration Response section:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the single row in the table, which is the Default mapping
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the Body Mapping Templates section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the application/json in the Content-Type table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following template code in the text area and click Save
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the API to the `dev` stage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code block as follows refers to step #4\. This is the Velocity Template
    language syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The template code in the preceding code block should be placed in the template
    section for the application/json, Content-Type, as shown in the screenshot as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a1bf104-df97-4c44-8afa-cea7f0a2789f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With that out of the way, calling our API will result in a completely different
    structure of the return payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Provided the backend system contains the necessary data, it's possible to implement
    a complete API with an entirely different structure, writing nothing more than
    some API Gateway configuration and Velocity Templates. As mentioned earlier, there
    are many other advantages to API Gateway that you can leverage, which may be extremely
    useful when replacing a legacy API.
  prefs: []
  type: TYPE_NORMAL
- en: Complex integration using a Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our prior example is a best-case scenario. Because our new backend system included
    all of the data we needed to support our legacy API, our jobs were pretty easy.
    However, what happens in cases where the legacy API you need to support does not
    have a one-to-one mapping with a newer API? Of course, if you control the new
    API it's possible to implement any missing functionality. While that may be possible,
    it may not be a good idea since you may be reimplementing imperfect design in
    your new and clean RESTful API in order to support a legacy system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, rather than dirtying the new API, it''s possible to use a Lambda
    function as the Integration Type, rather than an HTTP endpoint. With this pattern,
    the Lambda function may act with some intelligence and perform any type of task
    that is needed. For example, imagine another legacy endpoint of `https://$HOSTNAME/get_posts_with_users`
    that returns a list of `posts` with the `user` records embedded in each post record.
    The new API returns `posts` with a structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our legacy API needs that payload to be returned in the form of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The new API has the user data available at the `/users` endpoint. Using a Lambda
    function, we can make two separate API calls and mash up the results ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to implement our application logic. The code will be very straightforward
    and I won''t cover the details. Everything can be implemented in a mere 42 lines
    of Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that our application logic is making the two HTTP requests to our backend
    and mashing up the results, we finally have our desired output format, where `user`
    records are embedded in the `post` records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying this consists of setting up a serverless *service* with a single
    endpoint. Interestingly, we''ll define our function in `serverless.yml` but will
    not use any event to trigger this function. The reason for this is that we will
    manually set up this function to be triggered by our existing API Gateway deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a new resource and method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to set up a new resource and `GET` method in API Gateway. This
    time, we''ll select Lambda Function as the Integration type. Also, we will want
    to check Use Lambda Proxy integration. The reason for choosing this now is that
    we can control details of the response from our application code run by Lambda.
    If there is a need to update headers or otherwise transform the response, we simply
    update our application code and redeploy the Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81b312da-7b79-41bf-add0-46b1b8c346ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the already deployed Lambda function, click Save, and we're all done.
    There is no need to update the Method Request or Integration since we may perform
    any transformations from the application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, deploy the API, hit the new API endpoint, and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Migration techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In these examples, we've taken a look at a few strategies for implementing a
    new API using existing API backends. Another common scenario is migrating an *existing*
    API to a serverless architecture, *without* changing any of its functionality.
    In this scenario, we can still use the proxy pattern and API Gateway. With all
    of the work in place ready to go, how does one actually deploy a new proxy layer
    without affecting existing traffic or breaking these clients? The following are
    a few techniques and deployment strategies that you may consider when faced with
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Staged migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To replace an existing API with a serverless-based system, it makes sense to
    first implement the proxy pattern and define the complete API in API Gateway.
    Each endpoint would simply proxy requests and responses to and from their corresponding
    APIs on the system to be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s even possible to start initial testing with what is called a **proxy
    resource**. With this model, one creates a resource in API Gateway named `{proxy+}`.
    This is a greedy resource and will match any URL path that doesn''t already exist,
    be it `/cats`, `/users/10/comments`, and so on. It will also match on any HTTP
    verb. In short, it''s a catch-all that will send any request that doesn''t match
    an existing resource on to the configure Integration backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34bf8d80-a3ee-4b06-b5eb-aa8ff4c583f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Doing this first is a good way to start testing the interaction between Gateway
    and your backend system since you can build out a full test suite without the
    fear of misconfiguring anything. Slowly, you may begin implementing and replacing
    different APIs one by one. In this fashion, you can work at your own pace without
    the fear of flipping a switch to move *all* APIs to some new system at once. If
    a single deployment of a new serverless API doesn't go well, rolling back takes
    mere seconds by deleting the resource and redeploying the API. Since the proxy
    resource will catch any non-matching URL paths, deleting a problematic resource
    simply points that URL path back to the original HTTP integration endpoint. This
    is as simple of a rollback procedure as you'll find.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the URLs provided by API Gateway are quite obscure
    and not easy to remember, for example, [https://eocmzivub6.execute-api.us-west-2.amazonaws.com](https://eocmzivub6.execute-api.us-west-2.amazonaws.com).
    In the example of replacing a legacy API from under existing users, the ideal
    scenario is to merely update DNS records.
  prefs: []
  type: TYPE_NORMAL
- en: For example, presume the API you're migrating is located at ` https://api.mysite.io` and
    that this URL is embedded across thousands of devices in a mobile application.
    Forcing users to update their code isn't feasible with thousands of clients. You
    know that there will be traffic to that subdomain for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'API Gateway provides the ability to apply a custom domain to an API and provides
    free SSL/TLS certificates. With those two features, a migration would be fairly
    straightforward. Assuming you''ve implemented and thoroughly tested the new API
    Gateway version of your API, the migration would consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up `api.mysite.io` as a custom domain in API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a TLS certificate for `api.mysite.io` from API Gateway (using Amazon
    Certificate Manager, ACM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating DNS to point to the API Gateway URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In cases where the URL is not running on a subdomain, life becomes more complex.
    For example, if you have an existing web application running at `https://mysite.io`
    and the API is found at `https://mysite.io/api`, changing DNS would not work since
    it would break it for the users of your web application. In this case, there are
    two viable options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use or set up some type of router or load balancer that supports path-based
    routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update application code to call the API Gateway endpoints for any request to
    `/api`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A load balancer such as HAProxy would work out well here since it provides path-based
    routing and is extremely fast. If it's not feasible to set up a system such as
    that, a final solution would be to manually proxy requests from your own application
    code to the API Gateway endpoint. That method isn't elegant, but technically it
    would work provided headers and query parameters are forwarded along to API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the proxy pattern using API Gateway from AWS.
    We walked through multiple examples of mimicking a legacy API using an existing
    RESTful URL as an HTTP integration. You learned the four stages of API Gateway
    method execution and some of the details surrounding each of those integration
    points. We also discussed the proxy pattern when integrating with an AWS Lambda
    function, which provides a bit more control at the expense of more maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Readers should understand the proxy pattern and have a rough idea of how to
    implement this themselves using API Gateway after this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll move our focus from web application patterns to those
    for data processing.
  prefs: []
  type: TYPE_NORMAL
