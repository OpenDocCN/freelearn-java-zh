<html><head></head><body>
		<div id="_idContainer063">
			<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor165"/>9</h1>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor166"/>Persistence Practices – Exploring Polyglot Persistence</h1>
			<p>Software development has become more complex, requiring way more integration, and we need to innovate simultaneously to make our lives easier. One good option is to take advantage of several databases with <span class="No-Break">polyglot persistence.</span></p>
			<p>When we talk about persistence solutions, there are around 400, with different types, structures, and particular behavior that make sense in specific cases. The philosophy of polyglot persistence is to use the tool to find the <span class="No-Break">right solution.</span></p>
			<p>This chapter will introduce the principle of polyglot persistence and how to use it <span class="No-Break">with Java.</span></p>
			<p>We will discuss the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>The trade-offs of <span class="No-Break">polyglot persistence</span></li>
				<li>Understanding <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) <span class="No-Break">and Jakarta</span></li>
				<li><span class="No-Break">Jakarta Data</span></li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>The following are the technical requirements for <span class="No-Break">the chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Git</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li>Any <span class="No-Break">preferred IDE</span></li>
			</ul>
			<p>The source code for the chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09"><span class="No-Break">https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-09</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor168"/>The trade-offs of polyglot persistence</h1>
			<p>Polyglot persistence is an<a id="_idIndexMarker386"/> approach to data storage in which multiple types of databases are used together to address different needs within an application. The<a id="_idIndexMarker387"/> term <strong class="bold">polyglot</strong> refers to the use of various languages or tools, and in this context, it refers to the use of multiple types <span class="No-Break">of databases.</span></p>
			<p>In traditional monolithic applications, a single database is typically used to store all data types. However, this approach can become less effective as applications become more complex. Polyglot persistence, however, allows developers to choose the best database for each use case based on factors such as scalability, data structure, and <span class="No-Break">query requirements.</span></p>
			<p>For example, a social media platform might use a document database such as MongoDB to store user profiles and activity feeds, a graph database such as Neo4j to analyze social connections, and a relational database such as MySQL to manage transactions <span class="No-Break">and payments.</span></p>
			<p>By leveraging multiple databases, polyglot persistence can help improve an application’s performance, scalability, and flexibility. However, it also comes with additional complexity in managing data consistency, migrations, and backups across <span class="No-Break">multiple systems.</span></p>
			<p>The idea of polyglots is always good and provides several opportunities for an application. The core idea is sound: taking advantage of a database in the perfect scenario is terrific. But, even with polyglot persistence, there are trade-offs, as with any software <span class="No-Break">architecture decision.</span></p>
			<p>More databases also mean greater cost and infrastructure knowledge to handle specific persistence solutions. Please be aware <span class="No-Break">of this.</span></p>
			<p>In Java, more databases mean more dependencies in the application, which might <em class="italic">add to the jar-hell headache</em>. The microservices approach will help you in this situation, <em class="italic">where each database in your environment has its own interface</em>; it also helps to isolate the technology from <span class="No-Break">the business.</span></p>
			<p>From a code design perspective, there is the Ports and Adapters pattern, or the Hexagonal model, where you can isolate the core logic of an application from the persistence layer. However, as mentioned, more layers mean more code overall, which means concerns about maintainability <span class="No-Break">and bugs.</span></p>
			<p>Starting simply with three layers, as<a id="_idIndexMarker388"/> in the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) architectural pattern, and isolating them is a good start, such as beginning with a monolith instead of microservices. When the need arises, go for it and refactor <span class="No-Break">the code.</span></p>
			<p>Sometimes, we only need some of these layers for our applications; starting with enough architecture is an excellent way to manage risk in <span class="No-Break">your architecture.</span></p>
			<p>Recognizing the abstraction from/to the business layer and avoiding coupling it with the persistence layer as much as possible is crucial to an <span class="No-Break">evolutionary architecture.</span></p>
			<p>Common sense <a id="_idIndexMarker389"/>and pragmatism are the best formulas to define the best pattern for each scenario. As advice, think of software as a long-term project; we don’t need to design a sophisticated Netflix-style architecture on the <span class="No-Break">first day.</span></p>
			<p>Based on the best practices, enjoying, taking advantage of, and exploring databases to take advantage of your system is possible. In the following figure, based on James Serra’s article <em class="italic">What is Polyglot Persistence?</em> (<a href="https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/">https://www.jamesserra.com/archive/2015/07/what-is-polyglot-persistence/</a>), you can get more context for which database is best suited to or a good candidate for a given scenario. It describes what type of database is recommended to address recurrent and key requirements of the listed <span class="No-Break">use cases:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 9.1 – Use cases and database types" src="image/Figure_9.01_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Use cases and database types</p>
			<p>Those are some possibilities of database uses based on the type; when we talk about NoSQL, remember that in some classes, there is particular behavior that makes sense and is <span class="No-Break">worth using.</span></p>
			<p>For long-term <a id="_idIndexMarker390"/>applications, migration is possible. The isolation can help you in the polyglot journey. The following section will introduce <strong class="bold">DDD</strong>, its impacts on the persistence layer, and how Jakarta can help us on <span class="No-Break">this journ<a id="_idTextAnchor169"/>ey.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor170"/>Understanding DDD and Jakarta</h1>
			<p>DDD is an approach<a id="_idIndexMarker391"/> to<a id="_idIndexMarker392"/> software development that focuses on understanding the problem domain and modeling it in code. DDD is based on the idea that the problem domain should be the primary focus of development and that the software should be designed to reflect the underlying domain concepts <span class="No-Break">and processes.</span></p>
			<p>DDD distinguishes between strategic and tactical design. Strategic design refers to the overall architecture and organization of the software, while tactical design refers to the detailed design of individual components <span class="No-Break">and modules.</span></p>
			<p>In strategic design, DDD emphasizes the importance of defining a clear and consistent domain model that represents the business concepts and processes in the problem domain. This model should be independent of any particular technology or implementation and should be based on a deep understanding of the domain. Strategic design also involves defining bounded contexts and specific domain areas with well-defined boundaries modeled separately from other parts of <span class="No-Break">the domain.</span></p>
			<p>Tactical design, on the other hand, focuses on the details of how individual components and modules are designed and implemented. DDD uses patterns and techniques such as aggregates, entities, value objects, and repositories to model and manipulate the domain objects in the <span class="No-Break">tactical design.</span></p>
			<p>DDD can<a id="_idIndexMarker393"/> significantly <a id="_idIndexMarker394"/>impact the different layers of a software application, including the presentation layer, application layer, domain layer, and persistence layer. Here’s a brief overview of how DDD can apply to and impact <span class="No-Break">each layer:</span></p>
			<ul>
				<li><strong class="bold">The presentation layer</strong>: DDD can <a id="_idIndexMarker395"/>impact the presentation layer by providing a clear and consistent domain model that can be used to guide the design of user interfaces and user interactions. The presentation layer should reflect the domain model. It should provide a user-friendly interface that enables users to interact with the application in a way that makes sense from a <span class="No-Break">domain perspective.</span></li>
				<li><strong class="bold">The application layer</strong>: DDD can impact the application layer by providing a clear and consistent set of services and operations that reflects the business processes and workflows in the domain. The application layer should be designed to support the domain model and should provide a layer of abstraction, which enables the domain layer to focus on business logic rather than <span class="No-Break">implementation details.</span></li>
				<li><strong class="bold">The domain layer</strong>: DDD has the most significant impact on the domain layer, which is the heart of the application. In the domain layer, DDD emphasizes the importance of modeling the domain using a rich and expressive language that reflects the business concepts and processes. The domain layer should be designed to be independent of any specific technology or implementation and focused on encapsulating business logic and <span class="No-Break">domain knowledge.</span></li>
				<li><strong class="bold">The persistence layer</strong>: DDD can also impact the persistence layer by providing a clear and consistent way of mapping domain objects to the database. DDD emphasizes repositories, which provide a layer of abstraction between the domain layer and the persistence layer. Repositories enable the domain layer to focus on <a id="_idIndexMarker396"/>business logic rather than database access and provide a way to ensure that domain objects are persisted and retrieved consistently <span class="No-Break">and reliably.</span></li>
			</ul>
			<p>Overall, DDD can significantly impact the design and architecture of a software application and can help ensure that the application is focused on the problem domain rather than implementation details. DDD can help create more maintainable and scalable software that is adaptable to changing business requirements by providing a clear and consistent domain model and a set of design patterns <span class="No-Break">and techniques.</span></p>
			<p>The repository pattern is a design pattern that provides a layer of abstraction between the domain layer and the persistence layer. The repository pattern encapsulates the logic for accessing and persisting domain objects. It provides a way to ensure that domain objects are stored and retrieved consistently <span class="No-Break">and reliably.</span></p>
			<p>Using repositories, the domain layer can be designed to be independent of the persistence layer. It can be focused on modeling business processes and workflows using rich and<a id="_idIndexMarker397"/> expressive<a id="_idIndexMarker398"/> language. The repository pattern can significantly impact the persistence layer by enabling the domain layer to focus on business logic and domain knowledge rather than implementation details such as database access <span class="No-Break">and querying.</span></p>
			<p>The repository pattern is typically implemented as an interface in the domain layer, with a concrete implementation in the persistence layer. The repository interface defines a set of methods for storing, retrieving, and querying domain objects. The concrete implementation provides the actual implementation of these methods using the persistence technology of choice (such as a relational or <span class="No-Break">NoSQL database).</span></p>
			<p>One of the key benefits of the repository pattern is that it enables the domain layer to be decoupled from the persistence layer, making the application more modular and easier to maintain. By separating concerns and encapsulating logic, the repository pattern can ensure that the application is more flexible and adaptable to <span class="No-Break">changing requirements.</span></p>
			<p>The repository pattern is often compared<a id="_idIndexMarker399"/> to the <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) pattern, another design pattern for accessing and persisting data. The main difference between a repository and a DAO is a repository is designed to encapsulate the logic for accessing and persisting domain objects. In contrast, a DAO is designed to encapsulate general logic for accessing and persisting data. The following figure shows the sequence starting from the controller to<a id="_idIndexMarker400"/> the<a id="_idIndexMarker401"/> database and returning to <span class="No-Break">the controller.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 9.2 – Sequence from the controller to the database" src="image/Figure_9.02_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Sequence from the controller to the database</p>
			<p>In other words, a DAO is typically focused on low-level details, such as database connections, transactions, and SQL statements. In contrast, a repository focuses on the domain model’s higher-level concerns. While both patterns can be used for persistence, the repository pattern is often considered more aligned with the principles of DDD, as it provides a way to ensure that the persistence layer is designed to support the domain model and <span class="No-Break">business logic.</span></p>
			<p>Where does the data come from? We don’t need to know the source of the database, whether it comes from SQL, NoSQL, or a web service. The client does need <span class="No-Break">to know.</span></p>
			<p>The following figure shows this idea, where we have the business layer injecting a persistence layer, and it does matter where the data source comes from; it might be coming from all of the <span class="No-Break">sources simultaneously.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 9.3 – A DDD repository representation" src="image/Figure_9.03_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – A DDD repository representation</p>
			<p>Let’s see some code <a id="_idIndexMarker402"/>to <a id="_idIndexMarker403"/>explore the capabilities of Jakarta Data in the first version that released the repository feature. As with MicroStream, we’ll start with Java SE and then move the application to Jakarta EE. We’ll create two CRUD operations using both the <strong class="source-inline">Developer</strong> and <strong class="source-inline">Airplane</strong> entities, where the second will handle simple <span class="No-Break">pa<a id="_idTextAnchor171"/>gination code.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor172"/>Jakarta Data</h1>
			<p>Designing an application<a id="_idIndexMarker404"/> with multiple database systems is one of the hardest things to do in the software world. Fortunately, there is a specification that makes it easier to implement polyglot persistence in Java. It is a persistence-agnostic API that connects to different types of databases and storage sources seamlessly. The API offered by Jakarta Data enables convenient access to data technologies, making it possible for Java developers to divide their persistence and model concerns into distinct features. For instance, a repository interface can be created with a query method that the framework <span class="No-Break">will implement.</span></p>
			<p>Exploring agnostic design patterns is one of the goals of Jakarta Data; the first feature of this specification is the DDD repository pattern. The objective of the repository is to facilitate polyglot persistence without impacting <span class="No-Break">the business.</span></p>
			<p>Starting with dependencies, from now on, we’ll add only the API; then, we’ll start to explain the implementations. So, we’ll include the Jakarta <span class="No-Break">Data dependency:</span></p>
			<pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;jakarta.data&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta-data-api&lt;/artifactId&gt;
    &lt;version&gt;${data.version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>We will create both the <strong class="source-inline">Developer</strong> and <strong class="source-inline">Airline</strong> entities. In the Jakarta Data API, we must define the entity and its IDs using <strong class="source-inline">@Entity</strong> and <strong class="source-inline">@Id</strong>, respectively. Hey, how about adding other fields? It varies with the implementation; for example, in JPA, this is enough, whereas in Jakarta NoSQL, we need to identify the other fields with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Column</strong></span><span class="No-Break"> annotation:</span></p>
			<pre class="source-code">
@Entitypublic class Developer {
    @Id
    private String nickname;
    private String name;
    private String city;
    private String language;
}
@Entity
public class Airplane {
    @Id
    private String model;
    private String manufacturer;
    private String nationality;
    private int seats;
}</pre>
			<p>We have the entities; the next step is the persistence layer with a repository. Once we have two different entities, we’ll create two <span class="No-Break">separate repositories.</span></p>
			<p>This interface provides several methods the user doesn’t need to implement; the vendor will implement them. The first one relates to the <strong class="source-inline">Developer</strong> entity and uses the most basic repository: <strong class="source-inline">CrudDataRepository</strong>. Furthermore, there is the method that uses querying, where you can, using the convention, create queries that you don’t need to implement; the vendor will <span class="No-Break">implement them.</span></p>
			<p><strong class="source-inline">DeveloperRepository</strong> is the Developer repository, an interface that extends <strong class="source-inline">CrudDataRepository</strong>. Now we will go through several methods; furthermore, we will create a query<a id="_idIndexMarker405"/> to find by language using the <span class="No-Break"><strong class="source-inline">findByLanguage</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
@Repositorypublic interface DeveloperRepository extends
  CrudRepository&lt;Developer, String&gt; {
    List&lt;Developer&gt; findByLanguage(String language);
}</pre>
			<p>The next step is the <strong class="source-inline">Airplane</strong> repository, so we have our <strong class="source-inline">Hangar</strong>, but wait!? Should it be <strong class="source-inline">AirplaneRepository</strong> instead? We have a convention of using the <strong class="source-inline">Repository</strong> suffix. However, you can use the collection of the entity, such as <strong class="source-inline">Garage</strong> for a collection of cars or <strong class="source-inline">Team</strong> for a collection <span class="No-Break">of players.</span></p>
			<p>The <strong class="source-inline">Hangar</strong> interface extends a different interface, this time, <strong class="source-inline">PageableRepository</strong>. It is a specialization that enables pagination resources. It uses the query method and returns a <strong class="source-inline">Page</strong> interface to work with a slice of information <span class="No-Break">on airplanes:</span></p>
			<pre class="source-code">
@Repositorypublic interface Hangar extends
  PageableRepository&lt;Airplane, String&gt; {
    Page&lt;Hangar&gt; findByManufacturer(String manufacturer,
      Pageable pageable);
}</pre>
			<p>Finally, we have both code repositories ready for execution. Starting with the <strong class="source-inline">Developer</strong> repository, we’ll create developers, find them by ID, delete them by ID, and use the method we made, which<a id="_idIndexMarker406"/> is querying <span class="No-Break">by language:</span></p>
			<pre class="source-code">
public class App {    public static void main(String[] args) {
        try (SeContainer container =
         SeContainerInitializer.newInstance().initialize()) {
            DeveloperRepository repository = container
              .select(DeveloperRepository.class).get();
            Developer otavio = Developer.builder()
                    .name("Otavio Santana")
                    .city("Salvador")
                    .nickname("ptavopkava")
                    .language("Java")
                    .build();
            Developer kvarel4 = Developer.builder()
                     .name("Karina Varela")
                    .city("Brasília")
                    .nickname("kvarel4")
                    .language("Java")
                    .build();
            repository.save(otavio);
            repository.save(kvarel4);
            Optional&lt;Developer&gt; developer = repository
              .findById(otavio.getNickname());
            List&lt;Developer&gt; java = repository
              .findByLanguage("Java");
            System.out.println("Java developers: " + java);
            repository.delete(otavio);
        }
    }</pre>
			<p>The next step is to execute the pagination resource with pagination in our Hangar. Once we have a few airplanes added, we’ll include pagination with a size of two elements. In the real world, the <a id="_idIndexMarker407"/>number is more considerable. It will vary based on the area and context; it is often between 10 <span class="No-Break">and 100:</span></p>
			<pre class="source-code">
try (SeContainer container =  SeContainerInitializer.newInstance().initialize()) {
        Hangar hangar = container
          .select(Hangar.class).get();
        Airplane freighters = Airplane.builder()
         .model("Freighters")
                .manufacturer("Boeing")
                .nationality("United States")
                .seats(149)
                .build();
        Airplane max = Airplane.builder().model("Max")
                .manufacturer("Boeing").nationality("United
                 States")
                .seats(149)
                .build();
        Airplane nextGeneration = Airplane.builder()
                 .model("Next-Generation 737")
                .manufacturer("Boeing").nationality("United
                 States")
                .seats(149)
                .build();
        Airplane dreamliner = Airplane.builder()
                .model("Dreamliner")
                .manufacturer("Boeing").nationality("United
                 States")
                .seats(248)
                .build();
        hangar.saveAll(List.of(freighters, max,
          nextGeneration));
        Pageable pageable = Pageable.ofSize(1)
                .sortBy(Sort.asc("manufacturer"));
        Page&lt;Airplane&gt; page = hangar.findAll(pageable);
        System.out.println("The first page: " +
          page.content());
        Pageable nextPageable = page.nextPageable();
        Page&lt;Airplane&gt; page2 =
          hangar.findAll(nextPageable);
        System.out.println("The second page: " +
          page2.content());
    }</pre>
			<p>We have both running on Java SE; let’s move on to the next stage, which is pushing the same code to <strong class="source-inline">MicroProfile</strong> to create a microservice. In the chapter about <strong class="source-inline">MicroStream</strong> in <a href="B19375_08.xhtml#_idTextAnchor151"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we <a id="_idIndexMarker408"/>explained the CDI engine/core; we’ll follow the same principle – copy/paste the same code and change the access to make it a rest resource instead of a Java <span class="No-Break">SE application:</span></p>
			<pre class="source-code">
@ApplicationScoped@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Path("developers")
public class DeveloperResource {
    private final DeveloperRepository repository;
    @Inject
    public DeveloperResource(DeveloperRepository
     repository) {
        this.repository = repository;
    }
    @GET
    public List&lt;Developer&gt; getDevelopers() {
        return this.repository.findAll()
         .collect(Collectors.toUnmodifiableList());
    }
    @GET
    @Path("{id}")
    public Developer findById(@PathParam("id") String id) {
        return this.repository.findById(id)
        .orElseThrow(() -&gt; new WebApplicationException
         (Response.Status.NOT_FOUND));
    }
    @PUT
    public Developer insert(Developer developer) {
        return this.repository.save(developer);
    }
    @DELETE
    @Path("{id}")
    public void deleteById(@PathParam("id") String id) {
        this.repository.deleteById(id);
    }
}</pre>
			<p>We showed the pure API, but how about the implementations? To display the number of options, we have a repository that illustrates an implementation of the particular behavior to each <a id="_idIndexMarker409"/>example in our <strong class="source-inline">git</strong> remote. You can try out, run, and get a feel for the difference between vendors and <span class="No-Break">per<a id="_idTextAnchor173"/>sistence solutions.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor174"/>Summary</h1>
			<p>Polyglot persistence is a good path to advance most enterprise applications. It is possible to explore SQL, NoSQL, or any persistence solution with this approach. However, as with any architectural decision, pay attention to the trade-offs; an abstraction can ensure that the choice of database will not impact the <span class="No-Break">business perspective.</span></p>
			<p>Jakarta Data helps standardize behavior and code patterns. It helps us build a universe of capabilities out of several persistence solutions. It is promising solution to increase the capabilities around data persistence patterns on Java, and it is open for help and feedback; join us to make our lives even easier when working with <span class="No-Break">this tool.</span></p>
			<p>It’s now time to explore, at an architectural level, the integration practices that allow us to explore the best out-of-data integration patterns in modern <span class="No-Break">cloud-oriented solutions.</span></p>
		</div>
	</body></html>