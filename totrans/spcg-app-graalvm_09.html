<html><head></head><body>
		<div id="_idContainer124">
			<h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor120"/>Chapter 6</em>: Truffle – An Overview</h1>
			<p><a id="_idTextAnchor121"/>Support for polyglot development is one of the biggest features of GraalVM. In <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>, and <a href="B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Graal Ahead-of-Time Compiler and Native Image</em>, we went into a lot of detail on how Graal optimizes code, both at build time and run time. We have only used Java in all the previous chapters. However, GraalVM extends most of its advanced features to other programming languages too. GraalVM provides a language implementation framework called <strong class="bold">Truffle Language Implementation Framework</strong> (commonly known as <strong class="bold">Truffle</strong>).</p>
			<p>GraalVM not only provides a high-performance runtime for JVM languages such as Java, Groovy, Kotlin, and Scala, but it also supports non-JVM languages such as JavaScript, Ruby, Python, R, WebAssembly, and LLVM languages that implement Truffle. A lot more languages are being implemented on Truffle.</p>
			<p>This chapter provides a conceptual view of how Truffle helps guest language developers and provides a well-designed, high-performance framework to build applications using guest languages on top of GraalVM. This chapter does not get into too much detail on how to write in guest languages using Truffle. This is only intended to describe Truffle's architecture and concepts at a high level so that you can follow the subsequent chapters on how non-JVM languages are implemented on GraalVM.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring the Truffle language implementation framework</li>
				<li>Exploring the Truffle interpreter/compiler pipeline</li>
				<li>Learning Truffle DSL</li>
				<li>Understanding how Truffle supports interoperability</li>
				<li>Understanding Truffle instrumentation</li>
				<li>Ahead-of-time compilation using Truffle</li>
				<li>Optimizing Truffle interpreter performance with launcher options</li>
				<li>SimpleLanguage and Simple Tool</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of Truffle's architecture, and how Truffle provides a framework for other programming languages to run on GraalVM.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor122"/>Exploring the Truffle language implementation framework</h1>
			<p>In <a href="B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">GraalVM Architecture</em>, in the Truffle section, we briefly covered the architecture of Truffle. Truffle is an <a id="_idIndexMarker494"/>open source library that provides a framework to implement language interpreters. Truffle helps run guest programming languages that implement the framework to utilize the Graal compiler features to generate high-performance code. Truffle also provides a reference implementation called SimpleLanguage to guide developers to write interpreters for their languages. Truffle also provides a tools framework that helps integrate and utilize some of the modern diagnostic, debugging, and analysis tools. </p>
			<p>Let's understand how Truffle fits into the overall GraalVM ecosystem. Along with interoperability between the languages, Truffle also provides embeddability. Interoperability allows <a id="_idIndexMarker495"/>the calling of code between different languages, while embeddability allows the <a id="_idIndexMarker496"/>embedding of code written in different languages in the same program.</p>
			<p>Language interoperability is critical for the following reasons:</p>
			<ul>
				<li>Different programming languages are built to solve different problems, and they come with their own strengths. For example, we use Python and R extensively for machine learning and data analytics, and we use C/C+ for high-performance mathematical operations. Imagine if we would reuse the code as it is, either by calling the code from a host language (such as Java) or embedding that code within the host language. This also increases the reusability of the code and allows us to use an appropriate language for the task at hand, rather than rewriting the logic in different languages.</li>
				<li>Large migration projects where we are moving from one language to another can be phased out if we have the feature of multiple programming language interoperability. This brings down the risk of migration considerably.</li>
			</ul>
			<p>The following figure illustrates how to run applications written in other languages on GraalVM:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B16878_Figure_6.1.jpg" alt="Figure 6.1 – Truffle stack &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Truffle stack </p>
			<p>In the figure, we can see GraalVM, which is the JVM and Graal JIT compiler that we covered in the previous chapters. On top of that, we have the Truffle framework. Truffle has two major components. They are as follows:</p>
			<ul>
				<li><strong class="bold">Truffle API</strong>: The Truffle API is the language <a id="_idIndexMarker497"/>implementation framework that any guest language programmers can use to <a id="_idIndexMarker498"/>implement the Truffle interpreter for their respective languages. Truffle provides a sophisticated API for <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>) rewriting. The guest language is converted to AST for optimizing and running on GraalVM. The Truffle API also helps in providing an interoperability framework between languages that implement the Truffle API.</li>
				<li><strong class="bold">Truffle optimizer</strong>: The Truffle optimizer <a id="_idIndexMarker499"/>provides an <a id="_idIndexMarker500"/>additional layer of optimization for speculative optimization with partial evaluation. We will be going through this in more detail in the subsequent sections.</li>
			</ul>
			<p>Above the Truffle layer, we have the guest language. This is JavaScript, R, Ruby, and others that implement the Truffle Language Implementation framework. Finally, we have the application that runs on top of the guest language runtime. In most cases, application developers don't have to worry about changing the code to run on GraalVM. Truffle makes it seamless by providing a layer in between. The following diagram shows a detailed stack view of the GraalVM and Truffle ecosystem:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B16878_Figure_6.2.jpg" alt="Figure 6.2 – Truffle and Graal detailed stack view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Truffle and Graal detailed stack view</p>
			<p>This diagram is a <a id="_idIndexMarker501"/>simple representation of how Truffle acts as a layer between non-JVM languages and GraalVM. Let's understand this in detail. </p>
			<p>Truffle provides the API that the individual interpreters implement to rewrite the code into ASTs. The AST representation is later converted to a Graal intermediate representation for Graal to execute and also optimize just in time. The guest languages run on top of the Truffle interpreter implementations of the respective guest languages.</p>
			<p>Let's look at how these various layers interact and how Truffle helps the guest language to run on GraalVM.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor123"/>Exploring the Truffle interpreter/compiler pipeline</h1>
			<p>Truffle provides a Java library that can be <a id="_idIndexMarker502"/>used to write AST interpreters in Java for any language. The guest language semantics are expressed as an AST using the AST interpreters. Graal and Truffle specify the exact format of AST, and the framework enforces this specification. So, any guest language AST interpreter written using Truffle Language Implementation API will generate the semantics of the language in AST that GraalVM can then use to optimize just in time and run. The following figure provides a detailed flow of how Truffle and Graal work:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B16878_Figure_6.3.jpg" alt="Figure 6.3 – Truffle and Graal compilation pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Truffle and Graal compilation pipeline</p>
			<p>Let's understand the flow diagram better.</p>
			<p>The guest languages are <a id="_idIndexMarker503"/>parsed using a traditional syntactical and lexical analyzer. This generates an AST. The AST is an intermediate representation built as per the Truffle/Graal specifications. The AST is a tree structure where each parent node is an operation/function, and the child nodes are data/operands/dependencies. Each node that is part of the AST has an <strong class="source-inline">execute()</strong> method. The <strong class="source-inline">execute()</strong> method implements the semantics of the corresponding language construct. The guest language developers are supposed to design these nodes and provide facilities to parse the guest language code and build the tree. The following code snippet shows the abstract node object:</p>
			<p class="source-code">abstract class Node {</p>
			<p class="source-code">    // Executes the operation encoded by this</p>
			<p class="source-code">    // node and returns the result.</p>
			<p class="source-code">    public abstract Object execute(Frame f);</p>
			<p class="source-code">    // Link to the parent node and utility to</p>
			<p class="source-code">    // replace a node in the AST.</p>
			<p class="source-code">    private Node parent;</p>
			<p class="source-code">    protected void replace(Node newNode);</p>
			<p class="source-code">}</p>
			<p>All the node types implement this abstract node. AST interpreters go through the AST node by node to execute using a stack frame to keep track of the execution and data. AST interpreters are easy to implement but have huge performance overheads. Let's now look at how Truffle interpreters optimize the AST by rewriting the tree. </p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor124"/>Self-optimization and tree rewriting</h2>
			<p>The structure of the AST can be <a id="_idIndexMarker504"/>dynamically changed by rewriting. This is also sometimes referred to as AST rewriting. The AST interpreter can rewrite the AST dynamically based on the runtime profiling. This improves the performance significantly. The nodes can be updated at runtime by rewriting based on the runtime profiling and optimizing the AST.</p>
			<p>One of the biggest issues with dynamic languages, from a performance perspective, is the type declarations (unlike languages such as C, where the type is specified in the code). The types are not declared at coding time, which means the variables, at the start of the execution, may assume any type. The profiler can figure out the specific type after a few runs and can then specialize the type of the variables based on the runtime profiling. It then rewrites the AST with the specific type. This technique is called <strong class="bold">Type Specialization</strong>. This has a <a id="_idIndexMarker505"/>significant performance boost, as the operations/methods that are performed on this data can be specialized to the data type. The Truffle interpreter leaves a speculation <em class="italic">guard</em> in case the speculation/assumption made on the type is proven wrong in future executions. In this case, the guard is invoked to deoptimize the AST.</p>
			<p>Tree rewriting also <a id="_idIndexMarker506"/>happens when an operation/function has to be resolved at runtime. This is very important for the dynamic resolution of function or operations, due to <a id="_idIndexMarker507"/>polymorphic implementations of the operations or functions. When the profiler identifies a specific implementation of the function/operation, the resolved function/operation can be rewritten. A simple diagram that illustrates operation resolution follows this paragraph. The <strong class="source-inline">Node</strong> class has the <strong class="source-inline">replace()</strong> method, which is used for rewriting. The following figure illustrates a very simple expression, and shows how the AST gets rewritten after profiling:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B16878_Figure_6.4.jpg" alt="Figure 6.4 – AST specialization illustration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – AST specialization illustration</p>
			<p>On the left <a id="_idIndexMarker508"/>side of the figure, the Truffle interpreter starts off as a generic AST node. Based on the profiler, the interpreter understands that it's mostly a specific type value, let's say an integer. It will rewrite the nodes with integer types and the <a id="_idIndexMarker509"/>operation nodes with integer operations. This optimizes the execution of the AST. In the left-most representation, + might mean the <a id="_idIndexMarker510"/>concatenation of strings or the addition of integers or longs or floats, or any other polymorphic execution of the operation that is reduced to the right-most representation, where it is very clearly an integer. A guard check is placed there in case the assumption made is proven wrong in the future. If the operands happen to be floats, or some other type, then a deoptimization is invoked, which might take it back to the left-most representation. The Truffle interpreter will once again profile to identify the right type specializations to apply. It may identify that it is more of a long or double, so it might rewrite the AST as a double and optimize. Type specialization is applied to local variables, return types, operations, and fields.</p>
			<p>AST rewriting based on type specialization provides a significant boost to performance, and by the time we get to more advanced optimizations that the Graal performs, we have a very stable AST.</p>
			<p>Since the AST interpreters are <a id="_idIndexMarker511"/>implemented in Java, the node <strong class="source-inline">execute()</strong> method is written to handle a generic object. Type specialization also helps by replacing the <strong class="source-inline">execute()</strong> method with a specialized <strong class="source-inline">executeInt()</strong> method, and also reduces the load on the CPU for boxing and unboxing by replacing the wrapper implementations (<strong class="source-inline">Integer</strong>, <strong class="source-inline">Double</strong>, and so on) with primitive types (<strong class="source-inline">int</strong>, <strong class="source-inline">double</strong>). This <a id="_idIndexMarker512"/>technique is sometimes referred to as <em class="italic">boxing elimination</em>.</p>
			<p>Once the interpreter finds <a id="_idIndexMarker513"/>that there are no node rewrites, that means that the AST has been stable. The code is then compiled to machine code, and all the virtual calls are inlined with specific calls. This code is then passed to the Graal JIT compiler for further <a id="_idIndexMarker514"/>optimization at runtime. This is <a id="_idIndexMarker515"/>called <strong class="bold">partial evaluation</strong>. Guards are embedded into the code in case the assumptions made are valid. When any of the assumptions made are invalid, a guard code will bring back the execution to the AST interpreter, where node rewriting will once again happen. This is <a id="_idIndexMarker516"/>called <strong class="bold">Transfer to Interpreter</strong>.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor125"/>Partial Evaluation</h2>
			<p>The calls to these <strong class="source-inline">execute()</strong> methods are virtual dispatches, which have a significant overhead on the <a id="_idIndexMarker517"/>performance. As Truffle identifies the code that is stabilized, when no more AST rewriting happens and the code has a lot of calls, it performs <a id="_idIndexMarker518"/>partial evaluation to improve the performance of the execution of this code. Partial evaluation includes inlining the code, eliminating the virtual dispatches and replacing them with direct calls, and building a combined unit that will be submitted to the Graal compiler for further optimization. Truffle places guard points wherever the assumptions made might be disproved. These guard points trigger the deoptimization by invalidating the code and switching back to interpreter mode of execution. The <a id="_idIndexMarker519"/>code is then compiled to machine <a id="_idIndexMarker520"/>code for the guest language after aggressive constant folding, inlining, and escape analysis. Truffle performs inlining on the AST so that it is language agnostic. The inlining decisions are taken by performing partial evaluation on every candidate.</p>
			<p>In the next section, we'll have a look at the Truffle framework in GraalVM, which is used to create DSLs.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/>Learning Truffle DSL</h1>
			<p>Truffle defines a <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>) based on the <a id="_idIndexMarker521"/>Java annotation processor. The language developer has to write a lot of boilerplate code to manage the states of the specializations. To appreciate how Truffle DSL makes a programmer's life easy, let's take a quick example:</p>
			<p class="source-code">c = a + b</p>
			<p>As we discussed earlier in this chapter, in AST, every operation and operand is represented as a node. In Truffle, it is a Java class derived from <strong class="source-inline">com.oracle.truffle.api.nodes.Node</strong>. To understand the need for a DSL, let's oversimplify the implementation of AST for the preceding expression. </p>
			<p>Since we are looking at dynamically typed languages, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> can be any type. We need an expression node that should implement an <strong class="source-inline">execute</strong> method, which checks for all the possible types for <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. We will have to write logic something like this: </p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B16878_Figure_6.5.jpg" alt="Figure 6.5 – Guard checks for implementing specialization – flow chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Guard checks for implementing specialization – flow chart</p>
			<p>In the preceding flow chart, we are checking for <a id="_idIndexMarker522"/>all possible combinations of operand types and evaluating the expression based on that, and if none of these conditions satisfy, it throws a <strong class="source-inline">TypeError</strong> exception. This kind of logic needs to be written in the Truffle interpreter, as we are dealing with dynamically typed languages.</p>
			<p>If we convert this to Truffle interpreter code, this is a lot of code for a very simple expression. Imagine if we have more complex expressions and other operations and functions. The Truffle interpreter code will be a nightmare to write and manage.</p>
			<p>This is where Truffle DSL solves the issue. Truffle DSL provides a very well-defined framework of node hierarchy, annotations, and annotation processors that can be used to handle this type of dynamism. </p>
			<p>The <strong class="source-inline">@Specialization</strong> annotation is a specialization annotation <a id="_idIndexMarker523"/>implemented by the <strong class="source-inline">com.oracle.truffle.api.dsl.Specialization</strong> class, and this is used as an annotation for all the possible evaluation cases (green boxes in the previous figure). Truffle DSL compiles this into a dynamic code where Truffle picks the right implementation (the first in the sequence) based on the operand parameters. The language developer code will look something like the following code snippet:</p>
			<p class="source-code">@Specialization protected long executeAddInt (int left, int right) {</p>
			<p class="source-code">    return left + right;</p>
			<p class="source-code">}</p>
			<p class="source-code">@Specialization String executeAddFloat (Float left, Float right) {</p>
			<p class="source-code">    return left + right;</p>
			<p class="source-code">}</p>
			<p class="source-code">@Specialization String executeAddString (String left, String right) {</p>
			<p class="source-code">    return left + right;</p>
			<p class="source-code">}</p>
			<p>The preceding code shows <a id="_idIndexMarker524"/>how Truffle DSL simplifies the job, and there is no need to write a lot of <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> statements. Truffle DSL annotations take care of compiling and generating that code for us. And finally, to handle the exception case, we can use the @<strong class="source-inline">Fallback</strong> annotation implemented by the <strong class="source-inline">com.oracle.truffle.api.dsl.Fallback</strong> class. The fallback code block will look something like the following code snippet:</p>
			<p class="source-code">@Fallback protected void typeError (Object left, Object right) {</p>
			<p class="source-code">    throw new TypeException("type error: args must be two     integers or floats or two", this);</p>
			<p class="source-code">}</p>
			<p>As mentioned before, Truffle <a id="_idIndexMarker525"/>picks the right implementation based on the operand types dynamically, by default. However, this can be also modified by declaring guards with the <strong class="source-inline">@Specilization</strong> annotation. Four types of guard can be <a id="_idIndexMarker526"/>declared for the <strong class="source-inline">@Specialization</strong> annotation. They are as follows:</p>
			<ul>
				<li><strong class="bold">Type guard</strong>: Type guards pick the <a id="_idIndexMarker527"/>specialized method based on the parameter types. The parameter values are checked for the <a id="_idIndexMarker528"/>type and if the operand (or child nodes annotated as <strong class="source-inline">@NodeChild</strong> in the <strong class="source-inline">Node</strong> class declaration) types match, then that particular method is executed.</li>
				<li><strong class="bold">Expression guard</strong>: The language developer can <a id="_idIndexMarker529"/>declare specific custom expressions in the <strong class="source-inline">@Specification</strong> annotation. The <a id="_idIndexMarker530"/>expressions are very simple Java-like code that evaluates to a Boolean value. If this expression is evaluated to true, then that particular method is executed; if it is false, the interpreter skips that execution. Here is a simple example:<p class="source-code">@Specialization(guards = {"!isInteger(operand)",    "!isFloat(operand)"})</p><p class="source-code">protected final int executeTheMethod(final Object operand) {</p><p class="source-code">  //....code to execute if the expression is true</p><p class="source-code">}</p><p>In the preceding code, the <strong class="source-inline">executeTheMethod()</strong> method gets picked by the Truffle interpreter if the expression that is passed in <strong class="source-inline">guards</strong> is <strong class="source-inline">true</strong>. In this case, it will be true if the operand is not an integer and is not a float. <strong class="source-inline">guards</strong> is actually a <a id="_idIndexMarker531"/>String array attribute in <strong class="source-inline">com.oracle.truffle.api.dsl.Specialization</strong>. We can pass <a id="_idIndexMarker532"/>multiple expressions.</p></li>
				<li><strong class="bold">Event guard</strong>: An event guard is a <a id="_idIndexMarker533"/>powerful way to handle exception cases. Let's assume in the flowchart depicted in <em class="italic">Figure 6.5</em> we have an evaluation that might throw an exception, such as <strong class="source-inline">ArthimeticException</strong>. We <a id="_idIndexMarker534"/>could have multiple specialization implementations to rewrite that execution to handle exception cases. To understand this better, let's look at the following code example:<p class="source-code">@Specialization(rewriteOn = ArithmeticException.class)</p><p class="source-code"> int executeNoOverflow(int a, int b) {</p><p class="source-code">    return Math.addExact(a, b);</p><p class="source-code"> }</p><p class="source-code"> @Specialization</p><p class="source-code"> long executeWithOverflow(int a, int b) {</p><p class="source-code">    return a + b;</p><p class="source-code"> }</p><p>In this code, Truffle <a id="_idIndexMarker535"/>will call the <strong class="source-inline">executeWithOverflow()</strong> method when integer types are matching (type guard), but if the integer values cause an overflow, <strong class="source-inline">ArthimeticException</strong> is thrown. In that case, Truffle will use the <strong class="source-inline">executeNoOverflow()</strong> method to overwrite the add method. This is an example of node rewriting based on specialization, which we discussed previously in this chapter.</p></li>
				<li><strong class="bold">Assumption guard</strong>: An <strong class="source-inline">Assumption</strong> object is <a id="_idIndexMarker536"/>used by <a id="_idIndexMarker537"/>Truffle to validate and invalidate an assumption where <strong class="source-inline">com.oracle.truffle.api.Assumption</strong> is an interface. Once an assumption is invalidated, it can never be valid in that runtime. This is used by Truffle to take decisions on optimization and deoptimization. It is like a global Boolean flag. The language developer can invalidate an assumption <a id="_idIndexMarker538"/>programmatically to let the Truffle runtime know that a particular assumption is no longer valid, and accordingly the Truffle <a id="_idIndexMarker539"/>runtime can take decisions. Assumption objects are typically stored in the nodes as final fields. An assumption guard is used to pick a specialization method if the assumptions are true.</li>
			</ul>
			<p>Based on these various annotations, Truffle will generate the actual <strong class="source-inline">execute()</strong> method with all the <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> controls to make sure the right version of the method is called based on the constraints that we declared with the <strong class="source-inline">@Specification</strong> annotation. The Truffle DSL annotation generator also includes <strong class="source-inline">CompilerDirectives.transferToInterpreterAndInvalidate()</strong> in the <strong class="source-inline">execute()</strong> method, toward the end; this will tell the compiler to stop the compilation, insert a transfer to the interpreter, and invalidate the machine code. This will trigger the deoptimization and a return to the interpreter mode of execution. </p>
			<p>Apart from this, Truffle DSL <a id="_idIndexMarker540"/>also provides other annotations that make the job of a language developer easy. You can refer to the full list here: <a href="https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html">https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/dsl/package-summary.html</a>.</p>
			<p>Truffle defines a TypeSystem, where the language developers can provide custom behavior for casting operand types. For example, the Truffle interpreter may not know how to typecast a <strong class="source-inline">long</strong> to <strong class="source-inline">int</strong>. Using TypeSystem, we can define the typecasting logic. The Truffle interpreter will use the TypeSystem during specialization.</p>
			<p>One of the challenges with dynamically typed language is the polymorphic dispatch of the methods/functions. Truffle interpreters implement polymorphic inline caching to speed up the function lookups.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor127"/>Polymorphic inline caching</h2>
			<p>In dynamically typed languages, the interpreters <a id="_idIndexMarker541"/>have to perform lookups to identify the right implementation of the method/function that is called. Looking up the functions and calling the functions is expensive and slows down the execution. In dynamically typed languages, when an <a id="_idIndexMarker542"/>object or function is called, the class is not declared, at build time or at run time, the interpreter has to do a lookup to find the actual class that is implementing the method. This is typically a hashtable lookup, unlike the vTable lookup that occurs in strongly typed languages. Hashtable lookups are time-consuming and very expensive and slow down execution. If we have only one class implementing the method, we have to only do the lookup once. This is called <a id="_idIndexMarker543"/>monomorphic inlining. If multiple classes implement the method, it's polymorphic. </p>
			<p>Checking if the function lookup is valid is less expensive than the actual lookup. Truffle caches polymorphic lookups if there are lots of previous lookups for multiple (polymorphic) lookups of a function. When a function is redefined due to deoptimization, the <strong class="source-inline">Assumption</strong> object is used to invalidate and perform a fresh lookup. To improve the performance of lookups, Truffle provides the polymorphic inline cache. Truffle caches the lookups, and just checks if the lookup is still valid.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor128"/>Understanding how Truffle supports interoperability</h1>
			<p>Truffle provides a <a id="_idIndexMarker544"/>very well-designed interoperability framework to allow guest languages to read and store data. In this section, we will cover some of the key features that the Truffle interoperability framework provides. Let's have a rundown of each of them.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor129"/>Frame management and local variables</h2>
			<p>Truffle provides a <a id="_idIndexMarker545"/>standard interface to <a id="_idIndexMarker546"/>handle the local variables and data between host and guest language implementations. The <a id="_idIndexMarker547"/>frame provides <a id="_idIndexMarker548"/>the interface to read and store the data in the current namespace. When a function is called, the local variables' data is passed as an instance of <strong class="source-inline">com.oracle.truffle.api.frame.Frame</strong>. There are two implementations of the frame:</p>
			<ul>
				<li><strong class="bold">VirtualFrame</strong>: This is most commonly used, and is <a id="_idIndexMarker549"/>passed as a parameter to the <strong class="source-inline">execute()</strong> method. This is lightweight, and preferable, as Graal optimizes this better. This frame lives in the scope of the function. It is the <a id="_idIndexMarker550"/>optimum and recommended way to pass data to functions. <strong class="source-inline">VirtualFrame</strong> does not escape, so it is easy to handle and inline.</li>
				<li><strong class="bold">MaterializedFrame</strong>: <strong class="source-inline">MaterializedFrame</strong> is allocated in the <a id="_idIndexMarker551"/>heap and is accessible to other functions. <strong class="source-inline">MaterializedFrame</strong> lives beyond the scope of the function. Graal cannot <a id="_idIndexMarker552"/>optimize it as it might optimize <strong class="source-inline">VirtualFrame</strong>. This frame implementation also has an effect on the memory and speed. </li>
			</ul>
			<p>Frames keep <a id="_idIndexMarker553"/>track of the type of data that is <a id="_idIndexMarker554"/>stored as part of the key. The key <a id="_idIndexMarker555"/>used to get the data is an <a id="_idIndexMarker556"/>instance of <strong class="source-inline">FrameSlot</strong> and <strong class="source-inline">FrameSlotKind</strong>. The following code snippet shows the <strong class="source-inline">Frame</strong> interface definition:</p>
			<p class="source-code">public interface Frame {</p>
			<p class="source-code">    FrameDescriptor getFrameDescriptor();</p>
			<p class="source-code">    Object[] getArguments();</p>
			<p class="source-code">    boolean isType(FrameSlot slot);</p>
			<p class="source-code">    Type getType(FrameSlot slot) throws             FrameSlotTypeException;</p>
			<p class="source-code">    void setType(FrameSlot slot, Type value);</p>
			<p class="source-code">    Object getValue(FrameSlot slot);</p>
			<p class="source-code">    MaterializedFrame materialize();</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">FrameSlot.getIdentifier()</strong> provides the unique identifier for the data, and <strong class="source-inline">FrameSlotKind</strong> stores the type of data. <strong class="source-inline">FrameSlotKind</strong> is an enum of various types (Boolean, Byte, Double, Float, Illegal, Int , Long, Object).</p>
			<p>The <strong class="source-inline">FrameDescriptor</strong> class keeps <a id="_idIndexMarker557"/>track of values stored in the frames. <strong class="source-inline">FrameDiscriptor</strong> describes the layout of <strong class="source-inline">Frame</strong>, providing a mapping of <strong class="source-inline">FrameSlot</strong> and <strong class="source-inline">FrameSlotKind</strong> and the value. Please refer to <a href="https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html">https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/package-summary.html</a> for more <a id="_idIndexMarker558"/>details on the Frame API. SimpleLanguage has an implementation of frame management and is a good <a id="_idIndexMarker559"/>start to <a id="_idIndexMarker560"/>understand how the Frame API can be used to manage the data that is passed between languages while invoking methods/functions.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor130"/>Dynamic Object Model</h2>
			<p>Truffle provides a <strong class="bold">Dynamic Object Model</strong> (<strong class="bold">DOM</strong>) that <a id="_idIndexMarker561"/>provides an object storage framework to enable the interoperability of data and objects between different languages. Truffle's DOM defines a <a id="_idIndexMarker562"/>standard and optimized way to share data, especially between dynamically typed languages. The DOM provides a language-independent shared infrastructure that allows developers to derive and implement various language implementations of the objects. This also helps us to share type objects between languages. Truffle's DOM is one of the core components of Truffle's interoperability and embedding feature. It provides a consistent in-memory object storage structure for host and guest languages. This allows the sharing of data between code written in different languages and the application of optimization across polyglot applications. </p>
			<p>One of the challenges with dynamically typed languages is the dynamism that is expected of the data object model. The structure of the object may change dynamically. To support this, Truffle's DOM defines a Java class called <strong class="source-inline">DynamicObject</strong>. It provides extension arrays to provide the variability of primitive types and object extensions.</p>
			<p>The guest language objects should all derive from a base class that extends from <strong class="source-inline">DynamicObject</strong> and implements <strong class="source-inline">TruffleObject</strong>. Let's now understand the Truffle instrumentation in detail.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor131"/>Understanding Truffle instrumentation </h1>
			<p>Truffle provides an Instrumentation API to <a id="_idIndexMarker563"/>help build instrumentation and tools for diagnosis, monitoring, and debugging. Truffle also provides a reference implementation called Simple Tool (<a href="https://github.com/graalvm/simpletool">https://github.com/graalvm/simpletool</a>). Truffle provides a very high-performance instrumentation design. The instrumentation is achieved with the help of probes and tags. The probes are attached to the AST nodes to capture the instrumentation data, and the nodes are identified using tags. Multiple instruments can be attached to the probe. The following figure shows a typical instrumentation:</p>
			<p class="figure-caption"><img src="image/B16878_Figure_6.6.png" alt="Figure 6.6 – Truffle instrumentation&#13;&#10;"/></p>
			<p class="figure-caption">Figure 6.6 – Truffle instrumentation</p>
			<p>The preceding figure illustrates how Truffle's Instrument API connects to the AST to collect the various metrics/data. Truffle displaces the original node by inserting a wrapper node and passes the information to the probe node, which can be connected to multiple instruments to collect the data.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor132"/>Ahead-of-time compilation using Truffle </h1>
			<p>Guest language developers can <a id="_idIndexMarker564"/>make use of Graal's <strong class="bold">Ahead-of-Time</strong> (<strong class="bold">AOT</strong>) feature by implementing Truffle AOT. The guest language developer has to implement the <strong class="source-inline">RootNode.prepareForAOT()</strong> method by returning a non-null value. If a null value is returned, Truffle/Graal understands that this language does not support building <a id="_idIndexMarker565"/>native images. To support AOT, the <strong class="source-inline">prepraeForAOT()</strong> method typically might implement the following tasks:</p>
			<ul>
				<li>Provide type information about the local variables and update them in <strong class="source-inline">FrameDescriptor</strong>. This will help the AOT compiler to resolve the types during build time.</li>
				<li>Resolve and define the arguments and return types.</li>
			</ul>
			<p>Truffle DSL provides helper classes to accelerate the development of AOT features. The <strong class="source-inline">com.oracle.truffle.api.dsl.AOTSupport</strong> class recursively prepares the AST for AOT. Each node in the AST has to have an implementation of the <strong class="source-inline">prepareForAOT()</strong> method.</p>
			<p>AOT compilation can be triggered by passing the <strong class="source-inline">--engine.CompileAOTOnCreate=true</strong> argument to the language launcher. Each guest language will have a language launcher to run the application, for example, <strong class="source-inline">js</strong> for JavaScript, <strong class="source-inline">graalpython</strong> for Python, and so on. We will cover some of these guest language implementations in the next two chapters.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor133"/>Optimizing Truffle interpreter performance with launcher options</h1>
			<p>Truffle defines a design and specification for <a id="_idIndexMarker566"/>providing <a id="_idIndexMarker567"/>various launcher options that can be used to diagnose, debug, and optimize the interpreter. All the guest language developers support these launcher options. In this section, we will cover some of these important launcher options:</p>
			<ul>
				<li><strong class="bold">Help</strong>: All language launchers <a id="_idIndexMarker568"/>implement the <strong class="source-inline">–help</strong> command-line argument. <strong class="source-inline">--help:expert</strong> provides the expert options. For the language implementer's internal options, we can use <strong class="source-inline">--help:internal</strong>.</li>
				<li><strong class="bold">Analysis and profiling options</strong>: Truffle provides <a id="_idIndexMarker569"/>command-line options to generate the Graal dumps that can be <a id="_idIndexMarker570"/>analyzed using the <strong class="bold">Ideal Graph Visualizer</strong>. Please refer to the <em class="italic">Installing the Ideal Graph Visualizer </em>and <em class="italic">Graal intermediate representation</em> sections in <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">,</em> <em class="italic">Graal Just-In-Time Compiler</em>, for more details on how to use Graal graphs for analysis and diagnosis. Graal graphs can be generated by passing the <strong class="source-inline">--vm.Dgraal.Dump=Truffle:1</strong> argument. The Graal graphs generated with Truffle will have a phase <a id="_idIndexMarker571"/>called <em class="italic">After TruffleTier</em> that shows the optimizations performed by Truffle. <p><strong class="source-inline">--cpusampler</strong> can be used to find out the <a id="_idIndexMarker572"/>CPU time taken to run the application and provide a detailed breakdown of CPU usage by module. </p><p>The <strong class="source-inline">--engine.TraceCompilation</strong> argument can be <a id="_idIndexMarker573"/>passed to create a trace each time a method is compiled.</p><p>The <strong class="source-inline">--engine.TraceCompilationDetail</strong> argument can be passed to trace when compilation is queued, started, and finished. </p><p>The <strong class="source-inline">--engine.TraceCompilationAST</strong> argument can be passed to trace the AST whenever the code is compiled.</p><p>The <strong class="source-inline">--engine.TraceInlining</strong> argument can be passed to trace the inlining decisions taken by the guest language.</p><p>The <strong class="source-inline">--engine.TraceSplitting</strong> argument can be <a id="_idIndexMarker574"/>passed to trace the splitting decisions taken by the language.</p><p>The <strong class="source-inline">--engine.TraceTransferToInterpreter</strong> argument can be passed to trace when the <a id="_idIndexMarker575"/>deoptimization is <a id="_idIndexMarker576"/>triggered and a transfer to the interpreter occurs.</p></li>
			</ul>
			<p>You can refer to the GraalVM documentation for more information (<a href="https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/">https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Optimizing/</a>) or pass the <strong class="source-inline">--help</strong> argument in the language launcher.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor134"/>SimpleLanguage and Simple Tool</h1>
			<p>The GraalVM team has created a <a id="_idIndexMarker577"/>reference implementation of a guest language called SimpleLanguage. SimpleLanguage demonstrates the features of Truffle and explains how to use the Truffle API. A guest language developer can use SimpleLanguage as a reference. It is completely open source and is available on <a id="_idIndexMarker578"/>GitHub at <a href="https://github.com/graalvm/simplelanguage">https://github.com/graalvm/simplelanguage</a>. SimpleLanguage is just a starting point and does not implement all the features.</p>
			<p>There is also a reference implementation of Simple Tool<a id="_idIndexMarker579"/>. Simple Tool is an implementation of a code coverage tool that has been built using Truffle. This is also an open source project that can be used by tool developers to build new tools using Truffle to run on GraalVM. You can access the <a id="_idIndexMarker580"/>source code of this tool at <a href="https://github.com/graalvm/simpletool">https://github.com/graalvm/simpletool</a>.</p>
			<p>There is an increasing number of languages being developed with Truffle. We will be covering JavaScript, LLVM (C/C++), Ruby, Python, R, Java/Truffle, and WebAssemby in the next two chapters. You can see the status of some of the other programming languages at <a href="https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/">https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/</a>.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor135"/>Summary</h1>
			<p>In this chapter, we went through the architecture of Truffle and saw how it provides a well-designed framework for other languages (guest languages) to run on GraalVM. We also looked at how Truffle interpreters are implemented and how they can optimize the AST before submitting the stabilized AST to the Graal for further optimization. </p>
			<p>In this chapter, you have gained a good understanding of Truffle architecture and how Truffle provides a framework and an implementation layer on top of Graal. You have also explored the optimizations Truffle performs before submitting the code to Graal JIT for further optimization and execution.</p>
			<p>In the next chapter, we will look at how JavaScript and LLVM languages (C, C++, and so on) implement Truffle and run on GraalVM.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor136"/>Questions</h1>
			<ol>
				<li>What is specialization?</li>
				<li>What is tree/node rewriting?</li>
				<li>What is partial evaluation?</li>
				<li>What is Truffle DSL?</li>
				<li>What is a frame?</li>
				<li>What is a Dynamic Object Model?</li>
			</ol>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor137"/>Further reading</h1>
			<ul>
				<li>Truffle: A Self-Optimizing Runtime System (<a href="https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf">https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf</a>)</li>
				<li>Specializing Dynamic Techniques For Implementing the Ruby Programming Language  (<a href="https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language">https://www.researchgate.net/publication/285051808_Specialising_Dynamic_Techniques_For_Implementing_the_Ruby_Programming_Language</a>)</li>
				<li>A Domain-Specific Language for Building Self-Optimizing AST Interpreters (<a href="http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf">http://lafo.ssw.uni-linz.ac.at/papers/2014_GPCE_TruffleDSL.pdf</a>)</li>
				<li>One VM to Rule Them All (<a href="http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf">http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf</a>)</li>
				<li>High-Performance Cross-Language Interoperability in a Multi-language Runtime (<a href="https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf">https://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf</a>)</li>
				<li>Writing a Language in Truffle (<a href="http://cesquivias.github.io/index.html">http://cesquivias.github.io/index.html</a>)</li>
			</ul>
		</div>
	</body></html>