<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Working with Repositories"><div class="titlepage" id="aid-K0RQ2"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Repositories</h1></div></div></div><p>In the previous chapter, you learned how to define dependencies for your project. Those dependencies are mostly stored somewhere in a repository or a directory structure. A repository usually has a structure to support different versions for the same dependency. Also, some metadata, such as the other dependencies for a module, is saved in the repository.</p><p>In our build files, we must define the location of a repository for our dependencies. We can mix different types of repositories, such as Maven and Ivy. We can even use a local filesystem as a repository. We will see how we can define and configure repositories in our build files.</p><p>Also, Gradle offers the option of configuring the repository layout, if the repository is using a custom layout. We will learn how to provide credentials for repositories with basic authentication.</p><div class="section" title="Declaring repositories"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Declaring repositories</h1></div></div></div><p>If we want to add <a id="id54" class="indexterm"/>dependencies from a repository in a Gradle build file, we must explicitly add the <code class="literal">repositories</code> configuration block. Within the configuration block, we define the location of the repository and maybe some extra configuration. In the following example of a build file, we define a Maven repository with a custom location:</p><div class="informalexample"><pre class="programlisting">// Repositories configuration block,
// must be present to define and
// configure repositories to get
// dependencies in our build script.
repositories {

  // Sample Maven repository with a
  // custom location.
  maven {
    url 'http://mycompany.net/maven'
  }

}</pre></div><p>We can include several repositories in our build file. We can even mix the type of repositories, for example to, include both the Ivy repository and a local filesystem. Gradle supports the following <a id="id55" class="indexterm"/>types of repositories:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Type</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>Maven JCenter repository</p>
</td><td valign="top">
<p>This is a <a id="id56" class="indexterm"/>preconfigured repository for Bintray JCenter</p>
</td></tr><tr><td valign="top">
<p>Maven central repository</p>
</td><td valign="top">
<p>This is a <a id="id57" class="indexterm"/>preconfigured repository for Maven Central</p>
</td></tr><tr><td valign="top">
<p>Maven local repository</p>
</td><td valign="top">
<p>This is a <a id="id58" class="indexterm"/>preconfigured repository for the local Maven repository</p>
</td></tr><tr><td valign="top">
<p>Maven repository</p>
</td><td valign="top">
<p>This <a id="id59" class="indexterm"/>is a to-be-configured Maven repository, which has a custom location</p>
</td></tr><tr><td valign="top">
<p>Ivy repository</p>
</td><td valign="top">
<p>This is a <a id="id60" class="indexterm"/>to-be-configured Ivy repository, which has a location and layout</p>
</td></tr><tr><td valign="top">
<p>Flat directory repository</p>
</td><td valign="top">
<p>This is a <a id="id61" class="indexterm"/>local filesystem repository</p>
</td></tr></tbody></table></div><p>We will see how to use these repositories in our build file later. It is good to realize that Gradle will try to download all artifacts from a dependency, from the same repository that the dependency module descriptor file is found. So, if we have multiple repositories defined in our build script, Gradle will still use the first repository that the module descriptor file is found on to download the artifacts.</p><div class="section" title="Using the Maven JCenter repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Using the Maven JCenter repository</h2></div></div></div><p>Bintray's JCenter is a <a id="id62" class="indexterm"/>relatively new public Maven repository, where a lot of Maven open source dependencies are stored. It is a superset of the <a id="id63" class="indexterm"/>Maven Central repository and also contains dependency artifacts published directly to JCenter. The URL to access the repository is <a class="ulink" href="https://jcenter.bintray.com">https://jcenter.bintray.com</a>. Gradle provides a shortcut for JCenter, so we don't <a id="id64" class="indexterm"/>have to type the URL ourselves in the <code class="literal">repositories</code> configuration block. The shortcut method is <code class="literal">jcenter()</code>.</p><p>In the following example build file, we define a reference to Bintray's JCenter repository using the <code class="literal">jcenter()</code> shortcut:</p><div class="informalexample"><pre class="programlisting">repositories {
  // Define Bintray's JCenter
  // repository, to find
  // dependencies.
  jcenter()
}</pre></div><p>Since Gradle 2.1, the default protocol is <code class="literal">https</code> for the JCenter repository URL. If we want to use the <code class="literal">http</code> <a id="id65" class="indexterm"/>protocol, we must set the <code class="literal">url</code> property <a id="id66" class="indexterm"/>for the repository. In the next example build file, we will redefine the <code class="literal">url</code> property:</p><div class="informalexample"><pre class="programlisting">repositories {
  jcenter {
    // By default https is used as protocol,
    // but we can change it with the url
    // property.
    url = 'http://jcenter.bintray.com'
  }
}</pre></div><p>Optionally, we can assign a name to the repository definition. This can be done for all Maven repositories, and because JCenter is also a Maven repository, we can set the <code class="literal">name</code> property. In the following example build file, we define multiple repositories and set the <code class="literal">name</code> property. We add a new task, <code class="literal">repositoriesInfo</code>, which will display the <code class="literal">name</code> and <code class="literal">URL</code> properties for each repository:</p><div class="informalexample"><pre class="programlisting">repositories {
  // Define multiple Maven repositories.
  jcenter()

  jcenter {
    name 'Bintray JCenter legacy'
    url = 'http://jcenter.bintray.com'
  }
}

task repositoriesInfo {
  description 'Display information about repositories'

  doFirst {
    // Access repositories as collection.
    project.repositories.each {
      // Display name and URL for each
      // repository.
      println "'${it.name}' uses URL ${it.url}"
    }
  }
}</pre></div><p>When we run the <a id="id67" class="indexterm"/>
<code class="literal">repositoriesInfo</code> <a id="id68" class="indexterm"/>task, we get the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q repositoriesInfo</strong></span>
<span class="strong"><strong>'BintrayJCenter' uses URL https://jcenter.bintray.com/</strong></span>
<span class="strong"><strong>'Bintray JCenter legacy' uses URL http://jcenter.bintray.com</strong></span>
</pre></div></div><div class="section" title="Using the Maven Central repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Using the Maven Central repository</h2></div></div></div><p>We can configure the <a id="id69" class="indexterm"/>central Maven 2 repository <a id="id70" class="indexterm"/>in the <code class="literal">repositories</code> configuration block. Gradle provides the shortcut method, <code class="literal">mavenCentral</code>. This configures the central Maven repository with the URL <code class="literal">https://repo1.maven.org/maven2/</code>.</p><p>In the next example build file, we will define the central Maven 2 repository for our build:</p><div class="informalexample"><pre class="programlisting">repositories {
  // Define central Maven repository
  // to use for dependencies.
  mavenCentral()
}</pre></div><p>Gradle 2.1 uses the <code class="literal">https</code> protocol when we use the <code class="literal">mavenCentral</code> method. If we want to use the <code class="literal">http</code> protocol, we can redefine the <code class="literal">url</code> property and use the <code class="literal">http://repo1.maven.org/maven2/</code> address. In the next example build file, we will redefine the <code class="literal">url</code> property:</p><div class="informalexample"><pre class="programlisting">repositories {
  mavenCentral(
    // Use http protocol for the
    // central Maven repository.
    url: 'http://repo1.maven.org/maven2/'
  )
}</pre></div><p>Besides changing the <code class="literal">url</code> property, we can also set an optional <code class="literal">name</code> property when we use the <code class="literal">mavenCentral</code> method. In the following example build script, we assign a value to the <code class="literal">name</code> property. We add a new task, <code class="literal">repositoriesInfo</code>, to display information about the configured repositories:</p><div class="informalexample"><pre class="programlisting">repositories {
  // Define multiple Maven repositories.
  mavenCentral()

  mavenCentral(
    name: 'HTTP Maven Central',
    url:  'http://repo1.maven.org/maven2/'
  )
}

task repositoriesInfo {
  description 'Display information about repositories'

  doFirst {
    // Access repositories as collection.
    project.repositories.each {
      // Display name and URL for each
      // repository.
      println "'${it.name}' uses URL ${it.url}"
    }
  }
}</pre></div><p>Let's invoke the <a id="id71" class="indexterm"/>
<code class="literal">repositoriesInfo</code> <a id="id72" class="indexterm"/>task to see the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q repositoriesInfo</strong></span>
<span class="strong"><strong>'MavenRepo' uses URL https://repo1.maven.org/maven2/</strong></span>
<span class="strong"><strong>'HTTP Maven Central' uses URL http://repo1.maven.org/maven2/</strong></span>
</pre></div></div><div class="section" title="Using the Maven local repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Using the Maven local repository</h2></div></div></div><p>If we have used <a id="id73" class="indexterm"/>Maven on our local computer before <a id="id74" class="indexterm"/>there is a great change, we have a local Maven cache with downloaded artifacts. We can use this local cache as a repository in our Gradle build, with the <code class="literal">mavenLocal</code> shortcut method. Although it is possible to use our local Maven cache, it is not advisable because it makes the build dependent on local settings. If we work on a bigger project with more developers, then we cannot rely on the local Maven cache on each developer's computer as the only repository.</p><p>In the following example build file, we use the <code class="literal">mavenLocal</code> shortcut method:</p><div class="informalexample"><pre class="programlisting">repositories {
  // Define the local Maven cache as
  // a repository for dependencies.
  mavenLocal()
}</pre></div><p>The location of the local Maven cache is determined in the same way as Maven. Gradle will try to find the <code class="literal">settings.xml</code> file in <code class="literal">USER_HOME/.m2</code> or <code class="literal">M2_HOME/conf</code>, where the former takes precedence over <a id="id75" class="indexterm"/>the latter. If the <code class="literal">settings.xml</code> file is <a id="id76" class="indexterm"/>found, then the location of the local Maven repository defined in the file is used. If <code class="literal">settings.xml</code> cannot be found, or if the local Maven repository location is not defined, then the default location is <code class="literal">USER_HOME/.</code>
<code class="literal">m2/repository</code>.</p></div><div class="section" title="Using Maven repositories"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Using Maven repositories</h2></div></div></div><p>We have learned <a id="id77" class="indexterm"/>about shortcut methods to define a Maven <a id="id78" class="indexterm"/>repository. If we have our own Maven repository, such as Nexus or Artifactory, we can use the <code class="literal">maven</code> method in the <code class="literal">repositories</code> configuration block. With this method, we can define the <code class="literal">url</code> property to access the repository. We can see this in action in the following example build script:</p><div class="informalexample"><pre class="programlisting">repositories {

  // Define a custom Maven repository and
  // set the url property so Gradle can look
  // for the dependency module descripts
  // and artifacts.
  maven {
    url = 'http://ourcompany.com/maven'
    // Alternative syntax is to use
    // the url method:
    // url 'http://ourcompany.com/maven'
  }

}</pre></div><p>When Gradle finds the module dependency descriptor in the Maven repository, then the artifacts will be searched for in this repository. If the artifacts are stored in another location, we use the <code class="literal">artifactUrls</code> property to specify the location. This way, Gradle will look for the dependency module descriptors in the location specified by the <code class="literal">url</code> property, and for the artifacts in the locations specified by the <code class="literal">artifactUrls</code> property.</p><p>The next example build script will define a custom Maven repository, with multiple locations for the artifacts:</p><div class="informalexample"><pre class="programlisting">repositories {
  maven {
    // At this location at the least the
    // dependency module descriptor files
    // must be stored.
    url 'http://ourcompany.com/maven'

    // Define extra locations where artifacts
    // can be found and downloaded.
    artifactUrls 'http://ourcompany.com/jars'
    artifactUrls 'http://ourcompany.com/lib'

    // Alternative syntax is to use the
    // artifactUrls property assignment:
    // artifactUrls = [
    //   'http://ourcompany.com/jars', 'http://ourcompany.com/lib'
    // ]
  }
}</pre></div><p>If we have configured <a id="id79" class="indexterm"/>our custom Maven repository with basic authentication, we must provide a username and password to access the repository. In our <a id="id80" class="indexterm"/>Gradle build file, we set the username and password in the <code class="literal">credentials</code> block of the <code class="literal">maven</code> configuration. Let's first add the username and password to the build file and later see how we can externalize these properties. The next example build file will use the <code class="literal">credentials</code> configuration block:</p><div class="informalexample"><pre class="programlisting">repositories {
  maven {
    url 'http://ourcompany.com/maven'

    // Here we assign the username and
    // password to access the repository.
    credentials {
      username = 'developer'
      password = 'secret'

      // Alternate syntax is to use
      // the username and password
      // methods.
      // username 'developer'
      // password 'secret'
    }
  }
}</pre></div><p>It is not a good idea to add the username and password to the build file, because this file is shared with all the developers involved in our project. We fix this using project properties, instead of a hardcoded username and password. The values of the project properties can be set via the command line with the <code class="literal">-P</code> or <code class="literal">--project-prop</code> options. Or, we can add the <code class="literal">gradle.properties</code> file to our project with the names and values of the project properties. The <code class="literal">gradle.properties</code> file must not be put in the version control system of our project, so that the values are private for the developer.</p><p>The following example <a id="id81" class="indexterm"/>build file uses the <code class="literal">mavenUsername</code> project <a id="id82" class="indexterm"/>properties and <code class="literal">mavenPassword</code> for the Maven repository credentials:</p><div class="informalexample"><pre class="programlisting">repositories {
  maven {
    name = 'Company Maven Repository'

    url 'http://ourcompany.com/maven'

    // Check that properties mavenUsername
    // and mavenPassword are set when
    // we run the script.
    verifyProperty('mavenUsername')
    verifyProperty('mavenPassword')

    credentials {
      // Use project properties instead
      // of hard coded username and password.
      username mavenUsername
      password mavenPassword
    }
  }
}

/**
* Helper method to check if project property
* with the given name is set.
*
* @param propertyName Name of the property to check
* @throws GradleException When property is not set.
*/
void verifyProperty(final String propertyName) {
  if (!hasProperty(propertyName)) {
    throw new GradleException("Property $propertyName must be set")
  }
}</pre></div><p>When we execute any tasks for this script, we should provide the values for the project properties via the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -PmavenUsername=developer -PmavenPassword=secret</strong></span>
</pre></div><p>Or, we can create the <code class="literal">gradle.properties</code> file in the project directory, with the following contents:</p><div class="informalexample"><pre class="programlisting">mavenUsername = developer
mavenPassword = secret</pre></div><p>If we have multiple projects that use the same custom Maven repository, then we can also create a Gradle init script with the correct credentials. A Gradle init script runs before the build starts. In the script, we want to set the credentials for a Maven repository with a specific name. There are several ways to use an init script:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We can use an init <a id="id83" class="indexterm"/>script directly from the command line with the <code class="literal">-I</code> or <code class="literal">--init-script</code> options. Here, we specify the name of the init script.</li><li class="listitem">We put the <code class="literal">init.gradle</code> file in the <code class="literal">USER_HOME/.gradle</code> directory. This file is run before every Gradle build on our computer.</li><li class="listitem">We put a file with the<code class="literal">.gradle</code> extension in the <code class="literal">USER_HOME/.gradle/init.d</code> directory. All Gradle init scripts from this directory are run before every build.</li><li class="listitem">We put a file with <a id="id84" class="indexterm"/>the <code class="literal">.gradle</code> extension in the <code class="literal">GRADLE_HOME/init.d</code> directory. This way, we can package a custom Gradle distribution with init scripts that always need to be executed.</li></ul></div><p>Let's take a look at the contents of the init script in the next example init script file:</p><div class="informalexample"><pre class="programlisting">// Run for all projects.
allprojects {

  // After the project is evaluated, we can access
  // the repository by name.
  afterEvaluate { project -&gt;

    // Check if project contains a repository
    // with the given name.
    if (project.repositories.any { it.name == 'Company Maven Repository' }) {

      // Set credentials for custom Maven repository
      // with the given name.
      configure(project.repositories['Company Maven Repository']) {
        credentials {
          username 'developer'
          password 'secret'
        }
      }

    }

  }

}</pre></div><p>We must change our project Gradle build file, because the credentials are now set via an init script. We will <a id="id85" class="indexterm"/>remove the credentials from the project build file. In <a id="id86" class="indexterm"/>the next example build file, we will remove the credentials and helper method, to set the credential properties. The credentials are set by the init script. The following code shows this:</p><div class="informalexample"><pre class="programlisting">repositories {
  maven {
    name = 'Company Maven Repository'
    url 'http://ourcompany.com/maven'

    // Credentials are set via init script.
  }
}</pre></div></div><div class="section" title="Using the flat directory repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Using the flat directory repository</h2></div></div></div><p>Gradle also allows <a id="id87" class="indexterm"/>directories to be used as repositories to <a id="id88" class="indexterm"/>solve dependencies. We can specify one or more directories using the <code class="literal">flatDir</code> method. Optionally, we can specify a name for the repository. In the next example build file, we specify the <code class="literal">lib</code> and <code class="literal">jars</code> directories to be used as repositories:</p><div class="informalexample"><pre class="programlisting">repositories {

  // Define the directories jars and lib
  // to be used as repositories.
  flatDir {
    name 'Local lib directory'
    dirs "${projectDir}/jars", "${projectDir}/lib"
  }

  // Alternate syntax is using a Map
  // with the flatDir method.
  // flatDir name: 'Local lib directory',
  //         dirs: ["${projectDir}/jars", "${projectDir}/lib"]

}</pre></div><p>When we use the flat directory repository, Gradle resolves dependency artifacts based on the artifact name and version. The group part of a dependency is ignored. If we only use flat directory repositories in our project, we can even leave out the group part when we configure the dependencies. Gradle uses the following rules to resolve a dependency:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">[artifact]-[version].[ext]</li><li class="listitem">[artifact]-[version]-[classifier].[ext]</li><li class="listitem">[artifact].[ext]</li><li class="listitem">[artifact]-[classifier].[ext]</li></ul></div><p>In the next <a id="id89" class="indexterm"/>example build file, we will define a flat <a id="id90" class="indexterm"/>directory repository and a single dependency:</p><div class="informalexample"><pre class="programlisting">repositories {
  flatDir name: 'Local lib directory',
      dirs: ["${projectDir}/lib"]
}

dependencies {
  traffic group: 'com.traffic', name: 'pedestrian',
      version: '1.0', classifier: 'jdk16'
}</pre></div><p>Gradle will resolve the following files in the <code class="literal">lib</code> directory; the first matching file is used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">pedestrian-1.0.jar</code></li><li class="listitem"><code class="literal">pedestrian-1.0-jdk16.jar</code></li><li class="listitem"><code class="literal">pedestr</code><code class="literal">ian.jar</code></li><li class="listitem"><code class="literal">pedestrian-jdk16.jar</code></li></ul></div></div><div class="section" title="Using Ivy repositories"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Using Ivy repositories</h2></div></div></div><p>Ivy repositories allow <a id="id91" class="indexterm"/>customizable and flexible repository <a id="id92" class="indexterm"/>layout patterns. Gradle supports Ivy repositories, and we can configure the repository layout patterns in our Gradle build script. To define an Ivy repository, we use the <code class="literal">ivy</code> method in the <code class="literal">repositories</code> configuration block.</p><p>In the following example build file, we define a standard Ivy repository, and we also set the optional <code class="literal">name</code> property for the repository:</p><div class="informalexample"><pre class="programlisting">repositories {

  // Define an Ivy repository with
  // a URL and optional name property.
  ivy {
    name 'Ivy Repository'
    url 'http://ourompany.com/repo'
  }

}</pre></div><p>The layout of an Ivy repository defines the patterns used to search module dependency metadata and the dependency artifacts. We can use some predefined layouts in our build scripts. In the previous example build file, we didn't specify a layout. Gradle will then use the default <code class="literal">gradle</code> layout. The next table shows the different layout names we can use, their patterns to find the <a id="id93" class="indexterm"/>Ivy metadata XML files, and the artifacts <a id="id94" class="indexterm"/>for the dependency:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Name</p>
</th><th valign="bottom">
<p>Ivy pattern</p>
</th><th valign="bottom">
<p>Artifact pattern</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>gradle</p>
</td><td valign="top">
<p>
<code class="literal">[organisation]/[module]/[revision]/ivy-[revision].xml</code>
</p>
</td><td valign="top">
<p>
<code class="literal">[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier])(.[ext])</code>
</p>
</td></tr><tr><td valign="top">
<p>maven</p>
</td><td valign="top">
<p>
<code class="literal">[organisation]/[module]/[revision]/ivy-[revision].xml</code>
</p>
</td><td valign="top">
<p>
<code class="literal">[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier])(.[ext])</code>
</p>
</td></tr><tr><td valign="top">
<p>ivy</p>
</td><td valign="top">
<p>
<code class="literal">[organisation]/[module]/[revision]/[type]s/[artifact](.[ext])</code>
</p>
</td><td valign="top">
<p>
<code class="literal">[organisation]/[module]/[revision]/[type]s/[artifact](.[ext])</code>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">.</code> in <code class="literal">organisation</code> is replaced with <code class="literal">/</code>.</p><p>To use a layout, we use the <code class="literal">layout</code> method inside the <code class="literal">ivy</code> configuration. For example, in the next build script, we use the <code class="literal">maven</code> and <code class="literal">ivy</code> layouts:</p><div class="informalexample"><pre class="programlisting">repositories {

  ivy {
    // Set layout to maven.
    layout 'maven'
    name 'Ivy repository Maven layout'
    url 'http://ourcompany.com/repo1'
  }

  ivy {
    // Set layout to ivy.
    layout 'ivy'
    name 'Ivy repository'
    url 'http://ourcompany.com/repo'
  }

}</pre></div><p>To define a custom pattern for the Ivy XML files and the artifacts, we use the <code class="literal">pattern</code> layout. With this layout, we define our own patterns using the tokens defined by Ivy. In the following table, we <a id="id95" class="indexterm"/>see the tokens that can be used to build a pattern:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Token</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>[organisation]</p>
</td><td valign="top">
<p>This is the organisation name.</p>
</td></tr><tr><td valign="top">
<p>[orgPath]</p>
</td><td valign="top">
<p>This is the organisation name, where <code class="literal">.</code> has been replaced by <code class="literal">/</code>. This can be used to configure maven2-like repositories.</p>
</td></tr><tr><td valign="top">
<p>[module]</p>
</td><td valign="top">
<p>This is the module name.</p>
</td></tr><tr><td valign="top">
<p>[branch]</p>
</td><td valign="top">
<p>This is the branch name.</p>
</td></tr><tr><td valign="top">
<p>[revision]</p>
</td><td valign="top">
<p>This is the revision name.</p>
</td></tr><tr><td valign="top">
<p>[artifact]</p>
</td><td valign="top">
<p>This is the artifact name (or ID).</p>
</td></tr><tr><td valign="top">
<p>[type]</p>
</td><td valign="top">
<p>This is the artifact type.</p>
</td></tr><tr><td valign="top">
<p>[ext]</p>
</td><td valign="top">
<p>This is the artifact file extension.</p>
</td></tr><tr><td valign="top">
<p>[conf]</p>
</td><td valign="top">
<p>This is the configuration name.</p>
</td></tr><tr><td valign="top">
<p>[originalname]</p>
</td><td valign="top">
<p>This is the original artifact name (including the extension).</p>
</td></tr></tbody></table></div><p>To specify an optional token, we enclose the token with parentheses (<code class="literal">(</code> and <code class="literal">)</code>). If the token defined between parentheses is null or empty, then the token is ignored. For example, the <code class="literal">[artifact](-[revision]).[ext]</code> pattern will accept <code class="literal">artifact.jar</code> if <code class="literal">revision</code> is not set and <code class="literal">artifact-1.1.jar</code> if <code class="literal">revision</code> is set.</p><p>We define a custom <a id="id96" class="indexterm"/>layout in our build script by specifying the layout with the <code class="literal">pattern</code> name, and adding a configuration block where we define the patterns for the Ivy XML files and artifacts. If we don't specify a special pattern for the Ivy XML files, then the artifact pattern is used. We need to define at least one artifact pattern. The patterns are appended to the <code class="literal">url</code> property of the repository. Optionally, we can set the <code class="literal">pattern</code> layout property, <code class="literal">m2compatible</code>. If the value is <code class="literal">true</code>, then the <code class="literal">.</code> in the <code class="literal">[organisation]</code> token is replaced with <code class="literal">/</code>.</p><p>In the next example build script, we will define two new repositories with a custom layout:</p><div class="informalexample"><pre class="programlisting">repositories {

  ivy {
    url 'http://ourcompany.com/repo'

    // Here we define a custom pattern
    // for the artifacts and Ivy XML files.
    layout('pattern') {
      // Define pattern with artifact method.
      // This pattern is used for both Ivy XML files
      // and artifacts.
      artifact '[module]/[type]/[artifact]-[revision].[ext]'
    }
  }

  ivy {
    url 'http://ourcompany.com/repo1'

    layout('pattern') {
      // We can define multiple patterns. 
      // The order of the definitions
      // defines search path.
      artifact 'binaries/[organisation]/[module]/[artifact]-[revision].[ext]'
      artifact 'signed-jars/[organisation]/[module]/[artifact]-[revision].[ext]'

      // Seperate definition for Ivy XML files 
      // with ivy method.
      ivy '[organisation]/[module]/metadata/ivy-[revision].xml'
    }
  }

}</pre></div><p>An alternative syntax to define custom patterns is using <code class="literal">artifactPattern</code> and <code class="literal">ivyPattern</code> inside the <a id="id97" class="indexterm"/>
<code class="literal">ivy</code> configuration block. We don't have to <a id="id98" class="indexterm"/>use the <code class="literal">layout</code> method with this definition. If we don't specify <code class="literal">ivyPattern</code>, then the pattern defined with <code class="literal">artifactPattern</code> is used to find Ivy XML files. In the following example build script, we rewrite the repository definitions from the previous example build file:</p><div class="informalexample"><pre class="programlisting">repositories {

  ivy {
    url 'http://ourcompany.com/repo'

    // Define pattern with artifact method.
    // This pattern is used for both Ivy XML files
    // and artifacts.
    artifactPattern '[module]/[type]/[artifact]-[revision].[ext]'
  }

  ivy {
    url 'http://ourcompany.com/repo1'

    // We can define multiple patterns. The order of the definitions
    // defines search path.
    artifactPattern 'binaries/[organisation]/[module]/[artifact]-[revision].[ext]'
    artifactPattern 'signed-jars/[organisation]/[module]/[artifact]-[revision].[ext]'

    // Seperate definition for Ivy XML files with ivy method.
    ivyPattern '[organisation]/[module]/metadata/ivy-[revision].xml'
  }

}</pre></div><p>To specify the username and password for an Ivy repository with basic authentication, we use the <code class="literal">credentials</code> <a id="id99" class="indexterm"/>method, just as we did with the Maven <a id="id100" class="indexterm"/>repositories. In the next example build file, we will set the credentials to access an Ivy repository. Take a look at the section about Maven repositories to see how we can externalize the username and password, so that they are not part of the build script code. The following code shows this:</p><div class="informalexample"><pre class="programlisting">repositories {
  ivy {
    url 'http://ourcompany.com/repo'

    // Here we assign the username and
    // password to access the repository.
    credentials {
      username = 'developer'
      password = 'secret'

      // Alternate syntax is to use
      // the username and password
      // methods.
      // username 'developer'
      // password 'secret'
    }
  }
}</pre></div></div></div></div>
<div class="section" title="Using different protocols" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Using different protocols</h1></div></div></div><p>The Maven and Ivy <a id="id101" class="indexterm"/>repositories can be accessed via several protocols. We already learned that we can use the <code class="literal">http</code> and <code class="literal">https</code> protocols. However, we can also use the <code class="literal">file</code> and <code class="literal">sftp</code> protocols. We must provide credentials when we use the <code class="literal">sftp</code> protocol. The <code class="literal">file</code> protocol doesn't support authentication.</p><p>The next example build file will use the <code class="literal">file</code> and <code class="literal">sftp</code> protocols to define the Maven and Ivy repositories:</p><div class="informalexample"><pre class="programlisting">repositories {
  ivy {
    // Use file protocol, for example an
    // accessible network share or local directory.
    url 'file://Volumes/shared/developers/repo'
  }

  maven {
    url 'sftp://ourcompany.com:22/repo'

    // With the sftp protocol we must provide
    // the username and password.
    credentials {
      username 'developer'
      password 'secret'
    }
  }
}</pre></div></div>
<div class="section" title="Summary" id="aid-LTSU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, you learned how to define repositories in your Gradle build scripts. You saw how to use predefined shortcut methods: <code class="literal">jcenter</code>, <code class="literal">mavenCentral</code>, and <code class="literal">mavenLocal</code>. To access a Maven repository at a custom location, we can use the <code class="literal">url</code> property and the <code class="literal">maven</code> method. When we configure an Ivy repository, we have the most control. We can specify a URL, and also the layout pattern of the repository. You learned that you can also use a flat directory repository in your build scripts.</p><p>You saw how to provide credentials for repositories with basic authentication. You now know how to save the username and password outside your build script. Finally, you learned how to use different transport protocols to access repositories.</p><p>In the next chapter, we will see how Gradle will resolve dependencies.</p></div></body></html>