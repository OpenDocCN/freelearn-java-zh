<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Creating ImageJ Plugins for Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Creating ImageJ Plugins for Analysis</h1></div></div></div><p>In this chapter, we will examine how to create plugins to perform analyses. This chapter will examine how to make a flexible plugin, and how to implement it in ImageJ to perform a simple analysis. The following topics will be dealt with in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a new plugin project</li><li class="listitem" style="list-style-type: disc">Using a plugin to process and analyze images</li><li class="listitem" style="list-style-type: disc">Adding user interaction and preferences</li><li class="listitem" style="list-style-type: disc">Using external libraries</li><li class="listitem" style="list-style-type: disc">Sharing your plugin</li></ul></div><div class="section" title="Plugin background and goal"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec45"/>Plugin background and goal</h1></div></div></div><p>In this section, I <a id="id497" class="indexterm"/>will briefly describe an image-processing problem that we will <a id="id498" class="indexterm"/>try to solve using a plugin. The problem is a general one that is encountered in many experiments involving living cells or organisms: they move and change shape. When we want to quantify certain aspects of the cells that we have imaged, we need to perform three basic steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Detect the object of interest.</li><li class="listitem">Measure our object in the current frame.</li><li class="listitem">Detect each object in our time series independently.</li></ol></div><p>These steps are encountered in many different problems involving time series. For each of the three steps, we need to create a solution that solves the problem or quantifies the object in a meaningful manner. For detection, we can think of many methods that may be suitable to detect the object. When we think back to the topics discussed in <a class="link" href="ch04.html" title="Chapter 4. Image Segmentation and Feature Extraction with ImageJ">Chapter 4</a>, <span class="emphasis"><em>Image Segmentation and Feature Extraction with ImageJ</em></span> we may think of a threshold-based technique to segment the image, and use a particle analyzer to find objects that contain specific features. For measurements, we can go back to <a class="link" href="ch05.html" title="Chapter 5. Basic Measurements with ImageJ">Chapter 5</a>, <span class="emphasis"><em>Basic Measurements with ImageJ</em></span> where we looked at the basic methods to measure objects using ImageJ commands. The final component for this example uses the previous two methods for each of the identified objects.</p><p>To make our plugin more general and widely usable, we will also need to specify some parameters that will <a id="id499" class="indexterm"/>influence the outcome for each of these steps. The detection <a id="id500" class="indexterm"/>might need different criteria about what is a valid object depending on the data. To this end, we can create a generic dialog that will ask the user for input using a few input fields. I will give different examples of the same code that can be used in different scenarios.</p></div></div>
<div class="section" title="Basic project setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Basic project setup</h1></div></div></div><p>For this project, I <a id="id501" class="indexterm"/>will be using the Maven system to set up the project and the dependencies that are required. Most of the source code can also be run without these steps, but I will set it up using the NetBeans IDE using a Maven POM project. As we saw in <a class="link" href="ch07.html" title="Chapter 7. Explanation of ImageJ Constructs">Chapter 7</a>, <span class="emphasis"><em>Explanation of ImageJ Constructs</em></span> setting up a new project for ImageJ using Maven is done by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Project</strong></span>, and choosing <span class="strong"><strong>POM Project</strong></span> from the <span class="strong"><strong>Maven</strong></span> category in the wizard. For this plugin, I will use the project name <code class="literal">Object_Tracker</code>. After clicking <span class="strong"><strong>Finish</strong></span>, the project will be created and should show up in the <span class="strong"><strong>Projects</strong></span> view. If you cannot see the <span class="strong"><strong>Projects</strong></span> view, go to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Projects</strong></span> from the menu to display it.</p><p>To start with, we need to tell Maven that we require ImageJ as a dependency. We do this by adding a <code class="literal">&lt;dependencies&gt;</code> section to our <code class="literal">pom.xml</code> file, as was shown in <a class="link" href="ch07.html" title="Chapter 7. Explanation of ImageJ Constructs">Chapter 7</a>, <span class="emphasis"><em>Explanation of ImageJ Constructs</em></span>. We will first look at how to create this plugin as a legacy plugin using all the standard coding of a legacy plugin. To code it as a legacy plugin, we will use ImageJ version <span class="strong"><strong>1.50b</strong></span> as a dependency by adding the following code to our <code class="literal">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;repositories&gt;
&lt;repository&gt;
  &lt;id&gt;imagej.public&lt;/id&gt;
  &lt;url&gt;http://maven.imagej.net/content/groups/public&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
&lt;dependency&gt;
  &lt;groupId&gt;net.imagej&lt;/groupId&gt;
  &lt;artifactId&gt;ij&lt;/artifactId&gt;
  &lt;version&gt;1.50b&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><p>The <code class="literal">&lt;repositories&gt;</code> section tells Maven where to find the sources for our dependencies, and in the optional <code class="literal">&lt;version&gt;</code> tag, we specify which version of ImageJ we wish to use. Note that if you start typing the version number in the tag, NetBeans will suggest version numbers that you can enter. At the time of writing <span class="strong"><strong>1.50b</strong></span> was the latest version of ImageJ. If you leave this tag out, the version will be automatically set to the latest managed version. We will save the modifications to our POM file, which will trigger NetBeans to load the requested dependency from the repository and place it in the <span class="strong"><strong>Dependencies</strong></span> folder within your project. If you issue the build command (<span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Build Project</strong></span>) for the project at this stage, we will still get an error. We are missing the source code for the plugin; this will be our next step.</p><p>To add our source code, we <a id="id502" class="indexterm"/>will need to add a new Java class file to our project. The following steps will let you create the main class file for this project; however, these steps are identical to generate other classes that you want to add to the same project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the <code class="literal">Object_Tracker</code> project and go to <span class="strong"><strong>New | Java Class…</strong></span> from the context menu.</li><li class="listitem">Enter <code class="literal">Object_Tracker</code> as the name for the new class, and set the <span class="strong"><strong>Location</strong></span> to <code class="literal">/src/main/java</code>.</li></ol></div><p>You will get a new java source file, and in the <span class="strong"><strong>Projects</strong></span> view you will see the <span class="strong"><strong>Source Packages</strong></span> directory is added to your project. You can now try and build the project again, which should now finish successfully. As a Maven project can also create Javadoc documentation for a project, we will also make sure that we add Javadoc comments to our class, and methods to document the API of our plugin. We will start the development of our plugin by implementing it as a <code class="literal">PlugInFilter</code> type.</p></div>
<div class="section" title="Creating a basic PlugInFilter"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Creating a basic PlugInFilter</h1></div></div></div><p>To create a <a id="id503" class="indexterm"/>
<code class="literal">PlugInFilter</code> implementation, we add the <code class="literal">implements</code> keyword behind the class name and specify <code class="literal">PlugInFilter</code> as the implementation. When you do this using an IDE, such as NetBeans, it will place a red squiggly underline under this statement. When you place the cursor on the line with the squiggly underline and press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span> (in NetBeans), the editor will give you a list of suggestions to rectify the mistake that we made. The first complaint is that NetBeans cannot find the <code class="literal">PlugInFilter</code> symbol because we haven't added it yet. Press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span> and select the option called <span class="strong"><strong>Add import</strong></span> for <code class="literal">ij.plugin.filter.PlugInFilter</code>. You will now see that the import statement is added to your source file (usually at the top of the source file). We now still have a squiggly underline in our class statement as it is missing the overrides for the abstract setup and run methods. As explained in <a class="link" href="ch08.html" title="Chapter 8. Anatomy of ImageJ Plugins">Chapter 8</a>, <span class="emphasis"><em>Anatomy of ImageJ Plugins</em></span> <code class="literal">PlugInFilter</code> requires these two methods to be present and overridden with your initialization code (setup) and your programming logic (run). Use the <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span> method, and choose the option called <span class="strong"><strong>Implement all abstract methods</strong></span> from the list of choices. At this stage, we have a <a id="id504" class="indexterm"/>basic <code class="literal">PlugInFilter</code> implementation that contains all the required elements.</p><div class="section" title="Testing our current implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec60"/>Testing our current implementation</h2></div></div></div><p>There is no <a id="id505" class="indexterm"/>functional code yet, but let's test what happens when we try to run the project at this stage. When you go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Project</strong></span> from the menu, you will get a dialog that asks for the <code class="literal">main</code> class to be run. Since we did not specify a <code class="literal">main</code> method (yet), we cannot proceed and can only select cancel. We need to do two things: first, we need to add a <code class="literal">main</code> method to our source code file, and secondly, we need to tell Maven which class contains the <code class="literal">main</code> method. We will start with the first item on the list.</p><p>To add the <code class="literal">main()</code> method, we add the following code somewhere within the body of our class:</p><div class="informalexample"><pre class="programlisting">public static void main(String... args) {

}</pre></div><p>This is a standard Java style declaration of a <code class="literal">main</code> method that takes a <code class="literal">String</code> list of parameters stored in the <code class="literal">args</code> variable. The triple dots behind the <code class="literal">String</code> type indicate that this method can be called with a variable number of <code class="literal">String</code> arguments ranging from none to many. This type of calling structure can be helpful if you want to run your plugin via a <span class="strong"><strong>Command Line Interface</strong></span> (<span class="strong"><strong>CLI</strong></span>). Since we will mostly ignore the input parameters for now, it is not important to use them within the body of the <code class="literal">main</code> method.</p><p>For the second step, we can modify our project in two separate ways. We can type the <code class="literal">&lt;main-class&gt;</code> tag in the <code class="literal">&lt;properties&gt;</code> tag in the POM file (see <a class="link" href="ch07.html" title="Chapter 7. Explanation of ImageJ Constructs">Chapter 7</a>, <span class="emphasis"><em>Explanation of ImageJ Constructs</em></span>), or we can use the features of the IDE. To edit how the project is run, you can right-click on the project in the <span class="strong"><strong>Projects</strong></span> view and select <span class="strong"><strong>Properties</strong></span> from the context menu. This will open the properties available for this type of project. Select the <span class="strong"><strong>Run</strong></span> category from the left-hand side of the properties dialog:</p><div class="mediaobject"><img src="graphics/B04909_09_02.jpg" alt="Testing our current implementation"/></div><p>You can now see that there is an option to set the <span class="strong"><strong>Main Class</strong></span>. By pressing the <span class="strong"><strong>Browse…</strong></span> button, you are able to select the <code class="literal">Object_Tracker</code> class that contains our <code class="literal">main</code> method. You may also notice that you can specify <span class="strong"><strong>Arguments</strong></span> to your <code class="literal">main</code> method. The content of this field will be used as input parameters to your main method's argument <code class="literal">args</code>. One option we might also want to enter at a later stage is the <span class="strong"><strong>VM Options</strong></span> field. This option will allow <a id="id506" class="indexterm"/>us to control the amount of memory that is allocated to the application. For now, only select the <code class="literal">Object_Tracker</code> as the <span class="strong"><strong>Main Class</strong></span>. This will generate two new files in NetBeans where the run configuration is stored: <code class="literal">nbactions.xml</code> and <code class="literal">nb-configuration.xml</code>. Alternatively, you can add the sections to the <code class="literal">pom.xml</code> file, as described in <a class="link" href="ch07.html" title="Chapter 7. Explanation of ImageJ Constructs">Chapter 7</a>, <span class="emphasis"><em>Explanation of ImageJ Constructs</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Please note that using the <span class="strong"><strong>Properties</strong></span> method, you will limit your application to the NetBeans framework. If you wish to exchange your code with others that do not use NetBeans, you always want to choose the pure Maven approach and define your <code class="literal">main</code> class in the <code class="literal">pom.xml</code> file directly.</p></div></div><p>If you try to run the project now by navigating to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Project</strong></span>, you will get no errors and the building will be successful. The only problem is that nothing happens; we don't see ImageJ, and our plugin cannot be found. We still need to implement our main method to make sure that ImageJ is launched. To do this, we add a new instance of ImageJ to our <code class="literal">main</code> method, and save the source file:</p><div class="informalexample"><pre class="programlisting">public static void main(String... args) {
  new ImageJ();
}</pre></div><p>After fixing the error by adding the import for <code class="literal">ij.ImageJ</code>, we run our project and we will see the <a id="id507" class="indexterm"/>ImageJ interface. If you go to <span class="strong"><strong>Help</strong></span> | <span class="strong"><strong>About ImageJ</strong></span>, you will see that the version is indeed set to <span class="strong"><strong>1.50b</strong></span>. However, when we look in the <span class="strong"><strong>Plugins</strong></span> menu, we will not find our plugin there. We will use the same trick as shown in <a class="link" href="ch07.html" title="Chapter 7. Explanation of ImageJ Constructs">Chapter 7</a>, <span class="emphasis"><em>Explanation of ImageJ Constructs</em></span> to fix our plugins directory mix-up by adding the following code to our <code class="literal">main</code> method before calling <code class="literal">new ImageJ()</code>:</p><div class="informalexample"><pre class="programlisting">/* set the plugins.dir property to make the plugin appear in the Plugins menu */
Class&lt;?&gt; clazz = Object_Tracker.class;
String url = clazz.getResource("/" + clazz.getName().replace('.', '/') + ".class").toString();
int lastIdx = url.lastIndexOf('/');

String pluginsDir = url.substring(5, lastIdx);
System.setProperty("plugins.dir", pluginsDir);</pre></div><p>After saving the source file and running the project, we will now see our plugin in the <span class="strong"><strong>Plugins</strong></span> menu. When you launch the plugin you will get an error specifying that this method is not implemented yet. This is caused by the fact that the body of the abstract <code class="literal">setup</code> and <code class="literal">run</code> methods only contain an exception that is being thrown (this depends on your installation of NetBeans and your templates). We have the plugin framework completed, and next, we will implement our functionality.</p></div><div class="section" title="Implementing the setup method"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec61"/>Implementing the setup method</h2></div></div></div><p>We will start <a id="id508" class="indexterm"/>with implementing the <code class="literal">setup</code> method, which serves as a basic checkpoint to see if our plugin can process the currently active image. We can also use this method to make some preparations and perform some basic checks before we run our plugin. We will start with clearing the current statement from the body of the <code class="literal">setup</code> method and add a return value. The <code class="literal">setup</code> method requires that an integer value be returned, which tells ImageJ the type of image that can be processed using this plugin. We will also add some Javadoc comments to this function to explain what is going on in this function. For this project, I will assume that the following structure is the structure of the source code file:</p><div class="informalexample"><pre class="programlisting">//import section
import ij.ImageJ;

//class declaration
public class Object_Tracker implements PlugInFilter {
  //class-wide variables
  private ImagePlus imp;
  /*etc...*/
  
  //constructor
  public void Object_Tracker() {}
  
  //main method
  public static void main(String... args) {}
  
  //setup method
  public int setup(String arg, ImagePlus imp) {}
  
  //run method
  public void run(ImageProcessor ip) {}
  
  //additional methods follow below this point
  /*methods for image processing*/
  
}</pre></div><p>You are of course free to deviate from this template (within the bounds of Java syntax and programming logic). This type of structure is common to Java files, and it contains some elements that are not strictly required, but which can be useful. The constructor is not required to be present in an ImageJ plugin. However, it can be useful to add it, as it allows an increase in usability when you want to call your plugin from within other projects. Using the <a id="id509" class="indexterm"/>constructor, you can implement certain initializations or assert control over how the plugin is created.</p><div class="section" title="The return type and autocomplete"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec52"/>The return type and autocomplete</h3></div></div></div><p>We will start <a id="id510" class="indexterm"/>with adding the return statement specifying <a id="id511" class="indexterm"/>the type of images that we expect to process. For this project, we are interested in quantifying objects over time in a single channel (for now), so we will expect to process stacks of either 8 or 16-bit. Therefore, we add the following return statement:</p><div class="informalexample"><pre class="programlisting">return DOES_8C+DOES_8G+DOES_16;</pre></div><p>When typing in an IDE, you can use its autocomplete functionality to determine which type you wish to return. If you type <code class="literal">DOES</code> and press <span class="emphasis"><em>Ctrl</em></span> + Spacebar you will get a list of the possible autocomplete options. You can use the mouse or the arrow keys to select an option from the list, and by double-clicking it or pressing enter, it will be inserted at the point you were typing. If the list of options is very long, you can also continue typing after you have pressed <span class="emphasis"><em>Ctrl</em></span> + Spacebar. For every character that you add, the list will become more selective to match what you are typing. For example, when you type <code class="literal">_1</code> after you typed <code class="literal">DOES</code>, you will only get the single option <code class="literal">DOES_16</code>. Another nice feature is that when you <a id="id512" class="indexterm"/>select an option from the autocomplete list, it <a id="id513" class="indexterm"/>will also show the Javadoc for that selection. However, you may have noticed that this didn't work here; the IDE stated that the Javadoc was not found. We will remedy this in the next section.</p></div><div class="section" title="Javadoc for methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec53"/>Javadoc for methods</h3></div></div></div><p>As we saw, the Javadoc for our ImageJ project was not found. We will now fix this using the IDE, which <a id="id514" class="indexterm"/>only takes a few simple steps. First, we make sure that our Javadoc view is open by activating it. Go to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>IDE Tools</strong></span> | <span class="strong"><strong>Javadoc Documentation</strong></span> from the menu to activate the view. When we place our cursor on an object such as the <code class="literal">DOES_16</code> statement that we entered above, the Javadoc view will display the same message that we noticed in the autocomplete window. However, it also displays an option at the bottom called <span class="strong"><strong>Attach Javadoc…</strong></span> in the form of a link. When you click on it, a window will ask you for the location of the documentation. There is also a button called <span class="strong"><strong>Download</strong></span>, which will automatically download the Javadoc for the ImageJ version that we listed as a dependency in our project. After clicking OK, you will now see that the Javadoc view shows the documentation for the <code class="literal">DOES_16</code> field. You can also generate the Javadoc for your project by right-clicking on your project in the Projects view and selecting <span class="strong"><strong>Generate Javadoc</strong></span> from the context menu.</p><p>We will now create our own Javadoc comments for our setup method. The easiest way to do this using the IDE is to place the cursor on the setup method and press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span>. An option will be displayed stating <span class="strong"><strong>Create missing Javadoc for setup</strong></span>, which we will choose.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>You can also place your cursor above the method you wish to document, and type <code class="literal">/**</code>, and press <span class="emphasis"><em>Enter</em></span>. In NetBeans, typing the start of a Javadoc comment and pressing <span class="emphasis"><em>Enter</em></span> will autocomplete the Javadoc comment, and it will add the arguments and return type of your method as well.</p></div></div><p>After selecting this option, a Javadoc comment is added above the setup method containing the following information:</p><div class="informalexample"><pre class="programlisting">/**
 *
 * @param arg
 * @param ip
 * @return
 */</pre></div><p>This is the standard content for a Javadoc section that describes a method with input parameters and a return value. Parameters are designated as <code class="literal">@param</code> followed by the variable name. There is one <code class="literal">@param</code> line for each parameter in the methods arguments list. To add information about the parameter, you can start typing right after the variable name (make sure that there is a space between the variable name and your description). The first line above <a id="id515" class="indexterm"/>the parameter list is meant to provide a brief description of the methods purpose. Let's add some of the information about the <code class="literal">setup</code> method:</p><div class="informalexample"><pre class="programlisting">/**
 * This is the setup method for the Object Tracker plugin
 *
 * @param arg input argument for control
 * @param ip Currently active image
 * @return DOES_8G, DOES_8C and DOES_16
 */</pre></div><p>When you look at the Javadoc viewer now, you will see the text that you added is displayed and formatted. Please note that you can use standard HTML tags to format your text with paragraphs, headings, tables, and lists. At this stage it is possible to generate the Javadoc for your plugin and view it in a browser. To do so, right-click on your project in the <span class="strong"><strong>Projects</strong></span> view and select <span class="strong"><strong>Generate Javadoc</strong></span> from the context menu. After waiting a bit while the IDE is busy scanning the project and building the documentation, you can open the Javadoc in a browser by opening the <code class="literal">index.html</code> file from the <code class="literal">target/site/apidocs/</code> folder in the root of your project. Alternatively, you can click on the link in the <span class="strong"><strong>Output</strong></span> view which can be activated by navigating to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Output</strong></span> from the menu. The result will be as follows:</p><div class="mediaobject"><img src="graphics/B04909_09_03.jpg" alt="Javadoc for methods"/></div><p>In the preceding screenshot, you can see the setup method with the text that we added as a description, and at the bottom, we see the details we entered for the parameters and the return value.</p><p>It is good practice to add this information as you develop your source code, both for your own benefit <a id="id516" class="indexterm"/>when you review your code weeks from now, as well as for other developers who may wish to use or expand your code for their own projects. As the Javadoc tool takes care of all the processing and layout of the documentation, you only need to add the descriptions for the methods and classes. I will not explicitly add the documentation sections in the code snippets in this chapter, but they will be part of the final source code. After this small digression, we will return to creating a plugin to detect objects.</p></div><div class="section" title="Finishing the setup method"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec54"/>Finishing the setup method</h3></div></div></div><p>After <a id="id517" class="indexterm"/>completing the previous sections, we now have a <code class="literal">setup</code> method with a return value indicating that we will be processing all 8 or 16-bit images and stacks. We will now perform a few more checks that will be required for the processing to complete. The first step is to make sure that the ROI Manager is open so that we can see the detections and the results of our detection. At this stage, it might also be a good idea to think about the type of images we may want to process. Do we want to process RGB or multichannel images and stacks or only single channel stacks?</p><p>We will start with checking if the ROI Manager is available. To do this, we can use the <code class="literal">getInstance()</code> method from the <code class="literal">RoiManager</code> class. This method will return a value of <code class="literal">null</code> when it is not open yet; otherwise, it will return the reference of the ROI Manager instance. Add the following to the <code class="literal">setup</code> method before the return statement:</p><div class="informalexample"><pre class="programlisting">if(RoiManager.getInstance() == null) {
  new RoiManager();
}</pre></div><p>If you used the autocomplete option to select the <code class="literal">RoiManager</code> class, NetBeans also automatically added the required import statement at the top of your source code file. If you copied and pasted the code, you will need to add the import statement yourself using either the <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span> option or by typing it manually.</p><p>The only thing left to do in the setup is to check the image type; it needs to be a single channel image with a single frame or slice, or multiple frames and a single slice. The first step is to obtain the dimensions of the current image and then check whether it matches our specifications. For the current incarnation of the plugin, I will make these specifications binding so that when it fails, the plugin will not run. The code for retrieving the dimensions and checking whether they match our specifications is as follows:</p><div class="informalexample"><pre class="programlisting">//get the dimensions of the current image
int[] dims = ip.getDimensions();
if (dims[2] &gt; 1){
  //more than 1 channel
  return DONE;
}
else if(dims[3] &gt; 1 &amp;&amp; dims[4] &gt; 1) {
  //multiple slices AND frames
  return DONE;
}</pre></div><p>The <code class="literal">getDimensions()</code> method returns a vector of length <code class="literal">5</code>, with the width, height, channels, slices, and frames (in that order).</p><p>At this stage, I would like to introduce another useful feature of an IDE that will make your coding life much easier. When the IDE added the abstract methods for setup and run, it used the <code class="literal">ip</code> parameter name for both the <code class="literal">ImagePlus</code> type in the <code class="literal">setup</code> method and the <code class="literal">ImageProcessor</code> type in the <code class="literal">run</code> method. This is slightly confusing and inconsistent. The convention for <code class="literal">ImagePlus</code> objects is to use <code class="literal">imp</code> as a reference name, and <code class="literal">ip</code> for <code class="literal">ImageProcessor</code> references. We will now use the <span class="strong"><strong>Refactor</strong></span> option in the IDE to fix this problem.</p><p>We will start by selecting the parameter that we would like to change; in this case, the <code class="literal">ip</code> parameter in the <code class="literal">setup</code> method. We then go to <span class="strong"><strong>Refactor</strong></span> | <span class="strong"><strong>Rename</strong></span> from the context menu or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>R</em></span>. You will now see that there is a red box around the parameter, and you can change the name by typing a new name. When you now type <code class="literal">imp</code>, you will see that only the names associated with the <code class="literal">setup</code> method are changed. This does not affect the <a id="id518" class="indexterm"/>parameter of the <code class="literal">run</code> method. Also, the Javadoc section is updated to reflect the new variable name. This is a great feature to use when changing the name of a variable, and it is much more effective than a search-and-replace style approach. If you would have used search and replace, the variable name in the run method may have also been changed, making it inconsistent again.</p><p>If we now run our project, we should see the plugin in the <span class="strong"><strong>Plugins</strong></span> menu, but when we launch it, we will receive a <code class="literal">NullPointerException</code> exception. This is caused by the fact that we tried to retrieve the dimensions from a nonexistent image. So, we need to add a final check before we call the <code class="literal">getDimensions()</code> method to check if the <code class="literal">imp</code> parameter is not equal to <code class="literal">null</code>:</p><div class="informalexample"><pre class="programlisting">if (imp == null) { return DONE; }</pre></div><p>This will make sure that nothing happens when you have no image open or the wrong kind of image compared to what the plugin expects. It is currently not very user-friendly. When the user activates a plugin, he or she would expect something to happen. It would be nice if there were some feedback to indicate why nothing happened. As an example, I will add a message stating that the plugin requires a stack to be opened before exiting. To do so, we add the following statement to the body of the statement checking for the image:</p><div class="informalexample"><pre class="programlisting">if (imp == null) {
  IJ.showMessage("We need a single channel stack to continue!");
  return DONE;
}</pre></div><p>Now when you run your project and launch the plugin, the following message will be displayed:</p><div class="mediaobject"><img src="graphics/B04909_09_04.jpg" alt="Finishing the setup method"/></div><p>This is much more user-friendly and avoids generating unnecessary errors, which can be confusing to users. Most of the errors and exceptions generated by compilers are cryptic at best, and most non-programmers will not understand what went wrong. Now that we have finished the <a id="id519" class="indexterm"/>setup method, we will now focus on implementing the actual functional code that will perform the processing.</p></div></div><div class="section" title="Implementing the run method"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec62"/>Implementing the run method</h2></div></div></div><p>As mentioned in <a class="link" href="ch08.html" title="Chapter 8. Anatomy of ImageJ Plugins">Chapter 8</a>, <span class="emphasis"><em>Anatomy of ImageJ Plugins</em></span> the run method is the entry point for the <code class="literal">PlugInFilter</code> type. At this stage we know <a id="id520" class="indexterm"/>for sure that we have an 8 or 16-bit stack with a single channel; otherwise, we would have never reached the run method. We can now start implementing our algorithm to detect the object. After that, we will look at the required methods to measure the object in the current frame, and finally, how to process each object across frames in the case of multiple objects. We will start with the detection first, as this is the primary step that needs to be solved.</p><div class="section" title="Detecting an object"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec55"/>Detecting an object</h3></div></div></div><p>To be able to <a id="id521" class="indexterm"/>detect an object, we need to know about some of the properties that make the object identifiable. This may sound simpler than it really is. The human visual system is highly capable of finding objects in all types of lighting conditions and situations. Computer algorithms are only starting to approach the same levels of detection that feel natural to humans. For this example, I will limit the detection of objects based on the intensity of the object relative to the background. I'm going to assume that the object we wish to detect is bright compared to the darker background, as is the case in fluorescence imaging for example. We will use the <span class="strong"><strong>Confocal Series</strong></span> sample image to practice with as an example.</p><p>We need to make a few small preparations before we can start using this image. The image contains two channels, which is an exclusion criterion for our plugin! So we split the image into separate channels, and convert one of them to 16-bit before saving them both to disk as TIFF files. Using the knowledge from <a class="link" href="ch02.html" title="Chapter 2. Basic Image Processing with ImageJ">Chapter 2</a>, <span class="emphasis"><em>Basic Image Processing with ImageJ</em></span> and <a class="link" href="ch03.html" title="Chapter 3. Advanced Image Processing with ImageJ">Chapter 3</a>, <span class="emphasis"><em>Advanced Image Processing with ImageJ</em></span> you should be capable of performing these steps. We will use a threshold to detect the object based on the intensity, and based on that threshold, create a selection that will be added to the ROI manager. For the detection, we will create a method called <code class="literal">performDetection()</code> that will be called from the <code class="literal">run</code> method. As we assume a stack, we will also need to add a loop to go over each of the slices. We will start with the loop statement in the <code class="literal">run</code> method:</p><div class="informalexample"><pre class="programlisting">int nFrames = imp.getImageStackSize();
for (int f=0; f&lt;nFrames; f++) {
  imp.setSlice(f+1);
  ip = imp.getProcessor();
  performDetection(ip);
}</pre></div><p>Notice the slightly odd behavior for the <code class="literal">setSlice</code> method. Unlike arrays and other indexed objects in Java, the slice indices for an image are not zero-based. This idiosyncrasy was <a id="id522" class="indexterm"/>observed back in <a class="link" href="ch02.html" title="Chapter 2. Basic Image Processing with ImageJ">Chapter 2</a>, <span class="emphasis"><em>Basic Image Processing with ImageJ</em></span>. Next, we create the method to perform the detection, and we add the following statements:</p><div class="informalexample"><pre class="programlisting">private void performDetection(ImageProcessor ip) { ip.setAutoThreshold(AutoThresholder.Method.Default, true);
  imp.setProcessor(ip);
  Roi roi = ThresholdToSelection.run(imp);
  rm.addRoi(roi);
}</pre></div><p>This sets an automatic threshold using the default method (first parameter) and using a dark background (second parameter). When using the autocomplete option, many of these values will be filled in by default making it easier to write code, but not necessarily to understand it. We then add the new threshold to the current image using a reference to a class-wide variable that we added to our class definition (see the template for the class file that was mentioned earlier).</p><div class="informalexample"><pre class="programlisting">public class Object_Tracker implements PlugInFilter{
  private ImagePlus imp;
  private RoiManager rm;</pre></div><p>This allows us access to the current image and the ROI Manager throughout our class. We also modify the setup method slightly to accommodate these changes using the <code class="literal">rm</code> reference to get the instance or store a new reference to the ROI Manager. We do the same for the class-wide <code class="literal">ImagePlus</code> variable (<code class="literal">this.imp</code>) by storing the current image that comes in with the <code class="literal">setup</code> method.</p><div class="informalexample"><pre class="programlisting">rm = RoiManager.getInstance();
if(rm == null) { rm = new RoiManager();}
        
this.imp = imp;</pre></div><p>To add our thresholded object to the ROI manager, we use the <code class="literal">ThresholdToSelection</code> class (another <code class="literal">PlugInFilter</code> type) that comes with ImageJ. This is the class that is activated when you navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Selection</strong></span> | <span class="strong"><strong>Create Selection</strong></span> from the ImageJ menu. This is a nice example of one plugin calling the <code class="literal">run</code> method of another plugin. This means that we can also use the <code class="literal">run</code> method of our plugin in other plugins or macros.</p><p>We will now test our plugin by running the project and opening one of the images we saved, before launching our plugin. It should now run through all the slices of the stack and populate the ROI <a id="id523" class="indexterm"/>manager at every frame. The ROIs look quite good, but there are still a few small problems. There are holes in some of the ROIs, and some ROIs have small isolated pixels that are not connected to the main object. In the next section, we will examine ways to refine the detection using the techniques that we learned back in <a class="link" href="ch04.html" title="Chapter 4. Image Segmentation and Feature Extraction with ImageJ">Chapter 4</a>, <span class="emphasis"><em>Image Segmentation and Feature Extraction with ImageJ</em></span>.</p></div><div class="section" title="Refining the detection"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec56"/>Refining the detection</h3></div></div></div><p>When we tested the <a id="id524" class="indexterm"/>plugin at the end of the previous section, we noted some shortcomings of the current detection method using only a threshold. We saw holes in the object and small isolated pixels that we would like to remove. This is something that can be achieved using binary processing as discussed in <a class="link" href="ch04.html" title="Chapter 4. Image Segmentation and Feature Extraction with ImageJ">Chapter 4</a>, <span class="emphasis"><em>Image Segmentation and Feature Extraction with ImageJ</em></span>. We will now implement this processing before we convert the threshold to a selection. The first step is to take our ROI and use it to create a mask image, which we will process using the techniques that we learned in <a class="link" href="ch04.html" title="Chapter 4. Image Segmentation and Feature Extraction with ImageJ">Chapter 4</a>, <span class="emphasis"><em>Image Segmentation and Feature Extraction with ImageJ</em></span>. To create our mask image, we do the following:</p><div class="informalexample"><pre class="programlisting">ImagePlus impMask = new ImagePlus("mask", new 
  ByteProcessor(imp.getWidth(), imp.getHeight()));
impMask.setRoi(roi);
        
ImageProcessor ipMask = impMask.getProcessor();
ipMask.setColor(255);
ipMask.fill(impMask.getMask());
ipMask.invertLut();</pre></div><p>This code is inserted between the <code class="literal">Roi roi...</code> statement and the <code class="literal">rm.addRoi(roi)</code> statement in the <code class="literal">performDetection</code> method. The first line creates a new image called mask with a <code class="literal">ByteProcessor</code> for the <code class="literal">ImageProcessor</code>; this results in an 8-bit image. The width and the height are set to be equal to the original image. This is important when you want to measure the object in the original image. If you create a mask directly from the image, its size will be the size of the bounding rectangle of the ROI. Next we add the ROI to the new image, and get a reference to the <code class="literal">ImageProcessor</code> for this image. This will allow us to modify the pixels of the mask. Next, we set the foreground color to white <code class="literal">(255)</code> and fill the mask with white. Finally, we invert the LUT for the binary processing. Next, we will perform the binary processing. We want to fill the holes and get rid of the isolated pixels.</p><p>We will start with filling the holes in the shape using the <code class="literal">Binary</code> plugin. This is a class that implements a <code class="literal">PlugInFilter</code>; however, the use is a little different this time. We first need to create an instance of the class, and then set up the class for our purpose. We will add the following code directly underneath the last statement of the previous code listing:</p><div class="informalexample"><pre class="programlisting">Binary B = new Binary();
B.setup("fill", impMask);
B.run(ipMask);</pre></div><p>First, we create a new instance of the <code class="literal">Binary</code> class and add the import statement for <code class="literal">ij.plugin.filter.Binary</code> at the top of our source code file. Next, we set up the plugin to perform the task that we want, in this case, filling the holes in our mask. We do this by calling the <code class="literal">setup</code> method with a <code class="literal">String</code> argument (<code class="literal">"fill"</code>) and an <code class="literal">ImagePlus</code> argument (our mask image). Our own plugin has a similar form for the setup; this means that we could also choose to implement a similar system later on. In the last step, we call the <code class="literal">run</code> method of the <code class="literal">Binary</code> plugin, which will perform the actual processing on our image.</p><p>Next, we will use the <a id="id525" class="indexterm"/>erode and dilate operators to get rid of isolated pixels. We will run the erode operator three times and the dilate operator five times to create a smooth mask:</p><div class="informalexample"><pre class="programlisting">for (int i=0;i&lt;3; i++) {ipMask.erode();}
for (int i=0;i&lt;5; i++) {ipMask.dilate();}</pre></div><p>These values are quite arbitrary and other values might be more suitable when using different images. Finally, we set a threshold on our mask image to obtain a new ROI using the <code class="literal">ThresholdToSelection</code> method, just like we did before:</p><div class="informalexample"><pre class="programlisting">roi = ThresholdToSelection.run(impMask);
impMask.setRoi(roi);
rm.addRoi(roi);</pre></div><p>We use the <code class="literal">roi</code> variable again because we don't need the ROI that we created in the original image. We then add the new ROI to the ROI Manager, which is the last step for our detection. If you run the project and try it on the test images, you will see the effect of the binary processing—the ROIs are a bit more smooth and contain almost no isolated pixels anymore. The following image shows all the ROIs overlaid on the first frame of the original stack. I used the green channel for this example, but you can also try to run the plugin on the red channel.</p><div class="mediaobject"><img src="graphics/B04909_09_05.jpg" alt="Refining the detection"/></div></div><div class="section" title="Detecting multiple objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec57"/>Detecting multiple objects</h3></div></div></div><p>Up to this <a id="id526" class="indexterm"/>point, we assumed that we have only a single object in our frames. I will now look at a method that allows detecting multiple objects. To do this, we will use another technique that we learned in <a class="link" href="ch03.html" title="Chapter 3. Advanced Image Processing with ImageJ">Chapter 3</a>, <span class="emphasis"><em>Advanced Image Processing with ImageJ</em></span>. There, we looked at Z-projections and how they can be used to flatten a stack into a single image. We will now use this same technique to define our search space to detect the objects in the time series. By creating a maximum intensity projection, we can visualize all the pixels that our object will occupy at one time or another during the time series. This projection will help us define the search space. For <span class="emphasis"><em>N</em></span> number of objects that do not overlap, you will get <span class="emphasis"><em>N</em></span> search spaces.</p><p>To start with, we need to create the maximum intensity projection. To do this, we can use the <code class="literal">ZProjector</code> class and set it to maximum intensity using <code class="literal">MAX_METHOD</code>:</p><div class="informalexample"><pre class="programlisting">//create a maximum intensity projection
ZProjector zp = new ZProjector(imp);
zp.setMethod(ZProjector.MAX_METHOD);
zp.doProjection();
ImagePlus impMax = zp.getProjection();

//set a threshold in the maximum intensity projection
ImageProcessor ipMax = impMax.getProcessor();
ipMax.setAutoThreshold(AutoThresholder.Method.Default, true);
impMax.setProcessor(ipMax);</pre></div><p>We start by creating a new <code class="literal">ZProjector</code> instance using the original stack as an input. Next, we set the method to be used, and perform the projection. Finally, we retrieve the maximum intensity projection image using the <code class="literal">getProjection()</code> method. Next up, we will use the <code class="literal">ParticleAnalyzer</code> class to detect the objects in our maximum intensity projection that will define our search spaces.</p><p>To use the particle analyzer, we create an instance of the class and set its parameters to determine the search spaces. For this example, we want to find objects that are relatively large, so we will <a id="id527" class="indexterm"/>set a minimum size limit for the particles but not for the shape. To do this, we can use the following code:</p><div class="informalexample"><pre class="programlisting">//set the options for the particle analyzer
int nOpts = ParticleAnalyzer.ADD_TO_MANAGER;
int nMeasures = ParticleAnalyzer.SHOW_NONE;
double dMin = 500.0; 
double dMax = Double.MAX_VALUE

//perform the particle analysis
ParticleAnalyzer pa = new ParticleAnalyzer(nOpts, nMeasures, new ResultsTable(), dMin, dMax);
RoiManager rmMax = new RoiManager(true);
ParticleAnalyzer.setRoiManager(rmMax);
pa.analyze(impMax);

//get the detected particles
Roi[] searchSpaces = rmMax.getRoisAsArray();</pre></div><p>We start by setting the options and the measurements that we want. In this case, we only care about the found objects' location, so we need ROIs at the end of the detection (indicated by the <code class="literal">ADD_TO_MANAGER</code> option). The option for measurements is set to none to avoid generating results or other objects (indicated by <code class="literal">SHOW_NONE</code>). We then initialize the particle analyzer using the options and sizes that we specified. Next, we create an instance of an ROI Manager that will not be displayed. This instance of our ROI Manager will be assigned to our particle analyzer before we analyze our image using the <code class="literal">analyze()</code> method. This is necessary because we don't want to measure these intermediate ROIs, we only use them to identify and process each search space. In the last step, we extract the search spaces as ROI objects from our temporary ROI Manager instance. With our search spaces defined, we can start the detections for each search space individually.</p><p>The detections can be created in a similar way as we saw before with a small alteration: instead of using the <a id="id528" class="indexterm"/>entire image, we want to perform our detection within the search space for the individual object. We can achieve this by setting the search space ROI on our image and duplicate it using the <code class="literal">duplicate()</code> method. We then have access to the pixels from this cropped region:</p><div class="informalexample"><pre class="programlisting">//perform the detection for each search space
for (Roi searchSpace : searchSpaces) {
  imp.setRoi(searchSpace);
  impProcess = imp.duplicate();
  for (int f = 0; f &lt; nFrames; f++) {
    impProcess.setSlice(f + 1);
    ip = impProcess.getProcessor();
    performDetection(impProcess, ip);
  }
}</pre></div><p>We do this for each of our search spaces using the for-each syntax, and perform the detection as before. There are some other alterations that are required to make this work, so take a look at the complete code listed in the code bundle at Packt Publishing's website.</p></div></div><div class="section" title="Implementing the measurements"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec63"/>Implementing the measurements</h2></div></div></div><p>Now that we <a id="id529" class="indexterm"/>have our objects identified for each slice, we can start to look at measuring our object. We will use some of the knowledge from <a class="link" href="ch05.html" title="Chapter 5. Basic Measurements with ImageJ">Chapter 5</a>, <span class="emphasis"><em>Basic Measurements with ImageJ</em></span> to design a measurement for this object. Depending on the type of object, we may want to look at different measurements that may be important, but I will start with some of the obvious ones for the type of ROIs that we created. Our ROIs are area selections, so the first metric that seems relevant is the area of the object(s). Other relevant measurements are the mean intensity and the shape of the object(s). We will implement the measurements in a separate method that we will add to our class. The method will have the following declaration:</p><div class="informalexample"><pre class="programlisting">private void performMeasurements() {
  Analyzer.setMeasurements(msrmnt);
  imp.unlock();
  rm.runCommand(imp,"Measure");
}</pre></div><p>We will be using the ROIs in the ROI Manager so that we don't require an input argument. We will set the measurements according to the values that we discussed before by adding a variable called <code class="literal">msrmnt</code> at the beginning of our class declaration:</p><div class="informalexample"><pre class="programlisting">private static final int msrmnt = Measurements.SLICE + Measurements.AREA + Measurements.CIRCULARITY + Measurements.MEAN;</pre></div><p>This is used to set the measurements to the slice number, area, circularity, and mean. We use the <code class="literal">Analyzer</code> class and its <code class="literal">setMeasurements</code> method to get the desired results. Finally, we call the <code class="literal">unlock</code> method on our image to allow the macro command of the ROI Manager to gain access to our image for the measurements. If you omit this statement, the plugin will run without visible errors, but you will not get any results. To get the results, we call our measurement method directly after the loop has finished. In the next section, we will add some user interaction to our plugin, allowing us to change some of the <a id="id530" class="indexterm"/>parameters that are used in the detection. We will also introduce the preferences system of ImageJ to allow the storage of our parameters for future use.</p></div></div>
<div class="section" title="Adding user interaction and preferences"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Adding user interaction and preferences</h1></div></div></div><p>The plugin <a id="id531" class="indexterm"/>that we have created thus far runs fine as a standalone <a id="id532" class="indexterm"/>plugin. However, it is also very easy to increase its power by allowing it to run in batch mode over a folder containing a large set of data files. This section will look at some of the changes that need to be incorporated for it to work. By setting certain steps as individual methods that can be called when the main class is instantiated, we can perform specific steps in a similar way as we have been doing for other classes. In our example, we used the <code class="literal">ParticleAnalyzer</code>, <code class="literal">ThresholdToSelection</code> and the <code class="literal">Binary</code> plugin classes in a similar way. The only requirements that we need to add are some constants and default settings that allow this class to work with minimal configuration. In the following sections, I will show you a few alterations that can make this class a bit more flexible to use in other plugins.</p><div class="section" title="Settings and options dialog"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec64"/>Settings and options dialog</h2></div></div></div><p>We have several <a id="id533" class="indexterm"/>parameters in our plugin that will influence how it <a id="id534" class="indexterm"/>behaves. Variables, such as particle size and the thresholding method, will influence the outcome, and have to be adjusted to match the data. ImageJ allows you to set and get preferences that can be stored specifically for your plugin. It uses a key-value system that stores the value for a preference using a specific key name. The key name is a string, which must be unique to your plugin preferably. To set and get a preference, such as the minimum particle size, you can use the following syntax:</p><div class="informalexample"><pre class="programlisting">Prefs.set("object_tracker.minParticleSize", 500.0);
double DMIN = Prefs.getDouble("object_tracker.minParticleSize", 500.0);
Prefs.savePreferences();</pre></div><p>The first line shows you how to store the double value <code class="literal">500.0</code> into a preference using the <code class="literal">object_tracker.minParticleSize</code> key. The naming of keys does not really have a strict convention, but using the <code class="literal">&lt;class name&gt;.&lt;key name&gt;</code> construction makes sure that the key will be unique and identifiable. The second line retrieves the setting from the preferences. The second value that is supplied is a default value. If the key does not exist, the <code class="literal">DMIN</code> variable will be set to this default value (in this case <code class="literal">500.0</code>). Finally, we can save the preferences using the <code class="literal">savePreferences()</code> method.</p><p>To change the values used in our plugin, we can display a small dialog that allows the user to enter values or <a id="id535" class="indexterm"/>make selections. When we use the dialog, we will save the <a id="id536" class="indexterm"/>results in the preferences. This means that we can run it as a batch process from this moment onward. To let the user set the key parameters for the detection, we can create the following preference dialog:</p><div class="mediaobject"><img src="graphics/B04909_09_07.jpg" alt="Settings and options dialog"/></div><p>This is done using the <code class="literal">GenericDialog</code> class available in the <code class="literal">ij.gui</code> package. You start with creating an instance of the <code class="literal">GenericDialog</code> class, and then adding your fields of choice to it in the order that you wish for them to be displayed. For this example, we want to set the detection mode, the threshold method, the minimum particle size, and the maximum particle size. If you want, you could add more parameters to the preferences to allow more flexibility. The following code will create a dialog, add the fields, and display it:</p><div class="informalexample"><pre class="programlisting">//construct and show the options dialog
GenericDialog gd = new GenericDialog("Options Object Tracker");
gd.addChoice("Detection mode", (new String[]{"multi", "single"}), DETECT_METHOD);
gd.addChoice("Threshold method", AutoThresholder.getMethods(), THRESH_METHOD);
gd.addNumericField("Min. particle size", DMIN, 0);
gd.addNumericField("Max. particle size", DMAX, 0);
gd.showDialog();
            
//store the values
Prefs.set("object_tracker.detectMethod", gd.getNextChoice());
Prefs.set("object_tracker.threshMethod", gd.getNextChoice());
Prefs.set("object_tracker.minParticleSize", gd.getNextNumber());
Prefs.set("object_tracker.maxParticleSize", gd.getNextNumber());</pre></div><p>At the end, we store the values that the user selected in the preferences using the keys. To obtain the values, we use the <code class="literal">getNext&lt;&gt;</code> methods. These are called in the order that the fields were added to the <a id="id537" class="indexterm"/>dialog, so the first call to <code class="literal">getNextChoice</code> will get <a id="id538" class="indexterm"/>the value from the first choice list (in this case the detection mode selection). The call to <code class="literal">getNextNumber</code> will retrieve the number from the first numeric field (in this case the minimum particle size). The order of the fields in a <code class="literal">GenericDialog</code> implementation becomes fixed when the fields are added, so this needs to be accounted for when retrieving the values. Refer to listing 9.2 for the complete code of the plugin.</p></div></div>
<div class="section" title="Adding external libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Adding external libraries</h1></div></div></div><p>When you have <a id="id539" class="indexterm"/>created a plugin for processing, you may want to add some functionality that is not available in the ImageJ core API. In this case, you may want to use an external library that has the functionality that you require. If you use Maven to set up your project, adding a library is as easy as listing it in your <code class="literal">&lt;dependencies&gt;</code> section of your POM file. As an example, I will show you how to add the Apache POI library to add an option to export the results of our work to an MS Excel file. The advantage of this library is that it can create an <code class="literal">.xls(x)</code> file on all platforms, regardless of whether MS Excel is installed. I will briefly show you how to create an Excel file, write some data to it, and then save the result as an <code class="literal">.xls</code> file.</p><div class="section" title="Adding the dependency for Apache POI"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec65"/>Adding the dependency for Apache POI</h2></div></div></div><p>To add the <a id="id540" class="indexterm"/>dependency of the POI project in your POM file, you will need to add the <code class="literal">org.apache.poi</code> project to your <code class="literal">&lt;dependencies&gt;</code> section. The IDE can help you with this process using its autocomplete feature. Let's suppose you create a basic dependency template similar to the one shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;&lt;/groupId&gt;
  &lt;artifactId&gt;&lt;/artifactId&gt;
  &lt;version&gt;&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p>In this case, you can then place your cursor within the <code class="literal">&lt;groupId&gt;</code> tag and press <span class="emphasis"><em>Ctrl</em></span> + Spacebar. You will then get a list of possible IDs that you can select. When you start typing the first part (<code class="literal">org.</code>), you will notice that the list becomes more limited as you continue to type. When you get to <code class="literal">org.apache.po</code>, the list only contains two options, including the <a id="id541" class="indexterm"/>POI package. If you repeat the process for the remaining tags, you may end up with the following dependency section:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
  &lt;artifactId&gt;poi&lt;/artifactId&gt;
  &lt;version&gt;3.13&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p>At this point you can start to use the library and its interfaces, classes, and methods to create an Excel file (or Word documents and PowerPoint presentations). Please note that the packages for Excel files are designated with the <span class="strong"><strong>HSSF</strong></span> moniker (<span class="strong"><strong>Horrible SpreadSheet </strong></span><a id="id542" class="indexterm"/>
<span class="strong"><strong>Format</strong></span>). After saving the POM file, you will get a new JAR file in your projects dependencies folder. In this, case it is the <code class="literal">poi-3.13.jar</code> file, and it contains the packages for the POI project. Make sure you build your project before proceeding further by navigating to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Build Project</strong></span> from the menu. We will now look at how to implement this library in the next section.</p></div><div class="section" title="Creating an Excel file"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec66"/>Creating an Excel file</h2></div></div></div><p>To create an <a id="id543" class="indexterm"/>Excel file, we need to create a new instance of an Excel workbook using Apache POI. This is relatively simple using the <code class="literal">usermodel</code> package in <code class="literal">org.apache.poi.ss</code>. We create an instance of the Workbook interface and add a sheet with a specific name that will contain the data in a method we call <code class="literal">saveResultsToExcel</code>. Every time we add a new class, we can add our import statements automatically by pressing <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span>. Just make sure that you select the correct ones. If you want to add the <code class="literal">Cell</code> class, you have multiple options, but we require the package for <code class="literal">org.apache.poi.ss.usermodel.Cell</code> in this example:</p><div class="informalexample"><pre class="programlisting">public void saveResultsToExcel(String xlFile, ResultsTable rt) {
  FileOutputStream xlOut;
  try { xlOut = new FileOutputStream(xlFile); }
  catch (FileNotFoundException ex) {
    Logger.getLogger(Object_Tracker.class.getName()).log(Level.SEVERE, null, ex);
  }
  
  Workbook xlBook = new HSSFWorkbook();
  Sheet xlSheet = xlBook.createSheet("Results Object Tracker");
  Row r = null;
  Cell c = null;
  CellStyle cs = xlBook.createCellStyle();
  Font f = xlBook.createFont();
  Font fb = xlBook.createFont();
  DataFormat df = xlBook.createDataFormat();
  f.setFontHeightInPoints((short) 12);
  fb.setFontHeightInPoints((short) 12);
  fb.setBoldweight(Font.BOLDWEIGHT_BOLD);
  cs.setFont(f);
  cs.setDataFormat(df.getFormat("#,##0.000"));
  cb.setDataFormat(HSSFDataFormat.getBuiltinFormat("text"));
  cb.setFont(fb);
  
  int numRows = rt.size();
  String[] colHeaders = rt.getHeadings();
  int rownum = 0;
  //create a header
  r = xlSheet.createRow(rownum);
  for (int cellnum=0; cellnum&lt;colHeaders.length; cellnum++) {
    c = r.createCell(cellnum);
    c.setCellStyle(cb);
    c.setCellValue(colHeaders[cellnum]);
  }
  rownum++;
  
  for (int row=0; row&lt;numRows; row++) {
    r = xlSheet.createRow(rownum+row);
    int numCols = rt.getLastColumn() + 1;
    for (int cellnum=0; cellnum&lt;numCols; cellnum++) {
      c = r.createCell(cellnum);
      c.setCellValue(rt.getValueAsDouble(cellnum, row));
    }
  }
  try { xlBook.write(xlOut); xlOut.close();}
  catch (IOException ex) {
    Logger.getLogger(Object_Tracker.class.getName()).log(Level.SEVERE, null, ex);
  }
}</pre></div><p>In this example, I assumed that the data is in the form of an ImageJ <code class="literal">ResultsTable</code> object. In the loop, we go over the rows and then add cells to each row, one column at a time. We use the headers of the results table to make a header in the Excel file as well. We use a separate <code class="literal">Font</code> object (<code class="literal">fb</code> in this example) to make the style different from the data by making it bold. At the end, we save the results to a file using the generic <code class="literal">FileOutputStream</code> class.</p><p>To get the results table that is generated when you press the <span class="strong"><strong>Measure</strong></span> button in the ROI manager, you can use the following code:</p><div class="informalexample"><pre class="programlisting">ResultsTable rt = ResultsTable.getResultsTable();</pre></div><p>After asking the user for a file name, you can call the <code class="literal">saveResultsToExcel</code> method to generate an Excel file. The example code above works only to generate <code class="literal">.xls</code> files. To generate <code class="literal">.xlsx</code> files, you need to implement a workbook of the <code class="literal">XSSFWorkbook</code> class. The main difference <a id="id544" class="indexterm"/>between these two Excel formats is that the size of the data that can be contained on a sheet; <code class="literal">.xls</code> files have a limitation of 255 columns per sheet. If you expect to generate tables with more columns, you need to make sure to use the <code class="literal">XSSFWorkbook</code> class.</p></div></div>
<div class="section" title="Sharing your plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Sharing your plugin</h1></div></div></div><p>When you have <a id="id545" class="indexterm"/>finished implementing all the routines and completed (extensive) testing, you are ready to distribute your plugin to the world. Currently, there are several options available to distribute your plugin, ranging from sending it using e-mail to an automated update mechanism in ImageJ. Here, I will discuss the latter option, which has some great benefits that makes it very user-friendly and efficient. Fiji, and ImageJ2 have a system that allows you to set a website as a source for your plugin. This website will be checked to see whether there is a newer version available, and if so, it will be automatically updated. The only thing your users have to do is add that site to their list of update sites to install and update your plugin(s). The following sections will describe how to setup this site, and how users can add the site to ImageJ (ImageJ2 and Fiji, specifically).</p><div class="section" title="Creating a site"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec67"/>Creating a site</h2></div></div></div><p>To create a site, you <a id="id546" class="indexterm"/>have different options available: you can host your own update site, or you can use the ImageJ Wiki site. I will now focus on the latter option as it is easy, free, and accessible to everyone. Note that your users need to have ImageJ2 or Fiji to be able to use this mechanism. For this section, I will assume that you are using Fiji, but it works in a similar manner in ImageJ2. To create the site, you can go to <span class="strong"><strong>Help</strong></span> | <span class="strong"><strong>Update…</strong></span> in the menu. In the window that opens, press the <span class="strong"><strong>Manage update sites</strong></span> button on the bottom right to get the sites currently available.</p><div class="mediaobject"><img src="graphics/B04909_09_06.jpg" alt="Creating a site"/></div><p>You can press the <span class="strong"><strong>Add my site</strong></span> button in this window and either create a new account or use an existing account. If you already have an account, you only have to enter your user name, and if your password hasn't yet been stored, also enter your password. If you want to create a new account, you can enter a user name. If it doesn't yet exist, you can enter your e-mail address and press <a id="id547" class="indexterm"/>
<span class="strong"><strong>OK</strong></span>. You will receive an e-mail message on the account that you provided with a temporary password. You must then go to the Wiki login <a id="id548" class="indexterm"/>page at <a class="ulink" href="http://imagej.net/Special:UserLogin">http://imagej.net/Special:UserLogin</a> to change your password. Once you have modified your password, you can enter it in the <span class="strong"><strong>Add personal site</strong></span> window of ImageJ. You are now ready to add your plugins to the website.</p></div><div class="section" title="Uploading your plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Uploading your plugin</h2></div></div></div><p>To upload your <a id="id549" class="indexterm"/>plugin, you cannot just upload your file directly to the server. In order for it to be recognized as a proper update site and plugins, some additional files are required. Luckily, the ImageJ updater can also take care of this process for you. Open the updater by navigating to <span class="strong"><strong>Help</strong></span> | <span class="strong"><strong>Update…</strong></span> from the menu and click on the <span class="strong"><strong>Advanced mode</strong></span> button. The first time you upload a plugin, you need to select the <span class="strong"><strong>View local-only files</strong></span> from the <span class="strong"><strong>View options</strong></span> drop-down list. You can now select your plugin on the left-hand side, and edit the details in the <span class="strong"><strong>Details</strong></span> view on the right-hand side. By right-clicking on your plugin, you can open a context menu and select <span class="strong"><strong>Upload to My Site</strong></span>. The <span class="strong"><strong>Status/Action</strong></span> column should now display <span class="strong"><strong>Upload it</strong></span>, and after pressing the <span class="strong"><strong>Apply </strong></span><a id="id550" class="indexterm"/>
<span class="strong"><strong>changes</strong></span> button and providing your credentials, the upload will start.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we developed a legacy plugin from scratch using the Maven system and the NetBeans IDE. We applied some of the image processing techniques that we learned in the previous chapters in our plugin. We saw how to add a basic user interface to our plugin, allowing the user to change some of the parameters that influence the way the plugin functions. We also saw how to store our settings in the preferences so that they can be recalled the next time we use the plugin. We added an external library to provide additional functionality that was not present in ImageJ. Finally, we looked at an automated way of publishing our plugin and sharing it with the world.</p><p>In the next chapter, we will look at the resources that are available to further your knowledge and skills in image processing and project development.</p></div></body></html>