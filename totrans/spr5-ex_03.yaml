- en: Persistence with Spring Data and Reactive Fashion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created our **Content Management System** (**CMS**)
    application. We also introduced **REST** (**Representational State Transfer**)
    support in Spring, which enabled us to develop a simple web application. Also,
    we learned how dependency injection works in the Spring Framework, which is probably
    the most famous feature of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add more features to our application. Systems in the
    real world need to persist their data on a real database; this is an essential
    characteristic for a production-ready application. Also, based on our model, we
    need to choose the correct data structure to achieve performance and avoid the
    impedance mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, we will use the traditional SQL database
    as a store for our application. We will deep dive on the Spring Data **JPA** (**Java
    Persistence API**) to achieve the persistence for our CMS application. We will
    understand how to enable transactions with this amazing Spring module.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will change to a more modern type of database called **NoSQL**
    **technologies**. In this field, we will use the famous database document model
    called **MongoDB** and then we will create the final solution for our CMS application.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB offers a fantastic solution for our application because it has support
    for a document storage model and enables us to store our objects in the form of
    JSON, which makes our data more readable. Also, MongoDB is schema-less, which
    is a fantastic feature because one collection can store different documents. It
    means records can have different fields, content, and sizes. The other important
    characteristic from MongoDB is the query model. It offers a document-based query
    that is easy to understand, and, based on JSON notations, our queries will be
    more readable than any other database can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add the most important feature present in Spring 5.0: support
    for Reactive Streams. Our application will be transformed into a modern web application
    which has some important requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an overview of what you will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Spring Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating repositories with Spring Data Reactive MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Reactive Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the Project Reactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about Docker concepts in [Chapter 1](45a65572-53a1-42bd-aa7a-d1437e65a58f.xhtml),
    *Journey to the Spring World*. Now, it is time to test our knowledge and put it
    into practice. In the first part of this chapter, we will start MongoDB and Postgres instances
    to serve as a database for our application. We will configure connection settings
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of this chapter, we will introduce the Maven plugin which provides
    an easy way to create Docker images via `pom.xml` with a couple of configurations
    on file. Finally, we will run our application in a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing  MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create our MongoDB container. We will use the official image provided
    by the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to pull the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will see the Docker Engine downloading the image contents.
  prefs: []
  type: TYPE_NORMAL
- en: To create an isolation from our containers, we will create a separated network
    for our application and database. The network should use the bridge driver to
    allow the container communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `docker network`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The command output should be an ID of a created network. Your ID will probably
    be different compared to mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ef52923-37c6-446d-9e6a-371ac525bce9.png)'
  prefs: []
  type: TYPE_IMG
- en: To check if the network was created successfully, the `docker network ls` command can
    help us.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our MongoDB. The network should be `cms-application`, but we will
    map the database port to a host port. For debugging purposes, we will connect
    a client to a running database, but please don't do this in a non-development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing a port over host is not a best practice. Hence, we use a Docker container,
    which is one of the main advantages is process isolation. In this case, we will
    have no control over the network. Otherwise, we may cause some port conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Also, we can stop the Docker MongoDB container using `docker stop mongodb` and start
    our container again by using the following command: `docker start mongodb`.
  prefs: []
  type: TYPE_NORMAL
- en: The output will be a hash which represents the ID of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter instructions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: This instructs Docker to run the container in a background mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--name`: The container name; it will be a kind of hostname in our network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--net`: The network where the container will be attached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`: The host port and container port, which will be mapped to a container
    on a host interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have a pretty standard MongoDB instance running on our machines, and
    we can start to add a persistence in our CMS application. We will do that soon.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like MongoDB, we will prepare a PostgreSQL instance for our CMS application.
    We will change our persistence layer to demonstrate how Spring Data abstracts
    it for developers. Then, we need to prepare a Docker Postgres instance for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the version 9.6.6 of Postgres and use the `alpine` tag because
    it is smaller than other Postgres images. Let''s pull our image. The command should
    be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, wait until the download ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we created our Docker network called `cms-application`.
    Now, we will start our Postgres instance on that network as we did for MongoDB.
    The command to start the Postgres should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of parameters is the same as we passed for MongoDB. We want to run
    it in background mode and attach it to our custom network. As we can see, there
    is one more new parameter in the `docker run` command. Let''s understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`: This enables us to pass environment variables for a container. In this
    case, we want to change the password value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good job. We have done our infrastructure requirements. Let's understand the
    persistence details right now.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data project is an umbrella project that offers a familiar way to
    create our data access layer on a wide range of database technologies. It means
    there are high-level abstractions to interact with different kinds of data structures,
    such as the document model, column family, key-value, and graphs. Also, the JPA
    specification is fully supported by the Spring Data JPA project.
  prefs: []
  type: TYPE_NORMAL
- en: These modules offer powerful object-mapping abstractions for our domain model.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is support for different types of data structures and databases. There
    is a set of sub-modules to keep the framework modularity. Also, there are two
    categories of these sub-modules: the first one is a subset of projects supported
    by the Spring Framework Team and the second one is a subset of sub-modules provided
    by the community.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Projects supported by the Spring Team include:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Commons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data for Apache Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Projects supported by the community include:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Aerospike
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data ElasticSearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Neo4J
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base of the repositories interfaces chain is the `Repository` interface.
    It is a marker interface, and the general purpose is to store the type information.
    The type will be used for other interfaces that extend it.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `CrudRepository` interface. It is the most important, and the
    name is self-explanatory; it provides a couple of methods to perform CRUD operations,
    and it provides some utility methods, such as `count()`, `exists()`, and `deleteAll()`.
    Those are the most important base interfaces for the repository implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data JPA provides an easy way to implement a data access layer using
    the JPA specification from Java EE. Usually, these implementations had a lot of
    boilerplate and repetitive code and it was hard to maintain the changes in the
    database code. The Spring Data JPA is trying to resolve these issues and provides
    a comprehensible way to do that without boilerplate and repetitive code.
  prefs: []
  type: TYPE_NORMAL
- en: The JPA specification provides an abstraction layer to interact with different
    database vendors that have been implemented. Spring adds one more layer to the
    abstraction in a high-level mode. It means the Spring Data JPA will create a repositories
    implementation and encapsulate the whole JPA implementation details. We can build
    our persistence layer with a little knowledge of the JPA spec.
  prefs: []
  type: TYPE_NORMAL
- en: The *JPA Specification* was created by the **JCP** (**Java Community Process**)
    to help developers to persist, access, and manage data between Java classes and
    relational databases. There are some vendors that implement this specification.
    The most famous implementation is Hibernate ([http://hibernate.org/orm/](http://hibernate.org/orm/)),
    and by default, Spring Data JPA uses Hibernate as the JPA implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Say goodbye to the **DAO** (**Data Access Object**) pattern and implementations.
    The Spring Data JPA aims to solve this problem with a well-tested framework and
    with some production-ready features.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have an idea of what the Spring Data JPA is. Let's put it into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring pom.xml for Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to put the correct dependencies to work with Spring Data JPA. There
    are a couple of dependencies to configure in our `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the Spring Data JPA Starter, which provides a lot of auto-configuration
    classes which permits us to bootstrap the application quickly. The last one is
    the PostgreSQL JDBC driver, and it is necessary because it contains the JDBC implementation
    classes to connect with the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new dependencies are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Simple and pretty easy.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Postgres connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect our application with our recently created database, we need to configure
    a couple of lines in the `application.yaml` file. Once again, thanks to Spring
    Data Starter, our connection will be configured automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We can produce the connection objects using the `@Bean` annotations as well,
    but there are many objects to configure. We will go forward with the configuration
    file. It is more simple and straightforward to understand as well.
  prefs: []
  type: TYPE_NORMAL
- en: To configure the database connections, we need to provide the Spring Framework
    a couple of attributes, such as the database URL, database username, password,
    and also a driver class name to instruct the JPA framework about the full path
    of the JDBC class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `application.yaml` file should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `datasource` section, we have configured the database credentials connections
    and database host as well.
  prefs: []
  type: TYPE_NORMAL
- en: The JPA section in `application.yaml` can be used to configure the JPA framework.
    In this part, we configured to log SQL instructions in the console. This is helpful
    to debug and perform troubleshooting. Also, we have configured the JPA framework
    to create our tables in a database when the application gets the startup process.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, the JPA infrastructure is configured. Well done! Now, we can map our
    models in the JPA style. Let's do that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have configured the database connections successfully. Now, we are ready
    to map our models using the JPA annotations. Let's start with our `Category` model.
    It is a pretty simple class, which is good because we are interested in Spring
    Data JPA stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first version of the `Category` model should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We need to change some model classes to adapt to the JPA specification. We can
    find the model classes on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models).
  prefs: []
  type: TYPE_NORMAL
- en: There is some new stuff here. The `@Entity` annotation instructs the JPA framework
    that the annotated class is an entity, in our case, the `Category` class, and
    then the framework will correlate it with a database table. The `@Table` annotation
    is used to name the table in the database. These annotations are inserted on the
    class level, which means on top of the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Id` annotation instructs the JPA as to which annotated field is the primary
    key of the database table. It is not a good practice to generate IDs sequentially
    for entities, especially if you are creating the APIs. It helps hackers to understand
    the logic about the IDs and makes the attacks easier. So, we will generate UUIDs
    (Universally Unique IDentifiers) instead of simple sequentially IDs. The `@GenericGenerator`
    annotation instructs Hibernate, which is a JPA specification implementation vendor,
    to generate random UUIDs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the JPA repositories in the CMS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the whole infrastructure and JPA mappings are done, we can add our repositories
    to our projects. In the Spring Data project, there are some abstractions, such
    as `Repository`, `CrudRepository`, and `JpaRepository`. We will use the `JpaRepository`
    because it supports the paging and sorting features.
  prefs: []
  type: TYPE_NORMAL
- en: Our repository will be pretty simple. There are a couple of standard methods,
    such as `save()`, `update()`, and `delete()`, and we will take a look at some
    DSL query methods which allow developers to create custom queries based on attribute
    names. We created an `AbstractRepository` to help us to store the objects in memory.
    It is not necessary anymore. We can remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first JPA repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `JpaRepository` interface is typed with the desired entity
    and the type of ID of the entity as well. There is no secret to this part. This
    amazing thing happens to support the custom queries based on attribute names.
    In the `Category` model, there is an attribute called `name`**.** We can create
    custom methods in our `CategoryRepository` using the `Category` model attributes
    using the `By` instruction. As we can see, above `findByName(String name)`, Spring
    Data Framework will create the correct query to look up categories by name. It
    is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many keywords supported by the custom query methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical Keyword** | **Logical Expressions** |'
  prefs: []
  type: TYPE_TB
- en: '| `AND` | `And` |'
  prefs: []
  type: TYPE_TB
- en: '| `OR` | `Or` |'
  prefs: []
  type: TYPE_TB
- en: '| `AFTER` | `After`, `IsAfter` |'
  prefs: []
  type: TYPE_TB
- en: '| `BEFORE` | `Before`, `IsBefore` |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTAINING` | `Containing`, `IsContaining`, `Contains` |'
  prefs: []
  type: TYPE_TB
- en: '| `BETWEEN` | `Between`, `IsBetween` |'
  prefs: []
  type: TYPE_TB
- en: '| `ENDING_WITH` | `EndingWith`, `IsEndingWith`, `EndsWith` |'
  prefs: []
  type: TYPE_TB
- en: '| `EXISTS` | `Exists` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE` | `False`, `IsFalse` |'
  prefs: []
  type: TYPE_TB
- en: '| `GREATER_THAN` | `GreaterThan`, `IsGreaterThan` |'
  prefs: []
  type: TYPE_TB
- en: '| `GREATHER_THAN_EQUALS` | `GreaterThanEqual`, `IsGreaterThanEqual` |'
  prefs: []
  type: TYPE_TB
- en: '| `IN` | `In`, `IsIn` |'
  prefs: []
  type: TYPE_TB
- en: '| `IS` | `Is`, `Equals`, (or no keyword) |'
  prefs: []
  type: TYPE_TB
- en: '| `IS_EMPTY` | `IsEmpty`, `Empty` |'
  prefs: []
  type: TYPE_TB
- en: '| `IS_NOT_EMPTY` | `IsNotEmpty`, `NotEmpty` |'
  prefs: []
  type: TYPE_TB
- en: '| `IS_NOT_NULL` | `NotNull`, `IsNotNull` |'
  prefs: []
  type: TYPE_TB
- en: '| `IS_NULL` | `Null`, `IsNull` |'
  prefs: []
  type: TYPE_TB
- en: '| `LESS_THAN` | `LessThan`, `IsLessThan` |'
  prefs: []
  type: TYPE_TB
- en: '| `LESS_THAN_EQUAL` | `LessThanEqual`, `IsLessThanEqual` |'
  prefs: []
  type: TYPE_TB
- en: '| `LIKE` | `Like`, `IsLike` |'
  prefs: []
  type: TYPE_TB
- en: '| `NEAR` | `Near`, `IsNear` |'
  prefs: []
  type: TYPE_TB
- en: '| `NOT` | `Not`, `IsNot` |'
  prefs: []
  type: TYPE_TB
- en: '| `NOT_IN` | `NotIn`, `IsNotIn` |'
  prefs: []
  type: TYPE_TB
- en: '| `NOT_LIKE` | `NotLike`, `IsNotLike` |'
  prefs: []
  type: TYPE_TB
- en: '| `REGEX` | `Regex`, `MatchesRegex`, `Matches` |'
  prefs: []
  type: TYPE_TB
- en: '| `STARTING_WITH` | `StartingWith`, `IsStartingWith`, `StartsWith` |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `True`, `IsTrue` |'
  prefs: []
  type: TYPE_TB
- en: '| `WITHIN` | `Within`, `IsWithin` |'
  prefs: []
  type: TYPE_TB
- en: There are many ways to create a query based on attributes names. We can combine
    the keywords using keywords as well, such as `findByNameAndId`, for instance.
    The Spring Data JPA provides a consistent way to create queries.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we use the JPA specification, most of the applications need to have support
    for transactions as well. Spring has excellent support for transactions even in
    other modules. This support is integrated with Spring Data JPA, and we can take
    advantage of it. Configuring transactions in Spring is a piece of cake; we need
    to insert the `@Transactional` annotation whenever needed. There are some different
    use cases to use it. We will use the `@Transactional` in our services layer and
    then we will put the annotation in our service classes. Let''s see our `CategoryService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are many `@Transactional` annotations in the `CategoryService` class.
    The first annotation at class level instructs the framework to configure the `readOnly`
    for all methods present in those classes, except the methods configured with `@Transactional`.
    In this case, the class-level annotation will be overridden with `readOnly=false`.
    This is the default configuration when the value is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring pgAdmin3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect on our PostgreSQL instance, we will use pgAdmin 3, which is the free
    tool provided by the Postgres team.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install pgAdmin 3, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will install pgAdmin 3 on our machine.
  prefs: []
  type: TYPE_NORMAL
- en: After installation, open pgAdmin 3 and then click on Add a connection to a server.
    The button looks like this***:***
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dd5adeb-ebbf-47b8-a707-d01201e5e74f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, fill in the information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe9cc957-3670-4483-8475-6fc0265a1ef2.png)'
  prefs: []
  type: TYPE_IMG
- en: The password should be: `cms@springfive.`
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, our pgAdmin 3 tool is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the data on the database structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole application structure is ready. Now, we can check the database to
    get our persisted data. There are many open source Postgres clients. We will use
    pgAdmin 3, as previously configured.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you open the application, you will be asked about the credentials
    and host. We must put the same information as we configured on the `application.yaml`
    file. Then, we are able to make instructions in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Before checking the database, we can use Swagger to create some categories in
    our CMS system. We can use the instructions provided in [Chapter 2](8b857b24-87be-4066-acb3-daa9a596b61e.xhtml),
    *Starting in the Spring World – The CMS Application,* to create some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can execute the following SQL instruction in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result should be the categories created on Swagger calls. In my case,
    I have created two categories, `sports`, and `movies`. The result will be like
    the ones shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77ce367-0276-46c9-844e-c609c52369f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome work, guys. The application is fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create our final solution for the repositories. We have learned
    the basics of the Spring Data project and in the next section, we will change
    the persistence layer to a modern database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the final data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have played with the Spring Data JPA project, and we have seen how easy it
    can be. We learned how to configure the database connections to persist the real
    data on the Postgres database. Now, we will create the final solution for the
    data access layer for our application. The final solution will use MongoDB as
    a database and will use the Spring Data MongoDB project, which provides support
    for MongoDB repositories.
  prefs: []
  type: TYPE_NORMAL
- en: We will see some similarities with the Spring Data JPA projects. It is amazing because
    we can prove the power of Spring Data abstractions in practice. With a couple
    of changes, we can move to another database model.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the new project and put it into practice in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data MongoDB provides integration with our domain objects and the
    MongoDB document. With a couple of annotations, our entity class is ready to be
    persisted in the database. The mapping is based on a **POJO** (**Plain Old Java
    Object**) pattern, which is known by all Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: There are two levels of abstraction supplied by the module. The first one is
    a high-level abstraction. It increases the developer productivity. This level
    provides a couple of annotations to instruct the framework to convert the domain
    objects in MongoDB documents and vice versa. The developer does not need to write
    any code about the persistence; it will be managed by the Spring Data MongoDB
    framework. There are more exciting things at this level, such as the rich mapping
    configurations provided by the Spring Conversion Service. The Spring Data projects
    provide a rich DSL to enable developers to create queries based on the attribute
    names.
  prefs: []
  type: TYPE_NORMAL
- en: The second level of abstraction is the low-level abstraction. At this level,
    behaviors are not automatically managed by the framework. The developers need
    to understand a little bit more about the Spring and MongoDB document model. The
    framework provides a couple of interfaces to enable developers to take control
    of the read and write instructions. This can be useful for scenarios where the
    high-level abstraction does not fit well. In this case, the control should be
    more granular in the entities mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Again, Spring provides the power of choice for developers. The high-level abstraction
    improves the developer performance and the low-level permits developers to take
    more control.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add mapping annotation to our model. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the PostgreSQL and Spring Data JPA dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will convert our project to use the brand new Spring Data Reactive MongoDB
    repositories. After that, we will not use the Spring Data JPA and PostgreSQL drivers
    anymore. Let''s remove these dependencies from our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we can add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The final version of `pom.xml` can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml).
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add mapping annotations on our domain model. The Spring Data MongoDB
    will use these annotations to persist our objects in the MongoDB collections.
    We will start with the `Category` entity, which should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We added two new annotations in the `Category` class. The `@Document` from Spring
    Data MongoDB enables us to configure the collection name. Collections in MongoDB
    are similar to tables in SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Id` annotation is from the Spring Data Commons project. It is interesting
    because, as we can see, it is not specific for MongoDB mappings. The field annotation
    with this will be converted in the `_id` field on MongoDB collection.
  prefs: []
  type: TYPE_NORMAL
- en: With these few annotations, the `Category` class is configured to be persisted
    on MongoDB. In the following section, we will create our repository classes.
  prefs: []
  type: TYPE_NORMAL
- en: We need to do the same task for our other entities. The `User` and `News` need
    to be configured in the same way as we did for the `Category` class. The full
    source code can be found on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we create our repositories, we will configure the MongoDB connection.
    The repository layer abstracts the driver implementation, but is necessary to
    configure the driver correctly.
  prefs: []
  type: TYPE_NORMAL
- en: On the resources directory, we will change the `application.yaml` file, previously
    configured for the Spring Data JPA. The Spring Framework supports the configuration
    through the YAML file. This kind of file is more readable for humans and has a
    kind of hierarchy. These features are the reason to choose this extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `application.yaml` file should be like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `application.yaml` file for MongoDB can be found on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml)).
  prefs: []
  type: TYPE_NORMAL
- en: The file is quite simple for now. There is a `database` tag for configuring
    the database name. The `host` and `port` tags are about the address that the MongoDB
    instance is running.
  prefs: []
  type: TYPE_NORMAL
- en: We also can configure the connections programmatically with a couple of objects,
    but it requires us to code a lot of boilerplate code. Spring Boot offers it out
    of the box for us. Let's enjoy it.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent, the connection was configured successfully. The infrastructure requirements
    are solved. Let's go on to implement our repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Framework supports profiles in `application.properties`or`application.yaml`.
    This means that if the application was configured in a properties file style,
    we could use `application-<profile>.properties`. Then, these properties will be
    applied to the required profile. In YAML style, we can use only one file with
    multiples profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the repository layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the entities have been mapped, and the connections are done, it's time
    to create our repositories. The Spring Data Framework provides some interfaces
    that can be used in different use cases. We will use the specialization for the
    MongoDB database, which is `MongoRepository`. It extends the `PagingAndSortingRepository`
    and `QueryByExampleExecutor`. The first is about pagination and sorting features,
    and the other is about queries by example.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the database query result set can be very large. This can cause
    some application performance issues because we will fetch a lot of database records.
    We can limit the number of records fetched from the database and configure limits
    for that. This technique is called **Pagination**. We can find the full documentation
    at *Spring Data Commons Documentation* ([https://docs.spring.io/spring-data/commons/docs/current/reference/html/](https://docs.spring.io/spring-data/commons/docs/current/reference/html/)).
  prefs: []
  type: TYPE_NORMAL
- en: This interface offers a lot of built-in methods for convenience. There are a
    couple of methods to insert one or more instances, methods for listing all instances
    of requested entities, methods to remove one or more instances, and many more
    features, such as ordering and paging.
  prefs: []
  type: TYPE_NORMAL
- en: It enables developers to create repositories without code or even without a
    deep knowledge of MongoDB. However, some knowledge of MongoDB is necessary to
    troubleshoot various errors.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating the `CategoryRepository`. Change the type of `CategoryRepository`
    to an interface instead of a class. The code in this interface is not necessary.
    The Spring container will inject the correct implementation when the application
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first concrete repository, which means the repository will
    persist the data on the MongoDB we previously configured. The `CategoryRepository`
    needs to be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The type is an `interface`.Repositories do not have any stereotypes anymore. The
    Spring container can identify the implementation because it extends the `MongoRepository`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `MongoRepository` interface should be parameterized. The first argument
    is the type of model that it represents. In our case, it represents a repository
    for the `Category` class. The second parameter is about the type of ID of the
    model. We will use the string type for that.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to do the same for the other entities, `User`, and `News`. The
    code is quite similar to the preceding code. You can find the full source code
    on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will check the database to assert that the rows are
    persisted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can test the persistence and all layers of the application. We will
    provide the API documentation for that. Let's open the Swagger documentation and
    create some records in our CMS application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating sample categories on Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19e4c9c0-2dd1-4672-893c-0893ec51560e.png)'
  prefs: []
  type: TYPE_IMG
- en: Fill in the category JSON, as shown in the preceding screenshot, and then click
    on Try it out!. It will invoke the Category API and persist the category on the
    database. Now, we can check it.
  prefs: []
  type: TYPE_NORMAL
- en: To connect to the MongoDB instance and check the collection, we will use the
    `mongo-express` tool. It is a web-based tool written in NodeJS to interact with
    our database instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool can be installed, but we will run the tool on a Docker container. The
    Docker tool will help us in this part. Let''s start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It instructs Docker to spin up a container with the `mongo-express` tool and
    connect to the desired instance. The `--link` argument instructs Docker to create
    a kind of *hostname* for our MongoDB instance. Remember the name of our instance
    is `mongodb`; we did it on the run command previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good job. Go to `http://localhost:8081` and we will see this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/612df25d-1ee2-4b1e-9242-782e95554648.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a couple of databases. We are interested in the CMS database. Click
    on the View button next to cms. Then, the tool will present the collections of
    the selected database; in our case, the CMS database. The view should be like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06842b34-47ef-433d-a742-d7961996a368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The category is presented as a collection. We can View, Export, and export
    as JSON, but for now, we are interested in checking if our CMS application persisted
    the data properly. So, click on the View button. We will use the MongoDB collection
    data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca8b9aca-8cd4-4077-8617-f34e4e83df0f.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the data was stored in MongoDB as expected. There are two categories
    in the database—sports and travel. There is a `_class` field that helps Spring
    Data to convert domain classes.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome job, the CMS application is up and running, and also persisting the
    data in MongoDB. Now, our application is almost production ready, and the data
    is persisted outside in the amazing document datastore.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will create our Docker image, and then we will
    run the CMS application with Docker commands. It will be interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Docker image for CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are doing an awesome job. We created an application with the Spring Boot
    Framework. The application has been using the Spring REST, Spring Data, and Spring
    DI.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will go a step forward and create our Docker image. It will be useful
    to help us to deliver our application for production. There are some advantages,
    and we can run the application on-premise or on any cloud providers because Docker
    abstracts the operating system layer. We do not need Java to be installed on the
    application host, and it also allows us to use different Java versions on the
    hosts. There are so many advantages involved in adopting Docker for delivery.
  prefs: []
  type: TYPE_NORMAL
- en: We are using Maven as a build tool. Maven has an excellent plugin to helps us
    to create Docker images. In the following section, we will learn how Maven can
    help us.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the docker-maven-plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an excellent Maven plugin provided by fabric8 ([https://github.com/fabric8io/docker-maven-plugin](https://github.com/fabric8io/docker-maven-plugin)).
    It is licensed under the Apache-2.0 license, which means we can use it without
    any worries.
  prefs: []
  type: TYPE_NORMAL
- en: We will configure our project to use it, and after image creation, we will push
    this image on Docker Hub. It is a public Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the plugin
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the Docker image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Docker Spring profile
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it is show time. Let's go.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the plugin on pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s configure the Maven plugin. It is necessary to add a plugin to the plugin
    section on our `pom.xml` and add some configurations. The plugin should be configured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of new configurations here. Let's start with the `<name>`
    tag—it configures the repository and Docker image name to push to Docker Hub.
    For this book, we will use `springfivebyexample` as a Docker ID. We can see there
    is a *slash* as a separator for the repository and image name. The image name
    for us will be the final project name. Then, we need to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker ID is free to use, which can be used to access some Docker services,
    such as Docker Store, Docker Cloud, and Docker Hub. We can find more information
    at Docker Page ([https://docs.docker.com/docker-id/](https://docs.docker.com/docker-id/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration should be the same as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Another important tag is `<entrypoint>`. This is an exec system call instruction
    when we use the `docker run` command. In our case, we expected the application
    to run when the container bootstraps. We will execute `java -jar` passing the
    container as an active profile for Spring.
  prefs: []
  type: TYPE_NORMAL
- en: We need to pass the full path of the Java artifact. This path will be configured
    on the `<assembly>` tag with the `<basedir>` parameter. It can be any folder name.
    Also, there is a configuration to the Java artifact path. Usually, this is the
    target folder which is the result of the compilation. It can be configured in
    the `<source>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `<port>` configuration. The port of the application will
    be exposed using this tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a Docker image by using the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It should be executed in the root folder of the project. The goal of the `docker:build`
    command is to build a Docker image for our project. After the build ends, we can
    check if the Docker image has been created successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `springfivebyexample/cms` image should be present, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb420ba4-fd31-4f1c-9c8a-f6b3002071b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Good. The image is ready. Let's push to the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the image to Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Hub is a public repository to store Docker images. It is free, and
    we will use it for this book. Now, we will push our image to the Docker Hub registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command for that is pretty simple. Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I have used the `springfivebyexample` user that I have created. You can test
    the `docker push` command creating by your own user on Docker Hub and changing
    the user on the `docker push` command. You can create your Docker ID at Docker
    Hub ([https://cloud.docker.com/](https://cloud.docker.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the image will be sent to the registry. That is it.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the image at Docker Hub ([https://store.docker.com/community/images/springfivebyexample/cms](https://store.docker.com/community/images/springfivebyexample/cms)).
    If you have used your own user, the link will probably change.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Docker Spring profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we run our application in a Docker container, we need to create a YAML
    file to configure a container profile. The new YAML file should be named as `application-container.yaml`
    because we will use the container profile to run it. Remember, we configured the
    `entrypoint` on `pom.xml` in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our new file. The file should be the same content as described
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The host must be changed for MongoDB. We have been running the MongoDB container
    with this name in the *Preparing a MongoDB* section. It is an important configuration,
    and we need to pay attention at this point. We cannot use localhost anymore because
    the application is running in the Docker container now. The localhost in that
    context means it is in the same container, and we do not have MongoDB in the CMS
    application container. We need to have one application per container and avoid
    multiple responsibilities for one container.
  prefs: []
  type: TYPE_NORMAL
- en: Done. In the following section, we will run our first application in the Docker
    container. It will be amazing. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Dockerized CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have created our file to configure the container
    profile properly. Now, it is time to run our container. The command is quite simple,
    but we need to pay attention to the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instruction we run should be the same as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have been setting the link for the MongoDB container. Remember, we made this
    configuration in the YAML file, in the `host` property. During the bootstrapping
    phase, the application will look for MongoDB instance named `mongodb`. We solved
    this by using the link command. It will work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check if our application is healthy by using the `docker ps` command.
    The output should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa2019c6-2585-4fdb-aee0-97d8d59cd286.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first line, we have our application container. It is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome work. Our application is fully containerized and ready to deploy anywhere
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: Putting in Reactive fashion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been creating an amazing application with Spring Boot. The application
    was built on the traditional web stack present on Spring Framework. It means the
    application uses the web servers based on Servlet APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The servlet specification was built with the blocking semantics or one-request-per-thread
    model. Sometimes, we need to change the application architecture because of non-functional
    requirements. For example, if the application was bought by a huge company, and
    that company wanted to create a plan to launch the application for the entire
    world, the volume of requests would probably increase a lot. So, we need to change
    the architecture to adapt the application structure for cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, in a cloud environment, the machines are smaller than traditional data
    centers. Instead of a big machine, it is popular to use many small machines and
    try to scale applications horizontally. In this scenario, the servlet spec can
    be switched to an architecture created upon Reactive Streams. This kind of architecture
    fits better than servlet for the cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework has been creating the Spring WebFlux to helps developers to
    create Reactive Web Applications. Let's change our application architecture to
    reactive and learn the pretty new Spring WebFlux component.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Reactive Stream Spec is the specification that provides a standard for asynchronous
    programming for stream processing. It is becoming popular in the programming world
    nowadays, and Spring introduces it on the framework.
  prefs: []
  type: TYPE_NORMAL
- en: This style of programming is more efficient regarding resources usage and fits
    amazingly with the new generation of machines with multiple cores.
  prefs: []
  type: TYPE_NORMAL
- en: Spring reactive uses the Project Reactor as the implementation for the Reactive
    Streams. The Project Reactor is powered by Pivotal and has the very good implementation
    of the Reactive Streams Spec.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will deep dive in the reactive module for Spring Boot and create an
    amazing reactive API and try the new style of the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Project Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Project Reactor was created by the Spring and Pivotal teams. This project
    is an implementation of Reactive Streams for JVM.  It is a fully non-blocking
    foundation and helps developers to create a non-blocking application in the JVM
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: There is a restriction to using Reactor in our application. The project runs
    on Java 8 and above. It is important because we will use many lambda expressions
    in our examples and projects.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework internally uses the Project Reactor as an implementation
    of Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the different components of the Project Reactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publishers**:The publishers are responsible for pushing data elements to
    the stream. It notifies the subscribers that a new piece of data is coming to
    the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The publisher interface is defined in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Subscribers**: The subscribers are responsible for making the data flow in
    the stream. When the publisher starts to send the piece of data on the data flow,
    the piece of data will be collected by the `onNext(T instance)` method, which is
    the parametrized interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The subscriber interface is defined in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Hot and cold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two categories of reactive sequences—hot and cold. These functions
    affect the usage of the implementation directly. Hence, we need to understand
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cold**: The cold publishers start to generate data only if it receives a
    new subscription. If there are no subscriptions, the data never comes to the flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hot**: The hot publishers do not need any subscribers to generate the data
    flow. When the new subscriber is registered, the subscriber will only get the
    new data elements emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two reactive types which represent the reactive sequences. The `Mono` objects
    represent a single value or empty 0|1\. The `Flux` objects represent a sequence
    of 0|N items.
  prefs: []
  type: TYPE_NORMAL
- en: We will find many references in our code. The Spring Data reactive repository
    uses these abstractions in their methods. The `findOne()` method returns the `Mono<T>` object
    and the `findAll()` returns a `Flux<T>`. The same behavior we will be found in
    our REST resources.
  prefs: []
  type: TYPE_NORMAL
- en: Let's play with the Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand it better, let's play with the Reactor. We will implement and
    understand the difference between hot and cold publishers in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cold** publishers do not produce any data until a new subscription arrives.
    In the following code, we will create a cold publisher and the `System.out:println`
    will never be executed because it does not have any subscribers. Let''s test the
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the method `subscribe()` is not present in this snippet. When
    we execute the code, we will not see any data on the standard print output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute the method on the IDE. We will able to see the output of this
    test. The output should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2ea25e-3922-45d7-b0fc-beddae937856.png)'
  prefs: []
  type: TYPE_IMG
- en: The process has finished, the test passed, and we will not be able to see the
    print. That is the cold publisher's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will subscribe the publisher and the data will be sent on the data flow.
    Let's try this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will insert the subscribe instruction after `doOnNext()`. Let''s change
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcfef033-e11d-4d1d-9b4b-d9cdb2ac69b3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that the publisher pushes the data on
    the stream after the stream got subscribed. That is the cold publisher behavior
    after the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hot publishers do not depend on any subscribers. The hot publisher will publish
    data, even if there is no subscriber to receive the data. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand what happens here. The `UnicastProcessor` is a processor that
    allows only one `Subscriber`.The processor replays notifications when the subscriber
    requests. It will emit some data on a stream. The first subscription will capture
    all the categories, as we will see, because it was registered before the event
    emissions. The second subscription will capture only the last events because it
    was registered before the last two emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47ec7d59-37b9-4c73-9997-cc6cad4ecc34.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome. This is the hot publisher's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional Java enterprise web applications are based on the servlet specification.
    The servlet specification before 3.1 is synchronous, which means it was created
    with blocking semantics. This model was good at the time because computers were
    big with a powerful CPU and hundreds of gigabytes of memory. Usually, the applications
    at the time were configured with a big thread pool with hundreds of threads because
    the computer was designed for this. The primary deployment model at that time
    was the replica. There are some machines with the same configuration and application
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The developers have been creating applications like this for many years.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, most of the applications are deployed in cloud vendors. There are
    no big machines anymore because the price is much higher. Instead of big machines,
    there are a number of small machines. It is much cheaper and these machines have
    a reasonable CPU power and memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this new scenario, the application with the huge thread pools is not effective
    anymore, because the machine is small and it does not have the power to handle
    all these threads.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Team added the support for the Reactive Streams in the framework.
    This model of programming changes the application deployment and the way to build
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a thread-per-request model, the applications are created with the
    event-loop model. This model requires a small number of threads and is more efficient
    regarding resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Event-loop model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Popularized by the NodeJS language, this model is based on event-driven programming.
    There are two central concepts: the events which will be enqueued on a queue,
    and the handlers which keep track of and process these events.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some advantages of adopting this model. The first one is the ordering.
    The events are enqueued and dispatched in the same order in which the events are
    coming. In some uses cases, this is an important requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The other one is the synchronization. The event-loop must be executed on only
    one thread. This makes the states easy to handle and avoids the shared state problems.
  prefs: []
  type: TYPE_NORMAL
- en: There is an important piece of advice here. The handlers must not be synchronous.
    Otherwise, the application will be blocked until the handlers end their workload.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data for Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data projects have some extensions to work with a reactive foundation.
    The project provides a couple of implementations based on asynchronous programming.
    It means the whole stack is asynchronous since database drivers are as well.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring reactive repository supports Cassandra, MongoDB, and Redis as database
    stores. The repository implementations offer the same behaviors as the non-reactive
    implementation. There is a **DSL** (**Domain-Specific Language**) to create domain-specific
    query methods.
  prefs: []
  type: TYPE_NORMAL
- en: The module uses the Project Reactor as a reactive foundation implementation,
    but is possible to change the implementation to RxJava as well. Both libraries
    are production-ready and are adopted by the community. One point to be aware of
    is that if we change to RxJava, we need to ensure our method returns to `Observable`
    and `Single`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data Project has support for the reactive data access. Until now,
    Spring has support for MongoDB, Apache Cassandra, and Redis, all of which have
    reactive drivers.
  prefs: []
  type: TYPE_NORMAL
- en: In our CMS application, we will use the MongoDB reactive drivers to give the
    reactive characteristics for our repositories. We will use the new reactive interface
    provided by the Spring Data reactive. Also, we need to change the code a little
    bit. In this chapter, we will do that step by step. Let's start.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive repositories in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, we can check out the full source code at GitHub, or we can
    perform the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to build our new reactive repositories. The first thing that
    we need to do is add the Maven dependencies to our project. This can be done using
    `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure our new dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our project is ready to use reactive MongoDB repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first Reactive repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a couple of repositories in our CMS project. Now, we need to convert
    these repositories to reactive ones. The first thing we will do is remove the
    extension from `CrudRepository`, which is not necessary anymore. Now, we want
    the reactive version of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will update the `ReactiveMongoRepository` interface. The parameters of the
    interface are the same as the ones we inserted before. The interface should be
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is quite similar to the one we created before. We need to extend the new
    `ReactiveMongoRepository` interface, which contains methods for the CRUD operations
    and much more. The interface returns `Mono<Category>` or `Flux<Category>`.  The
    methods do not return the entities anymore. It is a common way of programming
    when the Reactive Stream is adopted.
  prefs: []
  type: TYPE_NORMAL
- en: We need to change the other repositories as well. You can find the full source
    code on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to change the service layer. Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to change the service layer to adopt the new reactive programming style.
    We changed the repository layer, so now we need to fix the compilation problem
    result because of this change. The application needs to be reactive. Any point
    of the application can be blocked because we are using the event-loop model. If
    we do not do this, the application will be getting blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the CategoryService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will fix the `CategoryService` class. We will change the return type
    of a couple of methods. Before, we could return the model class, but now we need
    to change to return `Mono` or `Flux`, similar to what we did in the repository
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `CategoryService` should be like the implementation shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the return types changed in the methods.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is that we need to follow the reactive principles.
    When the method returns only one instance, we need to use `Mono<Category>`. When
    the method returns one or more instances, we should use `Flux<Category>`. This
    is essential to follow because developers and Spring containers can then interpret
    the code correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The `update()` method has an interesting call: `flatMap()`. The project reactor
    allows us to use a kind of DSL to compose calls. It is very interesting and very
    useful as well. It helps developers to create code that is easier to understand
    than before. The `flatMap()` method is usually used to convert the data emitted
    by `Mono` or `Flux`. In this context, we need to set the new name of the category
    on the category retrieved from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the REST layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make some fixes on the REST layer as well. We changed the service layer,
    and it caused some compilation problems in our resources classes.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add the new dependency, `spring-web-reactive`. This supports the
    `@Controller` or `@RestController` annotations for the reactive non-blocking engine.
    The Spring MVC does not support the reactive extensions, and this module enables
    developers to use reactive paradigms, as they did before.
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-web-reactive` will change many contracts on the Spring MVC foundations,
    such as `HandlerMapping`, and `HandlerAdapter`, to enable reactive foundations
    on these components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image can help us to better understand the Spring HTTP layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1890e6e7-c0ca-4eb5-a423-dec9beea51ed.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, `@Controller` and `@RequestMapping` can be used for different
    approaches in the Spring MVC traditional applications, or by using the Spring
    web reactive module.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start to change our REST layer, we need to remove the Spring Fox dependencies
    and annotations in our project. At present, the Spring Fox has no support for
    reactive applications yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependencies to remove are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After that, we need to remove the annotations from the Swagger packages, such
    as `@Api` and `@ApiOperation`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's adjust our REST layer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Spring WebFlux dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to change our REST layer, we need to add the new dependency
    to our `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will remove the Spring MVC traditional dependencies. To do this,
    we need to remove the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need this dependency anymore. Our application will be reactive now.
    Then, we need to add the new dependencies described in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`spring-boot-starter-webflux`is a kind of syntax sugar for dependencies. It
    has the `spring-boot-starter-reactor-netty` dependency, which is the Reactor Netty,
    as embedded in the reactive HTTP server.'
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, our project is ready to convert the REST layer. Let's transform our
    application into a fully reactive application.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the CategoryResource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will change the `CategoryResource` class. The idea is pretty simple. We will
    convert our `ResponseEntity`, which is parametrized with the models class to `ResponseEntity`
    using `Mono` or `Flux`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new version of the `CategoryResource` should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code is quite similar to what we did before. We have used the  `@RequestBody`
    annotation in the method argument; otherwise, the JSON converter will not work.
  prefs: []
  type: TYPE_NORMAL
- en: The other important characteristic here is the `return` method. It returns `Mono`
    or `Flux`, which are parameterized types for `ResponseEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the reactive implementation by using the command line. It will
    persist the `Category` object on MongoDB. Type the following command on the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we can use the following command to check the database. Using the
    browser, go to `http://localhost:8080/api/category`. The following result should
    be presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6236f06f-38ed-46f9-9b97-68d12de94b78.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome, our reactive implementation is working as expected. Well done!!!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned a lot of Spring concepts. We have introduced
    you to Spring Data projects, which help developers to create data access layers
    as we have never seen before. We saw how easy it is to create repositories with
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we presented some relatively new projects, such as Spring WebFlux, which
    permits developers to create modern web applications, applying the Reactive Streams
    foundations and reactive programming style in projects.
  prefs: []
  type: TYPE_NORMAL
- en: We have finished our CMS application. The application has the characteristics
    of a production-ready application, such as database connections, and services
    which have been well-designed with single responsibilities. Also, we introduced
    the `docker-maven-plugin`, which provides a reasonable way to create images using
    the `pom.xml` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a new application using the *Reactive Manifesto*
    based on message-driven applications. See you there.
  prefs: []
  type: TYPE_NORMAL
