- en: Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue working on the retirement calculator that
    we implemented in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*. Our calculator worked correctly as long as we passed
    the right arguments, but would fail badly with a horrible stack trace if any of
    the parameters were wrong. Our program only worked for what we call the *happy
    path*.
  prefs: []
  type: TYPE_NORMAL
- en: The reality of writing production software is that all kinds of error scenarios
    can occur. Some of them are recoverable, some of them must be presented to the
    user in an attractive way, and, for some hardware-related errors, we might need
    to let the program crash.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce exception handling, explain what referential
    transparency is, and try to convince you that exceptions are not the best way
    to deal with errors. Then, we will explain how to use functional programming constructs
    to effectively handle the possibility of an error.
  prefs: []
  type: TYPE_NORMAL
- en: In each section, we will briefly introduce a new concept, and then use it in
    a Scala worksheet to get a sense of how to use it. After that, we will apply this
    new knowledge to improve the retirement calculator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding referential transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Option` to represent optional values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Either` to handle errors sequentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Validated` to handle errors in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not completed [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, then you can check out the retirement calculator project
    at GitHub. If you are not already familiar with Git, I would advise that you read
    the documents at [https://guides.github.com/introduction/git-handbook/](https://guides.github.com/introduction/git-handbook/) first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the setup, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account at [https://github.com/](https://github.com/) if you do not
    have one already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the retirement calculator project at [https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects).
    Click on Fork in the top-right corner to fork the project into your account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project is forked, click on Clone or download, and copy the URL into
    the clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In IntelliJ, go to File | New | Project from Version Control | GitHub and make
    the following edits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git repository URL**:** Paste the URL of your forked repository
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent directory**:** Choose a location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory name**:** Keep `retirement_calculator`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Clone
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project should be imported in IntelliJ. Click on git: master in the bottom-right
    of the screen and select Remote branches | origin/chapter2 | Checkout as new local
    branch. Name the new branch `chapter3_yourusername` to distinguish it from the
    final solution, which is in the `origin/chapter3` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project with *Ctrl* + *F9*. Everything should compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exceptions are one of the mechanisms that we can use in Scala to handle error
    scenarios. It consists of two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `throw exceptionObject` statement stops the current function and passes
    the exception up to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `try { myFunc() } catch { case pattern1 => recoverExpr1 }` statement catches
    any exception thrown by `myFunc()` if the exception matches one of the patterns
    inside the `catch` block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an exception is thrown by `myFunc`, but no pattern matches the exception,
    the function stops, and the exception is passed up to the caller again. If there
    is no `try...catch` block in the call chain that can catch the exception, the
    whole program stops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an exception is thrown by `myFunc`, and the `pattern1` pattern matches the
    exception, the `try...catch` block will return the `recoverExpr1` expression at
    the right of the arrow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no exception is thrown, the `try...catch` block returns the result returned
    by `myFunc()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This mechanism comes from Java, and since the Scala SDK sits on top of the Java
    SDK, many function calls to the SDK can throw exceptions. If you are familiar
    with Java, the Scala exception mechanism differs slightly. Exceptions in Scala
    are always *unchecked*, which means that the compiler will never force you to
    catch an exception or declare that a function can throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a code snippet that demonstrates how exceptions can be thrown.
    You can paste it in the Scala console or in a Scala worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createPerson` function creates the `Person` object if the string passed
    in an argument is correct, but throws different types of exceptions if it is not.
    In the preceding code, we also implemented our own `AgeNegativeException` isntance,
    which is thrown if the age passed in the string is negative, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the exceptions are not caught by any `try...catch` block, the Scala console
    shows a **stack trace**. The stack trace shows all the nested function calls that
    led to the point where the exception was thrown. In the last example, the `val
    age = split(1).toInt` line in `createPerson` called `scala.collection.immutable.StringOps.toInt`,
    which called `scala.collection.immutable.StringLike.toInt$`, and so on, until
    finally the `java.lang.Integer.parseInt` function threw the exception at line
    580 in `Integer.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to illustrate how exceptions bubble up the call stack, we are going
    to create a new `averageAge `function, which calculates the average age of a list
    of `Person `instances, using their string descriptions, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function calls our previously implemented `createPerson `function, and
    therefore will throw any exception that is thrown by `createPerson` because there
    is no `try...catch` block in `averageAge`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement another function on top that will parse an input containing
    several `Person` descriptions and return a summary in a string. It will print
    an error message in case the input cannot be parsed, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we declare an `avg` value, which will get the return value
    of `averageAge` if no exception is thrown. If one of the descriptions contains
    a negative age, our catch block will print an error message, and `avg` will be
    assigned the value of `0`. If another type of exception is thrown, and this exception
    is `NonFatal`, then we print another message and `avg` will also be assigned the
    value of `0`. A fatal exception is an exception that cannot be recovered, such
    as `OutOfMemoryException`. You can look at the implementation of `scala.util.control.NonFatal`
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a few sample calls to `personsSummary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, as soon as any of the descriptions cannot be parsed, an error
    is printed and the average age is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the finally block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `try...catch` block can optionally be followed by a `finally {}` block. The
    code inside the `finally` block is always executed, even if an exception is not
    matched by any pattern in the `catch` block. The `finally` block is typically
    used to close any resource that is accessed inside the `try` block, such as a
    file or a network connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use a URL to read a web page into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `finally` block allows us to close `InputStream`, whether the reading of
    the page succeeded or not. This way, we will not leave a dangling open connection
    in case there is a network issue or a thread interruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the preceding code is for illustrative purposes only. In a real project,
    you should use the following code format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to use exceptions, we are going to define the concept
    of referential transparency and show how catching exceptions can break it. We
    will then explore better data structures that will let us manage errors without
    breaking referential transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We say that an expression is **referentially transparent** when it can be replaced
    by its value without changing the program's behavior, in any context. When an
    expression is a function call, it means that we can always substitute this function
    call with the return value of the function. A function that guarantees this in
    any context is called a **pure function**.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is like a mathematical function—the return value depends only
    on the arguments passed to the function. You do not have to consider anything
    else about the context in which it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Defining pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code,  the `pureSquare` function is pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The functions called `pureSquare(4)` and `pureSquare(3)` are referentially transparent—when
    we replace them with the return value of the function, the program's behavior
    does not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following function is impure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot replace the call to `impure(3)` with its return value because the
    return value changes depending on the context. In fact, any function that has
    **side effects** is impure. A side effect can be any of the following constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutating a global variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a network connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading/writing data to/from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading/writing data to/from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More generally, any interaction with the outside world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is another example of an impure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You cannot substitute the result of `impureRand()` with its value because the
    value changes for every call. If you do so, the program's behavior changes. The
    call to `impureRand()` is not referentially transparent, and hence `impureRand`
    is impure. In fact, the `random()` function mutates a global variable to generate
    a new random number for every call. We can also say that this function is **nondeterministic**—we
    cannot predict its return value just by observing its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite our impure function to make it pure, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can substitute the call to `pureRand(seed)` with its value; the function
    will always return the same value given the same seed. The call to `pureRand`
    is referentially transparent, and `pureRand` is a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example of an impure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, the return value of `impurePrint` is of the `Unit `type.
    There is only one value of this type in the Scala SDK: the `()`value. If we replace
    the call to `impurePrint()` with `()`, then the program''s behavior changes—in
    the first case, something will be printed on the console, but not in the second
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Referential transparency is a key concept in functional programming. If most
    of your program uses pure functions, then it becomes much easier to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand what a program is doing:** You know that the function''s return
    value only depends on its arguments. You do not have to think about what the state
    of this or that variable is in this or that context. You just have to look at
    the arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test your functions:** I will restate this point—the function''s return value
    only depends on its argument. Testing it is very simple; you can try different
    argument values and confirm that the return value is what you expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write multithreaded programs:** Since a pure function''s behavior does not
    depend on a global state, you can execute it in parallel on multiple threads or
    even on different machines. The return values will not change. As our CPUs are
    built with more and more cores these days, this will help you write faster programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is not possible to only have pure functions in a program because,
    in essence, a program must interact with the outside world. It has to print something,
    read some user input, or save some state in a database. In functional programming,
    the best practice is to use pure functions in the majority of the code base and
    to push the impure side-effecting functions to the boundaries of the program.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, we implemented a retirement calculator that mostly uses
    pure functions. One side-effecting function was the `println` call in the `SimulatePlanApp`
    object, which was at the boundaries of the program. There were other side effects
    in `EquityData.fromFile` and `InflationData.fromFile`; these functions are for
    reading files. However, the resource files can never change for the duration of
    the program. For a given filename, we would always get the same file content,
    and we could substitute the return value of `fromFile` in all calls without changing
    the program's behavior. In this case, the side effect of reading a file is not
    observable, and we can consider theses file-reading functions as being pure. Another
    side-effecting function was `strMain` because it could throw exceptions. In the
    rest of this chapter, we will see why throwing exceptions break referential transparency,
    and we will learn how to replace it with better functional programming structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'An impure function fulfills the following two criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns `Unit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not take any arguments but returns a type. Since it returns something
    that cannot be obtained by using its arguments, it must be using a global state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that a pure function can use mutable variables or side effects inside
    the body of the function. As long as these effects are *not observable* by the
    caller, we consider the function pure. In the Scala SDK, many pure functions are
    implemented using mutable variables to improve performance. Look, for the instance,
    at the following implementation of `TraversableOnce.foldLeft`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Showing how exceptions break referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This might not seem obvious, but when a function throws an exception, it breaks
    referential transparency. In this section, I am going to show you why. First,
    create a new Scala worksheet and type the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will call `area` with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We get `total: Double = 14.0`. In the preceding code, the `area1` and `area2` expressions
    are referentially transparent. We can indeed *substitute* them with their value
    without changing the program''s behavior. In IntelliJ, select the `area1` variable inside
    the `try` block and hit *Ctrl* + *Alt* + *N* (inline variable), as shown in the
    following code. Do the same for `area2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `total` is the same as before. The program''s behavior did not change,
    hence `area1` and `area2` are referentially transparent. However, let''s see what
    happens if we define `area1` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we get `java.lang.IllegalArgumentException: too big`, because
    our `area(...)` function throws an exception when the width is greater than five.
    Now let''s see what happens if we inline `area1` and `area2` as before, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we get `total: Double = 0.0`. The program''s behavior changed
    when substituting `area1` with its value, hence `area1` is *not* referentially
    transparent.'
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated that exception handling breaks referential transparency, and
    hence functions that throw exceptions are impure. It makes a program more difficult
    to understand because you have to take into account *where* a variable is defined
    to understand how the program will behave. The behavior will change depending
    on whether a variable is defined inside or outside a `try` block. This might not
    seem to be a big deal in a trivial example, but when there are multiple chained
    function calls with `try` blocks along the line, matching different types of exceptions,
    it can become daunting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another disadvantage when you use exceptions is that the *signature* of the
    function does not indicate that it can throw an exception. When you call a function
    that can throw exceptions, you have to look at its implementation to figure out
    what type of exception it can throw, and under what circumstances. If the function
    calls other functions, it compounds the problem. You can accommodate this by adding
    comments or an `@throws` annotation to indicate what exception types can be thrown,
    but these can become outdated when the code is refactored. When we call a function,
    we should only have to consider its signature. A signature is a bit like a contract—given
    these arguments, I will return you a result. If you have to look at the implementation
    to know what exceptions are thrown, it means that the contract is not completed:
    some information is hidden.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know how to throw and catch exceptions, and why we should use them with
    caution. The best practice is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Catch recoverable exceptions as early as possible, and indicate the possibility
    of failure with a specific return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not catch exceptions that cannot be recovered, such as disk full, out of memory,
    or some other catastrophic failure. This will make your program crash whenever
    such exceptions happen, and you should then have a manual or automatic recovery
    process outside the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of this chapter, I will show you how to use the `Option`, `Either`,
    and `Validated` classes to model the possibility of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Using Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Scala `Option` type is an **algebraic data type** (**ADT**) that represents
    an optional value. It can also be viewed as `List` that can contain either one
    or no elements. It is a safe replacement for a `null` reference that you might
    have used if you have programmed in Java, C++, or C#.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating instances of Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a simplified definition of the `Option` ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala SDK provides a more refined implementation; the preceding definition
    is just for illustrative purpose. This definition implies that `Option` can be
    either of the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Some(value)`, which represents an optional value where the value is present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`, which represents an optional value where the value is not present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` sign in front of the `A` type parameter in the `Option[+A]` declaration
    means that `Option` is covariant in `A`. We will explore contravariance in more
    details in [Chapter 4](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml), *Advanced
    Features*.
  prefs: []
  type: TYPE_NORMAL
- en: For now, you just have to know that if `B` is a subtype of `A`, then `Option[B]`
    is a subtype of `Option[A]`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you might notice that `None` actually extends `Option[Nothing]`
    and not `Option[A]`. This is because a case object cannot accept a type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In Scala, `Nothing` is the bottom type, which means that it is a subtype of
    any other type.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that `None` is a subtype of `Option[A]` for any `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples of the usage of the different types of `Option`
    that you can paste in a Scala worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanation of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two examples show how we can define an `Option` type that can optionally
    contain `Int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following examples use the `headOption` and `lastOption` methods in `List`
    to show that many safe functions of the SDK return `Option`. If `List` is empty,
    these functions always return `None`. Note that the SDK also provides *unsafe*
    equivalent `head` and `last `methods. The unsafe methods throw an exception if
    we call them with an empty `List`, which might crash our program if we do not
    catch the exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many functions of the SDK provide equivalent safe (which return `Option`) and
    unsafe functions (which throw an exception). It is a best practice to always use
    the safe alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `Option` is an ADT, we can use pattern matching to test whether `Option`
    is `None` or `Some`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `get(key)`method in `Map` returns `Option`, containing the value associated
    with the key. If the key does not exist in `Map`, it returns `None`. When you
    start using `Option`, pattern matching is the most natural way of triggering different
    behaviors depending on the content of `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to use `map` and `getOrElse`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We saw earlier how to transform the elements of a vector using `map`. This works
    exactly the same for `Option`—we pass an anonymous function that will be called
    with the option's value if `Option` is not empty. Since our anonymous function
    returns a string, we obtain `Option[String]`. We then call `getOrElse`, which
    provides a value in case `Option` is `None`. The `getOrElse `phrase is a good
    way to safely extract the content of `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: Never use the `.get` method on `Option`—always use `.getOrElse`. The `.get`
    method throws an exception if `Option` is `None`, and hence is not safe.
  prefs: []
  type: TYPE_NORMAL
- en: Composing transformations with for... yield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the same `db: Map[String, Int]` phrase, containing the ages of different
    people, the following code is a naive implementation of a function that returns
    the average age of two people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The function returns `Option[Double]`. If `name1` or `name2` cannot be found
    in the `db` map, `averageAge` returns `None`. If both names are found, it returns
    `Some(value)`. The implementation uses `map` to transform the value contained
    in the option. We end up with a nested `Option[Option[Double]]`, but our function
    must return `Option[Double]`. Fortunately, we can use `flatten` to remove one
    level of nesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We managed to implement `averageAge`, but we can improve it using `flatMap`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As its name suggests, `flatMap` is equivalent to composing `flatten` and `map`.
    In our function, we replaced `map(...).flatten` with `flatMap(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good, but what if we want to get the average age of three or four
    people? We would have to nest several instances of `flatMap`, which would not
    be very pretty or readable. Fortunately, Scala provides a syntactic sugar that
    allows us to simplify our function further, called the `for` comprehension, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you compile a `for` comprehension, such as `for { ... } yield { ... }`,
    the Scala compiler transforms it into a composition of `flatMap`/`map` operations.
    Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` block, there can be one or many expressions phrased as `variable
    <- context`, which is called a **generator**. The left side of the arrow is the
    name of a variable that is bound to the content of the **context** on the right
    of the arrow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every generator except the last one is transformed into a `flatMap` expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last generator is transformed into a `map` expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All context expressions (the right side of the arrow) must have the same context
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding example, we used `Option` for the context type, but `for yield`
    can also be used with any class that has a `flatMap` and `map` operation. For
    instance, we can use `for..yield` with `Vector` to run nested loops, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Syntactic sugar** is syntax within a programming language that makes it easier
    to read or write. It makes it sweeter for the programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the retirement calculator to use Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what `Option` can do for us, we are going to refactor one of
    the functions of the retirement calculator that we developed in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, to improve the handling of some edge-case scenarios.
    If you have not done it yet, please follow the instructions at the beginning of
    the [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing a Retirement
    Calculator*, to set up the project.
  prefs: []
  type: TYPE_NORMAL
- en: In `RetCalc.scala`, we are going to change the return type of `nbMonthsSaving`.
    In [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing a Retirement
    Calculator*, we returned `Int.MaxValue` if `netIncome <= currentExpense` to avoid
    looping infinitely. This was not very robust, as this infinite result could then
    be used in another computation, which would lead to bogus results. It would be
    better to return `Option[Int]` to indicate that the function might not be computable
    and let the caller decide what to do. We would return `None` if it was not computable
    or `Some(returnValue)` if it was computable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the new implementation for `nbMonthsSaving`, with the
    changed portions highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now try to compile the project. This change breaks many parts of our project,
    but the Scala compiler is a terrific assistant. It will help us identify the portions
    of the code we need to change to make our code more robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first error is in `RetCalcSpec.scala`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This error means that the types in the `actual should === (expected)` expression
    do not match: `actual` is of the `Option[Int]0` type, whereas `expected` is of
    the `Int` type. We need to change the assertion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can apply the same fix for the second unit test. For the last unit test,
    we want to assert that `None` is returned instead of `Int.MaxValue`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can now compile and run the test. It should pass.
  prefs: []
  type: TYPE_NORMAL
- en: You are now able to model an optional value safely. However, sometimes it is
    not always obvious to know what `None` actually means. Why did this function return `None`?
    Was it because the arguments that were passed were wrong? Which argument was wrong?
    And what value would be correct? It would indeed be nice to have some explanation
    that comes along with the `None` in order to understand *why* there was no value.
    In the next section, we are going to use the `Either` type for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Using Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Either` type is an ADT that represents a value of either a `Left` type
    or a `Right` type. A simplified definition of `Either` would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you instantiate a `Right` type, you need to provide a value of a `B` type,
    and when you instantiate a `Left` type, you need to provide a value of an `A` type.
    Therefore, `Either[A, B]` can either hold a value of type `A` or a value of type
    `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of such a usage that you can type in a
    new Scala worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `divide` function returns either a string or a double:'
  prefs: []
  type: TYPE_NORMAL
- en: If the function cannot compute a value, it returns an error `String` wrapped
    in a `Left` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function can compute a correct value, it returns the `Double` value wrapped
    in a `Right` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By convention, we use `Right` to represent the correct or right value, and we
    use `Left` to represent an error.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `Either` is an ADT, we can use pattern matching to decide what to do when
    we get a `Left` or `Right` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a modified version of the `personDescription` function that
    we showed earlier in the *Using Option* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first `getPersonAge `function produces `Right(age)` if the `name `argument is
    present in `db`. If `name` is not present in `db`, it returns an error message
    wrapped in a `Left` type. For this purpose, we use the `Option.toRight `method.
    I encourage you to have a look at the documentation and implementation of this
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `personDescription` is straightforward—we pattern match
    using the result of `getPersonAge` and return an appropriate `String` depending
    on whether the result is a `Left` or `Right` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `Option`, we can also use `map` and `flatMap` to combine several instances
    of `Either`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note how the body of the function is almost the same as `Option`. This is because
    `Either` is **right biased**, meaning that `map` and `flatMap` transform the right
    side of `Either`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to transform the `Left` side of `Either`, you need to call the
    `Either.left `method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Either` implements `map` and `flatMap`, we can refactor `averageAge`
    to use a `for` comprehension, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, the code looks the same as it did with `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the retirement calculator to use Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of how to manipulate `Either`, we are
    going to refactor our retirement calculator to take advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring nbOfMonthsSavings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we changed the return type of `nbOfMonthsSavings` to
    return `Option[Int]`. The function returned `None` if the `expenses` arguments were greater
    than `income`. We are now going to change it to return an error message wrapped
    in `Left`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use a simple string for our error message, but the best practice when
    using `Either` is to create an ADT for all of the possible error messages. Create
    a new Scala class in `src/main/scala/retcalc` called `RetCalcError`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We define a `RetCalcError` trait that has only one `message `method. This method
    will produce the error message whenever we need to return it to the user. Inside
    the `RetCalcError `object, we define one case class per type of error message.
    We will then change the functions that need to return an error to return `Either[RetCalcError,
    A]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern has many advantages over just using `String`, as shown in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the error messages are located in one place. It allows you to immediately
    know what are all the possible error messages that can be returned to the user.
    You could also add different translations if your application uses multiple languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `RetCalcError` is an ADT, you can use pattern matching to recover from
    a specific error and take action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It simplifies testing. You can test whether a function returns a specific type
    of error without having to assert on the error message itself. This way, you can
    change your error messages without having to change any test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can refactor our `RetCalc.nbOfMonthsSavings `function to return `Either[RetCalcError,
    Int]`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to change the corresponding unit tests. ScalaTest provides convenient
    extensions to perform assertions on the `Either` type. To bring them in scope,
    extend `EitherValues` in `RetCalcSpec.scala`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a `myEither `variable of the `Either[A, B]` type in your test,
    then `EitherValues` will let us use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myEither.left.value` returns the left value of type `A` or fails the test
    if `myEither` is `Right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myEither.right.value` returns the right value of type `B` or fails the test
    if `myEither` is `Left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now change our unit tests on `nbOfMonthsSaving` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Run the unit test. It should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring monthlyRate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing a Retirement
    Calculator*, we implemented a `Returns.monthlyRate(returns: Returns, month: Int):
    Double` function that returned the monthly return rate for a given month. When
    we called it with a month exceeding the size of an instance of `VariableReturns`,
    we rolled over to the first month using a modulo operation.'
  prefs: []
  type: TYPE_NORMAL
- en: This was not completely satisfying, as it could compute unrealistic simulations.
    Say that your `VariableReturns` instance contains data for 1950 to 2017\. When
    you ask the monthly returns for 2018, `monthlyRate` would give you the returns
    that we had in 1950\. The economic outlook of the fifties was very different compared
    to the current one, and it is unlikely that the returns in 2018 will mirror those
    in 1950.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we are going to change `monthlyRate` to return an error if the `month`
    argument is outside the bounds of `VariableReturn`. First, open `RetCalcError.scala` and
    add the following error type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to change the unit tests to specify the function that we
    expect it to return. Open `ReturnsSpec.scala` and change the tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `Returns.scala` and change `monthlyRate` As follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Try to compile the project now. Since `monthlyRate` is called by other functions,
    we will get some compilation errors, which is actually a good thing. We just have
    to fix the compilation errors to make our code deal with the possibility of an
    error. Every fix requires some thinking about what to do with that possibility.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we had thrown an exception instead of returning `Either`,
    everything would have compiled, but the program would have crashed whenever the
    month was out of bounds. It would have been more difficult to achieve the desired
    behavior because the compiler would not have helped us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first compilation error is in `RetCalc.scala` in `futureCapital`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This means that we cannot call the `+` method on `Either[RetCalcError, Double]`.
    If `monthlyRate` returns `Left`, we cannot calculate the accumulated capital.
    The best course of action would be to stop here and return the error. For this,
    we need to change the return type of `futureCapital` to `Either[RetCalcError,
    Double]` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the corrected version of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the second line, we changed the initial element passed to `foldLeft`. We
    are now accumulating `Either[RetCalcError, Double]`. Note that we have to explicitly
    specify the type parameter for `foldLeft`. In the previous version of the function,
    when we were using `Double`, that type was inferred automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not specify the type parameter, the compiler will infer it to be of
    the type of the initial element. In our case, `Right(initialCapital)` is of the
    `Right[Nothing, Double] `type, which is a subclass of `Either[RetCalcError, Double]`.
    The problem is that, inside the anonymous function, we return `Either[RetCalcError,
    Double]`, not `Right[Nothing, Double]`. The compiler would complain that the types
    do not match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the anonymous function passed to `foldLeft`, we use a `for` comprehension
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the accumulated result in `Right` if both `acc` and `monthlyRate` are `Right`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `Left` if `acc` or `monthlyRate` is `Left`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that our implementation does not stop as soon as `monthlyRate` returns `Left`,
    which is a bit inefficient. There is no point in iterating through the other months
    when we get an error because this function should always return the first error
    it encounters. In [Chapter 4](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml), *Advanced
    Features*, we will see how we can use lazy evaluation with `foldr` to stop the
    iteration early.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the project again. Now we need to fix a compilation error in `simulatePlan`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring simulatePlan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `simulatePlan` calls `futureCapital`, we need to change its implementation
    to take into account the new return type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We moved the two calls to `futureCapital` inside a `for` comprehension. This
    way, if any of these calls return an error, `simulatePlan` will return it. If
    both calls succeed, `simulatePlan` will return the two double values in a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the project. Now we need to fix a compilation error in `nbOfMonthsSaving`,
    which uses `simulatePlan`. The following code is the fixed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We had to change our recursive `loop` function to return `Either[RetCalcError,
    Int]`. The loop will stop as soon as we get an error or `if (capitalAfterDeath
    > 0.0)`. You might wonder why we did not use `flatMap` instead of using pattern
    matching. It would indeed have been more concise, but the `loop` function would
    not be tail recursive anymore, because the recursive call to loop would be inside
    an anonymous function. As an exercise, I encourage you to try changing the code
    so that it uses `flatMap` and observe the tail recursion compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the project. The last compilation error in the production code is in
    `SimulatePlanApp.scala`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring SimulatePlanApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entry point of our `SimulatePlanApp `application calls `simulatePlan`. We
    need to change it to return the text of any error that could occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to change the integration test to add a new test case. Open 
    `SimulatePlanIT.scala` and add the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `SimulatePlanApp.scala` and change the implementation of `SimulatePlanApp `as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We just have to pattern match on the result of `simulatePlan`, and return a
    string explaining the result of the computation if it is a `Right` value, or return
    the error message if it is a `Left` value.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the project. Now all the production code should compile, but there are
    still several compilation errors in the unit tests. As an exercise, I encourage
    you to try to fix them. In most cases, you have to make the test extend `EitherValues`,
    and call `.right.value` on an `Either` class to get its right value. Once you
    have fixed the remaining errors, compile and run all the tests of the project.
    They should all pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now your code should look like the `Chapter03` branch in the Scala fundamentals
    GitHub project, apart from the `SimulatePlanApp` class, which we will improve
    in the next section. See [https://github.com/PacktPublishing/Scala-Programming-Projects](https://github.com/PacktPublishing/Scala-Programming-Projects) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Using ValidatedNel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can model the possibility of an optional
    value with `Option` and the possibility of an error with `Either`. We demonstrated
    how these types can replace exceptions while guaranteeing referential transparency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also saw how we can combine several `Option` or `Either` types using `flatMap`.
    This works well when we have to check for optional values or errors *sequentially*—call
    `function1`; if there is no error, call `function2`; if there is no error, call
    `function3`. If any of these functions return an error, we return that error and
    stop the call chain, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, in some situations, we would want to call several functions in parallel
    and return all the errors that might have occurred. For instance, when you enter
    some personal details to purchase a product from an online shop, you expect the
    website to highlight all the mistakes in all the fields after you submit the details.
    It would be a bad user experience to have the website tell you that the last name
    is mandatory after submitting the details, and subsequently that your password
    is too short after submitting the details again. All the fields must be validated
    simultaneously and all errors must be returned to the user in one go.
  prefs: []
  type: TYPE_NORMAL
- en: The data structure that can help us address this use case is `Validated`. Unfortunately,
    it is not part of the Scala SDK, and we have to use an external library called
    `cats` to bring it into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the cats dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cats` library provides abstractions for functional programming. Its name
    comes from the shortening of the phrase *category theory*. It is also a reference
    to the famous joke that managing developers is like herding cats—the truth is
    that you don't really have control—cats do whatever they want.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to focus only on `Validated` and `NonEmptyList`,
    but `cats` offers many more powerful abstractions that we will explore later in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit `built.sbt` and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This brings the `cats` dependency to our project and also enables a compiler
    flag (`partial unification`) that is required by the library to infer types correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Save the project with *Ctrl* + *S*. IntelliJ should offer to update the project
    to reflect the changes in the `build` file. Click on Refresh Project on top of
    `built.sbt`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing NonEmptyList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its name implies, the `cats.data.NonEmptyList` type represents a `List` instance
    that has at least one element. In other words, it is a `List` instance that cannot
    be empty. The following are some examples of this usage that you can retype in
    a new Scala worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can construct `NonEmptyList` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply[A]`: You can pass a `head` element and a `List` as a tail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromList[A]`: You can pass `List`. You get back `Option[NonEmptyList[A]]`
    that will be `None` if the `List` argument is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of[A]`: You can pass a `head` element and variable length `List `argument for
    the tail. This is is the most convenient way of building `NonEmptyList` when you
    know its constituents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since `NonEmptyList` always contains at least one element, we can always call
    the `head` method without risking getting an exception. As a consequence, there
    is no `headOption` method. You can manipulate `NonEmptyList` with all the usual
    methods that you would use on `List`: `map`, `tail`, `flatMap`, `filter`, and
    `foldLeft`, to name a few.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Validated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cats.data.Validated[E, A]`type is very similar to `Either[E, A]`. It is
    an ADT that represents a value of either an `Invalid` type or a `Valid` type.
    A simplified definition would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We will see what the `+` sign in front of a type parameter means in the section
    on covariance and contravariance in [Chapter 4](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml), *Advanced
    Features*. For now, though, do not worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the definition of `Option`, the definitions use contravariance
    and `Nothing`. This way, `Valid[A]` is a subtype of `Validated[E, A]` for any
    `E`; and `Invalid[E]` is a subtype of `Validated[E, A]` for any `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference with `Either` is that we can accumulate the errors produced
    by several `Validated` instances. Here are some examples that you can retype in
    a new Scala worksheet. I advise you to uncheck the Type-aware highlighting box
    in the bottom-right corner of IntelliJ; otherwise, IntelliJ will underline some
    expressions in red, even though they compile fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define a `Valid` value of `1`, with a `Valid` type `Int` parameter,
    and an `Invalid` type `NonEmptyList[String]` parameter. Each error will be of
    a `String` type, and the `NonEmptyList` instance will force us to have at least
    one error when we produce an `Invalid` value. This usage is so common that `cats`
    provide a type alias called `ValidatedNel` in the `cats.data `package, as shown
    in the following code :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Going back to our example, in the second line, we define a `Valid` value of `2`
    using a handy `cats` method called `.validNel`. When calling `validNel`, we have
    to pass the type of error, because in this case, the compiler does not have any
    information to infer it. In our case, the error type is `String`. The resulting
    type of `valid2` is `ValidatedNel[String, Int]`, which is an alias for `Validated[NonEmptyList[String],
    Int]`.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line, we *compose* the two valid values by putting them in a tuple
    and call `mapN`. The `mapN` phrase accepts an `f `function that takes as many
    arguments as there are elements in the tuple. If *all* of the elements of the
    tuple are `Valid` values, `f` is called and its result will be wrapped in a `Valid`
    value. If *any* of the elements inside the tuple are `Invalid` values, then all
    the `Invalid` values are *combined* together and wrapped in an `Invalid` value.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe that, when we compose `valid1` and `valid2`, which are all `Valid`,
    `mapN` returns a `Valid` value. When we compose `valid1`, `valid2`, `invalid3`,
    and `invalid4`, `mapN` returns an `Invalid` value. This `Invalid` value wraps
    a `NonEmptyList` that contains the errors of `invalid3` and `invalid4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know two mechanisms to represent the possibility of a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Either` with `for...yield` can be used to validate *sequentially*,stopping
    at the first error encountered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Validated` with `mapN` can be used to validate in parallel, accumulating all
    the errors in `NonEmptyList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the retirement calculator to use ValidatedNel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this new knowledge, we are well equipped to improve our retirement calculator
    further. We are going to improve `SimulatePlanApp` to give the users more information
    if one or many arguments passed to the program are wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When many arguments are wrong, for instance, if the user passes some random
    text instead of a parsable number, we want to report one error for every bad argument.
  prefs: []
  type: TYPE_NORMAL
- en: Adding unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we need to change the test associated with `SimulatePlanApp`. Open
    `SimulatePlanAppIT.scala` and change the content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two tests do not change much—we just changed the expectations to be `Valid(expectedResult)`.
    We are going to change the return type of `SimulatePlanApp.strMain`—instead of
    returning a string, we are going to change it to return `Validated[String, String]`.
    We expect `strMain` to return a `Valid` value containing the result if all arguments
    are correct. If some arguments are incorrect, it should return an `Invalid` value
    containing `String` explaining what the incorrect arguments are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third test is a new test. If we do not pass the right number of arguments,
    we expect `strMain` to return an `Invalid` value containing a usage example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth test checks that one error for every bad argument is reported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing parsing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to add new types of errors that will be returned in `ValidateNel`
    when some arguments are wrong. We need to change `RetCalcError.scala` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we introduced an `InvalidNumber` error that will be returned when a string
    cannot be parsed into a number. The other error, `InvalidArgument`, will be returned
    when an argument is wrong. We will use it when the `from` and `until` parameters
    are wrong (see the preceding unit test). Also, as we are going to use many types
    of `ValidatedNel[RetCalcError, A]` form, we created a type alias, `RetCalcResult`.
    It will also help IntelliJ to autocomplete the functions of the `cats` library.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we need to change `SimulatePlanApp.strMain` to validate the arguments.
    For this, we start by writing a small function that parses one string argument
    to produce `Validated Int`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, all the following parsing functions should be unit tested. We do have
    indirect test coverage for them in `SimulatePlanAppIT`, but it is not sufficient.
    In test-driven development, whenever you need to write a new function, you should
    just define its signature and then write a test before implementing it. Unfortunately,
    we do not have enough space in this book to show all of the unit tests that you
    would expect to have in a production application. However, as an exercise, I encourage
    you to write them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this function `parseInt`. It takes the name of an argument and its
    value, and returns `Validated Int`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We first call the `Validated.catchOnly` method, which executes a block of code
    (in our case, `value.toInt`) and catches a specific type of exception. If the
    block does not throw any exception, `catchOnly` returns a `Valid` value with the
    result. If the block throws the exception type passed as an argument (in our case, `NumberFormatException`),
    then `catchOnly` returns an `Invalid` value containing the caught exception. The
    resulting expression type is `Validated[NumberFormatException, Int]`. However,
    our `parseInt` function must return `RetCalcResut[Int]`, which is an alias for
    `ValidatedNel[RetCalcError, Int]`. In order to transform the error or left type,
    we call the `Validated.leftMap` method to produce `NonEmptyList[RetCalcError]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we write another function, `parseFromUntil`—that is in charge of parsing
    the `from` and `until `arguments. These two arguments are separated by a comma,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We create an `Array[String]` with the `String.split `method. If the array does
    not have exactly two elements, we return an `Invalid` value containing an `InvalidArgument`
    error. If the array has two elements, then we return them in a tuple inside a
    `Valid` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we write a `parseParams `function that accepts an array of arguments
    and produces `RetCalcResult[RetCalcParams]`. The `RetCalcParams` argument is one
    of the arguments required by `RetCalc.simulatePlan`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The function assumes that the `args` array has at least six elements. We create
    a tuple of four elements, each element being the result of `parseInt`, and hence,
    it has the `RetCalcResult[Int]` type. Then, we call the `mapN` method on our `Tuple4`,
    which will accumulate any error produced by the calls to `parseInt`. If all of
    the `parseInt` calls return a `Valid` value, the anonymous function passed to
    `mapN` is called. It takes `Tuple4 (Int, Int, Int, Int)` and returns a `RetCalcParams`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SimulatePlanApp.strSimulatePlan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to keep `SimulatePlanApp.strMain` small and readable, we are going
    to extract the code that is in charge of calling `RetCalc.simulatePlan` and return a
    human-readable string detailing the result of the simulation. We call this new
    function `strSimulatePlan`, and use it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The function takes the parsed arguments, calls `simulatePlan`, and transforms
    its result into a string. In order to keep the same type as our parsing functions,
    we declare the return type of the function to be `RetCalcResult[String]`. This
    is an alias for `ValidatedNel[RetCalcError, String]`, but `simulatePlan` returns `Either[RetCalcError,
    String]`. Fortunately, `cats` provide `.toValidatedNel` method to easily convert
    `Either` to `ValidatedNel`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring SimulatePlanApp.strMain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have implemented some building blocks for parsing the whole arguments array.
    It is now time to refactor `SimulatePlanApp.strMain` to call them. First, we need
    to check that the arguments array has the right size, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In order to match the assertions we made in the `SimulatePlanAppIT `integration
    test, we change the signature to return `Validated[String, String]`. If the arguments
    array is of the wrong size, we return an `Invalid` value, with a string explaining
    the correct usage for our program. Otherwise, when the arguments array is of the
    right size, we first declare the `allReturns` variable as before.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the three parsing functions that we implemented earlier and assign
    them to `vFromUntil`, `vNbOfYearsSaving`, and `vParams`. Their types are `RetCalcResult[(String,
    String)]`, `RetCalcResult[Int]`, and `RetCalcResult[RetCalcParams]` respectively.
    After that, we put these three values in `Tuple3`, and call the `cats` `tupled`
    function, which combines the three elements of the tuple to produce `RetCalcResult[((String,
    String), Int, RetCalcParams)]`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a `ValidatedNel` instance containing all the required
    parameters to call the `strSimulatePlan` function that we implemented earlier.
    In this case, we need to check errors sequentially—first, we validate all the
    arguments, *and then* we call `strSimulatePlan`. If we had used `Either` instead
    of `ValidatedNel`, we would have used `flatMap` to do this. Fortunately, `ValidatedNel`
    provides an equivalent method in the form of `andThen`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `Option` and `Either`, instances of `ValidatedNel` do not have a `flatMap`
    method because it is not a monad, it is an applicative functor. We will explain what
    these terms mean in [Chapter 4,](79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml) *Advanced
    Features*. If you want to run validations in sequence, you need to use `andThen` or
    convert in to `Either` and use `flatMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Before the call to `.leftMap`, we have an expression of the `RetCaclResult[String] `type,
    which is an alias for `Validated[NonEmptyList[RetCalcError], String]`. However,
    our function must return `Validated[String, String]`. Therefore, we transform
    the left `NonEmptyList[RetCalcError]`type to a string using the anonymous function
    passed to `.leftMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can handle optional values and how to handle
    errors in a purely functional way. You are now better equipped to write safer
    programs that do not throw exceptions and crash unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Java libraries or some non-purely-functional Scala libraries, you
    will notice that they can throw exceptions. If you do not want your program to
    crash when exceptions are raised, I advise you to wrap them as early as possible
    inside `Either` or `Validated`.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how `Either` can be used to handle errors sequentially, and how `Validated`
    can handle errors in parallel. As these two types are very similar, I would advise
    you to use `Validated` most of the time. Instances of `Validated` can indeed handle
    errors in parallel using `mapN`, but they can also perform sequential validation
    using `andThen`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter went a bit further in the way of writing programs in a functional
    way. In the next chapter we will explore other features of the language that you
    will necessarily encounter in typical Scala projects: laziness, covariance and
    contravariance, and implicit.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions to test your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: What type can you use to represent an optional value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type(s) can you use to represent the possibility of an error?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is referential transparency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it good practice to throw exceptions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Write unit tests for `SimulatePlanApp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `RetCalcResult` instead of `Either[RetCalcError, X]` in `RetCalc.scala`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `VariableReturns.fromUntil` to return an error if `monthIdFrom` or `monthIdUntil`
    cannot be found in the returns `Vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cats` documentation on `Either` and `Validated` at the following links
    provides other usage examples, as well as more details on their respective topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://typelevel.org/cats/datatypes/either.html](https://typelevel.org/cats/datatypes/either.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://typelevel.org/cats/datatypes/validated.html](https://typelevel.org/cats/datatypes/validated.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
