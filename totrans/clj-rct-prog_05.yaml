- en: Chapter 5. Creating Your Own CES Framework with core.async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, it was alluded to that `core.async` operates at a lower
    level of abstraction when compared to other frameworks such as RxClojure or RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: This is because most of the time we have to think carefully about the channels
    we are creating as well as what types and sizes of buffers to use, whether we
    need pub/sub functionality, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Not all applications require such level of control, however. Now that we are
    familiar with the motivations and main abstractions of `core.async` we can embark
    into writing a minimal CES framework using `core.async` as the underlying foundation.
  prefs: []
  type: TYPE_NORMAL
- en: By doing so, we avoid having to think about thread pool management as the framework
    takes care of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a CES framework using `core.async` as its underlying concurrency strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an application that uses our CES framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the trade-offs of the different approaches presented so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A minimal CES framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get start on the details, we should define at a high level what *minimal*
    means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the two main abstractions our framework will provide: behaviors
    and event streams.'
  prefs: []
  type: TYPE_NORMAL
- en: If you can recall from [Chapter 1](part0015_split_000.html#page "Chapter 1. What
    is Reactive Programming?"), *What is Reactive Programming?*, behaviors represent
    continuous, time-varying values such as time or a mouse position behavior. Event
    streams, on the other hand, represent discrete occurrences at a point in time
    *T*, such as key press.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should think about what kinds of operations we would like to support.
    Behaviors are fairly simple so at the very minimum we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the current value of a behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert a behavior into an event stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event streams have more interesting logic in play and we should at least support
    these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Push/deliver a value down the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a stream from a given interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform the stream with the `map` and `filter` operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine streams with `flatmap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe to a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a small subset but big enough to demonstrate the overall architecture
    of a CES framework. Once we're done, we'll use it to build a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure or ClojureScript?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we''ll shift gears and add another requirement to our little library:
    it should work both in Clojure and ClojureScript. At first, this might sound like
    a tough requirement. However, remember that `core.async`—the foundation of our
    framework—works both on the JVM and in JavaScript. This means we have a lot less
    work to do to make it happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It does mean, however, that we need to be capable of producing two artifacts
    from our library: a `jar` file and a JavaScript file. Luckily, there are leiningen
    plugins, which help us do that and we will be using a couple of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lein-cljsbuild` (see [https://github.com/emezeske/lein-cljsbuild](https://github.com/emezeske/lein-cljsbuild)):
    Leiningen plugin to make building ClojureScript easy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cljx` (see [https://github.com/lynaghk/cljx](https://github.com/lynaghk/cljx)):
    A preprocessor used to write portable Clojure codebases, that is, write a single
    file and output both `.clj` and `.cljs` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to understand these libraries in great detail. We are only using
    their basic functionality and will be explaining the bits and pieces as we encounter
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by creating a new leiningen project. We''ll call our framework
    respondent—one of the many synonyms for the word reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make a few changes to the `project.clj` file to include the dependencies
    and configurations we''ll be using. First, make sure the project dependencies
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no surprises here. Still in the project file, add the necessary
    plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These are the plugins that we've mentioned previously. By themselves they don't
    do much, however, and need to be configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `cljx`, add the following to the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For example, based on the preceding rules, if we have a file called `src/cljx/core.cljx`
    and we run the preprocessor we will end up with the `target/classes/core.clj`
    and `target/classes/core.cljs` output files. The hooks, on the other hand, are
    simply a convenient way to automatically run `cljx` whenever we start a REPL session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the configuration is for `cljsbuild`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`cljsbuild` provides leiningen tasks to compile Clojuresript source code into
    JavaScript. We know from our preceding `cljx` configuration that the `source.cljs`
    files will be under `target/classes`, so here we''re simply telling `cljsbuild`
    to compile all ClojureScript files in that directory and spit the contents to
    `target/main.js`. This is the last piece needed for the project file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and delete these files created by the leiningen template as we won''t
    be using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new `core.cljx` file under `src/cljx/respondent/` and add the
    following namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start seeing `cljx` annotations. `cljx` is simply a text preprocessor,
    so when it is processing a file using `clj` rules—as seen in the configuration—it
    will keep the `s-`expressions preceded by the annotation `#+clj` in the output
    file, while removing the ones prefixed by `#+cljs`. The reverse process happens
    when using `cljs` rules.
  prefs: []
  type: TYPE_NORMAL
- en: This is necessary because macros need to be compiled on the JVM, so they have
    to be included separately using the `:require-macros` namespace option when using
    ClojureScript. Don't worry about the `core.async` functions we haven't encountered
    before; they will be explained as we use them to build our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note how we are excluding functions from the Clojure standard API as we
    wish to use the same names and don't want any undesired naming collisions.
  prefs: []
  type: TYPE_NORMAL
- en: This section set us up with a new project and the plugins and configurations
    needed for our framework. We're ready to start implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the public API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the requirements for behaviors we agreed on is the ability to turn a
    given behavior into an event stream. A common way of doing this is by sampling
    a behavior at a specific interval. If we take the *mouse position* behavior as
    an example, by sampling it every *x* seconds we get an event stream, which will
    emit the current mouse position at discrete points in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the following protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It has a single function, `sample`, which we described in the preceding code.
    There are more things we need to do with a behavior, but for now this will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next main abstraction is `EventStream`, which—based on the requirements
    seen previously—leads to the following protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a few basic functions to transform and query an event stream.
    It does leave out the ability to subscribe to a stream. Don't worry, I didn't
    forget it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Although, it is common to subscribe to an event stream, the protocol itself
    doesn''t mandate it and this is because the operation fits best in its own protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as subscriptions go, it is useful to have a way of unsubscribing from
    a stream. This can be implemented in a couple of ways, but `docstring` of the
    preceding function hints at a specific one: a token that can be used to unsubscribe
    from a stream. This leads to our last protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Implementing tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The token type is the simplest in the whole framework as it has got a single
    function with a straightforward implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It simply closes whatever channel it is given, stopping events from flowing
    through subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing event streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event stream implementation, on the other hand, is the most complex in our
    framework. We'll tackle it gradually, implementing and experimenting as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at our main constructor function, `event-stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docstring` should be sufficient to understand the public API. What might
    not be clear, however, is what all the constructor arguments mean. From left to
    right, the arguments to `EventStream` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ch`: This is the `core.async` channel backing this stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple`: This is a way to broadcast information from one channel to many
    other channels. It''s a `core.async` concept we will be explaining shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`completed`: A Boolean flag indicating whether this event stream has completed
    and will not emit any new values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the implementation, you can see that the multiple is created from the
    channel backing the stream. `multiple` works kind of like a broadcast. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will make understanding the `EventStream` implementation easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s have a look at what a minimal implementation of the `EventStream`
    looks like the following—make sure the implementation goes before the constructor
    function described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For now, we have chosen to implement only the `map` and `deliver` functions
    from the `IEventStream` protocol. This allows us to deliver values to the stream
    as well as transform those values.
  prefs: []
  type: TYPE_NORMAL
- en: However, this would not be very useful if we could not retrieve the values delivered.
    This is why we also implement the `subscribe` function from the `IObservable`
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, `map` needs to take a value from the input stream, apply a function
    to it, and send it to the newly created stream. We do this by creating an output
    channel that taps on current `multiple`. We then use this channel to back the
    new event stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `deliver` function simply puts the value into the backing channel. If the
    value is the namespaced keyword `::complete`, we update the `completed` atom and
    close the backing channel. This ensures the stream will not emit any other values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `subscribe` function. The way subscribers are notified
    is by using an output channel tapped to backing `multiple`. We loop indefinitely
    calling the subscribing function whenever a new value is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: We finish by returning a token, which will close the output channel once disposed,
    causing the `go-loop` to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that all this makes sense by experimenting with a couple of
    examples in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We have a minimal, working implementation of our `IEventStream` protocol!
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we''ll implement is `filter` and it is very similar to `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that we use the `filter>` function and `pred` should
    be a Boolean function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we witness, `es2` only emits a new value if and only if that value is an
    even number.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are following along, typing the examples step by step, you will need
    to restart your REPL whenever we add new functions to any `deftype` definition.
    This is because `deftype` generates and compiles a Java class when evaluated.
    As such, simply reloading the namespace won't be enough.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use a tool such as `tools.namespace` (see [https://github.com/clojure/tools.namespace](https://github.com/clojure/tools.namespace))
    that addresses some of these REPL reloading limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving down our list, we now have `flatmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve encountered this operator before when surveying Reactive Extensions.
    This is what our docstring says about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Takes a function f from values in s to a new EventStream.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Returns an EventStream containing values from all underlying streams combined.*'
  prefs: []
  type: TYPE_NORMAL
- en: This means `flatmap` needs to combine all the possible event streams into a
    single output event stream. As before, we tap a new channel to the `multiple`
    stream, but then we loop over the output channel, applying `f` to each output
    value.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we saw, `f` itself returns a new event stream, so we simply subscribe
    to it. Whenever the function registered in the subscription gets called, we deliver
    that value to the output event stream, effectively combining all streams into
    a single one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have a function, `range-es`, that receives a number `n` and returns an event
    stream that emits numbers from `0` to `n`. As before, we have a starting stream,
    `es1`, and a transformed stream created with `flatmap`, `es2`.
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the preceding output that the stream created by `range-es` gets
    flattened into `es2` allowing us to receive all values by simply subscribing to
    it once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with single function from `IEventStream` left to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`completed?` simply returns the current value of the `completed` atom. We are
    now ready to implement behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, the `IBehavior` protocol has a single function called `sample`
    whose docstring states: *Turns this Behavior into an EventStream from the sampled
    values at the given interval*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement `sample`, we will first create a useful helper function
    that we will call `from-interval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docstring` function should be clear enough at this stage, but we would
    like to ensure we understand its behavior correctly by trying it at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As expected, `es1` emits integers starting at zero at 500-millisecond intervals.
    By default, it would emit numbers indefinitely; therefore, we keep a reference
    to the token returned by calling `subscribe`.
  prefs: []
  type: TYPE_NORMAL
- en: This way we can dispose it whenever we're done, causing `es-1` to complete and
    stop emitting items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can finally implement the `Behavior` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A behavior is created by passing it a function. You can think of this function
    as a generator responsible for generating the next value in this event stream.
  prefs: []
  type: TYPE_NORMAL
- en: This generator function will be called whenever we (1) `deref` the `Behavior`
    or (2) at the interval given to `sample`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `behavior` macro is there for convenience and allows us to create a new
    `Behavior` without wrapping the body in a function ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we defined `time-behavior` that always contains the
    current system time. We can then turn this behavior into a stream of discrete
    events by using the `sample` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember to keep a reference to the subscription token when dealing with
    infinite streams such as the ones created by `sample` and `from-interval`, or
    else you might incur undesired memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We have a working, minimal CES framework using `core.async`!
  prefs: []
  type: TYPE_NORMAL
- en: We didn't prove it works with ClojureScript, however, which was one of the main
    requirements early on. That's okay. We will be tackling that soon by developing
    a simple ClojureScript application, which makes use of our new framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we need to deploy the framework to our local Maven repository.
    From the project root, type the following `lein` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections have a few exercises for you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extend our current `EventStream` implementation to include a function called
    `take`. It works much like Clojure''s core `take` function for sequences: it will
    take `n` items from the underlying event stream after which it will stop emitting
    items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample interaction, which takes the first five items emitted from the original
    event stream, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping some state might be useful here. Atoms can help. Additionally, try to
    think of a way to dispose of any unwanted subscriptions required by the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will add a function called `zip` that zips together items
    emitted from two different event streams into a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample interaction with the `zip` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this exercise, we need a way to know when we have enough items to emit from
    both event streams. Managing this internal state can be tricky at first. Clojure's
    `ref` types and, in particular, `dosync`, can be of use.
  prefs: []
  type: TYPE_NORMAL
- en: A respondent application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter would not be complete if we didn't go through the whole development
    life cycle of deploying and using the new framework in a new application. This
    is the purpose of this section.
  prefs: []
  type: TYPE_NORMAL
- en: The application we will build is extremely simple. All it does is track the
    position of the mouse using the reactive primitives we built into respondent.
  prefs: []
  type: TYPE_NORMAL
- en: To that end, we will be using the excellent lein template `cljs-start` (see
    [https://github.com/magomimmo/cljs-start](https://github.com/magomimmo/cljs-start)),
    created by Mimmo Cosenza to help developers get started with ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s modify the project file to include the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first dependency is self-explanatory. It's simply our own framework. `dommy`
    is a DOM manipulation library for ClojureScript. We'll briefly use it when building
    our web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `dev-resources/public/index.html` file to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of the puzzle is modifying `src/cljs/respondent_app/core.cljs`
    to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is our main application logic. It creates an event stream to which we deliver
    the current mouse position from the `onmousemove` event of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we simply subscribe to it and use `dommy` to select and set the text
    of the `div` element we added previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to use the app! Let''s start by compiling ClojureScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should take a few seconds. If all is well, the next thing to do is to
    start a REPL session and start up the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, point your browser to `http://localhost:3000/` and drag the mouse around
    to see its current position.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on successfully developing, deploying, and using your own CES
    framework!
  prefs: []
  type: TYPE_NORMAL
- en: CES versus core.async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, you might be wondering when you should choose one approach over
    the other. After all, as demonstrated at the beginning of this chapter, we could
    use `core.async` to do everything we have done using `respondent`.
  prefs: []
  type: TYPE_NORMAL
- en: It all comes down to using the right level of abstraction for the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: '`core.async` gives us many low level primitives that are extremely useful when
    working with processes, which need to talk to each other. The `core.async` channels
    work as concurrent blocking queues and are an excellent synchronization mechanism
    in these scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it makes other solutions harder to implement: for instance, channels
    are single-take by default, so if we have multiple consumers interested in the
    values put inside a channel, we have to implement the distribution ourselves using
    tools such as `mult` and `tap`.'
  prefs: []
  type: TYPE_NORMAL
- en: CES frameworks, on the other hand, operate at a higher level of abstraction
    and work with multiple subscribers by default.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `core.async` relies on side effects, as can be seen by the use
    of functions such as `>!` inside `go` blocks. Frameworks such as RxClojure promote
    stream transformations by the use of pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say there aren't side effects in CES frameworks. There most definitely
    are. However, as a consumer of the library, this is mostly hidden from our eyes,
    allowing us to think of most of our code as simple sequence transformations.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, different application domains will benefit more or less from
    either approach—sometimes they can benefit from both. We should think hard about
    our application domain and analyze the types of solutions and idioms developers
    are most likely to design. This will point us in the direction of better abstraction
    for whatever application we are developing at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed our very own CES framework. By developing our
    own framework, we have solidified our understanding of both CES and how to effectively
    use `core.async`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea that `core.async` could be used as the foundation of a CES framework
    isn't mine, however. James Reeves (see [https://github.com/weavejester](https://github.com/weavejester))—creator
    of the routing library **Compojure** (see [https://github.com/weavejester/compojure](https://github.com/weavejester/compojure))
    and many other useful Clojure libraries—also saw the same potential and set off
    to write **Reagi** (see [https://github.com/weavejester/reagi](https://github.com/weavejester/reagi)),
    a CES library built on top of `core.async`, similar in spirit to the one we developed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: He has put a lot more effort into it, making it a more robust option for a pure
    Clojure framework. We'll be looking at it in the next chapter.
  prefs: []
  type: TYPE_NORMAL
