- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zooming in on the Heap Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18762_02.xhtml#_idTextAnchor038), we discussed the differences
    between references and objects in memory. References and the objects to which
    they refer are closely related. We discovered that Java’s call-by-value mechanism
    could lead to a security issue known as **escaping references**, in addition to
    mutable objects. With the aid of sample code and diagrams, we examined the issues
    and how to resolve them using defensive copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that primitives and references can live on both the stack and the heap,
    whereas objects just live on the heap. Now, we are ready to take a closer look
    at the heap in preparation for the next chapter, which is on **garbage collection**
    (**GC**). In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the different generations on the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how the spaces are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the different generations on the heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The heap space consists of two different memory areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Young generation space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old generation (tenured) space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we will not dive into the **GC** process in this chapter, we need to explain
    what a *live* object is. A live object is one that is reachable from the GC roots.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection roots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A GC root is a special type of live object and is, therefore, not eligible
    for GC. All objects reachable from GC roots are also live and are, therefore,
    not eligible for GC. The GC roots act as starting points in GC, that is, start
    at these roots and mark all objects reachable as *live*. The most common GC roots
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Local variables on the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All active Java threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variables (as these can be referenced by their classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Native Interface** (**JNI**) references – Objects created by the native
    code as part of a JNI call. This is a very special case of GC roots because the
    JVM does not know whether the objects are referenced by the native code or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us examine how the spaces appear in memory, as shown in *Figure 3**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The heap generations](img/Figure_3.1_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The heap generations
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we require brief definitions so that we can discuss how the
    spaces are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Young generation space** – The young generation space, sometimes called the
    **nursery** or **new** space, contains two separate areas: the **eden** space
    and the **survivor** space. Both serve different functions with the overall goal
    to increase memory efficiency. We will discuss them in turn:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eden space**: *New* objects are allocated in the eden space. When the eden
    space is full and there is no room for allocating a new object, the young generation
    (**minor**) garbage collector runs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Survivor space**: There are two equally divided survivor spaces, namely S0
    and S1\. The minor garbage collector uses these regions in an alternate fashion.
    We will explore this in more detail later.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Old generation space** – This is also known as **tenured** space. This is
    where longer-lived objects reside. In other words, the garbage collector moves
    objects that have survived a certain number of GCs here. When the tenured space
    becomes full, this triggers a **major** GC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a brief overview of the spaces, let us examine how they are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how the spaces are used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how these different spaces are used, we will explain them in two
    different stages. Initially, we will examine how the spaces are used in the minor
    GC algorithm. Subsequently, with the aid of an example, we will show the algorithm
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the minor garbage collection algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with the minor GC algorithm. *Figure 3**.2* is high-level pseudocode
    of the minor GC process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Pseudocode of the minor garbage collection algorithm](img/Figure_3.2_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Pseudocode of the minor garbage collection algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine the process outlined in the preceding figure using a *Given-When-Then*
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: **S0** as the target survivor and **S1** as the source survivor
    spaces initially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: Minor garbage collector runs. In other words, the eden space does
    not have enough space for an object that the JVM wishes to allocate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`, as they have just survived their first GC cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S1** is examined and any live objects whose ages meet a given threshold (the
    **tenuring threshold**) are copied to the old generation space, meaning they are
    tenured. In other words, this is a long-lived object, so copy it to the old generation
    area where longer-lived objects reside. This makes future minor GC runs more efficient
    as it ensures these same objects are not re-examined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining live **S1** objects (the ones that were not tenured) are copied
    to **S0**, where their ages are incremented by one, as they have just passed another
    GC cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the tenuring threshold is configurable using a JVM argument, `-XX:MaxTenuringThreshold`.
    In effect, this flag allows you to customize how many GC cycles an object will
    stay in the survivor space before it finally gets tenured into the old space.
    However, care must be exercised with the argument, as a value greater than 15
    specifies that objects should never tenure, thereby indefinitely filling up the
    survivor space with old objects.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.3* shows the process just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Minor garbage collection with S0 as the target space](img/Figure_3.3_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Minor garbage collection with S0 as the target space
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy live eden objects to `1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy old, live **S1** objects to long-generation space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy young, live **S1** objects to **S0** (ages incremented)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the live objects from eden and **S1** have been copied (saved), both
    eden and **S1** can now be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the minor collector runs again, given that `1` set for each object. As
    **S1** is now the target space, **S0** becomes the source space. The garbage collector
    examines **S0** and copies long-lived objects into tenured space and short-lived
    objects into **S1**. *Figure 3**.4* shows this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Minor garbage collection with S1 as the target space](img/Figure_3.4_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Minor garbage collection with S1 as the target space
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: All live eden objects are copied to `1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy old, live **S0** objects to long-generation space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy young, live **S0** objects to **S1** (ages incremented)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that the live objects from eden and **S0** have been copied, both eden
    and **S0** can be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed how the spaces are used, we will enhance our explanation
    with the aid of an example.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating the minor garbage collection algorithm in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 3**.5* shows the situation in memory initially, prior to the first
    run of the minor garbage collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Initial heap state prior to minor garbage collection #1](img/Figure_3.5_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5 – Initial heap state prior to minor garbage collection #1'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, object **H** represents an object that the JVM is
    trying to allocate memory for in the eden space. The eden space consists of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Red objects have no references to them from the GC roots. They are eligible
    for GC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green objects are live objects, meaning they are GC roots or can be reached
    via GC roots. These objects are *not* eligible for GC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White spaces are gaps in the eden space. If there is enough contiguous space
    to allocate the object, then the object is stored in eden, and its reference is
    returned. If, however, due to memory fragmentation, there is not enough contiguous
    space to allocate the object, a minor (young generation) GC is triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The survivor space consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S0** – Empty initially; we will assume that the JVM is using this as the
    target survivor space initially'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S1** – Also empty initially; as **S0** is the target space, **S1** becomes
    the source space (as there is nothing in **S1** initially, this has no effect
    the first time around)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tenured (old generation) space consists of long-lived objects. Long-lived
    objects are objects that have survived a certain predefined number of minor GC.
    This is a customizable threshold value using the `-XX:MaxTenuringThreshold` JVM
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in *Figure 3**.5*, the JVM has a requirement to allocate an object
    **H** but as there is not enough room in eden, this triggers a minor (young generation)
    GC. Objects **A**, **D**, and **G** can be removed from eden, and objects **B**,
    **C**, **E**, and **F** can be moved to **S0**. The eden space is reclaimed and
    object **H** is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.6* shows the heap after the first minor GC has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Heap state post minor garbage collection #1](img/Figure_3.6_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6 – Heap state post minor garbage collection #1'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, object **H** is allocated in eden, and objects **B**,
    **C**, **E**, and **F** in **S0**. Note that the objects in **S0** each have an
    age of **1** as this is their first minor GC to survive.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.7* shows the heap prior to the second minor GC run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Heap state prior to minor garbage collection #2](img/Figure_3.7_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7 – Heap state prior to minor garbage collection #2'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.7*, the JVM is trying to allocate object **N** but there is no
    space for it in eden. This will trigger the minor garbage collector to run (for
    the second time). In the eden space, objects **H**, **L**, and **M** are eligible
    for GC, and objects **I**, **J**, and **K** are live. In the survivor space, **S0**,
    object **B** is now eligible for GC, whereas objects **C**, **E**, and **F** are
    live.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.8* shows the heap after the second minor GC run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Heap state post minor garbage collection #2](img/Figure_3.8_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8 – Heap state post minor garbage collection #2'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.8*, **S1** is now the target survivor space and thus **S0** is
    the source. The garbage collector moves the live objects **C**, **E**, and **F**
    from **S0** to **S1**, incrementing their age values from **1** to **2**. The
    garbage collector then reclaims the **S0** space.
  prefs: []
  type: TYPE_NORMAL
- en: Objects **I**, **J**, and **K** are moved from eden to **S1** with age values
    of **1**, as this is their first time surviving a minor GC. The eden space is
    reclaimed and the object **N** is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to show is objects moving to the tenured space. This is what
    *Figure* *3**.9* demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Objects moving to tenured space](img/Figure_3.9_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Objects moving to tenured space
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.9* represents the heap after 15 minor GC runs. Objects **E** and
    **F** move to tenured space because their age values of **15** have reached the
    threshold (the default threshold value is 15). The next time the minor garbage
    collector runs, both of these objects will not feature, enabling the garbage collector
    to run more efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: Object **X** was the object that triggered the minor garbage collector and,
    for this iteration, **S1** was the source and **S0** the target survivor space.
    Objects **J**, **P**, and **S** are still live and move from **S1** to **S0**
    with age counts of **14**, **8**, and **3**, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we conclude this chapter, it is worth mentioning some other relevant
    JVM flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xms` and `-Xmx` specify the heap’s minimum and maximum sizes, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:NewSize` and `-XX:MaxNewSize` specify the young generation’s minimum and
    maximum sizes, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:SurvivorRatio` specifies the relative sizes of the two survivor spaces
    with respect to the eden space. For example, `-XX: SurvivorRatio=6` sets the ratio
    between eden and a survivor space to `1:6`. In other words, each survivor space
    will be one-sixth the size of eden and therefore, one-eighth the size of the young
    generation (not one-seventh, as there two survivor spaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:NewRatio` expresses the relative size of the new generation with respect
    to the old generation. For example, `-XX:NewRatio=3` sets the ratio between the
    new generation and old generation to `1:3`. This means that the new generation
    (eden plus both survivor spaces) occupies 25% of the heap and the old generation
    occupies the remaining 75%.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:PretenureSizeThreshold` – If an object’s size is greater than the size
    specified by this flag, then the object is tenured immediately, meaning the object
    is allocated straight to the old generation space. The default value is `0`, which
    means no object will be directly allocated to the old generation of the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, keep the young generation space between 25% and 33% of the total
    heap size. This ensures that the old-generation space is always larger. This is
    desirable because full GCs are more expensive than minor ones.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up this chapter. Let us recap the major points.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we zoomed in on the heap space. We started by examining the
    different generations on the heap – namely, the young generation space and the
    old generation (tenured) space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The young generation space is divided into two spaces: the eden and survivor
    spaces. The eden space is where new objects are allocated. The survivor space
    consists of two equally sized spaces, namely S0 and S1\. The minor (young generation)
    garbage collector uses these survivor spaces when reclaiming memory. Minor GC
    is triggered when there is not enough contiguous space to allocate an object in
    the eden space. Using pseudocode and diagrams, we examined how the minor garbage
    collector utilizes the generations and spaces. We then used an example that had
    several use case scenarios to reinforce the concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: The tenured space is where longer-lived objects reside. We saw that if an object
    survives several GC cycles, the object moves to tenured space to make subsequent
    minor GC cycles more efficient. Lastly, we looked at relevant JVM flags.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the heap and have had a high-level overview of the minor
    garbage collector, we are ready to take a deep dive into GC, which is the topic
    of the next chapter.
  prefs: []
  type: TYPE_NORMAL
