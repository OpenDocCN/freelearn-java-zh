- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zooming in on the Heap Space
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18762_02.xhtml#_idTextAnchor038), we discussed the differences
    between references and objects in memory. References and the objects to which
    they refer are closely related. We discovered that Java’s call-by-value mechanism
    could lead to a security issue known as **escaping references**, in addition to
    mutable objects. With the aid of sample code and diagrams, we examined the issues
    and how to resolve them using defensive copying.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that primitives and references can live on both the stack and the heap,
    whereas objects just live on the heap. Now, we are ready to take a closer look
    at the heap in preparation for the next chapter, which is on **garbage collection**
    (**GC**). In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the different generations on the heap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how the spaces are used
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the different generations on the heap
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The heap space consists of two different memory areas:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Young generation space
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old generation (tenured) space.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we will not dive into the **GC** process in this chapter, we need to explain
    what a *live* object is. A live object is one that is reachable from the GC roots.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection roots
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A GC root is a special type of live object and is, therefore, not eligible
    for GC. All objects reachable from GC roots are also live and are, therefore,
    not eligible for GC. The GC roots act as starting points in GC, that is, start
    at these roots and mark all objects reachable as *live*. The most common GC roots
    are the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Local variables on the stack
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All active Java threads
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variables (as these can be referenced by their classes)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Native Interface** (**JNI**) references – Objects created by the native
    code as part of a JNI call. This is a very special case of GC roots because the
    JVM does not know whether the objects are referenced by the native code or not.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us examine how the spaces appear in memory, as shown in *Figure 3**.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The heap generations](img/Figure_3.1_B18762.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The heap generations
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we require brief definitions so that we can discuss how the
    spaces are used:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Young generation space** – The young generation space, sometimes called the
    **nursery** or **new** space, contains two separate areas: the **eden** space
    and the **survivor** space. Both serve different functions with the overall goal
    to increase memory efficiency. We will discuss them in turn:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eden space**: *New* objects are allocated in the eden space. When the eden
    space is full and there is no room for allocating a new object, the young generation
    (**minor**) garbage collector runs.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Survivor space**: There are two equally divided survivor spaces, namely S0
    and S1\. The minor garbage collector uses these regions in an alternate fashion.
    We will explore this in more detail later.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Old generation space** – This is also known as **tenured** space. This is
    where longer-lived objects reside. In other words, the garbage collector moves
    objects that have survived a certain number of GCs here. When the tenured space
    becomes full, this triggers a **major** GC.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**老年代空间** – 这也被称为**晋升**空间。这是长期存在的对象所在的地方。换句话说，垃圾收集器将经过一定数量GC的存活对象移动到这里。当晋升空间满了，这会触发**主要**GC。'
- en: Now that we have a brief overview of the spaces, let us examine how they are
    used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对空间有了简要的了解，让我们来看看它们是如何被使用的。
- en: Learning how the spaces are used
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用这些空间
- en: To understand how these different spaces are used, we will explain them in two
    different stages. Initially, we will examine how the spaces are used in the minor
    GC algorithm. Subsequently, with the aid of an example, we will show the algorithm
    in action.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些不同空间的使用方式，我们将分两个不同阶段来解释。最初，我们将检查在小型GC算法中如何使用这些空间。随后，通过一个示例，我们将展示算法的实际运行。
- en: Understanding the minor garbage collection algorithm
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解小型垃圾回收算法
- en: 'Let us start with the minor GC algorithm. *Figure 3**.2* is high-level pseudocode
    of the minor GC process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从小型GC算法开始。*图3**.2*是小型GC过程的高级伪代码：
- en: '![Figure 3.2 – Pseudocode of the minor garbage collection algorithm](img/Figure_3.2_B18762.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 小型垃圾回收算法的伪代码](img/Figure_3.2_B18762.jpg)'
- en: Figure 3.2 – Pseudocode of the minor garbage collection algorithm
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 小型垃圾回收算法的伪代码
- en: Let us examine the process outlined in the preceding figure using a *Given-When-Then*
    scenario.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个*给定-当-然后*场景来检查前面图中概述的过程。
- en: '**Given**: **S0** as the target survivor and **S1** as the source survivor
    spaces initially.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定**：**S0**作为目标幸存者空间和**S1**作为初始源幸存者空间。'
- en: '**When**: Minor garbage collector runs. In other words, the eden space does
    not have enough space for an object that the JVM wishes to allocate.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**：运行小型垃圾回收器。换句话说，eden空间没有足够的空间来分配JVM希望分配的对象。'
- en: '`1`, as they have just survived their first GC cycle.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`，因为它们刚刚度过了它们的第一轮GC周期。'
- en: '**S1** is examined and any live objects whose ages meet a given threshold (the
    **tenuring threshold**) are copied to the old generation space, meaning they are
    tenured. In other words, this is a long-lived object, so copy it to the old generation
    area where longer-lived objects reside. This makes future minor GC runs more efficient
    as it ensures these same objects are not re-examined.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S1**被检查，并且任何年龄达到给定阈值（**晋升阈值**）的存活对象被复制到老年代空间，这意味着它们已经晋升。换句话说，这是一个长期存在的对象，所以将其复制到老年代区域，那里有更长时间存在的对象。这使得未来的小型GC运行更加高效，因为它确保这些相同的对象不会被重新检查。'
- en: The remaining live **S1** objects (the ones that were not tenured) are copied
    to **S0**, where their ages are incremented by one, as they have just passed another
    GC cycle.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的存活**S1**对象（那些没有晋升的对象）被复制到**S0**，它们的年龄增加一个，因为它们刚刚通过了另一个GC周期。
- en: Note that the tenuring threshold is configurable using a JVM argument, `-XX:MaxTenuringThreshold`.
    In effect, this flag allows you to customize how many GC cycles an object will
    stay in the survivor space before it finally gets tenured into the old space.
    However, care must be exercised with the argument, as a value greater than 15
    specifies that objects should never tenure, thereby indefinitely filling up the
    survivor space with old objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用JVM参数`-XX:MaxTenuringThreshold`可以配置晋升阈值。实际上，这个标志允许您自定义对象在最终晋升到老年代之前将在幸存者空间中停留多少次GC周期。然而，在使用此参数时必须谨慎，因为大于15的值指定对象永远不会晋升，从而无限期地用旧对象填满幸存者空间。
- en: '*Figure 3**.3* shows the process just discussed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3**.3*显示了刚刚讨论的过程：'
- en: '![Figure 3.3 – Minor garbage collection with S0 as the target space](img/Figure_3.3_B18762.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 以S0为目标空间的小型垃圾回收](img/Figure_3.3_B18762.jpg)'
- en: Figure 3.3 – Minor garbage collection with S0 as the target space
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 以S0为目标空间的小型垃圾回收
- en: 'Here is a summary:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个总结：
- en: Copy live eden objects to `1`)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实时eden对象复制到`1`
- en: Copy old, live **S1** objects to long-generation space
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将旧的存活**S1**对象复制到长生存空间
- en: Copy young, live **S1** objects to **S0** (ages incremented)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将年轻的存活**S1**对象复制到**S0**（年龄增加）
- en: Now that the live objects from eden and **S1** have been copied (saved), both
    eden and **S1** can now be reclaimed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在eden和**S1**中的存活对象已经被复制（保存），现在eden和**S1**都可以被回收。
- en: 'When the minor collector runs again, given that `1` set for each object. As
    **S1** is now the target space, **S0** becomes the source space. The garbage collector
    examines **S0** and copies long-lived objects into tenured space and short-lived
    objects into **S1**. *Figure 3**.4* shows this process:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当小回收器再次运行时，每个对象有`1`个集合。由于**S1**现在是目标空间，**S0**成为源空间。垃圾收集器检查**S0**并将长寿对象复制到持久代空间，将短寿对象复制到**S1**。*图3.4*显示了此过程：
- en: '![Figure 3.4 – Minor garbage collection with S1 as the target space](img/Figure_3.4_B18762.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 以S1为目标空间的小型垃圾收集](img/Figure_3.4_B18762.jpg)'
- en: Figure 3.4 – Minor garbage collection with S1 as the target space
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 以S1为目标空间的小型垃圾收集
- en: 'Here is a summary:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个总结：
- en: All live eden objects are copied to `1`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的活动eden对象都被复制到`1`）
- en: Copy old, live **S0** objects to long-generation space
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制老、活动的**S0**对象到长生存空间
- en: Copy young, live **S0** objects to **S1** (ages incremented)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制年轻、活动的**S0**对象到**S1**（年龄增加）
- en: Given that the live objects from eden and **S0** have been copied, both eden
    and **S0** can be reclaimed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于eden和**S0**中的活动对象已被复制，因此eden和**S0**都可以被回收。
- en: Now that we have discussed how the spaces are used, we will enhance our explanation
    with the aid of an example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了空间的使用方式，我们将通过一个例子来增强我们的解释。
- en: Demonstrating the minor garbage collection algorithm in action
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示小垃圾收集算法的实际操作
- en: '*Figure 3**.5* shows the situation in memory initially, prior to the first
    run of the minor garbage collector:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.5*显示了在第一次小垃圾收集器运行之前内存中的情况：'
- en: '![Figure 3.5 – Initial heap state prior to minor garbage collection #1](img/Figure_3.5_B18762.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 小型垃圾收集第1次之前的初始堆状态 #1](img/Figure_3.5_B18762.jpg)'
- en: 'Figure 3.5 – Initial heap state prior to minor garbage collection #1'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 小型垃圾收集第1次之前的初始堆状态
- en: 'In the preceding figure, object **H** represents an object that the JVM is
    trying to allocate memory for in the eden space. The eden space consists of the
    following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，对象**H**代表JVM试图在eden空间为其分配内存的对象。eden空间包括以下内容：
- en: Red objects have no references to them from the GC roots. They are eligible
    for GC.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色对象没有来自GC根的引用。它们符合GC的条件。
- en: Green objects are live objects, meaning they are GC roots or can be reached
    via GC roots. These objects are *not* eligible for GC.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色对象是活动对象，意味着它们是GC根或者可以通过GC根访问。这些对象**不**符合GC的条件。
- en: White spaces are gaps in the eden space. If there is enough contiguous space
    to allocate the object, then the object is stored in eden, and its reference is
    returned. If, however, due to memory fragmentation, there is not enough contiguous
    space to allocate the object, a minor (young generation) GC is triggered.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白色空间是eden空间中的间隙。如果有足够的连续空间来分配对象，则对象存储在eden中，并返回其引用。然而，如果由于内存碎片化，没有足够的连续空间来分配对象，则会触发小（年轻代）GC。
- en: 'The survivor space consists of the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存活空间包括以下内容：
- en: '**S0** – Empty initially; we will assume that the JVM is using this as the
    target survivor space initially'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S0** – 初始为空；我们将假设JVM最初使用它作为目标存活空间'
- en: '**S1** – Also empty initially; as **S0** is the target space, **S1** becomes
    the source space (as there is nothing in **S1** initially, this has no effect
    the first time around)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S1** – 初始也为空；由于**S0**是目标空间，**S1**成为源空间（由于**S1**最初没有内容，这第一次没有影响）'
- en: The tenured (old generation) space consists of long-lived objects. Long-lived
    objects are objects that have survived a certain predefined number of minor GC.
    This is a customizable threshold value using the `-XX:MaxTenuringThreshold` JVM
    argument.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 持久代（老年代）空间包括长寿对象。长寿对象是经过一定预定义数量的次要GC后存活的对象。这是一个可以通过`-XX:MaxTenuringThreshold`
    JVM参数自定义的阈值值。
- en: As can be seen in *Figure 3**.5*, the JVM has a requirement to allocate an object
    **H** but as there is not enough room in eden, this triggers a minor (young generation)
    GC. Objects **A**, **D**, and **G** can be removed from eden, and objects **B**,
    **C**, **E**, and **F** can be moved to **S0**. The eden space is reclaimed and
    object **H** is allocated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.5*所示，JVM需要分配对象**H**，但由于eden空间不足，这触发了小（年轻代）GC。对象**A**、**D**和**G**可以从eden中移除，而对象**B**、**C**、**E**和**F**可以移动到**S0**。eden空间被回收，对象**H**被分配。
- en: '*Figure 3**.6* shows the heap after the first minor GC has finished:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.6*显示了第一次小GC完成后的堆状态：'
- en: '![Figure 3.6 – Heap state post minor garbage collection #1](img/Figure_3.6_B18762.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 小型垃圾收集第1次之后的堆状态](img/Figure_3.6_B18762.jpg)'
- en: 'Figure 3.6 – Heap state post minor garbage collection #1'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, object **H** is allocated in eden, and objects **B**,
    **C**, **E**, and **F** in **S0**. Note that the objects in **S0** each have an
    age of **1** as this is their first minor GC to survive.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.7* shows the heap prior to the second minor GC run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Heap state prior to minor garbage collection #2](img/Figure_3.7_B18762.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7 – Heap state prior to minor garbage collection #2'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.7*, the JVM is trying to allocate object **N** but there is no
    space for it in eden. This will trigger the minor garbage collector to run (for
    the second time). In the eden space, objects **H**, **L**, and **M** are eligible
    for GC, and objects **I**, **J**, and **K** are live. In the survivor space, **S0**,
    object **B** is now eligible for GC, whereas objects **C**, **E**, and **F** are
    live.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.8* shows the heap after the second minor GC run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Heap state post minor garbage collection #2](img/Figure_3.8_B18762.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8 – Heap state post minor garbage collection #2'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.8*, **S1** is now the target survivor space and thus **S0** is
    the source. The garbage collector moves the live objects **C**, **E**, and **F**
    from **S0** to **S1**, incrementing their age values from **1** to **2**. The
    garbage collector then reclaims the **S0** space.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Objects **I**, **J**, and **K** are moved from eden to **S1** with age values
    of **1**, as this is their first time surviving a minor GC. The eden space is
    reclaimed and the object **N** is allocated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to show is objects moving to the tenured space. This is what
    *Figure* *3**.9* demonstrates:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Objects moving to tenured space](img/Figure_3.9_B18762.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Objects moving to tenured space
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.9* represents the heap after 15 minor GC runs. Objects **E** and
    **F** move to tenured space because their age values of **15** have reached the
    threshold (the default threshold value is 15). The next time the minor garbage
    collector runs, both of these objects will not feature, enabling the garbage collector
    to run more efficiently.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Object **X** was the object that triggered the minor garbage collector and,
    for this iteration, **S1** was the source and **S0** the target survivor space.
    Objects **J**, **P**, and **S** are still live and move from **S1** to **S0**
    with age counts of **14**, **8**, and **3**, respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we conclude this chapter, it is worth mentioning some other relevant
    JVM flags:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xms` and `-Xmx` specify the heap’s minimum and maximum sizes, respectively.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:NewSize` and `-XX:MaxNewSize` specify the young generation’s minimum and
    maximum sizes, respectively.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:SurvivorRatio` specifies the relative sizes of the two survivor spaces
    with respect to the eden space. For example, `-XX: SurvivorRatio=6` sets the ratio
    between eden and a survivor space to `1:6`. In other words, each survivor space
    will be one-sixth the size of eden and therefore, one-eighth the size of the young
    generation (not one-seventh, as there two survivor spaces).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:SurvivorRatio` 指定两个幸存空间相对于eden空间的大小比例。例如，`-XX:SurvivorRatio=6` 将eden和一个幸存空间之间的比例设置为
    `1:6`。换句话说，每个幸存空间将是eden的六分之一大小，因此是年轻代（不是七分之一，因为有两个幸存空间）的八分之一。'
- en: '`-XX:NewRatio` expresses the relative size of the new generation with respect
    to the old generation. For example, `-XX:NewRatio=3` sets the ratio between the
    new generation and old generation to `1:3`. This means that the new generation
    (eden plus both survivor spaces) occupies 25% of the heap and the old generation
    occupies the remaining 75%.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:NewRatio` 表示新年代相对于老年代的大小比例。例如，`-XX:NewRatio=3` 将新年代和老年代之间的比例设置为 `1:3`。这意味着新年代（包括eden和两个幸存空间）占堆的25%，而老年代占剩余的75%。'
- en: '`-XX:PretenureSizeThreshold` – If an object’s size is greater than the size
    specified by this flag, then the object is tenured immediately, meaning the object
    is allocated straight to the old generation space. The default value is `0`, which
    means no object will be directly allocated to the old generation of the heap.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:PretenureSizeThreshold` – 如果一个对象的大小大于此标志指定的值，则该对象将立即晋升到老年代，这意味着对象直接分配到老年代空间。默认值是
    `0`，这意味着没有对象将直接分配到堆的老年代。'
- en: In general, keep the young generation space between 25% and 33% of the total
    heap size. This ensures that the old-generation space is always larger. This is
    desirable because full GCs are more expensive than minor ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，保持年轻代空间在总堆大小的25%到33%之间。这确保了老年代空间始终更大。这是可取的，因为完全垃圾回收（full GCs）比部分垃圾回收（minor
    ones）更昂贵。
- en: That wraps up this chapter. Let us recap the major points.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容到此结束。让我们回顾一下主要要点。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we zoomed in on the heap space. We started by examining the
    different generations on the heap – namely, the young generation space and the
    old generation (tenured) space.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们聚焦于堆空间。我们首先检查堆上的不同代，即年轻代空间和老年代（晋升）空间。
- en: 'The young generation space is divided into two spaces: the eden and survivor
    spaces. The eden space is where new objects are allocated. The survivor space
    consists of two equally sized spaces, namely S0 and S1\. The minor (young generation)
    garbage collector uses these survivor spaces when reclaiming memory. Minor GC
    is triggered when there is not enough contiguous space to allocate an object in
    the eden space. Using pseudocode and diagrams, we examined how the minor garbage
    collector utilizes the generations and spaces. We then used an example that had
    several use case scenarios to reinforce the concepts.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 年轻代空间分为两个空间：eden空间和幸存空间。eden空间是新对象分配的地方。幸存空间由两个大小相等的空间组成，即S0和S1。在回收内存时，小（年轻代）垃圾回收器使用这些幸存空间。当eden空间中没有足够的连续空间来分配对象时，会触发小垃圾回收。我们使用伪代码和图表来检查小垃圾回收器如何利用代和空间。然后，我们使用具有几个用例场景的示例来加强这些概念。
- en: The tenured space is where longer-lived objects reside. We saw that if an object
    survives several GC cycles, the object moves to tenured space to make subsequent
    minor GC cycles more efficient. Lastly, we looked at relevant JVM flags.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 晋升空间是长期存活对象所在的地方。我们看到了如果一个对象在几个垃圾回收周期中存活下来，该对象将移动到晋升空间，以使后续的小垃圾回收周期更高效。最后，我们查看相关的JVM标志。
- en: Now that we understand the heap and have had a high-level overview of the minor
    garbage collector, we are ready to take a deep dive into GC, which is the topic
    of the next chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了堆，并对小垃圾回收器有了高级概述，我们准备深入探讨垃圾回收（GC），这是下一章的主题。
