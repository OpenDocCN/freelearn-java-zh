- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Mastering Concurrency Patterns in Cloud Computing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握云计算中的并发模式
- en: Mastering concurrency is crucial for unlocking the full potential of cloud computing.
    This chapter equips you with the knowledge and skills required to leverage concurrency
    patterns, the cornerstones of building high-performance, resilient, and scalable
    cloud applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握并发对于释放云计算的全部潜力至关重要。本章为你提供了利用并发模式的知识和技能，这些模式是构建高性能、健壮和可伸缩云应用的基础。
- en: These patterns are more than just theory. They empower you to harness the distributed
    nature of cloud resources, ensuring smooth operation under high loads and a seamless
    user experience. Leader-Follower, Circuit Breaker, and Bulkhead are indeed fundamental
    design patterns that serve as essential building blocks for robust cloud systems.
    They provide a strong foundation for understanding how to achieve high availability,
    fault tolerance, and scalability. We’ll explore these core patterns, which are
    designed to address challenges such as network latency and failures. While there
    are many other patterns beyond these three, these chosen patterns serve as a solid
    starting point for mastering concurrency in cloud computing. They provide a basis
    for understanding the principles and techniques that can be applied to a wide
    range of cloud architectures and scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式不仅仅是理论。它们赋予你利用云资源分布式特性的能力，确保在高负载下平稳运行和无缝的用户体验。领导者-追随者、断路器和舱壁确实是基本的设计模式，它们是构建强大云系统的基础构件。它们为理解如何实现高可用性、容错性和可伸缩性提供了坚实的基础。我们将探讨这些核心模式，它们旨在解决网络延迟和故障等挑战。虽然还有许多其他模式，但这些选定的模式为掌握云计算中的并发提供了一个坚实的起点。它们为理解可以应用于广泛云架构和场景的原则和技术提供了基础。
- en: We’ll then delve into patterns for asynchronous operations and distributed communication,
    including Producer-Consumer, Scatter-Gather, and Disruptor. The true power lies
    in combining these patterns strategically. We’ll explore techniques for integrating
    and blending patterns to achieve synergistic effects, boosting both performance
    and resilience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将深入探讨异步操作和分布式通信的模式，包括生产者-消费者、分散-聚集和破坏者。真正的力量在于战略性地结合这些模式。我们将探讨整合和融合模式以实现协同效应的技术，从而提高性能和弹性。
- en: By the end of this chapter, you’ll be equipped to design and implement cloud
    applications that excel at handling concurrent requests, are resilient to failures,
    and effortlessly scale to meet growing demands. We’ll conclude with practical
    implementation strategies to solidify your learning and encourage further exploration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够设计和实现能够出色处理并发请求、对故障具有弹性且能够轻松扩展以满足增长需求的云应用。我们将以实际实施策略来巩固你的学习并鼓励进一步探索。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Package and run a Java class as an AWS Lambda function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 类打包并作为 AWS Lambda 函数运行。
- en: 'First, prepare your Java class:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，准备你的 Java 类：
- en: Ensure your class implements the `RequestHandler<Input, Output>` interface from
    the `com.amazonaws:aws-lambda-java-core` library. This defines the handler method
    that processes events.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的类实现了来自 `com.amazonaws:aws-lambda-java-core` 库的 `RequestHandler<Input, Output>`
    接口。这定义了处理事件的处理器方法。
- en: 'Include any necessary dependencies in your `pom.xml` file (if you’re using
    Maven):'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `pom.xml` 文件中包含任何必要的依赖项（如果你使用 Maven）：
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be sure to replace `1.2.x` with the latest compatible version of the `aws-lambda-java-core`
    library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将 `1.2.x` 替换为 `aws-lambda-java-core` 库的最新兼容版本。
- en: 'Then, package your code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打包你的代码：
- en: Create a JAR file containing your compiled Java class and all its dependencies.
    You can use a tool such as Maven or a simple command such as `jar cvf myLambdaFunction.jar
    target/classes/*.class` (assuming compiled classes are in target/classes).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含编译后的 Java 类及其所有依赖项的 JAR 文件。你可以使用 Maven 这样的工具，或者使用简单的命令，例如 `jar cvf myLambdaFunction.jar
    target/classes/*.class`（假设编译后的类在 target/classes 中）。
- en: 'Create a Lambda function in AWS:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 中创建一个 Lambda 函数：
- en: Go to the AWS Lambda console and click **Create function**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 AWS Lambda 控制台并点击**创建函数**。
- en: Choose **Author from scratch** and select **Java 11** or a compatible runtime
    for your code.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**从头开始创建**并选择适用于你的代码的**Java 11**或兼容运行时。
- en: Provide a name for your function and choose **Upload** for the code source.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的函数提供一个名称，并选择**上传**作为代码源。
- en: Upload your JAR file in the **Code entry** **type** section.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**代码输入****类型**部分上传你的 JAR 文件。
- en: Configure your function’s memory allocation, timeout, and other settings as
    needed.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要配置您的函数内存分配、超时和其他设置。
- en: Click **Create function**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建函数**。
- en: 'Test your function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的函数：
- en: In the Lambda console, navigate to your newly created function.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lambda 控制台中，导航到您新创建的函数。
- en: Click on **Test** and provide a sample event payload (if applicable).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试**并提供一个示例事件有效负载（如果适用）。
- en: Click on **Invoke** to run your function with the provided test event.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**调用**以使用提供的测试事件运行您的函数。
- en: The Lambda console will display the output or error message returned by your
    function’s handler method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 控制台将显示您的函数处理方法返回的输出或错误消息。
- en: 'For a more comprehensive guide with screenshots and additional details, you
    can refer to the official AWS documentation on deploying Java Lambda functions:
    [https://docs.aws.amazon.com/lambda/latest/dg/java-package.html](https://docs.aws.amazon.com/lambda/latest/dg/java-package.html)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取带有截图和额外细节的更全面指南，您可以参考官方 AWS 文档中关于部署 Java Lambda 函数的内容：[https://docs.aws.amazon.com/lambda/latest/dg/java-package.html](https://docs.aws.amazon.com/lambda/latest/dg/java-package.html)
- en: This documentation provides step-by-step instructions on packaging your code,
    creating a deployment package, and configuring your Lambda function in the AWS
    console. It also covers additional topics such as environment variables, logging,
    and handling errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档提供了打包您的代码、创建部署包以及在 AWS 控制台中配置您的 Lambda 函数的逐步说明。它还涵盖了环境变量、日志记录和错误处理等附加主题。
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Core patterns for robust cloud foundations
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坚固云基础的核心模式
- en: In this section, we delve into the foundational design patterns that are essential
    for building resilient, scalable, and efficient cloud-based applications. These
    patterns provide the architectural groundwork necessary to address common challenges
    in cloud computing, including system failures, resource contention, and service
    dependencies. Specifically, we will explore the Leader-Follower pattern, the Circuit
    Breaker pattern, and the Bulkhead pattern, each offering unique strategies to
    enhance fault tolerance, system reliability, and service isolation in the dynamic
    environment of cloud computing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究对于构建弹性、可伸缩和高效云应用程序至关重要的基础设计模式。这些模式提供了必要的架构基础，以解决云计算中的常见挑战，包括系统故障、资源竞争和服务依赖。具体来说，我们将探讨领导者-跟随者模式、断路器模式和安全舱模式，每种模式都提供独特的策略来增强容错性、系统可靠性和服务隔离性，以适应云计算的动态环境。
- en: The Leader-Follower pattern
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领导者-跟随者模式
- en: The **Leader-Follower** pattern is a concurrency design pattern that’s particularly
    suited to distributed systems where tasks are dynamically allocated to multiple
    worker units. This pattern helps manage resources and tasks efficiently by organizing
    the worker units into a leader and multiple followers. The leader is responsible
    for monitoring and delegating work, while the followers wait to become leaders
    or to execute tasks assigned to them. This role-switching mechanism ensures that
    at any given time, one unit is designated to handle task distribution and management,
    optimizing resource utilization, and improving system scalability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**领导者-跟随者**模式是一种并发设计模式，特别适用于任务动态分配给多个工作单元的分布式系统。该模式通过将工作单元组织成一个领导者及其多个跟随者来有效地管理和分配资源与任务。领导者负责监控和委派工作，而跟随者则等待成为领导者或执行分配给他们的任务。这种角色切换机制确保在任何给定时间，都有一个单元被指定来处理任务分配和管理，优化资源利用，并提高系统可伸缩性。'
- en: 'In distributed systems, efficient task management is key. The Leader-Follower
    pattern addresses this in the following ways:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，有效的任务管理是关键。领导者-跟随者模式以下列方式解决此问题：
- en: '**Maximizing resource usage**: The pattern minimizes idle time by always assigning
    tasks to available workers.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大化资源使用**：该模式通过始终将任务分配给可用的工人来最小化空闲时间。'
- en: '**Streamlining distribution**: A single leader handles task allocation, simplifying
    the process and reducing overhead.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化分发**：单个领导者处理任务分配，简化流程并减少开销。'
- en: '**Enabling easy scaling**: You can seamlessly add more follower threads to
    handle increased workloads without significantly altering the system’s logic.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现轻松扩展**：您可以无缝地添加更多跟随者线程来处理增加的工作负载，而无需显著改变系统的逻辑。'
- en: '**Promoting fault tolerance**: If the leader fails, a follower can take its
    place, ensuring system continuity.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高容错性**：如果领导者失败，跟随者可以取代其位置，确保系统连续性。'
- en: '**Enhancing uptime and availability**: The Leader-Follower pattern improves
    system uptime and availability by efficiently distributing and processing tasks.
    Dynamic task allocation to available followers minimizes the impact of individual
    worker failures. If a follower becomes unresponsive, the leader can quickly reassign
    the task, reducing downtime. Moreover, promoting a follower to a leader role in
    case of leader failure enhances the system’s resilience and availability. This
    fault-tolerant characteristic contributes to higher levels of uptime and availability
    in distributed systems.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可用性和正常运行时间**：领导者-跟随者模式通过有效地分配和处理任务来提高系统的可用性和正常运行时间。将动态任务分配给可用的跟随者可以最小化单个工作者失败的影响。如果跟随者变得无响应，领导者可以快速重新分配任务，减少停机时间。此外，在领导者失败的情况下提升跟随者为领导者角色，增强了系统的弹性和可用性。这种容错特性有助于提高分布式系统中的正常运行时间和可用性水平。'
- en: To illustrate the Leader-Follower pattern in Java, we focus on its use for task
    delegation and coordination through a simplified code example. This pattern involves
    a central Leader that assigns tasks to a pool of Followers, effectively managing
    task execution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Java中的领导者-跟随者模式，我们关注其通过简化的代码示例用于任务委派和协调。这种模式涉及一个中央领导者，它将任务分配给一组跟随者，从而有效地管理任务执行。
- en: 'The following is a simplified code snippet (key elements; for the full code,
    please refer to the GitHub repository accompanying this title):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化的代码片段（关键元素；完整代码请参阅此标题所附的GitHub仓库）：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the code explanation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码解释：
- en: '`Task` interface: This defines the contract for the work units. Any class implementing
    this interface must have an `execute()` method that performs the actual work.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`接口：此接口定义了工作单元的合同。任何实现此接口的类都必须有一个`execute()`方法，该方法执行实际工作。'
- en: '`TaskQueue`: This class manages a queue of tasks using `BlockingQueue` for
    thread safety. `addTask()` allows the addition of tasks to the queue, and `getTask()`
    retrieves tasks for processing.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskQueue`：此类使用`BlockingQueue`来管理任务队列，以确保线程安全。`addTask()`允许将任务添加到队列中，而`getTask()`用于检索待处理任务。'
- en: '`LeaderThread`: This thread continuously retrieves tasks from the queue using
    `getTask()`. It then iterates through the list of followers and assigns the task
    to the first available Follower.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeaderThread`：此线程使用`getTask()`方法从队列中持续检索任务。然后，它遍历跟随者列表，并将任务分配给第一个可用的跟随者。'
- en: '`FollowerThread`: This thread processes tasks and signals its availability
    to the leader. The `isAvailable()` method allows the leader to check if a follower
    is ready for new work.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FollowerThread`：此线程处理任务，并向领导者信号其可用性。`isAvailable()`方法允许领导者检查跟随者是否准备好接受新工作。'
- en: This overview encapsulates the Leader-Follower pattern’s core logic. For a detailed
    exploration and the complete code, visit the GitHub repository accompanying this
    book. There, you’ll find extended functionalities and customization options, enabling
    you to tailor the implementation to your specific needs, such as electing a new
    leader or prioritizing urgent tasks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概述封装了领导者-跟随者模式的核心逻辑。要详细了解和获取完整代码，请访问此书所附的GitHub仓库。在那里，你可以找到扩展功能和定制选项，使你能够根据特定需求调整实现，例如选举新的领导者或优先处理紧急任务。
- en: Remember, this example serves as a foundation. You’re encouraged to expand upon
    it, integrating features such as dynamic leader election, task prioritization,
    and progress monitoring to build a robust task management system suited to your
    application’s requirements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个示例只是一个基础。我们鼓励你在此基础上扩展，集成动态领导者选举、任务优先级和进度监控等功能，以构建适合你应用程序需求的强大任务管理系统。
- en: Next, in *The Leader-Follower pattern in action*, we’ll see how this pattern
    empowers different real-world applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*行动中的领导者-跟随者模式*中，我们将看到这种模式如何赋予不同的实际应用以力量。
- en: The Leader-Follower pattern in action
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动中的领导者-跟随者模式
- en: 'The Leader-Follower pattern offers flexibility and adaptability for various
    distributed systems scenarios, particularly in cloud computing environments. Here
    are a few key use cases where it excels:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者-跟随者模式为各种分布式系统场景提供了灵活性和适应性，尤其是在云计算环境中。以下是一些它表现优异的关键用例：
- en: '**Scaling a cloud-based image processing service**: Imagine a service receiving
    numerous image manipulation requests. The leader thread monitors incoming requests,
    delegating them to available follower threads (worker servers). This distributes
    the workload, reduces bottlenecks, and improves response times.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展基于云的图像处理服务**：想象一个接收大量图像处理请求的服务。领导线程监控传入的请求，并将它们委派给可用的跟随线程（工作服务器）。这分配了工作负载，减少了瓶颈，并提高了响应时间。'
- en: '**Real-time data stream processing**: In applications handling continuous streams
    of data (e.g., sensor readings and financial transactions), a leader thread can
    receive incoming data and distribute it among follower threads for analysis and
    processing. This parallelization enables real-time insights by maximizing resource
    utilization.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据流处理**：在处理连续数据流的应用程序中（例如，传感器读数和金融交易），领导线程可以接收传入的数据并将其分配给跟随线程进行分析和处理。这种并行化通过最大化资源利用率实现了实时洞察。'
- en: '**Distributed job scheduling**: For systems with various computational tasks
    (e.g., scientific simulations and machine learning models), the Leader-Follower
    pattern promotes efficient distribution of these jobs across a cluster of machines.
    The leader coordinates task assignments based on resource availability, accelerating
    complex executions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式作业调度**：对于具有各种计算任务（例如，科学模拟和机器学习模型）的系统，领导-跟随模式促进了这些作业在机器集群中的有效分配。领导者根据资源可用性协调任务分配，加速复杂执行。'
- en: '**Work queue management**: In applications with unpredictable bursts of activity
    (e.g., e-commerce order processing), a leader thread can manage a central work
    queue and delegate tasks to follower threads as they become available. This design
    promotes responsiveness and optimizes resource usage during peak activity.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作队列管理**：在具有不可预测活动突发的应用程序中（例如，电子商务订单处理），领导线程可以管理中央工作队列，并在可用时将任务委派给跟随线程。这种设计促进了响应性，并在高峰活动期间优化了资源使用。'
- en: The Leader-Follower pattern’s core advantage lies in its ability to distribute
    workloads across multiple threads or processes. This distribution increases efficiency
    and scalability and is highly beneficial in cloud-based environments where resources
    can be scaled dynamically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 领导-跟随模式的核心理念在于其能够在多个线程或进程中分配工作负载。这种分配提高了效率和可扩展性，在资源可以动态扩展的云环境中非常有用。
- en: Picture our distributed system as a complex machine. The Leader-Follower pattern
    helps it run smoothly. But, like with any machine, parts can malfunction. The
    Circuit Breaker acts like a safety switch, preventing a single faulty component
    from bringing down the entire system. Let’s see how this protective mechanism
    operates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的分布式系统想象成一个复杂的机器。领导-跟随模式帮助它平稳运行。但是，就像任何机器一样，部分可能会出现故障。电路断路器就像一个安全开关，防止单个故障组件导致整个系统崩溃。让我们看看这个保护机制是如何运作的。
- en: The Circuit Breaker pattern – building resilience in cloud applications
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路断路器模式——在云应用程序中构建弹性
- en: Think of the Circuit Breaker pattern like its electrical counterpart—it prevents
    cascading failures in your distributed system. In cloud applications, where services
    rely on remote components, the **Circuit Breaker** pattern safeguards against
    the ripple effects of failing dependencies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将电路断路器模式想象成它的电气对应物——它防止了分布式系统中的级联故障。在云应用程序中，服务依赖于远程组件，**电路断路器**模式保护免受失败依赖的连锁反应。
- en: How it works? The Circuit Breaker monitors failures when calling a remote service.
    Once a failure threshold is crossed, the circuit *trips*. Tripping means calls
    to the remote service are blocked for a set amount of time. This timeout allows
    the remote service a chance to recover. During the timeout, your application can
    gracefully handle the error or use a fallback strategy. After the timeout, the
    circuit transitions to *half-open*, testing the service’s health with a limited
    number of requests. If those succeed, normal operation resumes; if they fail,
    the circuit reopens, and the timeout cycle begins again.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？电路断路器在调用远程服务时监控故障。一旦超过故障阈值，电路就会*跳闸*。跳闸意味着对远程服务的调用将被阻塞一段时间。这个超时允许远程服务有机会恢复。在超时期间，你的应用程序可以优雅地处理错误或使用回退策略。超时后，电路进入*半开*状态，通过有限数量的请求测试服务的健康状态。如果这些请求成功，则恢复正常操作；如果失败，电路重新打开，超时周期再次开始。
- en: 'Let’s look at the following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图示：
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| Closed | ------> | Open | ------> | Half-Open |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 关闭 | ------> | 开启 | ------> | 半开 |'
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| (Failure) | | (Success) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| （失败）| | （成功）|'
- en: v v v v
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: v v v v
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| Business as Usual | | Calls Blocked | | Probe Service |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 正常业务 | | 调用被阻塞 | | 探测服务 |'
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| (Timeout) | | (Failure) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| （超时）| | （失败）|'
- en: v v v v
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: v v v v
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: 'Figure 5.1: States of the Circuit Breaker'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：电路断路器状态
- en: 'The Circuit Breaker has three states:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器有三个状态：
- en: '**Closed**: This is the initial state. Calls to the service are allowed to
    flow through (business as usual).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：这是初始状态。对服务的调用允许正常流动（正常业务）。'
- en: '**Open**: This state is reached if the error threshold is hit (consecutive
    failures). Calls to the service are blocked, preventing further failures and giving
    the service time to recover.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启**：如果达到错误阈值（连续失败），则达到此状态。对服务的调用被阻止，防止进一步的失败，并给服务时间恢复。'
- en: '**Half-Open**: A single call is allowed through to probe the health of the
    service. If the call is successful, the circuit transitions back to *Closed*.
    However, if the call fails, the circuit transitions back to *Open*.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开式**：允许单个调用通过以探测服务的健康状态。如果调用成功，电路将转回**关闭**状态。然而，如果调用失败，电路将转回**开启**状态。'
- en: 'There are the following transition events:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些转换事件：
- en: '**Closed -> Open**: This transition occurs when the error threshold is reached'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭 -> 开启**：当达到错误阈值时发生此转换'
- en: '**Open -> Closed**: This transition occurs after a timeout period in the *Open*
    state (assuming the service has had enough time to recover)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启 -> 关闭**：在**开启**状态下经过超时期后发生此转换（假设服务已有足够时间恢复）'
- en: '**Open -> Half-Open**: This transition can be triggered manually or automatically
    after a configurable time in the *Open* state'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启 -> 半开**：此转换可以在**开启**状态下手动或自动触发，触发时间可配置'
- en: '**Half-Open -> Closed**: This transition occurs if the probe call in the *Half-Open*
    state is successful'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开 -> 关闭**：如果**半开**状态中的探测调用成功，则发生此转换'
- en: '**Half-Open -> Open**: This transition occurs if the probe call in the *Half-Open*
    state fails'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开 -> 开启**：如果**半开**状态中的探测调用失败，则发生此转换'
- en: Next, we’ll demonstrate the Circuit Breaker pattern in Java, focusing on safeguarding
    an e-commerce application’s order service from failures in its service dependencies.
    The pattern acts as a state machine with *Closed*, *Open*, and *Half-Open* states,
    along with implementing a fallback strategy for handling operations when failures
    occur.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示Java中的电路断路器模式，重点关注保护电子商务应用的订单服务免受其服务依赖项失败的影响。该模式作为一个具有**关闭**、**开启**和**半开**状态的有限状态机，并在发生失败时实现回退策略来处理操作。
- en: 'First, we create the `CircuitBreakerDemo` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`CircuitBreakerDemo`类：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `CircuitBreakerDemo` class defines an `enum State` to represent the three
    states: `CLOSED`, `OPEN`, and `HALF_OPEN`. The class has fields to store the maximum
    number of failures allowed (`maxFailures`), the duration for which the circuit
    breaker remains open (`openDuration`), the duration between consecutive probe
    calls in the `HALF_OPEN` state (`retryDuration`), and a `Supplier` representing
    the service being monitored. The `constructor()` initializes the state to `CLOSED`
    and sets the provided configuration values.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircuitBreakerDemo`类定义了一个`enum State`来表示三种状态：`CLOSED`、`OPEN`和`HALF_OPEN`。该类有字段来存储允许的最大失败次数（`maxFailures`）、电路断路器保持开启的时间（`openDuration`）、在`HALF_OPEN`状态中连续探测调用之间的持续时间（`retryDuration`），以及表示正在监控的服务的一个`Supplier`。`constructor()`将状态初始化为`CLOSED`并设置提供的配置值。'
- en: 'Next, we create the `call()` method and state transitions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`call()`方法和状态转换：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code performs the following actions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下操作：
- en: The `call()` method is the entry point for making requests to the service.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call()`方法是向服务发出请求的入口点。'
- en: In the `CLOSED` state, it calls the `callService()` method and returns the result.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CLOSED`状态下，它调用`callService()`方法并返回结果。
- en: In the `OPEN` state, it blocks requests and transitions to the `HALF_OPEN` state
    after the `openDuration` has elapsed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OPEN`状态下，它阻止请求，并在`openDuration`经过后转换到`HALF_OPEN`状态。
- en: In the `HALF_OPEN` state, it sends a probe request by calling `callService()`.
    If the probe succeeds, it transitions to `CLOSED`; otherwise, it transitions back
    to `OPEN`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `HALF_OPEN` 状态下，它通过调用 `callService()` 发送探测请求。如果探测成功，它转换为 `CLOSED` 状态；否则，它转换回
    `OPEN` 状态。
- en: 'Lastly, we have a service call and failure handling:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个服务调用和故障处理：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code performs the following functions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下功能：
- en: The `callService()` method invokes the service’s `get()` method and returns
    the result.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callService()` 方法调用服务的 `get()` 方法并返回结果。'
- en: If the service call fails (returns false or throws an exception), the `handleFailure()`
    method is called.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务调用失败（返回false或抛出异常），则调用 `handleFailure()` 方法。
- en: The `handleFailure()` method increments the failure count (`failureCount`).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleFailure()` 方法增加失败计数 (`failureCount`)。'
- en: If the `failure count` reaches the maximum allowed (`maxFailures`), the state
    is transitioned to `OPEN`, and the `lastFailureTime` is updated.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `failure count` 达到最大允许值 (`maxFailures`)，状态将转换为 `OPEN`，并更新 `lastFailureTime`。
- en: Remember, this is a simplified illustration of the Circuit Breaker pattern.
    For the full implementation, including detailed state management and customizable
    thresholds, please check out the accompanying GitHub repository. Also, consider
    using robust libraries such as Resilience4j for production-ready solutions, and
    remember to tailor failure thresholds, timeouts, and fallback behaviors to match
    your specific application’s needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是一个简化的断路器模式说明。对于完整的实现，包括详细的状态管理和可定制的阈值，请查看附带的GitHub仓库。此外，考虑使用如Resilience4j之类的健壮库来提供生产就绪的解决方案，并记住根据特定应用程序的需求调整故障阈值、超时和回退行为。
- en: 'The key takeaway is to understand the pattern’s underlying logic: how it transitions
    between states, handles failures gracefully with fallbacks, and ultimately shields
    your services from cascading breakdowns.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是理解该模式的底层逻辑：它是如何在不同状态之间转换的，如何通过回退机制优雅地处理故障，并最终保护你的服务免受级联故障的影响。
- en: Unleashing resilience – Circuit Breaker use cases in the cloud
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激发弹性 - 云中断路器的用例
- en: 'The Circuit Breaker pattern can be used in the following situations:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式可以在以下情况下使用：
- en: '**Online retail overload**: Circuit breakers protect dependent services (e.g.,
    payment processing) during high-traffic events. They enable graceful degradation,
    provide time for service recovery, and help automate the restoration of service.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线零售过载**: 断路器在高峰流量事件期间保护依赖服务（例如，支付处理）不受影响。它们允许优雅降级，提供服务恢复的时间，并帮助自动化服务的恢复。'
- en: '**Real-time data processing**: Circuit breakers safeguard analytics systems
    if data sources become slow or unresponsive, preventing overload.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据处理**: 当数据源变慢或无响应时，断路器保护分析系统，防止过载。'
- en: '**Distributed job scheduling**: In job scheduling systems, circuit breakers
    prevent jobs from overwhelming failing resources, promoting overall system health.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式作业调度**: 在作业调度系统中，断路器防止作业压倒失败资源，促进整体系统健康。'
- en: To maximize resilience, proactively integrate circuit breakers into your distributed
    cloud application’s design. Strategically position them at service boundaries,
    implement robust fallback mechanisms (e.g., caching and queuing), and couple them
    with monitoring tools to track circuit states and fine-tune configurations. Remember
    to weigh the added complexity against the resilience gains for your specific application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化弹性，积极地将断路器集成到分布式云应用程序的设计中。在服务边界处战略性地定位它们，实现强大的回退机制（例如，缓存和排队），并将它们与监控工具结合使用，以跟踪断路器状态并微调配置。请记住，权衡为特定应用程序带来的额外复杂性与其弹性收益。
- en: The Bulkhead pattern – enhancing cloud application fault tolerance
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防波墙模式 - 提高云应用程序的容错性
- en: The **Bulkhead** pattern, drawing inspiration from the maritime industry, involves
    compartmentalizing sections of a ship’s hull to prevent it from sinking if one
    part fills with water. Similarly, in software architecture, the Bulkhead pattern
    isolates elements of an application into separate sections (bulkheads) to prevent
    failures in one part from cascading throughout the entire system. This pattern
    is particularly useful in distributed systems and microservices architectures,
    where different components handle various functionalities.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bulkhead**模式从海事行业汲取灵感，涉及将船体部分隔离开来，以防止某一部位进水后整个船体下沉。同样，在软件架构中，Bulkhead模式将应用程序的元素隔离到不同的部分（bulkheads），以防止某一部分的故障在整个系统中级联。这种模式在分布式系统和微服务架构中特别有用，因为不同的组件处理各种功能。'
- en: 'The Bulkhead pattern safeguards your applications by dividing them into isolated
    compartments. This does the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Bulkhead模式通过将应用程序分割成隔离的隔间来保护你的应用程序。这做到了以下几点：
- en: '**Prevents cascading failures**: If one component fails, others remain unaffected'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止级联故障**：如果一个组件失败，其他组件不受影响'
- en: '**Optimizes resources**: Each compartment gets its own resources, preventing
    one area from hogging them all'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源**：每个隔间都有自己的资源，防止一个区域占用所有资源'
- en: '**Boosts resilience**: Critical parts of your application stay functional even
    during problems'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强弹性**：即使出现问题时，应用程序的关键部分也能保持功能正常'
- en: '**Simplifies scaling**: Scale individual components independently as needed'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化扩展**：根据需要独立扩展单个组件'
- en: Let’s look at practical examples and dive into how to implement the Bulkhead
    pattern in Java microservices and your projects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际例子，深入了解如何在Java微服务和你的项目中实现Bulkhead模式。
- en: Imagine an e-commerce application with a recommendation engine. This engine
    might be resource-intensive. We want to protect other services (order processing
    and search) from being starved of resources if the recommendation feature experiences
    high traffic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个电子商务应用程序，其中包含一个推荐引擎。这个引擎可能资源密集。我们希望保护其他服务（订单处理和搜索）免受推荐功能高流量时的资源短缺。
- en: 'Here is a code snippet using Resilience4j:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用Resilience4j的代码片段：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is an explanation of the code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对代码的解释：
- en: '`recommendationServiceBulkhead`, limiting the number of concurrent calls to
    10.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendationServiceBulkhead`，限制并发调用次数为10。'
- en: '**Wrapping the call**: We decorate the call to the recommendation engine with
    the bulkhead.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装调用**：我们用bulkhead装饰对推荐引擎的调用。'
- en: '`BulkheadFullException` is thrown. Implement a fallback (e.g., display default
    products) to handle this gracefully.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出`BulkheadFullException`异常。实现一个回退机制（例如，显示默认产品）以优雅地处理这种情况。
- en: The Bulkhead pattern safeguards your application by isolating resources; in
    this example, we limit the recommendation service to only 10 concurrent calls.
    This strategy ensures that order processing remains unaffected even if the recommendation
    engine is overloaded. For enhanced visibility, integrate the bulkhead with a metrics
    system to track how often the limit is reached. Remember that Resilience4j offers
    a Bulkhead implementation, but you can also explore alternative libraries or design
    your own.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Bulkhead模式通过隔离资源来保护你的应用程序；在这个例子中，我们限制推荐服务的并发调用次数为10。这种策略确保即使推荐引擎过载，订单处理也不会受到影响。为了提高可见性，将bulkhead与度量系统集成以跟踪限制达到的频率。记住，Resilience4j提供了Bulkhead实现，但你也可以探索其他库或设计自己的。
- en: This code snippet demonstrates the Bulkhead pattern in action, showcasing how
    to isolate services within a single application. Now, let’s explore some essential
    use cases of this pattern in cloud environments that can significantly enhance
    your system’s resilience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了Bulkhead模式的应用，展示了如何在单个应用程序中隔离服务。现在，让我们探索一些在云环境中至关重要的Bulkhead模式使用案例，这些案例可以显著增强你的系统弹性。
- en: Essential Bulkhead pattern use cases in cloud environments
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云环境中关键Bulkhead模式的使用案例
- en: 'Let’s focus on some highly practical use cases of the Bulkhead pattern in cloud
    environments that you would find immediately valuable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一些在云环境中高度实用的Bulkhead模式使用案例，这些案例将立即对你有价值：
- en: '**Multi-tenant applications**: Isolate tenants within a shared cloud application.
    This ensures that one tenant’s heavy usage won’t starve resources for others,
    guaranteeing fairness and consistent performance. Consider a multi-tenant e-commerce
    application. Each tenant (store) has its own product catalog, customer data, and
    order processing tasks. Using the Bulkhead pattern, each store would have a dedicated
    database connection pool for its product and customer data, separate message queues
    would be used for processing orders for each store, and there could be thread
    pools dedicated to handling order processing tasks for specific stores. This ensures
    that a surge in activity from one store won’t affect the performance of other
    stores in the application.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多租户应用程序**：在共享云应用程序中隔离租户。这确保了一个租户的密集使用不会使其他租户的资源枯竭，保证了公平性和一致的性能。考虑一个多租户电子商务应用程序。每个租户（商店）都有自己的产品目录、客户数据和订单处理任务。使用隔舱模式，每个商店都会为其产品和客户数据拥有一个专用的数据库连接池，为每个商店处理订单会使用单独的消息队列，还可能有专门用于处理特定商店订单处理任务的线程池。这确保了一个商店活动激增不会影响应用程序中其他商店的性能。'
- en: '**Mixed workload environments**: Separate critical services from less-critical
    ones (e.g., production batch jobs versus real-time user requests). Bulkheads ensure
    that lower-priority workloads don’t cannibalize resources needed by critical services.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合工作负载环境**：将关键服务与不那么关键的服务分开（例如，生产批处理作业与实时用户请求）。隔舱确保低优先级的工作负载不会蚕食关键服务所需的资源。'
- en: '**Unpredictable traffic**: Protect systems against sudden traffic spikes to
    specific components. Bulkheads isolate the impact, preventing a surge in one area
    from causing a total collapse.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可预测的流量**：保护系统免受特定组件突然流量激增的影响。隔舱隔离影响，防止一个区域的激增导致整体崩溃。'
- en: '**Microservice architectures**: A core principle in microservices! Bulkheads
    limit cascading failures. If one microservice fails, bulkheads help to prevent
    that failure from rippling through the entire application.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：微服务的一个核心原则！隔舱限制级联故障。如果一个微服务失败，隔舱有助于防止该故障在整个应用程序中蔓延。'
- en: 'When implementing the Bulkhead pattern, pay close attention to these key considerations:
    decide the granularity of isolation (service level, endpoint level, etc.) and
    meticulously configure bulkhead sizes (max calls and queues) based on thorough
    workload analysis. Always design robust fallback strategies (such as caching or
    default responses) for when bulkheads reach capacity. The Bulkhead pattern complements
    the cloud’s advantages—use it to dynamically scale isolated compartments and add
    a vital layer of resilience in your distributed cloud applications, where network
    reliance can increase the chances of failure.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现隔舱模式时，请密切关注以下关键考虑因素：决定隔离的粒度（服务级别、端点级别等）并根据彻底的工作负载分析仔细配置隔舱大小（最大调用和队列）。始终为隔舱达到容量时设计强大的回退策略（如缓存或默认响应）。隔舱模式补充了云的优势——使用它来动态扩展隔离的舱室，并在你的分布式云应用程序中添加一个至关重要的弹性层，其中网络依赖性可能会增加失败的机会。
- en: Java concurrency patterns for asynchronous operations and distributed communications
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发模式用于异步操作和分布式通信
- en: 'In this section, we’ll explore three crucial patterns that transform applications:
    the Producer-Consumer pattern for efficient data exchange, the Scatter-Gather
    pattern for distributed systems, and the Disruptor pattern for high-performance
    messaging. We’ll analyze each pattern and provide Java implementations, use cases,
    and their benefits in real-world cloud architectures emphasizing asynchronous
    operations and distributed communications.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三个关键模式，这些模式可以改变应用程序：用于高效数据交换的生产者-消费者模式、用于分布式系统的散列-收集模式以及用于高性能消息传递的破坏者模式。我们将分析每个模式，并提供Java实现、用例以及它们在现实世界云架构中的好处，强调异步操作和分布式通信。
- en: The Producer-Consumer pattern – streamlining data flow
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产者-消费者模式——简化数据流
- en: The **Producer-Consumer** pattern is a fundamental design pattern that addresses
    the mismatch between the rate of data generation and data processing. It decouples
    the producers, which generate tasks or data, from the consumers, which process
    those tasks or data, often asynchronously using a shared queue as a buffer. This
    pattern offers several benefits, particularly in cloud and distributed architectures,
    but it also introduces the need to handle the producer-consumer mismatch problem
    effectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The producer-consumer mismatch occurs when the rate of data production differs
    from the rate of data consumption. This mismatch can lead to two potential issues:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Overproduction**: If the producers generate data faster than the consumers
    can process it, the shared queue can become overwhelmed, leading to increased
    memory usage, potential out-of-memory errors, and overall system instability.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Underproduction**: If the producers generate data slower than the consumers
    can process it, the consumers may become idle, leading to underutilized resources
    and reduced system throughput.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address the producer-consumer mismatch problem, several strategies can be
    employed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Backpressure**: Implementing backpressure mechanisms allows consumers to
    signal to producers when they are overwhelmed, prompting producers to slow down
    or pause data generation temporarily. This helps prevent the shared queue from
    becoming overloaded and ensures a balanced flow of data.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue size management**: Configuring the shared queue with an appropriate
    size limit can prevent unbounded memory growth in the case of overproduction.
    When the queue reaches its maximum size, producers can be blocked or data can
    be dropped, depending on the specific requirements of the system.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic scaling**: In cloud and distributed environments, dynamically scaling
    the number of producers or consumers based on the observed load can help maintain
    a balanced data flow. Additional producers can be launched when data generation
    is high, and more consumers can be added when data processing lags behind.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load shedding**: In extreme cases, when the system is overloaded and cannot
    keep up with the incoming data, load shedding techniques can be employed to selectively
    drop or discard lower-priority data or tasks, ensuring that the most critical
    data is processed first.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and alerting**: Implementing monitoring and alerting mechanisms
    can provide visibility into the data flow rates and queue lengths, allowing timely
    intervention or automatic scaling when imbalances are detected.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By effectively managing the producer-consumer mismatch problem, the Producer-Consumer
    pattern can offer several advantages, such as decoupling, workload balancing,
    asynchronous flow, and improved performance through concurrency. It is the cornerstone
    of building robust and scalable applications where efficient data flow management
    is crucial, particularly in cloud and distributed architectures where components
    may not be immediately available, and workloads can vary dynamically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The Producer-Consumer pattern in Java – a real-world example
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s explore a practical example of how the Producer-Consumer pattern can
    be applied in a cloud-based image processing system, where the goal is to generate
    thumbnails for uploaded images asynchronously:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code demonstrates the Producer-Consumer pattern in the context of a cloud-based
    thumbnail generation system. Let’s break down how the pattern works in this example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Producer**:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *producer* uploads images to an S3 bucket and sends messages to an *SQS
    queue*
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each message contains information about the uploaded image, such as the image
    key
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThumbnailGenerator` class acts as the consumer and handles SQS events'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an `SQS event` is triggered, the `handleRequest()` method is invoked
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleRequest()` method receives an `SQSEvent` object representing the message
    from the SQS queue*   The `extractImageKey()` method extracts the `image key`
    from the `SQS event`*   `consumer` retrieves the image from the S3 bucket using
    the `image key`*   The `image` is loaded, resized while maintaining its aspect
    ratio, and saved as a JPEG*   The resized image bytes are stored in a `ByteArrayOutputStream`*   **Thumbnail
    upload**:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated thumbnail bytes are uploaded to a separate S3 bucket
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The thumbnail is stored with a key that includes the original image key and
    a *thumbnail.jpg* suffix*   `handleRequest()` method returns `null`, indicating
    no response is sent back to the producer*   This allows the `consumer` to process
    messages asynchronously, without blocking the producer
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This code demonstrates how the Producer-Consumer pattern enables asynchronous
    processing of image thumbnails in a cloud environment. The producer uploads images
    and sends messages, while the consumer processes the messages, generates thumbnails,
    and uploads them to a separate S3 bucket. This decoupling allows scalable and
    efficient image processing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve into the practical use cases of the Producer-Consumer pattern
    within cloud architectures.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The Producer-Consumer pattern – a foundation for efficient, scalable cloud systems
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a list of high-value use cases of the Producer-Consumer pattern within
    cloud environments:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Task offloading and distribution**: Decouple a computationally intensive
    process (image processing, video transcoding, etc.) from the main application.
    This allows scaling worker components independently to handle varying loads without
    impacting the primary application’s responsiveness.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice communication**: In microservice architectures, the Producer-Consumer
    pattern facilitates asynchronous communication between services. Services can
    produce messages without needing immediate responses, enhancing modularity and
    resilience.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven processing**: Design highly reactive cloud systems. Sensors,
    log streams, and user actions can trigger events, leading producers to generate
    messages that trigger downstream processing in a scalable way.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data pipelines**: Build multi-stage data processing workflows. Each stage
    can act as a consumer and a producer, enabling complex data transformations that
    operate asynchronously.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Producer-Consumer pattern offers significant benefits in cloud environments.
    It enables flexible scaling by allowing independent scaling of producers and consumers,
    ideal for handling unpredictable traffic. The pattern enhances system resilience
    with its queueing mechanism, preventing failures from cascading in the event of
    temporary component unavailability. It also encourages clean modular design through
    loose coupling, as components communicate indirectly. Finally, it promotes efficient
    resource usage by ensuring consumers process tasks only when they have capacity,
    optimizing resource allocation in dynamic cloud environments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scatter-Gather pattern: distributed processing powerhouse'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Scatter-Gather** pattern optimizes parallel processing in distributed
    systems by dividing a large task into smaller subtasks (scatter phase). These
    subtasks are then processed concurrently across multiple nodes. Finally, the results
    are collected and combined (gather phase) to produce the final output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The core concept involves the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Scatter**: A coordinator splits a task into independent subtasks'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel processing**: Subtasks are distributed for concurrent execution'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gather**: The coordinator collects partial results'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation**: Results are combined into the final output'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its key benefits are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved performance**: Parallel processing significantly reduces execution
    time'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Easily add more processing nodes to handle larger workloads'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Subtasks can run on nodes with specific capabilities'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: Potential for reassigning subtasks if a node fails'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is ideal for distributed systems and cloud environments where tasks
    can be parallelized for faster execution and dynamic resource allocation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to apply Scatter-Gather in a specific use case!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Scatter-Gather in Java with ExecutorService
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a compact Java example that illustrates the Scatter-Gather pattern, tailored
    for an AWS environment. This example conceptually demonstrates how you might use
    AWS Lambda functions (as the scatter phase) to perform parallel processing of
    tasks and then gather the results. It uses AWS SDK for Java to interact with AWS
    services such as Lambda and S3 for simplicity in code demonstration. Please note
    that this example assumes you have a basic setup done in AWS, such as Lambda functions
    and S3 buckets in place.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code demonstrates the Scatter-Gather pattern using AWS services for distributed
    task processing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService`) is created to match the number of tasks'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each task is submitted to the pool. Within each task, we have the following:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `InvokeRequest` is prepared for an AWS Lambda function, carrying the task
    data
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Lambda function is invoked (`lambdaClient.invoke(...)`)
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Future<InvokeResult>` holds references to the pending Lambda execution results*   The
    code iterates over the futures list and retrieves the `InvokeResult` for each
    task using `future.get()`*   Lambda results are processed (assuming the payload
    is a string) and collected into a list*   **Aggregation (optional)**:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collected results are joined into a single string
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The aggregated result is stored in an S3 bucket
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This code exemplifies the Scatter-Gather pattern by distributing tasks to AWS
    Lambda functions for parallel execution (scatter), awaiting their completion,
    and then aggregating the results (gather). The use of AWS Lambda highlights the
    pattern’s compatibility with cloud-native technologies. For a production-ready
    implementation, it’s crucial to incorporate robust error handling, timeout mechanisms,
    and proper resource management to ensure system resilience.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve into the practical use cases.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Practical applications of Scatter-Gather in cloud environments
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of practical applications where the Scatter-Gather pattern
    excels within cloud environments:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**High-performance computation**:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scientific simulations**: Break down complex simulations into smaller, independent
    sub-calculations that can be distributed across a cluster of machines or serverless
    functions for parallel execution.'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Financial modeling**: Apply Monte Carlo simulations or complex risk models
    in parallel to a large dataset, significantly reducing computation time.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machine learning (model training)**: Distribute the training of machine learning
    models across multiple GPUs or instances. Each worker trains on a subset of the
    data, and results are aggregated to update the global model.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large-scale** **data processing**:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batch processing**: Divide large datasets into smaller chunks for parallel
    processing. This is useful for tasks such as **Extract, Transform, Load**(**ETL**)
    pipelines in data warehouses.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MapReduce-style operations**: Implement custom MapReduce-like frameworks
    in the cloud. Split a large input, have workers process in parallel (map), and
    gather results to be combined (reduce).'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web crawling**: Distribute web page crawling tasks across multiple nodes
    (avoiding overwhelming individual websites), then combine results into a searchable
    index.'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time or** **event-driven workflows**:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fan-out processing**: An event (e.g., an IoT device reading) triggers multiple
    parallel actions. These could include sending notifications, updating databases,
    or initiating calculations. Results are then potentially aggregated.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices request-response**: A client request sent to an API Gateway
    might require calling multiple backend microservices in parallel, potentially
    with each service responsible for a different data source. Gather responses to
    provide a comprehensive response to the client.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scatter-Gather pattern is a powerful tool in your cloud development toolkit.
    Consider it when you need to accelerate computationally intensive tasks, process
    massive datasets, or architect responsive event-driven systems. Experiment with
    this pattern and witness the efficiency gains it brings to your cloud applications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The Disruptor pattern – streamlined messaging for low-latency applications
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Disruptor** pattern is a high-performance messaging and event processing
    framework designed to achieve exceptionally low latency. Its key elements are
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Ring buffer**: A pre-allocated circular data structure where producers place
    events and consumers retrieve them. This prevents dynamic memory allocation and
    garbage collection overheads.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lock-Free design**: The Disruptor pattern employs sequence numbers and atomic
    operations to eliminate the need for traditional locking, boosting concurrency
    and reducing latency.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching**: Events are processed in batches for increased efficiency, minimizing
    context switching and cache misses.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-producer/consumer**: The pattern supports multiple producers and consumers
    working concurrently, crucial for scalable distributed systems.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at *Figure 5**.2*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: A[Producer] --> B {Claim slot}
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: B --> C {Check availability}
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: C --> D {Wait (Optional)}
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: C --> E {Reserve slot (sequence number)}
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: E --> F {Publish event}
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: F --> G {Update sequence number}
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: G --> H {Notify consumers}
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: H --> I [Consumer]
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: I --> J {Check sequence}
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: J --> K {Process events (up to sequence)}
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: K --> L {Update consumer sequence}
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: L --> I
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Disruptor pattern flowchart (left-right)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an explanation of the Disruptor pattern flowchart:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The producer initiates the process by claiming a slot in the ring buffer (A
    --> B).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Disruptor checks if a slot is available (B --> C).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a slot is unavailable, the producer might wait (C --> D).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a slot is available, the producer reserves a slot using a sequence number
    (C --> E).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The event data is published to the reserved slot (E --> F).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sequence number is updated atomically (F --> G).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consumers are notified about the updated sequence (G --> H).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A consumer wakes up and checks the latest sequence (H --> I, J).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The consumer processes events in a batch up to the available sequence (J -->
    K).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The consumer’s sequence number is updated (K --> L).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process loops back for the consumer to check for new events (L --> I)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Disruptor pattern delivers remarkable performance benefits. It’s known for
    its ability to process millions of events per second, achieving ultra-low latency
    with processing times in the microsecond range. This exceptional performance makes
    it ideal for use cases such as financial trading systems, real-time analytics
    platforms, and high-volume event processing scenarios such as IoT or log analysis.
    The Disruptor pattern outperforms traditional queue-based approaches when speed
    and low latency are critical requirements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Now we will explore a practical implementation to see how the Disruptor pattern
    is used in specific cloud-based applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Disruptor in cloud environments – real-time stock market data processing
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore how the Disruptor pattern is used in cloud-based applications.
    We’ll use a simplified example to illustrate the key concepts, understanding that
    production-ready implementations will involve greater detail.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a system that needs to ingest a continuous stream of stock price updates
    and perform real-time calculations (e.g., moving averages and technical indicators).
    These calculations must be lightning-fast to enable rapid trading decisions. How
    does the Disruptor fit in? Here is a simple Java example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to use the Disruptor library in your Java project with Maven, you need
    to add the following dependency to your `pom.xml` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we create an event class, `StockPriceEvent`, and a `MovingAverageCalculator`
    class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the above code snippet, the `StockPriceEvent` class represents the event
    that will be processed by the `Disruptor`. It contains fields for the stock symbol,
    timestamp, and price.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The `MovingAverageCalculator` class implements the `EventHandler` interface
    and acts as a consumer for the `StockPriceEvent`. It calculates the moving average
    of the stock prices as events are processed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create the `DisruptorExample` class:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code demonstrates the Disruptor pattern for low-latency processing of
    stock price updates with a moving average calculation as a consumer. Let’s break
    down the key steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`bufferSize`: Defines the size of the pre-allocated ring buffer where events
    (stock price updates) are stored. This prevents memory allocation overhead during
    runtime.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executor`: A thread pool responsible for executing event handlers (consumers)
    concurrently.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`producerType`: Set to `ProducerType.MULTI` to allow multiple sources (producers)
    to publish stock price updates concurrently.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitStrategy`: A `BlockingWaitStrategy` is used here. This strategy causes
    producers to wait if the ring buffer is full, ensuring no data loss.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disruptor<StockPriceEvent>`: An instance of the `Disruptor` class is created,
    specifying the event type (`StockPriceEvent`). This Disruptor object manages the
    entire event processing pipeline.*   `disruptor.handleEventsWith(new MovingAverageCalculator())`:
    This line adds the `MovingAverageCalculator` class as an event handler (consumer)
    to the Disruptor. The consumer will be invoked for each published stock price
    update event.*   `disruptor.start()`: Starts the Disruptor, initializing the ring
    buffer and consumer threads.*   `for` loop simulates 100 stock price updates for
    the symbol `"AAPL"` with random prices.*   `disruptor.publishEvent(...)`: This
    line publishes each event to the `Disruptor` using a lambda function. The lambda
    calls `eventWriter.onData(event)` to populate the event data in the ring buffer.*   `Producers`
    (simulated in this example) publish stock price update events to the Disruptor’s
    ring buffer.*   The `Disruptor` assigns sequence numbers to events and makes them
    available to consumers.*   The `MovingAverageCalculator` consumer concurrently
    processes these events, updating the moving average based on each stock price.*   The
    Disruptor’s lock-free design ensures efficient event handling and prevents bottlenecks
    caused by traditional locking mechanisms.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that this is a simple illustration. Production code would include error
    handling, multiple consumers for different calculations, and integration with
    cloud-specific services for data input.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s delve into some practical use cases where the Disruptor pattern can
    significantly enhance the performance of cloud applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: High-performance cloud applications – essential Disruptor pattern use cases
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The top use cases where the Disruptor pattern shines within cloud environments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**High-throughput,** **low-latency processing**:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Financial trading**: Execute trades at lightning speed and make rapid decisions
    based on real-time market data. The Disruptor’s low latency processing is paramount
    in this domain.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time analytics**: Process massive streams of data (website clicks, sensor
    readings, etc.) to gain insights and trigger actions in near real time.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-frequency event logging**: Ingest and process vast amounts of log data
    for security monitoring, analysis, or troubleshooting in large-scale systems.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice architectures**:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-service communication**: Use the Disruptor as a high-performance message
    bus. Producers and consumers can be decoupled, enhancing modularity and scalability.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven workflows**: Orchestrate complex workflows where different microservices
    react to events in a responsive and efficient manner.'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud-specific** **use cases**:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT event processing**: Handle the deluge of data from IoT devices. The Disruptor
    can quickly process sensor readings or device state changes to trigger alerts
    or updates.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless event processing**: Integrate with serverless functions (e.g.,
    AWS Lambda), where the Disruptor can coordinate event processing with ultra-low
    overhead.'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While the Disruptor pattern offers exceptional performance benefits, it’s essential
    to be mindful of its potential complexities. Careful tuning of parameters such
    as ring buffer size and consumer batch sizes is often necessary to achieve optimal
    results. In a cloud environment, consider integrating with cloud-native services
    to enhance the system’s resilience through features such as replication or persistence
    of the ring buffer. Properly understanding and addressing potential bottlenecks
    is crucial to fully harness the Disruptor’s power and ensure your cloud-based
    system remains highly efficient and robust.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The Disruptor pattern versus the Producer-Consumer pattern – a comparative analysis
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s compare the Disruptor pattern and the Producer-Consumer pattern, highlighting
    their key differences:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**Design purpose**:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer-Consumer**: A general-purpose pattern for decoupling the production
    and consumption of data or events'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disruptor**: A specialized high-performance variant optimized for low-latency
    and high-throughput scenarios'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data structure**:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer-Consumer**: Uses a shared queue or buffer, which can be bounded
    or unbounded'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disruptor**: Employs a pre-allocated ring buffer with a fixed size to minimize
    memory allocation and garbage collection overhead'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locking mechanism**:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer-Consumer**: Often relies on traditional locking mechanisms, such
    as locks or semaphores, for synchronization'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disruptor**: Utilizes a lock-free design using sequence numbers and atomic
    operations, reducing contention and enabling higher concurrency'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching**:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer-Consumer**: Typically processes events or data one at a time, with
    no inherent support for batching'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disruptor**: Supports batching of events, allowing consumers to process events
    in batches for improved efficiency'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer-Consumer**: Performance depends on the implementation and chosen
    synchronization mechanisms, and may suffer from lock contention and increased
    latency'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disruptor**: Optimized for high performance and low latency, thanks to its
    lock-free design, pre-allocated ring buffer, and batching capabilities'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice between the two patterns depends on the system’s requirements. The
    Disruptor pattern is suitable for low-latency and high-throughput scenarios, while
    the Producer-Consumer pattern is more general-purpose and simpler to implement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: As we move into the next section, keep in mind that combining these core patterns
    opens up possibilities for even more sophisticated and robust cloud solutions.
    Let’s explore how they can work together to push the boundaries of performance
    and resilience!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Combining concurrency patterns for enhanced resilience and performance
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By strategically blending these patterns, you can achieve new levels of cloud
    system efficiency and robustness. Harness the power of combined concurrency patterns
    to build cloud systems that are both exceptionally performant and resilient, unlocking
    the hidden potential of your cloud architecture.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Circuit Breaker and Producer-Consumer patterns
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Combining the Circuit Breaker and Producer-Consumer patterns significantly
    boosts resilience and data flow efficiency in asynchronous cloud applications.
    The Circuit Breaker safeguards against failures, while the Producer-Consumer pattern
    optimizes data processing. Here’s how to integrate them effectively:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**Decouple with Circuit Breakers**: Place a Circuit Breaker between producers
    and consumers to prevent consumer overload during failures or slowdowns. This
    allows the system to recover gracefully.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive load management**: Use the Circuit Breaker’s state to dynamically
    adjust the producer’s task generation rate. Reduce the rate when the Circuit Breaker
    trips to maintain throughput while ensuring reliability.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritize data**: Use multiple queues with individual Circuit Breakers to
    protect each queue. This ensures that high-priority tasks are processed even during
    system stress.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-healing feedback loop**: Have the Circuit Breaker’s state trigger resource
    allocation, error correction, or alternative task routing, enabling autonomous
    system recovery.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement graceful degradation**: Employ fallback mechanisms in consumers
    to maintain service (even in a reduced form) when Circuit Breakers trip.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate how this integration enhances fault tolerance, let’s examine
    a code demo for resilient order processing using the Circuit Breaker and Producer-Consumer
    patterns.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Resilient order processing – Circuit Breaker and Producer-Consumer demo
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an e-commerce platform, use a queue to buffer orders (the Producer-Consumer
    pattern). Wrap external service calls (e.g., payment processing) within circuit
    breakers for resilience. If a service fails, the Circuit Breaker pattern prevents
    cascading failures and can trigger fallback strategies.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code demonstrates the integration of the Circuit Breaker and Producer-Consumer
    patterns to enhance the resilience of an order processing system. Let’s look at
    the code in detail:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderQueue` acts as a buffer between order generation and processing. `OrderConsumer`
    pulls orders from this queue for asynchronous processing.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paymentCircuitBreaker` protects an external payment service. If the payment
    service is experiencing issues, the circuit breaker prevents cascading failures.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceException` occurs during `processPayment`, the circuit breaker is tripped
    (`paymentCircuitBreaker.trip()`), temporarily halting further calls to the payment
    service.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryOrderLater` method signals that the order should be processed at a later
    time, allowing the dependent service to recover.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this code snippet highlights how these patterns work together to improve
    system robustness and maintain functionality even during partial failures.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Bulkhead with Scatter-Gather for enhanced fault tolerance
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Combine the Bulkhead pattern with Scatter-Gather to build more resilient and
    efficient microservice architectures in the cloud. Bulkhead’s focus on isolation
    helps manage failures and optimize resource usage within the Scatter-Gather framework.
    Here’s how:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolated scatter components**: Employ the Bulkhead pattern to isolate scatter
    components. This prevents failures or heavy loads in one component from affecting
    others.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dedicated gather resources**: Allocate distinct resources to the gather component
    using Bulkhead principles. This ensures efficient result aggregation, even under
    heavy load on the scatter services.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic resource allocation**: Bulkhead enables dynamic adjustment of resources
    for each scatter service based on its needs, optimizing overall system usage.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance and redundancy**: Bulkhead isolation ensures that the entire
    system doesn’t fail if one scatter service goes down. Create redundant scatter
    service instances with separate resource pools for high fault tolerance.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the benefits of this integration, let’s consider a real-world
    use case: a weather forecasting service.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Weather data processing with Bulkhead and Scatter-Gather
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine a weather forecasting service that gathers data from multiple weather
    stations spread across a vast geographical region. The system needs to process
    this data efficiently and reliably to generate accurate weather forecasts. Here’s
    how we can use the combined power of Bulkhead and Scatter-Gather patterns:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code demonstrates the integration of the Bulkhead and Scatter-Gather patterns
    for weather data processing. Here is the explanation:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '`WeatherDataCoordinator` orchestrates parallel processing. It scatters weather
    readings to regional bulkhead instances and gathers the results for final aggregation.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeatherDataProcessor` instances, potentially allowing further parallelization
    within a region.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: Bulkheads prevent failures in one region from affecting others.
    If a region’s processing experiences issues, other regions can continue working.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a simple example. Real-world implementations would involve error handling,
    communication mechanisms between coordinator and bulkheads, and specific logic
    for processing weather data and merging results.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: This integration not only enhances the resilience of distributed systems by
    isolating failures but also optimizes resource utilization across parallel processing
    tasks, making it an ideal strategy for complex, cloud-based environments.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Blending concurrency patterns – a recipe for high-performance cloud applications
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blending different concurrency patterns in cloud applications can significantly
    enhance both performance and resilience. By carefully integrating patterns that
    complement each other’s strengths, developers can create more robust, scalable,
    and efficient systems. In this section, we’ll explore strategies for the synergistic
    integration of concurrency patterns, highlighting scenarios where such blends
    are particularly effective.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Blending the Circuit Breaker and Bulkhead patterns
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a microservices architecture, where each service may depend on several other
    services, combining the Circuit Breaker and Bulkhead patterns can prevent failures
    from cascading across services and overwhelming the system.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration strategy**: Use the Circuit Breaker pattern to protect against
    failures in dependent services. In parallel, apply the Bulkhead pattern to limit
    the impact of any single service’s failure on the overall system. This approach
    ensures that if a service does become overloaded or fails, it doesn’t take down
    unrelated parts of the application.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Combining Scatter-Gather with the Actor model
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building on our previous discussion of the Actor model in [*Chapter 4*](B20937_04.xhtml#_idTextAnchor099),
    *Java Concurrency Utilities and Testing in the Cloud Era*, let’s see how it complements
    the Scatter-Gather pattern for distributed data processing tasks requiring result
    aggregation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration strategy**: Use the Actor model to implement the scatter component,
    distributing tasks among a group of actor instances. Each actor processes a portion
    of the data independently. Then, employ a gather actor to aggregate the results.
    This setup benefits from the Actor model’s inherent message-passing concurrency,
    ensuring that each task is handled efficiently and in isolation.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Merging Producer-Consumer with the Disruptor pattern
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In high-throughput systems where processing speed is critical, such as real-time
    analytics or trading platforms, the Producer-Consumer pattern can be enhanced
    with the Disruptor pattern for lower latency and higher performance.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration strategy**: Implement the Producer-Consumer infrastructure using
    the Disruptor pattern’s ring buffer to pass data between producers and consumers.
    This blend takes advantage of the Disruptor pattern’s high-performance, lock-free
    queues to minimize latency and maximize throughput, all while maintaining the
    clear separation of concerns and scalability of the Producer-Consumer pattern.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Synergizing event sourcing with CQRS
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both event sourcing and **Command Query Responsibility Segregation** (**CQRS**)
    are software architectural patterns. They address different aspects of system
    design:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**Event sourcing**: Focuses fundamentally on how the state of an application
    is represented, persisted, and derived. It emphasizes an immutable history of
    events as the source of truth.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CQRS**: Focuses on separating the actions that change an application’s state
    (commands) from those actions that retrieve information without changing the state
    (queries). This separation can improve scalability and performance.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While they are distinct, event sourcing and CQRS are often used together in
    a complementary way: event sourcing provides a natural source of events for CQRS,
    and CQRS allows the independent optimization of read and write models within an
    event-sourced system.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration strategy**: Use event sourcing to capture changes to the application
    state as a sequence of events. Combine this with CQRS to separate the models for
    reading and writing data. This blend allows highly efficient, scalable read models
    optimized for query operations while maintaining an immutable log of state changes
    for system integrity and replayability.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: To maximize the benefits of pattern integration, choose patterns with complementary
    objectives, such as those focused on fault tolerance and scalability. Combine
    patterns that promote isolation (such as Bulkhead) with those offering efficient
    resource management (such as Disruptor) to achieve both resilience and performance.
    Utilize patterns that decouple components (such as Event Sourcing and CQRS) to
    make a simpler system architecture that’s easier to scale and maintain over time.
    This strategic blending of concurrency patterns helps you address the complexities
    of cloud applications, resulting in systems that are more resilient, scalable,
    and easier to manage.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of this chapter as your journey into the heart of cloud application design.
    We started by building a strong foundation—exploring patterns such as Leader-Follower,
    Circuit Breaker, and Bulkhead to create systems that can withstand the storms
    of cloud environments. Think of these patterns as your architectural armor!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Next, we ventured into the realm of asynchronous operations and distributed
    communication. Patterns such as the Producer-Consumer, Scatter/Gather, and Disruptor
    became your tools for streamlining data flow and boosting performance. Imagine
    them as powerful engines propelling your cloud applications forward.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we uncovered the secret to truly exceptional cloud systems: the strategic
    combination of patterns. You learned how to integrate Circuit Breaker and Bulkhead
    for enhanced resilience, enabling you to create applications that can adapt and
    recover gracefully. This is like giving your cloud systems superpowers!'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'With your newfound mastery of concurrency patterns, you’re well equipped to
    tackle complex challenges. [*Chapter 6*](B20937_06.xhtml#_idTextAnchor162)*,*
    *Java in the Realm of Big Data*, throws you a new curveball: processing massive
    datasets. Let’s see how Java and these patterns come together to conquer this
    challenge.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main purpose of the Circuit Breaker pattern in a distributed system?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enhance data encryption
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent a high number of requests from overwhelming a service
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent failures in one service from affecting other services
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To schedule tasks for execution at a later time
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When implementing the Disruptor pattern, which of the following is crucial for
    achieving high performance and low latency?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a large number of threads to increase concurrency
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Employing a lock-free ring buffer to minimize contention
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Prioritizing tasks based on their complexity
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Increasing the size of the message payload
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the context of microservices, what is the primary advantage of implementing
    the Bulkhead pattern?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows a single point of operation for all services.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It encrypts messages exchanged between services.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It isolates services to prevent failures in one from cascading to others.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It aggregates data from multiple sources into a single response.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which concurrency pattern is particularly effective for operations that require
    results to be aggregated from multiple sources in a distributed system?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leader Election pattern
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scatter-Gather pattern
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bulkhead pattern
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Actor model
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Integrating the Circuit Breaker and Producer-Consumer patterns in cloud applications
    primarily enhances the system’s:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memory efficiency
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Computational complexity
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security posture
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resilience and data flow management
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 2: Java''s Concurrency in Specialized Domains'
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second part explores Java's concurrency capabilities across specialized
    domains, demonstrating how these features tackle complex challenges in big data,
    machine learning, microservices, and serverless computing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20937_06.xhtml#_idTextAnchor162), *Java and Big Data – a Collaborative
    Odyssey*'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20937_07.xhtml#_idTextAnchor187), *Concurrency in Java for Machine
    Learning*'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B20937_08.xhtml#_idTextAnchor206), *Microservices in the Cloud
    and Java''s Concurrency*'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B20937_09.xhtml#_idTextAnchor229), *Serverless Computing and
    Java''s Concurrent Capabilities*'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
