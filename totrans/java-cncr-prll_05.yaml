- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Mastering Concurrency Patterns in Cloud Computing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握云计算中的并发模式
- en: Mastering concurrency is crucial for unlocking the full potential of cloud computing.
    This chapter equips you with the knowledge and skills required to leverage concurrency
    patterns, the cornerstones of building high-performance, resilient, and scalable
    cloud applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握并发对于释放云计算的全部潜力至关重要。本章为你提供了利用并发模式的知识和技能，这些模式是构建高性能、健壮和可伸缩云应用的基础。
- en: These patterns are more than just theory. They empower you to harness the distributed
    nature of cloud resources, ensuring smooth operation under high loads and a seamless
    user experience. Leader-Follower, Circuit Breaker, and Bulkhead are indeed fundamental
    design patterns that serve as essential building blocks for robust cloud systems.
    They provide a strong foundation for understanding how to achieve high availability,
    fault tolerance, and scalability. We’ll explore these core patterns, which are
    designed to address challenges such as network latency and failures. While there
    are many other patterns beyond these three, these chosen patterns serve as a solid
    starting point for mastering concurrency in cloud computing. They provide a basis
    for understanding the principles and techniques that can be applied to a wide
    range of cloud architectures and scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式不仅仅是理论。它们赋予你利用云资源分布式特性的能力，确保在高负载下平稳运行和无缝的用户体验。领导者-追随者、断路器和舱壁确实是基本的设计模式，它们是构建强大云系统的基础构件。它们为理解如何实现高可用性、容错性和可伸缩性提供了坚实的基础。我们将探讨这些核心模式，它们旨在解决网络延迟和故障等挑战。虽然还有许多其他模式，但这些选定的模式为掌握云计算中的并发提供了一个坚实的起点。它们为理解可以应用于广泛云架构和场景的原则和技术提供了基础。
- en: We’ll then delve into patterns for asynchronous operations and distributed communication,
    including Producer-Consumer, Scatter-Gather, and Disruptor. The true power lies
    in combining these patterns strategically. We’ll explore techniques for integrating
    and blending patterns to achieve synergistic effects, boosting both performance
    and resilience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将深入探讨异步操作和分布式通信的模式，包括生产者-消费者、分散-聚集和破坏者。真正的力量在于战略性地结合这些模式。我们将探讨整合和融合模式以实现协同效应的技术，从而提高性能和弹性。
- en: By the end of this chapter, you’ll be equipped to design and implement cloud
    applications that excel at handling concurrent requests, are resilient to failures,
    and effortlessly scale to meet growing demands. We’ll conclude with practical
    implementation strategies to solidify your learning and encourage further exploration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够设计和实现能够出色处理并发请求、对故障具有弹性且能够轻松扩展以满足增长需求的云应用。我们将以实际实施策略来巩固你的学习并鼓励进一步探索。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Package and run a Java class as an AWS Lambda function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 类打包并作为 AWS Lambda 函数运行。
- en: 'First, prepare your Java class:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，准备你的 Java 类：
- en: Ensure your class implements the `RequestHandler<Input, Output>` interface from
    the `com.amazonaws:aws-lambda-java-core` library. This defines the handler method
    that processes events.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的类实现了来自 `com.amazonaws:aws-lambda-java-core` 库的 `RequestHandler<Input, Output>`
    接口。这定义了处理事件的处理器方法。
- en: 'Include any necessary dependencies in your `pom.xml` file (if you’re using
    Maven):'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `pom.xml` 文件中包含任何必要的依赖项（如果你使用 Maven）：
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be sure to replace `1.2.x` with the latest compatible version of the `aws-lambda-java-core`
    library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将 `1.2.x` 替换为 `aws-lambda-java-core` 库的最新兼容版本。
- en: 'Then, package your code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打包你的代码：
- en: Create a JAR file containing your compiled Java class and all its dependencies.
    You can use a tool such as Maven or a simple command such as `jar cvf myLambdaFunction.jar
    target/classes/*.class` (assuming compiled classes are in target/classes).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含编译后的 Java 类及其所有依赖项的 JAR 文件。你可以使用 Maven 这样的工具，或者使用简单的命令，例如 `jar cvf myLambdaFunction.jar
    target/classes/*.class`（假设编译后的类在 target/classes 中）。
- en: 'Create a Lambda function in AWS:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 中创建一个 Lambda 函数：
- en: Go to the AWS Lambda console and click **Create function**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 AWS Lambda 控制台并点击**创建函数**。
- en: Choose **Author from scratch** and select **Java 11** or a compatible runtime
    for your code.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**从头开始创建**并选择适用于你的代码的**Java 11**或兼容运行时。
- en: Provide a name for your function and choose **Upload** for the code source.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的函数提供一个名称，并选择**上传**作为代码源。
- en: Upload your JAR file in the **Code entry** **type** section.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**代码输入****类型**部分上传你的 JAR 文件。
- en: Configure your function’s memory allocation, timeout, and other settings as
    needed.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要配置您的函数内存分配、超时和其他设置。
- en: Click **Create function**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建函数**。
- en: 'Test your function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的函数：
- en: In the Lambda console, navigate to your newly created function.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lambda 控制台中，导航到您新创建的函数。
- en: Click on **Test** and provide a sample event payload (if applicable).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试**并提供一个示例事件有效负载（如果适用）。
- en: Click on **Invoke** to run your function with the provided test event.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**调用**以使用提供的测试事件运行您的函数。
- en: The Lambda console will display the output or error message returned by your
    function’s handler method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 控制台将显示您的函数处理方法返回的输出或错误消息。
- en: 'For a more comprehensive guide with screenshots and additional details, you
    can refer to the official AWS documentation on deploying Java Lambda functions:
    [https://docs.aws.amazon.com/lambda/latest/dg/java-package.html](https://docs.aws.amazon.com/lambda/latest/dg/java-package.html)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取带有截图和额外细节的更全面指南，您可以参考官方 AWS 文档中关于部署 Java Lambda 函数的内容：[https://docs.aws.amazon.com/lambda/latest/dg/java-package.html](https://docs.aws.amazon.com/lambda/latest/dg/java-package.html)
- en: This documentation provides step-by-step instructions on packaging your code,
    creating a deployment package, and configuring your Lambda function in the AWS
    console. It also covers additional topics such as environment variables, logging,
    and handling errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档提供了打包您的代码、创建部署包以及在 AWS 控制台中配置您的 Lambda 函数的逐步说明。它还涵盖了环境变量、日志记录和错误处理等附加主题。
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Core patterns for robust cloud foundations
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坚固云基础的核心模式
- en: In this section, we delve into the foundational design patterns that are essential
    for building resilient, scalable, and efficient cloud-based applications. These
    patterns provide the architectural groundwork necessary to address common challenges
    in cloud computing, including system failures, resource contention, and service
    dependencies. Specifically, we will explore the Leader-Follower pattern, the Circuit
    Breaker pattern, and the Bulkhead pattern, each offering unique strategies to
    enhance fault tolerance, system reliability, and service isolation in the dynamic
    environment of cloud computing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究对于构建弹性、可伸缩和高效云应用程序至关重要的基础设计模式。这些模式提供了必要的架构基础，以解决云计算中的常见挑战，包括系统故障、资源竞争和服务依赖。具体来说，我们将探讨领导者-跟随者模式、断路器模式和安全舱模式，每种模式都提供独特的策略来增强容错性、系统可靠性和服务隔离性，以适应云计算的动态环境。
- en: The Leader-Follower pattern
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领导者-跟随者模式
- en: The **Leader-Follower** pattern is a concurrency design pattern that’s particularly
    suited to distributed systems where tasks are dynamically allocated to multiple
    worker units. This pattern helps manage resources and tasks efficiently by organizing
    the worker units into a leader and multiple followers. The leader is responsible
    for monitoring and delegating work, while the followers wait to become leaders
    or to execute tasks assigned to them. This role-switching mechanism ensures that
    at any given time, one unit is designated to handle task distribution and management,
    optimizing resource utilization, and improving system scalability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**领导者-跟随者**模式是一种并发设计模式，特别适用于任务动态分配给多个工作单元的分布式系统。该模式通过将工作单元组织成一个领导者及其多个跟随者来有效地管理和分配资源与任务。领导者负责监控和委派工作，而跟随者则等待成为领导者或执行分配给他们的任务。这种角色切换机制确保在任何给定时间，都有一个单元被指定来处理任务分配和管理，优化资源利用，并提高系统可伸缩性。'
- en: 'In distributed systems, efficient task management is key. The Leader-Follower
    pattern addresses this in the following ways:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，有效的任务管理是关键。领导者-跟随者模式以下列方式解决此问题：
- en: '**Maximizing resource usage**: The pattern minimizes idle time by always assigning
    tasks to available workers.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大化资源使用**：该模式通过始终将任务分配给可用的工人来最小化空闲时间。'
- en: '**Streamlining distribution**: A single leader handles task allocation, simplifying
    the process and reducing overhead.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化分发**：单个领导者处理任务分配，简化流程并减少开销。'
- en: '**Enabling easy scaling**: You can seamlessly add more follower threads to
    handle increased workloads without significantly altering the system’s logic.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现轻松扩展**：您可以无缝地添加更多跟随者线程来处理增加的工作负载，而无需显著改变系统的逻辑。'
- en: '**Promoting fault tolerance**: If the leader fails, a follower can take its
    place, ensuring system continuity.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高容错性**：如果领导者失败，跟随者可以取代其位置，确保系统连续性。'
- en: '**Enhancing uptime and availability**: The Leader-Follower pattern improves
    system uptime and availability by efficiently distributing and processing tasks.
    Dynamic task allocation to available followers minimizes the impact of individual
    worker failures. If a follower becomes unresponsive, the leader can quickly reassign
    the task, reducing downtime. Moreover, promoting a follower to a leader role in
    case of leader failure enhances the system’s resilience and availability. This
    fault-tolerant characteristic contributes to higher levels of uptime and availability
    in distributed systems.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可用性和正常运行时间**：领导者-跟随者模式通过有效地分配和处理任务来提高系统的可用性和正常运行时间。将动态任务分配给可用的跟随者可以最小化单个工作者失败的影响。如果跟随者变得无响应，领导者可以快速重新分配任务，减少停机时间。此外，在领导者失败的情况下提升跟随者为领导者角色，增强了系统的弹性和可用性。这种容错特性有助于提高分布式系统中的正常运行时间和可用性水平。'
- en: To illustrate the Leader-Follower pattern in Java, we focus on its use for task
    delegation and coordination through a simplified code example. This pattern involves
    a central Leader that assigns tasks to a pool of Followers, effectively managing
    task execution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Java中的领导者-跟随者模式，我们关注其通过简化的代码示例用于任务委派和协调。这种模式涉及一个中央领导者，它将任务分配给一组跟随者，从而有效地管理任务执行。
- en: 'The following is a simplified code snippet (key elements; for the full code,
    please refer to the GitHub repository accompanying this title):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化的代码片段（关键元素；完整代码请参阅此标题所附的GitHub仓库）：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the code explanation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码解释：
- en: '`Task` interface: This defines the contract for the work units. Any class implementing
    this interface must have an `execute()` method that performs the actual work.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`接口：此接口定义了工作单元的合同。任何实现此接口的类都必须有一个`execute()`方法，该方法执行实际工作。'
- en: '`TaskQueue`: This class manages a queue of tasks using `BlockingQueue` for
    thread safety. `addTask()` allows the addition of tasks to the queue, and `getTask()`
    retrieves tasks for processing.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskQueue`：此类使用`BlockingQueue`来管理任务队列，以确保线程安全。`addTask()`允许将任务添加到队列中，而`getTask()`用于检索待处理任务。'
- en: '`LeaderThread`: This thread continuously retrieves tasks from the queue using
    `getTask()`. It then iterates through the list of followers and assigns the task
    to the first available Follower.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeaderThread`：此线程使用`getTask()`方法从队列中持续检索任务。然后，它遍历跟随者列表，并将任务分配给第一个可用的跟随者。'
- en: '`FollowerThread`: This thread processes tasks and signals its availability
    to the leader. The `isAvailable()` method allows the leader to check if a follower
    is ready for new work.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FollowerThread`：此线程处理任务，并向领导者信号其可用性。`isAvailable()`方法允许领导者检查跟随者是否准备好接受新工作。'
- en: This overview encapsulates the Leader-Follower pattern’s core logic. For a detailed
    exploration and the complete code, visit the GitHub repository accompanying this
    book. There, you’ll find extended functionalities and customization options, enabling
    you to tailor the implementation to your specific needs, such as electing a new
    leader or prioritizing urgent tasks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概述封装了领导者-跟随者模式的核心逻辑。要详细了解和获取完整代码，请访问此书所附的GitHub仓库。在那里，你可以找到扩展功能和定制选项，使你能够根据特定需求调整实现，例如选举新的领导者或优先处理紧急任务。
- en: Remember, this example serves as a foundation. You’re encouraged to expand upon
    it, integrating features such as dynamic leader election, task prioritization,
    and progress monitoring to build a robust task management system suited to your
    application’s requirements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个示例只是一个基础。我们鼓励你在此基础上扩展，集成动态领导者选举、任务优先级和进度监控等功能，以构建适合你应用程序需求的强大任务管理系统。
- en: Next, in *The Leader-Follower pattern in action*, we’ll see how this pattern
    empowers different real-world applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*行动中的领导者-跟随者模式*中，我们将看到这种模式如何赋予不同的实际应用以力量。
- en: The Leader-Follower pattern in action
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动中的领导者-跟随者模式
- en: 'The Leader-Follower pattern offers flexibility and adaptability for various
    distributed systems scenarios, particularly in cloud computing environments. Here
    are a few key use cases where it excels:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者-跟随者模式为各种分布式系统场景提供了灵活性和适应性，尤其是在云计算环境中。以下是一些它表现优异的关键用例：
- en: '**Scaling a cloud-based image processing service**: Imagine a service receiving
    numerous image manipulation requests. The leader thread monitors incoming requests,
    delegating them to available follower threads (worker servers). This distributes
    the workload, reduces bottlenecks, and improves response times.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展基于云的图像处理服务**：想象一个接收大量图像处理请求的服务。领导线程监控传入的请求，并将它们委派给可用的跟随线程（工作服务器）。这分配了工作负载，减少了瓶颈，并提高了响应时间。'
- en: '**Real-time data stream processing**: In applications handling continuous streams
    of data (e.g., sensor readings and financial transactions), a leader thread can
    receive incoming data and distribute it among follower threads for analysis and
    processing. This parallelization enables real-time insights by maximizing resource
    utilization.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据流处理**：在处理连续数据流的应用程序中（例如，传感器读数和金融交易），领导线程可以接收传入的数据并将其分配给跟随线程进行分析和处理。这种并行化通过最大化资源利用率实现了实时洞察。'
- en: '**Distributed job scheduling**: For systems with various computational tasks
    (e.g., scientific simulations and machine learning models), the Leader-Follower
    pattern promotes efficient distribution of these jobs across a cluster of machines.
    The leader coordinates task assignments based on resource availability, accelerating
    complex executions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式作业调度**：对于具有各种计算任务（例如，科学模拟和机器学习模型）的系统，领导-跟随模式促进了这些作业在机器集群中的有效分配。领导者根据资源可用性协调任务分配，加速复杂执行。'
- en: '**Work queue management**: In applications with unpredictable bursts of activity
    (e.g., e-commerce order processing), a leader thread can manage a central work
    queue and delegate tasks to follower threads as they become available. This design
    promotes responsiveness and optimizes resource usage during peak activity.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作队列管理**：在具有不可预测活动突发的应用程序中（例如，电子商务订单处理），领导线程可以管理中央工作队列，并在可用时将任务委派给跟随线程。这种设计促进了响应性，并在高峰活动期间优化了资源使用。'
- en: The Leader-Follower pattern’s core advantage lies in its ability to distribute
    workloads across multiple threads or processes. This distribution increases efficiency
    and scalability and is highly beneficial in cloud-based environments where resources
    can be scaled dynamically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 领导-跟随模式的核心理念在于其能够在多个线程或进程中分配工作负载。这种分配提高了效率和可扩展性，在资源可以动态扩展的云环境中非常有用。
- en: Picture our distributed system as a complex machine. The Leader-Follower pattern
    helps it run smoothly. But, like with any machine, parts can malfunction. The
    Circuit Breaker acts like a safety switch, preventing a single faulty component
    from bringing down the entire system. Let’s see how this protective mechanism
    operates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的分布式系统想象成一个复杂的机器。领导-跟随模式帮助它平稳运行。但是，就像任何机器一样，部分可能会出现故障。电路断路器就像一个安全开关，防止单个故障组件导致整个系统崩溃。让我们看看这个保护机制是如何运作的。
- en: The Circuit Breaker pattern – building resilience in cloud applications
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路断路器模式——在云应用程序中构建弹性
- en: Think of the Circuit Breaker pattern like its electrical counterpart—it prevents
    cascading failures in your distributed system. In cloud applications, where services
    rely on remote components, the **Circuit Breaker** pattern safeguards against
    the ripple effects of failing dependencies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将电路断路器模式想象成它的电气对应物——它防止了分布式系统中的级联故障。在云应用程序中，服务依赖于远程组件，**电路断路器**模式保护免受失败依赖的连锁反应。
- en: How it works? The Circuit Breaker monitors failures when calling a remote service.
    Once a failure threshold is crossed, the circuit *trips*. Tripping means calls
    to the remote service are blocked for a set amount of time. This timeout allows
    the remote service a chance to recover. During the timeout, your application can
    gracefully handle the error or use a fallback strategy. After the timeout, the
    circuit transitions to *half-open*, testing the service’s health with a limited
    number of requests. If those succeed, normal operation resumes; if they fail,
    the circuit reopens, and the timeout cycle begins again.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？电路断路器在调用远程服务时监控故障。一旦超过故障阈值，电路就会*跳闸*。跳闸意味着对远程服务的调用将被阻塞一段时间。这个超时允许远程服务有机会恢复。在超时期间，你的应用程序可以优雅地处理错误或使用回退策略。超时后，电路进入*半开*状态，通过有限数量的请求测试服务的健康状态。如果这些请求成功，则恢复正常操作；如果失败，电路重新打开，超时周期再次开始。
- en: 'Let’s look at the following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图示：
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| Closed | ------> | Open | ------> | Half-Open |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 关闭 | ------> | 开启 | ------> | 半开 |'
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| (Failure) | | (Success) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| （失败）| | （成功）|'
- en: v v v v
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: v v v v
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| Business as Usual | | Calls Blocked | | Probe Service |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 正常业务 | | 调用被阻塞 | | 探测服务 |'
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: '| (Timeout) | | (Failure) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| （超时）| | （失败）|'
- en: v v v v
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: v v v v
- en: +-------------------+ +-------------------+ +-------------------+
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: +-------------------+ +-------------------+ +-------------------+
- en: 'Figure 5.1: States of the Circuit Breaker'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：电路断路器状态
- en: 'The Circuit Breaker has three states:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器有三个状态：
- en: '**Closed**: This is the initial state. Calls to the service are allowed to
    flow through (business as usual).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：这是初始状态。对服务的调用允许正常流动（正常业务）。'
- en: '**Open**: This state is reached if the error threshold is hit (consecutive
    failures). Calls to the service are blocked, preventing further failures and giving
    the service time to recover.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启**：如果达到错误阈值（连续失败），则达到此状态。对服务的调用被阻止，防止进一步的失败，并给服务时间恢复。'
- en: '**Half-Open**: A single call is allowed through to probe the health of the
    service. If the call is successful, the circuit transitions back to *Closed*.
    However, if the call fails, the circuit transitions back to *Open*.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开式**：允许单个调用通过以探测服务的健康状态。如果调用成功，电路将转回**关闭**状态。然而，如果调用失败，电路将转回**开启**状态。'
- en: 'There are the following transition events:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些转换事件：
- en: '**Closed -> Open**: This transition occurs when the error threshold is reached'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭 -> 开启**：当达到错误阈值时发生此转换'
- en: '**Open -> Closed**: This transition occurs after a timeout period in the *Open*
    state (assuming the service has had enough time to recover)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启 -> 关闭**：在**开启**状态下经过超时期后发生此转换（假设服务已有足够时间恢复）'
- en: '**Open -> Half-Open**: This transition can be triggered manually or automatically
    after a configurable time in the *Open* state'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开启 -> 半开**：此转换可以在**开启**状态下手动或自动触发，触发时间可配置'
- en: '**Half-Open -> Closed**: This transition occurs if the probe call in the *Half-Open*
    state is successful'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开 -> 关闭**：如果**半开**状态中的探测调用成功，则发生此转换'
- en: '**Half-Open -> Open**: This transition occurs if the probe call in the *Half-Open*
    state fails'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开 -> 开启**：如果**半开**状态中的探测调用失败，则发生此转换'
- en: Next, we’ll demonstrate the Circuit Breaker pattern in Java, focusing on safeguarding
    an e-commerce application’s order service from failures in its service dependencies.
    The pattern acts as a state machine with *Closed*, *Open*, and *Half-Open* states,
    along with implementing a fallback strategy for handling operations when failures
    occur.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示Java中的电路断路器模式，重点关注保护电子商务应用的订单服务免受其服务依赖项失败的影响。该模式作为一个具有**关闭**、**开启**和**半开**状态的有限状态机，并在发生失败时实现回退策略来处理操作。
- en: 'First, we create the `CircuitBreakerDemo` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`CircuitBreakerDemo`类：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `CircuitBreakerDemo` class defines an `enum State` to represent the three
    states: `CLOSED`, `OPEN`, and `HALF_OPEN`. The class has fields to store the maximum
    number of failures allowed (`maxFailures`), the duration for which the circuit
    breaker remains open (`openDuration`), the duration between consecutive probe
    calls in the `HALF_OPEN` state (`retryDuration`), and a `Supplier` representing
    the service being monitored. The `constructor()` initializes the state to `CLOSED`
    and sets the provided configuration values.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircuitBreakerDemo`类定义了一个`enum State`来表示三种状态：`CLOSED`、`OPEN`和`HALF_OPEN`。该类有字段来存储允许的最大失败次数（`maxFailures`）、电路断路器保持开启的时间（`openDuration`）、在`HALF_OPEN`状态中连续探测调用之间的持续时间（`retryDuration`），以及表示正在监控的服务的一个`Supplier`。`constructor()`将状态初始化为`CLOSED`并设置提供的配置值。'
- en: 'Next, we create the `call()` method and state transitions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`call()`方法和状态转换：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code performs the following actions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下操作：
- en: The `call()` method is the entry point for making requests to the service.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call()`方法是向服务发出请求的入口点。'
- en: In the `CLOSED` state, it calls the `callService()` method and returns the result.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CLOSED`状态下，它调用`callService()`方法并返回结果。
- en: In the `OPEN` state, it blocks requests and transitions to the `HALF_OPEN` state
    after the `openDuration` has elapsed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OPEN`状态下，它阻止请求，并在`openDuration`经过后转换到`HALF_OPEN`状态。
- en: In the `HALF_OPEN` state, it sends a probe request by calling `callService()`.
    If the probe succeeds, it transitions to `CLOSED`; otherwise, it transitions back
    to `OPEN`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `HALF_OPEN` 状态下，它通过调用 `callService()` 发送探测请求。如果探测成功，它转换为 `CLOSED` 状态；否则，它转换回
    `OPEN` 状态。
- en: 'Lastly, we have a service call and failure handling:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个服务调用和故障处理：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code performs the following functions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下功能：
- en: The `callService()` method invokes the service’s `get()` method and returns
    the result.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callService()` 方法调用服务的 `get()` 方法并返回结果。'
- en: If the service call fails (returns false or throws an exception), the `handleFailure()`
    method is called.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务调用失败（返回false或抛出异常），则调用 `handleFailure()` 方法。
- en: The `handleFailure()` method increments the failure count (`failureCount`).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleFailure()` 方法增加失败计数 (`failureCount`)。'
- en: If the `failure count` reaches the maximum allowed (`maxFailures`), the state
    is transitioned to `OPEN`, and the `lastFailureTime` is updated.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `failure count` 达到最大允许值 (`maxFailures`)，状态将转换为 `OPEN`，并更新 `lastFailureTime`。
- en: Remember, this is a simplified illustration of the Circuit Breaker pattern.
    For the full implementation, including detailed state management and customizable
    thresholds, please check out the accompanying GitHub repository. Also, consider
    using robust libraries such as Resilience4j for production-ready solutions, and
    remember to tailor failure thresholds, timeouts, and fallback behaviors to match
    your specific application’s needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是一个简化的断路器模式说明。对于完整的实现，包括详细的状态管理和可定制的阈值，请查看附带的GitHub仓库。此外，考虑使用如Resilience4j之类的健壮库来提供生产就绪的解决方案，并记住根据特定应用程序的需求调整故障阈值、超时和回退行为。
- en: 'The key takeaway is to understand the pattern’s underlying logic: how it transitions
    between states, handles failures gracefully with fallbacks, and ultimately shields
    your services from cascading breakdowns.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是理解该模式的底层逻辑：它是如何在不同状态之间转换的，如何通过回退机制优雅地处理故障，并最终保护你的服务免受级联故障的影响。
- en: Unleashing resilience – Circuit Breaker use cases in the cloud
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激发弹性 - 云中断路器的用例
- en: 'The Circuit Breaker pattern can be used in the following situations:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式可以在以下情况下使用：
- en: '**Online retail overload**: Circuit breakers protect dependent services (e.g.,
    payment processing) during high-traffic events. They enable graceful degradation,
    provide time for service recovery, and help automate the restoration of service.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线零售过载**: 断路器在高峰流量事件期间保护依赖服务（例如，支付处理）不受影响。它们允许优雅降级，提供服务恢复的时间，并帮助自动化服务的恢复。'
- en: '**Real-time data processing**: Circuit breakers safeguard analytics systems
    if data sources become slow or unresponsive, preventing overload.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据处理**: 当数据源变慢或无响应时，断路器保护分析系统，防止过载。'
- en: '**Distributed job scheduling**: In job scheduling systems, circuit breakers
    prevent jobs from overwhelming failing resources, promoting overall system health.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式作业调度**: 在作业调度系统中，断路器防止作业压倒失败资源，促进整体系统健康。'
- en: To maximize resilience, proactively integrate circuit breakers into your distributed
    cloud application’s design. Strategically position them at service boundaries,
    implement robust fallback mechanisms (e.g., caching and queuing), and couple them
    with monitoring tools to track circuit states and fine-tune configurations. Remember
    to weigh the added complexity against the resilience gains for your specific application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化弹性，积极地将断路器集成到分布式云应用程序的设计中。在服务边界处战略性地定位它们，实现强大的回退机制（例如，缓存和排队），并将它们与监控工具结合使用，以跟踪断路器状态并微调配置。请记住，权衡为特定应用程序带来的额外复杂性与其弹性收益。
- en: The Bulkhead pattern – enhancing cloud application fault tolerance
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防波墙模式 - 提高云应用程序的容错性
- en: The **Bulkhead** pattern, drawing inspiration from the maritime industry, involves
    compartmentalizing sections of a ship’s hull to prevent it from sinking if one
    part fills with water. Similarly, in software architecture, the Bulkhead pattern
    isolates elements of an application into separate sections (bulkheads) to prevent
    failures in one part from cascading throughout the entire system. This pattern
    is particularly useful in distributed systems and microservices architectures,
    where different components handle various functionalities.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bulkhead**模式从海事行业汲取灵感，涉及将船体部分隔离开来，以防止某一部位进水后整个船体下沉。同样，在软件架构中，Bulkhead模式将应用程序的元素隔离到不同的部分（bulkheads），以防止某一部分的故障在整个系统中级联。这种模式在分布式系统和微服务架构中特别有用，因为不同的组件处理各种功能。'
- en: 'The Bulkhead pattern safeguards your applications by dividing them into isolated
    compartments. This does the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Bulkhead模式通过将应用程序分割成隔离的隔间来保护你的应用程序。这做到了以下几点：
- en: '**Prevents cascading failures**: If one component fails, others remain unaffected'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止级联故障**：如果一个组件失败，其他组件不受影响'
- en: '**Optimizes resources**: Each compartment gets its own resources, preventing
    one area from hogging them all'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源**：每个隔间都有自己的资源，防止一个区域占用所有资源'
- en: '**Boosts resilience**: Critical parts of your application stay functional even
    during problems'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强弹性**：即使出现问题时，应用程序的关键部分也能保持功能正常'
- en: '**Simplifies scaling**: Scale individual components independently as needed'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化扩展**：根据需要独立扩展单个组件'
- en: Let’s look at practical examples and dive into how to implement the Bulkhead
    pattern in Java microservices and your projects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际例子，深入了解如何在Java微服务和你的项目中实现Bulkhead模式。
- en: Imagine an e-commerce application with a recommendation engine. This engine
    might be resource-intensive. We want to protect other services (order processing
    and search) from being starved of resources if the recommendation feature experiences
    high traffic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个电子商务应用程序，其中包含一个推荐引擎。这个引擎可能资源密集。我们希望保护其他服务（订单处理和搜索）免受推荐功能高流量时的资源短缺。
- en: 'Here is a code snippet using Resilience4j:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用Resilience4j的代码片段：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is an explanation of the code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对代码的解释：
- en: '`recommendationServiceBulkhead`, limiting the number of concurrent calls to
    10.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendationServiceBulkhead`，限制并发调用次数为10。'
- en: '**Wrapping the call**: We decorate the call to the recommendation engine with
    the bulkhead.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装调用**：我们用bulkhead装饰对推荐引擎的调用。'
- en: '`BulkheadFullException` is thrown. Implement a fallback (e.g., display default
    products) to handle this gracefully.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出`BulkheadFullException`异常。实现一个回退机制（例如，显示默认产品）以优雅地处理这种情况。
- en: The Bulkhead pattern safeguards your application by isolating resources; in
    this example, we limit the recommendation service to only 10 concurrent calls.
    This strategy ensures that order processing remains unaffected even if the recommendation
    engine is overloaded. For enhanced visibility, integrate the bulkhead with a metrics
    system to track how often the limit is reached. Remember that Resilience4j offers
    a Bulkhead implementation, but you can also explore alternative libraries or design
    your own.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Bulkhead模式通过隔离资源来保护你的应用程序；在这个例子中，我们限制推荐服务的并发调用次数为10。这种策略确保即使推荐引擎过载，订单处理也不会受到影响。为了提高可见性，将bulkhead与度量系统集成以跟踪限制达到的频率。记住，Resilience4j提供了Bulkhead实现，但你也可以探索其他库或设计自己的。
- en: This code snippet demonstrates the Bulkhead pattern in action, showcasing how
    to isolate services within a single application. Now, let’s explore some essential
    use cases of this pattern in cloud environments that can significantly enhance
    your system’s resilience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了Bulkhead模式的应用，展示了如何在单个应用程序中隔离服务。现在，让我们探索一些在云环境中至关重要的Bulkhead模式使用案例，这些案例可以显著增强你的系统弹性。
- en: Essential Bulkhead pattern use cases in cloud environments
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云环境中关键Bulkhead模式的使用案例
- en: 'Let’s focus on some highly practical use cases of the Bulkhead pattern in cloud
    environments that you would find immediately valuable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一些在云环境中高度实用的Bulkhead模式使用案例，这些案例将立即对你有价值：
- en: '**Multi-tenant applications**: Isolate tenants within a shared cloud application.
    This ensures that one tenant’s heavy usage won’t starve resources for others,
    guaranteeing fairness and consistent performance. Consider a multi-tenant e-commerce
    application. Each tenant (store) has its own product catalog, customer data, and
    order processing tasks. Using the Bulkhead pattern, each store would have a dedicated
    database connection pool for its product and customer data, separate message queues
    would be used for processing orders for each store, and there could be thread
    pools dedicated to handling order processing tasks for specific stores. This ensures
    that a surge in activity from one store won’t affect the performance of other
    stores in the application.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多租户应用程序**：在共享云应用程序中隔离租户。这确保了一个租户的密集使用不会使其他租户的资源枯竭，保证了公平性和一致的性能。考虑一个多租户电子商务应用程序。每个租户（商店）都有自己的产品目录、客户数据和订单处理任务。使用隔舱模式，每个商店都会为其产品和客户数据拥有一个专用的数据库连接池，为每个商店处理订单会使用单独的消息队列，还可能有专门用于处理特定商店订单处理任务的线程池。这确保了一个商店活动激增不会影响应用程序中其他商店的性能。'
- en: '**Mixed workload environments**: Separate critical services from less-critical
    ones (e.g., production batch jobs versus real-time user requests). Bulkheads ensure
    that lower-priority workloads don’t cannibalize resources needed by critical services.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合工作负载环境**：将关键服务与不那么关键的服务分开（例如，生产批处理作业与实时用户请求）。隔舱确保低优先级的工作负载不会蚕食关键服务所需的资源。'
- en: '**Unpredictable traffic**: Protect systems against sudden traffic spikes to
    specific components. Bulkheads isolate the impact, preventing a surge in one area
    from causing a total collapse.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可预测的流量**：保护系统免受特定组件突然流量激增的影响。隔舱隔离影响，防止一个区域的激增导致整体崩溃。'
- en: '**Microservice architectures**: A core principle in microservices! Bulkheads
    limit cascading failures. If one microservice fails, bulkheads help to prevent
    that failure from rippling through the entire application.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：微服务的一个核心原则！隔舱限制级联故障。如果一个微服务失败，隔舱有助于防止该故障在整个应用程序中蔓延。'
- en: 'When implementing the Bulkhead pattern, pay close attention to these key considerations:
    decide the granularity of isolation (service level, endpoint level, etc.) and
    meticulously configure bulkhead sizes (max calls and queues) based on thorough
    workload analysis. Always design robust fallback strategies (such as caching or
    default responses) for when bulkheads reach capacity. The Bulkhead pattern complements
    the cloud’s advantages—use it to dynamically scale isolated compartments and add
    a vital layer of resilience in your distributed cloud applications, where network
    reliance can increase the chances of failure.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现隔舱模式时，请密切关注以下关键考虑因素：决定隔离的粒度（服务级别、端点级别等）并根据彻底的工作负载分析仔细配置隔舱大小（最大调用和队列）。始终为隔舱达到容量时设计强大的回退策略（如缓存或默认响应）。隔舱模式补充了云的优势——使用它来动态扩展隔离的舱室，并在你的分布式云应用程序中添加一个至关重要的弹性层，其中网络依赖性可能会增加失败的机会。
- en: Java concurrency patterns for asynchronous operations and distributed communications
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发模式用于异步操作和分布式通信
- en: 'In this section, we’ll explore three crucial patterns that transform applications:
    the Producer-Consumer pattern for efficient data exchange, the Scatter-Gather
    pattern for distributed systems, and the Disruptor pattern for high-performance
    messaging. We’ll analyze each pattern and provide Java implementations, use cases,
    and their benefits in real-world cloud architectures emphasizing asynchronous
    operations and distributed communications.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三个关键模式，这些模式可以改变应用程序：用于高效数据交换的生产者-消费者模式、用于分布式系统的散列-收集模式以及用于高性能消息传递的破坏者模式。我们将分析每个模式，并提供Java实现、用例以及它们在现实世界云架构中的好处，强调异步操作和分布式通信。
- en: The Producer-Consumer pattern – streamlining data flow
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产者-消费者模式——简化数据流
- en: The **Producer-Consumer** pattern is a fundamental design pattern that addresses
    the mismatch between the rate of data generation and data processing. It decouples
    the producers, which generate tasks or data, from the consumers, which process
    those tasks or data, often asynchronously using a shared queue as a buffer. This
    pattern offers several benefits, particularly in cloud and distributed architectures,
    but it also introduces the need to handle the producer-consumer mismatch problem
    effectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产者-消费者模式（Producer-Consumer pattern）**是一种基本的设计模式，用于解决数据生成速率与数据处理速率之间的不匹配问题。它将生成任务或数据的生产者与处理这些任务或数据的消费者解耦，通常异步地使用共享队列作为缓冲。这种模式提供了几个好处，尤其是在云和分布式架构中，但它也引入了有效处理生产者-消费者不匹配问题的需求。'
- en: 'The producer-consumer mismatch occurs when the rate of data production differs
    from the rate of data consumption. This mismatch can lead to two potential issues:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据生产速率与数据消费速率不同时，就会发生生产者-消费者不匹配。这种不匹配可能导致两个潜在问题：
- en: '**Overproduction**: If the producers generate data faster than the consumers
    can process it, the shared queue can become overwhelmed, leading to increased
    memory usage, potential out-of-memory errors, and overall system instability.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度生产（Overproduction）**: 如果生产者生成数据的速度超过消费者处理的速度，共享队列可能会过载，导致内存使用增加、潜在的内存不足错误以及整体系统不稳定。'
- en: '**Underproduction**: If the producers generate data slower than the consumers
    can process it, the consumers may become idle, leading to underutilized resources
    and reduced system throughput.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欠生产（Underproduction）**: 如果生产者生成数据的速度慢于消费者处理的速度，消费者可能会变得空闲，导致资源利用率低和系统吞吐量降低。'
- en: 'To address the producer-consumer mismatch problem, several strategies can be
    employed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决生产者-消费者不匹配问题，可以采用以下几种策略：
- en: '**Backpressure**: Implementing backpressure mechanisms allows consumers to
    signal to producers when they are overwhelmed, prompting producers to slow down
    or pause data generation temporarily. This helps prevent the shared queue from
    becoming overloaded and ensures a balanced flow of data.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背压（Backpressure）**: 实施背压机制允许消费者在过载时向生产者发出信号，促使生产者暂时减缓或暂停数据生成。这有助于防止共享队列过载，并确保数据流量的平衡。'
- en: '**Queue size management**: Configuring the shared queue with an appropriate
    size limit can prevent unbounded memory growth in the case of overproduction.
    When the queue reaches its maximum size, producers can be blocked or data can
    be dropped, depending on the specific requirements of the system.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列大小管理（Queue size management）**: 配置共享队列以适当的尺寸限制可以防止过度生产时的无界内存增长。当队列达到最大大小时，根据系统的具体要求，生产者可能会被阻塞或数据可能会被丢弃。'
- en: '**Dynamic scaling**: In cloud and distributed environments, dynamically scaling
    the number of producers or consumers based on the observed load can help maintain
    a balanced data flow. Additional producers can be launched when data generation
    is high, and more consumers can be added when data processing lags behind.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态扩展（Dynamic scaling）**: 在云和分布式环境中，根据观察到的负载动态扩展生产者或消费者的数量可以帮助保持数据流量的平衡。当数据生成量高时可以启动额外的生产者，当数据处理滞后时可以添加更多的消费者。'
- en: '**Load shedding**: In extreme cases, when the system is overloaded and cannot
    keep up with the incoming data, load shedding techniques can be employed to selectively
    drop or discard lower-priority data or tasks, ensuring that the most critical
    data is processed first.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载削减（Load shedding）**: 在极端情况下，当系统过载且无法跟上 incoming 数据时，可以采用负载削减技术来选择性地丢弃或丢弃低优先级的数据或任务，确保最关键的数据首先被处理。'
- en: '**Monitoring and alerting**: Implementing monitoring and alerting mechanisms
    can provide visibility into the data flow rates and queue lengths, allowing timely
    intervention or automatic scaling when imbalances are detected.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和警报（Monitoring and alerting）**: 实施监控和警报机制可以提供对数据流速率和队列长度的可见性，以便在检测到不平衡时及时干预或自动扩展。'
- en: By effectively managing the producer-consumer mismatch problem, the Producer-Consumer
    pattern can offer several advantages, such as decoupling, workload balancing,
    asynchronous flow, and improved performance through concurrency. It is the cornerstone
    of building robust and scalable applications where efficient data flow management
    is crucial, particularly in cloud and distributed architectures where components
    may not be immediately available, and workloads can vary dynamically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效管理生产者-消费者不匹配问题，生产者-消费者模式可以提供一些优势，如解耦、工作负载平衡、异步流程和通过并发提高性能。它是构建健壮和可扩展应用程序的基础，在这些应用程序中，有效的数据流管理至关重要，尤其是在云和分布式架构中，组件可能不是立即可用的，并且工作负载可以动态变化。
- en: The Producer-Consumer pattern in Java – a real-world example
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的生产者-消费者模式 – 一个真实世界的例子
- en: 'Let’s explore a practical example of how the Producer-Consumer pattern can
    be applied in a cloud-based image processing system, where the goal is to generate
    thumbnails for uploaded images asynchronously:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一个实际例子，说明生产者-消费者模式如何在基于云的图像处理系统中应用，其目标是异步生成上传图像的缩略图：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code demonstrates the Producer-Consumer pattern in the context of a cloud-based
    thumbnail generation system. Let’s break down how the pattern works in this example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了在基于云的缩略图生成系统中生产者-消费者模式的应用。让我们分析一下在这个例子中模式是如何工作的：
- en: '**Producer**:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**:'
- en: The *producer* uploads images to an S3 bucket and sends messages to an *SQS
    queue*
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者** 将图像上传到 S3 桶并向 `SQS 队列` 发送消息'
- en: Each message contains information about the uploaded image, such as the image
    key
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条消息都包含有关上传图像的信息，例如图像键
- en: '`ThumbnailGenerator` class acts as the consumer and handles SQS events'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThumbnailGenerator` 类作为消费者处理 SQS 事件'
- en: When an `SQS event` is triggered, the `handleRequest()` method is invoked
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `SQS 事件` 触发时，`handleRequest()` 方法被调用
- en: '`handleRequest()` method receives an `SQSEvent` object representing the message
    from the SQS queue*   The `extractImageKey()` method extracts the `image key`
    from the `SQS event`*   `consumer` retrieves the image from the S3 bucket using
    the `image key`*   The `image` is loaded, resized while maintaining its aspect
    ratio, and saved as a JPEG*   The resized image bytes are stored in a `ByteArrayOutputStream`*   **Thumbnail
    upload**:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleRequest()` 方法接收一个表示来自 SQS 队列消息的 `SQSEvent` 对象*   `extractImageKey()`
    方法从 `SQS 事件` 中提取 `image key`*   `consumer` 使用 `image key` 从 S3 桶中检索图像*   `image`
    被加载，在保持其宽高比的同时进行缩放，并保存为 JPEG 格式*   缩放后的图像字节被存储在 `ByteArrayOutputStream` 中*   **缩略图上传**:'
- en: The generated thumbnail bytes are uploaded to a separate S3 bucket
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的缩略图字节被上传到单独的 S3 桶
- en: The thumbnail is stored with a key that includes the original image key and
    a *thumbnail.jpg* suffix*   `handleRequest()` method returns `null`, indicating
    no response is sent back to the producer*   This allows the `consumer` to process
    messages asynchronously, without blocking the producer
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩略图使用包含原始图像键和 `*thumbnail.jpg` 后缀的键进行存储*   `handleRequest()` 方法返回 `null`，表示没有向生产者发送响应*   这允许
    `consumer` 异步处理消息，而不会阻塞生产者
- en: This code demonstrates how the Producer-Consumer pattern enables asynchronous
    processing of image thumbnails in a cloud environment. The producer uploads images
    and sends messages, while the consumer processes the messages, generates thumbnails,
    and uploads them to a separate S3 bucket. This decoupling allows scalable and
    efficient image processing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了生产者-消费者模式如何在云环境中异步处理图像缩略图。生产者上传图像并发送消息，而消费者处理消息，生成缩略图并将它们上传到单独的 S3 桶。这种解耦允许可扩展和高效的图像处理。
- en: Next, we will delve into the practical use cases of the Producer-Consumer pattern
    within cloud architectures.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解生产者-消费者模式在云架构中的实际应用案例。
- en: The Producer-Consumer pattern – a foundation for efficient, scalable cloud systems
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产者-消费者模式 – 高效、可扩展云系统的基础
- en: 'Here is a list of high-value use cases of the Producer-Consumer pattern within
    cloud environments:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生产者-消费者模式在云环境中的一些高价值用例列表：
- en: '**Task offloading and distribution**: Decouple a computationally intensive
    process (image processing, video transcoding, etc.) from the main application.
    This allows scaling worker components independently to handle varying loads without
    impacting the primary application’s responsiveness.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务卸载和分配**：将计算密集型过程（图像处理、视频转码等）从主应用程序中解耦。这允许独立扩展工作组件以处理不同的负载，而不会影响主应用程序的响应性。'
- en: '**Microservice communication**: In microservice architectures, the Producer-Consumer
    pattern facilitates asynchronous communication between services. Services can
    produce messages without needing immediate responses, enhancing modularity and
    resilience.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务通信**：在微服务架构中，Producer-Consumer 模式促进了服务之间的异步通信。服务可以产生消息而无需立即响应，增强了模块化和弹性。'
- en: '**Event-driven processing**: Design highly reactive cloud systems. Sensors,
    log streams, and user actions can trigger events, leading producers to generate
    messages that trigger downstream processing in a scalable way.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动处理**：设计高度反应性的云系统。传感器、日志流和用户操作可以触发事件，导致生产者生成消息，以可扩展的方式触发下游处理。'
- en: '**Data pipelines**: Build multi-stage data processing workflows. Each stage
    can act as a consumer and a producer, enabling complex data transformations that
    operate asynchronously.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管道**：构建多阶段数据处理工作流程。每个阶段都可以充当消费者和生产者，实现复杂的数据转换，这些转换可以异步操作。'
- en: The Producer-Consumer pattern offers significant benefits in cloud environments.
    It enables flexible scaling by allowing independent scaling of producers and consumers,
    ideal for handling unpredictable traffic. The pattern enhances system resilience
    with its queueing mechanism, preventing failures from cascading in the event of
    temporary component unavailability. It also encourages clean modular design through
    loose coupling, as components communicate indirectly. Finally, it promotes efficient
    resource usage by ensuring consumers process tasks only when they have capacity,
    optimizing resource allocation in dynamic cloud environments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Producer-Consumer 模式在云环境中提供了显著的好处。它通过允许生产者和消费者独立扩展，实现了灵活的扩展，非常适合处理不可预测的流量。该模式通过其队列机制增强了系统弹性，防止在临时组件不可用的情况下故障级联。它还通过松耦合鼓励了干净的模块化设计，因为组件通过间接通信。最后，它通过确保消费者仅在具有容量时处理任务，从而提高了资源使用效率，优化了动态云环境中的资源分配。
- en: 'The Scatter-Gather pattern: distributed processing powerhouse'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scatter-Gather 模式：分布式处理动力源泉
- en: The **Scatter-Gather** pattern optimizes parallel processing in distributed
    systems by dividing a large task into smaller subtasks (scatter phase). These
    subtasks are then processed concurrently across multiple nodes. Finally, the results
    are collected and combined (gather phase) to produce the final output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scatter-Gather** 模式通过将大任务分割成更小的子任务（scatter 阶段）来优化分布式系统中的并行处理。然后，这些子任务在多个节点上并发处理。最后，收集并合并结果（gather
    阶段）以生成最终输出。'
- en: 'The core concept involves the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 核心概念涉及以下内容：
- en: '**Scatter**: A coordinator splits a task into independent subtasks'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scatter**：协调器将任务分割成独立的子任务'
- en: '**Parallel processing**: Subtasks are distributed for concurrent execution'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行处理**：子任务被分配以进行并发执行'
- en: '**Gather**: The coordinator collects partial results'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gather**：协调器收集部分结果'
- en: '**Aggregation**: Results are combined into the final output'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：结果合并为最终输出'
- en: 'Its key benefits are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其关键好处如下：
- en: '**Improved performance**: Parallel processing significantly reduces execution
    time'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的性能**：并行处理显著减少了执行时间'
- en: '**Scalability**: Easily add more processing nodes to handle larger workloads'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：可以轻松添加更多处理节点以处理更大的工作负载'
- en: '**Flexibility**: Subtasks can run on nodes with specific capabilities'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：子任务可以运行在具有特定能力的节点上'
- en: '**Fault tolerance**: Potential for reassigning subtasks if a node fails'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：如果节点失败，可以重新分配子任务'
- en: This pattern is ideal for distributed systems and cloud environments where tasks
    can be parallelized for faster execution and dynamic resource allocation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式非常适合分布式系统和云环境，在这些环境中，任务可以并行化以实现更快的执行和动态资源分配。
- en: Next, we will explore how to apply Scatter-Gather in a specific use case!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在特定用例中应用 Scatter-Gather！
- en: Implementing Scatter-Gather in Java with ExecutorService
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ExecutorService 在 Java 中实现 Scatter-Gather
- en: Here’s a compact Java example that illustrates the Scatter-Gather pattern, tailored
    for an AWS environment. This example conceptually demonstrates how you might use
    AWS Lambda functions (as the scatter phase) to perform parallel processing of
    tasks and then gather the results. It uses AWS SDK for Java to interact with AWS
    services such as Lambda and S3 for simplicity in code demonstration. Please note
    that this example assumes you have a basic setup done in AWS, such as Lambda functions
    and S3 buckets in place.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个紧凑的 Java 示例，说明了 Scatter-Gather 模式，针对 AWS 环境进行了定制。这个例子从概念上展示了您如何使用 AWS Lambda
    函数（作为分散阶段）来执行任务的并行处理，然后汇总结果。它使用 AWS SDK for Java 与 AWS 服务（如 Lambda 和 S3）进行交互，以简化代码演示。请注意，此示例假设您已在
    AWS 中完成基本设置，例如 Lambda 函数和 S3 桶。
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code demonstrates the Scatter-Gather pattern using AWS services for distributed
    task processing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了使用 AWS 服务进行分布式任务处理的 Scatter-Gather 模式：
- en: '`ExecutorService`) is created to match the number of tasks'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`) 被创建以匹配任务数量'
- en: 'Each task is submitted to the pool. Within each task, we have the following:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务都提交到池中。在每一个任务中，我们有以下内容：
- en: An `InvokeRequest` is prepared for an AWS Lambda function, carrying the task
    data
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 AWS Lambda 函数准备了一个 `InvokeRequest`，携带任务数据
- en: The Lambda function is invoked (`lambdaClient.invoke(...)`)
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 Lambda 函数（`lambdaClient.invoke(...)`)
- en: '`Future<InvokeResult>` holds references to the pending Lambda execution results*   The
    code iterates over the futures list and retrieves the `InvokeResult` for each
    task using `future.get()`*   Lambda results are processed (assuming the payload
    is a string) and collected into a list*   **Aggregation (optional)**:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future<InvokeResult>` 包含对挂起的 Lambda 执行结果的引用*   代码遍历 futures 列表，并使用 `future.get()`
    获取每个任务的 `InvokeResult`*   Lambda 结果被处理（假设有效负载是字符串）并收集到一个列表中*   **聚合（可选）**：'
- en: The collected results are joined into a single string
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集到的结果被合并成一个字符串
- en: The aggregated result is stored in an S3 bucket
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总的结果存储在 S3 桶中
- en: This code exemplifies the Scatter-Gather pattern by distributing tasks to AWS
    Lambda functions for parallel execution (scatter), awaiting their completion,
    and then aggregating the results (gather). The use of AWS Lambda highlights the
    pattern’s compatibility with cloud-native technologies. For a production-ready
    implementation, it’s crucial to incorporate robust error handling, timeout mechanisms,
    and proper resource management to ensure system resilience.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过将任务分配给 AWS Lambda 函数以并行执行（分散），等待它们完成，然后汇总结果（聚集）来展示 Scatter-Gather 模式。使用
    AWS Lambda 突出了该模式与云原生技术的兼容性。为了实现生产就绪的实施，关键是要包含强大的错误处理、超时机制和适当的资源管理，以确保系统弹性。
- en: Next, we will delve into the practical use cases.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨其实际应用案例。
- en: Practical applications of Scatter-Gather in cloud environments
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scatter-Gather 在云环境中的实际应用
- en: 'Here’s a breakdown of practical applications where the Scatter-Gather pattern
    excels within cloud environments:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，Scatter-Gather 模式在以下实际应用中表现出色：
- en: '**High-performance computation**:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能计算**：'
- en: '**Scientific simulations**: Break down complex simulations into smaller, independent
    sub-calculations that can be distributed across a cluster of machines or serverless
    functions for parallel execution.'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**科学模拟**：将复杂的模拟分解成更小、独立的子计算，可以在机器集群或无服务器函数上分布式并行执行。'
- en: '**Financial modeling**: Apply Monte Carlo simulations or complex risk models
    in parallel to a large dataset, significantly reducing computation time.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金融建模**：将蒙特卡洛模拟或复杂的风险模型并行应用于大型数据集，显著减少计算时间。'
- en: '**Machine learning (model training)**: Distribute the training of machine learning
    models across multiple GPUs or instances. Each worker trains on a subset of the
    data, and results are aggregated to update the global model.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习（模型训练）**：将机器学习模型的训练分布在多个 GPU 或实例上。每个工作器在数据子集上训练，并将结果汇总以更新全局模型。'
- en: '**Large-scale** **data processing**:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大规模** **数据处理**：'
- en: '**Batch processing**: Divide large datasets into smaller chunks for parallel
    processing. This is useful for tasks such as **Extract, Transform, Load**(**ETL**)
    pipelines in data warehouses.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**：将大型数据集划分为更小的块以进行并行处理。这对于数据仓库中的 **提取、转换、加载**(**ETL**) 管道等任务非常有用。'
- en: '**MapReduce-style operations**: Implement custom MapReduce-like frameworks
    in the cloud. Split a large input, have workers process in parallel (map), and
    gather results to be combined (reduce).'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MapReduce 风格操作**：在云中实现自定义 MapReduce 类似框架。分割大输入，让工作者并行处理（映射），然后收集结果以进行组合（减少）。'
- en: '**Web crawling**: Distribute web page crawling tasks across multiple nodes
    (avoiding overwhelming individual websites), then combine results into a searchable
    index.'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网页爬取**：将网页爬取任务分配到多个节点（避免压倒单个网站），然后将结果组合成一个可搜索的索引。'
- en: '**Real-time or** **event-driven workflows**:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时或** **事件驱动工作流**：'
- en: '**Fan-out processing**: An event (e.g., an IoT device reading) triggers multiple
    parallel actions. These could include sending notifications, updating databases,
    or initiating calculations. Results are then potentially aggregated.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扇出处理**：一个事件（例如，物联网设备读取）触发多个并行操作。这些可能包括发送通知、更新数据库或启动计算。然后可能对结果进行聚合。'
- en: '**Microservices request-response**: A client request sent to an API Gateway
    might require calling multiple backend microservices in parallel, potentially
    with each service responsible for a different data source. Gather responses to
    provide a comprehensive response to the client.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务请求/响应**：发送到 API 网关的客户端请求可能需要并行调用多个后端微服务，每个服务可能负责不同的数据源。收集响应以向客户端提供全面的响应。'
- en: The Scatter-Gather pattern is a powerful tool in your cloud development toolkit.
    Consider it when you need to accelerate computationally intensive tasks, process
    massive datasets, or architect responsive event-driven systems. Experiment with
    this pattern and witness the efficiency gains it brings to your cloud applications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Scatter-Gather 模式是您云开发工具包中的强大工具。当您需要加速计算密集型任务、处理大量数据集或构建响应式事件驱动系统时考虑它。尝试这个模式并见证它为您云应用程序带来的效率提升。
- en: The Disruptor pattern – streamlined messaging for low-latency applications
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Disruptor 模式 – 为低延迟应用程序提供简化的消息传递
- en: 'The **Disruptor** pattern is a high-performance messaging and event processing
    framework designed to achieve exceptionally low latency. Its key elements are
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Disruptor** 模式是一个高性能的消息和事件处理框架，旨在实现极低的延迟。其关键元素如下：'
- en: '**Ring buffer**: A pre-allocated circular data structure where producers place
    events and consumers retrieve them. This prevents dynamic memory allocation and
    garbage collection overheads.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环形缓冲区**：一个预先分配的循环数据结构，其中生产者放置事件，消费者检索它们。这防止了动态内存分配和垃圾回收开销。'
- en: '**Lock-Free design**: The Disruptor pattern employs sequence numbers and atomic
    operations to eliminate the need for traditional locking, boosting concurrency
    and reducing latency.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无锁设计**：Disruptor 模式通过使用序列号和原子操作来消除传统锁的需求，从而提高并发性和降低延迟。'
- en: '**Batching**: Events are processed in batches for increased efficiency, minimizing
    context switching and cache misses.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**：事件以批处理方式处理以提高效率，最小化上下文切换和缓存未命中。'
- en: '**Multi-producer/consumer**: The pattern supports multiple producers and consumers
    working concurrently, crucial for scalable distributed systems.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多生产者/消费者**：该模式支持多个生产者和消费者同时工作，这对于可扩展的分布式系统至关重要。'
- en: 'Let’s look at *Figure 5**.2*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *图 5.2*：
- en: A[Producer] --> B {Claim slot}
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: A[生产者] --> B {请求槽位}
- en: B --> C {Check availability}
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: B --> C {检查可用性}
- en: C --> D {Wait (Optional)}
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: C --> D {等待（可选）}
- en: C --> E {Reserve slot (sequence number)}
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: C --> E {预留槽位（序列号）}
- en: E --> F {Publish event}
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: E --> F {发布事件}
- en: F --> G {Update sequence number}
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: F --> G {更新序列号}
- en: G --> H {Notify consumers}
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: G --> H {通知消费者}
- en: H --> I [Consumer]
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: H --> I [消费者]
- en: I --> J {Check sequence}
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: I --> J {检查序列}
- en: J --> K {Process events (up to sequence)}
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: J --> K {处理事件（至序列）}
- en: K --> L {Update consumer sequence}
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: K --> L {更新消费者序列}
- en: L --> I
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: L --> I
- en: 'Figure 5.2: Disruptor pattern flowchart (left-right)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：Disruptor 模式流程图（从左到右）
- en: 'Here is an explanation of the Disruptor pattern flowchart:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Disruptor 模式流程图的解释：
- en: The producer initiates the process by claiming a slot in the ring buffer (A
    --> B).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产者通过在环形缓冲区中请求一个槽位来启动流程（A --> B）。
- en: The Disruptor checks if a slot is available (B --> C).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Disruptor 检查槽位是否可用（B --> C）。
- en: If a slot is unavailable, the producer might wait (C --> D).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果槽位不可用，生产者可能会等待（C --> D）。
- en: If a slot is available, the producer reserves a slot using a sequence number
    (C --> E).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果槽位可用，生产者使用序列号预留一个槽位（C --> E）。
- en: The event data is published to the reserved slot (E --> F).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件数据被发布到预留槽位（E --> F）。
- en: The sequence number is updated atomically (F --> G).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列号以原子方式更新（F --> G）。
- en: Consumers are notified about the updated sequence (G --> H).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者被通知关于更新的序列（G --> H）。
- en: A consumer wakes up and checks the latest sequence (H --> I, J).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个消费者醒来并检查最新的序列（H --> I, J）。
- en: The consumer processes events in a batch up to the available sequence (J -->
    K).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者以批处理方式处理事件，直到可用的序列（J --> K）。
- en: The consumer’s sequence number is updated (K --> L).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者的序列号被更新（K --> L）。
- en: The process loops back for the consumer to check for new events (L --> I)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流程会循环回消费者以检查新事件（L --> I）
- en: The Disruptor pattern delivers remarkable performance benefits. It’s known for
    its ability to process millions of events per second, achieving ultra-low latency
    with processing times in the microsecond range. This exceptional performance makes
    it ideal for use cases such as financial trading systems, real-time analytics
    platforms, and high-volume event processing scenarios such as IoT or log analysis.
    The Disruptor pattern outperforms traditional queue-based approaches when speed
    and low latency are critical requirements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Disruptor模式提供了显著的性能优势。它以其每秒处理数百万事件的能力而闻名，以微秒级的处理时间实现了超低延迟。这种卓越的性能使其非常适合金融交易系统、实时分析平台以及物联网或日志分析等高容量事件处理场景。当速度和低延迟是关键要求时，Disruptor模式优于传统的基于队列的方法。
- en: Now we will explore a practical implementation to see how the Disruptor pattern
    is used in specific cloud-based applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索一个实际实现，以了解Disruptor模式在特定云应用中的使用。
- en: Disruptor in cloud environments – real-time stock market data processing
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云环境中的Disruptor – 实时股票市场数据处理
- en: Let’s explore how the Disruptor pattern is used in cloud-based applications.
    We’ll use a simplified example to illustrate the key concepts, understanding that
    production-ready implementations will involve greater detail.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索在云应用中如何使用Disruptor模式。我们将使用一个简化的例子来说明关键概念，理解到生产就绪的实现将涉及更多的细节。
- en: Imagine a system that needs to ingest a continuous stream of stock price updates
    and perform real-time calculations (e.g., moving averages and technical indicators).
    These calculations must be lightning-fast to enable rapid trading decisions. How
    does the Disruptor fit in? Here is a simple Java example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个需要持续摄入股票价格更新并执行实时计算（例如，移动平均和技术指标）的系统。这些计算必须非常快，以便能够快速做出交易决策。Disruptor如何适应？以下是一个简单的Java示例。
- en: 'First, to use the Disruptor library in your Java project with Maven, you need
    to add the following dependency to your `pom.xml` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要在使用Maven的Java项目中使用Disruptor库，您需要将以下依赖项添加到您的`pom.xml`文件中：
- en: '[PRE8]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we create an event class, `StockPriceEvent`, and a `MovingAverageCalculator`
    class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个事件类，`StockPriceEvent`，和一个`MovingAverageCalculator`类：
- en: '[PRE9]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the above code snippet, the `StockPriceEvent` class represents the event
    that will be processed by the `Disruptor`. It contains fields for the stock symbol,
    timestamp, and price.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`StockPriceEvent`类代表了将被`Disruptor`处理的事件。它包含股票符号、时间戳和价格字段。
- en: The `MovingAverageCalculator` class implements the `EventHandler` interface
    and acts as a consumer for the `StockPriceEvent`. It calculates the moving average
    of the stock prices as events are processed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovingAverageCalculator`类实现了`EventHandler`接口，并作为`StockPriceEvent`的消费者。它在处理事件时计算股票价格的移动平均。'
- en: 'Finally, we create the `DisruptorExample` class:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建`DisruptorExample`类：
- en: '[PRE10]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code demonstrates the Disruptor pattern for low-latency processing of
    stock price updates with a moving average calculation as a consumer. Let’s break
    down the key steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了使用移动平均计算作为消费者进行低延迟处理股票价格更新的Disruptor模式。让我们分解关键步骤：
- en: '`bufferSize`: Defines the size of the pre-allocated ring buffer where events
    (stock price updates) are stored. This prevents memory allocation overhead during
    runtime.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufferSize`：定义了预先分配的环形缓冲区的大小，其中存储事件（股票价格更新）。这防止了在运行时内存分配开销。'
- en: '`executor`: A thread pool responsible for executing event handlers (consumers)
    concurrently.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executor`：一个线程池，负责并发执行事件处理器（消费者）。'
- en: '`producerType`: Set to `ProducerType.MULTI` to allow multiple sources (producers)
    to publish stock price updates concurrently.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`producerType`：设置为`ProducerType.MULTI`以允许多个来源（生产者）并发发布股票价格更新。'
- en: '`waitStrategy`: A `BlockingWaitStrategy` is used here. This strategy causes
    producers to wait if the ring buffer is full, ensuring no data loss.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitStrategy`：这里使用的是`BlockingWaitStrategy`。这种策略会在环形缓冲区满时使生产者等待，确保没有数据丢失。'
- en: '`Disruptor<StockPriceEvent>`: An instance of the `Disruptor` class is created,
    specifying the event type (`StockPriceEvent`). This Disruptor object manages the
    entire event processing pipeline.*   `disruptor.handleEventsWith(new MovingAverageCalculator())`:
    This line adds the `MovingAverageCalculator` class as an event handler (consumer)
    to the Disruptor. The consumer will be invoked for each published stock price
    update event.*   `disruptor.start()`: Starts the Disruptor, initializing the ring
    buffer and consumer threads.*   `for` loop simulates 100 stock price updates for
    the symbol `"AAPL"` with random prices.*   `disruptor.publishEvent(...)`: This
    line publishes each event to the `Disruptor` using a lambda function. The lambda
    calls `eventWriter.onData(event)` to populate the event data in the ring buffer.*   `Producers`
    (simulated in this example) publish stock price update events to the Disruptor’s
    ring buffer.*   The `Disruptor` assigns sequence numbers to events and makes them
    available to consumers.*   The `MovingAverageCalculator` consumer concurrently
    processes these events, updating the moving average based on each stock price.*   The
    Disruptor’s lock-free design ensures efficient event handling and prevents bottlenecks
    caused by traditional locking mechanisms.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disruptor<StockPriceEvent>`：创建了一个`Disruptor`类的实例，指定了事件类型（`StockPriceEvent`）。此Disruptor对象管理整个事件处理管道。*   `disruptor.handleEventsWith(new
    MovingAverageCalculator())`：这一行将`MovingAverageCalculator`类作为事件处理器（消费者）添加到Disruptor中。消费者将为每个发布的股票价格更新事件调用。*   `disruptor.start()`：启动Disruptor，初始化环形缓冲区和消费者线程。*   `for`循环模拟了100次针对符号`"AAPL"`的随机股票价格更新。*   `disruptor.publishEvent(...)`：这一行使用lambda函数将每个事件发布到Disruptor中。lambda调用`eventWriter.onData(event)`以填充环形缓冲区中的事件数据。*   `Producers`（在本例中模拟）将股票价格更新事件发布到Disruptor的环形缓冲区。*   `Disruptor`为事件分配序列号，并将其提供给消费者。*   `MovingAverageCalculator`消费者并发处理这些事件，根据每个股票价格更新移动平均。*   Disruptor的无锁设计确保了高效的事件处理，并防止了传统锁定机制造成的瓶颈。'
- en: Remember that this is a simple illustration. Production code would include error
    handling, multiple consumers for different calculations, and integration with
    cloud-specific services for data input.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这只是一个简单的说明。生产代码将包括错误处理、针对不同计算的多个消费者，以及与云特定服务的数据输入集成。
- en: Now, let’s delve into some practical use cases where the Disruptor pattern can
    significantly enhance the performance of cloud applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解一些实际用例，在这些用例中，Disruptor模式可以显著提高云应用程序的性能。
- en: High-performance cloud applications – essential Disruptor pattern use cases
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高性能云应用程序 - 必要的Disruptor模式用例
- en: 'The top use cases where the Disruptor pattern shines within cloud environments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，Disruptor模式表现最出色的顶级用例：
- en: '**High-throughput,** **low-latency processing**:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高吞吐量，低延迟处理**：'
- en: '**Financial trading**: Execute trades at lightning speed and make rapid decisions
    based on real-time market data. The Disruptor’s low latency processing is paramount
    in this domain.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金融交易**：以闪电般的速度执行交易，并根据实时市场数据做出快速决策。在金融交易领域，Disruptor的低延迟处理至关重要。'
- en: '**Real-time analytics**: Process massive streams of data (website clicks, sensor
    readings, etc.) to gain insights and trigger actions in near real time.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时分析**：处理大量数据流（网站点击、传感器读数等），以在近实时中获得见解并触发操作。'
- en: '**High-frequency event logging**: Ingest and process vast amounts of log data
    for security monitoring, analysis, or troubleshooting in large-scale systems.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高频事件记录**：在大规模系统中，处理大量日志数据以进行安全监控、分析或故障排除。'
- en: '**Microservice architectures**:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：'
- en: '**Inter-service communication**: Use the Disruptor as a high-performance message
    bus. Producers and consumers can be decoupled, enhancing modularity and scalability.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务间通信**：将Disruptor用作高性能消息总线。生产者和消费者可以解耦，增强模块化和可扩展性。'
- en: '**Event-driven workflows**: Orchestrate complex workflows where different microservices
    react to events in a responsive and efficient manner.'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动工作流**：编排复杂的工作流，其中不同的微服务以响应和高效的方式对事件做出反应。'
- en: '**Cloud-specific** **use cases**:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云特定** **用例**：'
- en: '**IoT event processing**: Handle the deluge of data from IoT devices. The Disruptor
    can quickly process sensor readings or device state changes to trigger alerts
    or updates.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网事件处理**: 处理来自物联网设备的海量数据。Disruptor可以快速处理传感器读数或设备状态变化以触发警报或更新。'
- en: '**Serverless event processing**: Integrate with serverless functions (e.g.,
    AWS Lambda), where the Disruptor can coordinate event processing with ultra-low
    overhead.'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器事件处理**: 与无服务器函数（例如AWS Lambda）集成，Disruptor可以以极低的开销协调事件处理。'
- en: While the Disruptor pattern offers exceptional performance benefits, it’s essential
    to be mindful of its potential complexities. Careful tuning of parameters such
    as ring buffer size and consumer batch sizes is often necessary to achieve optimal
    results. In a cloud environment, consider integrating with cloud-native services
    to enhance the system’s resilience through features such as replication or persistence
    of the ring buffer. Properly understanding and addressing potential bottlenecks
    is crucial to fully harness the Disruptor’s power and ensure your cloud-based
    system remains highly efficient and robust.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Disruptor模式提供了卓越的性能优势，但必须注意其潜在的复杂性。仔细调整参数，如环形缓冲区大小和消费者批处理大小，通常对于实现最佳结果是必要的。在云环境中，考虑与云原生服务集成，通过环形缓冲区的复制或持久化等特性增强系统的弹性。正确理解和解决潜在的瓶颈对于充分利用Disruptor的力量并确保您的云系统保持高效和稳健至关重要。
- en: The Disruptor pattern versus the Producer-Consumer pattern – a comparative analysis
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Disruptor模式与生产者-消费者模式——比较分析
- en: 'Let’s compare the Disruptor pattern and the Producer-Consumer pattern, highlighting
    their key differences:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较Disruptor模式和生产者-消费者模式，突出它们的关键差异：
- en: '**Design purpose**:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计目的**:'
- en: '**Producer-Consumer**: A general-purpose pattern for decoupling the production
    and consumption of data or events'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者-消费者**: 一种通用模式，用于解耦数据或事件的生成和消费'
- en: '**Disruptor**: A specialized high-performance variant optimized for low-latency
    and high-throughput scenarios'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Disruptor**: 一种针对低延迟和高吞吐量场景优化的专用高性能变体'
- en: '**Data structure**:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据结构**:'
- en: '**Producer-Consumer**: Uses a shared queue or buffer, which can be bounded
    or unbounded'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者-消费者**: 使用共享队列或缓冲区，可以是有限或无界的'
- en: '**Disruptor**: Employs a pre-allocated ring buffer with a fixed size to minimize
    memory allocation and garbage collection overhead'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Disruptor**: 采用固定大小的预分配环形缓冲区以最小化内存分配和垃圾回收开销'
- en: '**Locking mechanism**:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁定机制**:'
- en: '**Producer-Consumer**: Often relies on traditional locking mechanisms, such
    as locks or semaphores, for synchronization'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者-消费者**: 通常依赖于传统的锁定机制，如锁或信号量，以实现同步'
- en: '**Disruptor**: Utilizes a lock-free design using sequence numbers and atomic
    operations, reducing contention and enabling higher concurrency'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Disruptor**: 利用无锁设计，使用序列号和原子操作，减少竞争并实现更高的并发性'
- en: '**Batching**:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**:'
- en: '**Producer-Consumer**: Typically processes events or data one at a time, with
    no inherent support for batching'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者-消费者**: 通常一次处理一个事件或数据，没有内在的批处理支持'
- en: '**Disruptor**: Supports batching of events, allowing consumers to process events
    in batches for improved efficiency'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Disruptor**: 支持事件批处理，允许消费者批量处理事件以提高效率'
- en: '**Performance**:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**:'
- en: '**Producer-Consumer**: Performance depends on the implementation and chosen
    synchronization mechanisms, and may suffer from lock contention and increased
    latency'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者-消费者**: 性能取决于实现和选择的同步机制，可能会受到锁竞争和增加延迟的影响'
- en: '**Disruptor**: Optimized for high performance and low latency, thanks to its
    lock-free design, pre-allocated ring buffer, and batching capabilities'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Disruptor**: 由于其无锁设计、预分配的环形缓冲区和批处理能力，优化了高性能和低延迟'
- en: The choice between the two patterns depends on the system’s requirements. The
    Disruptor pattern is suitable for low-latency and high-throughput scenarios, while
    the Producer-Consumer pattern is more general-purpose and simpler to implement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 两种模式的选择取决于系统的需求。Disruptor模式适用于低延迟和高吞吐量场景，而生产者-消费者模式更通用且易于实现。
- en: As we move into the next section, keep in mind that combining these core patterns
    opens up possibilities for even more sophisticated and robust cloud solutions.
    Let’s explore how they can work together to push the boundaries of performance
    and resilience!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入下一节时，请记住，结合这些核心模式可以开辟更复杂和稳健的云解决方案的可能性。让我们探索它们如何协同工作，以推动性能和弹性的边界！
- en: Combining concurrency patterns for enhanced resilience and performance
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合并发模式以增强弹性和性能
- en: By strategically blending these patterns, you can achieve new levels of cloud
    system efficiency and robustness. Harness the power of combined concurrency patterns
    to build cloud systems that are both exceptionally performant and resilient, unlocking
    the hidden potential of your cloud architecture.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过战略性地结合这些模式，您可以实现云系统效率和鲁棒性的新水平。利用结合的并发模式构建既高性能又弹性的云系统，释放云架构的潜在能力。
- en: Integrating the Circuit Breaker and Producer-Consumer patterns
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成熔断器和生产者-消费者模式
- en: 'Combining the Circuit Breaker and Producer-Consumer patterns significantly
    boosts resilience and data flow efficiency in asynchronous cloud applications.
    The Circuit Breaker safeguards against failures, while the Producer-Consumer pattern
    optimizes data processing. Here’s how to integrate them effectively:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将熔断器和生产者-消费者模式结合起来，显著提高了异步云应用中的弹性和数据流效率。熔断器保护免受故障的影响，而生产者-消费者模式优化数据处理。以下是有效集成它们的方法：
- en: '**Decouple with Circuit Breakers**: Place a Circuit Breaker between producers
    and consumers to prevent consumer overload during failures or slowdowns. This
    allows the system to recover gracefully.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用熔断器解耦**：在生产者和消费者之间放置熔断器，以防止在故障或减速期间消费者过载。这允许系统优雅地恢复。'
- en: '**Adaptive load management**: Use the Circuit Breaker’s state to dynamically
    adjust the producer’s task generation rate. Reduce the rate when the Circuit Breaker
    trips to maintain throughput while ensuring reliability.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自适应负载管理**：使用熔断器的状态动态调整生产者的任务生成速率。当熔断器触发时，降低速率以保持吞吐量同时确保可靠性。'
- en: '**Prioritize data**: Use multiple queues with individual Circuit Breakers to
    protect each queue. This ensures that high-priority tasks are processed even during
    system stress.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先处理数据**：使用具有单独熔断器的多个队列来保护每个队列。这确保了即使在系统压力下，高优先级任务也能得到处理。'
- en: '**Self-healing feedback loop**: Have the Circuit Breaker’s state trigger resource
    allocation, error correction, or alternative task routing, enabling autonomous
    system recovery.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自愈反馈循环**：让熔断器的状态触发资源分配、错误纠正或替代任务路由，从而实现自主系统恢复。'
- en: '**Implement graceful degradation**: Employ fallback mechanisms in consumers
    to maintain service (even in a reduced form) when Circuit Breakers trip.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现优雅降级**：在消费者中采用回退机制，当熔断器触发时，即使以减少的形式也能保持服务。'
- en: To demonstrate how this integration enhances fault tolerance, let’s examine
    a code demo for resilient order processing using the Circuit Breaker and Producer-Consumer
    patterns.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种集成如何增强容错性，让我们检查一个使用熔断器和生产者-消费者模式进行弹性订单处理的代码示例。
- en: Resilient order processing – Circuit Breaker and Producer-Consumer demo
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性订单处理 – 熔断器和生产者-消费者演示
- en: In an e-commerce platform, use a queue to buffer orders (the Producer-Consumer
    pattern). Wrap external service calls (e.g., payment processing) within circuit
    breakers for resilience. If a service fails, the Circuit Breaker pattern prevents
    cascading failures and can trigger fallback strategies.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子商务平台中，使用队列来缓冲订单（生产者-消费者模式）。将外部服务调用（例如，支付处理）包装在熔断器中以提高弹性。如果服务失败，熔断器模式可以防止级联故障并触发回退策略。
- en: 'Here is an example code snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例代码片段：
- en: '[PRE11]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code demonstrates the integration of the Circuit Breaker and Producer-Consumer
    patterns to enhance the resilience of an order processing system. Let’s look at
    the code in detail:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了熔断器和生产者-消费者模式的集成，以增强订单处理系统的弹性。让我们详细看看代码：
- en: '`OrderQueue` acts as a buffer between order generation and processing. `OrderConsumer`
    pulls orders from this queue for asynchronous processing.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderQueue`充当订单生成和处理之间的缓冲区。`OrderConsumer`从该队列中提取订单以进行异步处理。'
- en: '`paymentCircuitBreaker` protects an external payment service. If the payment
    service is experiencing issues, the circuit breaker prevents cascading failures.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paymentCircuitBreaker`保护外部支付服务。如果支付服务存在问题，熔断器可以防止级联故障。'
- en: '`ServiceException` occurs during `processPayment`, the circuit breaker is tripped
    (`paymentCircuitBreaker.trip()`), temporarily halting further calls to the payment
    service.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`processPayment`过程中发生`ServiceException`，熔断器被触发（`paymentCircuitBreaker.trip()`），暂时停止对支付服务的进一步调用。
- en: '`retryOrderLater` method signals that the order should be processed at a later
    time, allowing the dependent service to recover.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryOrderLater`方法表示订单应在稍后时间处理，允许依赖服务恢复。'
- en: Overall, this code snippet highlights how these patterns work together to improve
    system robustness and maintain functionality even during partial failures.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，此代码片段突出了这些模式如何协同工作以提高系统鲁棒性，即使在部分故障的情况下也能保持功能。
- en: Integrating Bulkhead with Scatter-Gather for enhanced fault tolerance
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成Bulkhead与Scatter-Gather以增强容错性
- en: 'Combine the Bulkhead pattern with Scatter-Gather to build more resilient and
    efficient microservice architectures in the cloud. Bulkhead’s focus on isolation
    helps manage failures and optimize resource usage within the Scatter-Gather framework.
    Here’s how:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 将Bulkhead模式与Scatter-Gather结合，以构建更健壮和高效的云中微服务架构。Bulkhead对隔离的关注有助于在Scatter-Gather框架内管理故障和优化资源使用。以下是具体做法：
- en: '**Isolated scatter components**: Employ the Bulkhead pattern to isolate scatter
    components. This prevents failures or heavy loads in one component from affecting
    others.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离的scatter组件**：使用Bulkhead模式隔离scatter组件。这防止了一个组件的故障或重负载影响其他组件。'
- en: '**Dedicated gather resources**: Allocate distinct resources to the gather component
    using Bulkhead principles. This ensures efficient result aggregation, even under
    heavy load on the scatter services.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用资源收集**：使用Bulkhead原则为收集组件分配独立资源。这确保了即使在scatter服务面临重负载的情况下，结果聚合也能高效进行。'
- en: '**Dynamic resource allocation**: Bulkhead enables dynamic adjustment of resources
    for each scatter service based on its needs, optimizing overall system usage.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态资源分配**：Bulkhead可以根据每个scatter服务的需求动态调整资源，优化整体系统使用。'
- en: '**Fault tolerance and redundancy**: Bulkhead isolation ensures that the entire
    system doesn’t fail if one scatter service goes down. Create redundant scatter
    service instances with separate resource pools for high fault tolerance.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错和冗余**：Bulkhead隔离确保如果一个scatter服务出现故障，整个系统不会崩溃。创建具有独立资源池的冗余scatter服务实例，以实现高容错性。'
- en: 'To illustrate the benefits of this integration, let’s consider a real-world
    use case: a weather forecasting service.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明此集成的优势，让我们考虑一个现实世界的用例：天气预报服务。
- en: Weather data processing with Bulkhead and Scatter-Gather
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Bulkhead和Scatter-Gather进行天气数据处理
- en: 'Imagine a weather forecasting service that gathers data from multiple weather
    stations spread across a vast geographical region. The system needs to process
    this data efficiently and reliably to generate accurate weather forecasts. Here’s
    how we can use the combined power of Bulkhead and Scatter-Gather patterns:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个天气预报服务，它从遍布广阔地理区域的多个气象站收集数据。系统需要高效且可靠地处理这些数据以生成准确的天气预报。以下是我们可以如何使用Bulkhead和Scatter-Gather模式的结合力量：
- en: '[PRE12]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code demonstrates the integration of the Bulkhead and Scatter-Gather patterns
    for weather data processing. Here is the explanation:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了Bulkhead和Scatter-Gather模式在天气数据处理中的集成。以下是解释：
- en: '`WeatherDataCoordinator` orchestrates parallel processing. It scatters weather
    readings to regional bulkhead instances and gathers the results for final aggregation.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeatherDataCoordinator`协调并行处理。它将天气读数分散到区域性的bulkhead实例，并收集最终聚合的结果。'
- en: '`WeatherDataProcessor` instances, potentially allowing further parallelization
    within a region.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeatherDataProcessor`实例，可能允许在区域内进一步并行化。'
- en: '**Resilience**: Bulkheads prevent failures in one region from affecting others.
    If a region’s processing experiences issues, other regions can continue working.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：Bulkhead防止一个区域的故障影响其他区域。如果一个区域的处理遇到问题，其他区域可以继续工作。'
- en: This is a simple example. Real-world implementations would involve error handling,
    communication mechanisms between coordinator and bulkheads, and specific logic
    for processing weather data and merging results.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子。现实世界的实现将涉及错误处理、协调器与bulkhead之间的通信机制，以及处理天气数据和合并结果的特定逻辑。
- en: This integration not only enhances the resilience of distributed systems by
    isolating failures but also optimizes resource utilization across parallel processing
    tasks, making it an ideal strategy for complex, cloud-based environments.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此集成不仅通过隔离故障增强了分布式系统的容错性，还优化了并行处理任务中的资源利用率，使其成为复杂、基于云的环境的理想策略。
- en: Blending concurrency patterns – a recipe for high-performance cloud applications
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合并发模式——高性能云应用的秘籍
- en: Blending different concurrency patterns in cloud applications can significantly
    enhance both performance and resilience. By carefully integrating patterns that
    complement each other’s strengths, developers can create more robust, scalable,
    and efficient systems. In this section, we’ll explore strategies for the synergistic
    integration of concurrency patterns, highlighting scenarios where such blends
    are particularly effective.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在云应用程序中混合不同的并发模式可以显著提高性能和弹性。通过精心整合互补各自优势的模式，开发者可以创建更健壮、可扩展和高效的系统。在本节中，我们将探讨并发模式协同整合的策略，突出这种混合在特定场景中特别有效的情况。
- en: Blending the Circuit Breaker and Bulkhead patterns
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合断路器和舱壁模式
- en: In a microservices architecture, where each service may depend on several other
    services, combining the Circuit Breaker and Bulkhead patterns can prevent failures
    from cascading across services and overwhelming the system.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务可能依赖于几个其他服务，结合断路器和舱壁模式可以防止故障在服务之间级联并压倒系统。
- en: '**Integration strategy**: Use the Circuit Breaker pattern to protect against
    failures in dependent services. In parallel, apply the Bulkhead pattern to limit
    the impact of any single service’s failure on the overall system. This approach
    ensures that if a service does become overloaded or fails, it doesn’t take down
    unrelated parts of the application.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成策略**：使用断路器模式来防止依赖服务的故障。同时，应用舱壁模式来限制单个服务故障对整体系统的影响。这种方法确保如果某个服务变得过载或失败，它不会拖垮应用程序的其他无关部分。'
- en: Combining Scatter-Gather with the Actor model
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将散列-聚集与Actor模型结合
- en: Building on our previous discussion of the Actor model in [*Chapter 4*](B20937_04.xhtml#_idTextAnchor099),
    *Java Concurrency Utilities and Testing in the Cloud Era*, let’s see how it complements
    the Scatter-Gather pattern for distributed data processing tasks requiring result
    aggregation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前关于Actor模型的讨论基础上，[*第4章*](B20937_04.xhtml#_idTextAnchor099)，“云时代下的Java并发工具和测试”，让我们看看它如何补充散列-聚集模式，用于需要结果聚合的分布式数据处理任务。
- en: '**Integration strategy**: Use the Actor model to implement the scatter component,
    distributing tasks among a group of actor instances. Each actor processes a portion
    of the data independently. Then, employ a gather actor to aggregate the results.
    This setup benefits from the Actor model’s inherent message-passing concurrency,
    ensuring that each task is handled efficiently and in isolation.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成策略**：使用Actor模型实现散列组件，将任务分配给一组actor实例。每个actor独立处理数据的一部分。然后，使用聚集actor来汇总结果。这种设置得益于Actor模型固有的消息传递并发性，确保每个任务都得到高效且独立的处理。'
- en: Merging Producer-Consumer with the Disruptor pattern
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将生产者-消费者与Disruptor模式合并
- en: In high-throughput systems where processing speed is critical, such as real-time
    analytics or trading platforms, the Producer-Consumer pattern can be enhanced
    with the Disruptor pattern for lower latency and higher performance.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理速度至关重要的高吞吐量系统中，例如实时分析或交易平台，可以通过Disruptor模式增强生产者-消费者模式，以实现更低的延迟和更高的性能。
- en: '**Integration strategy**: Implement the Producer-Consumer infrastructure using
    the Disruptor pattern’s ring buffer to pass data between producers and consumers.
    This blend takes advantage of the Disruptor pattern’s high-performance, lock-free
    queues to minimize latency and maximize throughput, all while maintaining the
    clear separation of concerns and scalability of the Producer-Consumer pattern.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成策略**：使用Disruptor模式的环形缓冲区实现生产者-消费者基础设施，在生产者和消费者之间传递数据。这种组合利用了Disruptor模式的高性能、无锁队列来最小化延迟并最大化吞吐量，同时保持生产者-消费者模式清晰的关注点分离和可伸缩性。'
- en: Synergizing event sourcing with CQRS
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将事件溯源与CQRS结合
- en: 'Both event sourcing and **Command Query Responsibility Segregation** (**CQRS**)
    are software architectural patterns. They address different aspects of system
    design:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源和**命令查询责任分离**（**CQRS**）都是软件架构模式。它们解决系统设计的不同方面：
- en: '**Event sourcing**: Focuses fundamentally on how the state of an application
    is represented, persisted, and derived. It emphasizes an immutable history of
    events as the source of truth.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件溯源**：从根本上关注应用程序状态如何表示、持久化和推导。它强调不可变的事件历史作为真相的来源。'
- en: '**CQRS**: Focuses on separating the actions that change an application’s state
    (commands) from those actions that retrieve information without changing the state
    (queries). This separation can improve scalability and performance.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CQRS**：专注于将改变应用程序状态的操作（命令）与那些不改变状态而检索信息的操作（查询）分离。这种分离可以提高可伸缩性和性能。'
- en: 'While they are distinct, event sourcing and CQRS are often used together in
    a complementary way: event sourcing provides a natural source of events for CQRS,
    and CQRS allows the independent optimization of read and write models within an
    event-sourced system.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们是不同的，但事件溯源和CQRS通常以互补的方式一起使用：事件溯源为CQRS提供了一个自然的事件源，而CQRS允许在事件溯源系统中独立优化读取和写入模型。
- en: '**Integration strategy**: Use event sourcing to capture changes to the application
    state as a sequence of events. Combine this with CQRS to separate the models for
    reading and writing data. This blend allows highly efficient, scalable read models
    optimized for query operations while maintaining an immutable log of state changes
    for system integrity and replayability.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成策略**：使用事件溯源来捕获应用程序状态的变化作为一系列事件。结合CQRS来分离读取和写入数据的模型。这种混合允许高度高效的、可伸缩的读取模型，针对查询操作进行了优化，同时保持状态变化的不可变日志，以确保系统完整性和可重放性。'
- en: To maximize the benefits of pattern integration, choose patterns with complementary
    objectives, such as those focused on fault tolerance and scalability. Combine
    patterns that promote isolation (such as Bulkhead) with those offering efficient
    resource management (such as Disruptor) to achieve both resilience and performance.
    Utilize patterns that decouple components (such as Event Sourcing and CQRS) to
    make a simpler system architecture that’s easier to scale and maintain over time.
    This strategic blending of concurrency patterns helps you address the complexities
    of cloud applications, resulting in systems that are more resilient, scalable,
    and easier to manage.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化模式集成的效益，选择具有互补目标的模式，例如那些专注于容错性和可伸缩性的模式。将促进隔离（如隔离舱）的模式与那些提供高效资源管理（如Disruptor）的模式结合起来，以实现弹性和性能的双重提升。利用解耦组件（如事件溯源和CQRS）的模式，创建一个更简单、易于随时间扩展和维护的系统架构。这种战略性的并发模式混合有助于您解决云应用的复杂性，从而实现更具有弹性、可伸缩且易于管理的系统。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Think of this chapter as your journey into the heart of cloud application design.
    We started by building a strong foundation—exploring patterns such as Leader-Follower,
    Circuit Breaker, and Bulkhead to create systems that can withstand the storms
    of cloud environments. Think of these patterns as your architectural armor!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章视为您探索云应用设计核心的旅程。我们首先构建了一个坚实的基础——通过探索如领导者-跟随者、断路器和隔离舱等模式，来创建能够抵御云环境风暴的系统。将这些模式视为您的架构盔甲！
- en: Next, we ventured into the realm of asynchronous operations and distributed
    communication. Patterns such as the Producer-Consumer, Scatter/Gather, and Disruptor
    became your tools for streamlining data flow and boosting performance. Imagine
    them as powerful engines propelling your cloud applications forward.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入了异步操作和分布式通信的领域。如生产者-消费者、散列/收集和Disruptor等模式成为您简化数据流和提升性能的工具。想象它们为推动您的云应用前进的强大引擎。
- en: 'Finally, we uncovered the secret to truly exceptional cloud systems: the strategic
    combination of patterns. You learned how to integrate Circuit Breaker and Bulkhead
    for enhanced resilience, enabling you to create applications that can adapt and
    recover gracefully. This is like giving your cloud systems superpowers!'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们揭开了真正卓越的云系统的秘密：模式的战略组合。您学习了如何集成断路器和隔离舱以增强弹性，使您能够创建能够优雅适应和恢复的应用程序。这就像赋予您的云系统超级能力！
- en: 'With your newfound mastery of concurrency patterns, you’re well equipped to
    tackle complex challenges. [*Chapter 6*](B20937_06.xhtml#_idTextAnchor162)*,*
    *Java in the Realm of Big Data*, throws you a new curveball: processing massive
    datasets. Let’s see how Java and these patterns come together to conquer this
    challenge.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了并发模式的新技能后，您已经准备好应对复杂挑战。[*第6章*](B20937_06.xhtml#_idTextAnchor162)*，* *大数据领域中的Java*，向您抛出了一个新的难题：处理大规模数据集。让我们看看Java和这些模式如何结合在一起，共同应对这一挑战。
- en: Questions
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main purpose of the Circuit Breaker pattern in a distributed system?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式系统中断路器模式的主要目的是什么？
- en: To enhance data encryption
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增强数据加密
- en: To prevent a high number of requests from overwhelming a service
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止大量请求压倒服务
- en: To prevent failures in one service from affecting other services
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止一个服务的故障影响其他服务
- en: To schedule tasks for execution at a later time
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以后执行的任务安排时间
- en: When implementing the Disruptor pattern, which of the following is crucial for
    achieving high performance and low latency?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现Disruptor模式时，以下哪项对于实现高性能和低延迟至关重要？
- en: Using a large number of threads to increase concurrency
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大量线程来增加并发性
- en: Employing a lock-free ring buffer to minimize contention
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无锁环形缓冲区来最小化竞争
- en: Prioritizing tasks based on their complexity
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据复杂度优先级排序任务
- en: Increasing the size of the message payload
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加消息负载的大小
- en: In the context of microservices, what is the primary advantage of implementing
    the Bulkhead pattern?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务背景下，实现Bulkhead模式的主要优势是什么？
- en: It allows a single point of operation for all services.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为所有服务提供了一个单一的运营点。
- en: It encrypts messages exchanged between services.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它加密了服务之间交换的消息。
- en: It isolates services to prevent failures in one from cascading to others.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它隔离服务以防止一个服务的故障级联到其他服务。
- en: It aggregates data from multiple sources into a single response.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将来自多个来源的数据聚合到单个响应中。
- en: Which concurrency pattern is particularly effective for operations that require
    results to be aggregated from multiple sources in a distributed system?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种并发模式对于需要从分布式系统中的多个来源聚合结果的操作特别有效？
- en: Leader Election pattern
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领导选举模式
- en: Scatter-Gather pattern
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scatter-Gather模式
- en: Bulkhead pattern
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bulkhead模式
- en: Actor model
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Actor模型
- en: 'Integrating the Circuit Breaker and Producer-Consumer patterns in cloud applications
    primarily enhances the system’s:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云应用程序中集成断路器和生产者-消费者模式主要增强了系统的：
- en: Memory efficiency
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存效率
- en: Computational complexity
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算复杂性
- en: Security posture
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全态势
- en: Resilience and data flow management
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹性和数据流管理
- en: 'Part 2: Java''s Concurrency in Specialized Domains'
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：Java在特定领域的并发
- en: The second part explores Java's concurrency capabilities across specialized
    domains, demonstrating how these features tackle complex challenges in big data,
    machine learning, microservices, and serverless computing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分探讨了Java在特定领域的并发能力，展示了这些功能如何解决大数据、机器学习、微服务和无服务器计算中的复杂挑战。
- en: 'This part includes the following chapters:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 6*](B20937_06.xhtml#_idTextAnchor162), *Java and Big Data – a Collaborative
    Odyssey*'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B20937_06.xhtml#_idTextAnchor162), *Java与大数据——协作之旅*'
- en: '[*Chapter 7*](B20937_07.xhtml#_idTextAnchor187), *Concurrency in Java for Machine
    Learning*'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20937_07.xhtml#_idTextAnchor187), *Java在机器学习中的并发*'
- en: '[*Chapter 8*](B20937_08.xhtml#_idTextAnchor206), *Microservices in the Cloud
    and Java''s Concurrency*'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20937_08.xhtml#_idTextAnchor206), *云中的微服务和Java的并发*'
- en: '[*Chapter 9*](B20937_09.xhtml#_idTextAnchor229), *Serverless Computing and
    Java''s Concurrent Capabilities*'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20937_09.xhtml#_idTextAnchor229), *无服务器计算与Java的并发能力*'
