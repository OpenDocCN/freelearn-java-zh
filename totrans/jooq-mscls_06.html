<html><head></head><body>
		<div id="_idContainer025">
			<h1 id="_idParaDest-70"><em class="italic"><a id="_idTextAnchor069"/>Chapter 4</em>: Building a DAO Layer (Evolving the Generated DAO Layer)</h1>
			<p>At this point, we know how to enable the jOOQ Code Generator and how to express queries via the jOOQ DSL API, and we have a decent level of understanding of how jOOQ works. In other words, we know how to start and configure a Spring Boot application relying on jOOQ for the persistence layer implementation.</p>
			<p>In this chapter, we tackle different approaches for organizing our queries in a <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) layer. Being a Spring Boot fan, you are most probably familiar with a DAO layer that is repository-centric, therefore, you'll see how jOOQ fits into this context. By the end of this chapter, you'll be familiar with the following:</p>
			<ul>
				<li>Hooking the DAO layer</li>
				<li>Shaping the DAO design pattern and using jOOQ</li>
				<li>Shaping the generic DAO design pattern and using jOOQ</li>
				<li>Extending the jOOQ built-in DAO</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04</a>.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Hooking the DAO layer</h1>
			<p>DAO is a design<a id="_idIndexMarker334"/> pattern that stands for <strong class="bold">Data Access Object</strong>. Following the separation of logic principle, DAO separates the data persistence logic in a dedicated layer and abstracts away the low-level database operations. Typically, the DAO is sketched around three main components:</p>
			<ul>
				<li>A model representing the data that is transferred between layers (for example, the <strong class="source-inline">Sale</strong> model corresponds to the <strong class="source-inline">SALE</strong> database table)</li>
				<li>An interface containing the API that should be implemented for the model (for example, <strong class="source-inline">SaleDao</strong>, or in Spring terms, <strong class="source-inline">SaleRepository</strong>)</li>
				<li>A concrete implementation of this interface (for example, <strong class="source-inline">SaleDaoImpl</strong>, or in Spring terms, <strong class="source-inline">SaleRepositoryImpl</strong>)</li>
			</ul>
			<p>The following diagram <a id="_idIndexMarker335"/>represents the relationships between these components using <strong class="source-inline">Sale</strong>, <strong class="source-inline">SaleRepository</strong>, and <strong class="source-inline">SaleRepositoryImpl</strong>:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B16833_Figure_4.1.jpg" alt="Figure 4.1 – DAO design pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – DAO design pattern</p>
			<p>If you are a <strong class="source-inline">JdbcTemplate</strong> fan, you most probably recognize this pattern in your own applications. On the other hand, if you are familiar with Spring Data JPA/JDBC, then you can associate <strong class="source-inline">Sale</strong> with a JPA/JDBC entity, <strong class="source-inline">SaleRepository</strong> with an extension of the Spring repository (for instance, <strong class="source-inline">CrudRepository</strong> or <strong class="source-inline">JpaRepository</strong>), and <strong class="source-inline">SaleRepositoryImpl</strong> with the Spring proxy instance automatically created for <strong class="source-inline">SaleRepository</strong>.</p>
			<p>A flavor of this design pattern is known as <em class="italic">generic DAO</em>. In this case, the goal is to isolate the query methods that are common to all repositories (for instance, <strong class="source-inline">fetchAll()</strong>, <strong class="source-inline">fetchById()</strong>, <strong class="source-inline">insert()</strong>, <strong class="source-inline">update()</strong>, and so on) from the query methods that are repository-specific (for instance, <strong class="source-inline">findSaleByFiscalYear()</strong>). This time, we add the common methods in a generic interface (such as <strong class="source-inline">ClassicModelsRepository&lt;&gt;</strong>) and we provide an implementation for it (<strong class="source-inline">ClassicModelsRepositoryImpl&lt;&gt;</strong>). </p>
			<p>The following diagrams depict two classical flavors of the generic DAO using the same <strong class="source-inline">Sale</strong>, <strong class="source-inline">SaleRepository</strong> and <strong class="source-inline">SaleRepositoryImpl</strong>:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B16833_Figure_4.2.jpg" alt="Figure 4.2 – Generic DAO (1)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Generic DAO (1)</p>
			<p>In <em class="italic">Figure 4.2</em>, the <a id="_idIndexMarker336"/>implementation of <strong class="source-inline">SaleRepository</strong> must provide an implementation of the generic <strong class="source-inline">ClassicModelsRepository</strong> as well. Each repository will follow this technique. To increase the DAO layer flexibility, we add a separate implementation for the generic interface as shown in the following figure:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B16833_Figure_4.3.jpg" alt="Figure 4.3 – Generic DAO (2)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Generic DAO (2)</p>
			<p>If you are familiar with Spring Data JPA/JDBC, then you can associate <strong class="source-inline">ClassicModelsRepository</strong> with a Spring built-in repository (for example, <strong class="source-inline">CrudRepository</strong> or <strong class="source-inline">JpaRepository</strong>) and the implementation of this interface, <strong class="source-inline">ClassicModelsRepositoryImpl</strong>, with <a id="_idIndexMarker337"/>a Spring built-in implementation such as <strong class="source-inline">SimpleJpaRepository</strong>.</p>
			<p>Next, let's see how we can shape these DAO patterns and use jOOQ.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Shaping the DAO design pattern and using jOOQ</h1>
			<p>Let's assume<a id="_idIndexMarker338"/> that <a id="_idIndexMarker339"/>we have a bunch of SQLs written in jOOQ for the <strong class="source-inline">SALE</strong> table, and we want to shape a simple DAO implementation around them. This is quite simple because all we have to do is to follow <em class="italic">Figure 4.1</em> from the previous section. </p>
			<p>First of all, the model is provided as POJOs by the jOOQ generator (we can have user-defined POJOs as well), therefore, we already have the <strong class="source-inline">Sale</strong> POJO. Next, we write <strong class="source-inline">SaleRepository</strong>:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">@Transactional(readOnly=true)</pre>
			<pre class="source-code">public interface SaleRepository {</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleByFiscalYear(int year);</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleAscGtLimit(double limit);    </pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">SaleRepositoryImpl</strong> provides a <a id="_idIndexMarker340"/>jOOQ implementation for these <a id="_idIndexMarker341"/>two methods:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">public class SaleRepositoryImpl implements SaleRepository {</pre>
			<pre class="source-code">  private final DSLContext ctx;</pre>
			<pre class="source-code">  public SaleRepositoryImpl(DSLContext ctx) {</pre>
			<pre class="source-code">    this.ctx = ctx;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleByFiscalYear(int year) {</pre>
			<pre class="source-code">    return ctx...</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleAscGtLimit(double limit) {</pre>
			<pre class="source-code">    return ctx...;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Done! Further, we <a id="_idIndexMarker342"/>can simply inject <strong class="source-inline">SaleRepository</strong> and <a id="_idIndexMarker343"/>call the query methods:</p>
			<pre class="source-code">@Service</pre>
			<pre class="source-code">public class SalesManagementService {</pre>
			<pre class="source-code">  private final SaleRepository saleRepository;   </pre>
			<pre class="source-code">  public SalesManagementService(</pre>
			<pre class="source-code">    SaleRepository saleRepository) {</pre>
			<pre class="source-code">      this.saleRepository = saleRepository;</pre>
			<pre class="source-code">  } </pre>
			<pre class="source-code">  public List&lt;Sale&gt; fetchSaleByFiscalYear(int year) {</pre>
			<pre class="source-code">    return saleRepository.findSaleByFiscalYear(year);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public List&lt;Sale&gt; fetchSaleAscGtLimit(double limit) {</pre>
			<pre class="source-code">    return saleRepository.findSaleAscGtLimit(limit);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>In the same way, we can evolve this DAO layer by adding more repositories and implementations for <a id="_idIndexMarker344"/>other models. This application is available for Maven and Gradle as <em class="italic">SimpleDao</em>.</p>
			<p>Moreover, if you have to combine Spring Data JPA DAO with the user-defined jOOQ DAO in a single interface, then simply extend the needed interfaces as in the following example:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public interface SaleRepository</pre>
			<pre class="source-code">  extends JpaRepository&lt;Sale, Long&gt;, // JPA</pre>
			<pre class="source-code">  com.classicmodels.jooq.repository.SaleRepository { // jOOQ</pre>
			<pre class="source-code">  List&lt;Sale&gt; findTop10By(); // Sale is a JPA entity</pre>
			<pre class="source-code">}</pre>
			<p>Once <a id="_idIndexMarker345"/>you<a id="_idIndexMarker346"/> inject <strong class="source-inline">SaleRepository</strong>, you'll have access to a Spring Data JPA DAO and the user-defined jOOQ DAO in the same service. This example <a id="_idIndexMarker347"/>is named <strong class="source-inline">JpaSimpleDao</strong>.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Shaping the generic DAO design pattern and using jOOQ</h1>
			<p>Trying to <a id="_idIndexMarker348"/>implement<a id="_idIndexMarker349"/> the generic DAO from <em class="italic">Figure 4.2</em> starts with the generic interface, <strong class="source-inline">ClassicModelsRepository</strong>:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public interface ClassicModelsRepository&lt;T, ID&gt; {</pre>
			<pre class="source-code">  List&lt;T&gt; fetchAll();</pre>
			<pre class="source-code">  @Transactional</pre>
			<pre class="source-code">  void deleteById(ID id);</pre>
			<pre class="source-code">}</pre>
			<p>While <strong class="source-inline">ClassicModelsRepository</strong> contains the common query methods, <strong class="source-inline">SaleRepository</strong> extends it to add specific query methods, as follows:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public interface SaleRepository</pre>
			<pre class="source-code">        extends ClassicModelsRepository&lt;Sale, Long&gt; {</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleByFiscalYear(int year);</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleAscGtLimit(double limit);</pre>
			<pre class="source-code">}</pre>
			<p>The<a id="_idIndexMarker350"/> implementation <a id="_idIndexMarker351"/>of <strong class="source-inline">SaleRepository</strong> provides implementations for methods from both interfaces:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">public class SaleRepositoryImpl implements SaleRepository {</pre>
			<pre class="source-code">  private final DSLContext ctx;</pre>
			<pre class="source-code">  public SaleRepositoryImpl(DSLContext ctx) {</pre>
			<pre class="source-code">    this.ctx = ctx;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleByFiscalYear(int year) { ... }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public List&lt;Sale&gt; findSaleAscGtLimit(double limit) { ... }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public List&lt;Sale&gt; fetchAll() { ... }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public void deleteById(Long id) { ... }</pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker352"/>complete <a id="_idIndexMarker353"/>example is named <em class="italic">SimpleGenericDao</em>. Moreover, if <a id="_idIndexMarker354"/>you have to combine Spring Data JPA DAO with the user-defined jOOQ generic DAO in a single interface, then extend the needed interfaces <a id="_idIndexMarker355"/>as in <em class="italic">JPASimpleGenericDao</em>. Once you inject <strong class="source-inline">SaleRepository</strong>, you'll have access to Spring Data JPA DAO and the user-defined jOOQ generic DAO in the same service.</p>
			<p>How about implementing the generic DAO from <em class="italic">Figure 4.3</em>? This is more flexible but not that easy to do it. Because of <em class="italic">genericity</em> aspects, we can't reference tables and fields directly as we did in the previous case. The query methods from <strong class="source-inline">ClassicModelsRepository</strong> are written in a generic fashion, therefore, the jOOQ queries written via the DSL support in <strong class="source-inline">ClassicModelsRepositoryImpl</strong> must be written in a generic fashion as well. </p>
			<p>It is not trivial to intuit how to express jOOQ SQLs in a generic fashion, but you can do it after studying the source code of the jOOQ built-in <strong class="source-inline">DAO</strong> interface and the <strong class="source-inline">DAOImpl</strong> class. For those who <a id="_idIndexMarker356"/>want to deep dive into this approach, consider the example named <em class="italic">GenericDao</em>. If you want to involve Spring Data JPA as well then check <a id="_idIndexMarker357"/>out <em class="italic">JpaGenericDao</em>.</p>
			<p>But, as you saw in <a href="B16833_02.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Customizing the jOOQ Level of Involvement</em>, jOOQ can generate a<a id="_idIndexMarker358"/> DAO<a id="_idIndexMarker359"/> layer on our behalf. Let's extend it and enrich/customize it as we like.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Extending the jOOQ built-in DAO</h1>
			<p>Let's assume <a id="_idIndexMarker360"/>that you have configured the jOOQ generator to output the generated DAO layer in the <strong class="source-inline">jooq.generated.tables.daos</strong> package. While the generated DAO exposes common query methods such as <strong class="source-inline">insert()</strong>, <strong class="source-inline">update()</strong>, <strong class="source-inline">delete()</strong>, and a few specific queries of the <strong class="source-inline">fetchBy...()</strong> or <strong class="source-inline">fetchRange...()</strong> types, we want to extend it with our own query methods. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This is one of my favorite ways of writing a DAO layer in a Spring Boot and jOOQ application.</p>
			<p>The jOOQ DAO layer contains a set of generated classes that mirrors the database tables and extends the built-in <strong class="source-inline">org.jooq.impl.DAOImpl</strong> class. For example, the <strong class="source-inline">jooq.generated.tables.daos.SaleRepository</strong> class (or, <strong class="source-inline">jooq.generated.tables.daos.SaleDao</strong> if you keep the default naming strategy used by jOOQ) corresponds to the <strong class="source-inline">SALE</strong> table. In order to extend <strong class="source-inline">SaleRepository</strong>, we have to take a quick look at its source code and highlight a part of it as follows:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">public class SaleRepository extends DAOImpl&lt;SaleRecord, </pre>
			<pre class="source-code">      jooq.generated.tables.pojos.Sale, Long&gt; {</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">  <strong class="bold">@Autowired</strong></pre>
			<pre class="source-code"><strong class="bold">  public SaleRepository(Configuration configuration) {</strong></pre>
			<pre class="source-code"><strong class="bold">     super(Sale.SALE, jooq.generated.tables.pojos.Sale.class,</strong></pre>
			<pre class="source-code"><strong class="bold">              configuration);</strong></pre>
			<pre class="source-code"><strong class="bold"> }</strong></pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">}</pre>
			<p>The highlighted code represents the climax of extending <strong class="source-inline">SaleRepository</strong>. When we extend <strong class="source-inline">SaleRepository</strong> (or any other jOOQ DAO class), it is our responsibility to pass a jOOQ valid configuration, otherwise, the code will produce <strong class="source-inline">NullPointerException</strong>. This is an easy task that can be accomplished as shown in the following snippet of code (basically, we pass into <strong class="source-inline">SaleRepository</strong> the configuration<a id="_idIndexMarker361"/> of <strong class="source-inline">DSLContext</strong> prepared by Spring Boot):</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public class SaleRepositoryImpl extends SaleRepository {</pre>
			<pre class="source-code">  private final DSLContext ctx;</pre>
			<pre class="source-code">  public SaleRepositoryImpl(DSLContext ctx) {</pre>
			<pre class="source-code">    <strong class="bold">super(ctx.configuration());</strong></pre>
			<pre class="source-code"><strong class="bold">    </strong>this.ctx = ctx;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">}</pre>
			<p>That's all! Now, you can exploit the query methods defined in <strong class="source-inline">SaleRepositoryImpl</strong> and <strong class="source-inline">SaleRepository</strong> as well. In other words, you can use the jOOQ built in and your own DAO as a "single" DAO. Here is an example:</p>
			<pre class="source-code">@Service</pre>
			<pre class="source-code">public class SalesManagementService {</pre>
			<pre class="source-code">  private final SaleRepositoryImpl saleRepository;</pre>
			<pre class="source-code">  public SalesManagementService(</pre>
			<pre class="source-code">       SaleRepositoryImpl saleRepository) {</pre>
			<pre class="source-code">    this.saleRepository = saleRepository;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">  // call jOOQ DAO</pre>
			<pre class="source-code">  @Transactional(readOnly = true)</pre>
			<pre class="source-code">  public List&lt;Sale&gt; fetchSaleByFiscalYear(int year) {</pre>
			<pre class="source-code">      return saleRepository.fetchByFiscalYear(year); </pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">   // call your DAO</pre>
			<pre class="source-code">   public List&lt;Sale&gt; fetchSaleAscGtLimit(double limit) {</pre>
			<pre class="source-code">      return saleRepository.findSaleAscGtLimit(limit);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Please consider<a id="_idIndexMarker362"/> the following note as well.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">At the time of writing, jOOQ DAOs work under the following statements:</p>
			<p class="callout"> jOOQ DAOs can be instantiated as much as you like since they don't have their own state.</p>
			<p class="callout"> jOOQ DAOs cannot generate methods on DAOs that use the interfaces of POJOs instead of classes. Actually, at the time of writing, the <strong class="source-inline">&lt;interfaces/&gt;</strong> and <strong class="source-inline">&lt;immutableInterfaces/&gt;</strong> features have been proposed to be removed. You can track this here: <a href="https://github.com/jOOQ/jOOQ/issues/10509">https://github.com/jOOQ/jOOQ/issues/10509</a>.</p>
			<p class="callout"> jOOQ cannot generate interfaces for DAOs.</p>
			<p class="callout"> jOOQ DAOs can be annotated with <strong class="source-inline">@Repository</strong> but they are not running by default in a transactional context (they cannot be annotated with <strong class="source-inline">@Transactional</strong> by the jOOQ generator). You can track this here: <a href="https://github.com/jOOQ/jOOQ/issues/10756">https://github.com/jOOQ/jOOQ/issues/10756</a>.</p>
			<p class="callout"> The DAO's generated <strong class="source-inline">insert()</strong> method cannot return the newly generated ID from the database or the POJO. It simply returns <strong class="source-inline">void</strong>. You can track this here: <a href="https://github.com/jOOQ/jOOQ/issues/2536">https://github.com/jOOQ/jOOQ/issues/2536</a> and <a href="https://github.com/jOOQ/jOOQ/issues/3021">https://github.com/jOOQ/jOOQ/issues/3021</a>.</p>
			<p class="callout">You don't have to consider these shortcomings as the end of the road. The jOOQ team filters dozens of features in order to choose the most popular ones that fit a significant number of scenarios and deserve an implementation directly in the jOOQ releases. Nevertheless, any corner-case or edge-case feature can be supplied by you via a custom generator, custom strategy, or customer configuration. </p>
			<p>The <a id="_idIndexMarker363"/>complete example <a id="_idIndexMarker364"/>from this section is named <em class="italic">jOOQ DAO</em>.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Summary </h1>
			<p>In this chapter, we have covered several approaches to developing, from scratch, a DAO layer or evolving the jOOQ-generated DAO layer in a Spring Boot and jOOQ application. Each of the presented applications can serve as a stub application for your own applications. Just choose the one that is suitable for you, replace the schema, and start developing.</p>
			<p>In the next chapter, we'll use jOOQ to express a wide range of queries involving <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong>.</p>
		</div>
	</body></html>