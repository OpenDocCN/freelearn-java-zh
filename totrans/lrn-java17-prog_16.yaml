- en: '*Chapter 13*: Functional Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter brings you into the world of functional programming. It explains
    what a functional interface is, provides an overview of the functional interfaces
    that come with JDK, and defines and demonstrates Lambda expressions and how to
    use them with functional interfaces, including using **method reference**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard functional interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expression limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to write functions and use them
    for Lambda expressions in order to pass them as method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or any code editor you prefer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on GitHub
    at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch13_functional` folder.
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we provide the definition, let us revisit the code with elements of functional
    programming that we have used already in the preceding chapters. All these examples
    give you a pretty good idea of how a function can be constructed and passed around
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures,
    Generics, and Popular Utilities*, we talked about the `Iterable` interface and
    its `default void forEach (Consumer<T> function)` method, and provided the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see how a `Consumer e -> System.out.print(e + " ")` function is passed
    into the `forEach()` method and applied to each element flowing into this method
    from the list. We will discuss the `Consumer` function shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also mentioned two methods of the `Collection` interface that accept a function
    as a parameter too:'
  prefs: []
  type: TYPE_NORMAL
- en: The `default boolean remove(Predicate<E> filter)` method attempts to remove
    all the elements that satisfy the given predicate from the collection; a `Predicate`
    function accepts an element of the collection and returns a Boolean value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default T[] toArray(IntFunction<T[]> generator)` method returns an array
    of all the elements of the collection, using the provided `IntFunction` generator
    function to allocate the returned array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same chapter, we also mentioned the following method of the `List` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default void replaceAll(UnaryOperator<E> operator)`: This replaces each element
    of the list with the result of applying the provided `UnaryOperator` to that element;
    `UnaryOperator` is one of the functions we are going to review in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We described the `Map` interface, its `default V merge(K key, V value, BiFunction<V,V,V>
    remappingFunction)` method, and how it can be used for concatenating the `String`
    values: `map.merge(key, value, String::concat)`. `BiFunction<V,V,V>` takes two
    parameters of the same type and returns the value of the same type as well. The
    `String::concat` construct is called a **method reference** and will be explained
    in the *Method references* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We provided the following example of passing a `Comparator` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It takes two `String` parameters, then compares the first one to `null`. If
    the first parameter is `null`, the function returns `-1`; otherwise, it compares
    the first parameter and the second one using the `compareTo()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 11*](B18388_11_ePub.xhtml#_idTextAnchor247), *Network Programming*,
    we looked at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BodyHandler` object (a function) is generated by the `BodyHandlers.ofString()`
    factory method and passed into the `send()` method as a parameter. Inside the
    method, the code calls its `apply()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in [*Chapter 12*](B18388_12_ePub.xhtml#_idTextAnchor266), *Java GUI
    Programming*, we used an `EventHandler` function as a parameter in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first function is `EventHandler<ActionEvent>`. This prints a message and
    forces the application to exit. The second is the `EventHandler<WindowEvent>`
    function. This just prints the message.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to pass a function as a parameter constitutes functional programming.
    It is present in many programming languages and does not require the managing
    of object states. The function is stateless. Its result depends only on the input
    data, no matter how many times it is called. Such coding makes the outcome more
    predictable, which is the most attractive aspect of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The area that benefits the most from such a design is parallel data processing.
    Functional programming allows for shifting the responsibility for parallelism
    from the client code to the library. Before that, in order to process elements
    of Java collections, the client code had to iterate over the collection and organize
    the processing. In Java 8, new (default) methods were added that accept a function
    as a parameter and then apply it to each element of the collection, in parallel
    or not, depending on the internal processing algorithm. So, it is the libraryâ€™s
    responsibility to organize parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: What is a functional interface?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we define a function, we provide an implementation of an interface that
    has only one abstract method. That is how the Java compiler knows where to put
    the provided functionality. The compiler looks at the interface (`Consumer`, `Predicate`,
    `Comparator`, `IntFunction`, `UnaryOperator`, `BiFunction`, `BodyHandler`, and
    `EventHandler` in the preceding examples), sees only one abstract method there,
    and uses the passed-in functionality as the method implementation. The only requirement
    is that the passed-in parameters must match the method signature. Otherwise, the
    compile-time error is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is why any interface that has only one abstract method is called a **functional
    interface**. Please note that the requirement of having **only one abstract method**
    includes the method inherited from the parent interface. For example, consider
    the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `A` interface is a functional interface because it has only one abstract
    method, `method1()`. The `B` interface is a functional interface too because it
    has only one abstract methodâ€”the same one inherited from the `A` interface. The
    `C` interface is a functional interface because it has only one abstract method,
    `method1()`, which overrides the abstract method of the parent interface, `A`.
    The `D` interface cannot be a functional interface because it has two abstract
    methodsâ€”`method1()` from the parent interface, `A`, and `method5()`.
  prefs: []
  type: TYPE_NORMAL
- en: To help avoid runtime errors, the `@FunctionalInterface` annotation was introduced
    in Java 8\. It tells the compiler about the intent so the compiler can check and
    see whether there is truly only one abstract method in the annotated interface.
    This annotation also warns a programmer, who reads the code, that this interface
    has only one abstract method intentionally. Otherwise, a programmer may waste
    time adding another abstract method to the interface only to discover at runtime
    that it cannot be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, the `Runnable` and `Callable` interfaces, which have existed
    in Java since its early versions, were annotated in Java 8 as `@FunctionalInterface`.
    This distinction is made explicit and serves as a reminder to users that these
    interfaces can be used to create a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As with any other interface, the functional interface can be implemented using
    the `anonymous` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'An object created this way can later be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If we look closely at the preceding code, we notice that there is unnecessary
    overhead. First, there is no need to repeat the interface name, because we declared
    it already as the type for the object reference. And, second, in the case of a
    functional interface that has only one abstract method, there is no need to specify
    the method name that has to be implemented. The compiler and Java runtime can
    figure it out. All we need is to provide the new functionality. The Lambda expressions
    were introduced especially for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Lambda expression?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **Lambda** comes from *lambda calculus*â€”a universal model of computation
    that can be used to simulate any Turing machine. It was introduced by mathematician
    Alonzo Church in the 1930s. A **Lambda expression** is a function, implemented
    in Java as an anonymous method. It also allows for the omitting of modifiers,
    return types, and parameter types. That makes for a very compact notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the Lambda expression includes the list of parameters, an arrow
    token (`->`), and a body. The list of parameters can be empty, such as `()`, without
    parentheses (if there is only one parameter), or a comma-separated list of parameters
    surrounded by parentheses. The body can be a single expression or a statement
    block inside braces (`{}`). Letâ€™s look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`() -> 42;` always returns `42`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x -> x*42 + 42;` multiplies the `x` value by `42`, then adds `42` to the result
    and returns it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(x, y) -> x * y;` multiplies the passed-in parameters and returns the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s -> "abc".equals(s);` compares the value of the `s` variable and literal
    `"abc"`; it returns a Boolean result value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s -> System.out.println("x=" + s);` prints the `s` value with the prefix `"x="`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(i, s) -> { i++; System.out.println(s + "=" + i); };` increments the input
    integer and prints the new value with the prefix `s + "="`, with `s` being the
    value of the second parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without functional programming, the only way to pass some functionality as a
    parameter in Java would be by writing a class that implements an interface, creating
    its object, and then passing it as a parameter. But even the least-involved style
    using an `anonymous` class requires writing too much boilerplate code. Using functional
    interfaces and Lambda expressions makes the code shorter, clearer, and more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Lambda expressions allow us to reimplement our preceding example
    with the `Runnable` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, creating a functional interface is easy, especially with Lambda
    expressions. But before doing that, consider using one of the 43 functional interfaces
    provided in the `java.util.function` package. This will not only allow you to
    write less code but will also help other programmers who are familiar with the
    standard interfaces to understand your code better.
  prefs: []
  type: TYPE_NORMAL
- en: The local variable syntax for Lambda parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until the release of Java 11, there were two ways to declare parameter typesâ€”explicitly
    and implicitly. Here is an explicit version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an implicit parameter type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the compiler infers the type of the parameters from the
    interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 11, another method of parameter type declaration was introduced using
    the `var` type holder, which is similar to the `var` local variable type holder
    introduced in Java 10 (see [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following parameter declaration is syntactically exactly the same as the
    implicit one before Java 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The new local variable-style syntax allows us to add annotations without defining
    the parameter type explicitly. Letâ€™s add the following dependency to the `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'It allows us to define passed-in variables as non-null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'An annotation communicates to the compiler the programmerâ€™s intent, so it can
    warn the programmer during compilation or execution if the declared intent is
    violated. For example, we have tried to run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It failed with `NullPointerException` at runtime. Then, we have added the annotation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the preceding code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The Lambda expression was not even executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of the local variable syntax in the case of Lambda parameters
    becomes clear if we need to use annotations when the parameters are the objects
    of a class with a really long name. Before Java 11, the code might have looked
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to declare the type of the variable explicitly because we wanted to
    add annotations, and the following implicit version would not even compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 11, the new syntax allows us to use the implicit parameter type inference
    using the `var` type holder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: That is the advantage of and the motivation behind introducing the local variable
    syntax for the Lambda parameterâ€™s declaration. Otherwise, consider staying away
    from using `var`. If the type of the variable is short, using its actual type
    makes the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Standard functional interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the interfaces provided in the `java.util.function` package are specializations
    of the following four interfaces: `Consumer<T>`, `Predicate<T>`, `Supplier<T>`,
    and `Function<T,R>`. Letâ€™s review them and then look at a short overview of the
    other 39 standard functional interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By looking at the `Consumer<T>` interface definition, `<indexentry content="standard
    functional interfaces:Consumer">`, you can already guess that this interface has
    an abstract method that accepts a parameter of type `T` and does not return anything.
    Well, when only one type is listed, it may define the type of the return value,
    as in the case of the `Supplier<T>` interface. But the interface name serves as
    a clue: the `consumer` name indicates that the method of this interface just takes
    the value and returns nothing, while `supplier` returns the value. This clue is
    not precise but helps to jog the memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best source of information about any functional interface is the `java.util.function`
    package API documentation ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html)).
    If we read it, we learn that the `Consumer<T>` interface has one abstract and
    one default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void accept(T t)`: Applies the operation to the given argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Consumer<T> andThen(Consumer<T> after)`: Returns a composed `Consumer`
    function that performs, in sequence, the current operation followed by the `after`
    operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It means that, for example, we can implement and then execute it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have a factory method that creates the function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the `andThen()` method, letâ€™s create the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that `record` is the only property that has a setting.
    We will use it to set a personal record in a consumer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setRecord` function takes the values of the `Person` object properties
    and some data from an external source and sets the resulting value as the `record`
    property value. Obviously, it could be done in several other ways, but we do it
    for demo purposes. Letâ€™s also create a function that prints the `record` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The composition of these two functions can be created and executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: This way, it is possible to create a whole processing pipe of the operations
    that transform the properties of an object that is passed through the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This functional interface, `Predicate<T>`, has one abstract method, five defaults,
    and a static method that allows predicates chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean test(T t)`: Evaluates the provided parameter to see whether it meets
    the criteria or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Predicate<T> negate()`: Returns the negation of the current predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static <T> Predicate<T> not(Predicate<T> target)`: Returns the negation of
    the provided predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Predicate<T> or(Predicate<T> other)`: Constructs a logical `OR` from
    this predicate and the provided one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Predicate<T> and(Predicate<T> other)`: Constructs a logical `AND`
    from this predicate and the provided one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static <T> Predicate<T> isEqual(Object targetRef)`: Constructs a predicate
    that evaluates whether or not two arguments are equal according to `Objects.equals(Object,
    Object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The basic use of this interface is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine it with the previously created `printWithPrefixAndPostfix(String
    pref, String postf)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The other methods (also called **operations**) can be used for creating operational
    chains (also called **pipelines**), and can be seen in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: The `predicate` objects can be chained into more complex logical statements
    and include all necessary external data, as was demonstrated before.
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This functional interface, `Supplier<T>`, has only one abstract method, `T
    get()`, which returns a value. The basic usage can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be chained with the functions discussed in the preceding sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: The `Supplier<T>` function is typically used as an entry point of data going
    into a processing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Function<T, R>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notation of this and other functional interfaces that return values includes
    the listing of the return type as the last in the list of generics (`R` in this
    case) and the type of the input data in front of it (an input parameter of type
    `T` in this case). So, the `Function<T, R>` notation means that the only abstract
    method of this interface accepts an argument of type `T` and produces a result
    of type `R`. Letâ€™s look at the online documentation ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Function<T, R>` interface has one abstract method, `R apply(T)`, and two
    methods for operations chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default <V> Function<T,V> andThen(Function<R, V> after)`: Returns a composed
    function that first applies the current function to its input, and then applies
    the `after` function to the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default <V> Function<V,R> compose(Function<V, T> before)`: Returns a composed
    function that first applies the `before` function to its input, and then applies
    the current function to the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also an `identity()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static <T> Function<T,T> identity()`: Returns a function that always returns
    its input argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Letâ€™s review all these methods and how they can be used. Here is an example
    of the basic usage of the `Function<T,R>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also chain it with all the functions we have discussed in the preceding
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'The `andThen()` method allows constructing a complex function from simpler
    ones. Notice the `divideByTwo.andThen()` line in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: It describes the sequence of the operations applied to the input value. Notice
    how the return type of the `divideByTwo()` function (`Long`) matches the input
    type of the `incrementAndCreateString()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compose()` method accomplishes the same result, but in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the sequence of composition of the complex function does not match the
    sequence of the execution. It may be very convenient in the case where the `divideByTwo()`
    function is not created yet and you would like to create it in-line. Then, the
    following construct will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line will compile just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: It allows for more flexibility while constructing a functional pipeline, so
    you can build it in a fluent style without breaking the continuous line when creating
    the next operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `identity()` method is useful when you need to pass in a function that
    matches the required function signature but does nothing. But, it can substitute
    only a function that returns the same type as the input type, as shown in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate its usability, letâ€™s assume we have the following processing
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we decide that, under certain circumstances, the `multiplyByTwo()` function
    should do nothing. We could add to it a conditional close that turns it on/off.
    But, if we want to keep the function intact or if this function is passed to us
    from third-party code, we can just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `multiplyByTwo()` function now does nothing, and the final
    result is different.
  prefs: []
  type: TYPE_NORMAL
- en: Other standard functional interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other 39 functional interfaces in the `java.util.function` package are
    variations of the four interfaces we have just reviewed. These variations are
    created in order to achieve one or any combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Better performance by avoiding autoboxing and unboxing via the explicit usage
    of `int`, `double`, or `long` primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing two input parameters and/or a shorter notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are just a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntFunction<R>` with the `R apply(int)` method provides a shorter notation
    (without generics for the input parameter type) and avoids autoboxing by requiring
    the primitive `int` as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BiFunction<T,U,R>` with the `R apply(T,U)` method allows two input parameters;
    `BinaryOperator<T>` with the `T apply(T,T)` method allows two input parameters
    of type `T` and returns a value of the same type, `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntBinaryOperator` with the `int applAsInt(int,int)` method accepts two parameters
    of the `int` type and returns the value of the `int` type, too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are going to use functional interfaces, we encourage you to study the
    API of the interfaces of the `java.util.functional` package ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expression limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two aspects of a Lambda expression that we would like to point out
    and clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: If a Lambda expression uses a local variable created outside it, this local
    variable has to be final or effectively final (not reassigned in the same context).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword in a Lambda expression refers to the enclosing context, not
    the Lambda expression itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As in an `anonymous` class, the variable created outside and used inside a
    Lambda expression becomes effectively final and cannot be modified. The following
    is an example of an error caused by the attempt to change the value of an initialized
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this restriction is that a function can be passed around and
    executed in different contexts (different threads, for example), and an attempt
    to synchronize these contexts would defeat the original idea of the stateless
    function and the evaluation of the expression, depending only on the input parameters,
    not on the context variables. That is why all the local variables used in the
    Lambda expression have to be effectively final, meaning that they can either be
    *declared* final explicitly or *become* final by virtue of not changing the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one possible workaround for this limitation though. If the local variable
    is of a reference type (but not a `String` or primitive wrapping type), it is
    possible to change its state, even if this local variable is used in the Lambda
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: This workaround should be used with care because of the danger of unexpected
    side effects if this Lambda is executed in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` keyword inside an `anonymous` class refers to the instance of the
    `anonymous` class. By contrast, inside the Lambda expression, the `this` keyword
    refers to the instance of the class that surrounds the expression, also called
    an **enclosing instance**, **enclosing context**, or **enclosing scope**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s create a `ThisDemo` class that illustrates the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the preceding methods, the output will be as shown in the following
    code comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `this` keyword inside the `anonymous` class refers to the
    `anonymous` class instance, while `this` in a Lambda expression refers to the
    enclosing class instance. A Lambda expression just does not (and cannot) have
    a field. A Lambda expression is not a class instance and cannot be referred to
    by `this`. According to Javaâ€™s specifications, such an approach *allows more flexibility
    for implementations* by treating `this` the same as the surrounding context.
  prefs: []
  type: TYPE_NORMAL
- en: Method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, all our functions were short one-liners. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function consists of two or more lines, we could implement them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'When the size of a function implementation grows beyond several lines of code,
    such a code layout may not be easy to read. It may obscure the overall code structure.
    To avoid this issue, it is possible to move the function implementation into a
    method and then refer to this method in the Lambda expression. For example, letâ€™s
    add one static and one instance method to the class where the Lambda expression
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to demonstrate the variety of possibilities, letâ€™s create another class,
    with one static method and one instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can rewrite our last example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even if each function consists of many lines of code, such a
    structure keeps the code easy to read. Yet, when a one-line Lambda expression
    consists of a reference to an existing method, it is possible to further simplify
    the notation by using a method reference without listing the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the method reference is `Location::methodName`, where `Location`
    indicates in which object or class the `methodName` method belongs, and the two
    colons (`::`) serve as a separator between the location and the method name. Using
    method reference notation, the preceding example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: You have probably noticed that we have intentionally used different locations,
    two instance methods, and two static methods in order to demonstrate the variety
    of possibilities. If it feels like too much to remember, the good news is that
    a modern IDE (IntelliJ IDEA is one example) can do it for you and convert the
    code you are writing to the most compact form. You just have to accept the IDEâ€™s
    suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to functional programming by explaining and demonstrating
    the concept of functional interfaces and Lambda expressions. The overview of standard
    functional interfaces that comes with JDK helps you to avoid writing custom code,
    while the method reference notation allows you to write well-structured code that
    is easy to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are able to write functions and use them for Lambda expressions in
    order to pass them as a method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about data stream processing. We will define
    what data streams are, and look at how to process their data and how to chain
    stream operations in a pipeline. Specifically, we will discuss the streamsâ€™ initialization
    and operations (methods), how to connect them in a fluent style, and how to create
    parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a functional interface? Select all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A collection of functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface that has only one method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any interface that has only one abstract method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any library written in Java
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is a Lambda expression? Select all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function, implemented as an anonymous method without modifiers, return types,
    and parameter types
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A functional interface implementation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any implementation in a Lambda calculus style
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A notation that includes the list of parameters, an arrow token (->), and a
    body that consists of a single statement or a block of statements
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How many input parameters does the implementation of the `Consumer<T>` interface
    have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the type of the return value in the implementation of the `Consumer<T>`
    interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many input parameters does the implementation of the `Predicate<T>` interface
    have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the type of the return value in the implementation of the `Predicate<T>`
    interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many input parameters does the implementation of the `Supplier<T>` interface
    have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the type of the return value in the implementation of the `Supplier<T>`
    interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many input parameters does the implementation of the `Function<T,R>` interface
    have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the type of the return value in the implementation of the `Function<T,R>`
    interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Lambda expression, what does the `this` keyword refer to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is method reference syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
