<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Execution Control</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Throughout this book, we have been working with Reactor operators. This has included performing various tasks, such as filtering, transforming, and collecting. Most operators do not create additional threads and just work on the main thread. However, we can configure multithreading and concurrency in Reactor by using a set of</span> schedulers<span>.</span></p>
<p class="mce-root"><span>We will cover the following topics in this chapter:</span></p>
<ul>
<li>Schedulers</li>
<li>Parallel processing</li>
<li>Broadcasting</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>Java Standard Edition, JDK 8 or above</li>
<li><span>IntelliJ IDEA IDE, 2018.1 or above</span></li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09</a>.<a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter09"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scheduler</h1>
                </header>
            
            <article>
                
<p>Reactor executes all operations using one of the schedulers. A Reactor scheduler does not belong to the <kbd>java.util.concurrent</kbd> API. The Java concurrent API is quite low-level, where we can initiate and control task execution. On the other hand, all tasks in a Reactor chain are executed by the Reactor engine. Consequently, we do not need a low-level API to manage task execution. Instead, Reactor offers a declarative model, which we can use to configure a <kbd>Scheduler</kbd> and alter the behavior of the chain execution.  </p>
<p class="mce-root"/>
<p>Before we start to configure Reactor, let's first determine the default execution model. By default, Reactor is mostly single-threaded. The publisher and subscriber do not create additional threads for their execution. All life cycle hooks, and most operators, perform single-threaded execution. Before we jump ahead, let's build some code to validate this, as follows:</p>
<pre>    @Test<br/>    public void testReactorThread() throws Exception{<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>               sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            print("Generating next of "+ state.getT2());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                })<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>    }<br/><br/>    static void print(String text){<br/>        System.out.println("["+Thread.currentThread().getName()+"] "+text);<br/>    }</pre>
<p>In the preceding code, the following applies:</p>
<ol>
<li>We built a simple Fibonacci chain, using the <kbd>filter</kbd> operator and life cycle hooks.</li>
<li>Each operation prints to a console using the <kbd>print</kbd> function.</li>
<li>The <kbd>print</kbd> function prints the current thread name, along with the text.</li>
</ol>
<p>The following screenshot shows a simple debugging code snippet, which allows us to see how Reactor does stream execution. Let's run this and see how it works:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5110c466-7ed1-4abe-84fd-70c48f9d8126.png"/></div>
<p>In the preceding screenshot, we can see that all of the text is prefixed with <kbd>[main]</kbd>. Consequently, all operations are executed on the main thread, and no additional threads are used by Reactor. This output validates the idea that Reactor is single-threaded, by default. Due to the single-threaded execution, we did not pause the test execution using  <kbd>Thread.sleep</kbd> or <kbd>latch.wait</kbd>.</p>
<p>However, the preceding concept is only partially true; Reactor operators do alter the behavior of chain execution. Previously, we used <kbd>latch</kbd> and <kbd>Thread.sleep</kbd> in our test cases, for the delay and timeout operator. Let's add the operator to our test case and analyze the output, as follows:</p>
<pre> @Test<br/>    public void testReactorDelayThread() throws Exception{<br/>        // Removed for brevity<br/>        <br/>        fibonacciGenerator<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                }).delayElements(Duration.ZERO)<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>        Thread.sleep(500);<br/>    }</pre>
<p>In the preceding code, the following applies:</p>
<ol>
<li>We added the <kbd>delayElements</kbd> operator to our chain, after the <kbd>filter</kbd> operator.</li>
<li>The test now terminates quickly, so we need to add <kbd>Thread.sleep</kbd> to pause the execution of the main thread. The pause ensures that the complete chain is executed.</li>
</ol>
<p class="mce-root"/>
<p>Let's run this and analyze the output, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/36366260-ab46-4522-b2e3-04fce9cbfb8f.png"/></div>
<p>We can deduce the following by looking at the preceding output:</p>
<ul>
<li>The publisher does not create a thread; it executes in the main thread.</li>
<li>The <kbd>filter</kbd> operation does not create a thread; it executes in the main thread.</li>
<li>The <kbd>delayElements</kbd> operations add a thread pool of two threads, denoted by <kbd>parallel-1</kbd> and <kbd>parallel-2</kbd>.</li>
<li>The rest of the chain now executes in the thread pool, rather than the main thread.</li>
</ul>
<p>Now that you have gained some understanding of the threading model of Reactor, let's discuss the ways in which we can configure it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor schedulers</h1>
                </header>
            
            <article>
                
<p>As discussed in the previous section, Reactor operators configure reactive chain execution behavior. However, the behavior can be altered by using a different scheduler. Most of the operators have overloaded methods, which take a scheduler as an argument. In this section, we will look at the various schedulers available in Reactor. Reactor also provides a <kbd>schedulers</kbd> utility class, to build instances of the available implementations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The immediate scheduler</h1>
                </header>
            
            <article>
                
<p>The <kbd>Schedulers.immediate</kbd> scheduler executes work on the currently executing thread. All tasks are executed on the caller thread, and no task is performed in parallel. This is the default execution model for most Reactor tasks. Consider the following code:</p>
<pre>@Test<br/>  public void testImmediateSchedular() throws Exception{<br/><br/>       // Removed for Brevity<br/><br/>        fibonacciGenerator<br/>                .delayElements(Duration.ofNanos(10),Schedulers.immediate())<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>            .subscribe(x -&gt; print("Sub received : "+x));<br/>      Thread.sleep(500);<br/> }</pre>
<p>In the preceding code, the following has occurred:</p>
<ol>
<li>We added the <kbd>delayElements</kbd> operator to our chain.</li>
<li>The test tries to schedule the delay on the main thread.</li>
</ol>
<p>We can execute the code, but the task will fail, because the main thread lacks the time-based scheduling capability. The following screenshot shows this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d1152db0-c2a5-4ca0-91c7-afd42343bfeb.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The single scheduler</h1>
                </header>
            
            <article>
                
<p>The <kbd>Schedulers.single</kbd> scheduler executes work on a single-worker thread pool. Since this is a single worker, all tasks are executed one by one, and no task is performed in a concurrent manner. The scheduler is quite useful for isolating the execution of non-threadsafe operations to a single thread. Consider the following code:</p>
<pre>@Test<br/>  public void testSingleScheduler() throws Exception{<br/><br/>       // Removed for Brevity<br/><br/>        fibonacciGenerator<br/>                .delayElements(Duration.ofNanos(10),Schedulers.single())<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>           .subscribe(x -&gt; print("Sub received : "+x));<br/>      Thread.sleep(500);<br/> }</pre>
<p>In the preceding code, the following has occurred:</p>
<ol>
<li>We added the <kbd>delayElements</kbd> operator to our chain.</li>
<li>The test tries to schedule the delay on a single thread, and not on the main thread of test execution.</li>
</ol>
<p>From the output, we can validate that all of the tasks in the chain are executed on a <kbd>single-1</kbd> thread. Consider the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8eb38d32-4333-4ba7-9041-3ca1254d13c1.png"/></div>
<p>Here, the <kbd>single</kbd> scheduler is meant to execute non-blocking, computation-intensive operations. This can be treated as an event loop, executing non-blocking tasks in its queue. If we invoke any  reactive blocking APIs, the scheduler throws back the following error:</p>
<pre> @Test<br/>    public void testSingleSchedulerBlockingOps() throws Exception{<br/>       // Removed for Brevity<br/>        fibonacciGenerator<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                }).delayElements(Duration.ZERO,Schedulers.single())<br/>                .window(10)<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "+x))<br/>                .subscribe(x -&gt; print("Sub received : "+x.blockFirst()));<br/>        Thread.sleep(500);<br/>    }</pre>
<p>In addition to the chain discussed previously, the following has occurred in the preceding code:</p>
<ol>
<li>We invoked the <kbd>window</kbd> operator to generate batches of <kbd>10</kbd> elements each.</li>
<li>The subscriber invoked the <kbd>blockFirst</kbd> API to get back the first element.</li>
</ol>
<p>Executing the preceding code leads to the following exception:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53dbda69-8667-48a3-80b6-622dfff298f1.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The parallel scheduler</h1>
                </header>
            
            <article>
                
<p>The <kbd>Schedulers.parallel</kbd> scheduler executes work on a multiple-worker thread pool. It creates workers based on the number of available processors. This is the default scheduler used in various Reactor operators. Consider the following code:</p>
<pre>@Test<br/>    public void testParalleScheduler() throws Exception{<br/><br/>       // Removed for Brevity<br/><br/>        fibonacciGenerator<br/>                .delayElements(Duration.ofNanos(10),Schedulers.parallel())<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>           .subscribe(x -&gt; print("Sub received : "+x));<br/>      Thread.sleep(500);<br/> }</pre>
<p>From the output, we can validate that all of the tasks in the chain are executed on <kbd>paralle-1</kbd> and <kbd>parallel-2</kbd> threads. Go through the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/89563f6d-82a3-41b1-9ae3-c32573a5f199.png"/></div>
<p>Similar to the <kbd>single</kbd> scheduler, the <kbd>parallel</kbd> scheduler is aimed at executing non-blocking tasks. If an operation invokes any of the reactive blocking APIs, the scheduler will throw back the following exception:</p>
<pre>Caused by: java.lang.IllegalStateException: block()/blockFirst()/blockLast() are blocking, which is not supported in thread parallel-1<br/>    at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:77)<br/>    at reactor.core.publisher.Flux.blockFirst(Flux.java:2013)<br/>    at SchedulerTest.lambda$testSingleSchedulerBlockingOps$27(SchedulerTest.java:116)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The elastic scheduler</h1>
                </header>
            
            <article>
                
<p>The <kbd>Schedulers.elastic</kbd> scheduler executes work on a multiple-worker thread pool. Each of the executed workers can execute long-lived tasks that ask for a blocking operation. Each worker is returned to the pool when the task finishes. There is also an idle time associated with the worker, after which the worked is disposed. The scheduler tries to consume an existing idle worker, but if there aren't any, the scheduler dynamically generates one and schedules the task on it. The following code shows this:</p>
<pre>@Test<br/>    public void testElasticSchedular() throws Exception{<br/><br/>       // Removed for Brevity<br/><br/>        fibonacciGenerator<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                }).delayElements(Duration.ZERO,Schedulers.elastic())<br/>                .window(10)<br/>                .doOnNext(x -&gt; print("Next value is  "+ x))<br/>                .doFinally(x -&gt; print("Closing "+x))<br/>                .subscribe(x -&gt; print("Sub received : "+x.blockFirst()));<br/>      Thread.sleep(500);<br/> }</pre>
<p>Unlike the previous worker, a blocking reactive call executes on an elastic scheduler successfully. Consider the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/26525eb6-bb91-4dfa-838b-1f526af5eb51.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ExecutorService scheduler</h1>
                </header>
            
            <article>
                
<p>The <kbd>Schedulers.fromExecutor</kbd> enables us to build a scheduler over the Java <kbd>ExecutorService</kbd>. The scheduler does not own thread generation, but instead, it is controlled by the underlying <kbd>ExecutorService</kbd>. The scheduler should not be favored over other schedulers, as the life cycle of the <kbd>ExecutorService</kbd> must be managed by the developer. Consider the following code:</p>
<pre> @Test<br/>    public void testExecutorScheduler() throws Exception{<br/>        // Removed for Brevity<br/><br/>        ExecutorService executor = Executors.newSingleThreadExecutor();<br/>        fibonacciGenerator<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                }).delayElements(Duration.ZERO,Schedulers.fromExecutor(executor))<br/>                 .doOnNext(x -&gt; print("Next value is  "+ x))<br/>                .doFinally(x -&gt; print("Closing "+executor.isShutdown()))<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>        Thread.sleep(5000);<br/>        print("Is shutdown ? "+executor.isShutdown());<br/>    }</pre>
<p>In the following output, we can validate that the service is still running after the execution of our reactive chain:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6929c62c-c5ac-4ec0-81c6-d8f7f6d07cf2.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallel processing</h1>
                </header>
            
            <article>
                
<p>Reactor publishers and subscribers do not create threads. However, as seen in the previous section, there are operators that can alter this behavior. In the last section, we saw that the <kbd>delay</kbd> operator moved the execution of the Reactor chain from the main thread to the scheduler thread. However, we do not need delay/timeout operators for the purpose of switching execution. Reactor offers the <kbd>publishOn</kbd> and <kbd>subscribeOn</kbd> operators for the purpose of switching the chain execution. Both of these operators change the execution context of the reactive chain to the configured scheduler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PublishOn operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>publishOn</kbd> operator intercepts events from a publisher at a configured point in the execution chain, and sends them to a different scheduler for the rest of the chain. As a result, the operator changes the threading context of the downstream reactive chain. It is important to note that the operator only influences the downstream event chain. It does not alter the upstream chain, and leaves the upstream execution to the default execution model. The following code shows this:</p>
<pre>    @Test<br/>    public void testReactorPublishOn() throws Exception{<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            print("Generating next of "+ state.getT2());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator<br/>                .publishOn(Schedulers.single())<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                })<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>        Thread.sleep(500);<br/>    }</pre>
<p>In the preceding code, the following applies:</p>
<ol>
<li>We configured the <kbd>publishOn</kbd> operator before the <kbd>filter</kbd> operator. This should leave the generation on the main thread, and execute the rest of the chain on the scheduler.</li>
<li>We configured the <kbd>single</kbd> scheduler for the chain execution.</li>
<li>Since we are not executing the chain on the main thread, we have to pause the test execution for some time. This is accomplished by using <kbd>Thread.sleep</kbd>.</li>
</ol>
<p>Let's execute the test case and determine the output. The publisher generates events on the <kbd>main</kbd> thread, which are then passed over to a <kbd>single-1</kbd> thread, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53503a77-3911-41b3-856d-520025c25adc.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SubscribeOn operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>subscribeOn</kbd> operator intercepts events from a publisher in the execution chain and sends them to a different scheduler for the complete chain. It is important to note that the operator changes the execution context for the complete chain, unlike the <kbd>publishOn</kbd> operator, which only alters the execution of a downstream chain:</p>
<pre>@Test<br/>    public void testReactorSubscribeOn() throws Exception{<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            print("Generating next of "+ state.getT2());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator                <br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                })<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>                .subscribeOn(Schedulers.single())<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>      Thread.sleep(500);<br/> }</pre>
<p>In the preceding code, we did the following:</p>
<ol>
<li>Configured the <kbd>subscribeOn</kbd> operator, prior to subscribing.</li>
<li>Configured the <kbd>single</kbd> scheduler for the chain execution.</li>
<li>Since we are not executing the chain on the main thread, we have to pause the test execution for some time. This is accomplished by using <kbd>Thread.sleep</kbd>.</li>
</ol>
<p>Let's execute the test case and validate the output. All of the events are generated on the single thread configured by the <kbd>subscribeOn</kbd> operator:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e40c33e3-47ea-431d-b0e4-fc1ebe2ae80a.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We have the <kbd>subscribeOn</kbd> and <kbd>publishOn</kbd> operators in the same chain. The <kbd>subscribeOn</kbd> operator will execute the complete reactive chain on the configured scheduler. However, the <kbd>publishOn</kbd> operator will change the downstream chain to the specified scheduler. It leaves back the upstream chain on the scheduler configured by the <kbd>subscribeOn</kbd> scheduler:</p>
<pre> @Test<br/>    public void testReactorComposite() throws Exception{<br/>      // Removed for Brevity<br/>        fibonacciGenerator<br/>                .publishOn(Schedulers.parallel())<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                })<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .doFinally(x -&gt; print("Closing "))<br/>                .subscribeOn(Schedulers.single())<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>        Thread.sleep(500);<br/>    }</pre>
<p>The preceding code will generate events on a <kbd>single-1</kbd> scheduler, configured by the <kbd>subscribeOn</kbd> operator. The rest of the chain is executed on a parallel scheduler, configured by the <kbd>publishOn</kbd> operator.</p>
<p>The following is the output after running the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aecb7263-b72b-4e21-95f6-2a4e3599127b.png"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ParallelFlux</h1>
                </header>
            
            <article>
                
<p>Reactor offers <kbd>ParallelFlux</kbd>, which is capable of splitting an existing stream into multiple streams <span>in a round-robin manner</span><span>.</span> <kbd>ParallelFlux</kbd> is <span>created from an existing</span> <kbd>Flux</kbd>, <span>using the</span> <kbd>parallel</kbd> <span>operator. By default, this splits the stream into the total number of CPU cores that are available. </span><kbd>ParallelFlux</kbd> <span>only divides the stream, and does not change the execution model. Instead, it executes the streams on the default thread—the main thread. The divided stream can be configured for parallel processing by using the</span> <kbd>runOn</kbd> <span>operator. Similar to the</span> <kbd>publishOn</kbd> <span>operator, the</span> <kbd>runOn</kbd> <span>takes a scheduler and executes the downstream on the specified scheduler.</span></p>
<p>It is important to note that <kbd>ParallelFlux</kbd> does not offer the <kbd>doFinally</kbd> life cycle hook. It can be converted back to a <kbd>Flux</kbd> by using the <kbd>sequential</kbd> operator, which can then be configured by using the <kbd>doFinally</kbd> hook:</p>
<pre>@Test<br/>    public void testParalleFlux() throws Exception{<br/>      // Removed for Brevity<br/><br/>        fibonacciGenerator<br/>                .parallel()<br/>                .runOn(Schedulers.parallel())<br/>                .filter(x -&gt; {<br/>                    print("Executing Filter");<br/>                    return x &lt; 100;<br/>                })<br/>                .doOnNext(x -&gt; print("Next value is  "+x))<br/>                .sequential()<br/>                .doFinally(x -&gt; print("Closing "))<br/>                .subscribeOn(Schedulers.single())<br/>                .subscribe(x -&gt; print("Sub received : "+x));<br/>        Thread.sleep(500);<br/>    }</pre>
<p>In the preceding code, the following applies:</p>
<ol>
<li>The <kbd>parallel</kbd> operator is configured to generate <kbd>ParallelFlux</kbd> from <kbd>fibonacciGenerator</kbd>.</li>
<li>The <kbd>runOn</kbd> operator is used to configure <kbd>ParallelFlux</kbd> on the parallel scheduler.</li>
<li>The <kbd>sequential</kbd> operator is used to convert <kbd>ParallelFlux</kbd> to Flux.</li>
<li><kbd>doFinally</kbd> is configured on the <kbd>sequential</kbd> Flux.</li>
<li><kbd>subscribeOn</kbd> is configured to execute Flux generation on a single thread.</li>
</ol>
<p>Let's run the code and validate the output, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f82c6be-7615-42fb-954c-013baeb7e9d9.png"/></div>
<p>So far, we have discussed how to perform stream operations in parallel. In the next section, we will deliver events to all subscribers simultaneously, and then configure parallel processing for all of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Broadcasting</h1>
                </header>
            
            <article>
                
<p>In networking, <strong>broadcasting</strong> is defined as simultaneous event publishing to multiple receivers. In terms of Reactive Streams, this means simultaneous event publishing to multiple subscribers. Until now, we have subscribed to cold publishers, where each subscription generates a new series of events. We have even subscribed to hot publishers, where the publisher keeps pushing events without waiting for a subscriber. Each subscriber gets the same event as soon as it is generated. A hot publisher may look like a broadcasting event, but there is a key difference with regard to the start of the event generation stream. Reactor allows us to create a <kbd>ConnecatableFlux</kbd>, capable of waiting for <em>n</em> subscribers before starting event generation. It then keeps publishing each event to all of its subscribers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The replay operator</h1>
                </header>
            
            <article>
                
<p>Reactor provides the <kbd>replay</kbd> operator to convert a Flux to a <kbd>ConnectableFlux</kbd>. The resulting <kbd>ConnectableFlux</kbd> keeps buffering events published to the first subscriber. The buffer can be configured to keep the last <em>n</em> entries, or it can be configured to be based on the time duration. Only the buffered events are replayed back to the subscribers.</p>
<p>Refer to the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9415c581-8d26-468e-af00-a8ed25743872.png" style=""/></div>
<p>A <kbd>ConnectableFlux</kbd> must be subscribed by <em>n</em> subscribers before it starts to publish events. <kbd>ConnectableFlux</kbd> provides the following operators to manage subscribers:</p>
<ul>
<li><strong>Connect</strong>: The <kbd>connect</kbd> operator must be invoked after enough subscriptions have been made. We must manage the subscription count ourselves. Subscription cancellation must also be tracked by developers.</li>
<li><strong>Auto-Connect</strong>: The <kbd>autoConnect</kbd> operator configures a subscription count. This keeps track of subscriptions made to the publisher dynamically. It is best to use the <kbd>autoConnect</kbd> operator, and leave the subscription management to Reactor.</li>
</ul>
<p>Let's take a look at the following code:</p>
<pre>   @Test<br/>    public void testReplayBroadcast() throws Exception{<br/>        // Removed for Brevity<br/>        Flux&lt;Long&gt; broadcastGenerator=fibonacciGenerator.doFinally(x -&gt; {<br/>            System.out.println("Closing ");<br/>        }).replay().autoConnect(2);<br/><br/><br/>        fibonacciGenerator.subscribe(x -&gt; System.out.println("[Fib] 1st : "+x));<br/>        fibonacciGenerator.subscribe(x -&gt; System.out.println("[Fib] 2nd : "+x));<br/><br/>        broadcastGenerator.subscribe(x -&gt; System.out.println("1st : "+x));<br/>        broadcastGenerator.subscribe(x -&gt; System.out.println("2nd : "+x));<br/>      }</pre>
<p class="mce-root"/>
<p>In the preceding code, you can see the following:</p>
<ol>
<li>The <kbd>broadcastGenerator</kbd> is generated from <kbd>fibonacciGenerator</kbd>, using the <kbd>replay</kbd> operator.</li>
<li>The <kbd>broadcastGenerator</kbd> waits for two subscribers before starting event publishing.</li>
<li><kbd>fibonacciGenerator</kbd> is subscribed twice.</li>
<li><kbd>broadcastGenerator</kbd> is also subscribed twice.</li>
</ol>
<p>In the preceding code, we have subscribed twice, to both the <kbd>fibonacciGenerator</kbd> and <kbd>broadcastGenerator</kbd> publishers. Let's run the test case and validate the output, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed5f9ff8-5b15-46da-8f3e-6a48ba58103b.png"/></div>
<p>In the preceding screenshot (output), we can see that the <kbd>fibonacciGenerator</kbd> publisher is called every time the next value is requested by the respective publisher. However, the <kbd>broadcastGenerator</kbd> publisher is invoked once, and the same value is published to both subscribers before generating the next value.</p>
<p>The <kbd>connect</kbd> and <kbd>autoConnect</kbd> operators, discussed in the preceding section, only keep track of subscription events. These start to process events when the configured count is reached. They keep publishing them until the publisher sends a terminating event. These operators do not keep track of a subscriber cancelling the subscription; once event generation has started, it keeps generating events, even when the subscribers have cancelled their subscription.</p>
<p>Reactor provides a <kbd>refCount</kbd> operator for the previously discussed situation. The <kbd>refCount</kbd> operator also keeps track of the subscription. It stops generating new events if all subscribers have cancelled their subscription, as follows:</p>
<pre>@Test<br/>    public void testBroadcastWithCancel() throws Exception{<br/>        // removed for brevity<br/><br/>       fibonacciGenerator=fibonacciGenerator.doFinally(x -&gt;  System.out.println("Closing "))<br/>       .replay().autoConnect(2);<br/><br/>        fibonacciGenerator.subscribe(new BaseSubscriber&lt;Long&gt;() {<br/>            @Override<br/>            protected void hookOnSubscribe(Subscription subscription) {<br/>                request(1);<br/>            }<br/><br/>            @Override<br/>            protected void hookOnNext(Long value) {<br/>                System.out.println("1st: "+value);<br/>                cancel();<br/>            }<br/>        });<br/><br/>        fibonacciGenerator.subscribe(new BaseSubscriber&lt;Long&gt;() {<br/>            @Override<br/>            protected void hookOnNext(Long value) {<br/>                System.out.println("2nd : "+value);<br/>                cancel();<br/>            }<br/>        });<br/>        Thread.sleep(500);<br/><br/>    }</pre>
<p>In the preceding code, the following applies:</p>
<ul>
<li>The <kbd>fibonacciGenerator</kbd> is configured for two subscribers, before starting event publishing.</li>
<li>Each subscriber requests one event.</li>
<li>Each subscriber cancels its subscription while processing the generated event.</li>
</ul>
<p>Let's run the following test case to get the output, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/684e01be-2524-4778-9d07-50cead22f0b1.png"/></div>
<p class="mce-root"/>
<p>In the preceding output, we can see that the complete Fibonacci series is generated before the stream is closed. The subscribers did not ask for more than one event. Now, let's replace <kbd>autoConnect</kbd> with <kbd>refCount</kbd>, and compare the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/658f0cfe-4d09-4339-aa64-53737ae41973.png"/></div>
<p>In the preceding output, you can see that the stream is closed as soon as all subscribers have cancelled their subscription. Now, if new subscribers arrive at <kbd>ConnectedFlux</kbd>, the series is generated from the first event.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The publish operator</h1>
                </header>
            
            <article>
                
<p>Reactor provides the <kbd>publish</kbd> operator to generate a <kbd>ConnectedFlux</kbd>. Unlike the <kbd>replay</kbd> operator, which buffers events received by the first subscriber, the <kbd>publish</kbd> operator gets events from the source stream. The operator keeps track of the demands raised by its subscribers. If any subscriber does not raise a demand, it pauses the event generation until a new demand is raised by all of its subscribers. Consider the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bb8f3485-b6fc-493d-b584-788333cd970e.png" style=""/></div>
<p>Just like the <kbd>replay</kbd> operator, the <kbd>ConnectedFlux</kbd> generated by the publisher also needs subscriber management. Here, we can configure this by using any of the following three options—<kbd>connect</kbd>, <kbd>autoConnect</kbd>, or <kbd>refCount</kbd>:</p>
<pre> @Test<br/>    public void testPublishBroadcast() throws Exception{<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            System.out.println("generating next of "+ state.getT2());<br/><br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator=fibonacciGenerator.doFinally(x -&gt; {<br/>            System.out.println("Closing ");<br/>        }).publish().autoConnect(2);<br/><br/>        fibonacciGenerator.subscribe(new BaseSubscriber&lt;Long&gt;() {<br/>            @Override<br/>            protected void hookOnSubscribe(Subscription subscription) {<br/>                request(1);<br/>            }<br/><br/>            @Override<br/>            protected void hookOnNext(Long value) {<br/>                System.out.println("1st: "+value);<br/>            }<br/>        });<br/><br/>        fibonacciGenerator.subscribe(x -&gt; System.out.println("2nd : "+x));<br/>        Thread.sleep(500);<br/><br/>    }</pre>
<p>In the preceding code, the following applies:</p>
<ol>
<li>The <kbd>fibonacciGenerator</kbd> is configured for two subscribers, before starting event publishing.</li>
<li>The first subscriber requests only one event.</li>
<li>The second subscriber does not put a constraint on the event count.</li>
</ol>
<p>Let's run the test case to analyze the output, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eb239031-d37e-4604-89ec-6b9c155a5f6e.png"/></div>
<p>In the preceding output, you can see that only the first event is generated. There is no closing event either, because the stream was waiting for the next event request from subscriber one. Consequently, the stream did not terminate. The test finished after waiting for 500 ms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored Reactor execution models. We discovered that publisher and subscriber R<span>eactive Streams </span><span>are concurrency agnostic</span><span>. Most of the operators in Reactor are also concurrency agnostic. Some operators, such as</span> <kbd>delayElements</kbd> <span>and</span> <kbd>timeout</kbd><span>, do alter the concurrency behavior of a stream's execution. Reactor provides various schedulers, which can be used to control the execution behavior of the stream. We found out that these schedulers can be configured for various operators, such as </span><kbd>publishOn</kbd> <span>and</span> <kbd>subscribeOn</kbd><span>. Next, we discussed</span> <kbd>ParallelFlux</kbd>, <span>which can be configured, along with the available schedulers, to perform parallel processing. Finally, we discussed event broadcasting by using</span> <kbd>ConnectedFlux</kbd><span>. Reactor presents</span> <kbd>replay</kbd> <span>and</span> <kbd>publishOn</kbd> <span>operators, to generate a</span> <kbd>ConnectedFlux</kbd> <span>from an existing Flux.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the different types of schedulers that are available in Reactor?</li>
<li>What scheduler should be used for blocking operations?</li>
<li>What scheduler should be used for computation-intensive operations?</li>
<li>How are <kbd>PublishOn</kbd> and <kbd>SubscriberOn</kbd> different from each other?</li>
<li>What is the limitation of <kbd>ParallelFlux</kbd>?</li>
<li>Which operators are available for generating a <kbd>ConnectedFlux</kbd>?</li>
</ol>


            </article>

            
        </section>
    </body></html>