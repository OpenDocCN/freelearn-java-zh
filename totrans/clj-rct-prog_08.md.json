["```java\n(def f (clojure.core/future\n         (println \"doing some expensive work...\")\n         (Thread/sleep 5000)\n         (println \"done\")\n         10))\n(println \"You'll see me before the future finishes\")\n;; doing some expensive work...\n;; You'll see me before the future finishes\n;; done\n```", "```java\nclojure.core/future macro with a body simulating an expensive computation. In this example, it simply sleeps for 5 seconds before returning the value 10\\. As the output demonstrates, this does not block the main thread, which is free to serve more clients, pick work items from a queue, or what have you.\n```", "```java\n(def f (clojure.core/future\n         (println \"doing some expensive work...\")\n         (Thread/sleep 5000)\n         (println \"done\")\n         10))\n(println \"You'll see me before the future finishes\")\n@f\n(println \"I could be doing something else. Instead I had to wait\")\n\n;; doing some expensive work...\n;; You'll see me before the future finishes\n;; 5 SECONDS LATER\n;; done\n;; I could be doing something else. Instead, I had to wait\n```", "```java\nlein new clj-futures-playground\n\n```", "```java\n(ns clj-futures-playground.core\n  (:require [clojure.pprint :refer [pprint]]))\n\n(def movie\n  {:name \"Lord of The Rings: The Fellowship of The Ring\"\n   :cast [\"Cate Blanchett\"\n          \"Elijah Wood\"\n          \"Liv Tyler\"\n          \"Orlando Bloom\"]})\n\n(def actor-movies\n  [{:name \"Cate Blanchett\"\n    :movies [\"Lord of The Rings: The Fellowship of The Ring\"\n             \"Lord of The Rings: The Return of The King\"\n             \"The Curious Case of Benjamin Button\"]}\n\n   {:name \"Elijah Wood\"\n    :movies [\"Eternal Sunshine of the Spotless Mind\"\n             \"Green Street Hooligans\"\n             \"The Hobbit: An Unexpected Journey\"]}\n\n   {:name \"Liv Tyler\"\n    :movies [\"Lord of The Rings: The Fellowship of The Ring\"\n             \"Lord of The Rings: The Return of The King\"\n             \"Armageddon\"]}\n\n   {:name \"Orlando Bloom\"\n    :movies [\"Lord of The Rings: The Fellowship of The Ring\"\n             \"Lord of The Rings: The Return of The King\"\n             \"Pirates of the Caribbean: The Curse of the Black Pearl\"]}])\n\n(def actor-spouse\n  [{:name \"Cate Blanchett\"    :spouse \"Andrew Upton\"}\n   {:name \"Elijah Wood\"       :spouse \"Unknown\"}\n   {:name \"Liv Tyler\"         :spouse \"Royston Langdon\"}\n   {:name \"Orlando Bloom\"     :spouse \"Miranda Kerr\"}])\n(def top-5-movies\n  [\"Lord of The Rings: The Fellowship of The Ring\"\n   \"The Matrix\"\n   \"The Matrix Reloaded\"\n   \"Pirates of the Caribbean: The Curse of the Black Pearl\"\n   \"Terminator\"])\n```", "```java\n(defn cast-by-movie [name]\n  (future (do (Thread/sleep 5000)\n              (:cast  movie))))\n\n(defn movies-by-actor [name]\n  (do (Thread/sleep 2000)\n      (->> actor-movies\n           (filter #(= name (:name %)))\n           first)))\n\n(defn spouse-of [name]\n  (do (Thread/sleep 2000)\n      (->> actor-spouse\n           (filter #(= name (:name %)))\n           first)))\n\n(defn top-5 []\n  (future (do (Thread/sleep 5000)\n              top-5-movies)))\n```", "```java\n(defn aggregate-actor-data [spouses movies top-5]\n  (map (fn [{:keys [name spouse]} {:keys [movies]}]\n         {:name   name\n          :spouse spouse\n          :movies (map (fn [m]\n                         (if (some #{m} top-5)\n                           (str m \" - (top 5)\")\n                           m))\n                       movies)})\n       spouses\n       movies))\n```", "```java\n(defn -main [& args]\n  (time (let [cast    (cast-by-movie \"Lord of The Rings: The Fellowship of The Ring\")\n              movies  (pmap movies-by-actor @cast)\n              spouses (pmap spouse-of @cast)\n              top-5   (top-5)]\n          (prn \"Fetching data...\")\n          (pprint (aggregate-actor-data spouses movies @top-5))\n          (shutdown-agents))))\n```", "```java\nFirst, we wrap the whole body in a call to time, a simple benchmarking function that comes with Clojure. This is just so we know how long the program took to fetch all data—this information will become relevant later.\n```", "```java\nlein run -m clj-futures-playground.core\n\n\"Fetching data...\"\n({:name \"Cate Blanchett\",\n :spouse \"Andrew Upton\",\n :movies\n (\"Lord of The Rings: The Fellowship of The Ring - (top 5)\"\n \"Lord of The Rings: The Return of The King\"\n \"The Curious Case of Benjamin Button\")}\n {:name \"Elijah Wood\",\n :spouse \"Unknown\",\n :movies\n (\"Eternal Sunshine of the Spotless Mind\"\n \"Green Street Hooligans\"\n \"The Hobbit: An Unexpected Journey\")}\n {:name \"Liv Tyler\",\n :spouse \"Royston Langdon\",\n :movies\n (\"Lord of The Rings: The Fellowship of The Ring - (top 5)\"\n \"Lord of The Rings: The Return of The King\"\n \"Armageddon\")}\n {:name \"Orlando Bloom\",\n :spouse \"Miranda Kerr\",\n :movies\n (\"Lord of The Rings: The Fellowship of The Ring - (top 5)\"\n \"Lord of The Rings: The Return of The King\"\n \"Pirates of the Caribbean: The Curse of the Black Pearl - (top 5)\")})\n\"Elapsed time: 10120.267 msecs\"\n\n```", "```java\n  (time (let [cast    (cast-by-movie \"Lord of The Rings: The Fellowship of The Ring\")\n              ;; the following line blocks\n              movies  (pmap movies-by-actor @cast)\n              spouses (pmap spouse-of @cast)\n              top-5   (top-5)]\n```", "```java\ncast-by-movie to finish. As stated previously, Clojure futures don't give us a way to run some piece of code when the future finishes—like a callback—forcing us to block too soon.\n```", "```java\nlein new imminent-playground\n\n```", "```java\n:dependencies [[org.clojure/clojure \"1.6.0\"]\n               [com.leonardoborges/imminent \"0.1.0\"]]\n```", "```java\n(ns imminent-playground.repl\n  (:require [imminent.core :as Ii]))\n\n(def  repl-out *out*)\n(defn prn-to-repl [& args]\n  (binding [*out* repl-out]\n    (apply prn args)))\n```", "```java\nFeel free to type this in the REPL as we go along. Otherwise, you can require the namespace file from a running REPL like so:\n```", "```java\n(require 'imminent-playground.repl)\n\n```", "```java\n(def age (i/future 31))\n\n;; #<Future@2ea0ca7d: #<Success@3e4dec75: 31>>\n```", "```java\n(def failed-computation   (i/future (throw (Exception. \"Error\"))))\n;; #<Future@63cd0d58: #<Failure@2b273f98: #<Exception java.lang.Exception: Error>>>\n\n(def failed-computation-1 (i/failed-future :invalid-data))\n;; #<Future@a03588f: #<Failure@61ab196b: :invalid-data>>\n```", "```java\n@age           ;; #<Success@3e4dec75: 31>\n(deref @age)   ;; 31\n(i/dderef age) ;; 31\n```", "```java\n@(i/future (do (Thread/sleep 500)\n               \"hello\"))\n;; :imminent.future/unresolved\n```", "```java\n(def double-age (i/map age #(* % 2)))\n;; #<Future@659684cb: #<Success@7ce85f87: 62>>\n```", "```java\n(i/on-success age #(prn-to-repl (str \"Age is: \" %)))\n;; \"Age is: 31\"\n```", "```java\n(-> failed-computation\n    (i/map #(* % 2)))\n;; #<Future@7f74297a: #<Failure@2b273f98: #<Exception java.lang.Exception: Error>>>\n```", "```java\n(i/map (i/success \"hello\")\n       #(str % \" world\"))\n;; #<Success@714eea92: \"hello world\">\n\n(i/map (i/failure \"error\")\n       #(str % \" world\"))\n;; #<Failure@6d685b65: \"error\">\n```", "```java\n(i/map-failure (i/success \"hello\")\n               #(str % \" world\"))\n;; #<Success@779af3f4: \"hello\">\n\n(i/map-failure (i/failure \"Error\")\n               #(str \"We failed: \" %))\n;; #<Failure@52a02597: \"We failed: Error\">\n```", "```java\n(i/on-complete age\n               (fn [result]\n                 (i/map result #(prn-to-repl \"success: \" %))\n                 (i/map-failure result #(prn-to-repl \"error: \" %))))\n\n;; \"success: \" 31\n```", "```java\n(defn range-future [n]\n  (i/const-future (range n)))\n\n(def age-range (i/map age range-future))\n\n;; #<Future@3d24069e: #<Success@82e8e6e: #<Future@2888dbf4: #<Success@312084f6: (0 1 2...)>>>>\n```", "```java\n(def age-range (i/flatmap age range-future))\n\n;; #<Future@601c1dfc: #<Success@55f4bcaf: (0 1 2 ...)>>\n```", "```java\n(def name (i/future (do (Thread/sleep 500)\n                        \"Leo\")))\n(def genres (i/future (do (Thread/sleep 500)\n                          [\"Heavy Metal\" \"Black Metal\" \"Death Metal\" \"Rock 'n Roll\"])))\n\n(->  (i/sequence [name age genres])\n     (i/on-success\n      (fn [[name age genres]]\n        (prn-to-repl (format \"%s is %s years old and enjoys %s\"\n                             name\n                             age\n                             (clojure.string/join \",\" genres))))))\n\n;; \"Leo is 31 years old and enjoys Heavy Metal,Black Metal,Death Metal,Rock 'n Roll\"\n```", "```java\n(defn calculate-double [n]\n  (i/const-future (* n 2)))\n\n(-> (i/map-future calculate-double [1 2 3 4])\n    i/await\n    i/dderef)\n\n;; [2 4 6 8]\n```", "```java\n(ns imminent-playground.core\n  (:require [clojure.pprint :refer [pprint]]\n            [imminent.core :as i]))\n\n(def movie ...)\n\n(def actor-movies ...)\n\n(def actor-spouse ...)\n\n(def top-5-movies ...)\n```", "```java\nThe service functions will need small tweaks in this new version:\n```", "```java\n(defn cast-by-movie [name]\n  (i/future (do (Thread/sleep 5000)\n                (:cast  movie))))\n\n(defn movies-by-actor [name]\n  (i/future (do (Thread/sleep 2000)\n                (->> actor-movies\n                     (filter #(= name (:name %)))\n                     first))))\n\n(defn spouse-of [name]\n  (i/future (do (Thread/sleep 2000)\n                (->> actor-spouse\n                     (filter #(= name (:name %)))\n                     first))))\n\n(defn top-5 []\n  (i/future (do (Thread/sleep 5000)\n                top-5-movies)))\n\n(defn aggregate-actor-data [spouses movies top-5]\n    ...)\n```", "```java\n(defn -main [& args]\n  (time (let [cast    (cast-by-movie \"Lord of The Rings: The Fellowship of The Ring\")\n              movies  (i/flatmap cast #(i/map-future movies-by-actor %))\n              spouses (i/flatmap cast #(i/map-future spouse-of %))\n              result  (i/sequence [spouses movies (top-5)])]\n          (prn \"Fetching data...\")\n          (pprint (apply aggregate-actor-data\n                      (i/dderef (i/await result)))))))\n```", "```java\nmovies  (i/flatmap cast #(i/map-future movies-by-actor %))\n```", "```java\nresult  (i/sequence [spouses movies (top-5)])\n```", "```java\n(pprint (apply aggregate-actor-data\n                      (i/dderef (i/await result)))\n```", "```java\nlein run -m imminent-playground.core\n\"Fetching data...\"\n({:name \"Cate Blanchett\",\n :spouse \"Andrew Upton\",\n :movies\n (\"Lord of The Rings: The Fellowship of The Ring - (top 5)\"\n \"Lord of The Rings: The Return of The King\"\n \"The Curious Case of Benjamin Button\")}\n...\n\"Elapsed time: 7088.398 msecs\"\n\n```", "```java\n(let [...\n      result  (i/sequence [spouses movies (top-5)])]\n   ...)\n```", "```java\n  (-> (immi/blocking-future \n       (Thread/sleep 100)\n       10)\n      (immi/await))\n  ;; #<Future@4c8ac77a: #<Success@45525276: 10>>\n\n  (-> (immi/blocking-future-call\n       (fn []\n         (Thread/sleep 100)\n         10))\n      (immi/await))\n  ;; #<Future@37162438: #<Success@5a13697f: 10>>\n```"]