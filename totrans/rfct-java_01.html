<html><head></head><body>
<div id="_idContainer014">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">What is Refactoring?</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Picture this. </span><span class="koboSpan" id="kobo.3.2">It’s your first day at a new job, and you’re filled with excitement and eager to showcase your skills. </span><span class="koboSpan" id="kobo.3.3">Your new colleagues are enjoyable to be around, the company seems fine, and you’re itching to get started. </span><span class="koboSpan" id="kobo.3.4">Your “onboarding buddy” begins showing you the project that you’ll be working on for the next several months or even years. </span><span class="koboSpan" id="kobo.3.5">The concepts behind it are promising, and the business itself is stable. </span><span class="koboSpan" id="kobo.3.6">However, the code base is an enormous, chaotic mess—like a smoking, tangled plate of spaghetti. </span><span class="koboSpan" id="kobo.3.7">Well, perhaps you don’t need to imagine it. </span><span class="koboSpan" id="kobo.3.8">It’s likely you’ve been in that situation before. </span><span class="koboSpan" id="kobo.3.9">Maybe you’re even experiencing it </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">right now.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">As soon as you open your IDE, you’re greeted with a plethora of modules with very similar names. </span><span class="koboSpan" id="kobo.5.2">Once you enter a module, you’re met with a daunting number of classes, some of which run hundreds of lines. </span><span class="koboSpan" id="kobo.5.3">These classes often house methods with vague names such as “</span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">manageThis</span></strong><span class="koboSpan" id="kobo.7.1">” or “</span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">processThat</span></strong><span class="koboSpan" id="kobo.9.1">,” and they tend to be burdened with an excessive number of parameters. </span><span class="koboSpan" id="kobo.9.2">Suffice it to say, this isn’t the most conducive environment for grasping the inner workings of your new project. </span><span class="koboSpan" id="kobo.9.3">Brace yourself for a few challenging weeks – or even months – of work, as the code base and architecture of the project are far from optimal. </span><span class="koboSpan" id="kobo.9.4">Lack of documentation or poor code commenting can make things even more challenging when dealing with existing code issues. </span><span class="koboSpan" id="kobo.9.5">However, if the code itself is well written and follows good architecture practices, it can compensate for the lack of documentation (which is definitely not something desirable) and minimize the need for excessive comments (we’ll delve into this in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the book).</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Let me be clear: it’s not about blaming. </span><span class="koboSpan" id="kobo.11.2">Every one of us – and by “us,” I mean a large group of people I could call “The Software Development Community” – has a slightly different way of solving the very same problem. </span><span class="koboSpan" id="kobo.11.3">And everyone, at least once in their lifetime, thought “I would have done it better.” </span><span class="koboSpan" id="kobo.11.4">But again, every one of us knows – or will know – that it’s a lot about circumstances. </span><span class="koboSpan" id="kobo.11.5">If a certain module or piece of code was completed quickly but poorly, it is likely because someone requested it to be completed quickly. </span><span class="koboSpan" id="kobo.11.6">Sometimes, we come across situations where contradictory requirements are given to us or when priorities change due to internal or external events that take place. </span><span class="koboSpan" id="kobo.11.7">This request may have been made due to a valid business reason, a critical security concern, or any other reason that they deemed important. </span><span class="koboSpan" id="kobo.11.8">No one is lazy; (almost) nobody works poorly. </span><span class="koboSpan" id="kobo.11.9">It’s just a matter of circumstances. </span><span class="koboSpan" id="kobo.11.10">We’ve all felt </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">that pressure.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">The techniques and concepts</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.14.1"> that fall under the broad umbrella of “refactoring” help prevent you from ending up in that situation, ensuring that your code doesn’t become that plate of spaghetti. </span><span class="koboSpan" id="kobo.14.2">These techniques, and, more importantly, the mindset associated with refactoring, can also assist you in improving the existing code base, gracefully navigating the swamp you find yourself in, without feeling overwhelmed. </span><span class="koboSpan" id="kobo.14.3">In this chapter, we will explore the meaning of refactoring and, in reality, how elusive it can be. </span><span class="koboSpan" id="kobo.14.4">I will try to narrate, also based on my experience, the motivations behind refactoring – motivations that will probably be familiar to you. </span><span class="koboSpan" id="kobo.14.5">I will then give you some advice on how to organize your refactoring sessions and how to prioritize the various parts that need to be fixed in </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">But let’s start slowly, trying to agree on what we mean by the term that gives the title to </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">In this chapter, we’ll cover </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">these topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">What do we mean </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">by refactoring?</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Why you should </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">consider refactoring</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">When you </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">should refactor</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">What you </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">should refactor</span></span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.28.1">What do we mean by refactoring?</span></h1>
<p><span class="koboSpan" id="kobo.29.1">If we should give a strict definition</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.30.1"> of refactoring, we could be in some trouble, because it is often interpreted in different ways. </span><span class="koboSpan" id="kobo.30.2">The most common meaning, anyway, is related to code rewriting. </span><span class="koboSpan" id="kobo.30.3">Code refactoring is the process of restructuring and improving existing code without changing its behavior. </span><span class="koboSpan" id="kobo.30.4">Code is rewritten so that it is easier to understand and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">to modify.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">We could also give a “recursive” definition of refactoring: a series of refactorings applied to the software without changing </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">its behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Let me highlight this again because it’s very important: the software will return the very same results as before, no more and no less. </span><span class="koboSpan" id="kobo.34.2">It will just be written differently. </span><span class="koboSpan" id="kobo.34.3">The main (maybe the only) target you have to achieve is to make your code easier to understand, and this is one of the most important yet most difficult tasks </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">to accomplish.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Refactoring could also be bounded with another couple </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">of concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">It can be viewed as a way of iteratively improving the design of a software system. </span><span class="koboSpan" id="kobo.38.2">As the system evolves, its design can degrade and become outdated, leading to issues such as increased complexity, reduced maintainability, and reduced flexibility. </span><span class="koboSpan" id="kobo.38.3">Refactoring helps to address these issues by making incremental changes to the design of the system, improving its overall quality and maintainability. </span><span class="koboSpan" id="kobo.38.4">Moreover, refactoring can be used as a technique for discovering the underlying design of a system. </span><span class="koboSpan" id="kobo.38.5">By identifying patterns and commonalities in the code, developers can gain insights into the design of the system and identify areas</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.39.1"> for improvement. </span><span class="koboSpan" id="kobo.39.2">We’ll deepen this concept in the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">following paragraph.</span></span></p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.41.1">Refactoring and clean code</span></h2>
<p><span class="koboSpan" id="kobo.42.1">Refactoring is also closely tied</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.43.1"> to the concept of clean code. </span><span class="koboSpan" id="kobo.43.2">We’ll go into details</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.44.1"> in the next chapter, but we can briefly say that clean code refers to code that is easy to read, understand, and </span><em class="italic"><span class="koboSpan" id="kobo.45.1">maintain</span></em><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Refactoring is one of the primary ways in which developers can ensure that their code remains clean. </span><span class="koboSpan" id="kobo.46.3">By continuously improving the design of their code through refactoring, developers can eliminate code smells (a code smell is a sign of a potential problem in the source code – we’ll deep dive into this later on in the book) and improve the overall quality of the code base. </span><span class="koboSpan" id="kobo.46.4">Refactoring helps to keep the code base</span><em class="italic"><span class="koboSpan" id="kobo.47.1"> maintainable</span></em><span class="koboSpan" id="kobo.48.1"> and extensible, reducing the risk of issues. </span><span class="koboSpan" id="kobo.48.2">Refactoring can help to ensure that the code base remains aligned with the principles of clean code. </span><span class="koboSpan" id="kobo.48.3">When your code is not clean enough – and we will see what this means in the following chapter – what you have to do is just stop </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and refactor.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.50.1">Misconceptions about refactoring</span></h2>
<p><span class="koboSpan" id="kobo.51.1">There are various concepts</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.52.1"> that may resemble refactoring but are not synonymous with it. </span><span class="koboSpan" id="kobo.52.2">Exploring these concepts can contribute to a better comprehension </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">of refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Refactoring is not about optimization. </span><span class="koboSpan" id="kobo.54.2">However, refactored code could have </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">better performance.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Let me explain a little bit better. </span><span class="koboSpan" id="kobo.56.2">The main purpose of refactoring is to make your code easier to read, not to – for instance – reduce its cyclomatic complexity. </span><span class="koboSpan" id="kobo.56.3">(Cyclomatic complexity is a way to measure how complex a program’s flow is. </span><span class="koboSpan" id="kobo.56.4">It counts the number of different paths or decision points in the code. </span><span class="koboSpan" id="kobo.56.5">The higher the complexity, the more complicated the code becomes. </span><span class="koboSpan" id="kobo.56.6">It’s a useful tool for gauging code maintainability and finding areas that could use some simplification or extra testing.) It’s quite the opposite! </span><span class="koboSpan" id="kobo.56.7">Improving your code’s performance will probably reduce its readability… and it’s OK because the purposes are different. </span><span class="koboSpan" id="kobo.56.8">Refactoring is one thing; improving performance is another. </span><span class="koboSpan" id="kobo.56.9">Nonetheless, it is also true that more readable code could be, in some cases, also </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">more efficient.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Here’s a very </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">simple</span></span><span class="No-Break"><a id="_idIndexMarker006"/></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1"> example.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Suppose you have this (very </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">old-school) method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
public static int sumArray(int[] arr) {
    int sum = 0;
    for (int i : arr) {
    sum += i;
    }
    return sum;
}</span></pre> <p><span class="koboSpan" id="kobo.64.1">As you can easily see, this method just takes an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">int</span></strong><span class="koboSpan" id="kobo.66.1"> elements and sums them, scanning the array one element at a time. </span><span class="koboSpan" id="kobo.66.2">We could try to make this method faster, without changing its behavior, by writing </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
public static int sumArray(int[] arr) {
    int sum = 0;
    int i = 0;
    int len = arr.length;
    while (i &lt; len - 1) {
    sum += arr[i++] + arr[i++];
    }
    if (i == len - 1) {
    sum += arr[i];
    }
    return sum;
}</span></pre> <p><span class="koboSpan" id="kobo.69.1">The refactored method uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">while</span></strong><span class="koboSpan" id="kobo.71.1"> loop instead of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">for</span></strong><span class="koboSpan" id="kobo.73.1"> loop and increments the loop counter by 2 in each iteration. </span><span class="koboSpan" id="kobo.73.2">This allows the method to process two elements of the array at a time, effectively</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.74.1"> reducing the number of iterations needed to sum the array. </span><span class="koboSpan" id="kobo.74.2">This is a bit more efficient, but it is not more readable for sure. </span><span class="koboSpan" id="kobo.74.3">We reached the goal of optimization, but we did not refactor the code. </span><span class="koboSpan" id="kobo.74.4">How could we reach both goals? </span><span class="koboSpan" id="kobo.74.5">For instance, using a plain, simple one-liner such </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">as this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
public static int sumArray(int[] array) {
    return IntStream.of(array).parallel().sum();
}</span></pre> <p><span class="koboSpan" id="kobo.77.1">This method uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">IntStream</span></strong><span class="koboSpan" id="kobo.79.1"> class from Java 8’s Stream API to perform a parallel sum operation on the elements of the array. </span><span class="koboSpan" id="kobo.79.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">parallel()</span></strong><span class="koboSpan" id="kobo.81.1"> method enables parallel processing, allowing multiple threads to work on different portions of the array simultaneously. </span><span class="koboSpan" id="kobo.81.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">sum()</span></strong><span class="koboSpan" id="kobo.83.1"> method then calculates the sum of all the elements in </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the array.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Refactoring is not “fixing bugs.” </span><span class="koboSpan" id="kobo.85.2">This is much like the matter of complexity we just saw: you could fix a bug by refactoring a piece of code but it would be almost accidental. </span><span class="koboSpan" id="kobo.85.3">Or, better, it would be like killing two birds with a stone: if you can fix a bug </span><em class="italic"><span class="koboSpan" id="kobo.86.1">and</span></em><span class="koboSpan" id="kobo.87.1"> refactor a piece of code, it’s a big win! </span><span class="koboSpan" id="kobo.87.2">But remember – it’s generally advised not to mix different code actions in a single code change, even though it </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">frequently happens.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Refactoring can actually </span><em class="italic"><span class="koboSpan" id="kobo.90.1">help</span></em><span class="koboSpan" id="kobo.91.1"> you solve bugs, but we’ll see it </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">later on.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Most important, refactoring is not “adding features.” </span><span class="koboSpan" id="kobo.93.2">When you’re adding functions to your software, you should not change existing code, but just add capabilities. </span><span class="koboSpan" id="kobo.93.3">On the contrary, when you refactor, your northern star shouldn’t be to change the existing behavior. </span><span class="koboSpan" id="kobo.93.4">As a software professional, you will probably find yourself switching between these two aspects. </span><span class="koboSpan" id="kobo.93.5">The important thing is that you are aware of what you are doing: you structure the code better, then you add new functionality; once the new functionalities are tested and proven to be working, you can refactor again; and so on. </span><span class="koboSpan" id="kobo.93.6">It’s like you’re wearing two hats (using Kent Beck’s metaphor) and you keep swapping them: you can and you should, but remember which one you’re wearing at </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">each moment.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">In certain situations, there might be pressure from the business to prioritize adding new features instead of allocating time for refactoring, which may be seen as having no immediate value or merely serving the IT department. </span><span class="koboSpan" id="kobo.95.2">As a result, attempting to incorporate refactoring tasks discreetly within feature releases can lead to a blurring of roles. </span><span class="koboSpan" id="kobo.95.3">This means that you are not maintaining</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.96.1"> separate focuses or responsibilities (you’re not </span><em class="italic"><span class="koboSpan" id="kobo.97.1">wearing two hats</span></em><span class="koboSpan" id="kobo.98.1">), thus creating a mixture </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">of objectives.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Now that we know, more or less, what refactoring means, we are ready to get the reasons </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">behind it.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.102.1">Why you should consider refactoring</span></h1>
<p><span class="koboSpan" id="kobo.103.1">We just saw that refactoring</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.104.1"> is highly coupled with the concept of clean code. </span><span class="koboSpan" id="kobo.104.2">Hence, we could say that one of the most important outtakes of refactoring your code is to improve its readability. </span><span class="koboSpan" id="kobo.104.3">In other words, refactoring makes your code easier </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">Even if the main goal of writing code is to tell a machine to do what you want, exactly the way you want it, it’s important to underline something that we tend to forget, sometimes: you have to be understood not only by computers, but first and foremost you have to be understood by human beings. </span><span class="koboSpan" id="kobo.106.2">And one of those human beings is you: your future self! </span><span class="koboSpan" id="kobo.106.3">In my experience, I’ve found myself a lot of times asking, “Why?!” </span><span class="koboSpan" id="kobo.106.4">looking at a piece of code I wrote, maybe just </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">weeks before.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Although it may seem simple or even naive, the idea of writing readable code is often overlooked due to the urgency of making our programs work. </span><span class="koboSpan" id="kobo.108.2">While this is certainly important, we must also remember that a significant portion of our work as software professionals is devoted to maintenance. </span><span class="koboSpan" id="kobo.108.3">In my experience, the opportunity to start a project from scratch is rare; more often than not, we inherit code from someone else and must maintain or build upon it. </span><span class="koboSpan" id="kobo.108.4">By prioritizing readability, we can benefit in </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">many ways.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Although it’s important to write code that is easy to understand in the future, it’s also helpful to transform complex and unreadable code into clear and organized code. </span><span class="koboSpan" id="kobo.110.2">Just like Indiana Jones or Lara Croft, developers often have to delve deep into the projects they are working on to comprehend the intentions of their programmer ancestors. </span><span class="koboSpan" id="kobo.110.3">However, this can be significantly more challenging if the code is difficult to read. </span><span class="koboSpan" id="kobo.110.4">By refactoring the code, you can gain confidence in the functionality of the code you’ll be </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">working with.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Another good reason for having readable code is when the code is intended to be open sourced. </span><span class="koboSpan" id="kobo.112.2">Whether it is due to a personal interest in collaborating with open source projects, a company’s approach or using it as a showcase for professional profile building, having readable code becomes even more crucial in </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">these scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">Another situation where readable code is valuable is when your code undergoes peer review or is used for training junior team members. </span><span class="koboSpan" id="kobo.114.2">In such cases, having code that is easy to follow and comprehend helps ensure effective collaboration and knowledge transfer within </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the team.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">I also like readable code because I have a very bad memory. </span><span class="koboSpan" id="kobo.116.2">I am unable to hold more than a certain amount of information in my head; actually, I don’t want it. </span><span class="koboSpan" id="kobo.116.3">There’s no need if you can retrieve the information by simply reading the code like it was a piece of prose. </span><span class="koboSpan" id="kobo.116.4">It’s not fair to expect my future self or colleagues to recall details that could easily be included in the code, such as why a particular approach was taken, why certain information was sourced from a particular location, or why one solution was chosen over another. </span><span class="koboSpan" id="kobo.116.5">One of the most frequent questions I ask myself when dealing with legacy code is, “Is this a mistake or is it intentional?”; readable code (coupled with the correct amount of tests, code comments, and coding standards, but we’ll see this later) is the right choice to </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">remove doubts.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">There are many techniques to make the code more readable, and we will expand on them later in this book. </span><span class="koboSpan" id="kobo.118.2">There is something else I’d like to highlight first: readability can be something very subjective. </span><span class="koboSpan" id="kobo.118.3">What is readable for me may not be for my teammates. </span><span class="koboSpan" id="kobo.118.4">Some prefer one-liners, and others prefer to isolate a couple of lines in a single method. </span><span class="koboSpan" id="kobo.118.5">You may prefer to make explicit the type of every single variable; I prefer to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">var</span></strong><span class="koboSpan" id="kobo.120.1"> keyword. </span><span class="koboSpan" id="kobo.120.2">My suggestion is simple: talk to your teammates and agree on a trade-off. </span><span class="koboSpan" id="kobo.120.3">Remove from the discussion objective improvements (for example, using streams in place of classic loops) and agree on a general “code style” level (you could use a coding standard document or a unique formatter</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.121.1"> for your IDE, but we’ll deep dive into this later). </span><span class="koboSpan" id="kobo.121.2">It is important to keep the code consistent in all of the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">project classes.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.123.1">Improving the design of your software</span></h2>
<p><span class="koboSpan" id="kobo.124.1">Refactoring helps you improve</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.125.1"> the design of your software. </span><span class="koboSpan" id="kobo.125.2">If you don’t do it, the design will (not so slowly) decay; it will be more difficult to understand, for instance, where to put new features or how to implement them. </span><span class="koboSpan" id="kobo.125.3">Refactoring is like “tidying up” your project once a new functionality is guaranteed. </span><span class="koboSpan" id="kobo.125.4">If you don’t do it, you will probably fall into pitfalls, one of which is, the ancient monster that lies in almost every software company. </span><span class="koboSpan" id="kobo.125.5">Reducing duplicated code is not just a matter of “doing things properly” (even if doing things properly should be the norm) but has a direct benefit: when you have to modify that code, you will modify it only once. </span><span class="koboSpan" id="kobo.125.6">Believe me when I say that this very basic concept is not always respected. </span><span class="koboSpan" id="kobo.125.7">I will quote Martin Fowler here, in his book </span><em class="italic"><span class="koboSpan" id="kobo.126.1">Refactoring: Improving the Design of Existing Code</span></em><span class="koboSpan" id="kobo.127.1">: “</span><em class="italic"><span class="koboSpan" id="kobo.128.1">By eliminating the duplicates, you ensure that the code says everything once and only once, which is the essence of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">good design.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">If code is poorly designed or implemented, you’ll have</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.132.1"> to do extra work to add functionalities, fix bugs, or improve performance: that extra work is due to something called </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">technical debt</span></strong><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">Technical debt happens when you prioritize speed over long-term benefits in your design or implementation choices. </span><span class="koboSpan" id="kobo.134.3">Just like a loan, it accumulates interest over time, making it harder to maintain and improve the software later. </span><span class="koboSpan" id="kobo.134.4">Constant refactoring improves design and quality; a better design reduces </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">technical debt.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.136.1">Maintainability and scalability</span></h2>
<p><span class="koboSpan" id="kobo.137.1">As we said before, software development </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.138.1">is a lot about maintainability. </span><span class="koboSpan" id="kobo.138.2">If refactoring </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.139.1">helps you keep a good design, that is a clear understanding of what each piece of code does and where to put any new code. </span><span class="koboSpan" id="kobo.139.2">In a situation such as this, maintainability is facilitated: by improving code organization and structure, it becomes easier to identify and fix issues or add new features over time. </span><span class="koboSpan" id="kobo.139.3">If you take care of your software and refactor when you think it’s necessary (see the next subsection), the consequent good design will help you to scale your code. </span><span class="koboSpan" id="kobo.139.4">While improving performance isn’t the main reason for refactoring, it often ends up being a nice bonus. </span><span class="koboSpan" id="kobo.139.5">If a certain functionality is properly isolated, for instance, it will be likely easier to parallelize it or to remove it and put it in another service, using a remote call to retrieve information </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">from it.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.141.1">Understanding, avoiding, and fixing bugs</span></h2>
<p><span class="koboSpan" id="kobo.142.1">Good design means that each part of your code does one thing, and it does it well. </span><span class="koboSpan" id="kobo.142.2">But things can go bananas, sometimes; bugs</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.143.1"> are just around the corner. </span><span class="koboSpan" id="kobo.143.2">One of the first things</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.144.1"> to do when you fight against a bug is to understand what’s happening and where. </span><span class="koboSpan" id="kobo.144.2">Refactoring helps to understand the code (because you have to rewrite or restructure it a little bit without changing the external behavior), and thus you get to know the code better. </span><span class="koboSpan" id="kobo.144.3">If you know and understand your code, it will be faster to spot bugs or </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">implement fixes.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Let me give you some advice: try to avoid</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.147.1"> having “restricted areas” in projects </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.148.1">you’re working on. </span><span class="koboSpan" id="kobo.148.2">In this case, a restricted area refers to a library, module, or another part of your code base that you rely on and understand </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.149.1">its purpose, but you’re afraid to touch</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.150.1"> because it’s really fragile. </span><span class="koboSpan" id="kobo.150.2">You know what it does, but not exactly how it does it. </span><span class="koboSpan" id="kobo.150.3">It’s like a big mess that no one in your company wants to deal with. </span><span class="koboSpan" id="kobo.150.4">The more complex and old the system is, and the more people have worked on it, the harder it becomes to understand the code base. </span><span class="koboSpan" id="kobo.150.5">Sometimes these restricted areas are unavoidable, especially if the previous developers didn’t leave any documentation. </span><span class="koboSpan" id="kobo.150.6">It’s not a big deal if you have some of these areas, but it’s best to minimize them as much as possible. </span><span class="koboSpan" id="kobo.150.7">Refactoring can help, but there are certain conditions that need to be met, such as having good test coverage (but we can talk about </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">that later).</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.152.1">Faster development</span></h2>
<p><span class="koboSpan" id="kobo.153.1">All of the previous considerations</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.154.1"> bring us to one, big deal: refactoring helps to do things faster. </span><span class="koboSpan" id="kobo.154.2">It may sound a bit counterintuitive, but if you think about it a little bit, it becomes crystal clear. </span><span class="koboSpan" id="kobo.154.3">Having well-designed, bug-free, understandable software means keeping good quality software. </span><span class="koboSpan" id="kobo.154.4">And of course, the main goal of having high-quality software is to add functionality faster, to scale it quickly, and to fix bugs in the blink of </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">an eye.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Keep in mind that writing software is a craft. </span><span class="koboSpan" id="kobo.156.2">As software developers, we are like artisans who shape and mold our applications and engineer and assemble our services. </span><span class="koboSpan" id="kobo.156.3">Even though we don’t use physical tools such as hammers and wrenches, we are still artisans. </span><span class="koboSpan" id="kobo.156.4">The main difference is that what we create is flexible and adaptable. </span><span class="koboSpan" id="kobo.156.5">We have the ability to revisit our work, improve upon it, and make it more receptive to change. </span><span class="koboSpan" id="kobo.156.6">By doing so, we can establish a solid foundation to build upon whenever we need to expand </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">our work.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">If there is no proper design, engineering tasks turn into an endless cycle of quick fixes and hacks. </span><span class="koboSpan" id="kobo.158.2">If you continue to approach projects in this way, relying on one temporary solution after another, it is only a matter of time before the project </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">becomes unmanageable.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">If your manager is more focused on schedules</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.161.1"> and timelines rather than technical aspects or quality in general (yes – that can happen), highlighting faster development as a key benefit of refactoring can be a compelling </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">selling point.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.163.1">When you should refactor</span></h1>
<p><span class="koboSpan" id="kobo.164.1">At this point, we have a clear understanding</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.165.1"> of what refactoring is and why it holds such significant importance or, I would even go as far as to say, it is crucial in our daily work. </span><span class="koboSpan" id="kobo.165.2">You may be wondering when is the appropriate time to engage in this activity. </span><span class="koboSpan" id="kobo.165.3">There are several factors to consider when deciding on the timing of refactoring. </span><span class="koboSpan" id="kobo.165.4">It is no secret that refactoring can be time-consuming, so how can we effectively incorporate it into our workflow? </span><span class="koboSpan" id="kobo.165.5">When is the optimal time to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">this activity?</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Let me start with some fundamental advice based on our experience: it’s always a good idea to do some minor refactoring whenever you have the chance, even if it means integrating it into your current task. </span><span class="koboSpan" id="kobo.167.2">For example, while running tests or performing static code analysis, you might come across a variable named </span><em class="italic"><span class="koboSpan" id="kobo.168.1">x</span></em><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">That name doesn’t convey much meaning, does it? </span><span class="koboSpan" id="kobo.169.3">So, you’ll spend some time trying to figure out what that variable represents, only to discover that it contains a user’s name. </span><span class="koboSpan" id="kobo.169.4">You went through the trouble of deciphering it, but why should others have to do the same thing? </span><span class="koboSpan" id="kobo.169.5">Why should you have to go through the same hassle 3 weeks later when you revisit the code? </span><span class="koboSpan" id="kobo.169.6">Just take a moment to rename the variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">username</span></strong><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">It’s a simple and almost effortless task (your IDE can do that) that can save others time and effort. </span><span class="koboSpan" id="kobo.171.3">I try to maintain this mindset at all times, which aligns with my “lazy” attitude of achieving maximum results with </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">minimal effort.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.173.1">The “Rule of Three”</span></h2>
<p><span class="koboSpan" id="kobo.174.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Rule of Three</span></strong><span class="koboSpan" id="kobo.176.1"> suggests that code should not be duplicated </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.177.1">more than twice and that once</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.178.1"> duplication occurs for the third time, it should be extracted into a reusable module or function. </span><span class="koboSpan" id="kobo.178.2">It is unclear who originally stated this principle as it has been widely used and adapted by various software developers and teams over the years (it was popularized by Martin Fowler, who credits it to Don Roberts). </span><span class="koboSpan" id="kobo.178.3">A more effective way to state the same is </span><em class="italic"><span class="koboSpan" id="kobo.179.1">three strikes and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.180.1">you refactor</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.182.1">Preparatory refactoring for smooth feature implementation</span></h2>
<p><span class="koboSpan" id="kobo.183.1">When adding a new feature</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.184.1"> to your code base, it is often helpful to engage in </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">preparatory refactoring</span></strong><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">This means taking the time to analyze parts of your code base that will be affected by the new feature and making necessary changes</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.187.1"> beforehand. </span><span class="koboSpan" id="kobo.187.2">I’ll borrow Martin Fowler’s excellent analogy for preparatory refactoring: it’s like taping off electrical sockets, door frames, and skirting boards when painting a wall. </span><span class="koboSpan" id="kobo.187.3">The taping itself isn’t painting, but it makes the painting process quicker </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">and easier.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">During the analysis phase of preparatory refactoring, you may notice areas where a small change in the code could lead to significant improvements in speed or efficiency. </span><span class="koboSpan" id="kobo.189.2">For example, you may realize that using a method parameter instead of a literal or a class hierarchy instead of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">switch</span></strong><span class="koboSpan" id="kobo.191.1"> statement would improve the flexibility and adaptability of your code. </span><span class="koboSpan" id="kobo.191.2">By making these changes through refactoring, you can make your code more open to change in the future and ultimately make development </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">easier overall.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.193.1">Refactoring for bug fixing</span></h2>
<p><span class="koboSpan" id="kobo.194.1">It is often overlooked, but fixing</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.195.1"> a bug can present a great opportunity for a refactor. </span><span class="koboSpan" id="kobo.195.2">This is because</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.196.1"> a significant portion of bug-fixing-related refactoring is aimed at improving the readability of your code. </span><span class="koboSpan" id="kobo.196.2">By making your code more understandable, you can identify the root cause of the bug sooner and fix it more efficiently. </span><span class="koboSpan" id="kobo.196.3">The bug had been present all along, but it went unnoticed due to the lack of readability in your code. </span><span class="koboSpan" id="kobo.196.4">So, it’s always a good practice to take the time to refactor when fixing bugs to prevent them from happening again in </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">the future.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.198.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.199.1">Let me be a bit clearer here: refactoring and bug fixing are two different things. </span><span class="koboSpan" id="kobo.199.2">It’s important to fix the bug first and then focus on improving the code. </span><span class="koboSpan" id="kobo.199.3">They may be related but separate steps, and one doesn’t automatically include </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">the other.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.201.1">Comprehension refactoring</span></h2>
<p><span class="koboSpan" id="kobo.202.1">You don’t need a bug to make</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.203.1"> your code cleaner and more understandable; you can refactor</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.204.1"> your code while trying to understand it or – we all have been there – remember what you were trying to do 2 months ago. </span><span class="koboSpan" id="kobo.204.2">I will repeat this concept several times because I think it’s one of the most important in our job: writing code is not only talking to a set of machines; it is more about talking to our future selves and our colleagues. </span><span class="koboSpan" id="kobo.204.3">Martin Fowler refers to this technique as </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">comprehension refactoring</span></strong><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">The idea can be likened to organizing one’s wardrobe, where the goal is to have a clear and complete view of all available clothing options to select the best-fitting outfit. </span><span class="koboSpan" id="kobo.206.3">In the same way, comprehension refactoring involves streamlining code to improve its readability </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">and comprehensibility.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.208.1">The “Boy Scout Rule”</span></h2>
<p><span class="koboSpan" id="kobo.209.1">And then comes one of my favorite concepts</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.210.1"> related to software engineering, which is borrowed</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.211.1"> from the camping world and should also be applied in real life. </span><span class="koboSpan" id="kobo.211.2">Leave code better than you found it; at least, leave it as clean as it was. </span><span class="koboSpan" id="kobo.211.3">Do not leave it worse. </span><span class="koboSpan" id="kobo.211.4">Just like when you go camping or you picnic on a green field, you must think that that green field is not yours – you’re just borrowing it; do not leave your trash. </span><span class="koboSpan" id="kobo.211.5">If you find some trash, take some time to pick </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">it up.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">Going back to our world, if you find some code that is – let’s say – understandable but that you think could work better (for instance, parametrizing a function or using another library method with a better signature), just do not ignore the problem and fix it. </span><span class="koboSpan" id="kobo.213.2">Pick up that small amount of trash you found along your path. </span><span class="koboSpan" id="kobo.213.3">At the same time, remember that you were doing something else; your task was not to pick up the trash but to enjoy your day in the open air (just to continue this joyful metaphor). </span><span class="koboSpan" id="kobo.213.4">So, find a trade-off between your actual task and this litter-picking refactoring; something I found useful, sometimes, is just to keep note that someone will have to clean that piece of code: how you do it (a Jira task, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">git pull</span></strong><span class="koboSpan" id="kobo.215.1"> request, a Post-it on your monitor) depends on how your team works. </span><span class="koboSpan" id="kobo.215.2">But this is the kind of small-step refactoring that you will find very</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.216.1"> useful and, I would say, </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">almost</span></span><span class="No-Break"><a id="_idIndexMarker035"/></span><span class="No-Break"><span class="koboSpan" id="kobo.218.1"> mind-changing.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.219.1">Planned refactoring</span></h2>
<p><span class="koboSpan" id="kobo.220.1">At this time, it could seem that refactoring</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.221.1"> must be an activity included in your software</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.222.1"> developer routine, something “opportunistic;” and of course it is. </span><span class="koboSpan" id="kobo.222.2">You should refactor code as part of your daily activity. </span><span class="koboSpan" id="kobo.222.3">Writing software can be seen as adding functionalities upon functionalities, resulting in a never-ending stack of features and, thus, code modules, but developers know that most of the time it’s easier just to change existing code to add a new feature. </span><span class="koboSpan" id="kobo.222.4">You should never think about software as “done;” it is alive, and it is ever-changing. </span><span class="koboSpan" id="kobo.222.5">The moment software stays the same for too much time, there’s probably a problem: it could be too hard to change or to extend (not enough refactoring has been done), or maybe it has been replaced by something else (and so, my advice is… </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">dismiss it).</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">What I’m trying to say here is that it is not always possible to write excellent code on the first try; sometimes you have to stop, rewatch what you’ve done, and… try to do it better. </span><span class="koboSpan" id="kobo.224.2">Sometimes, you’ll even have to plan to refactor because you understand that changes are too hard to make on the existing code base; the concept is similar to the preparatory refactoring we mentioned before, but it is like a level up because you plan the refactoring. </span><span class="koboSpan" id="kobo.224.3">You should do it rarely, because this means that you didn’t include small refactorings into your daily activity, but it can happen. </span><span class="koboSpan" id="kobo.224.4">In this case, plan with attention: sometimes it could be better, for instance, to use separate branches or commits for new features and refactorings; someone else says that this would separate the refactoring from its purpose. </span><span class="koboSpan" id="kobo.224.5">I don’t really have a suggestion here: just do what fits best for </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">your team.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.226.1">Long-term refactoring and “Branch by Abstraction”</span></h2>
<p><span class="koboSpan" id="kobo.227.1">Although most refactoring</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.228.1"> tasks can be completed in just a few minutes</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.229.1"> or hours, certain activities may require</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.230.1"> several weeks of effort to complete. </span><span class="koboSpan" id="kobo.230.2">These typically include</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.231.1"> tasks such as isolating specific logic into a separate component or replacing one library with another. </span><span class="koboSpan" id="kobo.231.2">To address these more complex tasks, it can be helpful for a team to establish a practice of performing refactoring whenever they approach a “danger zone” that has been identified as in need of improvement. </span><span class="koboSpan" id="kobo.231.3">One useful technique for achieving this is called </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">Branch by Abstraction</span></strong><span class="koboSpan" id="kobo.233.1">, which can be used to change a library or service call in a gradual and </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">controlled manner.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Branch by Abstraction consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">five phases.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Imagine that you need</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.238.1"> to replace the outdated </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">FaultyPay</span></strong><span class="koboSpan" id="kobo.240.1"> payment service</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.241.1"> that you integrated into your system several years ago. </span><span class="koboSpan" id="kobo.241.2">Naturally, you don’t want</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.242.1"> to cause your customers</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.243.1"> any problems or inconvenience during the transition process. </span><span class="koboSpan" id="kobo.243.2">Here, you can see that there is a call and response between the client code and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">FaultyPay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1"> service:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.246.1"><img alt="Figure 1.1 – A very basic situation: our client code calls a legacy system and gets a response" src="image/B20912_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.247.1">Figure 1.1 – A very basic situation: our client code calls a legacy system and gets a response</span></p>
<p><span class="koboSpan" id="kobo.248.1">After you identified the service you want to replace, you build an abstraction layer to allow continued communication between the systems that are being replaced and the entities requesting that service. </span><span class="koboSpan" id="kobo.248.2">This abstraction layer acts as a contract, exposing functionality while concealing the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">implementation details:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.250.1"><img alt="Figure 1.2 – An abstraction layer, often represented by a Java interface, is inserted between the client code and the component that needs to be eliminated" src="image/B20912_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.251.1">Figure 1.2 – An abstraction layer, often represented by a Java interface, is inserted between the client code and the component that needs to be eliminated</span></p>
<p><span class="koboSpan" id="kobo.252.1">Then, start replacing the legacy system by systematically building the replacement system (we’ll call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ShinyPay</span></strong><span class="koboSpan" id="kobo.254.1">) and gradually integrating each rebuilt feature into the abstraction layer as they are completed. </span><span class="koboSpan" id="kobo.254.2">It is important to keep in mind that during this process, all traffic – both from the new and the old system – will be passing through the abstraction layer. </span><span class="koboSpan" id="kobo.254.3">It is also important to note that you could also choose (if this is possible – it is not always) to migrate one function at </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">a time:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.256.1"><img alt="Figure 1.3 – Once the replacement component is prepared, it can be connected to the abstraction layer" src="image/B20912_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.257.1">Figure 1.3 – Once the replacement component is prepared, it can be connected to the abstraction layer</span></p>
<p><span class="koboSpan" id="kobo.258.1">The abstraction layer can</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.259.1"> also be used to fine-tune the service, such as directing</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.260.1"> only a portion of the traffic or specific</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.261.1"> features to the new component (feature toggle). </span><span class="koboSpan" id="kobo.261.2">It could</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.262.1"> also be possible to migrate one method at a time. </span><span class="koboSpan" id="kobo.262.2">It is important to ensure that both the legacy and the new system adhere to the </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">same contract.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">At this point, the code in the old system (</span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">FaultyPay</span></strong><span class="koboSpan" id="kobo.266.1">, in our example) becomes obsolete, so you can </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">delete it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.268.1"><img alt="Figure 1.4 – The previous implementation (FaultyPay) is disconnected from the system; all traffic and functionalities are now exclusively directed toward the new implementation (ShinyPay)" src="image/B20912_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.269.1">Figure 1.4 – The previous implementation (FaultyPay) is disconnected from the system; all traffic and functionalities are now exclusively directed toward the new implementation (ShinyPay)</span></p>
<p><span class="koboSpan" id="kobo.270.1">Once all of the legacy code has been removed, you have the option to dismantle the abstraction layer. </span><span class="koboSpan" id="kobo.270.2">Alternatively, you may choose to retain this layer for the purpose of extensibility </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">or future-proofing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.272.1"><img alt="Figure 1.5 – We have returned to the ideal situation but with our new component! If we have been careful, skilled, and lucky, nobody has noticed anything (meaning there has been no disruption)" src="image/B20912_01_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.273.1">Figure 1.5 – We have returned to the ideal situation but with our new component! </span><span class="koboSpan" id="kobo.273.2">If we have been careful, skilled, and lucky, nobody has noticed anything (meaning there has been no disruption)</span></p>
<p><span class="koboSpan" id="kobo.274.1">This approach has several obvious advantages. </span><span class="koboSpan" id="kobo.274.2">Apart from the primary advantage of enabling seamless migration</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.275.1"> of large features in continuous integration, there are several</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.276.1"> additional benefits of using the Branch by </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Abstraction technique:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.278.1">The release schedule is completely independent of architectural changes, making it easy and cost-effective to pause and resume the migration process as needed. </span><span class="koboSpan" id="kobo.278.2">This is because the new implementation is safeguarded by the system, allowing for quick adaptation to urgent requests or priority features from the leadership team or customer service department or to fix bugs. </span><span class="koboSpan" id="kobo.278.3">In contrast, when using a standard feature branch, it can be more challenging to resume a migration that has </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">been paused.</span></span></li>
<li><span class="koboSpan" id="kobo.280.1">The potential for merge conflicts is also limited to the abstraction layer only, which can significantly reduce the scope of conflicts that may arise. </span><span class="koboSpan" id="kobo.280.2">Without the abstraction layer, a code base refactor sitting in a feature branch for an extended period could generate a wide range of merge conflicts that might be difficult to </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">resolve completely.</span></span></li>
<li><span class="koboSpan" id="kobo.282.1">Instead of switching</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.283.1"> completely to the new system, you could choose to turn new features on and off when</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.284.1"> you need to. </span><span class="koboSpan" id="kobo.284.2">These “specific switches” are called </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">feature toggles</span></strong><span class="koboSpan" id="kobo.286.1">. </span><span class="koboSpan" id="kobo.286.2">A feature toggle, also known as a feature flag or feature switch, is a technique that allows developers to enable or disable specific features or functionality in an application, at runtime and without modifying the code base. </span><span class="koboSpan" id="kobo.286.3">By using feature toggles, developers can release new features to a subset of users, test them in production environments, or enable/disable features based on certain conditions or user segments. </span><span class="koboSpan" id="kobo.286.4">This approach provides flexibility, allows for gradual</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.287.1"> rollouts, and reduces risk associated</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.288.1"> with deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">new features.</span></span></li>
</ul>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.290.1">Refactoring in a code review</span></h2>
<p><span class="koboSpan" id="kobo.291.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">code review</span></strong><span class="koboSpan" id="kobo.293.1"> is a process of reviewing the source</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.294.1"> code. </span><span class="koboSpan" id="kobo.294.2">It is usually done by other developers or peers who </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.295.1">are more or less familiar with the programming language and the project’s requirements. </span><span class="koboSpan" id="kobo.295.2">We'll cover code reviews in detail in </span><a href="B20912_08.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.296.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.297.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">The purpose of a code review is to ensure that the code is written in a clear, concise, and efficient manner and that it meets the project’s requirements and coding standards. </span><span class="koboSpan" id="kobo.298.2">Code reviews can help to identify and fix potential bugs or security issues, as well as improve the overall quality and maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">During a code review, the reviewer examines the code line by line and provides feedback on issues such as code structure, syntax errors, performance, and readability. </span><span class="koboSpan" id="kobo.300.2">The review may also involve discussions and suggestions for improvement, as well as questions and clarifications about the code’s functionality and design. </span><span class="koboSpan" id="kobo.300.3">Code reviews are an important part of the software development process and are typically conducted before the code is merged into the main code base or released </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">to customers.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Martin Fowler suggests that code reviews are a great time to do some refactoring. </span><span class="koboSpan" id="kobo.302.2">If you want to understand someone else’s code (as we’ve already said), the best way is to refactor it. </span><span class="koboSpan" id="kobo.302.3">Otherwise, you might only get bits and pieces of it and give vague feedback. </span><span class="koboSpan" id="kobo.302.4">Refactoring helps</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.303.1"> you get a clearer picture. </span><span class="koboSpan" id="kobo.303.2">By the way, there’s something called </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">pair programming</span></strong><span class="koboSpan" id="kobo.305.1"> (and something called </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">mob programming</span></strong><span class="koboSpan" id="kobo.307.1">) that takes code review</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.308.1"> to the next level. </span><span class="koboSpan" id="kobo.308.2">We’ll talk about it more in this </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">book later.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.310.1">What you should refactor</span></h1>
<p><span class="koboSpan" id="kobo.311.1">Sometimes in my career, we've come across situations where I wanted to make changes to different parts of my project. </span><span class="koboSpan" id="kobo.311.2">Maybe there was something that wasn’t working properly or something that I didn’t fully understand, or simply something that could be improved. </span><span class="koboSpan" id="kobo.311.3">It’s important to decide</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.312.1"> which parts to focus on and prioritize. </span><span class="koboSpan" id="kobo.312.2">And in some cases, it might</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.313.1"> even be better to leave things as they are and not make any changes </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">There’s no hard and fast rule when it comes to refactoring, but with a little thought, you can come up with a solid plan that meets your specific needs. </span><span class="koboSpan" id="kobo.315.2">Remember – in our profession and in life, we often have to </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">make compromises.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Recently, I came across a helpful concept in Gary Keller’s book, </span><em class="italic"><span class="koboSpan" id="kobo.318.1">The One Thing</span></em><span class="koboSpan" id="kobo.319.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.320.1">Bard Press</span></em><span class="koboSpan" id="kobo.321.1">, </span><em class="italic"><span class="koboSpan" id="kobo.322.1">2013</span></em><span class="koboSpan" id="kobo.323.1">). </span><span class="koboSpan" id="kobo.323.2">While it’s not specifically related to software development, it can be applied to our needs. </span><span class="koboSpan" id="kobo.323.3">The idea is this: “What’s the one thing you can do, such that by doing it, everything else will be easier or unnecessary?” </span><span class="koboSpan" id="kobo.323.4">While this is a broad question with many implications that we can’t discuss here, it can be a useful starting point for deciding what to do with our code base. </span><span class="koboSpan" id="kobo.323.5">This approach is super helpful when it comes to refactoring code. </span><span class="koboSpan" id="kobo.323.6">So, when you’re starting a new task or feature, take a look at your code and ask yourself if there’s anything that, if improved, would make the rest of the project work a lot easier or </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">completely unnecessary.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">The question is focused on what you can do, which forces you to think in actionable terms. </span><span class="koboSpan" id="kobo.325.2">It’s not about what you would do if certain conditions were met, but rather what you’re capable of doing right now. </span><span class="koboSpan" id="kobo.325.3">By identifying the one thing that can make everything else easier or unnecessary, we can focus our efforts on the most critical task at hand. </span><span class="koboSpan" id="kobo.325.4">It’s like distilling the essence of our job down to its core: doing the minimum necessary to achieve the maximum impact. </span><span class="koboSpan" id="kobo.325.5">This approach can be particularly valuable in software development, where there are often many different areas that could benefit from refactoring or improvement, but we need to prioritize and focus our efforts to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">greatest impact.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Let me give you an example to illustrate this point. </span><span class="koboSpan" id="kobo.327.2">Picture yourself working at a travel company that’s doing well, but facing challenges in handling a complex ecosystem with multiple travel providers and their solutions. </span><span class="koboSpan" id="kobo.327.3">The trouble is, there’s some outdated code causing problems, and the booking process occasionally fails. </span><span class="koboSpan" id="kobo.327.4">The system technically works without any bugs, but it’s outdated, difficult to maintain, lacks proper documentation (in one word: its </span><em class="italic"><span class="koboSpan" id="kobo.328.1">legacy</span></em><span class="koboSpan" id="kobo.329.1">), and definitely not ready to handle the expected surge in traffic. </span><span class="koboSpan" id="kobo.329.2">We really need to refactor it, or else the company won’t be able to handle all the upcoming new customers. </span><span class="koboSpan" id="kobo.329.3">Meanwhile, there’s an internal team responsible for managing website content, and they’re struggling with a tool they only use twice a month. </span><span class="koboSpan" id="kobo.329.4">It’s incredibly confusing and impractical, making even simple tasks time-consuming. </span><span class="koboSpan" id="kobo.329.5">We absolutely have to refactor that tool to make it more user-friendly for the team. </span><span class="koboSpan" id="kobo.329.6">While both issues are important, it’s clear that the first problem with the legacy code and booking process should be addressed first, because travel booking is the core business of the company and because those people would be free to deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">something else.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Anyways, let’s face it – refactoring</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.332.1"> legacy code can be overwhelming, especially</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.333.1"> when you’re pressed for time and resources. </span><span class="koboSpan" id="kobo.333.2">While “the one thing” rule is a fantastic approach, it’s also pretty broad. </span><span class="koboSpan" id="kobo.333.3">So, let me show you something more precise that can help you decide which parts of the code base require your attention </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">the most.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.335.1">Impact analysis</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.336.1">Impact analysis</span></strong><span class="koboSpan" id="kobo.337.1"> is like detective work in software</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.338.1"> refactoring. </span><span class="koboSpan" id="kobo.338.2">It’s all about</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.339.1"> figuring out how changes to one part of the code base will affect other parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">So, first, the developers identify code modules that need to be refactored or updated. </span><span class="koboSpan" id="kobo.341.2">Then, they investigate the connections and relationships between these modules and other parts of the software, such as external libraries, user interfaces, </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">and interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">By understanding these dependencies, the developers can get a good sense of how changes will ripple through the system. </span><span class="koboSpan" id="kobo.343.2">They can pinpoint areas that might be particularly tricky to change and take steps to reduce the chances of bugs or other issues </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">cropping up.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Basically, impact analysis is a crucial tool in the software refactoring toolkit. </span><span class="koboSpan" id="kobo.345.2">It helps developers make changes in a more thoughtful and careful way so that the code remains stable and easy to maintain in the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">Performing an impact analysis involves thoroughly assessing the potential effects of making changes to a system or project. </span><span class="koboSpan" id="kobo.347.2">Here’s a breakdown of </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">the steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.349.1">Preparation</span></strong><span class="koboSpan" id="kobo.350.1">: Define the change, clearly stating</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.351.1"> what you want to do. </span><span class="koboSpan" id="kobo.351.2">Collect data about the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">proposed change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.353.1">Identify affected areas and dependencies</span></strong><span class="koboSpan" id="kobo.354.1">: Brainstorm which parts of the system will be impacted by the change and how the change will affect other components in </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.356.1">Identify affected elements in each area</span></strong><span class="koboSpan" id="kobo.357.1">: Evaluate how the change will impact functionality, performance, security, and other aspects. </span><span class="koboSpan" id="kobo.357.2">Identify potential risks and problems that could arise from </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">the change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.359.1">Evaluate</span></strong><span class="koboSpan" id="kobo.360.1">: Conducting an evaluation, the team identifies both positive and negative impacts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">proposed change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.362.1">Deal with negative consequences</span></strong><span class="koboSpan" id="kobo.363.1">: With a clearer understanding of the negative impacts, the team can now focus on addressing them. </span><span class="koboSpan" id="kobo.363.2">They have the opportunity to consult with team members and stakeholders to discuss whether the change should</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.364.1"> proceed or not. </span><span class="koboSpan" id="kobo.364.2">Additionally, conducting regression testing becomes crucial</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.365.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">this scenario.</span></span></li>
</ol>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.367.1">Risk assessment</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.368.1">Risk assessment</span></strong><span class="koboSpan" id="kobo.369.1"> is a fancy way of saying “figuring out what could go wrong.” </span><span class="koboSpan" id="kobo.369.2">In software</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.370.1"> refactoring, it’s all about taking a hard look at the code base</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.371.1"> and identifying potential risks before </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">making changes.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">When assessing risk, developers consider a range of factors, including the complexity of the code, the likelihood of introducing bugs, and the potential impact of any issues that might arise. </span><span class="koboSpan" id="kobo.373.2">There may be impacts on data (some pieces of code are maybe dealing with crucial information such as personal or financial data), possible downtimes (some pieces of code, in case of issues, may bring down the entire system or some core functionalities), business issues (pieces of code that if broken could cause financial issues or contract infringements), or security breaches. </span><span class="koboSpan" id="kobo.373.3">They may also look at the time and resources available for the refactoring project and the potential impact on users </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">and stakeholders.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">Once risks have been identified, developers can take steps to mitigate them. </span><span class="koboSpan" id="kobo.375.2">For example, they might create test cases to ensure that the refactored code works as expected, or they might make changes in small increments to reduce the chances of something going wrong. </span><span class="koboSpan" id="kobo.375.3">We will talk more deeply about test coverage later in </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">Overall, risk assessment is an important part of software refactoring because it helps developers make informed decisions about how to proceed. </span><span class="koboSpan" id="kobo.377.2">By taking the time to consider potential risks and plan accordingly, they can ensure that the refactoring project is successful </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.378.1">and that the code base remains stable and maintainable</span><a id="_idIndexMarker072"/> <span class="No-Break"><span class="koboSpan" id="kobo.379.1">over time.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.380.1">Value estimation</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.381.1">Value estimation</span></strong><span class="koboSpan" id="kobo.382.1"> in software refactoring is all about figuring out whether a particular refactoring project</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.383.1"> is worth the time and resources required</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.384.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">complete it.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">When estimating value, developers consider a variety of factors, such as the current state of the code base, the potential benefits of the refactoring, and the potential costs and risks involved. </span><span class="koboSpan" id="kobo.386.2">They might also take into account factors such as user feedback, performance metrics, and the needs </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">of stakeholders.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Once the potential value of a refactoring project has been estimated, developers can decide whether it makes sense to move forward. </span><span class="koboSpan" id="kobo.388.2">In some cases, the potential benefits might not outweigh the costs, and the project may be shelved or postponed. </span><span class="koboSpan" id="kobo.388.3">In other cases, the benefits may be significant enough to justify the investment, and the project may </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">move forward.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Value estimation is an important part of software refactoring because it helps developers prioritize their efforts and make strategic decisions about how to allocate resources. </span><span class="koboSpan" id="kobo.390.2">By focusing on projects with high potential value and avoiding those with lower potential value, developers can ensure that they are making the most efficient use of their time </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">and resources.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.392.1">Prioritization matrix</span></h2>
<p><span class="koboSpan" id="kobo.393.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">prioritization matrix</span></strong><span class="koboSpan" id="kobo.395.1"> (also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">Eisenhower Matrix</span></strong><span class="koboSpan" id="kobo.397.1">) is a tool used in software refactoring</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.398.1"> to help developers</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.399.1"> prioritize their efforts and make informed decisions about</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.400.1"> which refactoring projects to tackle first. </span><span class="koboSpan" id="kobo.400.2">It typically involves a matrix with two axes, one representing the level of urgency given to a project and the other representing the potential impact on </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Each project is evaluated based on these two factors and then plotted on the matrix accordingly. </span><span class="koboSpan" id="kobo.402.2">Projects that require the least effort and have the greatest potential impact are considered the highest priority, while those that require more effort and have a lower potential impact are considered </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">lower priority.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Using a prioritization </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.405.1">matrix can help developers make strategic decisions</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.406.1"> about which projects to tackle first, based on the potential benefits and costs of each project. </span><span class="koboSpan" id="kobo.406.2">By focusing on the highest priority projects first, developers can make the most efficient use of their time and resources, and ensure that they are addressing the most critical issues in the </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">code base:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.408.1"><img alt="Figure 1.6 – You should put your activities in a prioritization matrix in order to choose the right priority for execution" src="image/B20912_01_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.409.1">Figure 1.6 – You should put your activities in a prioritization matrix in order to choose the right priority for execution</span></p>
<p><span class="koboSpan" id="kobo.410.1">The higher priority should be assigned to activities that have high urgency and impact. </span><span class="koboSpan" id="kobo.410.2">Lower priority (or no importance at all) should be given to activities that are not urgent and will have </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">no impact.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.412.1">Further considerations</span></h2>
<p><span class="koboSpan" id="kobo.413.1">There’s more to</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.414.1"> think about when it comes to refactoring. </span><span class="koboSpan" id="kobo.414.2">I’ll jot it down here just to cover all our bases, but honestly, it might be a bit beyond the scope of this chapter. </span><span class="koboSpan" id="kobo.414.3">Once you’ve figured out which parts of your code base to prioritize for refactoring, the next step is to create a detailed plan that includes the scope, goals, steps, and timeline for the project. </span><span class="koboSpan" id="kobo.414.4">It’s also crucial to communicate this plan to everyone involved, such as your team, manager, clients, and users. </span><span class="koboSpan" id="kobo.414.5">You need to explain why you’re refactoring, what you’ll be doing, how you’ll be doing it, and when it’ll be done. </span><span class="koboSpan" id="kobo.414.6">It’s important to set clear expectations and manage them throughout the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">refactoring process.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">The final step is to execute the plan with discipline and diligence. </span><span class="koboSpan" id="kobo.416.2">Stick to best practices such as making small and frequent changes, running tests before and after each change, committing and documenting each change, and reviewing and verifying each change. </span><span class="koboSpan" id="kobo.416.3">Keep an eye on how the refactoring is affecting things such as code quality, system performance, and user feedback. </span><span class="koboSpan" id="kobo.416.4">Measure the outcomes and compare them with your goals </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">and expectations.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.418.1">Refactor or rewrite?</span></h2>
<p><span class="koboSpan" id="kobo.419.1">There are various opinions </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.420.1">on this matter, which I have observed to be a common source of disputes among</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.421.1"> teammates and colleagues. </span><span class="koboSpan" id="kobo.421.2">The truth is there is no simple answer. </span><span class="koboSpan" id="kobo.421.3">It’s just one of those things where there are a ton of conflicting opinions out there, and it’s tough to figure out what to believe. </span><span class="koboSpan" id="kobo.421.4">But I’ll do my best to share some of those opinions with you and offer up some advice, for whatever </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">it’s worth.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">There are situations when it’s simply not justifiable to refactor your code. </span><span class="koboSpan" id="kobo.423.2">Perhaps it’s plagued with too many bugs, the design is overly complicated, and comprehending it is nearly impossible. </span><span class="koboSpan" id="kobo.423.3">Going through it’s like trying to solve the Rubik’s Cube blindfolded – or, quoting a former colleague of mine, like counting money with a fan blowing nearby. </span><span class="koboSpan" id="kobo.423.4">In such cases, rewriting it from the ground up may be the better option, and it’s something that many software developers find enjoyable. </span><span class="koboSpan" id="kobo.423.5">After all, it’s often more comfortable to create something new than to take small, incremental steps that are still tied to what was </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">previously done.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">On the other hand, we often fall into the trap of wanting to rewrite everything, thinking that what’s already there is terrible, when in reality, we may not have put in the effort to fully understand it. </span><span class="koboSpan" id="kobo.425.2">It’s important to remember one of the fundamental rules of programming, according to American developer Joel Spolsky: </span><em class="italic"><span class="koboSpan" id="kobo.426.1">it’s harder to read code than to write it</span></em><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">Let’s not immediately denigrate the legacy code we come across in our code bases, which typically wasn’t written by us (our own code is, of course, beautiful). </span><span class="koboSpan" id="kobo.427.3">Legacy code has a history; it has been thoroughly tested and integrated with all necessary use cases and has often demonstrated good performance. </span><span class="koboSpan" id="kobo.427.4">We should respect </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">legacy code.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">It’s a really complicated decision, and as I said, there’s no general rule. </span><span class="koboSpan" id="kobo.429.2">Perhaps, a very simple rule to adopt could be to try to evaluate the cost (both in terms of time and complexity) of rewriting and refactoring code and choose the option that seems best to you. </span><span class="koboSpan" id="kobo.429.3">Note that I didn’t say “the option that costs less,” because it’s often an investment. </span><span class="koboSpan" id="kobo.429.4">Another useful thing could be to break down the part under examination into smaller parts (the good old “divide and conquer”) and choose to refactor (or rewrite) only that part, so as not to be “stuck” for </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">too long.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">If you decide to rewrite a piece of code, a module, or an entire component, let me give you a heartfelt piece of advice: don’t get too attached to what has already been done. </span><span class="koboSpan" id="kobo.431.2">Let me explain. </span><span class="koboSpan" id="kobo.431.3">Surely, it will be useful to try and understand what the code does and the individual steps that make up the logical flow. </span><span class="koboSpan" id="kobo.431.4">It will be equally useful to understand how users currently behave and which business cases are currently implemented. </span><span class="koboSpan" id="kobo.431.5">However, I have often found that what is currently present does not correspond to the real needs of users; perhaps it never did, or perhaps needs have changed over time. </span><span class="koboSpan" id="kobo.431.6">Perhaps half of that software is simply no longer needed. </span><span class="koboSpan" id="kobo.431.7">So, it’s fine to read what exists and try to rewrite it better or differently, but often this reverse-engineering process can be quite complicated, time-consuming, and, especially, error-prone. </span><span class="koboSpan" id="kobo.431.8">Instead, try to identify what users need, possibly</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.432.1"> with the help of the Product Owner (to know what a PO exactly is, you can refer </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">to </span></span><a href="https://www.scrum.org/resources/what-is-a-product-owner"><span class="No-Break"><span class="koboSpan" id="kobo.434.1">https://www.scrum.org/resources/what-is-a-product-owner</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.435.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">This may actually encounter</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.437.1"> some resistance, which depends on the mentality of the company</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.438.1"> you are working for. </span><span class="koboSpan" id="kobo.438.2">Many times, I have been told: It must have the same logic as before, but it must work better. </span><span class="koboSpan" id="kobo.438.3">This is obviously a great way to cover one’s back, but it almost never leads to effective results. </span><span class="koboSpan" id="kobo.438.4">It forces engineers to do huge reverse-engineering work, which in light of (often) changing user needs can be partially useless; it does not allow the team (both the so-called tech part and the so-called product part, assuming such differentiation makes sense) to focus on the importance of individual features, in order to prioritize activities and perhaps avoid unnecessary ones. </span><span class="koboSpan" id="kobo.438.5">So, I suggest you always start from the needs – from the why, before the how. </span><span class="koboSpan" id="kobo.438.6">Think</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.439.1"> about the goal</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.440.1"> before how to </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">get there.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.442.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.443.1">This chapter delves into the concept of refactoring and its elusive nature. </span><span class="koboSpan" id="kobo.443.2">It examines the underlying motivations for refactoring and offers insights into organizing effective refactoring sessions, as well as prioritizing different areas requiring attention in your code. </span><span class="koboSpan" id="kobo.443.3">Furthermore, it emphasizes the significance of integrating refactoring seamlessly into your regular activities. </span><span class="koboSpan" id="kobo.443.4">In conclusion, the chapter provides a comprehensive summary and presents a range of techniques to successfully incorporate refactoring into your </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">professional routine.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">In the upcoming chapter, we will discuss a set of recommended practices that are considered “good habits” for software professionals to adopt in </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">their work.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.447.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.448.1">Martin Fowler</span></em><span class="koboSpan" id="kobo.449.1">, </span><em class="italic"><span class="koboSpan" id="kobo.450.1">Refactoring</span></em><span class="koboSpan" id="kobo.451.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.452.1">Addison-Wesley Professional</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.453.1">How do you prioritize which legacy code to refactor </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">first?</span></strong></span><span class="No-Break"> </span><a href="https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor"><span class="No-Break"><span class="koboSpan" id="kobo.455.1">https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.456.1">Refactor vs. </span><span class="koboSpan" id="kobo.456.2">rewrite: Deciding what to do with problem </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.457.1">software</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">: </span></span><a href="https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software"><span class="No-Break"><span class="koboSpan" id="kobo.459.1">https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.460.1">Things You Should Never Do, Part </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.461.1">I</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">: </span></span><a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/"><span class="No-Break"><span class="koboSpan" id="kobo.463.1">https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.464.1">Feature Toggles (aka Feature </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.465.1">Flags)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">: </span></span><a href="https://martinfowler.com/articles/feature-toggles.html"><span class="No-Break"><span class="koboSpan" id="kobo.467.1">https://martinfowler.com/articles/feature-toggles.html</span></span></a></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.468.1">BranchByAbstraction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">: </span></span><a href="https://martinfowler.com/bliki/BranchByAbstraction.html"><span class="No-Break"><span class="koboSpan" id="kobo.470.1">https://martinfowler.com/bliki/BranchByAbstraction.html</span></span></a></li>
</ul>
</div>
</body></html>