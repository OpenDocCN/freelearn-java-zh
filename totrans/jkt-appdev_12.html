<html><head></head><body>
<div id="_idContainer065">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.2.1">Jakarta Enterprise Beans</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Jakarta Enterprise Beans</span></strong><span class="koboSpan" id="kobo.4.1"> are </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.5.1">server-side components that encapsulate the business logic of an application. </span><span class="koboSpan" id="kobo.5.2">Enterprise beans simplify application development by automatically taking care of transaction management and security. </span><span class="koboSpan" id="kobo.5.3">There are two types of enterprise beans: </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">session beans</span></strong><span class="koboSpan" id="kobo.7.1">, which </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.8.1">perform business logic, and </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">message-driven beans</span></strong><span class="koboSpan" id="kobo.10.1">, which act as a</span><a id="_idIndexMarker562"/> <span class="No-Break"><span class="koboSpan" id="kobo.11.1">message listener.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Session beans</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Message-driven beans</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Transactions in </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">enterprise beans</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Enterprise bean </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">life cycles</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Enterprise bean </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">timer service</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">bean security</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.24.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.25.1">Example source code for this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch12_src</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.29.1">Session beans</span></h1>
<p><span class="koboSpan" id="kobo.30.1">As we</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.31.1"> previously mentioned, session beans typically encapsulate business logic. </span><span class="koboSpan" id="kobo.31.2">One or two artifacts need to be created in order to create a session bean, including the bean itself, and an optional business interface. </span><span class="koboSpan" id="kobo.31.3">These artifacts need to be annotated adequately to let the Jakarta EE runtime know they are </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">session beans.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.33.1">A simple session bean</span></h2>
<p><span class="koboSpan" id="kobo.34.1">The </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.35.1">following example illustrates a very simple </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">session bean:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.37.1">
package com.ensode.jakartaeebook;
import jakarta.ejb.Stateless;
</span><strong class="bold"><span class="koboSpan" id="kobo.38.1">@Stateless</span></strong><span class="koboSpan" id="kobo.39.1">
public class SimpleSessionBean implements SimpleSession{
  private final String message =
    "If you don't see this, it didn't work!";
  @Override
  public String getMessage() {
    return message;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.40.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">@Stateless</span></strong><span class="koboSpan" id="kobo.42.1"> annotation lets the Jakarta EE runtime know that this class is a </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">stateless session bean</span></strong><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">There </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.45.1">are three types of session beans: stateless, stateful, and singleton. </span><span class="koboSpan" id="kobo.45.2">Before we explain the difference between these types of session beans, we need to clarify how an instance of an enterprise bean is provided to a </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">client application.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">When a stateless or stateful session bean is deployed, the Jakarta EE container creates a series of instances of each session bean. </span><span class="koboSpan" id="kobo.47.2">This is what is typically referred to as the </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">enterprise bean pool</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">When </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.50.1">a client application obtains an instance of an enterprise bean, one of the instances in the pool is provided to this </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">client application.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">The difference between stateful and stateless session beans is that stateful session beans maintain a </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">conversational state</span></strong><span class="koboSpan" id="kobo.54.1"> with </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.55.1">the client, whereas stateless session beans do not. </span><span class="koboSpan" id="kobo.55.2">In simple terms, what this means is that when a client application obtains an instance of a stateful session bean, we are guaranteed that the value of any instance variables in the bean will be consistent across method calls. </span><span class="koboSpan" id="kobo.55.3">Therefore, it is safe to modify any instance variables on a stateful session bean, since they will retain their value for the next method call. </span><span class="koboSpan" id="kobo.55.4">The Jakarta EE runtime saves conversational state by passivating stateful session beans, and retrieves said state when the bean is activated. </span><span class="koboSpan" id="kobo.55.5">The conversational state is the reason why the life cycle of stateful session beans is a bit more complex than the life cycle of stateless session beans or message-driven beans (the enterprise bean life cycle is discussed later in </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">this chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.58.1">Jakarta EE runtime may provide any instance of an enterprise bean in the pool when a client application requests an instance of a stateless session bean. </span><span class="koboSpan" id="kobo.58.2">Since we are not guaranteed the same instance for every method call, values set to any instance variables in a stateless session bean may be “lost” (they are not really lost; the modification is in another instance of the enterprise bean in </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the pool).</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Other than being decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">@Stateless</span></strong><span class="koboSpan" id="kobo.62.1"> annotation, there is nothing special about our example class. </span><span class="koboSpan" id="kobo.62.2">Notice that it implements an interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">SimpleSession</span></strong><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">This interface is the bean’s business interface. </span><span class="koboSpan" id="kobo.64.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">SimpleSession</span></strong><span class="koboSpan" id="kobo.66.1"> interface is </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
package com.ensode.jakartaeebook;
import jakarta.ejb.Remote;
</span><strong class="bold"><span class="koboSpan" id="kobo.69.1">@Remote</span></strong><span class="koboSpan" id="kobo.70.1">
public interface SimpleSession {
  public String getMessage();
}</span></pre> <p><span class="koboSpan" id="kobo.71.1">The only peculiar thing about this interface is that it is decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">@Remote</span></strong><span class="koboSpan" id="kobo.73.1"> annotation. </span><span class="koboSpan" id="kobo.73.2">This annotation indicates that </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.74.1">this is a </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">remote business interface</span></strong><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">What this means is that the interface may be in a different JVM than the client application invoking it. </span><span class="koboSpan" id="kobo.76.3">Remote business interfaces may even be invoked across </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Business interfaces may also be decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">@Local</span></strong><span class="koboSpan" id="kobo.80.1"> interface. </span><span class="koboSpan" id="kobo.80.2">This annotation indicates that the business interface</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.81.1"> is a </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">local business interface</span></strong><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">Local business interface implementations must be in the same JVM as the client application invoking </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">its methods.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Once we have</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.86.1"> compiled the session bean and its corresponding business interface, we need to place them in a JAR file and deploy them. </span><span class="koboSpan" id="kobo.86.2">How to deploy an enterprise bean JAR file depends on what application server we are using. </span><span class="koboSpan" id="kobo.86.3">Most modern application servers have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">autodeploy</span></strong><span class="koboSpan" id="kobo.88.1"> directory. </span><span class="koboSpan" id="kobo.88.2">We can simply copy our JAR file to this directory in most cases. </span><span class="koboSpan" id="kobo.88.3">Consult your application server documentation to find the exact location of its </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">autodeploy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Now that we have seen the session bean and its corresponding business interface, let’s take a look at a client </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">sample application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
package com.ensode.jakartaeebook;
import jakarta.ejb.EJB;
import javax.naming.NamingException;
public class SessionBeanClient {
  </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">@EJB</span></strong><span class="koboSpan" id="kobo.95.1">
  private static SimpleSession simpleSession;
  private void invokeSessionBeanMethods() throws
    NamingException {
    System.out.println(simpleSession.getMessage());
    System.out.println("\nSimpleSession is of type: "
        + simpleSession.getClass().getName());
  }
  public static void main(String[] args)
    throws NamingException {
    new SessionBeanClient().invokeSessionBeanMethods();
  }
}</span></pre> <p><span class="koboSpan" id="kobo.96.1">The preceding code simply declares an instance variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">com.ensode.jakartaeebook.SimpleSession</span></strong><span class="koboSpan" id="kobo.98.1"> type, which is the business interface for our session bean. </span><span class="koboSpan" id="kobo.98.2">The instance variable is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">@EJB</span></strong><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">This annotation lets the Jakarta EE runtime know that this variable is a business interface for a session bean. </span><span class="koboSpan" id="kobo.100.3">The Jakarta EE runtime then injects an implementation of the business interface for the client code </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">Since our </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.103.1">client is a standalone application (as opposed to a Jakarta EE artifact such as a WAR file or a deployable JAR file), we don’t need to deploy to the Jakarta EE runtime. </span><span class="koboSpan" id="kobo.103.2">In order for it to be able to access code deployed to the server, it must have access to the application server’s client libraries. </span><span class="koboSpan" id="kobo.103.3">The procedure on how to accomplish this varies from application server to application server. </span><span class="koboSpan" id="kobo.103.4">When using GlassFish, our client code must be placed in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">JAR</span></strong><span class="koboSpan" id="kobo.105.1"> file and executed through</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.106.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">appclient</span></strong><span class="koboSpan" id="kobo.108.1"> utility. </span><span class="koboSpan" id="kobo.108.2">This utility can be found at </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">[glassfish installation directory]/glassfish/bin/</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Assuming this directory is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">PATH</span></strong><span class="koboSpan" id="kobo.112.1"> environment variable, and assuming we placed our client code in a JAR file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">simplesessionbeanclient.jar</span></strong><span class="koboSpan" id="kobo.114.1">, we would execute the preceding client code by typing the following command in the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">command line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.116.1">
appclient -client simplesessionbeanclient.jar </span></pre> <p><span class="koboSpan" id="kobo.117.1">Executing this command results in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">console output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.119.1">
If you don't see this, it didn't work!
</span><span class="koboSpan" id="kobo.119.2">SimpleSession is of type: com.ensode.jakartaeebook._SimpleSession_Wrapper</span></pre> <p><span class="koboSpan" id="kobo.120.1">This is the expected output upon executing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">SessionBeanClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1"> class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.123.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.124.1">We are using Maven to build our code. </span><span class="koboSpan" id="kobo.124.2">For this example, we have used the Maven Assembly Plugin (</span><a href="http://maven.apache.org/plugins/maven-assembly-plugin/"><span class="koboSpan" id="kobo.125.1">http://maven.apache.org/plugins/maven-assembly-plugin/</span></a><span class="koboSpan" id="kobo.126.1">) to build a client JAR file that includes all dependencies. </span><span class="koboSpan" id="kobo.126.2">This frees us from having to specify all the dependent JAR files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">-classpath</span></strong><span class="koboSpan" id="kobo.128.1"> command-line option of </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">appclient</span></strong><span class="koboSpan" id="kobo.130.1">. </span><span class="koboSpan" id="kobo.130.2">To build this JAR file, simply invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">mvn assembly:assembly</span></strong><span class="koboSpan" id="kobo.132.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">command line.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">The</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.135.1"> first line of output is simply the return value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">getMessage()</span></strong><span class="koboSpan" id="kobo.137.1"> method we implemented in the session bean. </span><span class="koboSpan" id="kobo.137.2">The second line of output displays the fully qualified class name of the class implementing the business interface. </span><span class="koboSpan" id="kobo.137.3">Notice that the class name is not the fully qualified name of the session bean we wrote; instead, what is actually provided is an implementation of the business interface created behind the scenes by the Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">EE runtime.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.139.1">A more realistic example</span></h2>
<p><span class="koboSpan" id="kobo.140.1">In the</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.141.1"> previous section, we saw a very simple “Hello World” type of example. </span><span class="koboSpan" id="kobo.141.2">In this section, we will show a more realistic example. </span><span class="koboSpan" id="kobo.141.3">Session beans are </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.142.1">frequently used as </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Data Access Objects</span></strong><span class="koboSpan" id="kobo.144.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.145.1">DAOs</span></strong><span class="koboSpan" id="kobo.146.1">). </span><span class="koboSpan" id="kobo.146.2">Sometimes they are used as a wrapper for JDBC calls; other times they are used to wrap calls to obtain or modify Jakarta Persistence entities. </span><span class="koboSpan" id="kobo.146.3">In this section, we will take the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">latter approach.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">The following example illustrates how to implement the DAO design pattern in a </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">session bean.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">Let’s now take a look at the session bean implementing our example business interface. </span><span class="koboSpan" id="kobo.150.2">As we are about to see, there are some differences between the way Jakarta Persistence code is implemented in a session bean versus in a plain old </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">Java object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
package com.ensode.jakartaeebook;
//imports omitted for brevity
@Stateful
public class CustomerDaoBean implements CustomerDao {
  @PersistenceContext
  private EntityManager entityManager;
  @Override
  public void saveCustomer(Customer customer) {
    if (customer.getCustomerId() == null) {
      entityManager.persist(customer);
    } else {
      entityManager.merge(customer);
    }
  }
  @Override
  public Customer getCustomer(Long customerId) {
    Customer customer;
    customer = entityManager.find(Customer.class,
      customerId);
    return customer;
  }
  @Override
  public void deleteCustomer(Customer customer) {
    entityManager.remove(customer);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.153.1">It is worth </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.154.1">pointing out that since we don’t intend for</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.155.1"> our session bean to be invoked remotely, there is no need for a remote business interface in this case. </span><span class="koboSpan" id="kobo.155.2">Our client applications can simply inject an instance of the session bean via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">EJB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">As we can see, our session bean implements three methods. </span><span class="koboSpan" id="kobo.159.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">saveCustomer()</span></strong><span class="koboSpan" id="kobo.161.1"> method saves customer data to the database, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">getCustomer()</span></strong><span class="koboSpan" id="kobo.163.1"> method obtains data for a </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.164.1">customer from the database, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">deleteCustomer()</span></strong><span class="koboSpan" id="kobo.166.1"> method deletes customer data from the database. </span><span class="koboSpan" id="kobo.166.2">All of these methods take an instance of a Jakarta Persistence entity bean or </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Customer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Normally, when </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.171.1">making Jakarta Persistence calls, we need to start and commit transactions via </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">UserTransaction.begin()</span></strong><span class="koboSpan" id="kobo.173.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">UserTransaction.commit()</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">The reason we need to do this is that Jakarta Persistence calls are required to be wrapped in a transaction. </span><span class="koboSpan" id="kobo.175.3">If they are not in a transaction, most Jakarta Persistence calls will throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">TransactionRequiredException</span></strong><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">Session bean methods are implicitly transactional. </span><span class="koboSpan" id="kobo.177.3">There is nothing we need to do to make them that way. </span><span class="koboSpan" id="kobo.177.4">For this reason, we don’t need to manually start and commit transactions when invoking Jakarta Persistence calls from a session bean. </span><span class="koboSpan" id="kobo.177.5">This</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.178.1"> default behavior is what is known as </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">container-managed transactions</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">Container-managed transactions are discussed in detail later in </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">this chapter.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.182.1">Invoking session beans from web applications</span></h2>
<p><span class="koboSpan" id="kobo.183.1">Frequently, Jakarta EE applications</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.184.1"> consist of web applications acting as clients for enterprise beans. </span><span class="koboSpan" id="kobo.184.2">In this section, we will develop a Jakarta Faces web application with a CDI named bean acting as a client for the DAO session bean we just discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">previous section.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">In order to make this application act as an enterprise bean client, we will develop a </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">CustomerController</span></strong><span class="koboSpan" id="kobo.188.1"> named bean so that it delegates the logic to save a new customer to the database to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">CustomerDaoBean</span></strong><span class="koboSpan" id="kobo.190.1"> session bean we developed in the previous section, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
package com.ensode.jakartaeebook.facesjpa;
//imports omitted for brevity
@Named
@RequestScoped
public class CustomerController implements Serializable {
  @EJB
  private CustomerDaoBean customerDaoBean;
 //variable declarations omitted for brevity
  public CustomerController() {
    customer = new Customer();
  }
  public String saveCustomer() {
    String returnValue = "customer_saved";
    try {
      populateCustomer();
      </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">customerDaoBean.saveCustomer(customer);</span></strong><span class="koboSpan" id="kobo.194.1">
    } catch (Exception e) {
      e.printStackTrace();
      returnValue = "error_saving_customer";
    }
    return returnValue;
  }
  private void populateCustomer() {
     //method implementation omitted for brevity
  }
  //getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.195.1">As we </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.196.1">can see, all we had to do was to obtain an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">CustomerDaoBean</span></strong><span class="koboSpan" id="kobo.198.1"> session bean and annotate it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">@EJB</span></strong><span class="koboSpan" id="kobo.200.1"> annotation, then invoke the bean’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">saveCustomer()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Notice that we injected an instance of the session bean directly into our client code. </span><span class="koboSpan" id="kobo.203.2">Since the client </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.204.1">code is running on the same JVM as the enterprise bean, there is no need for </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">remote interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Now that we have developed our web application client for our session bean, we need to package it in a WAR (web archive) file and deploy it in order to </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">use it.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.208.1">Singleton session beans</span></h2>
<p><span class="koboSpan" id="kobo.209.1">Another</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.210.1"> type of session bean is the </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">singleton session bean</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">A </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.213.1">single instance of each singleton session bean exists in the Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">EE runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">Singleton session beans are useful to cache database data. </span><span class="koboSpan" id="kobo.215.2">Caching frequently used data in a singleton session bean increases performance since it greatly minimizes trips to the database. </span><span class="koboSpan" id="kobo.215.3">The common pattern is to have a method in our bean decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">@PostConstruct</span></strong><span class="koboSpan" id="kobo.217.1"> annotation. </span><span class="koboSpan" id="kobo.217.2">In this method, we retrieve the data we want to cache. </span><span class="koboSpan" id="kobo.217.3">Then, we provide a setter method for the bean’s clients to call. </span><span class="koboSpan" id="kobo.217.4">The following example illustrates </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">this technique:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
package com.ensode.jakartaeebook.singletonsession;
//imports omiktted for brevity
</span><strong class="bold"><span class="koboSpan" id="kobo.220.1">@Singleton</span></strong><span class="koboSpan" id="kobo.221.1">
public class SingletonSessionBean implements
  SingletonSessionBeanRemote {
  @PersistenceContext
  private EntityManager entityManager;
  private List&lt;UsStates&gt; stateList;
  @PostConstruct
  public void init() {
    Query query = entityManager.createQuery(
      "Select us from UsStates us");
    stateList = query.getResultList();
  }
  @Override
  public List&lt;UsStates&gt; getStateList() {
    return stateList;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.222.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">@Singleton</span></strong><span class="koboSpan" id="kobo.224.1"> annotation </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.225.1">denotes our class as a </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.226.1">singleton session bean. </span><span class="koboSpan" id="kobo.226.2">Since our bean is a singleton, all of its clients would access the same instance, avoiding having duplicate data in memory. </span><span class="koboSpan" id="kobo.226.3">Additionally, since it is a singleton, it is safe to have an instance variable, since all clients access the same instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">the bean.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.228.1">Asynchronous method calls</span></h2>
<p><span class="koboSpan" id="kobo.229.1">Sometimes it is </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.230.1">useful to have some processing done asynchronously, that is, invoke a method call and return control immediately to the client, without having the client wait for the method </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">to finish.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">@Asynchronous</span></strong><span class="koboSpan" id="kobo.234.1"> annotation can be used to mark a method in a session bean as asynchronous. </span><span class="koboSpan" id="kobo.234.2">When an enterprise bean client invokes an asynchronous method, control immediately goes back to the client, without waiting for the method </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">to finish.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Asynchronous methods can only return </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">void</span></strong><span class="koboSpan" id="kobo.238.1"> or an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">java.util.concurrent.Future</span></strong><span class="koboSpan" id="kobo.240.1"> interface. </span><span class="koboSpan" id="kobo.240.2">The following example illustrates </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">both scenarios:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
package com.ensode.jakartaeebook.asynchronousmethods;
//imports omitted for brevity
@Stateless
public class AsynchronousSessionBean implements
    AsynchronousSessionBeanRemote {
  private static Logger logger = Logger.getLogger(
    AsynchronousSessionBean.class.getName());
  </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">@Asynchronous</span></strong><span class="koboSpan" id="kobo.244.1">
  @Override
  </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">public void slowMethod()</span></strong><span class="koboSpan" id="kobo.246.1"> throws InterruptedException{
    long startTime = System.currentTimeMillis();
    logger.log(Level.INFO, "entering slowMethod()");
    Thread.sleep(10000); //simulate processing for 10 seconds
    logger.log(Level.INFO, "leaving slowMethod()");
    long endTime = System.currentTimeMillis();
    logger.log(Level.INFO, "execution took {0} milliseconds",
      endTime - startTime)
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">@Asynchronous</span></strong><span class="koboSpan" id="kobo.248.1">
  @Override
  </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">public Future&lt;Long&gt; slowMethodWithReturnValue() </span></strong><span class="koboSpan" id="kobo.250.1">throws
    InterruptedException{
    Thread.sleep(15000); //simulate processing for 15 seconds
    </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">return new AsyncResult&lt;&gt;(42L);</span></strong><span class="koboSpan" id="kobo.252.1">
  }
}</span></pre> <p><span class="koboSpan" id="kobo.253.1">When</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.254.1"> our asynchronous method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">void</span></strong><span class="koboSpan" id="kobo.256.1">, the only thing we need to do is decorate the method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">@Asynchronous</span></strong><span class="koboSpan" id="kobo.258.1"> annotation, and then call it as usual from the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">client code.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">If we need a return value, this value needs to be wrapped in an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">jav.util.concurrent.Future</span></strong><span class="koboSpan" id="kobo.262.1"> interface. </span><span class="koboSpan" id="kobo.262.2">Jakarta EE provides a convenient implementation in the form of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">jakarta.ejb.AsyncResult</span></strong><span class="koboSpan" id="kobo.264.1"> class. </span><span class="koboSpan" id="kobo.264.2">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Future</span></strong><span class="koboSpan" id="kobo.266.1"> interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">AsyncResult</span></strong><span class="koboSpan" id="kobo.268.1"> class use generics. </span><span class="koboSpan" id="kobo.268.2">We need to specify our return type as the type parameter of </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">these artifacts.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Future</span></strong><span class="koboSpan" id="kobo.272.1"> interface </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.273.1">has several methods we can use to cancel the execution of an asynchronous method, check to see whether the method has been carried out, get the return value of the method, or check to see whether the method has been canceled. </span><em class="italic"><span class="koboSpan" id="kobo.274.1">Table 12.1</span></em><span class="koboSpan" id="kobo.275.1"> lists </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">these methods:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.277.1">Method</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.278.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">cancel(boolean mayInterruptIfRunning)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.280.1">Cancels method execution. </span><span class="koboSpan" id="kobo.280.2">If the Boolean parameter is </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">true</span></strong><span class="koboSpan" id="kobo.282.1">, then this method will attempt to cancel the method execution even if it is </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">already running.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">get()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.285.1">Will return the “unwrapped” return value of the method. </span><span class="koboSpan" id="kobo.285.2">The return value will be of the type parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">Future</span></strong><span class="koboSpan" id="kobo.287.1"> interface implementation returned by </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">the method.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">get(long timeout, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">TimeUnit unit)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.291.1">Will attempt the “unwrapped” return value of the method. </span><span class="koboSpan" id="kobo.291.2">The return value will be of the type parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">Future</span></strong><span class="koboSpan" id="kobo.293.1"> interface implementation returned by the method. </span><span class="koboSpan" id="kobo.293.2">This method will block for the amount of time specified by the first parameter. </span><span class="koboSpan" id="kobo.293.3">The unit of time to wait is determined by the second parameter. </span><span class="koboSpan" id="kobo.293.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">TimeUnit</span></strong><span class="koboSpan" id="kobo.295.1"> enum has constants for NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, and so on. </span><span class="koboSpan" id="kobo.295.2">Refer to its Javadoc documentation for the </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">complete list.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">isCancelled()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.298.1">Returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">true</span></strong><span class="koboSpan" id="kobo.300.1"> if the method has been canceled, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1"> otherwise.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">isDone()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.304.1">Returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">true</span></strong><span class="koboSpan" id="kobo.306.1"> if the method has finished executing, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> otherwise.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.309.1">Table 12.1 – Canceling asynchronous method execution</span></p>
<p><span class="koboSpan" id="kobo.310.1">As </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.311.1">we can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">@Asynchronous</span></strong><span class="koboSpan" id="kobo.313.1"> annotation makes it very easy to make asynchronous calls without having the overhead of having to set up message queues </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">or topics.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The following example illustrates how to invoke asynchronous Jakarta Enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">Bean methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
package com.ensode.jakarteebook.asynchronousmethodsclient;
//imports omitted for brevity
public class App {
  @EJB
  private static AsynchronousSessionBeanRemote async;
  public void invokeEjbMethods() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">async.slowMethod();</span></strong><span class="koboSpan" id="kobo.319.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">Future&lt;Long&gt; retVal</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.321.1">        = async.slowMethodWithReturnValue();</span></strong><span class="koboSpan" id="kobo.322.1">
    if (</span><strong class="bold"><span class="koboSpan" id="kobo.323.1">!retVal.isDone()</span></strong><span class="koboSpan" id="kobo.324.1">) {
      System.out.println("Canceling second method call");
      </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">retVal.cancel(true);</span></strong><span class="koboSpan" id="kobo.326.1">
    } else {
      try {
        System.out.println("second method call done, "
            + "return value is: " + </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">retVal.get()</span></strong><span class="koboSpan" id="kobo.328.1">);
      } catch (Exception ex) {
        Logger.getLogger(App.class.getName()).
</span><span class="koboSpan" id="kobo.328.2">            log(Level.SEVERE, null, ex);
      }
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.329.1">As we can see, invoking</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.330.1"> the asynchronous Jakarta Enterprise Beans method returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">void</span></strong><span class="koboSpan" id="kobo.332.1"> is no different from invoking a regular method. </span><span class="koboSpan" id="kobo.332.2">Things get a bit more interesting when invoking a method that returns a value. </span><span class="koboSpan" id="kobo.332.3">The asynchronous invocation returns an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Future</span></strong><span class="koboSpan" id="kobo.334.1">. </span><span class="koboSpan" id="kobo.334.2">We can then check to see whether the invocation is done by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">isDone()</span></strong><span class="koboSpan" id="kobo.336.1"> on the future instance, cancel it if it’s taking too long by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">cancel()</span></strong><span class="koboSpan" id="kobo.338.1">, or obtain the value from the asynchronous method by </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">invoking </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">get()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Now that we’ve discussed session beans at length, we’ll focus our attention on the other type of enterprise bean, </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">message-driven beans.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.344.1">Message-driven beans</span></h1>
<p><span class="koboSpan" id="kobo.345.1">The purpose </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.346.1">of a message-driven bean is to consume messages from a Jakarta messaging queue or a Jakarta messaging topic, depending on the messaging domain used (refer to </span><a href="B21231_13.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.347.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.348.1">). </span><span class="koboSpan" id="kobo.348.2">A message-driven bean must be annotated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">@MessageDriven</span></strong><span class="koboSpan" id="kobo.350.1"> annotation. </span><span class="koboSpan" id="kobo.350.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">mappedName</span></strong><span class="koboSpan" id="kobo.352.1"> attribute of this annotation must contain the </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Java Naming and Directory Interface</span></strong><span class="koboSpan" id="kobo.354.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.355.1">JNDI</span></strong><span class="koboSpan" id="kobo.356.1">) name of the message queue or message topic that the bean will be consuming messages from. </span><span class="koboSpan" id="kobo.356.2">The </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.357.1">following example illustrates a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">message-driven bean:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
package com.ensode.jakartaeebook;
//imports omitted for brevity
</span><strong class="bold"><span class="koboSpan" id="kobo.360.1">@JMSDestinationDefinition(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.361.1">    name = "java:global/queue/JakartaEEBookQueue",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.362.1">    interfaceName = "jakarta.jms.Queue",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.363.1">    destinationName = "JakartaEEBookQueue"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.364.1">)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.365.1">@MessageDriven(activationConfig = {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.366.1">  @ActivationConfigProperty(propertyName = "destinationLookup»,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.367.1">      propertyValue = "java:global/queue/JakartaEEBookQueue"),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.368.1">  @ActivationConfigProperty(propertyName = "destinationType",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.369.1">      propertyValue = "jakarta.jms.Queue")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.370.1">})</span></strong><span class="koboSpan" id="kobo.371.1">
public class ExampleMessageDrivenBean implements MessageListener {
  private static final Logger LOG = Logger.getLogger(
    ExampleMessageDrivenBean.class.getName());
  public void onMessage(Message message) {
    TextMessage textMessage = (TextMessage) message;
    try {
      LOG.log(Level.INFO, "Received message: ");
      LOG.log(Level.INFO, textMessage.getText());
    } catch (JMSException e) {
      e.printStackTrace();
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.372.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.374.1"> annotation defines a Jakarta messaging destination</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.375.1"> that the message-driven bean will use to consume messages from. </span><span class="koboSpan" id="kobo.375.2">The destination can either be a queue or a topic; in our case, we are using a queue, therefore </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">jakarta.jms.Queue</span></strong><span class="koboSpan" id="kobo.377.1"> is the value of the annotation’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">interfaceName</span></strong><span class="koboSpan" id="kobo.379.1"> attribute. </span><span class="koboSpan" id="kobo.379.2">The annotation’s name attribute defines a JNDI name that the message-driven bean can use to refer to </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Message-driven beans must be decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">@MessageDriven</span></strong><span class="koboSpan" id="kobo.383.1"> annotation; they listen for messages on the queue or topic defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">destinationLookup</span></strong><span class="koboSpan" id="kobo.385.1"> property as defined by an </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">@ActivationConfigProperty</span></strong><span class="koboSpan" id="kobo.387.1"> annotation. </span><span class="koboSpan" id="kobo.387.2">Notice that in our example, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">destinationLookup</span></strong><span class="koboSpan" id="kobo.389.1"> property matches the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">name</span></strong><span class="koboSpan" id="kobo.391.1"> attribute in the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">@JMSDestinationDefinition</span></strong><span class="koboSpan" id="kobo.393.1"> annotation. </span><span class="koboSpan" id="kobo.393.2">The type of Jakarta messaging destination (</span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">jakarta.jmsQueue</span></strong><span class="koboSpan" id="kobo.395.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">jakarta.jms.Topic</span></strong><span class="koboSpan" id="kobo.397.1">) must be specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">destinationType</span></strong><span class="koboSpan" id="kobo.399.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">@MessageDriven</span></strong><span class="koboSpan" id="kobo.401.1">, as illustrated in </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">our example.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">It is recommended, but not required, for message-driven beans to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">jakarta.jms.MessageListener</span></strong><span class="koboSpan" id="kobo.405.1"> interface. </span><span class="koboSpan" id="kobo.405.2">However, message-driven beans must have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">onMessage()</span></strong><span class="koboSpan" id="kobo.407.1"> whose signature is identical to the </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">preceding example.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Client applications never invoke a message-driven bean’s methods directly. </span><span class="koboSpan" id="kobo.409.2">Instead, they put messages in the message queue or topic, and then the bean consumes those messages and acts as appropriate. </span><span class="koboSpan" id="kobo.409.3">Our example simply prints the message to the Jakarta EE </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">runtime log.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">Both session and message-driven beans support transaction management, this is discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">following sections.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.413.1">Transactions in enterprise beans</span></h1>
<p><span class="koboSpan" id="kobo.414.1">As we mentioned </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.415.1">earlier in this chapter, by default, all </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.416.1">enterprise bean methods are automatically wrapped in a transaction. </span><span class="koboSpan" id="kobo.416.2">This default behavior is known as </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">container-managed transactions</span></strong><span class="koboSpan" id="kobo.418.1">, since transactions are managed by the Jakarta EE runtime. </span><span class="koboSpan" id="kobo.418.2">Application developers may also choose to manage transactions themselves. </span><span class="koboSpan" id="kobo.418.3">This can be accomplished by using </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">bean-managed transactions</span></strong><span class="koboSpan" id="kobo.420.1">. </span><span class="koboSpan" id="kobo.420.2">Both of these approaches are discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">following sections.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.422.1">Container-managed transactions</span></h2>
<p><span class="koboSpan" id="kobo.423.1">Because enterprise </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.424.1">bean </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.425.1">methods are transactional by default, we run into an interesting dilemma when an enterprise bean method is invoked from client code that is already in a transaction. </span><span class="koboSpan" id="kobo.425.2">How should the Jakarta EE runtime behave? </span><span class="koboSpan" id="kobo.425.3">Should it suspend the client transaction, execute its method in a new transaction, and then resume the client transaction? </span><span class="koboSpan" id="kobo.425.4">Should it not create a new transaction and execute its method as part of the client transaction? </span><span class="koboSpan" id="kobo.425.5">Should it throw </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">an exception?</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">By default, if an enterprise bean method is invoked by client code that is already in a transaction, the Jakarta EE runtime will simply execute the enterprise bean method as part of the client transaction. </span><span class="koboSpan" id="kobo.427.2">If this is not the behavior we need, we can change it by annotating the method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">@TransactionAttribute</span></strong><span class="koboSpan" id="kobo.429.1"> annotation. </span><span class="koboSpan" id="kobo.429.2">This annotation has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">value</span></strong><span class="koboSpan" id="kobo.431.1"> attribute that determines how the Jakarta EE runtime will behave when the session bean method is invoked within an existing transaction and when it is invoked outside any transactions. </span><span class="koboSpan" id="kobo.431.2">The value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">value</span></strong><span class="koboSpan" id="kobo.433.1"> attribute is typically a constant defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">jakarta.ejb.TransactionAttributeType</span></strong><span class="koboSpan" id="kobo.435.1"> enum. </span><em class="italic"><span class="koboSpan" id="kobo.436.1">Table 12.2</span></em><span class="koboSpan" id="kobo.437.1"> lists the possible values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">TransactionAttribute</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1"> annotation:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.441.1">@</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.442.1">TransactionAttribute Value</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.443.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">TransactionAttributeType.MANDATORY</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.445.1">Forces the method to be invoked as part of a client transaction. </span><span class="koboSpan" id="kobo.445.2">If the method is called outside any transactions, it will </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">throw </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">TransactionRequiredException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">TransactionAttributeType.NEVER</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.450.1">The method is never executed in a transaction. </span><span class="koboSpan" id="kobo.450.2">If the method is invoked as part of a client transaction, it will throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">RemoteException</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">No transaction is created if the method is not invoked inside a </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">client transaction.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">TransactionAttributeType.NOT_SUPPORTED</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.455.1">If the method is invoked as part of a client transaction, the client transaction is suspended. </span><span class="koboSpan" id="kobo.455.2">The method is executed outside any transaction. </span><span class="koboSpan" id="kobo.455.3">After the method completes, the client transaction is resumed. </span><span class="koboSpan" id="kobo.455.4">No transaction is created if the method is not invoked inside a </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">client transaction.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">TransactionAttributeType.REQUIRED</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.458.1">If the method is invoked as part of a client transaction, the method is executed as part of said transaction. </span><span class="koboSpan" id="kobo.458.2">If the method is invoked outside any transaction, a new transaction is created for the method. </span><span class="koboSpan" id="kobo.458.3">This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">default behavior.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">TransactionAttributeType.REQUIRES_NEW</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.461.1">If the method is invoked as part of a client transaction, said transaction is suspended, and a new transaction is created for the method. </span><span class="koboSpan" id="kobo.461.2">Once the method completes, the client transaction is resumed. </span><span class="koboSpan" id="kobo.461.3">If the method is called outside any transactions, a new transaction is created for </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">the method.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">TransactionAttributeType.SUPPORTS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.464.1">If the method is invoked as part of a client transaction, it is executed as part of said transaction. </span><span class="koboSpan" id="kobo.464.2">If the method is invoked outside a transaction, no new transaction is created for </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the method.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.466.1">Table 12.2 – Container-managed transactions transaction attributes</span></p>
<p><span class="koboSpan" id="kobo.467.1">Although </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.468.1">the default transaction attribute is reasonable in most cases, it is good to be able to override this default if necessary. </span><span class="koboSpan" id="kobo.468.2">For example, transactions have a performance impact, therefore being able to turn off transactions for a method that does not need them is beneficial. </span><span class="koboSpan" id="kobo.468.3">For</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.469.1"> a case like this, we would annotate our method as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">code snippet:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.471.1">@TransactionAttribute(value=TransactionAttributeType.NEVER)</span></strong><span class="koboSpan" id="kobo.472.1">
public void doitAsFastAsPossible(){
  //performance critical code goes here.
</span><span class="koboSpan" id="kobo.472.2">}</span></pre> <p><span class="koboSpan" id="kobo.473.1">Other transaction attribute types can be declared by annotating the methods with the corresponding constant in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">TransactionAttributeType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1"> enum.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">If we wish to override the default transaction attribute consistently across all methods in a session bean, we can decorate the session bean class with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">@TransactionAttribute</span></strong><span class="koboSpan" id="kobo.478.1"> annotation. </span><span class="koboSpan" id="kobo.478.2">The value of its </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">value</span></strong><span class="koboSpan" id="kobo.480.1"> attribute will be applied to every method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">session bean.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Container-managed transactions </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.483.1">are automatically rolled back whenever an exception is thrown inside an</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.484.1"> enterprise bean method. </span><span class="koboSpan" id="kobo.484.2">Additionally, we can programmatically roll back a container-managed transaction by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">setRollbackOnly()</span></strong><span class="koboSpan" id="kobo.486.1"> method on an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">jakarta.ejb.EJBContext</span></strong><span class="koboSpan" id="kobo.488.1"> corresponding to the session bean in question. </span><span class="koboSpan" id="kobo.488.2">The following example is a new version of the session bean we saw earlier in this chapter, modified to roll back transactions </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">if necessary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
package com.ensode.jakartaeebook;
//imports omitted for brevity
@Stateless
public class CustomerDaoRollbackBean implements
  CustomerDaoRollback {
  @Resource
  private EJBContext ejbContext;
  @PersistenceContext
  private EntityManager entityManager;
  @Resource(name = "java:app/jdbc/customerdbDatasource")
  private DataSource dataSource;
  @Override
  public void saveNewCustomer(Customer customer) {
    if (customer == null ||
      customer.getCustomerId() != null) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">ejbContext.setRollbackOnly();</span></strong><span class="koboSpan" id="kobo.492.1">
    } else {
      customer.setCustomerId(getNewCustomerId());
      entityManager.persist(customer);
    }
  }
  //additional methods omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.493.1">In this</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.494.1"> version of the DAO session bean, we made the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">saveNewCustomer()</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.496.1">updateCustomer()</span></strong><span class="koboSpan" id="kobo.497.1"> method public. </span><span class="koboSpan" id="kobo.497.2">This </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.498.1">method now checks to see whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">customerId</span></strong><span class="koboSpan" id="kobo.500.1"> field is null. </span><span class="koboSpan" id="kobo.500.2">If it is not null, this implies we are working with a customer that already exists in the database. </span><span class="koboSpan" id="kobo.500.3">Our method also checks to make sure the object to be persisted is not null. </span><span class="koboSpan" id="kobo.500.4">If any of the checks result in invalid data, the method simply rolls back the transaction by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">setRollBackOnly()</span></strong><span class="koboSpan" id="kobo.502.1"> method on the injected instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">EJBContext</span></strong><span class="koboSpan" id="kobo.504.1"> and does not update </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">the database.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.506.1">Bean-managed transactions</span></h2>
<p><span class="koboSpan" id="kobo.507.1">As we have </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.508.1">seen, container-managed transactions </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.509.1">make it ridiculously easy to write code that is wrapped in a transaction; after all, there is nothing special that we need to do to make them that way. </span><span class="koboSpan" id="kobo.509.2">As a matter of fact, some developers are sometimes not even aware that they are writing code that will be transactional in nature when they develop session beans. </span><span class="koboSpan" id="kobo.509.3">Container-managed transactions cover most of the typical cases that we will encounter. </span><span class="koboSpan" id="kobo.509.4">However, they do have a limitation. </span><span class="koboSpan" id="kobo.509.5">Each method can be wrapped in a single transaction or with no transaction. </span><span class="koboSpan" id="kobo.509.6">With container-managed transactions, it is not possible to implement a method that generates more than one transaction, but this can be accomplished by using </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.510.1">bean-managed transactions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
package com.ensode.jakartaee;
//imports omitted
@Stateless
</span><strong class="bold"><span class="koboSpan" id="kobo.513.1">@TransactionManagement(value =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.514.1">  TransactionManagementType.BEAN)</span></strong><span class="koboSpan" id="kobo.515.1">
public class CustomerDaoBmtBean implements CustomerDaoBmt {
  </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">@Resource private UserTransaction userTransaction;</span></strong><span class="koboSpan" id="kobo.517.1">
  @PersistenceContext
  private EntityManager entityManager;
  @Resource(name = "java:app/jdbc/customerdbDatasource")
  private DataSource dataSource;
@Override
  public void saveMultipleNewCustomers(
    List&lt;Customer&gt; customerList)
    throws Exception {
      for (Customer customer : customerList) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">userTransaction.begin();</span></strong><span class="koboSpan" id="kobo.519.1">
        customer.setCustomerId(getNewCustomerId());
        </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">entityManager.persist(customer);</span></strong><span class="koboSpan" id="kobo.521.1">
        userTransaction.commit();
      }
    }
  //additional methods omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.522.1">In this</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.523.1"> example, we implemented a </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.524.1">method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">saveMultipleNewCustomers()</span></strong><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">This method takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">List</span></strong><span class="koboSpan" id="kobo.528.1"> of customers as its sole parameter. </span><span class="koboSpan" id="kobo.528.2">The intention of this method is to save as many elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">ArrayList</span></strong><span class="koboSpan" id="kobo.530.1"> as possible. </span><span class="koboSpan" id="kobo.530.2">An exception saving one of the entities should not stop the method from attempting to save the remaining elements. </span><span class="koboSpan" id="kobo.530.3">This behavior is not possible using container-managed transactions, since an exception thrown when saving one of the entities would roll back the whole transaction. </span><span class="koboSpan" id="kobo.530.4">The only way to achieve this behavior is through </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">bean-managed transactions.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">As can be</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.533.1"> seen in the example, we </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.534.1">declare that the session bean uses bean-managed transactions by decorating the class with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">@TransactionManagement</span></strong><span class="koboSpan" id="kobo.536.1"> annotation and using </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">TransactionManagementType.BEAN</span></strong><span class="koboSpan" id="kobo.538.1"> as the value for its </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">value</span></strong><span class="koboSpan" id="kobo.540.1"> attribute (the only other valid value for this attribute is </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">TransactionManagementType.CONTAINER</span></strong><span class="koboSpan" id="kobo.542.1">, but since this is the default value, it is not necessary to </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">specify it).</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">To be able to programmatically control transactions, we inject an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">jakarta.transaction.UserTransaction</span></strong><span class="koboSpan" id="kobo.546.1">, which is then used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">for</span></strong><span class="koboSpan" id="kobo.548.1"> loop inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">saveMultipleNewCustomers()</span></strong><span class="koboSpan" id="kobo.550.1"> method to begin and commit transactions in each iteration of </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the loop.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">If we need to roll back a bean-managed transaction, we can do it by simply calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">rollback()</span></strong><span class="koboSpan" id="kobo.554.1"> method on the appropriate instance </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">jakarta.transaction.UserTransaction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Before moving on, it is worth noting that even though all the examples in this section were session beans, the concepts explained apply to message-driven beans </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">We will now focus our attention on enterprise bean </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">life cycles.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.562.1">Enterprise bean life cycles</span></h1>
<p><span class="koboSpan" id="kobo.563.1">Enterprise</span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.564.1"> beans go through different states throughout their life cycle. </span><span class="koboSpan" id="kobo.564.2">Each type of enterprise bean has different states. </span><span class="koboSpan" id="kobo.564.3">States specific to each type of enterprise bean are discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">following sections.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.566.1">Stateful session bean life cycle</span></h2>
<p><span class="koboSpan" id="kobo.567.1">We </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.568.1">can annotate methods in </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.569.1">session beans so that they are automatically invoked by the Jakarta EE runtime at certain points in the bean’s life cycle. </span><span class="koboSpan" id="kobo.569.2">For example, we could have a method invoked right after the bean is created or right before it </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">is destroyed.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">Before explaining the annotations available to implement life cycle methods, a brief explanation of the session bean life cycle is in order. </span><span class="koboSpan" id="kobo.571.2">The life cycle of a stateful session bean is different from the life cycle of a stateless or singleton </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">session bean.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">A stateful session</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.574.1"> bean life cycle contains </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.575.1">three states: </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.577.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">Ready</span></strong><span class="koboSpan" id="kobo.579.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.580.1">Passive</span></strong><span class="koboSpan" id="kobo.581.1">, as</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.582.1"> illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.583.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.584.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.586.1"><img alt="Figure 12.1 – Stateful session bean life cycle" src="image/B21231_12_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.587.1">Figure 12.1 – Stateful session bean life cycle</span></p>
<p><span class="koboSpan" id="kobo.588.1">Before a </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.589.1">stateful session </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.590.1">bean is deployed, it is in the </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.592.1"> state. </span><span class="koboSpan" id="kobo.592.2">Upon successful deployment, the Jakarta EE runtime does any required dependency injection on the bean and it goes into the </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">Ready</span></strong><span class="koboSpan" id="kobo.594.1"> state. </span><span class="koboSpan" id="kobo.594.2">At this point, the bean is ready to have its methods called by a </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">client application.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">When a stateful session bean is in the </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">Ready</span></strong><span class="koboSpan" id="kobo.598.1"> state, the Jakarta EE runtime may decide to passivate it, that is, to move it from main memory to secondary storage. </span><span class="koboSpan" id="kobo.598.2">When this happens, the bean goes into the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.599.1">Passive</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1"> state.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">If an instance of a stateful session bean hasn’t been accessed for a period of time, the Jakarta EE runtime will set the bean to the </span><strong class="bold"><span class="koboSpan" id="kobo.602.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.603.1"> state. </span><span class="koboSpan" id="kobo.603.2">How long a bean will stay in memory </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.604.1">before being destroyed varies from application server to application server and is </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">usually configurable.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">Any methods in a stateful session bean annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">@PostActivate</span></strong><span class="koboSpan" id="kobo.608.1"> will be invoked just after the stateful session bean has been activated. </span><span class="koboSpan" id="kobo.608.2">Similarly, any method annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">@PrePassivate</span></strong><span class="koboSpan" id="kobo.610.1"> will be invoked just before the stateful session bean </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">is passivated.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">When a stateful session bean that is in the </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">Ready</span></strong><span class="koboSpan" id="kobo.614.1"> state times out and is sent to the </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.616.1"> state, any method decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.618.1"> annotation is executed. </span><span class="koboSpan" id="kobo.618.2">If the </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.619.1">session bean is in the </span><strong class="bold"><span class="koboSpan" id="kobo.620.1">Passive</span></strong><span class="koboSpan" id="kobo.621.1"> state and it times out, methods decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.623.1"> annotation are not executed. </span><span class="koboSpan" id="kobo.623.2">Additionally, if a client of the stateful session bean executes any method decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">@Remove</span></strong><span class="koboSpan" id="kobo.625.1"> annotation, any methods decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.627.1"> annotation are executed and the bean is marked for </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">garbage collection.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">@PostActivate</span></strong><span class="koboSpan" id="kobo.631.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">@PrePassivate</span></strong><span class="koboSpan" id="kobo.633.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">@Remove</span></strong><span class="koboSpan" id="kobo.635.1"> annotations are valid only for stateful session beans. </span><span class="koboSpan" id="kobo.635.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.637.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">@PostConstruct</span></strong><span class="koboSpan" id="kobo.639.1"> annotations are valid for stateful session beans, stateless session beans, and </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">message-driven beans.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.641.1">Stateless and singleton session bean life cycle</span></h2>
<p><span class="koboSpan" id="kobo.642.1">A </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.643.1">stateless or singleton </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.644.1">session bean</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.645.1"> life cycle contains only the </span><strong class="bold"><span class="koboSpan" id="kobo.646.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.647.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.648.1">Ready</span></strong><span class="koboSpan" id="kobo.649.1"> states, as illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.650.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.651.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.653.1"><img alt="Figure 12.2 – Stateless and singleton session beans life cycle" src="image/B21231_12_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.654.1">Figure 12.2 – Stateless and singleton session beans life cycle</span></p>
<p><span class="koboSpan" id="kobo.655.1">Stateless and singleton session beans are never passivated. </span><span class="koboSpan" id="kobo.655.2">A stateless or singleton session bean’s methods can be decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">@PostConstruct</span></strong><span class="koboSpan" id="kobo.657.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.659.1"> annotations. </span><span class="koboSpan" id="kobo.659.2">Just like in stateful session beans, any methods decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">@PostConstruct</span></strong><span class="koboSpan" id="kobo.661.1"> annotation</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.662.1"> will be executed when the session bean goes from the </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.664.1"> state </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.665.1">to the </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">Ready</span></strong><span class="koboSpan" id="kobo.667.1"> state, and any methods decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.669.1"> annotation will be executed when a stateless session bean goes from the </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">Ready</span></strong><span class="koboSpan" id="kobo.671.1"> state to the </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.673.1"> state. </span><span class="koboSpan" id="kobo.673.2">Stateless and singleton session beans are never passivated, therefore any </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">@PrePassivate</span></strong><span class="koboSpan" id="kobo.675.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">@PostActivate</span></strong><span class="koboSpan" id="kobo.677.1"> annotations</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.678.1"> in a stateless session bean are simply ignored by the Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">EE runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">Most Jakarta EE runtimes allow us to configure how long to wait before an idle stateless or singleton session bean </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">is destroyed.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.682.1">Message-driven bean life cycle</span></h2>
<p><span class="koboSpan" id="kobo.683.1">Just like</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.684.1"> stateless session beans, message-driven beans</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.685.1"> contain </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.686.1">only the </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">Does Not Exist</span></strong><span class="koboSpan" id="kobo.688.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">Ready</span></strong><span class="koboSpan" id="kobo.690.1"> states, as illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.692.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.694.1"><img alt="Figure 12.3 – Message-driven bean life cycle" src="image/B21231_12_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.695.1">Figure 12.3 – Message-driven bean life cycle</span></p>
<p><span class="koboSpan" id="kobo.696.1">A message-driven bean can have methods decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">@PostConstruct</span></strong><span class="koboSpan" id="kobo.698.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.700.1"> methods. </span><span class="koboSpan" id="kobo.700.2">Methods decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">@PostConstruct</span></strong><span class="koboSpan" id="kobo.702.1"> are executed just before the bean goes to the </span><strong class="bold"><span class="koboSpan" id="kobo.703.1">Ready</span></strong><span class="koboSpan" id="kobo.704.1"> state. </span><span class="koboSpan" id="kobo.704.2">Methods decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">@PreDestroy</span></strong><span class="koboSpan" id="kobo.706.1"> annotation are executed just before the bean goes to the </span><strong class="bold"><span class="koboSpan" id="kobo.707.1">Does Not </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.708.1">Exist</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.709.1"> state.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Now that we’ve covered enterprise bean life cycles, we’ll focus our attention on another enterprise bean feature, namely the enterprise bean </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">timer service.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.712.1">Enterprise bean timer service</span></h1>
<p><span class="koboSpan" id="kobo.713.1">Stateless session beans </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.714.1">and message-driven beans can have a method that is executed periodically at regular intervals of time. </span><span class="koboSpan" id="kobo.714.2">This can be accomplished by using the </span><strong class="bold"><span class="koboSpan" id="kobo.715.1">enterprise bean timer service</span></strong><span class="koboSpan" id="kobo.716.1">. </span><span class="koboSpan" id="kobo.716.2">The following example illustrates how to take advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">this feature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.718.1">
package com.ensode.jakartaeebook;
//imports omitted
@Stateless
public class JebTimerExampleBean implements
  JebTimerExample
  private static final Logger LOG =
    Logger.getLogger(JebTimerExampleBean.class.getName());
  </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">@Resource</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.720.1">  TimerService timerService;</span></strong><span class="koboSpan" id="kobo.721.1">
  @Override
  public void startTimer(Serializable info) {
    </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">timerService.createTimer(new Date(), 5000, info);</span></strong><span class="koboSpan" id="kobo.723.1">
  }
  @Override
  public void stopTimer(Serializable info) {
    Collection&lt;Timer&gt; timers = timerService.getTimers();
    timers.stream().filter(t -&gt; t.getInfo().equals(info)).
</span><span class="koboSpan" id="kobo.723.2">      forEach(t -&gt; t.cancel());
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">@Timeout</span></strong><span class="koboSpan" id="kobo.725.1">
  @Override
  public void logMessage(Timer timer) {
    LOG.log(Level.INFO, "Message triggered by :{0} at {1}",
      new Object[]{timer.getInfo(),
        System.currentTimeMillis()});
  }
}</span></pre> <p><span class="koboSpan" id="kobo.726.1">In this example, we</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.727.1"> inject an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">jakarta.ejb.TimerService</span></strong><span class="koboSpan" id="kobo.729.1"> interface by annotating an instance variable of this type with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">@Resource</span></strong><span class="koboSpan" id="kobo.731.1"> annotation. </span><span class="koboSpan" id="kobo.731.2">We can then create a timer by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">createTimer()</span></strong><span class="koboSpan" id="kobo.733.1"> method of this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">TimerService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.735.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">There are several overloaded versions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">createTimer()</span></strong><span class="koboSpan" id="kobo.738.1"> method. </span><span class="koboSpan" id="kobo.738.2">The one we chose to use takes an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">java.util.Date</span></strong><span class="koboSpan" id="kobo.740.1"> as its first parameter. </span><span class="koboSpan" id="kobo.740.2">This parameter is used to indicate the first time the timer should expire (“go off”). </span><span class="koboSpan" id="kobo.740.3">In the example, we chose to use a brand-new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">Date</span></strong><span class="koboSpan" id="kobo.742.1"> class, which in effect makes the timer expire immediately. </span><span class="koboSpan" id="kobo.742.2">The second parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">createTimer()</span></strong><span class="koboSpan" id="kobo.744.1"> method is the amount of time to wait, in milliseconds, before the timer expires again. </span><span class="koboSpan" id="kobo.744.2">In our example, the timer will expire every five seconds. </span><span class="koboSpan" id="kobo.744.3">The third parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">createTimer()</span></strong><span class="koboSpan" id="kobo.746.1"> method can be an instance of any class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">java.io.Serializable</span></strong><span class="koboSpan" id="kobo.748.1"> interface. </span><span class="koboSpan" id="kobo.748.2">Since a single enterprise bean can have several timers executing concurrently, this third parameter is used to uniquely identify each of the timers. </span><span class="koboSpan" id="kobo.748.3">If we don’t need to identify the timers, null can be passed as a value for </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">this parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">We can stop a timer by invoking its </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">cancel()</span></strong><span class="koboSpan" id="kobo.752.1"> method. </span><span class="koboSpan" id="kobo.752.2">There is no way to directly obtain a single timer associated with an enterprise bean. </span><span class="koboSpan" id="kobo.752.3">What we need to do is invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">getTimers()</span></strong><span class="koboSpan" id="kobo.754.1"> method on the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">TimerService</span></strong><span class="koboSpan" id="kobo.756.1"> that is linked to the enterprise bean. </span><span class="koboSpan" id="kobo.756.2">This method will return a collection containing all the timers associated with the enterprise bean. </span><span class="koboSpan" id="kobo.756.3">We can then obtain a stream from the collection, filter it so that it only contains</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.757.1"> elements with the desired value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">getInfo()</span></strong><span class="koboSpan" id="kobo.759.1">, and then invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">cancel()</span></strong><span class="koboSpan" id="kobo.761.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">matching timers.</span></span></p>
<p><span class="koboSpan" id="kobo.763.1">Finally, any enterprise bean method decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">@Timeout</span></strong><span class="koboSpan" id="kobo.765.1"> annotation will be executed when a timer expires. </span><span class="koboSpan" id="kobo.765.2">Methods decorated with this annotation must return </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">void</span></strong><span class="koboSpan" id="kobo.767.1"> and take a single parameter of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">jakarta.ejb.Timer</span></strong><span class="koboSpan" id="kobo.769.1">. </span><span class="koboSpan" id="kobo.769.2">In our example, the method simply writes a message to the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">server log.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">The following class is a standalone client for our example </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">enterprise bean:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.773.1">
package com.ensode.jakartaeebook;
import jakarta.ejb.EJB;
public class Client {
  @EJB
  private static JebTimerExample jebTimerExample;
  public static void main(String[] args) {
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">jebTimerExample.startTimer("Timer 1");</span></strong><span class="koboSpan" id="kobo.775.1">
      Thread.sleep(2000);
      </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">jebTimerExample.startTimer("Timer 2");</span></strong><span class="koboSpan" id="kobo.777.1">
      Thread.sleep(30000);
      </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">jebTimerExample.stopTimer("Timer 1");</span></strong><span class="koboSpan" id="kobo.779.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">jebTimerExample.stopTimer("Timer 2");</span></strong><span class="koboSpan" id="kobo.781.1">
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.782.1">The example simply starts a timer, waits for a couple of seconds, and then starts a second timer. </span><span class="koboSpan" id="kobo.782.2">It</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.783.1"> then sleeps for 30 seconds and then stops both timers. </span><span class="koboSpan" id="kobo.783.2">After deploying the enterprise bean and executing the client, we should see some entries like this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">server log:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.785.1">
This message was triggered by :Timer 1 at 1,699,468,776,716|#]
This message was triggered by :Timer 2 at 1,699,468,778,762|#]
This message was triggered by :Timer 1 at 1,699,468,781,716|#]
This message was triggered by :Timer 2 at 1,699,468,783,762|#]
This message was triggered by :Timer 1 at 1,699,468,786,716|#]
This message was triggered by :Timer 2 at 1,699,468,788,762|#]</span></pre> <p><span class="koboSpan" id="kobo.786.1">These entries are created each time one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">timers expires.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">In addition to starting a timer programmatically, as seen in the example in this section, we can schedule our timers via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">@Schedule</span></strong><span class="koboSpan" id="kobo.790.1"> annotation, which uses calendar-based expressions for scheduling enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">bean timers.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.792.1">Calendar-based enterprise bean timer expressions</span></h2>
<p><span class="koboSpan" id="kobo.793.1">The </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.794.1">example</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.795.1"> in the previous section has one disadvantage: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">startTimer()</span></strong><span class="koboSpan" id="kobo.797.1"> method in the session bean must be invoked from a client in order to start the timer. </span><span class="koboSpan" id="kobo.797.2">This restriction makes it difficult to have the timer start as soon as the bean </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">is deployed.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">Java EE 6 introduced calendar-based enterprise bean timer expressions. </span><span class="koboSpan" id="kobo.799.2">Calendar-based expressions allow one or more methods in our session beans to be executed at a certain date and time. </span><span class="koboSpan" id="kobo.799.3">For example, we could configure one of our methods to be executed every night at 8:10 p.m., which is exactly what our next </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">example does:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
package com.ensode.javaee8book.calendarbasedtimer;
//imports omitted for brevity
@Stateless
public class CalendarBasedTimerJebExampleBean {
  private static Logger logger = Logger.getLogger(
      CalendarBasedTimerJebExampleBean.class.getName());
  </span><strong class="bold"><span class="koboSpan" id="kobo.802.1">@Schedule(hour = "20", minute = "10")</span></strong><span class="koboSpan" id="kobo.803.1">
  public void logMessage() {
    logger.log(Level.INFO,
      "This message was triggered at:{0}",
      System.currentTimeMillis());
  }
}</span></pre> <p><span class="koboSpan" id="kobo.804.1">As we</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.805.1"> can see in this example, we set up the time when the method will be executed via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">jakarta.ejb.Schedule</span></strong><span class="koboSpan" id="kobo.807.1"> annotation. </span><span class="koboSpan" id="kobo.807.2">In this particular example, we set</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.808.1"> up our method to be executed at 8:10 p.m. </span><span class="koboSpan" id="kobo.808.2">by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">hour</span></strong><span class="koboSpan" id="kobo.810.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">@Schedule</span></strong><span class="koboSpan" id="kobo.812.1"> annotation to </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">"20"</span></strong><span class="koboSpan" id="kobo.814.1">, and its minute attribute to </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">"10"</span></strong><span class="koboSpan" id="kobo.816.1"> (the value of the hour attribute is 24-hour based; hour 20 is equivalent to </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">8:00 p.m.).</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">@Schedule</span></strong><span class="koboSpan" id="kobo.820.1"> annotation has several other attributes, which allows a lot of flexibility in specifying when the method should be executed. </span><span class="koboSpan" id="kobo.820.2">We could, for instance, have a method executed on the third Friday of every month, on the last day of the month, and so on and </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">so forth.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">The following table lists all the attributes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">@Schedule</span></strong><span class="koboSpan" id="kobo.824.1"> annotation that allow us to control when the annotated method will </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">be executed:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.826.1">Attribute</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.827.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.828.1">Example Values</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.829.1">Default Value</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">dayOfMonth</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.831.1">The day of </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">the month</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.833.1">“3”: The third day of </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">the month</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">“Last”: The last day of </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">the month</span></span></p>
<p><span class="koboSpan" id="kobo.837.1">“-2”: Two days before the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">the month</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">“1st Tue”: The first Tuesday of </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">the month</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.841.1">“*”</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">dayOfWeek</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.843.1">The day of </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">the week</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.845.1">“3”: </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">Every Wednesday</span></span></p>
<p><span class="koboSpan" id="kobo.847.1">“Thu”: </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">Every Thursday</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.849.1">“*”</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">hour</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.851.1">Hour of the day (</span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">24-hour based)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.853.1">“14”: </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">2:00 p.m.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.855.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">0”</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">minute</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.858.1">Minute of </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">the hour</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.860.1">“10”: 10 minutes after </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">the hour</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.862.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">0”</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">month</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.865.1">Month of </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">the year</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.867.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">2”: February</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">March”: March</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.871.1">“*”</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">second</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.873.1">Second of </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">the minute</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.875.1">“5”: Five seconds after </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">the minute</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.877.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">0”</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">timezone</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.880.1">Time </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">zone ID</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.882.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">America/New York”</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.884.1">“”</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">year</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.886.1">Four-digit year</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.887.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">2010”</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.889.1">“*”</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.890.1">Table 12.3 – @Schedule annotation attributes</span></p>
<p><span class="koboSpan" id="kobo.891.1">In addition to single values, most attributes accept the asterisk (“*”) as a wildcard, meaning that the</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.892.1"> annotated method will be executed every unit of time (every day, </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">hour, etc.).</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">Additionally, we</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.895.1"> can specify more than one value by separating the values with commas. </span><span class="koboSpan" id="kobo.895.2">For example, if we needed a method to be executed every Tuesday and Thursday, we could annotate the method as </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">Schedule(dayOfWeek="Tue, Thu")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">We can also specify a range of values. </span><span class="koboSpan" id="kobo.899.2">The first value and last value are separated by a dash (-). </span><span class="koboSpan" id="kobo.899.3">To execute a method from Monday through Friday, we could </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">@Schedule(dayOfWeek="Mon-Fri")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">Additionally, we could specify that we need the method to be executed every </span><em class="italic"><span class="koboSpan" id="kobo.904.1">n</span></em><span class="koboSpan" id="kobo.905.1"> units of time (for example, every day, every 2 hours, or every 10 minutes). </span><span class="koboSpan" id="kobo.905.2">To do something like this, we could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">@Schedule(hour="*/12")</span></strong><span class="koboSpan" id="kobo.907.1">, which would execute the method every </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">12 hours.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">As we can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">@Schedule</span></strong><span class="koboSpan" id="kobo.911.1"> annotation provides a lot of flexibility regarding how to specify when we need our methods executed. </span><span class="koboSpan" id="kobo.911.2">Plus it provides the advantage of not needing a client call to activate the scheduling. </span><span class="koboSpan" id="kobo.911.3">Additionally, it also has the advantage of using cron-like syntax, therefore developers familiar with that Unix tool will feel right at home using </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">this annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">The final topic we will cover in this chapter is enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">bean security.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.915.1">Enterprise bean security</span></h1>
<p><span class="koboSpan" id="kobo.916.1">Enterprise beans allow </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.917.1">us to declaratively decide which users can access their methods. </span><span class="koboSpan" id="kobo.917.2">For example, some methods might only be available to users in certain roles. </span><span class="koboSpan" id="kobo.917.3">A typical scenario is that only users with the role of administrator can add, delete, or modify other users in </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">The following example is a slightly modified version of the DAO session bean we saw earlier in this chapter. </span><span class="koboSpan" id="kobo.919.2">In this version, some methods that were previously private have been made public. </span><span class="koboSpan" id="kobo.919.3">Additionally, the session bean has been modified to allow only users in certain roles to access </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">its methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.921.1">
package com.ensode.jakartaeebook;
//imports omitted for brevity
@Stateless
</span><strong class="bold"><span class="koboSpan" id="kobo.922.1">@RolesAllowed("admin")</span></strong><span class="koboSpan" id="kobo.923.1">
public class SecureCustomerDaoBean {
  @PersistenceContext
  private EntityManager entityManager;
  public Long saveCustomer(Customer customer) {
    if (customer.getCustomerId() == null) {
      entityManager.persist(customer);
    } else {
      entityManager.merge(customer);
    }
    return customer.getCustomerId();
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">@RolesAllowed({"user", "admin"})</span></strong><span class="koboSpan" id="kobo.925.1">
  public Customer getCustomer(Long customerId) {
    Customer customer;
    customer = entityManager.find(Customer.class,
      customerId);
    return customer;
  }
  public void deleteCustomer(Customer customer) {
    entityManager.remove(customer);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.926.1">As we can see, we declare what roles have access to the methods by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">@RolesAllowed</span></strong><span class="koboSpan" id="kobo.928.1"> annotation. </span><span class="koboSpan" id="kobo.928.2">This annotation can take either a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">String</span></strong><span class="koboSpan" id="kobo.930.1"> or an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">String</span></strong><span class="koboSpan" id="kobo.932.1"> as a parameter. </span><span class="koboSpan" id="kobo.932.2">When</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.933.1"> a single String is used as a parameter for this annotation, only users with the role specified by the parameter can access the method. </span><span class="koboSpan" id="kobo.933.2">If an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">String</span></strong><span class="koboSpan" id="kobo.935.1"> is used as a parameter, users with any of the roles specified by the array’s elements can access </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.937.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">@RolesAllowed</span></strong><span class="koboSpan" id="kobo.939.1"> annotation can be used at the class level, in which case its values apply to all the methods in the enterprise bean. </span><span class="koboSpan" id="kobo.939.2">It can also be used at the method level, in which case its values apply only to the method the annotation is decorating. </span><span class="koboSpan" id="kobo.939.3">If, like in our example, both the class and one or more of its methods are decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">@RolesAllowed</span></strong><span class="koboSpan" id="kobo.941.1"> annotation, the method-level annotation </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">takes precedence.</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">In our example, only users with the role of “admin” can save or update customer data, both admins and users can retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">customer data.</span></span></p>
<p><span class="koboSpan" id="kobo.945.1">Clients invoking secured enterprise beans must be authenticated (refer to </span><a href="B21231_10.xhtml#_idTextAnchor135"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.946.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.947.1">) and must have the </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">appropriate role.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.949.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.950.1">In this chapter, we covered how to implement business logic via stateless and stateful session beans. </span><span class="koboSpan" id="kobo.950.2">Additionally, we covered how to implement message-driven beans to consume Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">messaging messages.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">The following topics were covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.954.1">How to take advantage of the transactional nature of enterprise beans to simplify implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">DAO pattern</span></span></li>
<li><span class="koboSpan" id="kobo.956.1">Container-managed transactions and how to control transactions by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">appropriate annotations</span></span></li>
<li><span class="koboSpan" id="kobo.958.1">Bean-managed transactions, for cases in which container-managed transactions are not enough to satisfy </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">our requirements</span></span></li>
<li><span class="koboSpan" id="kobo.960.1">Life cycles for the different types of Enterprise Java beans, including an explanation of how to have enterprise bean methods automatically invoked by the Jakarta EE runtime at certain points in the </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">life cycle</span></span></li>
<li><span class="koboSpan" id="kobo.962.1">How to have enterprise bean methods invoked periodically by the runtime by taking advantage of the </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">timer service</span></span></li>
<li><span class="koboSpan" id="kobo.964.1">How to make sure enterprise bean methods are only invoked by authorized users by annotating enterprise bean classes and/or methods with the appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">security annotations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.966.1">As we have seen in this chapter, Jakarta Enterprise Beans take care of some enterprise requirements such as transactions and security, freeing us as application developers from having to implement them, and allowing us to focus on implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">business logic.</span></span></p>
</div>
</body></html>