<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;JSF Custom Components"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. JSF Custom Components</h1></div></div></div><p>JSF is a component-based framework, and JSF custom components are the major proof that sustain JSF flexibility and extensibility. In order to write custom components or extend the existing ones, JSF <a id="id1222" class="indexterm"/>provides a powerful API that allows us to develop two types of components: <span class="strong"><strong>custom components,</strong></span> and, from JSF 2.0 onwards, <span class="strong"><strong>composite components</strong></span>. A custom component implementation is responsible<a id="id1223" class="indexterm"/> for providing an <span class="strong"><strong>aspect</strong></span> (optional for non-UI components, such as custom validators, converters, and renderers) and a <span class="strong"><strong>behavior</strong></span>. Usually the decision to write custom components and the skills for accomplishing it belong to advanced JSF developers.</p><p>Before you decide to write a custom component, which can be a time-consuming task, you have to overview the following bullets (especially the first bullet):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the Internet (for example, <a class="ulink" href="http://jsfcentral.com/">http://jsfcentral.com/</a>) to make sure the component doesn't exist yet. Many JSF extensions, such as PrimeFaces, ICEfaces, OmniFaces, and RichFaces, already come with hundreds of custom components.</li><li class="listitem" style="list-style-type: disc">Make sure that you need a custom component and not just a Facelet template (see <a class="link" href="ch12.html" title="Chapter 12. Facelets Templating">Chapter 12</a>, <span class="emphasis"><em>Facelets Templating</em></span>) or some custom logic over the existing components.</li><li class="listitem" style="list-style-type: disc">Try to redesign the application goals to use the existing components (sometimes you can combine several existing components to obtain the desired aspect and behavior).</li><li class="listitem" style="list-style-type: disc">Take a closer look at non-JSF components, such as jQueryUI, ComponentJS, and AmplifyJS (as you are not forced to solely use JSF components in your JSF applications!).</li></ul></div><p>If your application has some specific goals that just cannot be solved by any of the preceding bullets, it is time to start coding your own components.</p><p>In the first part of this chapter, you will see how to write noncomposite custom components, and in the second part you will learn about composite components. The noncomposite components have been available for a long time in JSF, and the technique of writing such components is based on writing several Java classes. The new concept, which came along with composite components, is available from JSF 2 onwards, and the idea behind it is to replace the Java classes with XHTML pages.</p><div class="section" title="Building noncomposite custom components"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Building noncomposite custom components</h1></div></div></div><p>Let's jump directly<a id="id1224" class="indexterm"/> to the cool stuff and say that in JSF 2.0 a custom component was made available to page authors by configuring it in a Facelet tag library (<code class="literal">*taglib.xml</code>).</p><p>Moreover, when the component is mapped in a JAR, a special entry in <code class="literal">web.xml</code> is needed to point to the <code class="literal">*taglib.xml</code> file. See the application named <code class="literal">ch10_3</code>.</p><p>As of JSF 2.2, we don't need these files anymore. A JSF 2.2 simple custom component contains a single class, and it may look like the following code:</p><div class="informalexample"><pre class="programlisting">@FacesComponent(value = "components.WelcomeComponent", createTag = true)
public class WelcomeComponent extends UIComponentBase {

    @Override
    public String getFamily() {
        return "welcome.component";
    }

    @Override
    public void encodeBegin(FacesContext context) throws IOException {

        String value = (String) getAttributes().get("value");
        String to = (String) getAttributes().get("to");

        if ((value != null) &amp;&amp; (to != null)) {
            ResponseWriter writer = context.getResponseWriter();
            writer.writeAttribute("id", getClientId(context), null);
            writer.write(value + ", " + to);
        }
    }
}</pre></div><p>Most of the hard work is accomplished by the <code class="literal">@FacesComponent</code> annotation (<code class="literal">javax.faces.component.FacesComponent</code>). All we need to do is set the <code class="literal">createTag</code> element to <code class="literal">true</code>, and JSF should create the tag for us. Further, we can easily exploit our custom components, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
<span class="strong"><strong>      &gt;</strong></span>
    &lt;h:head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;       
<span class="strong"><strong>        &lt;t:welcomeComponent value="Welcome" to="Rafael Nadal"/&gt;</strong></span>
    &lt;/h:body&gt;
&lt;/html&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note170"/>Note</h3><p>Notice that the default namespace of the component is <code class="literal">http://xmlns.jcp.org/jsf/component</code>. This is true for all components that don't have an explicit namespace.</p></div></div><p>The complete application is named <code class="literal">ch10_1</code>.</p><p>The entire<a id="id1225" class="indexterm"/> list of elements supported by JSF 2.2 <code class="literal">@FacesComponent</code> is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">createTag</code>: This can<a id="id1226" class="indexterm"/> be set to <code class="literal">true</code> or <code class="literal">false</code>. When<a id="id1227" class="indexterm"/> it is set to <code class="literal">true</code>, JSF will generate the tag for us (to be more specific, JSF will create, at runtime, a Facelet tag handler that extends <code class="literal">ComponentHandler</code>). This element can be used only in JSF 2.2.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tagName</code>: This allows us<a id="id1228" class="indexterm"/> to indicate the tag name. When <code class="literal">createTag</code> is set to <code class="literal">true</code>, JSF will use this name for<a id="id1229" class="indexterm"/> the generated tag. This element can only be used in JSF 2.2.</li><li class="listitem" style="list-style-type: disc"><code class="literal">namespace</code>: This allows us to indicate the tag namespace. When <code class="literal">createTag</code> is set to <code class="literal">true</code>, JSF will use this namespace<a id="id1230" class="indexterm"/> for<a id="id1231" class="indexterm"/> the generated tag. When namespace is not specified, JSF will use the <code class="literal">http://xmlns.jcp.org/jsf/component</code> namespace. This element can be used only in JSF 2.2.</li><li class="listitem" style="list-style-type: disc"><code class="literal">value</code>: This element comes<a id="id1232" class="indexterm"/> from JSF 2.0 and<a id="id1233" class="indexterm"/> indicates the <span class="strong"><strong>component type</strong></span>. The<a id="id1234" class="indexterm"/> component type can be used as the argument of the <code class="literal">Application.createComponent(java.lang.String)</code> method for creating instances of the <code class="literal">Component</code> class. As of JSF 2.2, if the <code class="literal">value</code> element is missing or is <code class="literal">null</code>, JSF will obtain it by calling the <code class="literal">getSimpleName</code> method on the class to which <code class="literal">@FacesComponent</code> is attached and<a id="id1235" class="indexterm"/> lowercasing the first character.</li></ul></div><p>By the component type, we understand a small chunk of data, specific to each <code class="literal">UIComponent</code> subclass, that can be used in conjunction with an <code class="literal">Application</code> instance to programmatically obtain new instances of those subclasses. Moreover, each <code class="literal">UIComponent</code> subclass belongs to a component family (for example <code class="literal">javax.faces.Input</code>). This is important when we write a custom component and declare it under a certain family, because we can exploit the renderer specific to that family of components. Next to the component family, we can use the <span class="strong"><strong>renderer type</strong></span> property<a id="id1236" class="indexterm"/> to select a <code class="literal">Renderer</code> instance from a <code class="literal">RenderKit</code> collection (for example, an input field belongs to the <code class="literal">javax.faces.Input</code> family and to the <code class="literal">javax.faces.Text</code> renderer type).</p><p>Each custom component must extend <code class="literal">UIComponent</code> or one of its subtypes, such as <code class="literal">UIComponentBase</code>, which is actually just a default implementation of all abstract methods of <code class="literal">UIComponent</code>. Anyway, there is one exception represented by the <code class="literal">getFamily</code> method that must be overridden even when you extend <code class="literal">UIComponentBase</code>. As a common <a id="id1237" class="indexterm"/>practice, when a custom component needs to accept end user inputs, it will extend <code class="literal">UIInput</code>, and when it needs to act as a command, it will extend <code class="literal">UICommand</code>.</p><p>Further, let's modify our application as follows to indicate a custom namespace and tag name:</p><div class="informalexample"><pre class="programlisting">@FacesComponent(value = "components.WelcomeComponent", createTag = true, namespace = "http://atp.welcome.org/welcome", tagName = "welcome")
public class WelcomeComponent extends UIComponentBase {
...
}</pre></div><p>Next, the component will be used as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html 
      
      &gt;
...
  &lt;t:welcome value="Welcome" to="Rafael Nadal"/&gt;</pre></div><p>The complete application is named <code class="literal">ch10_2</code>. Moreover, the JSF 2.0 version of this application (containing the <code class="literal">*taglib.xml</code> descriptor and the specific entry in <code class="literal">web.xml</code>) is named <code class="literal">ch10_3</code>.</p><div class="section" title="Writing a custom tag handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Writing a custom tag handler</h2></div></div></div><p>Notice that <code class="literal">*taglib.xml</code> is<a id="id1238" class="indexterm"/> still needed in some cases. For example, if you decide to write a custom tag handler for your component, then<a id="id1239" class="indexterm"/> you still need this file to configure the handler class. In this rare case, you will extend the <code class="literal">ComponentHandler</code> class<a id="id1240" class="indexterm"/> and override the desired methods. Most developers exploit the <code class="literal">onComponentCreated</code> and <code class="literal">onComponentPopulated</code> methods. The first one is called after the component has been created but before it has been populated with children, and the second one is called after the component has been populated with children. As of JSF 2.2, a new method was added for developers who wish to take<a id="id1241" class="indexterm"/> over the task of instantiating the <code class="literal">UIComponent</code>. This<a id="id1242" class="indexterm"/> method is named <code class="literal">createComponent</code>. If it returns <code class="literal">null</code>, then this method<a id="id1243" class="indexterm"/> will be required to create the component by <code class="literal">TagHandlerDelegate</code> instead. Since this is a pretty rare case, we do not insist on it, and we just provide a simple stub of <code class="literal">ComponentHandler</code>:</p><div class="informalexample"><pre class="programlisting">public class WelcomeComponentHandler extends ComponentHandler {

 private static final Logger logger = 
         Logger.getLogger(WelcomeComponentHandler.class.getName());

 public WelcomeComponentHandler(ComponentConfig config) {
  super(config);
 }

 @Override
 public UIComponent createComponent(FaceletContext ctx) {
  logger.info("Inside 'createComponent' method");
  return null;
 }

 @Override
 public void onComponentCreated(FaceletContext ctx, 
             UIComponent c, UIComponent parent) {
  logger.info("Inside 'onComponentCreated' method");
  super.onComponentCreated(ctx, c, parent);
 }

 @Override
 public void onComponentPopulated(FaceletContext ctx, 
             UIComponent c, UIComponent parent) {
  logger.info("Inside 'onComponentPopulated' method");
  super.onComponentPopulated(ctx, c, parent);
 }
}</pre></div><p>In order to indicate that our class handler should be used, we need to configure it in the <code class="literal">*taglib.xml</code> file, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;handler-class&gt;book.beans.WelcomeComponentHandler&lt;/handler-class&gt;</pre></div><p>The complete example is named <code class="literal">ch10_24_1</code>. Another stub that can be used as a starting point can be found in <code class="literal">ch10_24_2</code>. The latter one defines<a id="id1244" class="indexterm"/> the minimum implementation for a custom <code class="literal">ComponentHandler</code>, a <a id="id1245" class="indexterm"/>custom <code class="literal">TagHandlerDelegateFactory</code>, and a custom <code class="literal">TagHandlerDelegate</code>.</p></div><div class="section" title="Dissecting a custom component"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec110"/>Dissecting a custom component</h2></div></div></div><p>So far you can see that our component class overrides the<a id="id1246" class="indexterm"/> <code class="literal">encodeBegin</code> method. This method belongs to a<a id="id1247" class="indexterm"/> set of four methods used for <a id="id1248" class="indexterm"/>rendering a component where each component can render itself (the <code class="literal">setRendererType</code> method gets a <code class="literal">null</code> value for its argument) or delegate the rendering process to a <code class="literal">Renderer</code> class (built-in or user defined). These methods are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">decode</code>: In order to parse the input values and save them into the component, each request passes through the <a id="id1249" class="indexterm"/><code class="literal">decode</code> method. Usually, when this method is overridden, the developer extracts the needed values from the request map (or from the <code class="literal">Map</code> attributes using the <code class="literal">UIComponent.getAttributes</code> method) and sets them into the component by calling the <code class="literal">setSubmittedValue(</code><span class="emphasis"><em>value</em></span><code class="literal">)</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">encodeBegin</code>: This <a id="id1250" class="indexterm"/>method starts the rendering process of the custom component. It writes to the response stream obtained through the <code class="literal">FacesContext.getResponseWriter</code> method. This method is overridden when we need to encode child components, but we want to output a response to the user before that.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note171"/>Note</h3><p>The <a id="id1251" class="indexterm"/>
<code class="literal">ResponseWriter</code> object (<code class="literal">FacesContext.getResponseWriter</code>) contains special methods for generating a markup, such as <code class="literal">startElement</code>, <code class="literal">writeAttribute</code>, <code class="literal">writeText</code>, and <code class="literal">endElement</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">encodeChildren</code>: This method renders the custom component children. It is very rarely<a id="id1252" class="indexterm"/> overridden; however, if you want to alter the default recursive process of encoding component children, then go ahead and override it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">encodeEnd</code>: Probably<a id="id1253" class="indexterm"/> this is the most overridden method. As its name suggests, this method is called at the end. Here, we write the custom markup to the response stream. When the custom component accepts end user inputs, the <code class="literal">encodeEnd</code> is preferred against <code class="literal">encodeBegin</code> because<a id="id1254" class="indexterm"/> in the case of <code class="literal">encodeBegin</code>, the inputs may not be passed yet through a potential attached converter.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note172"/>Note</h3><p>The four methods we just discussed are available for all custom components and for all renderers. In both cases, they have the same name, and the difference between them consists of one argument. When they are overridden in a custom component class, they get a single argument representing <code class="literal">FacesContext</code>. On the other hand, when they are overridden in a custom renderer, they get as arguments the <code class="literal">FacesContext</code> instance and the corresponding custom component (<code class="literal">UIComponent</code>).</p></div></div><p>So we are at a point where we can conclude that a custom component is based on a subclass of <code class="literal">UIComponent</code> and it can render itself or delegate this task to a <code class="literal">Renderer</code> class, which is capable of rendering <code class="literal">UIComponent</code> instances and decoding the POST requests for obtaining user inputs.</p><p>An important aspect<a id="id1255" class="indexterm"/> of custom components <a id="id1256" class="indexterm"/>involves managing their state. You should already be familiar with the concept of states from <a class="link" href="ch09.html" title="Chapter 9. JSF State Management">Chapter 9</a>, <span class="emphasis"><em>JSF State Management</em></span>. For this reason, we can say that JSF 2.0 comes with the <code class="literal">StateHelper</code> interface, which basically allows us to store, read, and remove data across multiple requests (postbacks). This means we can use it to preserve states of the components.</p><p>It can be a little tricky to understand how to use the <code class="literal">StateHelper</code> methods in conjunction with custom components, but a common example can be useful to clear things up. Let's consider the following custom component usage:</p><div class="informalexample"><pre class="programlisting">&lt;t:temperature unitto="Celsius" temp="100" /&gt;</pre></div><p>In the custom component class, we can easily map these attribute names and default values, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// Attribute name constant for unitto
private static final String ATTR_UNITTO = "unitto";
// Default value for the unitto attribute
private static final String ATTR_UNITTO_DEFAULT = "Fahrenheit";
// Attribute name constant for temp
private static final String ATTR_TEMP = "temp";
// Default value for the temp attribute
private static final Float ATTR_TEMP_DEFAULT = 0f;</pre></div><p>Next, we want to preserve the value of <code class="literal">unitto</code> under the constant <code class="literal">ATTR_UNITTO</code> (for <code class="literal">temp</code> it is exactly the same). For this, we <a id="id1257" class="indexterm"/>use the <code class="literal">StateHelper.put</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void setUnitto(String unitto) {
 getStateHelper().put(ATTR_UNITTO, unitto);
}</pre></div><p>These examples use the <code class="literal">Object put(Serializable key, Object value)</code> method, but <code class="literal">StateHelper</code> also has a method <code class="literal">Object put(Serializable key, String mapKey, Object value)</code>, which can be used to store values that would otherwise be stored in a <code class="literal">Map</code> instance variable. Moreover, <code class="literal">StateHelper</code> has a method named <code class="literal">void add(Serializable key, Object value)</code> <a id="id1258" class="indexterm"/>that can be used to preserve values which would otherwise be stored in a <code class="literal">List</code> instance variable.</p><p>Next, you can retrieve the<a id="id1259" class="indexterm"/> value stored under the <code class="literal">ATTR_UNITTO</code> constant, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public String getUnitto() {
 return (String) getStateHelper().eval(ATTR_UNITTO, ATTR_UNITTO_DEFAULT);
}</pre></div><p>The <code class="literal">Object eval(Serializable key, Object defaultValue)</code> method will search for the <code class="literal">ATTR_UNITTO</code> constant. If it can't find it, then the default value (<code class="literal">ATTR_UNITTO_DEFAULT</code>) is returned. This is a very useful approach because it spears us to perform <code class="literal">null</code> value checks. Besides this method, <code class="literal">StateHelper</code> also has the <code class="literal">Object eval(Serializable key)</code> and <code class="literal">Object get(Serializable key)</code> methods.</p><p>In order to remove an entry from <code class="literal">StateHelper</code>, we can call <code class="literal">Object remove(Serializable key)</code> or <code class="literal">Object remove(Serializable key, Object valueOrKey)</code>.</p><p>At this<a id="id1260" class="indexterm"/> moment, we have plenty of information that can be translated into code, so let's write a <a id="id1261" class="indexterm"/>custom component to exemplify the above knowledge. Let's name it the Temperature custom component. Basically, the next custom component will expose a public web service as a JSF component. The web service is capable of converting the temperature from Celsius to Fahrenheit and vice versa for which we need to pass the temperature value and the conversion unit as arguments. Based on these two arguments, we can intuit that the corresponding JSF tag will look like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;t:temperature unitto="celsius/fahrenheit" temp="<span class="emphasis"><em>number_of_degrees</em></span>" /&gt;</pre></div><p>We can start by implementing a helper<a id="id1262" class="indexterm"/> class to deal with the web service underlying the communication tasks. The name of this class is <code class="literal">TempConvertClient</code>, and it can be seen in the complete application named <code class="literal">ch10_4</code>. It's relevant part is the<a id="id1263" class="indexterm"/> declaration of the following method:</p><div class="informalexample"><pre class="programlisting">public String callTempConvertService(String unitto, Float temp) {
...
}</pre></div><div class="section" title="Custom component implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec06"/>Custom component implementation</h3></div></div></div><p>Now we can focus on<a id="id1264" class="indexterm"/> the important part for us, the custom component implementation. For this we can follow the ensuing steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a class annotated with <code class="literal">@FacesComponent</code>.</li><li class="listitem">Use <code class="literal">StateHelper</code> to preserve the component's attribute values over multiple requests.</li><li class="listitem">Call the <code class="literal">callTempConvertService</code> method.</li><li class="listitem">Render the result.</li></ol></div><p>The first three steps can be coded as follows:</p><div class="informalexample"><pre class="programlisting">@FacesComponent(value = TempConvertComponent.COMPONENT_TYPE, createTag = true, namespace = "http://temp.converter/", tagName = "temperature")
public class TempConvertComponent extends UIComponentBase {

 public TempConvertComponent() {
  setRendererType(TempConvertRenderer.RENDERER_TYPE);
 }

 public static final String COMPONENT_FAMILY = 
                            "components.TempConvertComponent";
 public static final String COMPONENT_TYPE = 
                            "book.beans.TempConvertComponent";
 private static final String ATTR_UNITTO = "unitto";
 private static final String ATTR_UNITTO_DEFAULT = "fahrenheit";
 private static final String ATTR_TEMP = "temp";
 private static final Float ATTR_TEMP_DEFAULT = 0f;
 public String getUnitto() {
  return (String) getStateHelper().
          eval(ATTR_UNITTO, ATTR_UNITTO_DEFAULT);
 }

 public void setUnitto(String unitto) {
  getStateHelper().put(ATTR_UNITTO, unitto);
 }

 public Float getTemp() {
  return (Float) getStateHelper().eval(ATTR_TEMP, ATTR_TEMP_DEFAULT);
 }

 public void setTemp(Float temp) {
  getStateHelper().put(ATTR_TEMP, temp);
 }

 public String getTempConvert() {
  TempConvertClient tempConvertClient = new TempConvertClient();
  return String.format("%.1f", Float.valueOf(tempConvertClient.
               callTempConvertService(getUnitto(), getTemp())));
 }

 @Override
 public String getFamily() {
  return TempConvertComponent.COMPONENT_FAMILY;
 }
}</pre></div><p>For step number four there is a hint in the preceding code. If you look carefully at the class constructor, you<a id="id1265" class="indexterm"/> can see that the rendering tasks are delegated to an external class (renderer). This class will render a simple styled HTML <code class="literal">div</code> containing the web service response as follows:</p><div class="informalexample"><pre class="programlisting">@ResourceDependencies({
 @ResourceDependency(name="css/temp.css",library="default",target="head")
})
@FacesRenderer(componentFamily = TempConvertComponent.COMPONENT_FAMILY, rendererType = TempConvertRenderer.RENDERER_TYPE)
public class TempConvertRenderer extends Renderer {

public static final String RENDERER_TYPE = 
                "book.beans.TempConvertRenderer";

public TempConvertRenderer() {
}

@Override
public void encodeEnd(FacesContext context, UIComponent uicomponent) 
                                                 throws IOException {

 ResponseWriter responseWriter = context.getResponseWriter();
 TempConvertComponent component = (TempConvertComponent) uicomponent;

 String unit = component.getUnitto();

 responseWriter.startElement("div", component);
 responseWriter.writeAttribute("class", "tempClass", null);
 responseWriter.writeAttribute("id", component.getClientId(), "id");
 responseWriter.write("&amp;deg;");
 if (unit.equals("fahrenheit")) {
     responseWriter.write("F ");
 } else {
     responseWriter.write("C ");
 }
 responseWriter.write(component.getTempConvert());
 responseWriter.endElement("div");
 }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note173"/>Note</h3><p>The <code class="literal">@ResourceDependency</code> and <code class="literal">@ResourceDependencies</code> annotations are used for linked external resources (for example, JavaScript, and CSS) in custom components and renderers.</p></div></div><p>In order to register this<a id="id1266" class="indexterm"/> class as a <code class="literal">Renderer</code> class, you need to annotate it with <code class="literal">@FacesRenderer</code> or configure it in <code class="literal">faces-config.xml</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
 &lt;render-kit&gt;
  &lt;renderer&gt;                    
   &lt;component-family&gt;
    components.TempConvertComponent
   &lt;/component-family&gt;
   &lt;renderer-type&gt;book.beans.TempConvertRenderer&lt;/renderer-type&gt;
   &lt;renderer-class&gt;book.beans.TempConvertRenderer&lt;/renderer-class&gt;
  &lt;/renderer&gt;
 &lt;/render-kit&gt;
&lt;/application&gt;</pre></div><p>Another important characteristic of a <code class="literal">Renderer</code> class<a id="id1267" class="indexterm"/> consists of the fact that it must define a public zero-argument constructor.</p><p>Notice that the <code class="literal">&lt;renderer-type&gt;</code> tag corresponds to the <code class="literal">renderedType</code> element and the <code class="literal">&lt;component-family&gt;</code> tag corresponds to the <code class="literal">componentFamily</code> element. Moreover, the value of <code class="literal">componentFamily</code> is<a id="id1268" class="indexterm"/> the same as the value returned by the component's <code class="literal">getFamily</code> method. A <code class="literal">RenderKit</code> can provide a <code class="literal">Renderer</code> instance based on this information.</p><p>Of course, in this example you can implement the rendering process in the custom component class also, since there is no real justification for writing a separate class. Usually, you will want to write a separate renderer class when you need to support multiple client devices and you need special renderers to be registered through a <code class="literal">RenderKit</code> collection.</p><p>The following is an example of code that uses our custom component (the code is self explanatory):</p><div class="informalexample"><pre class="programlisting">&lt;html 
      
<span class="strong"><strong>      </strong></span>
      &gt;
...
  &lt;h:form&gt;
   Convert to:
   &lt;h:selectOneMenu value="#{tempBean.unitto}"&gt;
    &lt;f:selectItem itemValue="fahrenheit" itemLabel="fahrenheit" /&gt;
    &lt;f:selectItem itemValue="celsius" itemLabel="celsius" /&gt;
   &lt;/h:selectOneMenu&gt;
   Insert value:
   &lt;h:inputText value="#{tempBean.temp}"/&gt;
   &lt;h:commandButton value="Convert"&gt;
    &lt;f:ajax execute="@form" render=":tempId" /&gt;
   &lt;/h:commandButton&gt;
  &lt;/h:form&gt;     

<span class="strong"><strong>  &lt;t:temperature id="tempId" </strong></span>
<span class="strong"><strong>                unitto="#{tempBean.unitto}" temp="#{tempBean.temp}" /&gt;</strong></span>
</pre></div><p>Alternatively, we can<a id="id1269" class="indexterm"/> provide the conversion unit and temperature as constants (if one, or both attributes are missing, then the default value(s) will be used):</p><div class="informalexample"><pre class="programlisting">  &lt;t:temperature id="tempId" unitto="celsius" temp="10" /&gt;</pre></div><p>The <code class="literal">TempBean</code> is just a simple backing bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@SessionScoped
public class TempBean implements Serializable {
    
 private String unitto = "fahrenheit";
 private Float temp = 0f;
 ...
 //getters and setters
}</pre></div><p>The complete application is in the code bundle of this chapter under the name <code class="literal">ch10_4</code>. In the following screenshot, you can see the result of running this application:</p><div class="mediaobject"><img src="graphics/6466EN_10_01.jpg" alt="Custom component implementation"/></div><p>So, our custom component just renders a <code class="literal">div</code> block containing the result of the temperature conversion. Further, we want to write a custom component that, besides this <code class="literal">div</code>, will render the user interface for collecting data (conversion unit and temperature) and submit it through AJAX. In other words, the content of the preceding form will be a part of the custom component.</p><p>This time we<a id="id1270" class="indexterm"/> need to deal with user inputs directly into the custom component, which means that our custom component can extend <code class="literal">UIInput</code> instead of <code class="literal">UIComponentBase</code>. This major change will bring us the advantages of an <code class="literal">UIInput</code> component. We can submit the custom component value (using the <code class="literal">setSubmittedValue</code> method during the decoding process) and obtain the resultant value (using the <code class="literal">getValue</code> method during the encoding (rendering) process).</p><p>The big problem is that our custom component value is made up of two values: the conversion unit and the temperature value. There are a few workarounds to solve this kind of issue. In this case, we can simply concatenate these values into one, such as the one shown in the following example (<span class="emphasis"><em>conversion_unit</em></span><code class="literal">/</code><span class="emphasis"><em>temperature</em></span>):</p><div class="informalexample"><pre class="programlisting">&lt;t:temperature value="celsius/1" /&gt;</pre></div><p>Now we can write the custom component class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@FacesComponent(createTag = true, namespace = "http://temp.converter/", tagName = "temperature")
public class TempConvertComponent extends UIInput 
                           implements NamingContainer {

 public TempConvertComponent() {
  setRendererType(TempConvertRenderer.RENDERER_TYPE);
 }    

 public String getTempConvert(String unitto, float temp) {
  TempConvertClient tempConvertClient = new TempConvertClient();
  return String.format("%.1f", 
   tempConvertClient.callTempConvertService(unitto, temp));
  }
}</pre></div><p>Notice that we don't need to specify the component family anymore and the <code class="literal">getFamily</code> method is inherited from the <code class="literal">UIInput</code> class. Going further, we need to write the renderer class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>If you want to allow the component to render itself, use <code class="literal">setRendererType(null)</code> and override the corresponding methods in the component class.</p></div></div><p>We need to render<a id="id1271" class="indexterm"/> four HTML tags (the drop-down list, the input field, the button for submit, and the result <code class="literal">div</code>). For this, we can override the <code class="literal">encodeEnd</code> method, as<a id="id1272" class="indexterm"/> shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void encodeEnd(FacesContext context, UIComponent uicomponent) 
                                                    throws IOException {

 TempConvertComponent component = (TempConvertComponent) uicomponent;

 String clientId = component.getClientId(context);
 char separator = UINamingContainer.getSeparatorChar(context);
 encodeSelectOneMenu(context, 
                   component, clientId + separator + "selectonemenu");
 encodeInput(context, component, clientId + separator + "inputfield");
 encodeButton(context, component, clientId + separator + "button");
 encodeResult(context, component, clientId + separator + "div");
 }</pre></div><p>The identifier of each component was obtained from the client ID of the main component (using the <code class="literal">getClientId</code> method) concatenated with the char naming container separator and a string hinting the component type.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note174"/>Note</h3><p>In this example, the <code class="literal">NamingContainer</code> interface (implemented by <code class="literal">UINamingContainer</code>) is queried for obtaining the separator used to separate segments of client ID, but its main purpose is to ensure the uniqueness of the components declared within it.</p></div></div><p>Next, the method that renders the drop-down component is as follows:</p><div class="informalexample"><pre class="programlisting">private void encodeSelectOneMenu(FacesContext context, TempConvertComponent component, String clientId) throws IOException {

 String cv = String.valueOf(component.getValue());
 String unitto = cv.substring(0, cv.indexOf("/"));

 ResponseWriter responseWriter = context.getResponseWriter();
 responseWriter.startElement("span", component);
 responseWriter.write("Convert to:");
 responseWriter.endElement("span");
 responseWriter.startElement("select", component);
 responseWriter.writeAttribute("name", clientId, "clientId");
 responseWriter.writeAttribute("size", 1, "size");
 responseWriter.startElement("option", component);
 responseWriter.writeAttribute("value", "fahrenheit", "value");
 if (unitto.equals("fahrenheit")) {
     responseWriter.writeAttribute("selected", "selected", "selected");
    }
 responseWriter.writeText("fahrenheit", "fahrenheit");
 responseWriter.endElement("option");
 responseWriter.startElement("option", component);
 responseWriter.writeAttribute("value", "celsius", "value");
 if (unitto.equals("celsius")) {
     responseWriter.writeAttribute("selected", "selected", "selected");
 }
 responseWriter.writeText("celsius", "celsius");
 responseWriter.endElement("option");
 responseWriter.endElement("select");
}</pre></div><p>The first two lines <a id="id1273" class="indexterm"/>of this code are important where we extract the conversion unit part from the component value, and select the corresponding item in the drop-down component.</p><p>Next, we render the input field, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private void encodeInput(FacesContext context, TempConvertComponent component, String clientId) throws IOException {

 String cv = String.valueOf(component.getValue());
 String temp = cv.substring(cv.indexOf("/") + 1);

 ResponseWriter responseWriter = context.getResponseWriter();
 responseWriter.startElement("span", component);
 responseWriter.write("Insert value:");
 responseWriter.endElement("span");
 responseWriter.startElement("input", component);
 responseWriter.writeAttribute("name", clientId, "clientId");
 responseWriter.writeAttribute("value", temp, "value");
 responseWriter.writeAttribute("type", "text", "type");
 responseWriter.endElement("input");
}</pre></div><p>Now we will extract the temperature value from the component value. To accomplish this, we render the button labeled <span class="strong"><strong>Convert</strong></span>, which is responsible to submit the user input via AJAX as follows:</p><div class="informalexample"><pre class="programlisting">private void encodeButton(FacesContext context, TempConvertComponent component, String clientId) throws IOException {

 ResponseWriter responseWriter = context.getResponseWriter();
 responseWriter.startElement("input", component);
 responseWriter.writeAttribute("type", "Submit", null);
 responseWriter.writeAttribute("name", clientId, "clientId");
 responseWriter.writeAttribute("value", "Convert", null);
 responseWriter.writeAttribute("onclick",
   "jsf.ajax.request(this,event,{execute:'" + "@form" + "',"
 + "render:'" + "@form" + "'," + "});"
 + "return false;", null);
 responseWriter.endElement("input");
}</pre></div><p>After the user inputs<a id="id1274" class="indexterm"/> are submitted, we need to render the result obtained from the web service:</p><div class="informalexample"><pre class="programlisting">private void encodeResult(FacesContext context, TempConvertComponent component, String clientId) throws IOException {
        
 String cv = String.valueOf(component.getValue());
 String unitto = cv.substring(0, cv.indexOf("/"));
 String temp = cv.substring(cv.indexOf("/") + 1);
 String result = component.getTempConvert(unitto, Float.valueOf(temp));

 ResponseWriter responseWriter = context.getResponseWriter();
 responseWriter.startElement("div", component);
 responseWriter.writeAttribute("class", "tempClass", null);
 responseWriter.writeAttribute("name", clientId, "clientId");
 responseWriter.write("&amp;deg;");
 if (unitto.equals("fahrenheit")) {
     responseWriter.write("F ");
 } else {
     responseWriter.write("C ");
 }
 responseWriter.write(result);
 responseWriter.endElement("div");
}</pre></div><p>The backing bean, <code class="literal">TempBean</code>, is pretty simple, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@SessionScoped
public class TempBean implements Serializable {
    
 private String value = "celsius/0";

 public String getValue() {
  return value;
 }

 public void setValue(String value) {
  this.value = value;
 }              
}</pre></div><p>The final step involves<a id="id1275" class="indexterm"/> decoding the user input and submitting it to the component, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void decode(FacesContext context, UIComponent uicomponent) {

 TempConvertComponent component = (TempConvertComponent) uicomponent;
 Map requestMap = context.getExternalContext().getRequestParameterMap();
 String clientId = component.getClientId(context);
 char separator = UINamingContainer.getSeparatorChar(context);
 String temp = ((String) 
                requestMap.get(clientId+ separator + "inputfield"));
 String unitto = ((String) 
                requestMap.get(clientId + separator + "selectonemenu"));       
 component.setSubmittedValue(unitto+"/"+temp);       
}</pre></div><p>Done! Now you can see both the tests, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Specified unit and temperature from bean:
&lt;h:form id="tempForm1"&gt;            
 &lt;t:temperature id="temp1" value="#{tempBean.value}" /&gt; 
 &lt;h:message for="temp1"/&gt;
&lt;/h:form&gt;   
&lt;hr/&gt;
Specified unit and temperature as constants:
&lt;h:form id="tempForm2"&gt;           
 &lt;t:temperature id="temp2" value="celsius/1" /&gt; 
 &lt;h:message for="temp2"/&gt;
&lt;/h:form&gt;</pre></div><p>The complete<a id="id1276" class="indexterm"/> application is present in the code bundle of this chapter under the name <code class="literal">ch10_5</code>.</p></div></div></div></div>
<div class="section" title="Building composite components"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Building composite components</h1></div></div></div><p>Maybe the idea behind composite components originates from the fact that JSF page authors and JSF <a id="id1277" class="indexterm"/>component authors have different perspectives regarding components. While JSF page authors perceive components as tags that can be used in XHTML pages, JSF component authors see components as a mixture of <code class="literal">UIComponent</code>, <code class="literal">UIComponentBase</code>, <code class="literal">NamingContainer</code>, <code class="literal">Renderer</code>, <code class="literal">Validator</code>, and <code class="literal">Converter</code> elements—these are elements that shape up a JSF component. Based on this, it seems that custom components can be written only by JSF component authors, since they have knowledge about these JSF elements and Java language. This fact, however, has begun to change as of JSF 2 and composite components, which are practically custom components written in XHTML pages using markup tags. This means that JSF page authors can start writing their components without having the same level of knowledge and skills as dedicated JSF component authors—at least, simple, composite components.</p><p>For example, the skeleton of a JSF 2.2 composite component looks as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;

 &lt;!-- INTERFACE --&gt;
 &lt;cc:interface&gt;
 &lt;/cc:interface&gt;

 &lt;!-- IMPLEMENTATION --&gt;
 &lt;cc:implementation&gt;
 &lt;/cc:implementation&gt;
&lt;/html&gt;</pre></div><p>The structure is pretty simple! As you can see, there are two main tags that belong to the <code class="literal">http://xmlns.jcp.org/jsf/composite</code> library. The first tag demarcates the interface section and represents the component use contract. Here, we can define the component's attributes that may be changed by the end user (in principle, anything that can be used by the page author). The <a id="id1278" class="indexterm"/>second tag marks the implementation section, which contains the component itself. This will be rendered to the end user. Moreover, in this section, we define the component behavior based on the attributes defined in the interface section (the use contract implementation).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note175"/>Note</h3><p>Composite components are basically XHTML pages stored in libraries under the <code class="literal">resources</code> folder (placed as a top-level folder under the web application root or under the <code class="literal">META-INF</code> folder in JARs). Remember that a library is just a subfolder of the <code class="literal">resources</code> folder. Based on this, a composite component path is of type <code class="literal">http://xmlns.jcp.org/jsf/composite/</code><span class="emphasis"><em>library_name</em></span>.</p></div></div><p>So, let's have a quick test. Remember that the first custom component developed in this chapter, <code class="literal">WelcomeComponent</code>, was built from a class annotated with <code class="literal">@FacesComponent</code>. In that class, we have overridden the <code class="literal">encodeBegin</code> method for rendering the component. Well, now let's see the same component, but this time as a composite component. We store this page under <code class="literal">resources/customs/welcome.xhtml</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;

 &lt;!-- INTERFACE --&gt;
 &lt;cc:interface&gt;
  &lt;cc:attribute name="value"/&gt;
  &lt;cc:attribute name="to"/&gt;
 &lt;/cc:interface&gt;

 &lt;!-- IMPLEMENTATION --&gt;
 &lt;cc:implementation&gt;
  &lt;p&gt;#{cc.attrs.value}, #{cc.attrs.to}&lt;/p&gt;
 &lt;/cc:implementation&gt;
&lt;/html&gt;</pre></div><p>It is very simple to make the analogy between the custom component and the composite version of it. The important thing here is to notice how attributes were declared using the <code class="literal">&lt;cc:attribute&gt;</code> tag. Besides the name, an attribute can have a type, can be required or not, can have a default value, can target component(s), and so on (during this chapter, you will have the chance to explore different kinds of attributes). As a general rule, JSF determines if the attribute is <code class="literal">MethodExpression</code> (or it has a special name such as <code class="literal">actionListener</code>, <code class="literal">valueChangeListener</code>, <code class="literal">action</code>, and so on) or <code class="literal">ValueExpression</code>.</p><p>The first case is a little bit tricky; JSF will try to match the attribute with the components from the implementation based on the list of IDs defined in the <a id="id1279" class="indexterm"/>
<code class="literal">targets</code> attribute (the list of IDs are separated<a id="id1280" class="indexterm"/> by space and relative to top-level component). If the <code class="literal">targets</code> attribute is not present, then JSF will take the value of the <code class="literal">name</code> attribute as the client ID (relative to the top-level component) and try to find the corresponding component in the implementation section. Well, in the simple case, the attribute is a <code class="literal">ValueExpression</code>, and JSF will just store the attribute in the attributes map that is accessible via <code class="literal">UIComponent.getAttributes</code>.</p><p>In the implementation section, the attributes are used via the <code class="literal">#{cc}</code> implicit object.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note176"/>Note</h3><p>It may be useful to know that JSF will implicitly create a top-level component for all the components that form a composite component. This component is the parent of all components in the page and is named <code class="literal">UINamingContainer</code> (available through the <code class="literal">UIComponent.getNamingContainer</code> method). Now the <code class="literal">#{cc}</code> implicit object actually refers to this top-level component and can be used to obtain various information, but it is especially used for obtaining the client ID (<code class="literal">#{cc.clientId}</code>) and for accessing the composite component attributes (<code class="literal">#{cc.attrs}</code>).</p></div></div><p>Now it's time to test our composite component. This is very easy—just import the composite namespace, set a prefix, and start using it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      <span class="strong"><strong/></span>&gt;
 &lt;h:head&gt;
  &lt;title&gt;&lt;/title&gt;
 &lt;/h:head&gt;
 &lt;h:body&gt;
<span class="strong"><strong>  &lt;t:welcome value="Welcome" to="Rafael Nadal"/&gt;</strong></span>
 &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Learning the techniques for writing composite components can be achieved by a lot of practice. This is why, in the upcoming sections you will see several types of composite components that<a id="id1281" class="indexterm"/> explore different kinds of implementations.</p><p>The complete application is named <code class="literal">ch10_6</code>.</p><div class="section" title="Developing the Temperature composite component"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec111"/>Developing the Temperature composite component</h2></div></div></div><p>Starring: backing component</p><p>Remember the<a id="id1282" class="indexterm"/> Temperature custom component that we implemented in the preceding section? Well, we are sure you do. So let's see how to develop a composite component that looks and behaves the same. The composite component page can be named <code class="literal">temperature.xhtml</code>, and we can store it in the <code class="literal">temperature</code> folder under the <code class="literal">resources</code> folder. First, let's see it in the following code; afterwards we can dissect it:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      
      &gt;

 &lt;!-- INTERFACE --&gt;
 &lt;cc:interface componentType="book.beans.TempConvertComponent"&gt;
  &lt;cc:attribute name="value" type="java.lang.String" 
                                          default="celsius/0"/&gt;
 &lt;/cc:interface&gt;

 &lt;!-- IMPLEMENTATION --&gt;
 &lt;cc:implementation&gt;
  &lt;h:outputStylesheet name="temperature/temp.css" /&gt;            
  &lt;div id="#{cc.clientId}"&gt;
   &lt;h:outputLabel for="selectonemenu" value="Convert to:"/&gt;
   &lt;h:selectOneMenu id="selectonemenu" binding="#{cc.unittoI}"&gt;
    &lt;f:selectItem itemValue="fahrenheit" itemLabel="fahrenheit" /&gt;
    &lt;f:selectItem itemValue="celsius" itemLabel="celsius" /&gt;
   &lt;/h:selectOneMenu&gt;
   &lt;h:outputLabel for="inputfield" value="Insert value:"/&gt;
   &lt;h:inputText id="inputfield" binding="#{cc.temptI}"/&gt;          
   &lt;h:commandButton id="button" value="Convert"&gt;
    &lt;f:ajax execute="@form" render="@form"/&gt;
   &lt;/h:commandButton&gt;
   &lt;h:panelGroup id="div" layout="block" class="tempClass"&gt;
    &lt;h:outputText value="&amp;deg; #{cc.unittoI.value eq 'fahrenheit' ? 'F ': 'C ' } #{cc.getTempConvert()}"/&gt;
   &lt;/h:panelGroup&gt;
  &lt;/div&gt;
 &lt;/cc:implementation&gt;
&lt;/html&gt;</pre></div><p>In the interface section, we have defined the attribute named <code class="literal">value</code>, which is specific to an <code class="literal">UIInput</code> component. Further, we indicate that the accepted value is of type <code class="literal">String</code> and the default value, applicable when the attribute is missing, is <code class="literal">celsius/0</code>. Usually, the <code class="literal">type</code> attribute<a id="id1283" class="indexterm"/> is used to link the element(s) to the bean's properties (for its value, use the fully qualified name, as shown in the preceding code).</p><p>The implementation section is more interesting, because here we need to define the subcomponents of our component: the drop-down menu, the input field, the submit button, and the result div (notice that JSF generates an HTML <code class="literal">&lt;div&gt;</code> from <code class="literal">&lt;h:panelGroup layout="block"/&gt;</code>). When your composite component contains multiple components, it is a good practice to place them inside a <code class="literal">&lt;div&gt;</code> or a <code class="literal">&lt;span&gt;</code> tag with the ID set to <code class="literal">#{cc.clientId}</code>. This ID is the client identifier of the composite itself and is useful when the page author needs to refer to the entire composite component via a simple ID.</p><p>External resources, such as CSS and JS, don't need any special treatment. You can place them under the same library with composite components or under any other library, and you can load them using <code class="literal">&lt;h:outputScript&gt;</code> and <code class="literal">&lt;h:outputStylesheet&gt;</code>.</p><p>After a quick look, an obvious question arises: where is the implementation of the <code class="literal">getTempConvert</code> method and the backing beans properties used for linking these components according to the <code class="literal">binding</code> attribute? Well, all these are in a Java class, known as <a id="id1284" class="indexterm"/>
<span class="strong"><strong>backing component</strong></span> (do not confuse this with the backing bean!). Yes, I know that earlier I said composite components don't need Java code, but sometimes they do, like in this case, where we need to write the code for calling the web service! In order to write a backing component, you need to keep in mind the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Annotate the backing component with <code class="literal">@FacesComponent</code></li><li class="listitem">Extend <code class="literal">UINamingContainer</code> or implement <code class="literal">NamingContainer</code> and override the <code class="literal">getFamily</code> method as follows:<div class="informalexample"><pre class="programlisting">  @Override
  public String getFamily() {
   return UINamingContainer.COMPONENT_FAMILY;
  }</pre></div></li><li class="listitem">Link the composite component with the backing component by adding the <code class="literal">componentType</code> attribute to the <code class="literal">&lt;cc:interface&gt;</code> tag. The value of this attribute is the component-type (this tells JSF to create an instance of the class indicated here):<div class="informalexample"><pre class="programlisting">@FacesComponent(value = "<span class="emphasis"><em>component type value</em></span>")
...
&lt;cc:interface componentType="<span class="emphasis"><em>component type value</em></span>"&gt;</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note177"/>Note</h3><p>A backing component can define getters for exposing its properties via the <code class="literal">#{cc}</code> implicit object (<code class="literal">#{cc}</code> has access to action methods also). On the other hand, the <code class="literal">&lt;cc:attribute&gt;</code> attributes are available in a backing component via the <code class="literal">UIComponent.getAttributes</code> method.</p></div></div><p>Keeping<a id="id1285" class="indexterm"/> these in mind, the backing component<a id="id1286" class="indexterm"/> for our composite component is as follows:</p><div class="informalexample"><pre class="programlisting">@FacesComponent(value = "book.beans.TempConvertComponent", 
                                           createTag = false)
public class TempConvertComponent extends UIInput implements NamingContainer {

 private UIInput unittoI;
 private UIInput temptI;

 public TempConvertComponent() {
 }

 public UIInput getUnittoI() {
  return unittoI;
 }

 public void setUnittoI(UIInput unittoI) {
  this.unittoI = unittoI;
 }

 public UIInput getTemptI() {
  return temptI;
 }

 public void setTemptI(UIInput temptI) {
  this.temptI = temptI;
 }

 public String getTempConvert() {
  TempConvertClient tempConvertClient = new TempConvertClient();
  return String.format("%.1f", 
  tempConvertClient.callTempConvertService(String.valueOf(unittoI.getValue()), Float.valueOf(String.valueOf(temptI.getValue()))));
}

 @Override
 public void decode(FacesContext context) {
  this.setSubmittedValue(temptI.getSubmittedValue() + "/" + 
                                  unittoI.getSubmittedValue());
 }
         
 /*
  * you can override getSubmittedValue instead of decode
 @Override
 public Object getSubmittedValue() {
  return temptI.getSubmittedValue() + "/" + unittoI.getSubmittedValue();
 }
 */

 @Override
 public void encodeBegin(FacesContext context) throws IOException {

  if (getValue() != null) {
      String cv = String.valueOf(getValue());
      String unitto = cv.substring(0, cv.indexOf("/"));
      String temp = cv.substring(cv.indexOf("/") + 1);
      if (temptI.getValue() == null) {
          temptI.setValue(temp);
      }
      if (unittoI.getValue() == null) {
          unittoI.setValue(unitto);
      }
    }
   super.encodeBegin(context);
  }

 @Override
 public String getFamily() {
  return UINamingContainer.COMPONENT_FAMILY;
 }
}</pre></div><p>The<a id="id1287" class="indexterm"/> story of our backing component<a id="id1288" class="indexterm"/> is pretty clear. In the <code class="literal">encodeBegin</code> method, we ensure that the component value is parsed and each subcomponent (the dropdown and the input field) received<a id="id1289" class="indexterm"/> the correct part of the value. When the user submits the data, we deal with it in the <code class="literal">encode</code> method, where we take the value of the dropdown and of the input field and build a string of type <span class="emphasis"><em>conversion_unit</em></span><code class="literal">/</code><span class="emphasis"><em>temperature</em></span>. This becomes the submitted value.</p><p>This is a good time to point out how JSF chooses the top-level component. JSF tries to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Locate the <code class="literal">componentType</code> attribute<a id="id1290" class="indexterm"/> in the <code class="literal">&lt;cc:interface&gt;</code> tag. If it is present, then the backing component is instantiated and used as a top-level component. This is the case with the Temperature composite component.</li><li class="listitem" style="list-style-type: disc">Locate a <code class="literal">UIComponent</code> implementation<a id="id1291" class="indexterm"/> that fits the composite component page. This can be a Groovy script with the same name and location as the composite component page (of course, with the <code class="literal">.groovy</code> extension).</li><li class="listitem" style="list-style-type: disc">Locate a Java class named <span class="emphasis"><em>component_library_name.composite_component_page_name</em></span> and instantiate it as a top-level component. This approach spears us to use <code class="literal">@FacesComponent</code>.</li><li class="listitem" style="list-style-type: disc">Generate a component with the component type <code class="literal">javax.faces.NamingContainer</code>.</li></ul></div><p>The complete application is named <code class="literal">ch10_8</code>. Based on the knowledge introduced through this didactical example, you can check out another example, named Timezone, as shown in the following screenshot. The complete application is named <code class="literal">ch10_25</code>.</p><div class="mediaobject"><img src="graphics/6466EN_10_02.jpg" alt="Developing the Temperature composite component"/></div></div><div class="section" title="Transforming a jQuery component into composite component"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec112"/>Transforming a jQuery component into composite component</h2></div></div></div><p>Starring: JavaScript closures</p><p>The jQuery UI is<a id="id1292" class="indexterm"/> a great collection of user interface interactions, effects, widgets, and themes built on top of the jQuery<a id="id1293" class="indexterm"/> JavaScript library. In this section, you will see how to expose a jQuery component as a JSF composite component. More precisely, we will transform the jQuery range slider (<a class="ulink" href="https://jqueryui.com/slider/#range">https://jqueryui.com/slider/#range</a>), as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_10_03.jpg" alt="Transforming a jQuery component into composite component"/></div><p>The main code behind this component is listed as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html lang="en-US"&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt; 
  &lt;title&gt;Range Slider with jQuery UI&lt;/title&gt;  
  &lt;link rel="stylesheet" type="text/css" media="all" 
                                     href="css/styles.css"&gt;
  &lt;link rel="stylesheet" type="text/css" media="all" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css"&gt;
  &lt;script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"&gt;&lt;/script&gt;
 &lt;/head&gt;

 &lt;body&gt;
  &lt;div id="w"&gt;
   &lt;div id="content"&gt;     
    &lt;h2&gt;Ranged Slider&lt;/h2&gt;
    &lt;div id="rangedval"&gt;
     Range Value: &lt;span id="rangeval"&gt;90 - 290&lt;/span&gt;
    &lt;/div&gt;      
    &lt;div id="rangeslider"&gt;&lt;/div&gt;      
   &lt;/div&gt;
  &lt;/div&gt;
  &lt;script type="text/javascript"&gt;
   $(function(){  
   $('#rangeslider').slider({
     range: true,
     min: 0,
     max: 100,
     values: [ 5, 20 ],
     slide: function( event, ui ) {
      $('#rangeval').html(ui.values[0]+" - "+ui.values[1]);
     }
    });  
   });
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The JSF <a id="id1294" class="indexterm"/>composite component<a id="id1295" class="indexterm"/> should look like the following code (the important part is highlighted):</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="sliderFormId"&gt;
 &lt;h:panelGrid columns="1"&gt;
<span class="strong"><strong>  &lt;t:range-slider id="sliderId" min="#{sliderBean.min}" </strong></span>
<span class="strong"><strong>         max="#{sliderBean.max}" leftside="#{sliderBean.leftside}" </strong></span>
<span class="strong"><strong>         rightside="#{sliderBean.rightside}"/&gt;</strong></span>
  &lt;h:commandButton value="Send" action="#{sliderBean.sliderListener()}"&gt;
   &lt;f:ajax execute="@form" render="@form"/&gt;
  &lt;/h:commandButton&gt;
 &lt;/h:panelGrid&gt;
&lt;/h:form&gt;</pre></div><p>We can start by defining the composite component attributes. These will allow the end user to set the minimum (<code class="literal">min</code> attribute), maximum (<code class="literal">max</code> attribute) and the initial range (<code class="literal">leftside</code> and <code class="literal">rightside</code> attributes). These attributes will be declared in the interface section, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:attribute name="min" type="java.lang.Integer" 
                          default="0" required="true"/&gt;
 &lt;cc:attribute name="max" type="java.lang.Integer" 
                          default="1000" required="true"/&gt;
 &lt;cc:attribute name="leftside" type="java.lang.Integer" 
                          default="450" required="true"/&gt;
 &lt;cc:attribute name="rightside" type="java.lang.Integer" 
                          default="550" required="true"/&gt; 
&lt;/cc:interface&gt;</pre></div><p>The implementation section can be<a id="id1296" class="indexterm"/> divided into three logical parts. In the first part we define the external resources (CSS and JS files). Notice that <code class="literal">&lt;h:outputScript&gt;</code> and <code class="literal">&lt;h:outputStylesheet&gt;</code> cannot<a id="id1297" class="indexterm"/> load such resources for an absolute URL (<code class="literal">http://...</code>), so you need to have these resources on your local machine:</p><div class="informalexample"><pre class="programlisting">&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;h:outputStylesheet name="range-slider/css/styles.css"/&gt;  
 &lt;h:outputStylesheet name="range-slider/css/jquery-ui.css"/&gt;         
 &lt;h:outputScript target="head" name="range-slider/js/jquery.min.js"/&gt;
 &lt;h:outputScript target="head" name="range-slider/js/jquery-ui.min.js"/&gt;         
 ...</pre></div><p>In the second part, we render the divs that expose the range slider. For this, we follow the exact model of the original component, but we add our attributes, <code class="literal">leftside</code> and <code class="literal">rightside</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;div id="#{cc.clientId}:w" class="w"&gt;
  &lt;div id="#{cc.clientId}:content" class="content"&gt;
   &lt;div id="#{cc.clientId}:rangedval" class="rangedval"&gt;
    Range Value: &lt;span id="#{cc.clientId}:rangeval"&gt;
                 #{cc.attrs.leftside} - #{cc.attrs.rightside}&lt;/span&gt;
   &lt;/div&gt;
   &lt;div id="#{cc.clientId}:slider"&gt;
   &lt;/div&gt;
  &lt;/div&gt;
  &lt;h:inputHidden id="leftsideId" value="#{cc.attrs.leftside}"/&gt;
  &lt;h:inputHidden id="rightsideId" value="#{cc.attrs.rightside}"/&gt;
&lt;/div&gt;</pre></div><p>While the <code class="literal">min</code> and <code class="literal">max</code> attributes can be set to certain values, we are especially interested in the <code class="literal">leftside</code> and <code class="literal">rightside</code> attributes, which should be treated as the end user inputs. For this, we have added two hidden fields (one for <code class="literal">leftside</code> and one for <code class="literal">rightside</code>) that can easily transport this information to the server.</p><p>In the third part, we need to adapt the JavaScript code, which represents the component engine. This code has to be correctly generated when multiple range sliders are added in the same page, so we need to modify it as follows to fit the correct IDs and attribute values:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
 $(function() {
   var rangeval = "${cc.clientId}:rangeval".replace(/:/g, "\\:");
   var slider = "${cc.clientId}:slider".replace(/:/g, "\\:");
   $('#' + slider).slider({
     range: true,
     min: #{cc.attrs.min},
     max: #{cc.attrs.max},
     values: [#{cc.attrs.leftside}, #{cc.attrs.rightside}],
     slide: function(event, ui) {
     $('#' + rangeval).html(ui.values[0] + " - " + ui.values[1]);
     $("#${cc.clientId}:leftsideId".
          replace(/:/g, "\\:")).val(ui.values[0]);
     $("#${cc.clientId}:rightsideId".
          replace(/:/g, "\\:")).val(ui.values[1]);
     }
   });
  });
 &lt;/script&gt;
&lt;/cc:implementation&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note178"/>Note</h3><p>A common issue of combining JSF and jQuery involves using the colon (<code class="literal">:</code>). While JSF uses it as a separator of ID segments, the jQuery selector has other jobs for it. In order to work in jQuery, we need to escape the colon. This can be easily accomplished if you use a PrimeFaces method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">escadpeClientId:function(a){return"#"+a.replace(/:/g,"\\:")}</pre></div></div></div><p>Done! Now you can test the composite <a id="id1298" class="indexterm"/>component in your page. The complete application is named <code class="literal">ch10_11</code>.</p><p>Well, if you add multiple range sliders<a id="id1299" class="indexterm"/> in the page, you will see that the preceding JavaScript code will be generated and added each time. The size of this code is insignificant, and the chances that you'll need multiple range sliders in the same page are pretty small, so it will not be a big issue. But, when such an issue arises, you need to know that there are a few workarounds for it.</p><p>For example, we can take out JavaScript from the composite component and place it into the page, or as a component should be self contained it would be better to place the code in a separate JavaScript file and reference it in the composite component with <code class="literal">&lt;h:outputScript&gt;</code>. After that, we parameterize the JavaScript code with the desired attributes, and call it from the composite component. So, the parameterized version might look like the following code (place this in a file named <code class="literal">slider.js</code>):</p><div class="informalexample"><pre class="programlisting">  var rangeslider = {
  init: function(clientId, min, max, leftside, rightside) {
  var rangeval = (clientId + ":rangeval").replace(/:/g, "\\:");
  var slider = (clientId + ":slider").replace(/:/g, "\\:");
   $('#' + slider).slider({
    range: true,
<span class="strong"><strong>    min: min,</strong></span>
<span class="strong"><strong>    max: max,</strong></span>
<span class="strong"><strong>    values: [parseInt(leftside), parseInt(rightside)],</strong></span>
    slide: function(event, ui) {
     $('#' + rangeval).html(ui.values[0] + " - " + ui.values[1]);
     $("#" + (clientId + ":leftsideId").
              replace(/:/g, "\\:")).val(ui.values[0]);
     $("#" + (clientId + ":rightsideId").
              replace(/:/g, "\\:")).val(ui.values[1]);
    }
   });
  }
 };</pre></div><p>Further, we adapt the composite component<a id="id1300" class="indexterm"/> implementation section for calling the following reusable JavaScript code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:implementation&gt;
 ...
 &lt;h:outputScript target="head" name="range-slider/js/slider.js"/&gt;
 ...
 &lt;script&gt;
  rangeslider.init('#{cc.clientId}', '#{cc.attrs.min}', 
   '#{cc.attrs.max}', '#{cc.attrs.leftside}', '#{cc.attrs.rightside}');
 &lt;/script&gt;
&lt;/cc:implementation&gt;</pre></div><p>Probably you already know that you just saw<a id="id1301" class="indexterm"/> a technique of JavaScript closures. The idea is to speculate the fact that JavaScript is a dynamic language that lets us modify the DOM at runtime. Using the JSF client identifier and this JavaScript capability can help us to solve the issue of repeating code for multiple components. Sometimes, a good practice is to place the entire composite component inside a <code class="literal">div</code> element whose ID is the JSF client identifier. Moreover, you can identify and manage each <code class="literal">div</code> content directly from JavaScript.</p><p>The complete application for this example is named <code class="literal">ch10_9</code>. If you want to place the JavaScript code directly into the page, check the application named <code class="literal">ch10_26</code>. Besides this application, another complete example of using JavaScript closures is named <code class="literal">ch10_7</code>. In this example, a composite <a id="id1302" class="indexterm"/>component encapsulates an HTML5 SSE (Server-sent Events) example. For those who are<a id="id1303" class="indexterm"/> not familiar with SSE, a good starting point is the tutorial at <a class="ulink" href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">http://www.html5rocks.com/en/tutorials/eventsource/basics/</a>.</p></div><div class="section" title="Writing the HTML5 date picker as a composite component"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Writing the HTML5 date picker as a composite component</h2></div></div></div><p>Starring: <code class="literal">&lt;cc:clientBehavior&gt;</code> and <code class="literal">&lt;cc:insertChildren /&gt;</code></p><p>In this section, you<a id="id1304" class="indexterm"/> will see how to transform the HTML5 date picker component into a composite component. There are a few<a id="id1305" class="indexterm"/> attributes that allow us to customize the native date picker component. The following is a list of three examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code for the simplest case is as follows:<div class="informalexample"><pre class="programlisting">&lt;input id="exId" type="date" value="" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">The code for the constrained date picker is as follows:<div class="informalexample"><pre class="programlisting">&lt;input id="exId" type="date" value="2015-01-05"
              min="2015-01-01" max="2015-01-31" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">The code for the date picker with data list is as follows:<div class="informalexample"><pre class="programlisting">&lt;input id="exId" type="date" value="" list="listId" /&gt;
&lt;datalist id="listId"&gt;
 &lt;option label="Day 1" value="2015-01-01"/&gt;
 &lt;option label="Day 2" value="2015-01-02" /&gt;
 &lt;option label="Day 3" value="2015-01-03" /&gt;
&lt;/datalist&gt;</pre></div></li></ul></div><p>Our composite component should reflect these forms, so it might look like the following code:</p><div class="informalexample"><pre class="programlisting">Date-time without data-list:
&lt;h:form&gt;             
 &lt;t:datetime value="#{dateTimeBean.date}" 
             min="#{dateTimeBean.min}" max="#{dateTimeBean.max}"&gt; 
  &lt;f:ajax event="change" execute="@form" 
                        listener="#{dateTimeBean.selectedDate()}"/&gt;                
 &lt;/t:datetime&gt;            
&lt;/h:form&gt;</pre></div><p>Alternatively, use a data list, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Date-time with data-list:
&lt;h:form&gt;             
 &lt;t:datetime list="listId" value="#{dateTimeBean.date}"&gt; 
 &lt;f:ajax event="change" execute="@form" 
                 listener="#{dateTimeBean.selectedDate()}"/&gt;     
&lt;/t:datetime&gt;
&lt;t:datalist id="listId"&gt;
 &lt;t:option label="Day 1" value="2015-01-01"/&gt;
 &lt;t:option label="Day 2" value="2015-01-02"/&gt;
 &lt;t:option label="Day 3" value="2015-01-03"/&gt;
&lt;/t:datalist&gt;</pre></div><p>So, let's focus on <a id="id1306" class="indexterm"/>the interface definition. First, we have a set of <a id="id1307" class="indexterm"/>attributes that are very easy to define, such as <code class="literal">value</code>, <code class="literal">list</code>, <code class="literal">step</code>, <code class="literal">required</code>, and <code class="literal">readonly</code>:</p><div class="informalexample"><pre class="programlisting">&lt;cc:attribute name="value" type="java.util.Date" required="true" /&gt;
&lt;cc:attribute name="list" type="java.lang.String" default="" /&gt;
&lt;cc:attribute name="step" type="java.lang.String" default="1" /&gt; 
&lt;cc:attribute name="required" type="java.lang.String"
  default="false" /&gt;
&lt;cc:attribute name="readonly" type="java.lang.String"
  default="false" /&gt;</pre></div><p>This was easy! Now we need to take a closer look at the <code class="literal">min</code> and <code class="literal">max</code> attributes, which delimitate the range of selection. Practically, they are just some dates, but NOT instances of <code class="literal">java.util.Date</code>, because their format is specific to HTML 5 (y-m-d), not to Java. This means that we need some Java code for accomplishing the conversion from Java date format to HTML5 date format. We need a backing component to do this (notice that we can't use any converter here):</p><div class="informalexample"><pre class="programlisting">@FacesComponent(value = "datetime")
public class DateTimeComponent extends UINamingContainer {

 private static final DateTimeFormatter HTML5_FORMAT =  
                DateTimeFormat.forPattern("yyyy-MM-dd");
 private String minHTML5Date = "";
 private String maxHTML5Date = "";

 public String getMinHTML5Date() {
  return minHTML5Date;
 }

 public String getMaxHTML5Date() {
  return maxHTML5Date;
 }

 @Override
 public void encodeBegin(FacesContext context) throws IOException {

  Date min = (Date) getAttributes().get("min");
  if (min != null) {
      DateTime minDateTime = new DateTime(min);
      minHTML5Date = HTML5_FORMAT.print(minDateTime);
  }
  Date max = (Date) getAttributes().get("max");
  if (max != null) {
      DateTime maxDateTime = new DateTime(max);
      maxHTML5Date = HTML5_FORMAT.print(maxDateTime);
  }
 super.encodeBegin(context);
 }
}</pre></div><p>Of course, we don't forget to indicate the backing <a id="id1308" class="indexterm"/>component in the interface and the restriction selection attributes, which can now be declared as <code class="literal">java.util.Date</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:interface componentType="datetime"&gt;
 &lt;cc:attribute name="min" type="java.util.Date" /&gt;
 &lt;cc:attribute name="max" type="java.util.Date" /&gt;
...</pre></div><p>We need to do<a id="id1309" class="indexterm"/> one more thing in the interface. When the end user selects a date, we want it to be submitted via AJAX to a backing bean. For this, we need to allow him/her to attach a client behavior (we spoke about client behavior several times in this book, but a perfect tutorial can be found at DZone, <a class="ulink" href="http://java.dzone.com/articles/jsf-2-client-behaviors">http://java.dzone.com/articles/jsf-2-client-behaviors</a>), and for this we need the <code class="literal">&lt;cc:clientBehavior&gt;</code> tag, as shown in the following code. The <code class="literal">name</code> attribute contains the name of the event that will listen (for example, <code class="literal">change</code> here) and the <code class="literal">targets</code> attribute indicates the component(s) from the implementation, which will support the declared JavaScript event via the <code class="literal">event</code> attribute (do not use the prefix <code class="literal">on</code> for JavaScript events).</p><div class="informalexample"><pre class="programlisting">&lt;cc:clientBehavior name="change" targets="#{cc.id}" event="change" /&gt;</pre></div><p>So far, the interface is ready! Going further, we need an implementation. This is pretty simple and is based on JSF 2.2 pass-through elements, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:implementation&gt;
 &lt;div id="#{cc.clientId}:dt"&gt;
  &lt;input jsf:id="#{cc.id}" type="date" jsf:value="#{cc.attrs.value}" 
         jsf:readonly="#{cc.attrs.readonly != 'false' ? 'true': 'false'}"
         min="#{cc.minHTML5Date}" max="#{cc.maxHTML5Date}" 
         jsf:required="#{cc.attrs.required != 'false' ? 'true': 'false'}" 
         step="#{cc.attrs.step}" list="#{cc.attrs.list}"&gt;
  &lt;f:convertDateTime pattern="yyyy-MM-dd" /&gt;
  &lt;/input&gt;
 &lt;/div&gt;
&lt;/cc:implementation&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note179"/>Note</h3><p>In order to have an easy way to reference <code class="literal">&lt;datalist&gt;</code>, we used <code class="literal">#{cc.id}</code>. If the component is used multiple times in a page, then you have to specify a unique ID for each use. Nevertheless, if you need a clean solution that avoids nonunique IDs in the rendered XHTML document, you might require some additional ID resolving to be done (with JavaScript or in a backing component for instance).</p></div></div><p>At this moment, we can use our composite<a id="id1310" class="indexterm"/> component, except the data list (see the preceding HTML5 <code class="literal">&lt;datalist&gt;</code>). For this, we need to write two more<a id="id1311" class="indexterm"/> composite components. As you can see, a data list is just a set of several options (items) and each option has two attributes, named <code class="literal">label</code> and <code class="literal">value</code>. So, we can easily encapsulate an option in a composite component, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:attribute name="label" type="java.lang.String" default="" /&gt;
 &lt;cc:attribute name="value" type="java.lang.String" default="" /&gt;    
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;option value="#{cc.attrs.value}" label="#{cc.attrs.label}" /&gt;
&lt;/cc:implementation&gt;</pre></div><p>Now we need to nest several options in <code class="literal">&lt;datalist&gt;</code>, but this is inappropriate here, because the number of options is indeterminate. Fortunately, for these kinds of situations, JSF provides the <code class="literal">&lt;cc:insertChildren&gt;</code> tag, which is used to insert the child component within a parent component (the child components will be automatically re-parented by JSF). Knowing this, we can write the following composite component for <code class="literal">&lt;datalist&gt;</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;  
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;datalist id="#{cc.id}"&gt;
  &lt;cc:insertChildren /&gt;
 &lt;/datalist&gt;
&lt;/cc:implementation&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note180"/>Note</h3><p>Use the <code class="literal">&lt;datalist&gt;</code> tag<a id="id1312" class="indexterm"/> only in <code class="literal">&lt;cc:implementation&gt;</code> and be careful to avoid duplicate ID errors. In order to avoid this, it is recommended that you use this tag only once. To find out the number of children, use <code class="literal">#{cc.childCount}</code>.</p></div></div><p>Done! Now you can try to test the<a id="id1313" class="indexterm"/> complete application<a id="id1314" class="indexterm"/> named <code class="literal">ch10_12</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note181"/>Note</h3><p>For the sake of completeness, you can treat the case when the browser doesn't support HTML5 by getting back to the jQuery UI version of this component. This can be accomplished via the<a id="id1315" class="indexterm"/> Modernizr library (<a class="ulink" href="http://modernizr.com/">http://modernizr.com/</a>), which is able to detect this kind of issue. From our point of view, such browsers will be obsolete in the future, so we don't think the effort to add this check and fallback is justified.</p></div></div></div><div class="section" title="Decorating an image with actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec114"/>Decorating an image with actions</h2></div></div></div><p>Starring: <code class="literal">&lt;cc:actionSource&gt;</code>, Java <code class="literal">enum</code> types</p><p>Composite<a id="id1316" class="indexterm"/> components are amazing because <a id="id1317" class="indexterm"/>they can transform simple things into a real powerful component. For example, in this section we will decorate a simple image to become a composite component with AJAX and action capabilities by adding action and action listener support. Moreover, we will force the page author to use only a range of values for a certain attribute.</p><p>First, we take care of the interface section, and we can start by declaring an attribute that represents the image location, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:attribute name="src" required="true"/&gt;</pre></div><p>After this quick warm up, we can declare the <code class="literal">action</code> attribute. The page author will use this attribute to indicate an <code class="literal">action</code> method of a backing bean. Notice that the <code class="literal">action</code> method signature must be declared here, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:attribute name="action" method-signature="void action()"/&gt;</pre></div><p>When you write a method signature, you need to indicate the return type (<code class="literal">void</code> in this case), the method name and the argument types. For example, an <code class="literal">action</code> method that returns <code class="literal">String</code> and gets two <code class="literal">Integer</code> arguments will be declared as follows:</p><div class="informalexample"><pre class="programlisting">method-signature="java.lang.String
myMethod(java.lang.Integer, java.lang.Integer)"
</pre></div><p>Furthermore, we add support for the <code class="literal">&lt;f:actionListener&gt;</code> tag. For this, we use the <code class="literal">&lt;cc:actionSource&gt;</code> tag as follows:</p><div class="informalexample"><pre class="programlisting">
&lt;cc:actionSource name="imgActionListener" targets="#{cc.clientId}:imgForm:imgAction"/&gt;</pre></div><p>The value of the <code class="literal">name</code> attribute will be<a id="id1318" class="indexterm"/> used by the <a id="id1319" class="indexterm"/>page authors as the value for the <code class="literal">&lt;f:actionListener&gt;</code> <code class="literal">for</code> attribute. The <code class="literal">targets</code> attribute points the component(s) from the implementation section, which receives this capability.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note182"/>Note</h3><p>The <code class="literal">&lt;cc:actionSource&gt;</code> tag specifies the implementation of <code class="literal">ActionSource2</code>.</p></div></div><p>Next, we declare a client behavior using the <code class="literal">&lt;cc:clientBehavior&gt;</code> tag as follows:</p><div class="informalexample"><pre class="programlisting">&lt;cc:attribute name="item" targets="#{cc.clientId}:
      imgForm:imgAction" required="true"/&gt;</pre></div><p>As the final touch, we add an attribute that will accept only a range of values, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:attribute name="item" targets="#{cc.clientId}:
      imgForm:imgAction" required="true"/&gt;</pre></div><p>The interface section is ready, so let's focus on the implementation section. For a better understanding, let's have a look at it as follows:</p><div class="informalexample"><pre class="programlisting">&lt;cc:implementation&gt;
 &lt;h:outputStylesheet library="default" name="css/styles.css" /&gt;            
 &lt;ui:param name="range" value="#{cc.attrs.item}" /&gt; &lt;!-- or c:set --&gt;
 &lt;ui:fragment rendered="#{range == 'item_1' or 
                      range == 'item_2' or range == 'item_3'}"&gt;
  &lt;div id="#{cc.clientId}:img"&gt;
   &lt;h:form id="imgForm"&gt;
    &lt;h:commandLink id="imgAction" immediate="true" 
       action="#{cc.attrs.action}" styleClass="linkopacity"&gt;
     &lt;h:inputHidden id="itemId" value="#{cc.attrs.item}"/&gt;
     &lt;h:graphicImage value="#{cc.attrs.src}"/&gt;
    &lt;/h:commandLink&gt;
   &lt;/h:form&gt;
  &lt;/div&gt;
 &lt;/ui:fragment&gt;
&lt;/cc:implementation&gt;</pre></div><p>There are a few interesting points here! Let's dissect the code from the inside to the outside in the<a id="id1320" class="indexterm"/> following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, the image is loaded in JSF classic style through the <code class="literal">&lt;h:graphicImage&gt;</code> tag. Nothing fancy here!</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;h:graphicImage&gt;</code> tag<a id="id1321" class="indexterm"/> is nested in a <code class="literal">&lt;h:commandLink&gt;</code> tag, which supports<a id="id1322" class="indexterm"/> action and action listener capabilities. Notice that this component is targeted from the interface section. Moreover, we nest a hidden field here (<code class="literal">&lt;h:inputHidden&gt;</code>) that associates (holds) a value with our image. This value comes from a range of allowed values via the <code class="literal">item</code> attribute.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;h:commandLink&gt;</code> tag is nested in a <code class="literal">&lt;h:form&gt;</code> tag<a id="id1323" class="indexterm"/> and everything is added into a <code class="literal">&lt;div&gt;</code> tag. Notice that, usually, it is not a good practice to add <code class="literal">&lt;h:form&gt;</code> in a composite component, since the page author may want to use the composite component in his/her <code class="literal">&lt;h:form&gt;</code>. This will lead to nested forms, which leads to invalid HTML code.</li><li class="listitem" style="list-style-type: disc">In order to restrict an attribute value to <a id="id1324" class="indexterm"/>a range of values, you may think of using Java enum types. The problem is that you cannot do that in the interface section, but you can add a check in the implementation section. For example, we choose not to render the composite component when the value of the <code class="literal">item</code> attribute is different from <code class="literal">item_1</code>, <code class="literal">item_2</code>, and <code class="literal">item_3</code>.</li></ul></div><p>The composite component is ready for testing. A perfect example can be seen in the code bundle of this chapter under the name <code class="literal">ch10_18</code>. Based on the same principle, we have written another example under the name <code class="literal">ch10_13</code>.</p></div><div class="section" title="Working with composite facets"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Working with composite facets</h2></div></div></div><p>Starring: <code class="literal">&lt;cc:facet&gt;</code>, <code class="literal">&lt;cc:renderFacet&gt;</code>, and <code class="literal">&lt;cc:insertFacet&gt;</code></p><p>A composite component <a id="id1325" class="indexterm"/>contains the facets definition in<a id="id1326" class="indexterm"/> the interface section. For this, we need to use the <code class="literal">&lt;cc:facet&gt;</code> tag<a id="id1327" class="indexterm"/> and to specify at least the facet name through the <code class="literal">name</code> attribute, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:facet name="name" /&gt;
&lt;cc:facet name="surname" /&gt;</pre></div><p>Once the facets are<a id="id1328" class="indexterm"/> declared in the interface section, they can be used in the implementation section via<a id="id1329" class="indexterm"/> the <code class="literal">&lt;cc:renderFacet&gt;</code> tag. For this tag, we need to specify which facet to be <a id="id1330" class="indexterm"/>rendered, by setting the value of the <code class="literal">name</code> attribute in agreement with the corresponding facet defined in the interface section, as<a id="id1331" class="indexterm"/> shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:renderFacet name="name" required="true"/&gt;
&lt;cc:renderFacet name="surname" required="true"/&gt;     </pre></div><p>That's all! You can see a complete example in the code bundle of this chapter under the name <code class="literal">ch10_14</code>.</p><p>Besides <code class="literal">&lt;cc:renderFacet&gt;</code>, a composite component supports the <code class="literal">&lt;cc:insertFacet&gt;</code> tag. Now things <a id="id1332" class="indexterm"/>become more interesting, because a common<a id="id1333" class="indexterm"/> question is, what is the difference between them? The best answer will come from an example. Let's take a simple composite component that uses <code class="literal">&lt;cc:renderFacet&gt;</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:facet name="header" /&gt;        
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;              
 &lt;cc:renderFacet name="header"/&gt;
 &lt;!-- this will not render --&gt;
 &lt;!-- &lt;cc:insertFacet name="header"/&gt; --&gt;
&lt;/cc:implementation&gt;</pre></div><p>This will render correctly through the following usage:</p><div class="informalexample"><pre class="programlisting">...

...
&lt;q:renderfacet&gt;
 &lt;f:facet name="header"&gt;
  Render Facet
 &lt;/f:facet&gt;
&lt;/q:renderfacet&gt;</pre></div><p>However, replacing <code class="literal">&lt;cc:renderFacet&gt;</code> with <code class="literal">&lt;cc:insertFacet&gt;</code> will not work. Nothing will be rendered.</p><p>Now let's take a look at the following composite component that uses <code class="literal">&lt;cc:insertFacet&gt;</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:facet name="header" /&gt;        
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;h:dataTable border="1"&gt;
  &lt;cc:insertFacet name="header"/&gt;     
  &lt;!-- this will not render --&gt;
  &lt;!-- &lt;cc:renderFacet name="header"/&gt; --&gt;
 &lt;/h:dataTable&gt;  
&lt;/cc:implementation&gt;</pre></div><p>The following code snippet will render the desired result:</p><div class="informalexample"><pre class="programlisting">&lt;t:insertfacet&gt;
 &lt;f:facet name="header"&gt;
  Insert Facet
 &lt;/f:facet&gt;          
&lt;/t:insertfacet&gt;</pre></div><p>But again, replacing <code class="literal">&lt;cc:insertFacet&gt;</code> with <code class="literal">&lt;cc:renderFacet&gt;</code> will not work. Nothing will be rendered.</p><p>So, we can<a id="id1334" class="indexterm"/> conclude that <code class="literal">&lt;cc:renderFacet&gt;</code> is useful for rendering facets as child components of the composite component. This means that <code class="literal">&lt;cc:renderFacet&gt;</code> allows us<a id="id1335" class="indexterm"/> to render facets when<a id="id1336" class="indexterm"/> the parent component doesn't support facets; the facet name can be any accepted string. On the other hand, <code class="literal">&lt;cc:insertFacet&gt;</code> allows<a id="id1337" class="indexterm"/> us to render facets only in components that support facets. Here, the facet name must exist in the facet map of the top-level component. The facet is inserted as a facet child of the component in which this element is nested.</p><p>The complete application is named <code class="literal">ch10_17</code>.</p></div><div class="section" title="Validating/converting inputs inside composite components"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec116"/>Validating/converting inputs inside composite components</h2></div></div></div><p>Starring: <code class="literal">&lt;cc:editableValueHolder&gt;</code></p><p>Let's take a quick <a id="id1338" class="indexterm"/>look at a simple composite<a id="id1339" class="indexterm"/> component in<a id="id1340" class="indexterm"/> the following code, especially <a id="id1341" class="indexterm"/>at the highlighted parts:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:attribute name="name" type="java.lang.String" required="true"/&gt;
 &lt;cc:attribute name="surname" type="java.lang.String"
  required="true" /&gt;
<span class="strong"><strong> &lt;cc:editableValueHolder name="playerId" targets="nameId surnameId"/&gt;</strong></span>
 &lt;cc:attribute name="action" 
               method-signature="void action()" required="true" /&gt;
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;h:messages/&gt;
 &lt;h:outputLabel for="<span class="strong"><strong>nameId</strong></span>" value="Player Name:"/&gt;
 &lt;h:inputText id="nameId" value="#{cc.attrs.name}" /&gt;          
 &lt;h:outputLabel for="<span class="strong"><strong>surnameId</strong></span>" value="Player Surname:"/&gt;
 &lt;h:inputText id="surnameId" value="#{cc.attrs.surname}" /&gt;      
 &lt;h:commandButton id="button" value="Submit" action="#{cc.attrs.action}"&gt;
  &lt;f:ajax execute="@form" render="@form"/&gt;
 &lt;/h:commandButton&gt;  
&lt;/cc:implementation&gt;</pre></div><p>Now we write a page that uses this component and attaches a custom converter and a custom validator to it as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="playerFormId"&gt;
 &lt;t:player name="#{playerBean.name}" surname="#{playerBean.surname}" 
           action="#{playerBean.playerAction()}"&gt;
  &lt;f:converter converterId="playerConverter" <span class="strong"><strong>for="playerId"</strong></span>/&gt;
  &lt;f:validator validatorId="playerValidator" <span class="strong"><strong>for="playerId"</strong></span>/&gt;    
 &lt;/t:player&gt;
&lt;/h:form&gt;</pre></div><p>Everything works as expected, thanks to <code class="literal">&lt;cc:editableValueHolder&gt;</code>. In this case, this tag tells JSF that any converter/validator that has the value of the <code class="literal">for</code> attribute equal to <code class="literal">playerId</code> should be<a id="id1342" class="indexterm"/> applied to the targeted components, <code class="literal">nameId</code> and <code class="literal">surnameId</code>. Generally speaking, <code class="literal">&lt; cc:editableValueHolder&gt;</code> indicates the components<a id="id1343" class="indexterm"/> that implement <code class="literal">EditableValueHolder</code>, so any attached objects suitable for implementations of <code class="literal">EditableValueHolder</code> may be attached to the composite component.</p><p>The complete<a id="id1344" class="indexterm"/> application is named <code class="literal">ch10_10</code>.</p><p>As you know, <code class="literal">EditableValueHolder</code> is an extension of <code class="literal">ValueHolder</code>. Besides <code class="literal">&lt;cc:editableValueHolder&gt;</code>, JSF defines a tag named <code class="literal">&lt;cc:valueHolder&gt;</code>, which indicates the<a id="id1345" class="indexterm"/> components that implement <code class="literal">ValueHolder</code>.</p></div><div class="section" title="Checking the presence of an attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec117"/>Checking the presence of an attribute</h2></div></div></div><p>Sometimes you need to<a id="id1346" class="indexterm"/> render a composite<a id="id1347" class="indexterm"/> component only if a certain attribute is present in the author page. For example, the following composite component checks for the presence of the <code class="literal">mandatory</code> attribute:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:attribute name="value" required="true"/&gt;
 &lt;cc:attribute name="mandatory" type="java.lang.Boolean"/&gt;
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;h:panelGroup rendered="#{not empty cc.attrs.mandatory}"&gt;
  &lt;h:inputText value="#{cc.attrs.value}" 
               required="#{cc.attrs.mandatory}"/&gt;
 &lt;/h:panelGroup&gt;
&lt;/cc:implementation&gt;</pre></div><p>Now the composite component will be rendered only if the <code class="literal">mandatory</code> attribute is present, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;t:attrcheck value="<span class="emphasis"><em>some_text</em></span>" mandatory="false"/&gt;</pre></div><p>The<a id="id1348" class="indexterm"/> complete application is named <code class="literal">ch10_22</code>.</p></div><div class="section" title="Composite components' pitfalls"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec118"/>Composite components' pitfalls</h2></div></div></div><p>In the next part of this chapter, we will discuss a few pitfalls of composite components, such as: <code class="literal">null</code> values<a id="id1349" class="indexterm"/> within composite component attributes, hidden pass-through attributes in composite components, number of children of composite components, and rendered top-level component in <code class="literal">&lt;h:panelGrid&gt;</code>.</p><div class="section" title="Null values within a composite component's attributes"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec07"/>Null values within a composite component's attributes</h3></div></div></div><p>As of version 2.2, JSF can determine the right type of a composite component attributes even when that value is <code class="literal">null</code>. This is an issue in version 2.1.</p><p>Let's have a simple composite<a id="id1350" class="indexterm"/> component, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:attribute name="value"/&gt;
 &lt;cc:editableValueHolder name="test"/&gt;
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;h:inputText id="test" value="#{cc.attrs.value}"/&gt;
&lt;/cc:implementation&gt;</pre></div><p>Also, a simple page that uses this composite component is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;            
 &lt;t:nullTest value="#{dummyBean.dummy}"&gt;
  &lt;f:validator for="test" binding="#{dummyBean.dummyValidator}"/&gt;
 &lt;/t:nullTest&gt;
 &lt;h:commandButton value="Send"/&gt;
&lt;/h:form&gt;</pre></div><p>Now if you supply a <code class="literal">null</code> value from this component, it will work correctly in JSF 2.2, but will not work in JSF 2.1. The complete example is named <code class="literal">ch10_19</code>.</p></div></div><div class="section" title="Hiding pass-through attributes in composite components"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec119"/>Hiding pass-through attributes in composite components</h2></div></div></div><p>A composite component can<a id="id1351" class="indexterm"/> hide pass-through attributes. For example, let's<a id="id1352" class="indexterm"/> take a simple composite component as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface componentType="book.beans.PtaComponent"&gt;
 &lt;cc:attribute name="value"/&gt;   
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;       
 &lt;h:inputText value="#{cc.attrs.value}"/&gt;                             
&lt;/cc:implementation&gt;</pre></div><p>Next, let's use this composite component in a page by adding two pass-through attributes to it as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
 &lt;t:pta value="leoprivacy@yahoo.com"&gt;
  &lt;f:passThroughAttribute name="placeholder" 
                          value="Type an e-mail address" /&gt;
  &lt;f:passThroughAttribute name="type" value="email" /&gt;
 &lt;/t:pta&gt;
 &lt;h:commandButton value="Submit"/&gt;
&lt;/h:form&gt;</pre></div><p>At this moment, if you check the list of attributes (using the <code class="literal">UIComponent.getAttributes</code> method) and the list of pass-through attributes (using the <code class="literal">UIComponent.getPassThroughAttributes</code> method), you will notice that the <code class="literal">placeholder</code> and <code class="literal">type</code> attributes<a id="id1353" class="indexterm"/> are in the list of pass-through attributes. We can easily move them into the attributes list by encapsulating them into the composite component, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface componentType="book.beans.PtaComponent"&gt;
 &lt;cc:attribute name="value"/&gt;   
 &lt;cc:attribute name="placeholder"/&gt;
 &lt;cc:attribute name="type"/&gt;
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;       
 &lt;h:inputText value="#{cc.attrs.value}"&gt; 
  &lt;f:passThroughAttribute name="placeholder" 
                          value="#{cc.attrs.placeholder}" /&gt;
  &lt;f:passThroughAttribute name="type" value="#{cc.attrs.type}" /&gt;
 &lt;/h:inputText&gt;
&lt;/cc:implementation&gt;</pre></div><p>Also, you can use the composite component in the page, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
 &lt;t:pta value="leoprivacy@yahoo.com" 
        placeholder="Type an e-mail address" type="email" /&gt;                               
 &lt;h:commandButton value="Submit"/&gt;
&lt;/h:form&gt;</pre></div><p>Done! Now the <code class="literal">placeholder</code> and <code class="literal">type</code> attributes are not present in the pass-through attributes list. They<a id="id1354" class="indexterm"/> were added in the attributes list returned by the <code class="literal">getAttributes</code> method.</p><p>The complete application is named <code class="literal">ch10_16</code>.</p><div class="section" title="Counting the children of a composite component"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec08"/>Counting the children of a composite component</h3></div></div></div><p>Suppose that you have a <a id="id1355" class="indexterm"/>composite component that accepts children via the <code class="literal">&lt;cc:insertChildren/&gt;</code> tag. Sometimes you may need to render a certain message when the list of children is empty, and for this you may think of writing a composite component implementation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;div id="#{cc.clientId}"&gt;
  &lt;ul&gt;           
   &lt;cc:insertChildren/&gt;                
   &lt;h:panelGroup rendered="#{cc.childCount == 0}"&gt;
    The list of names is empty!
   &lt;/h:panelGroup&gt; 
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/cc:implementation&gt;</pre></div><p>Now if the composite component is used as follows, you may think that the message <span class="strong"><strong>The list of names is empty!</strong></span> will be rendered:</p><div class="informalexample"><pre class="programlisting">&lt;t:iccc/&gt;</pre></div><p>Well, you are right! But, the same message, next to the list content, will be rendered when the component is used as follows:</p><div class="informalexample"><pre class="programlisting">&lt;t:iccc&gt;
 &lt;li&gt;Mike&lt;/li&gt; 
 &lt;li&gt;Andrew&lt;/li&gt;
&lt;/t:iccc&gt;</pre></div><p>In order to solve this issue, you can use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cc:implementation&gt;
 &lt;div id="#{cc.clientId}"&gt;
  &lt;ul&gt;           
   &lt;cc:insertChildren/&gt;                
<span class="strong"><strong>   &lt;c:if test="#{cc.childCount == 0}"&gt;</strong></span>
<span class="strong"><strong>    The list of names is empty!</strong></span>
<span class="strong"><strong>   &lt;/c:if&gt;</strong></span>
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/cc:implementation&gt;</pre></div><p>Done! The complete application is named <code class="literal">ch10_20</code>.</p></div><div class="section" title="Top-level component's pitfall"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec09"/>Top-level component's pitfall</h3></div></div></div><p>Remember that we<a id="id1356" class="indexterm"/> have said earlier in this chapter<a id="id1357" class="indexterm"/> that each composite component receives <code class="literal">UINamingContainer</code> as the top-level component. Well, it is important to not forget this when you define a composite component, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- INTERFACE --&gt;
&lt;cc:interface&gt;
 &lt;cc:attribute name="labelvalue"/&gt;
 &lt;cc:attribute name="imgvalue"/&gt;
&lt;/cc:interface&gt;

&lt;!-- IMPLEMENTATION --&gt;
&lt;cc:implementation&gt;
 &lt;h:outputLabel for="img" value="#{cc.attrs.labelvalue}"/&gt;
 &lt;h:graphicImage id="img" value="#{cc.attrs.imgvalue}"/&gt;
&lt;/cc:implementation&gt;</pre></div><p>And, you try to use it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:panelGrid columns="2" border="1"&gt;
 &lt;t:pg labelvalue="SMILEY" 
       imgvalue="#{resource['default/images:smiley.gif']}"/&gt;              
 &lt;t:pg labelvalue="SAD SMILE" 
       imgvalue="#{resource['default/images:sad_smile.gif']}"/&gt;              
&lt;/h:panelGrid&gt;</pre></div><p>If you forgot about the top-level component, you probably expect to see something like the  left-hand side of the following screenshot, while in reality, you will see something like the right-hand side of the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_10_04.jpg" alt="Top-level component's pitfall"/></div><p>This is normal, since <code class="literal">&lt;h:panelGrid&gt;</code> perceives the composite component as a whole. All components<a id="id1358" class="indexterm"/> that define the composite component are the children of the top-level component and are invisible to <code class="literal">&lt;h:panelGrid&gt;</code>.</p><p>The complete example is named <code class="literal">ch10_15</code>.</p></div></div><div class="section" title="Distributing composite components as JARs in JSF 2.2"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec120"/>Distributing composite components as JARs in JSF 2.2</h2></div></div></div><p>As of JSF 2, we can add composite<a id="id1359" class="indexterm"/> components in custom tag libraries (taglibs). After placing the composite component artifacts in the correct <a id="id1360" class="indexterm"/>folders, we need to write a file of type (this filename should be suffixed with <code class="literal">taglib.xml</code>), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;facelet-taglib version="2.0"&gt;
 &lt;namespace&gt;<span class="strong"><strong>http://</strong></span><span class="emphasis"><em>some</em></span><span class="strong"><strong>/</strong></span><span class="emphasis"><em>namespace</em></span>&lt;/namespace&gt;
 &lt;composite-library-name&gt;
<span class="emphasis"><em>library_name</em></span>
 &lt;/composite-library-name&gt;
&lt;/facelet-taglib&gt;</pre></div><p>Based on this <a id="id1361" class="indexterm"/>file's content, and more precisely on <code class="literal">&lt;composite-library-name&gt;</code>, JSF 2 detects the composite components belonging to this library. This means that the composite components mapped in this JAR must come from this library only.</p><p>As of JSF 2.2, this restriction doesn't exist anymore, and we can add, in the same JAR, composite components that come from different libraries.</p><p>Let's see an example! Suppose that we want to add in the same JAR the Temperature component (developed in application <code class="literal">ch10_8</code>) and the Range-slider component (developed in application <code class="literal">ch10_11</code>). The JAR will be named <code class="literal">jsfcc.jar</code>. The steps for accomplishing this are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an empty JAR named <code class="literal">jsfcc.jar</code>.</li><li class="listitem">In <code class="literal">jsfcc.jar</code>, create the folder <code class="literal">META-INF/resources</code>.</li><li class="listitem">Copy the libraries that contain the composite components in <code class="literal">META-INF/resources</code> (copy the <code class="literal">resources/temperature</code> folder from the application <code class="literal">ch10_8</code> and <code class="literal">resources/range-slider</code> from the application <code class="literal">ch10_11</code>).</li><li class="listitem">For the Temperature composite <a id="id1362" class="indexterm"/>component, copy the classes <code class="literal">book.beans.TempConvertClient.class</code> and <code class="literal">book.beans.TempConvertComponent.class</code> under the JAR root.</li><li class="listitem">Create an empty <code class="literal">faces-config.xml</code> file and place it under the <code class="literal">META-INF</code> folder as follows:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;faces-config 
 
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
       http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
       version="2.2"&gt;
&lt;/faces-config&gt;</pre></div></li><li class="listitem">Create the following <code class="literal">cc.taglib.xml</code> file and place it under the <code class="literal">META-INF</code> folder. Notice that we don't need a <code class="literal">&lt;composite-library-name&gt;</code> tag, and we have configured both composite components<a id="id1363" class="indexterm"/> under the same<a id="id1364" class="indexterm"/> namespace, <a class="ulink" href="http://jsf/cc/packt/taglib">http://jsf/cc/packt/taglib</a>. Using this example, it is very easy to define more components as follows:<div class="informalexample"><pre class="programlisting">&lt;facelet-taglib version="2.2"
    
    
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaeehttp://xmlns.jcp.org/xml/ns/javaee/web-facelettaglibrary_2_2.xsd"

 &lt;namespace&gt;http://jsf/cc/packt/taglib&lt;/namespace&gt;
 &lt;tag&gt;    
  &lt;tag-name&gt;range-slider&lt;/tag-name&gt;
   &lt;component&gt;
    &lt;resource-id&gt;
     resources/range-slider/range-slider.xhtml
    &lt;/resource-id&gt;      
   &lt;/component&gt;
 &lt;/tag&gt;  
 &lt;tag&gt;
  &lt;tag-name&gt;temperature&lt;/tag-name&gt;
   &lt;component&gt;
    &lt;resource-id&gt;
     resources/temperature/temperature.xhtml
    &lt;/resource-id&gt;
   &lt;/component&gt;
 &lt;/tag&gt;
&lt;/facelet-taglib&gt;</pre></div></li><li class="listitem">In the following screenshot, you can see how the JAR structure should look:<div class="mediaobject"><img src="graphics/6466EN_10_05.jpg" alt="Distributing composite components as JARs in JSF 2.2"/></div></li></ol></div><p>Specially for testing <code class="literal">jsfcc.jar</code>, you can run<a id="id1365" class="indexterm"/> the application <code class="literal">ch10_21</code>. Notice that even if NetBeans doesn't recognize the tags of the composite components, they<a id="id1366" class="indexterm"/> work like <a id="id1367" class="indexterm"/>a charm.</p></div><div class="section" title="Adding composite components programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec121"/>Adding composite components programmatically</h2></div></div></div><p>The last section in<a id="id1368" class="indexterm"/> this chapter discusses adding composite components programmatically. Before JSF 2.2, there wasn't any official API for instantiating composite components as a Java instance via user code. But, there were at least two facile options for unofficially accomplishing this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Components.includeCompositeComponent</code> method available in OmniFaces<a id="id1369" class="indexterm"/> from JSF Version 1.5 onwards (<a class="ulink" href="https://code.google.com/p/omnifaces/">https://code.google.com/p/omnifaces/</a>).</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Components.includeCompositeComponent</code> source code as an inspiration to write your own implementation. This kind of implementation is listed in the complete application named <code class="literal">ch10_23</code>. In that application, you can see how to programmatically add in a page the Welcome and Temperature composite components (you need to pass to the <code class="literal">addCompositeComponent</code> method<a id="id1370" class="indexterm"/> the following data: the composite component parent, the library name and path, and a unique ID).</li></ul></div><p>As of JSF 2.2, we can use an explicit API for instantiating composite components programmatically. The core of this API is based on the new <code class="literal">createComponent</code> method added in the <code class="literal">ViewDeclarationLanguage</code> class. The signature<a id="id1371" class="indexterm"/> of this method is as follows:</p><div class="informalexample"><pre class="programlisting">public UIComponent createComponent(FacesContext context, String taglibURI, String tagName, Map&lt;String,Object&gt; attributes)</pre></div><p>Besides <code class="literal">FacesContext</code>, you need to pass the tag library URI, the tag name, and the tag's attributes, or <code class="literal">null</code>, if there are no attributes. For example, the Welcome component can be added via this API as follows (we append the Welcome component to a <code class="literal">&lt;h:panelGroup&gt;</code> with the <code class="literal">welcomeId</code> ID):</p><div class="informalexample"><pre class="programlisting">public void addWelcomeCompositeComponent() {
 FacesContext context = FacesContext.getCurrentInstance();
 ViewDeclarationLanguage vdl = context.getApplication().getViewHandler().getViewDeclarationLanguage(context,
  context.getViewRoot().getViewId());

 Map&lt;String, Object&gt; attributes = new HashMap&lt;&gt;();
 attributes.put("value", createValueExpression("#{welcomeBean.value}",  
  java.lang.String.class).getExpressionString());
 attributes.put("to", createValueExpression("#{welcomeBean.to}", 
  java.lang.String.class).getExpressionString());

 UINamingContainer welcomeComponent = (UINamingContainer) 
  vdl.createComponent(context, "http://xmlns.jcp.org/jsf/composite/customs", "welcome", attributes);
 UIComponent parent = context.getViewRoot().findComponent("welcomeId");
 welcomeComponent.setId(parent.getClientId(context) + "_" + "welcomeMsgId");
 parent.getChildren().add(welcomeComponent);
}</pre></div><p>The complete application is named <code class="literal">ch10_27_1</code>.</p><p>A side-effect of this API includes the fact that it <a id="id1372" class="indexterm"/>allows us to add regular components also. For example, you can append an <code class="literal">UIOutput</code> component to <code class="literal">&lt;h:panelGroup&gt;</code> with the <code class="literal">myPlayerId</code> ID, as follows:</p><div class="informalexample"><pre class="programlisting">public void addComponent() {
 FacesContext context = FacesContext.getCurrentInstance();
 ViewDeclarationLanguage vdl = context.getApplication().getViewHandler().getViewDeclarationLanguage(context,
  context.getViewRoot().getViewId());
        
 Map&lt;String, Object&gt; attributes = new HashMap&lt;&gt;();       
 attributes.put("value", createValueExpression("#{playersBean.player}", java.lang.String.class).getExpressionString());
 UIOutput outputTextComponent = (UIOutput) vdl.createComponent(context, 
  "http://java.sun.com/jsf/html", "outputText", attributes);

 UIComponent parent = context.getViewRoot().findComponent("myPlayerId");
 outputTextComponent.setId(parent.getClientId(context) + 
  "_" + "nameId_"+ new Date().getTime());
 parent.getChildren().clear();
 parent.getChildren().add(outputTextComponent);
}</pre></div><p>The complete <a id="id1373" class="indexterm"/>application is named <code class="literal">ch10_27_2</code>. In <a class="link" href="ch12.html" title="Chapter 12. Facelets Templating">Chapter 12</a>, <span class="emphasis"><em>Facelets Templating</em></span>, you can see an example of adding <code class="literal">&lt;ui:include&gt;</code> using this API.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Summary</h1></div></div></div><p>In this chapter, you saw at work one of the greatest facilities of JSF. The custom and composite components feature represents the way how JSF expresses the respect for its developers. Writing custom/composite components is definitely a mandatory test of each JSF developer, since the difference between an ordinary and an extraordinary component resides in his skills. I hope that, next to many other books and tutorials about JSF custom/composite components, you have found this chapter as an interesting dissertation about this wide topic.</p><p>As a final note of this chapter, we have to apologize to all JSP fans who felt ignored in this chapter by the fact that we did not mention anything about writing custom/composite components compatible with JSP. As you know, such components can be made compatible with JSP via tag classes (not tag handlers), but JSP was deprecated as of JSF 2. I think that this is a plausible excuse for not covering or even mentioning JSP.</p><p>See you in the next chapter, where we will explore the new JSF 2.2 themes!</p></div></body></html>