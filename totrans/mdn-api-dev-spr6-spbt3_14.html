<html><head></head><body>
<div id="_idContainer070">
<h1 class="chapter-number" id="_idParaDest-314"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-315"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.2.1">GraphQL API Development and Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about the fundamental concepts of GraphQL. </span><span class="koboSpan" id="kobo.3.2">You are going to use that knowledge to develop and test GraphQL-based APIs in this chapter. </span><span class="koboSpan" id="kobo.3.3">You will implement GraphQL-based APIs for a sample application in this chapter. </span><span class="koboSpan" id="kobo.3.4">The GraphQL server</span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.4.1"> implementation will be developed based on a </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">design-first</span></strong><span class="koboSpan" id="kobo.6.1"> approach, the way you defined the OpenAPI specification in </span><a href="B19349_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">API Specifications and Implementation</span></em><span class="koboSpan" id="kobo.10.1">, and designed the schema in </span><a href="B19349_11.xhtml#_idTextAnchor250"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">gRPC API Development </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">and Testing</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">After completing this chapter, you will have learned how to practically implement the GraphQL concepts learned about in the previous chapter and about the implementation of the GraphQL server using Java and Spring and </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">its testing.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Workflow and tooling </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">for GraphQL</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">GraphQL server</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Documenting APIs</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Test automation</span></span></li>
</ul>
<h1 id="_idParaDest-316"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">The code for this chapter is </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">available at</span></span></p>
<p> <a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14</span></span></a></p>
<h1 id="_idParaDest-317"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.30.1">Workflow and tooling for GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.31.1">As per the data graph (data structure) way of thinking in GraphQL, data is exposed using an API consisting</span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.32.1"> of graphs of objects. </span><span class="koboSpan" id="kobo.32.2">These</span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.33.1"> objects are connected using relations. </span><span class="koboSpan" id="kobo.33.2">GraphQL only exposes a single API endpoint. </span><span class="koboSpan" id="kobo.33.3">Clients query this endpoint, which uses a </span><em class="italic"><span class="koboSpan" id="kobo.34.1">single data graph</span></em><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">On top of that, the data graph may resolve</span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.36.1"> data from a single source, or multiple sources, by following the </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">OneGraph principle</span></strong><span class="koboSpan" id="kobo.38.1"> of GraphQL. </span><span class="koboSpan" id="kobo.38.2">These sources could be a database, legacy system, or services that expose data </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">using REST/gRPC/SOAP.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">The GraphQL server can be implemented in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">two ways:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Standalone GraphQL service</span></strong><span class="koboSpan" id="kobo.43.1">: A standalone GraphQL service contains a single data graph. </span><span class="koboSpan" id="kobo.43.2">It could</span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.44.1"> be a monolithic app</span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.45.1"> or based on a microservice architecture that fetches the data from single or multiple sources (having no </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">GraphQL API).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.47.1">Federated GraphQL services</span></strong><span class="koboSpan" id="kobo.48.1">: It’s very easy to query a single data graph for comprehensive</span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.49.1"> data fetching. </span><span class="koboSpan" id="kobo.49.2">However, enterprise applications</span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.50.1"> are made using multiple services; hence, you can’t have a single data graph unless you build a monolithic system. </span><span class="koboSpan" id="kobo.50.2">If you don’t build a monolithic system, then you will have multiple service-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">data graphs.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.52.1">This is where you make use</span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.53.1"> of federated GraphQL services. </span><span class="koboSpan" id="kobo.53.2">A federated GraphQL service contains a </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">single distributed graph</span></strong><span class="koboSpan" id="kobo.55.1"> exposed using a gateway. </span><span class="koboSpan" id="kobo.55.2">Clients call the gateway, which is an entry point into the system. </span><span class="koboSpan" id="kobo.55.3">The data graph is distributed among multiple services and each service can maintain its own development and release cycle independently. </span><span class="koboSpan" id="kobo.55.4">Having said that, federated GraphQL services still follow the OneGraph principle. </span><span class="koboSpan" id="kobo.55.5">Therefore, the client queries the single endpoint to fetch any part of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the graph.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Let’s assume that a sample e-commerce app is developed using GraphQL federated services. </span><span class="koboSpan" id="kobo.57.2">It has products, orders, shipping, inventory, customers, and other services that expose the domain-specific data graphs using the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">GraphQL API.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s look at a high-level diagram</span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.60.1"> of GraphQL federated e-commerce services, </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 14.1 – Federated GraphQL services" src="image/Figure_14.1_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 14.1 – Federated GraphQL services</span></p>
<p><span class="koboSpan" id="kobo.64.1">Let’s say the GraphQL client</span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.65.1"> queries for a list of the most ordered products with the least</span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.66.1"> inventory by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Gateway</span></strong><span class="koboSpan" id="kobo.68.1"> endpoint. </span><span class="koboSpan" id="kobo.68.2">This query may have fields from </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">Orders</span></strong><span class="koboSpan" id="kobo.70.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Products</span></strong><span class="koboSpan" id="kobo.72.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">Inventory</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">Each service is responsible for resolving only the respective part of a data graph. </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">Orders</span></strong><span class="koboSpan" id="kobo.76.1"> would resolve order-related data, </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Products</span></strong><span class="koboSpan" id="kobo.78.1"> would resolve product-related data, </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">Inventory</span></strong><span class="koboSpan" id="kobo.80.1"> would resolve inventory-related data, and so on. </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Gateway</span></strong><span class="koboSpan" id="kobo.82.1"> then consolidates the graph data and sends it back to </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">the clients.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">graphql-java</span></strong><span class="koboSpan" id="kobo.86.1"> library (</span><a href="https://www.graphql-java.com"><span class="koboSpan" id="kobo.87.1">https://www.graphql-java.com</span></a><span class="koboSpan" id="kobo.88.1">) provides the Java implementation</span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.89.1"> of the GraphQL specification. </span><span class="koboSpan" id="kobo.89.2">Its source code is available </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">at </span></span><a href="https://github.com/graphql-java/graphql-java"><span class="No-Break"><span class="koboSpan" id="kobo.91.1">https://github.com/graphql-java/graphql-java</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.92.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Spring provides a Spring Boot Starter project for GraphQL based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">graphql-java</span></strong><span class="koboSpan" id="kobo.95.1">, available at </span><a href="https://github.com/spring-projects/spring-graphql"><span class="koboSpan" id="kobo.96.1">https://github.com/spring-projects/spring-graphql</span></a><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">However, we are going to use the Spring-based Netflix </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Domain Graph Service</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">DGS</span></strong><span class="koboSpan" id="kobo.101.1">) framework (</span><a href="https://netflix.github.io/dgs"><span class="koboSpan" id="kobo.102.1">https://netflix.github.io/dgs</span></a><span class="koboSpan" id="kobo.103.1">) because the Netflix DGS</span><a id="_idIndexMarker1249"/><span class="koboSpan" id="kobo.104.1"> provides not only the GraphQL Spring Boot starter but also the full set of tools and libraries that you need to develop production-ready GraphQL services. </span><span class="koboSpan" id="kobo.104.2">It is built on top of Spring Boot and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">graphql-java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> library.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">Netflix open sourced the DGS framework after using it in production in February 2021. </span><span class="koboSpan" id="kobo.107.2">It is continuously being enhanced and supported by the community. </span><span class="koboSpan" id="kobo.107.3">Netflix uses the same open sourced DGS framework</span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.108.1"> codebase in production environments, which gives</span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.109.1"> the assurance of the code’s quality and future maintenance. </span><span class="koboSpan" id="kobo.109.2">The OTT Disney+ platform was also built using the Netflix DGS </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">framework (</span></span><a href="https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&amp;cd=14&amp;hl=en&amp;ct=clnk&amp;gl=in&amp;client=firefox-b-d"><span class="No-Break"><span class="koboSpan" id="kobo.111.1">https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&amp;cd=14&amp;hl=en&amp;ct=clnk&amp;gl=in&amp;client=firefox-b-d</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.112.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">It provides</span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.114.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">following features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.116.1">A Spring Boot starter and integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">Spring Security</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">Full </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">WebFlux support</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">A Gradle plugin for code generation from a </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">GraphQL schema</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">Support for interfaces and union types, plus the provision of custom </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">scalar types</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">Support for GraphQL subscriptions using WebSocket and </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">server-sent events</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.126.1">Error handling</span></span></li>
<li><span class="koboSpan" id="kobo.127.1">Pluggable instrumentation and </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">Micrometer integration</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">GraphQL federated services with easy integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">GraphQL federation</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">Dynamic schemas with hot </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">reloading schemas</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.133.1">Operation caching</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.134.1">File upload</span></span></li>
<li><span class="koboSpan" id="kobo.135.1">GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">Java client</span></span></li>
<li><span class="koboSpan" id="kobo.137.1">GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">test</span></span><span class="No-Break"><a id="_idIndexMarker1253"/></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1"> framework</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.140.1">Let’s write a GraphQL server using Netflix’s DGS framework in the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">next section.</span></span></p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.142.1">Implementing the GraphQL server</span></h1>
<p><span class="koboSpan" id="kobo.143.1">You are going to develop</span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.144.1"> a standalone GraphQL server in this chapter. </span><span class="koboSpan" id="kobo.144.2">The knowledge you acquire while developing the standalone GraphQL server can be used to implement federated </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">GraphQL services.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Let’s create the Gradle project first in the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">next subsection.</span></span></p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.148.1">Creating the gRPC server project</span></h2>
<p><span class="koboSpan" id="kobo.149.1">Either you can use</span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.150.1"> the </span><a href="B19349_14.xhtml#_idTextAnchor313"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.151.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.152.1"> code by cloning the Git repository (</span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14"><span class="koboSpan" id="kobo.153.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14</span></a><span class="koboSpan" id="kobo.154.1">) or you can start by creating a new Spring project from scratch using Spring Initializr for the server and client with the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">following options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.156.1">Project</span></strong><span class="koboSpan" id="kobo.157.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Gradle - </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Groovy</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.160.1">Language</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Java</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Spring Boot</span></strong><span class="koboSpan" id="kobo.164.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">3.0.8</span></strong> </li>
</ul>
<p><span class="koboSpan" id="kobo.166.1">The preferred version is 3.0+; if not available, you can modify it later manually in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1"> file</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.169.1">Project Metadata</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">:</span></span><ul><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.171.1">Group</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">com.packt.modern.api</span></strong></span></li><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.174.1">Artifact</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">chapter14</span></strong></span></li><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.177.1">Name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">chapter14</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.180.1">Description</span></strong><span class="koboSpan" id="kobo.181.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Chapter 14 code of book Modern API Development with Spring and Spring Boot </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Ed 2</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.184.1">Package </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.185.1">name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">com.packt.modern.api</span></strong></span></li><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.188.1">Packaging</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">JAR</span></strong></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Java</span></strong><span class="koboSpan" id="kobo.192.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">17</span></strong> </li>
</ul>
<p><span class="koboSpan" id="kobo.194.1">You can change it to another version, such as 17/20/21, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">build.gradle</span></strong><span class="koboSpan" id="kobo.196.1"> file later, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
// update following build.gradle filesourceCompatibility = JavaVersion.VERSION_17
// or for Java 20
// sourceCompatibility = JavaVersion.VERSION_20
// or for Java 21
// sourceCompatibility = JavaVersion.VERSION_20</span></pre>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.199.1">Dependencies</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">org.springframework.boot:spring-boot-starter-web</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.202.1">Then, you can click on the </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">GENERATE</span></strong><span class="koboSpan" id="kobo.204.1"> button and download the project. </span><span class="koboSpan" id="kobo.204.2">The downloaded project</span><a id="_idIndexMarker1256"/><span class="koboSpan" id="kobo.205.1"> will be used to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">GraphQL server.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Next, let’s add the GraphQL DGS dependencies to the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">created project.</span></span></p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.209.1">Adding the GraphQL DGS dependencies</span></h2>
<p><span class="koboSpan" id="kobo.210.1">Once the Gradle project</span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.211.1"> is available, you can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">build.gradle</span></strong><span class="koboSpan" id="kobo.213.1"> file to include the GDS dependencies and plugin as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
 plugins {    id 'org.springframework.boot' version '3.0.6'
    id 'io.spring.dependency-management' version '1.1.0'
    id 'java'
    </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">id 'com.netflix.dgs.codegen' version '5.7.1'</span></strong><span class="koboSpan" id="kobo.217.1">
 }
 // code truncated for brevity
 def dgsVersion = '6.0.5'
 dependencies {
    </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">implementation platform("com.netflix.graphql.</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.219.1">        dgs:graphql-dgs-platform-dependencies:${</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.220.1">        dgsVersion}")</span></strong><span class="koboSpan" id="kobo.221.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">implementation 'com.netflix.graphql.dgs:graphql-dgs-</span></strong><span class="koboSpan" id="kobo.223.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">spring-boot-starter'</span></strong><span class="koboSpan" id="kobo.225.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">implementation 'com.netflix.graphql.dgs:graphql-dgs-</span></strong><span class="koboSpan" id="kobo.227.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">extended-scalars'</span></strong><span class="koboSpan" id="kobo.229.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">implementation 'com.netflix.graphql.dgs:graphql-dgs-</span></strong><span class="koboSpan" id="kobo.231.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">spring-boot-micrometer'</span></strong><span class="koboSpan" id="kobo.233.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">runtimeOnly 'com.netflix.graphql.dgs:graphql-dgs-</span></strong><span class="koboSpan" id="kobo.235.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">subscriptions-websockets-autoconfigure'</span></strong><span class="koboSpan" id="kobo.237.1">
    implementation 'org.springframework.boot:spring-boot-
        starter-web'
    implementation 'org.springframework.boot:spring-boot-
        starter-actuator'
    testImplementation 'org.springframework.boot:
        spring-boot-starter-test'
    </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">implementation 'net.datafaker:datafaker:1.9.0'</span></strong><span class="koboSpan" id="kobo.239.1">
 }</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle"><span class="No-Break"><span class="koboSpan" id="kobo.240.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle</span></span></a></p>
<p><span class="koboSpan" id="kobo.241.1">Here, first, the DGS Codegen plugin</span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.242.1"> is added, which will generate the code from the GraphQL schema file. </span><span class="koboSpan" id="kobo.242.2">Next, the following five dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">are added:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">graphql-dgs-platform-dependencies</span></strong><span class="koboSpan" id="kobo.245.1">: The DGS platform dependencies for the DGS bill of </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">materials (BOM)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">graphql-dgs-spring-boot-starter</span></strong><span class="koboSpan" id="kobo.248.1">: The DGS Spring Boot Starter library for DGS </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">Spring support</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">graphql-dgs-extended-scalars</span></strong><span class="koboSpan" id="kobo.251.1">: The DGS extended scalars library for custom </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">scalar types</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">graphql-dgs-spring-boot-micrometer</span></strong><span class="koboSpan" id="kobo.254.1">: The DGS library to provide integration with Micrometer to provide support for metrics and instrumentation along with </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">Spring Actuator</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">graphql-dgs-subscriptions-websockets-autoconfigure</span></strong><span class="koboSpan" id="kobo.257.1">: To provide the autoconfiguration for GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">WebSocket support</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.259.1">Please note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">datafaker</span></strong><span class="koboSpan" id="kobo.261.1"> library</span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.262.1"> is used here to generate the domain </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">seed data.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Next, let’s configure the DGS Codegen plugin in the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">build.gradle</span></strong><span class="koboSpan" id="kobo.266.1"> file as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
 generateJava {     generateClient = true
     packageName = "com.packt.modern.api.generated"
 }</span></pre>
<p><span class="koboSpan" id="kobo.269.1">You have configured the following two properties of DGS Codegen using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">generateJava</span></strong><span class="koboSpan" id="kobo.271.1"> task, which uses the Gradle plugin </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">com.netflix.graphql.dgs.codegen.GenerateJavaTask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1"> class:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">generateClient</span></strong><span class="koboSpan" id="kobo.275.1">: This determines whether you would like to generate the client </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">or not</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">packageName</span></strong><span class="koboSpan" id="kobo.278.1">: The Java package name of the generated </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">Java classes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.280.1">The DGS Codegen plugin picks GraphQL schema files from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">src/main/resources/schema</span></strong><span class="koboSpan" id="kobo.282.1"> directory by default. </span><span class="koboSpan" id="kobo.282.2">However, you can modify it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">schemaPaths</span></strong><span class="koboSpan" id="kobo.284.1"> property, which accepts an array. </span><span class="koboSpan" id="kobo.284.2">You can add this property to the previous code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">generateTask</span></strong><span class="koboSpan" id="kobo.286.1"> along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">packageName</span></strong><span class="koboSpan" id="kobo.288.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">generateClient</span></strong><span class="koboSpan" id="kobo.290.1"> if you want to change the default schema location, as </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">shown next:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.292.1">schemaPaths</span></strong><span class="koboSpan" id="kobo.293.1"> = ["${projectDir}/src/main/resources/schema"]</span></pre> <p><span class="koboSpan" id="kobo.294.1">You can also configure type mappings as you did for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">org.hidetake.swagger. </span><span class="koboSpan" id="kobo.295.2">generator</span></strong><span class="koboSpan" id="kobo.296.1"> Gradle plugin while generating the Java code from OpenAPI specs in </span><em class="italic"><span class="koboSpan" id="kobo.297.1">step 4</span></em><span class="koboSpan" id="kobo.298.1"> of the </span><em class="italic"><span class="koboSpan" id="kobo.299.1">Converting OAS to Spring code</span></em><span class="koboSpan" id="kobo.300.1"> section in </span><a href="B19349_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.301.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.302.1">, </span><em class="italic"><span class="koboSpan" id="kobo.303.1">API Specifications and Implementation</span></em><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">To add a custom type mapping, you can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">typeMapping</span></strong><span class="koboSpan" id="kobo.306.1"> property to the plugin task, as </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
 typeMapping = ["GraphQLType": "mypackage.JavaType"]</span></pre> <p><span class="koboSpan" id="kobo.309.1">This property accepts</span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.310.1"> an array; you can add one or more type mappings here. </span><span class="koboSpan" id="kobo.310.2">You can refer to the plugin documentation at </span><a href="https://netflix.github.io/dgs/generating-code-from-schema/"><span class="koboSpan" id="kobo.311.1">https://netflix.github.io/dgs/generating-code-from-schema/</span></a><span class="koboSpan" id="kobo.312.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">more</span></span><span class="No-Break"><a id="_idIndexMarker1261"/></span><span class="No-Break"><span class="koboSpan" id="kobo.314.1"> information.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Let’s add the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">schema next.</span></span></p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.317.1">Adding the GraphQL schema</span></h2>
<p><span class="koboSpan" id="kobo.318.1">Netflix’s DGS supports</span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.319.1"> both the code-first and design-first approaches. </span><span class="koboSpan" id="kobo.319.2">However, we are going to use the design-first approach in this chapter as we have done throughout this book. </span><span class="koboSpan" id="kobo.319.3">Therefore, first, we’ll design the schema using the GraphQL schema language and then use the generated code to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">GraphQL APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">We are going to keep the domain objects minimal to reduce the complexity of business logic and keep the focus on the GraphQL server implementation. </span><span class="koboSpan" id="kobo.321.2">Therefore, you’ll have just two domain objects – </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Product</span></strong><span class="koboSpan" id="kobo.323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Tag</span></strong><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">The GraphQL schema allows the following operation using its endpoint as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">schema definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
type </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">Query</span></strong><span class="koboSpan" id="kobo.329.1"> {    products(filter: ProductCriteria): [Product]!
</span><span class="koboSpan" id="kobo.329.2">    product(id: ID!): Product
}
type </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">Mutation</span></strong><span class="koboSpan" id="kobo.331.1"> {
    addTag(productId: ID!, tags: [TagInput!]!): Product
    addQuantity(productId: ID!, quantity: Int!): Product
}
type </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">Subscription</span></strong><span class="koboSpan" id="kobo.333.1"> {
    quantityChanged: Product
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/schema/schema.graphqls"><span class="No-Break"><span class="koboSpan" id="kobo.334.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/schema/schema.graphqls</span></span></a></p>
<p><span class="koboSpan" id="kobo.335.1">You need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">schema.graphqls</span></strong><span class="koboSpan" id="kobo.337.1"> GraphQL schema file at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">src/main/ resources/schema</span></strong><span class="koboSpan" id="kobo.339.1"> location. </span><span class="koboSpan" id="kobo.339.2">You can</span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.340.1"> have multiple schema files there to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">schema module-wise.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Here, the following root types have </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">been exposed:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Query</span></strong><span class="koboSpan" id="kobo.345.1">: The product and product queries to fetch a product by its ID, and a collection of products matched by the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">given criteria.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">Mutation</span></strong><span class="koboSpan" id="kobo.348.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">addTag</span></strong><span class="koboSpan" id="kobo.350.1"> mutation adds a tag to the product that matches the given ID. </span><span class="koboSpan" id="kobo.350.2">Another mutation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">addQuantity</span></strong><span class="koboSpan" id="kobo.352.1">, increases the product quantity. </span><span class="koboSpan" id="kobo.352.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">addQuantity</span></strong><span class="koboSpan" id="kobo.354.1"> mutation can also be used as an event that triggers the </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">subscription publication.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Subscription</span></strong><span class="koboSpan" id="kobo.357.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">quantityChanged</span></strong><span class="koboSpan" id="kobo.359.1"> subscription publishes the product where the quantity has been updated. </span><span class="koboSpan" id="kobo.359.2">The event quantity change is captured through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">addQuantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.361.1"> mutation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.362.1">Let’s add the object types and input types being used in these root types to </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">schema. </span><span class="koboSpan" id="kobo.363.2">graphqls</span></strong><span class="koboSpan" id="kobo.364.1"> as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
 type Product {     id: String
     name: String
     description: String
     imageUrl: String
     price: </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">BigDecimal</span></strong><span class="koboSpan" id="kobo.368.1">
     count: Int
     tags: [Tag]
 }
 </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">input</span></strong><span class="koboSpan" id="kobo.370.1"> ProductCriteria {
     tags: [TagInput] = []
     name: String = ""
     page: Int = 1
     size: Int = 10
 }
 </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">input</span></strong><span class="koboSpan" id="kobo.372.1"> TagInput {
     name: String
 }
 type Tag {
     id: String
     name: String
 }</span></pre>
<p><span class="koboSpan" id="kobo.373.1">These are straightforward object</span><a id="_idIndexMarker1264"/><span class="koboSpan" id="kobo.374.1"> and input types. </span><span class="koboSpan" id="kobo.374.2">All fields of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ProductCriteria</span></strong><span class="koboSpan" id="kobo.376.1"> input type have been </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">kept optional.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">We have also used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">BigDecimal</span></strong><span class="koboSpan" id="kobo.380.1"> custom scalar type. </span><span class="koboSpan" id="kobo.380.2">Therefore, we need to first declare it in the schema. </span><span class="koboSpan" id="kobo.380.3">We can do that by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">BigDecimal</span></strong><span class="koboSpan" id="kobo.382.1"> to the end of the schema file, as </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">shown next:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.384.1">scalar BigDecimal</span></strong></pre> <p><span class="koboSpan" id="kobo.385.1">Next, you also need to map it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">java.math.BigDecimal</span></strong><span class="koboSpan" id="kobo.387.1"> in the code generator plugin. </span><span class="koboSpan" id="kobo.387.2">Let’s add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">build.gradle</span></strong><span class="koboSpan" id="kobo.389.1"> file as shown next (check the </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">highlighted line):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
generateJava {    generateClient = true
    packageName = "com.packt.modern.api.generated"
    </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">typeMapping = ["BigDecimal": "java.math.BigDecimal"]</span></strong><span class="koboSpan" id="kobo.393.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.394.1">After these changes, your project is ready to generate the GraphQL objects and client. </span><span class="koboSpan" id="kobo.394.2">You can run the following command from the project root directory to build </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the project:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.396.1">
 $ ./gradlew clean build</span></pre> <p><span class="koboSpan" id="kobo.397.1">This command will generate</span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.398.1"> the Java classes in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">build/generated</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">Before you start implementing the GraphQL root types, let’s discuss the custom scalar types in the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">next subsection.</span></span></p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.403.1">Adding custom scalar types</span></h2>
<p><span class="koboSpan" id="kobo.404.1">You are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">BigDecimal</span></strong><span class="koboSpan" id="kobo.406.1"> to capture the monetary</span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.407.1"> values. </span><span class="koboSpan" id="kobo.407.2">This is a custom</span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.408.1"> scalar type; therefore, you need to add this custom scalar to the code so that the DGS framework can pick it for serialization and deserialization. </span><span class="koboSpan" id="kobo.408.2">(You also need to add a mapping to the Gradle code </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">generator plugin.)</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">There are two ways to add the custom scalar type – by implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Coercing</span></strong><span class="koboSpan" id="kobo.412.1"> interface and by making use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">graphql-dgs-extended-scalars</span></strong><span class="koboSpan" id="kobo.414.1"> library. </span><span class="koboSpan" id="kobo.414.2">We are going to use the latter because it has fewer lines and the actual implementation is provided by the Netflix </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">DGS framework.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">The first, crude way of adding the scalar type is to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">graphql.schema.Coercing</span></strong><span class="koboSpan" id="kobo.418.1"> interface and annotate it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">@DgsScalar</span></strong><span class="koboSpan" id="kobo.420.1"> annotation. </span><span class="koboSpan" id="kobo.420.2">Here, you need to write the boiler plate </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">code yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Instead, we will opt for the second method, which involves using the scalar type provided by the DGS framework, which is well tested on production systems. </span><span class="koboSpan" id="kobo.422.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">graphql.schema.Coercing</span></strong><span class="koboSpan" id="kobo.424.1"> interface is provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">graphql-java</span></strong><span class="koboSpan" id="kobo.426.1"> library. </span><span class="koboSpan" id="kobo.426.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">DateTimeScalar</span></strong><span class="koboSpan" id="kobo.428.1"> scalar type is implemented using </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Coercing</span></strong><span class="koboSpan" id="kobo.430.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.432.1">@DgsScalar(name="DateTime")</span></strong><span class="koboSpan" id="kobo.433.1">public class </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">DateTimeScalar</span></strong><span class="koboSpan" id="kobo.435.1">
               </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">implements Coercing</span></strong><span class="koboSpan" id="kobo.437.1">&lt;LocalDateTime, String&gt; {
  </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">@Override</span></strong><span class="koboSpan" id="kobo.439.1">
  public String </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">serialize</span></strong><span class="koboSpan" id="kobo.441.1">(Object dataFetcherResult)
                throws CoercingSerializeException {
    if (dataFetcherResult instanceof LocalDateTime) {
      return ((LocalDateTime) dataFetcherResult)
            .format(DateTimeFormatter.ISO_DATE_TIME);
    } else {
      throw new CoercingSerializeException
          ("Invalid Dt Tm");
    }
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">@Override</span></strong><span class="koboSpan" id="kobo.443.1">
  public LocalDateTime </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">parseValue</span></strong><span class="koboSpan" id="kobo.445.1">(Object input)
        throws CoercingParseValueException {
    return LocalDateTime.parse(input.toString(),
        DateTimeFormatter.ISO_DATE_TIME);
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">@Override</span></strong><span class="koboSpan" id="kobo.447.1">
  public LocalDateTime </span><strong class="bold"><span class="koboSpan" id="kobo.448.1">parseLiteral</span></strong><span class="koboSpan" id="kobo.449.1">(Object input)
       throws CoercingParseLiteralException {
    if (input instanceof StringValue) {
      return LocalDateTime.parse(((StringValue) input)
          .getValue(), DateTimeFormatter.ISO_DATE_TIME);
    }
    throw new CoercingParseLiteralException
        ("Invalid Dt Tm");
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.450.1">Here, you have overridden the three methods – </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">serialize()</span></strong><span class="koboSpan" id="kobo.452.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">parseValue()</span></strong><span class="koboSpan" id="kobo.454.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">parseLiteral()</span></strong><span class="koboSpan" id="kobo.456.1"> – of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Coercing</span></strong><span class="koboSpan" id="kobo.458.1"> interface to implement serialization and parsing for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">DateTimeScalar</span></strong><span class="koboSpan" id="kobo.460.1"> custom </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">scalar type.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">However, you are going</span><a id="_idIndexMarker1268"/><span class="koboSpan" id="kobo.463.1"> to use the second</span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.464.1"> method – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">graphql-dgs-extended-scalars</span></strong><span class="koboSpan" id="kobo.466.1"> library – for registering new scalar types. </span><span class="koboSpan" id="kobo.466.2">This library has already been added in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">build.gradle</span></strong><span class="koboSpan" id="kobo.468.1"> file. </span><span class="koboSpan" id="kobo.468.2">Let’s make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">graphql-dgs-extended-scalars</span></strong><span class="koboSpan" id="kobo.470.1"> library to register the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">BigDecimalScaler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.472.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">Create a new Java file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">BigDecimalScaler.java</span></strong><span class="koboSpan" id="kobo.475.1"> and add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">to it:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.477.1">@DgsComponent</span></strong><span class="koboSpan" id="kobo.478.1">public class BigDecimalScalar {
  </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">@DgsRuntimeWiring</span></strong><span class="koboSpan" id="kobo.480.1">
  public RuntimeWiring.Builder addScalar(
      RuntimeWiring.Builder builder) {
    return builder.scalar(</span><strong class="bold"><span class="koboSpan" id="kobo.481.1">GraphQLBigDecimal</span></strong><span class="koboSpan" id="kobo.482.1">);
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java"><span class="No-Break"><span class="koboSpan" id="kobo.483.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.484.1">Here, you are making use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">DgsRuntimeWiring</span></strong><span class="koboSpan" id="kobo.486.1"> to add the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">GraphQLBigDecimal</span></strong><span class="koboSpan" id="kobo.488.1"> scalar provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">graphql-dgs-extended-scalars</span></strong><span class="koboSpan" id="kobo.490.1"> library. </span><span class="koboSpan" id="kobo.490.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">RuntimeWiring</span></strong><span class="koboSpan" id="kobo.492.1"> class comprises data fetchers, type resolvers, and custom scalars that are needed to wire together a functional </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">GraphQLSchema</span></strong><span class="koboSpan" id="kobo.494.1"> class. </span><span class="koboSpan" id="kobo.494.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">DgsRuntimeWiring</span></strong><span class="koboSpan" id="kobo.496.1"> annotation marks the method as runtime wiring. </span><span class="koboSpan" id="kobo.496.2">So, you can perform the customization before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">RuntimeWiring</span></strong><span class="koboSpan" id="kobo.498.1"> class gets executed. </span><span class="koboSpan" id="kobo.498.2">Basically, you are adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">GraphQLBigDecimal</span></strong><span class="koboSpan" id="kobo.500.1"> scalar type to </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">RuntimeWiring.Builder</span></strong><span class="koboSpan" id="kobo.502.1"> for runtime </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">wiring execution.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">BigDecimalScalar</span></strong><span class="koboSpan" id="kobo.506.1"> class is marked with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">@Dgs</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Component</span></strong><span class="koboSpan" id="kobo.509.1"> annotation. </span><span class="koboSpan" id="kobo.509.2">The DGS framework is an annotation-based Spring Boot programming model. </span><span class="koboSpan" id="kobo.509.3">The DGS framework provides these types of annotations (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">@DgsComponent</span></strong><span class="koboSpan" id="kobo.511.1">) for Spring Boot. </span><span class="koboSpan" id="kobo.511.2">A class marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">@DgsComponent</span></strong><span class="koboSpan" id="kobo.513.1"> is a DGS component as well as a regular </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">Spring component.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">Similarly, you have added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">DateTimeScalar</span></strong><span class="koboSpan" id="kobo.517.1"> type. </span><span class="koboSpan" id="kobo.517.2">The code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">DateTimeScalar</span></strong><span class="koboSpan" id="kobo.519.1"> scalar type is available </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java"><span class="No-Break"><span class="koboSpan" id="kobo.521.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.522.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">All the schema details</span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.524.1"> and its documentation can be explored using the GraphQL documentation</span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.525.1"> that is available in GraphiQL or similar tools. </span><span class="koboSpan" id="kobo.525.2">Let’s find out how you find the auto-generated </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">documentation next.</span></span></p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.527.1">Documenting APIs</span></h2>
<p><span class="koboSpan" id="kobo.528.1">You can use GraphiQL or a playground tool</span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.529.1"> that provides a graphical interface</span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.530.1"> to explore the GraphQL schema </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">and documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">On GraphiQL (</span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">http://localhost:8080/graphiql</span></strong><span class="koboSpan" id="kobo.534.1">, which can be started by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">jar</span></strong><span class="koboSpan" id="kobo.536.1"> built out of this chapter code), you can open the document explorer by clicking on the book icon available in the top-left corner of the page. </span><span class="koboSpan" id="kobo.536.2">Once you click on it, it will display </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">the documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">However, if you are looking for a static page, then you can use tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">graphdoc</span></strong><span class="koboSpan" id="kobo.540.1"> (</span><a href="https://github.com/2fd/graphdoc"><span class="koboSpan" id="kobo.541.1">https://github.com/2fd/graphdoc</span></a><span class="koboSpan" id="kobo.542.1">) to generate the static</span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.543.1"> documentation</span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.544.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">GraphQL APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">Next, let’s start implementing GraphQL root types. </span><span class="koboSpan" id="kobo.546.2">First, you are going to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">GraphQL queries.</span></span></p>
<h1 id="_idParaDest-324"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.548.1">Implementing GraphQL queries</span></h1>
<p><span class="koboSpan" id="kobo.549.1">Both the queries</span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.550.1"> we introduced in the schema in the previous section are straightforward. </span><span class="koboSpan" id="kobo.550.2">You pass a product ID to find a product identified by that ID – that’s the product query for you. </span><span class="koboSpan" id="kobo.550.3">Next, you pass the optional product criteria to find the products based on the given criteria; otherwise, products are returned based on the default values of the fields of </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">product criteria.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">In REST, you implemented the controller class in the </span><em class="italic"><span class="koboSpan" id="kobo.553.1">Implementing the OAS code interfaces</span></em><span class="koboSpan" id="kobo.554.1"> section of </span><a href="B19349_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.555.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.556.1">, </span><em class="italic"><span class="koboSpan" id="kobo.557.1">API Specifications and Implementation</span></em><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">You created a controller, passed the call to the service, and the service called the repository to fetch the data from the database. </span><span class="koboSpan" id="kobo.558.3">You are going to use the same design. </span><span class="koboSpan" id="kobo.558.4">However, you are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">ConcurrentHashMap</span></strong><span class="koboSpan" id="kobo.560.1"> in place of the database to simplify the code. </span><span class="koboSpan" id="kobo.560.2">This can also be used in your </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">automated tests.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Let’s create a repository class for that, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
public interface Repository {  Product getProduct(String id);
  List&lt;Product&gt; getProducts();
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java"><span class="No-Break"><span class="koboSpan" id="kobo.565.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.566.1">These are straightforward signatures for fetching the product and collection </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">of products.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">Let’s implement the newly created repository interface using </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">ConcurrentHashMap</span></strong><span class="koboSpan" id="kobo.570.1">, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.572.1">
@org.springframework.stereotype.Repositorypublic class InMemRepository implements Repository {
  private static final Map&lt;String, Product&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.573.1">productEntities</span></strong><span class="koboSpan" id="kobo.574.1"> = new ConcurrentHashMap&lt;&gt;();
  private static final Map&lt;String, Tag&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">tagEntities</span></strong><span class="koboSpan" id="kobo.576.1"> =
      new ConcurrentHashMap&lt;&gt;();
  // rest of the code is truncated</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java"><span class="No-Break"><span class="koboSpan" id="kobo.577.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.578.1">Here, you have created</span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.579.1"> two instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">ConcurrentHashMap</span></strong><span class="koboSpan" id="kobo.581.1"> for storing the products and tags. </span><span class="koboSpan" id="kobo.581.2">Let’s add the seed data to these maps using </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
public InMemRepository() {  Faker faker = new Faker();
  IntStream.range(0, faker.number()
      .numberBetween(20, 50)).forEach(number -&gt; {
    String tag = faker.book().genre();
    </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">tagEntities.putIfAbsent</span></strong><span class="koboSpan" id="kobo.585.1">(tag,
       Tag.newBuilder().id(UUID.randomUUID().toString())
         .name(tag).build());
  });
  IntStream.range(0, faker.number().numberBetween(4, 20))
    .forEach(number -&gt; {
      String id = String.format("a1s2d3f4-%d", number);
      String title = faker.book().title();
      List&lt;Tag&gt; tags = tagEntities.entrySet().stream()
        .filter(t -&gt; t.getKey().startsWith(
          faker.book().genre().substring(0, 1)))
        .map(Entry::getValue).collect(toList());
    if (tags.isEmpty()) {
     tags.add(tagEntities.entrySet().stream()
       .findAny().get().getValue());
    }
    Product product = Product.newBuilder().id(id).
</span><span class="koboSpan" id="kobo.585.2">        name(title)
      .description(faker.lorem().sentence())
      .count(faker.number().numberBetween(10, 100))
      .price(BigDecimal.valueOf(faker.number()
         .randomDigitNotZero()))
      .imageUrl(String.format("/images/%s.jpeg",
         title.replace(" ", "")))
      .tags(tags).build();
    </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">productEntities.put</span></strong><span class="koboSpan" id="kobo.587.1">(id, product);
  });
  // rest of the code is truncated</span></pre>
<p><span class="koboSpan" id="kobo.588.1">This code first generates the tags</span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.589.1"> and then stores them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">tagEntities</span></strong><span class="koboSpan" id="kobo.591.1"> map. </span><span class="koboSpan" id="kobo.591.2">The code also attaches the tags to new products before storing products in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">productEntities</span></strong><span class="koboSpan" id="kobo.593.1"> map. </span><span class="koboSpan" id="kobo.593.2">This has been done for development purposes only. </span><span class="koboSpan" id="kobo.593.3">You should use the database in </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">production applications.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">getProduct</span></strong><span class="koboSpan" id="kobo.597.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">getProducts</span></strong><span class="koboSpan" id="kobo.599.1"> methods are straightforward, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
@Overridepublic Product getProduct(String id) {
  if (Strings.isBlank(id)) {
    throw new RuntimeException("Invalid Product ID.");
  }
  Product product = productEntities.get(id);
  if (Objects.isNull(product)) {
    throw new RuntimeException("Product not found.");
  }
  return product;
}
@Override
public List&lt;Product&gt; getProducts() {
  return productEntities.entrySet().stream()
    .map(e -&gt; e.getValue()).collect(toList());
}</span></pre>
<p><span class="koboSpan" id="kobo.602.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">getProduct</span></strong><span class="koboSpan" id="kobo.604.1"> method performs the basic validations and returns the product. </span><span class="koboSpan" id="kobo.604.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">getProducts</span></strong><span class="koboSpan" id="kobo.606.1"> method simply returns the collection of products converted from </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">the map.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Now, you can add the service </span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.609.1">and its implementation. </span><span class="koboSpan" id="kobo.609.2">Let’s add the service interface as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
public interface ProductService {  Product getProduct(String id);
  List&lt;Product&gt; getProducts(ProductCriteria criteria);
  Product addQuantity(String productId, int qty);
  Publisher&lt;Product&gt; gerProductPublisher();
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java"><span class="No-Break"><span class="koboSpan" id="kobo.612.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.613.1">These service method implementations simply call the repository to fetch the data. </span><span class="koboSpan" id="kobo.613.2">Let’s add the implementation shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
@Servicepublic class ProductServiceImpl implements ProductService {
  private final Repository repository;
  public ProductServiceImpl(Repository repository) {
    this.repository = repository;
  }
  @Override
  public Product getProduct(String id) {
    return repository.getProduct(id);
  }
  // continue …</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java"><span class="No-Break"><span class="koboSpan" id="kobo.616.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.617.1">Here, the repository is injected</span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.618.1"> using </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">constructor injection.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">Let’s add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">getProducts()</span></strong><span class="koboSpan" id="kobo.622.1"> method also, which performs filtering based on given filtering criteria, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
@Overridepublic List&lt;Product&gt; getProducts(ProductCriteria criteria) {
  List&lt;Predicate&lt;Product&gt;&gt; predicates = new ArrayList&lt;&gt;(2);
  if (!Objects.isNull(criteria)) {
    if (Strings.isNotBlank(criteria.getName())) {
      Predicate&lt;Product&gt; namePredicate =
        p -&gt; p.getName().contains(criteria.getName());
      </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">predicates.add(namePredicate);</span></strong><span class="koboSpan" id="kobo.626.1">
    }
    if (!Objects.isNull(criteria.getTags()) &amp;&amp;
        !criteria.getTags().isEmpty()) {
      List&lt;String&gt; tags = criteria.getTags().stream()
        .map(ti -&gt; ti.getName()).collect(toList());
      Predicate&lt;Product&gt; tagsPredicate =
        p -&gt; p.getTags().stream().filter(
          t -&gt; tags.contains(t.getName())).count() &gt; 0;
      </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">predicates.add(tagsPredicate)</span></strong><span class="koboSpan" id="kobo.628.1">;
    }
  }
  if (predicates.isEmpty()) {
    return repository.getProducts();
  }
  return repository.getProducts().stream()
    .filter(p -&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">predicates.stream().allMatch(</span></strong><span class="koboSpan" id="kobo.630.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">pre -&gt; pre.test(p)))</span></strong><span class="koboSpan" id="kobo.632.1">.collect(toList());
}</span></pre>
<p><span class="koboSpan" id="kobo.633.1">This method first checks whether criteria</span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.634.1"> are given or not. </span><span class="koboSpan" id="kobo.634.2">If criteria are not given, then it calls the repository and returns all </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">the products.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">If criteria are given, then it creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">predicates</span></strong><span class="koboSpan" id="kobo.638.1"> list. </span><span class="koboSpan" id="kobo.638.2">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">predicates</span></strong><span class="koboSpan" id="kobo.640.1"> are then used to filter out the matching products</span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.641.1"> and return to the </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">calling function.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Now comes the most critical piece of GraphQL query implementation: writing the data fetchers. </span><span class="koboSpan" id="kobo.643.2">First, let’s write the data fetcher for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1"> query.</span></span></p>
<h1 id="_idParaDest-325"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.646.1">Writing fetchers for GraphQL queries</span></h1>
<p><span class="koboSpan" id="kobo.647.1">You are going to write</span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.648.1"> data fetchers</span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.649.1"> in this section. </span><span class="koboSpan" id="kobo.649.2">Data fetchers, as the name suggests, retrieve</span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.650.1"> the information from the source that is from a persistent store such as a database or a third-party API/document store. </span><span class="koboSpan" id="kobo.650.2">You will learn how to write data fetchers to retrieve a single field of data, a single object, and a collection </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">of objects.</span></span></p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.652.1">Writing the data fetcher for product</span></h2>
<p><span class="koboSpan" id="kobo.653.1">The data fetcher is a critical DSG component</span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.654.1"> for serving GraphQL requests that fetches</span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.655.1"> the data and the DSG internally resolves each of the fields. </span><span class="koboSpan" id="kobo.655.2">You mark them with the special </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">@DgsComponent</span></strong><span class="koboSpan" id="kobo.657.1"> DGS annotation. </span><span class="koboSpan" id="kobo.657.2">These are types of Spring components that the DGS framework scans and uses for </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">serving requests.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">Let’s create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">ProductDatafetcher.java</span></strong><span class="koboSpan" id="kobo.661.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">datafetchers</span></strong><span class="koboSpan" id="kobo.663.1"> package to represent a DGS data fetcher component. </span><span class="koboSpan" id="kobo.663.2">It will have a data fetcher method for serving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">product</span></strong><span class="koboSpan" id="kobo.665.1"> query. </span><span class="koboSpan" id="kobo.665.2">You can add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
@DgsComponentpublic class ProductDatafetcher {
  private final ProductService productService;
  public ProductDatafetcher(
      ProductService productService) {
    this.productService = productService;
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.668.1">@DgsData(parentType = DgsConstants.QUERY_TYPE,</span></strong><span class="koboSpan" id="kobo.669.1">
           </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">field = QUERY.Product)</span></strong><span class="koboSpan" id="kobo.671.1">
  public Product getProduct(@InputArgument("id") String id) {
    if (Strings.isBlank(id)) {
      new RuntimeException("Invalid Product ID.");
    }
    return </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">productService.getProduct(id)</span></strong><span class="koboSpan" id="kobo.673.1">;
  }
  // continue …</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java"><span class="No-Break"><span class="koboSpan" id="kobo.674.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.675.1">Here, you create a product</span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.676.1"> service bean injection using the constructor. </span><span class="koboSpan" id="kobo.676.2">This service</span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.677.1"> bean helps you to find the product based on the given </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">product ID.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">Two other important DGS framework annotations have been used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">getProduct</span></strong><span class="koboSpan" id="kobo.681.1"> method. </span><span class="koboSpan" id="kobo.681.2">Let’s understand what </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">they do:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">@DgsData</span></strong><span class="koboSpan" id="kobo.684.1">: This is a data fetcher annotation</span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.685.1"> that marks the method as the data fetcher. </span><span class="koboSpan" id="kobo.685.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">parentType</span></strong><span class="koboSpan" id="kobo.687.1"> property represents the type, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">field</span></strong><span class="koboSpan" id="kobo.689.1"> property represents the type’s (</span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">parentType</span></strong><span class="koboSpan" id="kobo.691.1">) field. </span><span class="koboSpan" id="kobo.691.2">Therefore, you can say that method will fetch the field of the </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">given type.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.693.1">You have set </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">Query</span></strong><span class="koboSpan" id="kobo.695.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">parentType</span></strong><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">field</span></strong><span class="koboSpan" id="kobo.699.1"> property is set as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">product</span></strong><span class="koboSpan" id="kobo.701.1"> query. </span><span class="koboSpan" id="kobo.701.2">Therefore, this method works as an entry point for the GraphQL query product call. </span><span class="koboSpan" id="kobo.701.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">@DsgData</span></strong><span class="koboSpan" id="kobo.703.1"> annotation properties are set using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">DgsConstants</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.705.1">constants class.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">DgsConstants</span></strong><span class="koboSpan" id="kobo.707.1"> is generated by the DGS Gradle plugin, which contains all the constant parts</span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.708.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">the schema.</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">@InputArgument</span></strong><span class="koboSpan" id="kobo.711.1">: This annotation allows you to capture the arguments passed</span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.712.1"> by the GraphQL requests. </span><span class="koboSpan" id="kobo.712.2">Here, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">id</span></strong><span class="koboSpan" id="kobo.714.1"> parameter is captured and assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">id</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.716.1">string variable.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.717.1">You can find the test cases related to this data fetcher method in the </span><em class="italic"><span class="koboSpan" id="kobo.718.1">Test </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.719.1">automation</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.720.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">Similarly, you can write</span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.722.1"> the data fetcher</span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.723.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">products</span></strong><span class="koboSpan" id="kobo.725.1"> query. </span><span class="koboSpan" id="kobo.725.2">Let’s code it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">next subsection.</span></span></p>
<h2 id="_idParaDest-327"><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.727.1">Writing the data fetcher for a collection of products</span></h2>
<p><span class="koboSpan" id="kobo.728.1">Let’s create a new</span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.729.1"> file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">ProductsDatafetcher.java</span></strong><span class="koboSpan" id="kobo.731.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">datafetchers</span></strong><span class="koboSpan" id="kobo.733.1"> package</span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.734.1"> to represent a DGS data fetcher component. </span><span class="koboSpan" id="kobo.734.2">It will have a data fetcher method for serving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">products</span></strong><span class="koboSpan" id="kobo.736.1"> query. </span><span class="koboSpan" id="kobo.736.2">You can add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
@DgsComponentpublic class ProductsDatafetcher {
  private ProductService service;
  public ProductsDatafetcher(ProductService service) {
    this.service = service;
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">@DgsData(</span></strong><span class="koboSpan" id="kobo.740.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">parentType</span></strong><span class="koboSpan" id="kobo.742.1"> = DgsConstants.QUERY_TYPE,
    </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">field</span></strong><span class="koboSpan" id="kobo.744.1"> = QUERY.Products
  )
  public </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">List&lt;Product&gt; getProducts</span></strong><span class="koboSpan" id="kobo.746.1">(@InputArgument("filter")
      ProductCriteria criteria) {
    return service.getProducts(criteria);
  }
 // continue …</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java"><span class="No-Break"><span class="koboSpan" id="kobo.747.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.748.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">getProducts()</span></strong><span class="koboSpan" id="kobo.750.1"> method does not look different from the data fetcher method returned for </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">getProduct()</span></strong><span class="koboSpan" id="kobo.752.1"> in the second-to-last code block. </span><span class="koboSpan" id="kobo.752.2">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">parentType</span></strong><span class="koboSpan" id="kobo.754.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">field</span></strong><span class="koboSpan" id="kobo.756.1"> properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">@DsgData</span></strong><span class="koboSpan" id="kobo.758.1"> indicate that this method will be used to fetch the collection of products for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">products</span></strong><span class="koboSpan" id="kobo.760.1"> query (note that we are using the plural </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">form here).</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">You are done with the GraphQL query</span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.763.1"> implementation. </span><span class="koboSpan" id="kobo.763.2">You can now test your changes. </span><span class="koboSpan" id="kobo.763.3">You need to build</span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.764.1"> the application before running the test. </span><span class="koboSpan" id="kobo.764.2">Let’s build the application using the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.766.1">
 $ gradlew clean build</span></pre> <p><span class="koboSpan" id="kobo.767.1">Once the build is done successfully, you can run the following command to run </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">the application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.769.1">
 $ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar</span></pre> <p><span class="koboSpan" id="kobo.770.1">The application should be running on the default port </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">8080</span></strong><span class="koboSpan" id="kobo.772.1"> if you have not made any changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">port settings.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">Now, you can open a browser window and open GraphiQL using the following URL: </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">http://localhost:8080/graphiql</span></strong><span class="koboSpan" id="kobo.776.1"> (part of the DGS framework). </span><span class="koboSpan" id="kobo.776.2">Change the host/port accordingly </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">if required.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">You can use the following query to fetch the collection </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">of products:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.780.1">
{  products(
    filter: {name: "His Dark Materials",
       tags: [{name: "Fantasy"}, {name: "Legend"}]}
  ) {
    id
    name
    price
    description
    tags {
      id
      name
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.781.1">Once you run the preceding</span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.782.1"> query, it will fetch the products </span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.783.1">matching the given criteria in </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">the filter.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.785.1"><img alt="Figure 14.2 – GraphQL query execution in the GraphiQL tool" src="image/Figure_14.2_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.786.1">Figure 14.2 – GraphQL query execution in the GraphiQL tool</span></p>
<p><span class="koboSpan" id="kobo.787.1">This will work great. </span><span class="koboSpan" id="kobo.787.2">However, what if you want to fetch the tags separately? </span><span class="koboSpan" id="kobo.787.3">You might have relations (such as orders with billing information) in objects that may be fetched from separate databases or services, or from two separate tables. </span><span class="koboSpan" id="kobo.787.4">In that case, you might want to add a field resolver</span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.788.1"> using the data </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">fetcher </span></span><span class="No-Break"><a id="_idIndexMarker1302"/></span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">method.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">Let’s add a field resolver using the data fetcher method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">next subsection.</span></span></p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.793.1">Writing the field resolver using the data fetcher method</span></h2>
<p><span class="koboSpan" id="kobo.794.1">So far, you don’t have</span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.795.1"> a separate data fetcher for fetching</span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.796.1"> the tags. </span><span class="koboSpan" id="kobo.796.2">You fetch the products, and it also fetches the tags for you because we are using a concurrent map that stores both queries’ data together. </span><span class="koboSpan" id="kobo.796.3">Therefore, first, you need to write a new data fetcher method for fetching the tags for a </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">given product.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">Let’s add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">tags()</span></strong><span class="koboSpan" id="kobo.800.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">ProductsDatafetcher</span></strong><span class="koboSpan" id="kobo.802.1"> class to fetch the tags, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">code block:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.804.1">@DgsData</span></strong><span class="koboSpan" id="kobo.805.1">(    </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">parentType</span></strong><span class="koboSpan" id="kobo.807.1"> = PRODUCT.TYPE_NAME,
    </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">field</span></strong><span class="koboSpan" id="kobo.809.1"> = PRODUCT.Tags
)
public </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">List&lt;Tags&gt; tags(String productId)</span></strong><span class="koboSpan" id="kobo.811.1"> {
  return tagService.fetch(productId);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java"><span class="No-Break"><span class="koboSpan" id="kobo.812.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.813.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">tags()</span></strong><span class="koboSpan" id="kobo.815.1"> method has a different set of values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">@DsgData</span></strong><span class="koboSpan" id="kobo.817.1"> properties. </span><span class="koboSpan" id="kobo.817.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">parentType</span></strong><span class="koboSpan" id="kobo.819.1"> property is not set to a root type like in earlier data fetcher methods, which were set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Query</span></strong><span class="koboSpan" id="kobo.821.1">. </span><span class="koboSpan" id="kobo.821.2">Instead, it is set to an object type – </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">Product</span></strong><span class="koboSpan" id="kobo.823.1">. </span><span class="koboSpan" id="kobo.823.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">field</span></strong><span class="koboSpan" id="kobo.825.1"> property is set </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">tags</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">This method will be called for fetching the tags for each individual product because it is a field resolver for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">tags</span></strong><span class="koboSpan" id="kobo.831.1"> field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">Product</span></strong><span class="koboSpan" id="kobo.833.1"> object. </span><span class="koboSpan" id="kobo.833.2">Therefore, if you have 20 products, this method will be called 20 times to fetch the tags for each of the 20 products. </span><span class="koboSpan" id="kobo.833.3">This is an </span><em class="italic"><span class="koboSpan" id="kobo.834.1">N+1</span></em><span class="koboSpan" id="kobo.835.1"> problem, which we learned about in the </span><em class="italic"><span class="koboSpan" id="kobo.836.1">Solving the N+1 problem</span></em><span class="koboSpan" id="kobo.837.1"> section in </span><a href="B19349_13.xhtml#_idTextAnchor288"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.838.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.839.1">, </span><em class="italic"><span class="koboSpan" id="kobo.840.1">Getting Started </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.841.1">with GraphQL</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">In the N+1 problem, extra database calls are made for fetching the data for relations. </span><span class="koboSpan" id="kobo.843.2">Therefore, given a collection of products, it may hit a database for fetching the tags for each </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">product separately.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">You know that you must use data loaders</span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.846.1"> to avoid the N+1 problem. </span><span class="koboSpan" id="kobo.846.2">Data loaders</span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.847.1"> cache all the IDs of products before fetching their corresponding tags in a </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">single query.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">Next, let’s learn how to implement a data loader for fixing the N+1 problem in </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">this case.</span></span></p>
<h2 id="_idParaDest-329"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.851.1">Writing a data loader for solving the N+1 problem</span></h2>
<p><span class="koboSpan" id="kobo.852.1">You are going to make use</span><a id="_idIndexMarker1307"/><span class="koboSpan" id="kobo.853.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">DataFetchingEnvironment</span></strong><span class="koboSpan" id="kobo.855.1"> class as an argument</span><a id="_idIndexMarker1308"/><span class="koboSpan" id="kobo.856.1"> in the data fetcher methods. </span><span class="koboSpan" id="kobo.856.2">It is injected by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">graphql-java</span></strong><span class="koboSpan" id="kobo.858.1"> library in the data fetcher methods to provide the execution context. </span><span class="koboSpan" id="kobo.858.2">This execution context contains information about the resolver, such as the object and its fields. </span><span class="koboSpan" id="kobo.858.3">You can also use them in special use cases such as loading the data </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">loader classes.</span></span></p>
<p><span class="koboSpan" id="kobo.860.1">Let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">tags()</span></strong><span class="koboSpan" id="kobo.862.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">ProductsDatafetcher</span></strong><span class="koboSpan" id="kobo.864.1"> class mentioned in the previous code block to fetch the tags without the N+1 problem, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.866.1">
 @DgsData(   parentType = PRODUCT.TYPE_NAME,
   field = PRODUCT.Tags
 )
 public </span><strong class="bold"><span class="koboSpan" id="kobo.867.1">CompletableFuture&lt;List&lt;Tags&gt;&gt;</span></strong><span class="koboSpan" id="kobo.868.1"> tags(
     </span><strong class="bold"><span class="koboSpan" id="kobo.869.1">DgsDataFetchingEnvironment</span></strong><span class="koboSpan" id="kobo.870.1"> env) {
   DataLoader&lt;String, List&lt;Tags&gt;&gt; tagsDataLoader =
       </span><strong class="bold"><span class="koboSpan" id="kobo.871.1">env.getDataLoader</span></strong><span class="koboSpan" id="kobo.872.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.873.1">TagsDataloaderWithContext.class</span></strong><span class="koboSpan" id="kobo.874.1">);
   Product product = env.getSource();
   return </span><strong class="bold"><span class="koboSpan" id="kobo.875.1">tagsDataLoader.load</span></strong><span class="koboSpan" id="kobo.876.1">(product.getId());
 }</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java"><span class="No-Break"><span class="koboSpan" id="kobo.877.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.878.1">Here, the modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">tags()</span></strong><span class="koboSpan" id="kobo.880.1"> data fetcher method performs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">fetch</span></strong><span class="koboSpan" id="kobo.882.1"> method using a data loader and returns</span><a id="_idIndexMarker1309"/><span class="koboSpan" id="kobo.883.1"> the collection of tags wrapped inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">CompletableFuture</span></strong><span class="koboSpan" id="kobo.885.1">. </span><span class="koboSpan" id="kobo.885.2">And it will be called only once even if the number of products</span><a id="_idIndexMarker1310"/><span class="koboSpan" id="kobo.886.1"> is more </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">than </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.888.1">1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.890.1">What is CompletableFuture?</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">CompletableFuture</span></strong><span class="koboSpan" id="kobo.892.1"> is a Java concurrency class</span><a id="_idIndexMarker1311"/><span class="koboSpan" id="kobo.893.1"> that represents the result of asynchronous computation, which is marked as completed explicitly. </span><span class="koboSpan" id="kobo.893.2">It can chain multiple dependent tasks asynchronously where the next task will be triggered when the current task’s result </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.895.1">You are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">DsgDataFetchingEnvironment</span></strong><span class="koboSpan" id="kobo.897.1"> as an argument. </span><span class="koboSpan" id="kobo.897.2">It implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">DataFetchingEnvironment</span></strong><span class="koboSpan" id="kobo.899.1"> interface and provides ways to load the data loader class by both its class and name. </span><span class="koboSpan" id="kobo.899.2">Here, you are using the data loader class to load the </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">data loader.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">getSource()</span></strong><span class="koboSpan" id="kobo.903.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">DsgDataFetchingEnvironment</span></strong><span class="koboSpan" id="kobo.905.1"> returns the value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">parentType</span></strong><span class="koboSpan" id="kobo.907.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">@DsgData</span></strong><span class="koboSpan" id="kobo.909.1">. </span><span class="koboSpan" id="kobo.909.2">Therefore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">getSource()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.911.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.914.1">This modified data fetcher method will fetch the tags for a given list of products in a single call. </span><span class="koboSpan" id="kobo.914.2">This method will fetch the tags for a list of products because the data loader class implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">MappedBatchLoader</span></strong><span class="koboSpan" id="kobo.916.1">, which performs the operation </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">using batches.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">The data loader class fetches the tags of the given product (by ID) using the data loader in batches. </span><span class="koboSpan" id="kobo.918.2">The magic lies in returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">CompletableFuture</span></strong><span class="koboSpan" id="kobo.920.1">. </span><span class="koboSpan" id="kobo.920.2">Therefore, though you are passing a single product ID as an argument, the data loader processes it in bunches. </span><span class="koboSpan" id="kobo.920.3">Let’s implement this data loader class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">TagsDataloaderWithContext</span></strong><span class="koboSpan" id="kobo.922.1">) next to dig into </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">it more.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">You can create a data loader class in two ways – with context or without context. </span><span class="koboSpan" id="kobo.924.2">Data loaders without context implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">MappedBatchLoader</span></strong><span class="koboSpan" id="kobo.926.1">, which has the following </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">method signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.928.1">
 CompletionStage&lt;Map&lt;K, V&gt;&gt; load(Set&lt;K&gt; keys);</span></pre> <p><span class="koboSpan" id="kobo.929.1">On the other hand, data loaders with context implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">MappedBatchLoaderWithContext</span></strong><span class="koboSpan" id="kobo.931.1"> interface, which has the following </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">method signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.933.1">
 CompletionStage&lt;Map&lt;K, V&gt;&gt; load(Set&lt;K&gt; keys,                         BatchLoaderEnvironment environment);</span></pre>
<p><span class="koboSpan" id="kobo.934.1">Both are the same</span><a id="_idIndexMarker1312"/><span class="koboSpan" id="kobo.935.1"> as far as data loading is concerned. </span><span class="koboSpan" id="kobo.935.2">However, the data loader</span><a id="_idIndexMarker1313"/><span class="koboSpan" id="kobo.936.1"> with context provides you with extra information (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">BatchLoaderEnvironment</span></strong><span class="koboSpan" id="kobo.938.1">) that can be used for various additional features, such as authentication, authorization, or passing the </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">database details.</span></span></p>
<p><span class="koboSpan" id="kobo.940.1">Create a new Java file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">TagsDataloaderWithContext.java</span></strong><span class="koboSpan" id="kobo.942.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">dataloaders</span></strong><span class="koboSpan" id="kobo.944.1"> package with the </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.946.1">@DgsDataLoader</span></strong><span class="koboSpan" id="kobo.947.1">(name = "tagsWithContext")public class TagsDataloaderWithContext implements
          MappedBatchLoaderWithContext&lt;String, List&lt;Tag&gt;&gt; {
  private final TagService tagService;
  public TagsDataloaderWithContext(TagService tagService) {
    this.tagService = tagService;
  }
  @Override
  public CompletionStage&lt;Map&lt;String, List&lt;Tag&gt;&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.948.1">load</span></strong><span class="koboSpan" id="kobo.949.1">(
    Set&lt;String&gt; keys, </span><strong class="bold"><span class="koboSpan" id="kobo.950.1">BatchLoaderEnvironment environment</span></strong><span class="koboSpan" id="kobo.951.1">) {
    return </span><strong class="bold"><span class="koboSpan" id="kobo.952.1">CompletableFuture.supplyAsync</span></strong><span class="koboSpan" id="kobo.953.1">(() -&gt;
        tagService.getTags(new ArrayList&lt;&gt;(keys)));
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java"><span class="No-Break"><span class="koboSpan" id="kobo.954.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.955.1">Here, it implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">load()</span></strong><span class="koboSpan" id="kobo.957.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">MappedBatchLoaderWithContext</span></strong><span class="koboSpan" id="kobo.959.1"> interface. </span><span class="koboSpan" id="kobo.959.2">It contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">BatchLoaderEnvironment</span></strong><span class="koboSpan" id="kobo.961.1"> argument, which provides the environment</span><a id="_idIndexMarker1314"/><span class="koboSpan" id="kobo.962.1"> context, which can contain user authentication</span><a id="_idIndexMarker1315"/><span class="koboSpan" id="kobo.963.1"> and authorization information or database information. </span><span class="koboSpan" id="kobo.963.2">However, we are not using it because we don’t have any additional information related to authentication, authorization, or the database to pass to the repository or underlying data access layer. </span><span class="koboSpan" id="kobo.963.3">If you do, you can make use of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">environment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.965.1"> argument.</span></span></p>
<p><span class="koboSpan" id="kobo.966.1">You can also find the data loader without context at </span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java"><span class="koboSpan" id="kobo.967.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java</span></a><span class="koboSpan" id="kobo.968.1">. </span><span class="koboSpan" id="kobo.968.2">Its code is more or less like what we have written for the data loader with context. </span><span class="koboSpan" id="kobo.968.3">The only difference is we haven’t used </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">the context.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">You can see that it makes use of the tag’s service to fetch the tags. </span><span class="koboSpan" id="kobo.970.2">Then, it simply returns the completion stage by supplying the tags received from the tag service. </span><span class="koboSpan" id="kobo.970.3">This operation is performed in a batch by the </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">data loader.</span></span></p>
<p><span class="koboSpan" id="kobo.972.1">You can create a new tag service and its implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.974.1">
public interface TagService {  Map&lt;String, List&lt;Tag&gt;&gt; getTags(List&lt;String&gt; productIds);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java"><span class="No-Break"><span class="koboSpan" id="kobo.975.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.976.1">This is the signature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">getTags</span></strong><span class="koboSpan" id="kobo.978.1"> method, which returns the map of product IDs with </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">corresponding tags.</span></span></p>
<p><span class="koboSpan" id="kobo.980.1">Let’s implement</span><a id="_idIndexMarker1316"/><span class="koboSpan" id="kobo.981.1"> this interface</span><a id="_idIndexMarker1317"/><span class="koboSpan" id="kobo.982.1"> as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.984.1">
@Servicepublic class TagServiceImpl implements TagService {
  private final Repository repository;
  public TagServiceImpl(Repository repository) {
    this.repository = repository;
  }
  @Override
  public Map&lt;String, List&lt;Tag&gt;&gt; getTags(
       List&lt;String&gt; productIds) {
    return repository.getProductTagMappings(productIds);
  }
  @Override
  public Product addTags(
       String productId, List&lt;TagInput&gt; tags) {
    return repository.addTags(productId, tags);
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java"><span class="No-Break"><span class="koboSpan" id="kobo.985.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.986.1">Here, the implemented method</span><a id="_idIndexMarker1318"/><span class="koboSpan" id="kobo.987.1"> is straightforward. </span><span class="koboSpan" id="kobo.987.2">It passes the call to the repository, which fetches the tags</span><a id="_idIndexMarker1319"/><span class="koboSpan" id="kobo.988.1"> based on the passed collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">product IDs.</span></span></p>
<p><span class="koboSpan" id="kobo.990.1">You can add </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">getProductTagMappings</span></strong><span class="koboSpan" id="kobo.992.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">src/main/java/com/packt/ modern/api/repository/Repository.java</span></strong><span class="koboSpan" id="kobo.994.1"> interface as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">next line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.996.1">
Map&lt;String, List&lt;Tag&gt;&gt; getProductTagMappings(     List&lt;String&gt; productIds);</span></pre>
<p><span class="koboSpan" id="kobo.997.1">Then, you can implement this method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">src/main/java/com/packt/ modern/api/repository/InMemRepository.java</span></strong><span class="koboSpan" id="kobo.999.1"> class as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1001.1">
@Overridepublic Map&lt;String, List&lt;Tag&gt;&gt; getProductTagMappings(
     List&lt;String&gt; productIds) {
  return productEntities.entrySet().stream()
    .filter(e -&gt; productIds.contains(e.getKey()))
    .collect(toMap(e -&gt; e.getKey(),
       e -&gt; e.getValue().getTags()));
}</span></pre>
<p><span class="koboSpan" id="kobo.1002.1">Here, the code first creates the stream of the product map’s entry set, then filters the products that match the product passed in this method. </span><span class="koboSpan" id="kobo.1002.2">At the end, it converts filtered products to map the product ID with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">Key</span></strong><span class="koboSpan" id="kobo.1004.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">Tags</span></strong><span class="koboSpan" id="kobo.1006.1"> values and then </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">map</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1010.1">Now, if you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">product</span></strong><span class="koboSpan" id="kobo.1012.1"> GraphQL query, and even if products are fetched with a properly normalized database, it loads the product tags in batches without the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1013.1">N+1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1"> problem.</span></span></p>
<p><span class="koboSpan" id="kobo.1015.1">You are done with GraphQL query implementation and should be comfortable</span><a id="_idIndexMarker1320"/><span class="koboSpan" id="kobo.1016.1"> with implementing queries</span><a id="_idIndexMarker1321"/><span class="koboSpan" id="kobo.1017.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">your own.</span></span></p>
<p><span class="koboSpan" id="kobo.1019.1">Next, you are going to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">GraphQL mutations.</span></span></p>
<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.1021.1">Implementing GraphQL mutations</span></h1>
<p><span class="koboSpan" id="kobo.1022.1">As per the GraphQL schema, you are going to implement</span><a id="_idIndexMarker1322"/><span class="koboSpan" id="kobo.1023.1"> two mutations – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">addTag</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1025.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">addQuantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">addTag</span></strong><span class="koboSpan" id="kobo.1030.1"> mutation takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">productId</span></strong><span class="koboSpan" id="kobo.1032.1"> and a collection of tags as arguments and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">Product</span></strong><span class="koboSpan" id="kobo.1034.1"> object. </span><span class="koboSpan" id="kobo.1034.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1036.1"> mutation takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">productId</span></strong><span class="koboSpan" id="kobo.1038.1"> and the quantity to add and </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1042.1">Let’s add this implementation to the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">ProductDatafetcher</span></strong><span class="koboSpan" id="kobo.1044.1"> class as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
// rest of the ProductDatafetcher class code</span><strong class="bold"><span class="koboSpan" id="kobo.1047.1">@DgsMutation(field = MUTATION.AddTag)</span></strong><span class="koboSpan" id="kobo.1048.1">
public Product </span><strong class="bold"><span class="koboSpan" id="kobo.1049.1">addTags</span></strong><span class="koboSpan" id="kobo.1050.1">(
    @InputArgument("productId") String productId,
    </span><strong class="bold"><span class="koboSpan" id="kobo.1051.1">@InputArgument(value = "tags", collectionType =</span></strong><span class="koboSpan" id="kobo.1052.1">
         TagInput.class) List&lt;TagInput&gt; tags) {
  return tagService.addTags(productId, tags);
}
</span><strong class="bold"><span class="koboSpan" id="kobo.1053.1">@DgsMutation(field = MUTATION.AddQuantity)</span></strong><span class="koboSpan" id="kobo.1054.1">
public Product </span><strong class="bold"><span class="koboSpan" id="kobo.1055.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1056.1">(
      @InputArgument("productId") String productId,
      @InputArgument(value = "quantity") int qty) {
  return productService.addQuantity(productId, qty);
}
// rest of the ProductDatafetcher class code</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java"><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1058.1">Here, these signatures follow</span><a id="_idIndexMarker1323"/><span class="koboSpan" id="kobo.1059.1"> the respective mutations written in the GraphQL schema. </span><span class="koboSpan" id="kobo.1059.2">You are using another DGS framework </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">@DgsMutation</span></strong><span class="koboSpan" id="kobo.1061.1"> annotation, which is a type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">@DgsData</span></strong><span class="koboSpan" id="kobo.1063.1"> annotation that is marked on methods to denote them as a data fetcher method. </span><span class="koboSpan" id="kobo.1063.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">@DgsMutation</span></strong><span class="koboSpan" id="kobo.1065.1"> annotation, by default, has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">Mutation</span></strong><span class="koboSpan" id="kobo.1067.1"> value set to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">parentType</span></strong><span class="koboSpan" id="kobo.1069.1"> property. </span><span class="koboSpan" id="kobo.1069.2">You just must set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">field</span></strong><span class="koboSpan" id="kobo.1071.1"> property in this annotation. </span><span class="koboSpan" id="kobo.1071.2">Both methods have their respective values set to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">field</span></strong><span class="koboSpan" id="kobo.1073.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">DgsMutation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.1077.1">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">@InputArgument</span></strong><span class="koboSpan" id="kobo.1079.1"> annotation for tags uses another </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">collectionType</span></strong><span class="koboSpan" id="kobo.1081.1"> property that is used for setting the type of input. </span><span class="koboSpan" id="kobo.1081.2">It is required when the input type is not scalar. </span><span class="koboSpan" id="kobo.1081.3">If you don’t use it, you’ll get an error. </span><span class="koboSpan" id="kobo.1081.4">Therefore, make sure to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">collectionType</span></strong><span class="koboSpan" id="kobo.1083.1"> property whenever you have a non-scalar </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">type input.</span></span></p>
<p><span class="koboSpan" id="kobo.1085.1">These methods use the tag and product services to perform the requested operations. </span><span class="koboSpan" id="kobo.1085.2">So far, you have not added the tag service into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">ProductDatafetcher</span></strong><span class="koboSpan" id="kobo.1087.1"> class. </span><span class="koboSpan" id="kobo.1087.2">Therefore, you need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">TagService</span></strong><span class="koboSpan" id="kobo.1089.1"> first, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1091.1">
// rest of the ProductDatafetcher class codeprivate final </span><strong class="bold"><span class="koboSpan" id="kobo.1092.1">TagService tagService</span></strong><span class="koboSpan" id="kobo.1093.1">;
public ProductDatafetcher(ProductService productService,
     </span><strong class="bold"><span class="koboSpan" id="kobo.1094.1">TagService tagService</span></strong><span class="koboSpan" id="kobo.1095.1">) {
  this.productService = productService;
  </span><strong class="bold"><span class="koboSpan" id="kobo.1096.1">this.tagService = tagService</span></strong><span class="koboSpan" id="kobo.1097.1">;
}
// rest of the ProductDatafetcher class code</span></pre>
<p><span class="koboSpan" id="kobo.1098.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">TagService</span></strong><span class="koboSpan" id="kobo.1100.1"> bean has been injected using </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">the constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.1102.1">Now, you need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">addTag()</span></strong><span class="koboSpan" id="kobo.1104.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">TagService</span></strong><span class="koboSpan" id="kobo.1106.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1108.1"> methods in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">ProductService</span></strong><span class="koboSpan" id="kobo.1110.1">. </span><span class="koboSpan" id="kobo.1110.2">Both the interfaces and their implementations are straightforward and pass the call to the repository to perform the operations. </span><span class="koboSpan" id="kobo.1110.3">You can find the complete source code </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">TagService</span></strong><span class="koboSpan" id="kobo.1112.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">ProductService</span></strong><span class="koboSpan" id="kobo.1114.1"> classes in the GitHub code </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">repository (</span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services"><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1118.1">Let’s also add these two methods</span><a id="_idIndexMarker1324"/><span class="koboSpan" id="kobo.1119.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">Repository</span></strong><span class="koboSpan" id="kobo.1121.1"> interface as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1123.1">
 // rest of the Repository class code Product addTags(String productId, List&lt;TagInput&gt; tags);
 Product addQuantity(String productId, int qty);
 // rest of the Repository class code</span></pre>
<p><span class="koboSpan" id="kobo.1124.1">These signatures in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">src/main/java/com/packt/modern/api/repository /Repository.java</span></strong><span class="koboSpan" id="kobo.1126.1"> interface also follow the respective mutations written in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">GraphQL schema.</span></span></p>
<p><span class="koboSpan" id="kobo.1128.1">Let’s implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">addTags()</span></strong><span class="koboSpan" id="kobo.1130.1"> method first</span><a id="_idIndexMarker1325"/><span class="koboSpan" id="kobo.1131.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">src/main/java/com/packt/ modern/api/repository/InMemRepository.java</span></strong><span class="koboSpan" id="kobo.1133.1"> class, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1135.1">
@Overridepublic Product addTags(String productId, List&lt;TagInput&gt; tags) {
  if (Strings.isBlank(productId)) {
    throw new RuntimeException("Invalid Product ID.");
  }
  Product product = productEntities.get(productId);
  if (Objects.isNull(product)) {
    throw new RuntimeException("Product not found.");
  }
  if (tags != null &amp;&amp; !tags.isEmpty()) {
    List&lt;String&gt; newTags = tags.stream().map(
         t -&gt; t.getName()).collect(toList());
    List&lt;String&gt; existingTags = product.getTags().stream()
         .map(t -&gt; t.getName())
         .collect(toList());
    newTags.stream().forEach(nt -&gt; {
      if (!existingTags.contains(nt)) {
        product.getTags().add(Tag.newBuilder()
          .id(UUID.randomUUID().toString())
        .name(nt).build());
      }
    });
    productEntities.put(product.getId(), product);
  }
  return product;
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java"><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1137.1">Here, you first perform</span><a id="_idIndexMarker1326"/><span class="koboSpan" id="kobo.1138.1"> the validation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">productId</span></strong><span class="koboSpan" id="kobo.1140.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">tags</span></strong><span class="koboSpan" id="kobo.1142.1"> arguments. </span><span class="koboSpan" id="kobo.1142.2">If everything goes fine, then you add the tags to the product, update the concurrent map, and return the </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">updated product.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">You are done with the implementation of GraphQL mutations. </span><span class="koboSpan" id="kobo.1144.2">You can now test your changes. </span><span class="koboSpan" id="kobo.1144.3">You need to build the application before running the test. </span><span class="koboSpan" id="kobo.1144.4">Let’s build the application using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1146.1">
 $ gradlew clean build</span></pre> <p><span class="koboSpan" id="kobo.1147.1">Once the build is done successfully, you can run the following command to run </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">the application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1149.1">
 $ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar</span></pre> <p><span class="koboSpan" id="kobo.1150.1">The application should be running on default port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">8080</span></strong><span class="koboSpan" id="kobo.1152.1"> if you have not made any changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">port settings.</span></span></p>
<p><span class="koboSpan" id="kobo.1154.1">Now, you can open a browser window and open </span><em class="italic"><span class="koboSpan" id="kobo.1155.1">GraphiQL</span></em><span class="koboSpan" id="kobo.1156.1"> using the following URL: </span><a href="http://localhost:8080/graphiql"><span class="koboSpan" id="kobo.1157.1">http://localhost:8080/graphiql</span></a><span class="koboSpan" id="kobo.1158.1"> (part of the DGS framework). </span><span class="koboSpan" id="kobo.1158.2">Change the host/port accordingly </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">if required.</span></span></p>
<p><span class="koboSpan" id="kobo.1160.1">You can use the following GraphQL request</span><a id="_idIndexMarker1327"/><span class="koboSpan" id="kobo.1161.1"> to perform the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">addTag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1"> mutation:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1164.1">mutation</span></strong><span class="koboSpan" id="kobo.1165.1"> {   </span><strong class="bold"><span class="koboSpan" id="kobo.1166.1">addTag</span></strong><span class="koboSpan" id="kobo.1167.1">(productId: "a1s2d3f4-0",
          tags: [{name: "new Tags..."}]) {
     id
     name
     price
     description
     tags {
       id
       name
     }
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.1168.1">Here, you are adding the tags to the given </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">productId</span></strong><span class="koboSpan" id="kobo.1170.1">; therefore, you pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">productId</span></strong><span class="koboSpan" id="kobo.1172.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">tags</span></strong><span class="koboSpan" id="kobo.1174.1"> as arguments. </span><span class="koboSpan" id="kobo.1174.2">You can</span><a id="_idIndexMarker1328"/><span class="koboSpan" id="kobo.1175.1"> use the following GraphQL request to perform the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">addQuantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1"> mutation:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1178.1">mutation</span></strong><span class="koboSpan" id="kobo.1179.1"> {   </span><strong class="bold"><span class="koboSpan" id="kobo.1180.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1181.1">(productId: "a1s2d3f4-0", quantity: 10) {
     id
     name
     description
     price
     count
     tags {
       id
       name
     }
   }
 }</span></pre>
<p><span class="koboSpan" id="kobo.1182.1">Here, you pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">productId</span></strong><span class="koboSpan" id="kobo.1184.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">quantity</span></strong><span class="koboSpan" id="kobo.1186.1"> as arguments. </span><span class="koboSpan" id="kobo.1186.2">You have learned how to implement GraphQL mutations</span><a id="_idIndexMarker1329"/><span class="koboSpan" id="kobo.1187.1"> in the GraphQL server. </span><span class="koboSpan" id="kobo.1187.2">Let’s implement GraphQL subscriptions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">next section.</span></span></p>
<h1 id="_idParaDest-331"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.1189.1">Implementing and testing GraphQL subscriptions</span></h1>
<p><span class="koboSpan" id="kobo.1190.1">Subscription is another GraphQL root type</span><a id="_idIndexMarker1330"/><span class="koboSpan" id="kobo.1191.1"> that sends the object</span><a id="_idIndexMarker1331"/><span class="koboSpan" id="kobo.1192.1"> to the subscriber (client) when a particular </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">event occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.1194.1">Let’s assume an online shop offers a discount on products when the product’s inventory reaches a certain level. </span><span class="koboSpan" id="kobo.1194.2">You cannot track each product’s quantity manually and then perform the computation and trigger the discount. </span><span class="koboSpan" id="kobo.1194.3">To do things faster (or reduce manual intervention), this is where you can make use of </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">a subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.1196.1">Each change in the product’s inventory (quantity) through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">addQuantity()</span></strong><span class="koboSpan" id="kobo.1198.1"> mutation should trigger the event and the subscriber should receive the updated product and hence the quantity. </span><span class="koboSpan" id="kobo.1198.2">Then, the subscriber can place the logic and automate </span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1">this process.</span></span></p>
<p><span class="koboSpan" id="kobo.1200.1">Let’s write the subscription</span><a id="_idIndexMarker1332"/><span class="koboSpan" id="kobo.1201.1"> that will send the updated product object</span><a id="_idIndexMarker1333"/><span class="koboSpan" id="kobo.1202.1"> to the subscriber. </span><span class="koboSpan" id="kobo.1202.2">You are going to use Reactive Streams and WebSocket to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">this functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.1204.1">You need to enable CORS. </span><span class="koboSpan" id="kobo.1204.2">Let’s enable it by adding the following properties into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1207.1">
management.endpoints.web.exposure.include=health,metricsgraphql.servlet.actuator-metrics=true
graphql.servlet.tracing-enabled=false
</span><strong class="bold"><span class="koboSpan" id="kobo.1208.1">graphql.servlet.corsEnabled=true</span></strong></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties"><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties</span></span></a></p>
<p><span class="koboSpan" id="kobo.1210.1">Here, you have also enabled the actuator metrics and tracing for GraphQL along with exposing the health and metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">actuator endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.1212.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">build.gradle</span></strong><span class="koboSpan" id="kobo.1214.1">, you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">graphql-dgs-subscriptions-websockets-autoconfigure</span></strong><span class="koboSpan" id="kobo.1216.1"> to take care of the auto-configuration of WebSocket that is required for WebSocket-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">GraphQL subscriptions.</span></span></p>
<p><span class="koboSpan" id="kobo.1218.1">You can add the following subscription data fetcher to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">ProductDatafetcher</span></strong><span class="koboSpan" id="kobo.1220.1"> class as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1222.1">
// rest of the ProductDatafetcher class code </span><strong class="bold"><span class="koboSpan" id="kobo.1223.1">@DgsSubscription(field = SUBSCRIPTION.QuantityChanged)</span></strong><span class="koboSpan" id="kobo.1224.1">public </span><strong class="bold"><span class="koboSpan" id="kobo.1225.1">Publisher&lt;Product&gt; quantityChanged</span></strong><span class="koboSpan" id="kobo.1226.1">(
    @InputArgument("productId") String productId) {
  return productService.gerProductPublisher();
}
// rest of the ProductDatafetcher class code</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java"><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1228.1">Here, you are using another DGS framework annotation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">@DgsSubscription</span></strong><span class="koboSpan" id="kobo.1230.1">, which is a type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">@DgsData</span></strong><span class="koboSpan" id="kobo.1232.1"> annotation that is marked on a method to denote it as a data fetcher method. </span><span class="koboSpan" id="kobo.1232.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">@DgsSubscription</span></strong><span class="koboSpan" id="kobo.1234.1"> annotation, by default, has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">Subscription</span></strong><span class="koboSpan" id="kobo.1236.1"> value set to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">parentType</span></strong><span class="koboSpan" id="kobo.1238.1"> property. </span><span class="koboSpan" id="kobo.1238.2">You just must set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">field</span></strong><span class="koboSpan" id="kobo.1240.1"> property in this annotation. </span><span class="koboSpan" id="kobo.1240.2">By setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">field</span></strong><span class="koboSpan" id="kobo.1242.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">quantityChanged</span></strong><span class="koboSpan" id="kobo.1244.1">, you are indicating to the DGS framework to use this method when the subscription request for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">quantityChanged</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1246.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.1247.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">Subscription</span></strong><span class="koboSpan" id="kobo.1249.1"> method returns</span><a id="_idIndexMarker1334"/><span class="koboSpan" id="kobo.1250.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">Publisher</span></strong><span class="koboSpan" id="kobo.1252.1"> instance, which can send an unbound number of objects (in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">Product</span></strong><span class="koboSpan" id="kobo.1254.1"> instances) to multiple subscribers. </span><span class="koboSpan" id="kobo.1254.2">Therefore, the client just needs to subscribe to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">product publisher.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">You need to add a new method </span><a id="_idIndexMarker1335"/><span class="koboSpan" id="kobo.1257.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">ProductService</span></strong><span class="koboSpan" id="kobo.1259.1"> interface and its implementation in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">ProductServiceImpl</span></strong><span class="koboSpan" id="kobo.1261.1"> class. </span><span class="koboSpan" id="kobo.1261.2">The method signature in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">ProductService</span></strong><span class="koboSpan" id="kobo.1263.1"> interface and its implementation are straightforward. </span><span class="koboSpan" id="kobo.1263.2">It passes the call to the repository to perform the operation. </span><span class="koboSpan" id="kobo.1263.3">You can have a look at the source code in the book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">code repository.</span></span></p>
<p><span class="koboSpan" id="kobo.1265.1">The actual work is being performed by the repository. </span><span class="koboSpan" id="kobo.1265.2">Therefore, you need to make certain changes in the repository, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1267.1">First, add the following method signature to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">repository interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1269.1">
Publisher&lt;Product&gt; getProductPublisher();</span></pre></li> <li><span class="koboSpan" id="kobo.1270.1">Next, you have to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">getProductPublisher()</span></strong><span class="koboSpan" id="kobo.1272.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">InMemRepository</span></strong><span class="koboSpan" id="kobo.1274.1"> class. </span><span class="koboSpan" id="kobo.1274.2">This method returns the product publisher as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1276.1">
public Publisher&lt;Product&gt; getProductPublisher() {  return productPublisher;}</span></pre></li> <li><span class="koboSpan" id="kobo.1277.1">Now, we need all the magic to be performed by Reactive Streams. </span><span class="koboSpan" id="kobo.1277.2">First, let’s declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">FluxSink&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1279.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">ConnectableFlux&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1281.1"> (which is returned by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">repository) variables:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1283.1">
private </span><strong class="bold"><span class="koboSpan" id="kobo.1284.1">FluxSink&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1285.1"> productsStream;private </span><strong class="bold"><span class="koboSpan" id="kobo.1286.1">ConnectableFlux&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1287.1"> productPublisher;</span></pre></li> <li><span class="koboSpan" id="kobo.1288.1">Now, we need to initialize</span><a id="_idIndexMarker1336"/><span class="koboSpan" id="kobo.1289.1"> these declared instances. </span><span class="koboSpan" id="kobo.1289.2">Let’s do</span><a id="_idIndexMarker1337"/><span class="koboSpan" id="kobo.1290.1"> so in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">InMemRepository</span></strong><span class="koboSpan" id="kobo.1292.1"> constructor, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">following code:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1294.1">Flux&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1295.1"> publisher = </span><strong class="bold"><span class="koboSpan" id="kobo.1296.1">Flux.create</span></strong><span class="koboSpan" id="kobo.1297.1">(emitter -&gt; {  productsStream = emitter;});productPublisher = publisher.publish();productPublisher.connect();</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">Flux&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1299.1"> is a product stream publisher that passes the baton to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">productsStream</span></strong><span class="koboSpan" id="kobo.1301.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">FluxSink</span></strong><span class="koboSpan" id="kobo.1303.1">) to emit the next signals followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">onError()</span></strong><span class="koboSpan" id="kobo.1305.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">onComplete()</span></strong><span class="koboSpan" id="kobo.1307.1"> events. </span><span class="koboSpan" id="kobo.1307.2">This means </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">productsStream</span></strong><span class="koboSpan" id="kobo.1309.1"> should emit the signal when the product quantity gets changed. </span><span class="koboSpan" id="kobo.1309.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">Flux&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.1311.1"> calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">publish()</span></strong><span class="koboSpan" id="kobo.1313.1"> method, it returns an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">connectableFlux</span></strong><span class="koboSpan" id="kobo.1315.1">, which is assigned to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">productPublisher</span></strong><span class="koboSpan" id="kobo.1317.1"> (the one that is returned by </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">the subscription).</span></span></li>
<li><span class="koboSpan" id="kobo.1319.1">You are almost done with the setup. </span><span class="koboSpan" id="kobo.1319.2">You just need to emit the signal (product) when the product gets changed. </span><span class="koboSpan" id="kobo.1319.3">Let’s add the following highlighted line to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">addQuantity()</span></strong><span class="koboSpan" id="kobo.1321.1"> method before it returns the product, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1322.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1323.1">
product.setCount(product.getCount() + qty);productEntities.put(product.getId(), product);</span><strong class="bold"><span class="koboSpan" id="kobo.1324.1">productsStream.next(product);</span></strong><span class="koboSpan" id="kobo.1325.1">return product;</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1326.1">You have completed the subscription </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">quantityChanged</span></strong><span class="koboSpan" id="kobo.1328.1"> implementation. </span><span class="koboSpan" id="kobo.1328.2">You can test </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">it next.</span></span></p>
<p><span class="koboSpan" id="kobo.1330.1">You need to build the application before running the test. </span><span class="koboSpan" id="kobo.1330.2">Let’s build the application using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1332.1">
 $ gradlew clean build</span></pre> <p><span class="koboSpan" id="kobo.1333.1">Once the build is done successfully, you can run the following command to run </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">the application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1335.1">
 $ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar</span></pre> <p><span class="koboSpan" id="kobo.1336.1">The application should be running on the default port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">8080</span></strong><span class="koboSpan" id="kobo.1338.1"> if you have not made any changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">port settings.</span></span></p>
<p><span class="koboSpan" id="kobo.1340.1">Before testing</span><a id="_idIndexMarker1338"/><span class="koboSpan" id="kobo.1341.1"> the GraphQL subscription, you need to understand</span><a id="_idIndexMarker1339"/><span class="koboSpan" id="kobo.1342.1"> the GraphQL subscription protocol </span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">over WebSocket.</span></span></p>
<h2 id="_idParaDest-332"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.1344.1">Understanding the WebSocket sub-protocol for GraphQL</span></h2>
<p><span class="koboSpan" id="kobo.1345.1">You have implemented</span><a id="_idIndexMarker1340"/><span class="koboSpan" id="kobo.1346.1"> the GraphQL subscription</span><a id="_idIndexMarker1341"/><span class="koboSpan" id="kobo.1347.1"> over WebSocket in this chapter. </span><span class="koboSpan" id="kobo.1347.2">In WebSocket-based subscription implementation, the network socket is the main communication channel between the GraphQL server and </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.1349.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">graphql-dgs-subscriptions-websockets-autoconfigure</span></strong><span class="koboSpan" id="kobo.1351.1"> dependency’s current implementation (</span><em class="italic"><span class="koboSpan" id="kobo.1352.1">version 6.0.5</span></em><span class="koboSpan" id="kobo.1353.1">) makes use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">graphql-transport-ws</span></strong><span class="koboSpan" id="kobo.1355.1"> sub-protocol specifications. </span><span class="koboSpan" id="kobo.1355.2">In this sub-protocol, messages are represented using the JSON format, and over the network, these JSON messages are </span><em class="italic"><span class="koboSpan" id="kobo.1356.1">stringified</span></em><span class="koboSpan" id="kobo.1357.1">. </span><span class="koboSpan" id="kobo.1357.2">Both the server and client should conform to this </span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">message structure.</span></span></p>
<p><span class="koboSpan" id="kobo.1359.1">There are the following types of messages (code in Kotlin from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">DGS framework):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1361.1">
object MessageType {    const val CONNECTION_INIT = "connection_init"
    const val CONNECTION_ACK = "connection_ack"
    const val PING = "ping"
    const val PONG = "pong"
    const val SUBSCRIBE = "subscribe"
    const val NEXT = "next"
    const val ERROR = "error"
    const val COMPLETE = "complete"
}</span></pre>
<p><span class="koboSpan" id="kobo.1362.1">You might have got</span><a id="_idIndexMarker1342"/><span class="koboSpan" id="kobo.1363.1"> the idea about the life cycle of a GraphQL subscription</span><a id="_idIndexMarker1343"/><span class="koboSpan" id="kobo.1364.1"> over WebSocket by looking at the message type. </span><span class="koboSpan" id="kobo.1364.2">Let’s understand the life cycle of a subscription </span><span class="No-Break"><span class="koboSpan" id="kobo.1365.1">in detail:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.1366.1">Connection Initialization</span></strong><span class="koboSpan" id="kobo.1367.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">CONNECTION_INIT</span></strong><span class="koboSpan" id="kobo.1369.1">): The client initiates the communication by sending this type of message. </span><span class="koboSpan" id="kobo.1369.2">The connection initialization message contains two fields – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">type</span></strong><span class="koboSpan" id="kobo.1371.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">'connection_init'</span></strong><span class="koboSpan" id="kobo.1373.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">payload</span></strong><span class="koboSpan" id="kobo.1375.1">. </span><span class="koboSpan" id="kobo.1375.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">payload</span></strong><span class="koboSpan" id="kobo.1377.1"> field is an optional field. </span><span class="koboSpan" id="kobo.1377.2">Its (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">ConnectionInitMessage</span></strong><span class="koboSpan" id="kobo.1379.1">) structure is represented </span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1381.1">
{  type: 'connection_init';  payload: Map&lt;String, Object&gt;; // optional}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.1382.1">Connection Acknowledgment</span></strong><span class="koboSpan" id="kobo.1383.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">CONNECTION_ACK</span></strong><span class="koboSpan" id="kobo.1385.1">): The server sends the connection acknowledgment in response to a successful connection initialization request. </span><span class="koboSpan" id="kobo.1385.2">It means the server is ready for subscription. </span><span class="koboSpan" id="kobo.1385.3">Its structure (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">ConnectionAckMessage</span></strong><span class="koboSpan" id="kobo.1387.1">) is represented </span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1389.1">
{  type: 'connection_ack';  payload: Map&lt;String, Any&gt;; // optional}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.1390.1">Subscribe</span></strong><span class="koboSpan" id="kobo.1391.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">SUBSCRIBE</span></strong><span class="koboSpan" id="kobo.1393.1">): The client now can send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">subscribe</span></strong><span class="koboSpan" id="kobo.1395.1"> request. </span><span class="koboSpan" id="kobo.1395.2">If the client sends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">subscribe</span></strong><span class="koboSpan" id="kobo.1397.1"> request without getting a connection acknowledgment from the server, the client may get the error </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">4401: Unauthorized</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1400.1">This request contains</span><a id="_idIndexMarker1344"/><span class="koboSpan" id="kobo.1401.1"> three fields – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">id</span></strong><span class="koboSpan" id="kobo.1403.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">type</span></strong><span class="koboSpan" id="kobo.1405.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">payload</span></strong><span class="koboSpan" id="kobo.1407.1">. </span><span class="koboSpan" id="kobo.1407.2">Here, each new subscription</span><a id="_idIndexMarker1345"/><span class="koboSpan" id="kobo.1408.1"> request should contain a unique </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">id</span></strong><span class="koboSpan" id="kobo.1410.1">; otherwise, the server may throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">4409: Subscriber for &lt;unique-operation-id&gt; already exists</span></strong><span class="koboSpan" id="kobo.1412.1">. </span><span class="koboSpan" id="kobo.1412.2">The server keeps track of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">id</span></strong><span class="koboSpan" id="kobo.1414.1">, until the subscription is active. </span><span class="koboSpan" id="kobo.1414.2">The moment the subscription is complete, the client can reuse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">id</span></strong><span class="koboSpan" id="kobo.1416.1">. </span><span class="koboSpan" id="kobo.1416.2">The structure of this message type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">SubscribeMessage</span></strong><span class="koboSpan" id="kobo.1418.1">) is </span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1420.1">
{  id: '&lt;unique-id&gt;';
  type: 'subscribe';
  payload: {
    operationName: ''; // optional operation name
    query: '';  // </span><strong class="bold"><span class="koboSpan" id="kobo.1421.1">Mandatory</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1422.1">GraphQL subscription</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1423.1">    query</span></strong><span class="koboSpan" id="kobo.1424.1">
    variables?: Map&lt;String, Any&gt;; // optional
    variables
    extensions?: Map&lt;String, Any&gt;; // optional
  };
}</span></pre>
<ol>
<li value="4"><strong class="bold"><span class="koboSpan" id="kobo.1425.1">Next</span></strong><span class="koboSpan" id="kobo.1426.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">NEXT</span></strong><span class="koboSpan" id="kobo.1428.1">): After a successful subscription operation, the client receives the messages of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">NEXT</span></strong><span class="koboSpan" id="kobo.1430.1"> from the server that contain the data related to the operation the client subscribes to. </span><span class="koboSpan" id="kobo.1430.2">Data is part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">payload</span></strong><span class="koboSpan" id="kobo.1432.1"> field. </span><span class="koboSpan" id="kobo.1432.2">The server keeps sending these message types to the client until GraphQL subscription events occur. </span><span class="koboSpan" id="kobo.1432.3">Once the operation gets completed, the server sends the complete message to the client. </span><span class="koboSpan" id="kobo.1432.4">Its message type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">NextMessage</span></strong><span class="koboSpan" id="kobo.1434.1">) is represented by </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1436.1">
{  id: '&lt;unique-id&gt;'; // one sent with subscribe  type: 'next';  payload: ExecutionResult;}</span></pre></li> <li> <strong class="bold"><span class="koboSpan" id="kobo.1437.1">Complete</span></strong><span class="koboSpan" id="kobo.1438.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">COMPLETE</span></strong><span class="koboSpan" id="kobo.1440.1">): </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">Complete</span></strong><span class="koboSpan" id="kobo.1442.1"> is a bi-directional</span><a id="_idIndexMarker1346"/><span class="koboSpan" id="kobo.1443.1"> message, which can be sent by both</span><a id="_idIndexMarker1347"/><span class="koboSpan" id="kobo.1444.1"> the server </span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">and client:</span></span><ul><li><em class="italic"><span class="koboSpan" id="kobo.1446.1">Client to Server</span></em><span class="koboSpan" id="kobo.1447.1">: The client can send the complete message to the server when the client wants to stop listening to the message sent by the server. </span><span class="koboSpan" id="kobo.1447.2">Since it’s a duplex call, the client should ignore the messages that are en route when the client sends a </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">complete request.</span></span></li><li><em class="italic"><span class="koboSpan" id="kobo.1449.1">Server to Client</span></em><span class="koboSpan" id="kobo.1450.1">: The server sends the complete message to the client when the requested operation is completed by the server. </span><span class="koboSpan" id="kobo.1450.2">The server doesn’t send the complete message when an error message is sent by the server for the subscription request by </span><span class="No-Break"><span class="koboSpan" id="kobo.1451.1">the client.</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.1452.1">The message type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">CompleteMessage</span></strong><span class="koboSpan" id="kobo.1454.1">) is represented by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1455.1">following structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1456.1">
{  id: '&lt;unique-id&gt;'; // one sent with subscribe
  type: 'complete';
}</span></pre>
<ol>
<li value="6"><strong class="bold"><span class="koboSpan" id="kobo.1457.1">Error</span></strong><span class="koboSpan" id="kobo.1458.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">ERROR</span></strong><span class="koboSpan" id="kobo.1460.1">): The server sends an error message when the server encounters any operation execution error. </span><span class="koboSpan" id="kobo.1460.2">Its type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">ErrorMessage</span></strong><span class="koboSpan" id="kobo.1462.1">) is represented by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1463.1">following structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1464.1">
{  id: '&lt;unique-id&gt;';  type: 'error';  payload: GraphQLError[];}</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">PING</span></strong><span class="koboSpan" id="kobo.1466.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">PONG</span></strong><span class="koboSpan" id="kobo.1468.1">: These are bi-directional message types and are sent by both the server and client. </span><span class="koboSpan" id="kobo.1468.2">If the client sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">ping</span></strong><span class="koboSpan" id="kobo.1470.1"> message, the server should immediately send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">pong</span></strong><span class="koboSpan" id="kobo.1472.1"> message and vice versa. </span><span class="koboSpan" id="kobo.1472.2">These messages are useful for detecting networking problems and network latency. </span><span class="koboSpan" id="kobo.1472.3">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">ping</span></strong><span class="koboSpan" id="kobo.1474.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">PingMessage</span></strong><span class="koboSpan" id="kobo.1476.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">pong</span></strong><span class="koboSpan" id="kobo.1478.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">PongMessage</span></strong><span class="koboSpan" id="kobo.1480.1">) contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.1481.1">following structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1482.1">
{  type: String; // either 'ping' or 'pong'  payload: Map&lt;String, Object&gt;; // optional}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1483.1">Understanding the subscription life cycle will help you test the </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">subscription thoroughly.</span></span></p>
<p><span class="koboSpan" id="kobo.1485.1">You can use any tool</span><a id="_idIndexMarker1348"/><span class="koboSpan" id="kobo.1486.1"> that supports GraphQL subscription</span><a id="_idIndexMarker1349"/><span class="koboSpan" id="kobo.1487.1"> testing. </span><span class="koboSpan" id="kobo.1487.2">We’ll test it using the Insomnia WebSocket request client – a bit of a crude way so you can understand the complete life cycle of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">GraphQL subscription.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.1489.1"><img alt="Figure 14.3 – GraphQL subscription connection_init call in the Insomnia client" src="image/Figure_14.3_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1490.1">Figure 14.3 – GraphQL subscription connection_init call in the Insomnia client</span></p>
<h2 id="_idParaDest-333"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.1491.1">Testing GraphQL subscriptions using Insomnia WebSocket</span></h2>
<p><span class="koboSpan" id="kobo.1492.1">Let’s perform</span><a id="_idIndexMarker1350"/><span class="koboSpan" id="kobo.1493.1"> the following steps to test the </span><span class="No-Break"><span class="koboSpan" id="kobo.1494.1">subscription</span></span><span class="No-Break"><a id="_idIndexMarker1351"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1"> manually:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1496.1">First, add a new request using </span><em class="italic"><span class="koboSpan" id="kobo.1497.1">WebSocket Request</span></em><span class="koboSpan" id="kobo.1498.1"> by using the (</span><strong class="bold"><span class="koboSpan" id="kobo.1499.1">+</span></strong><span class="koboSpan" id="kobo.1500.1">) drop-down menu available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1501.1">top-left corner.</span></span></li>
<li><span class="koboSpan" id="kobo.1502.1">Then add the following URL in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1503.1">URL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1504.1"> box:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1505.1">
ws://localhost:8080/subscriptions</span></pre></li> <li><span class="koboSpan" id="kobo.1506.1">Then, add the following headers in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1507.1">Headers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1508.1"> tab:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1509.1">
Connection: UpgradeUpgrade: websocketdnt: 1accept: */*accept-encoding: gzip, deflate, brhost: localhost:8080origin: http://localhost:8080sec-fetch-dest: websocketsec-fetch-mode: websocketsec-fetch-site: same-origin</span><strong class="bold"><span class="koboSpan" id="kobo.1510.1">Sec-WebSocket-Protocol: graphql-transport-ws</span></strong><span class="koboSpan" id="kobo.1511.1">Sec-WebSocket-Version: 13Sec-WebSocket-Key: </span><strong class="bold"><span class="koboSpan" id="kobo.1512.1">3dcYr9va5icM8VcKuCr/KA==</span></strong><span class="koboSpan" id="kobo.1513.1">Sec-WebSocket-Extensions: permessage-deflate</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1514.1">Here, through</span><a id="_idIndexMarker1352"/><span class="koboSpan" id="kobo.1515.1"> the headers, you upgrade the connection to WebSocket; therefore, the server</span><a id="_idIndexMarker1353"/><span class="koboSpan" id="kobo.1516.1"> sends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1517.1">101 Switching Protocol</span></strong><span class="koboSpan" id="kobo.1518.1"> response. </span><span class="koboSpan" id="kobo.1518.2">Also, you can see that you are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">graphql-transport-ws</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1520.1">GraphQL sub-protocol.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1521.1">Then, add the following payload in the </span><strong class="bold"><span class="koboSpan" id="kobo.1522.1">JSON</span></strong><span class="koboSpan" id="kobo.1523.1"> tab for connection initialization (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1524.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1525.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1526.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1527.1">
{  "type": "</span><strong class="bold"><span class="koboSpan" id="kobo.1528.1">connection_init</span></strong><span class="koboSpan" id="kobo.1529.1">",  "payload": {     "variables": {},  "extensions": {},  "operationName": null,  "query":"subscription { quantityChanged { id name price count} }"}}</span></pre></li> <li><span class="koboSpan" id="kobo.1530.1">Then, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1531.1">Send</span></strong><span class="koboSpan" id="kobo.1532.1"> button (don’t click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1533.1">Connect</span></strong><span class="koboSpan" id="kobo.1534.1"> button – if you do, then it needs to be followed by one more click </span><span class="No-Break"><span class="koboSpan" id="kobo.1535.1">on </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1536.1">Send</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1537.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1538.1">On a successful connection, you will receive</span><a id="_idIndexMarker1354"/><span class="koboSpan" id="kobo.1539.1"> the following acknowledgment</span><a id="_idIndexMarker1355"/><span class="koboSpan" id="kobo.1540.1"> message from the server. </span><span class="koboSpan" id="kobo.1540.2">It means the server is ready to serve the subscription request (shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1541.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1542.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1544.1">
{  "payload": {},  "type": "</span><strong class="bold"><span class="koboSpan" id="kobo.1545.1">connection_ack</span></strong><span class="koboSpan" id="kobo.1546.1">"}</span></pre></li> <li><span class="koboSpan" id="kobo.1547.1">Then, use the following payload in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1548.1">JSON</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1"> tab:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1550.1">
{  "id": "</span><strong class="bold"><span class="koboSpan" id="kobo.1551.1">b</span></strong><span class="koboSpan" id="kobo.1552.1">",  "type": "</span><strong class="bold"><span class="koboSpan" id="kobo.1553.1">subscribe</span></strong><span class="koboSpan" id="kobo.1554.1">",  "payload": {     "variables": {},  "extensions": {},  "operationName": null,      "operationName": null,"query":"subscription { quantityChanged { id name price count} }"}}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1555.1">Here, you are adding a unique ID to the message. </span><span class="koboSpan" id="kobo.1555.2">The type of message is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">subscribe</span></strong><span class="koboSpan" id="kobo.1557.1">. </span><span class="koboSpan" id="kobo.1557.2">You can send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">subscribe</span></strong><span class="koboSpan" id="kobo.1559.1"> message because a connection acknowledgment is received by the client. </span><span class="koboSpan" id="kobo.1559.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">query</span></strong><span class="koboSpan" id="kobo.1561.1"> field contains the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">subscription query.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.1563.1">Then, again click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">Send</span></strong><span class="koboSpan" id="kobo.1565.1"> button (don’t click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1566.1">Connect</span></strong><span class="koboSpan" id="kobo.1567.1"> button – if you do, then it needs to be followed by one more click </span><span class="No-Break"><span class="koboSpan" id="kobo.1568.1">on </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1569.1">Send</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1571.1">After clicking</span><a id="_idIndexMarker1356"/><span class="koboSpan" id="kobo.1572.1"> on the </span><strong class="bold"><span class="koboSpan" id="kobo.1573.1">Send</span></strong><span class="koboSpan" id="kobo.1574.1"> button, you need</span><a id="_idIndexMarker1357"/><span class="koboSpan" id="kobo.1575.1"> to fire the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1577.1"> mutation to trigger the publication of the event by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1">following payload:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1579.1">
mutation {  </span><strong class="bold"><span class="koboSpan" id="kobo.1580.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1581.1">(productId: "</span><strong class="bold"><span class="koboSpan" id="kobo.1582.1">a1s2d3f4-0</span></strong><span class="koboSpan" id="kobo.1583.1">", quantity: </span><strong class="bold"><span class="koboSpan" id="kobo.1584.1">10</span></strong><span class="koboSpan" id="kobo.1585.1">) {    id    name    price    count  }}</span></pre></li> <li><span class="koboSpan" id="kobo.1586.1">After a successful mutation call, you can check the subscription output in the Insomnia client. </span><span class="koboSpan" id="kobo.1586.2">You will find an incoming JSON message that will display the increased quantity, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1587.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1588.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1589.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1590.1">You can repeat </span><em class="italic"><span class="koboSpan" id="kobo.1591.1">steps 9 and 10</span></em><span class="koboSpan" id="kobo.1592.1"> to get the (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1593.1">NEXT</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1594.1">type) messages.</span></span></li>
<li><span class="koboSpan" id="kobo.1595.1">Once you</span><a id="_idIndexMarker1358"/><span class="koboSpan" id="kobo.1596.1"> are done, you can send the following JSON payload</span><a id="_idIndexMarker1359"/><span class="koboSpan" id="kobo.1597.1"> to complete the call as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1598.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1599.1">.4:</span></em></span><pre class="source-code"><span class="koboSpan" id="kobo.1600.1">
{  "id": "</span><strong class="bold"><span class="koboSpan" id="kobo.1601.1">b</span></strong><span class="koboSpan" id="kobo.1602.1">",  "type": "</span><strong class="bold"><span class="koboSpan" id="kobo.1603.1">complete</span></strong><span class="koboSpan" id="kobo.1604.1">"}</span></pre></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.1605.1"><img alt="Figure 14.4 – GraphQL subscription’s next and complete calls in the Insomnia client" src="image/Figure_14.4_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1606.1">Figure 14.4 – GraphQL subscription’s next and complete calls in the Insomnia client</span></p>
<p><span class="koboSpan" id="kobo.1607.1">This is the way you</span><a id="_idIndexMarker1360"/><span class="koboSpan" id="kobo.1608.1"> can implement and test</span><a id="_idIndexMarker1361"/><span class="koboSpan" id="kobo.1609.1"> the GraphQL subscription over WebSocket. </span><span class="koboSpan" id="kobo.1609.2">You will automate the test for GraphQL subscription in the </span><em class="italic"><span class="koboSpan" id="kobo.1610.1">Testing GraphQL subscriptions using automated test code</span></em><span class="koboSpan" id="kobo.1611.1"> subsection in </span><span class="No-Break"><span class="koboSpan" id="kobo.1612.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1613.1">Next, you should know about the instrumentation that helps to implement the tracing, logging, and metrics collection. </span><span class="koboSpan" id="kobo.1613.2">Let’s discuss this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1614.1">next subsection.</span></span></p>
<h1 id="_idParaDest-334"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.1615.1">Instrumenting the GraphQL APIs</span></h1>
<p><span class="koboSpan" id="kobo.1616.1">The GraphQL Java library</span><a id="_idIndexMarker1362"/><span class="koboSpan" id="kobo.1617.1"> supports the instrumentation of the GraphQL APIs. </span><span class="koboSpan" id="kobo.1617.2">This can be used to support metrics, tracing, and logging. </span><span class="koboSpan" id="kobo.1617.3">The DGS framework also uses it. </span><span class="koboSpan" id="kobo.1617.4">You just must mark the instrumentation class with the Spring </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">Component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1620.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.1621.1">The instrumentation bean can be implemented using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">graphql.execution. </span><span class="koboSpan" id="kobo.1622.2">instrumentation.Instumentation</span></strong><span class="koboSpan" id="kobo.1623.1"> interface. </span><span class="koboSpan" id="kobo.1623.2">Here, you have to write boilerplate code, which may increase the unit test automation code for you. </span><span class="koboSpan" id="kobo.1623.3">Another way that is much easier is to extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">SimpleInstrumentation</span></strong><span class="koboSpan" id="kobo.1625.1"> class, which does the simple implementation for you. </span><span class="koboSpan" id="kobo.1625.2">However, you can override the methods for </span><span class="No-Break"><span class="koboSpan" id="kobo.1626.1">custom implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.1627.1">Let’s add instrumentation</span><a id="_idIndexMarker1363"/><span class="koboSpan" id="kobo.1628.1"> that will record the time taken by the data fetcher and complete GraphQL request processing. </span><span class="koboSpan" id="kobo.1628.2">This metric may help you to fine-tune the performance and identify the fields that take more time </span><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">to resolve.</span></span></p>
<p><span class="koboSpan" id="kobo.1630.1">Before adding the tracing, let’s add the custom header in </span><span class="No-Break"><span class="koboSpan" id="kobo.1631.1">the response.</span></span></p>
<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.1632.1">Adding a custom header</span></h2>
<p><span class="koboSpan" id="kobo.1633.1">Let’s create</span><a id="_idIndexMarker1364"/><span class="koboSpan" id="kobo.1634.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1635.1">DemoInstrumentation.java</span></strong><span class="koboSpan" id="kobo.1636.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1637.1">instrumentation</span></strong><span class="koboSpan" id="kobo.1638.1"> package</span><a id="_idIndexMarker1365"/><span class="koboSpan" id="kobo.1639.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1640.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1641.1">
@Componentpublic class DemoInstrumentation
               extends </span><strong class="bold"><span class="koboSpan" id="kobo.1642.1">SimpleInstrumentation</span></strong><span class="koboSpan" id="kobo.1643.1"> {
  @NotNull
  </span><strong class="bold"><span class="koboSpan" id="kobo.1644.1">@Override</span></strong><span class="koboSpan" id="kobo.1645.1">
  public CompletableFuture&lt;ExecutionResult&gt;
     </span><strong class="bold"><span class="koboSpan" id="kobo.1646.1">instrumentExecutionResult</span></strong><span class="koboSpan" id="kobo.1647.1">(ExecutionResult exeResult,
               InstrumentationExecutionParameters params,
               InstrumentationState state) {
    HttpHeaders responseHeaders = new HttpHeaders();
    </span><strong class="bold"><span class="koboSpan" id="kobo.1648.1">responseHeaders.add("myHeader", "hello");</span></strong><span class="koboSpan" id="kobo.1649.1">
    return super.instrumentExecutionResult(DgsExecutionResult
        .builder().executionResult(execResult)
        .headers(responseHeaders).build(),
        params,
        state
    );
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java"><span class="No-Break"><span class="koboSpan" id="kobo.1650.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1651.1">Here, this class</span><a id="_idIndexMarker1366"/><span class="koboSpan" id="kobo.1652.1"> extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">SimpleInstrumentation</span></strong><span class="koboSpan" id="kobo.1654.1"> and is created as a Spring bean by marking it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">@Component</span></strong><span class="koboSpan" id="kobo.1656.1">. </span><span class="koboSpan" id="kobo.1656.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1657.1">SimpleInstrumentation</span></strong><span class="koboSpan" id="kobo.1658.1"> class allows you to instrument</span><a id="_idIndexMarker1367"/><span class="koboSpan" id="kobo.1659.1"> the execution result. </span><span class="koboSpan" id="kobo.1659.2">Here, you can see that you have added the custom header in the response. </span><span class="koboSpan" id="kobo.1659.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1660.1">test it.</span></span></p>
<p><span class="koboSpan" id="kobo.1661.1">You can build and execute the project after adding the previous code and then execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.1662.1">following mutation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1663.1">
mutation {  addQuantity(productId: "a1s2d3f4-0", quantity: 10) {
    id
    name
    price
    count
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1664.1">You’ll find the instrumented </span><strong class="source-inline"><span class="koboSpan" id="kobo.1665.1">myHeader</span></strong><span class="koboSpan" id="kobo.1666.1"> header and its value in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1667.1">response headers.</span></span></p>
<p><span class="koboSpan" id="kobo.1668.1">Now, you can instrument</span><a id="_idIndexMarker1368"/><span class="koboSpan" id="kobo.1669.1"> the tracing information in your response</span><a id="_idIndexMarker1369"/><span class="koboSpan" id="kobo.1670.1"> by adding the following bean to </span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">your project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1672.1">
@Configurationpublic class InstrumentationConfig {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1673.1">@Bean</span></strong><span class="koboSpan" id="kobo.1674.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1675.1">@ConditionalOnProperty( prefix = "graphql.tracing",</span></strong><span class="koboSpan" id="kobo.1676.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1677.1">name = "enabled", matchIfMissing = true)</span></strong><span class="koboSpan" id="kobo.1678.1">
  public Instrumentation tracingInstrumentation(){
    return new TracingInstrumentation();
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java"><span class="No-Break"><span class="koboSpan" id="kobo.1679.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1680.1">This configuration does the magic. </span><span class="koboSpan" id="kobo.1680.2">You must remember that you need </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">com.netflix.graphql.dgs:graphql-dgs-spring-boot-micrometer</span></strong><span class="koboSpan" id="kobo.1682.1"> along with Spring Actuator dependencies in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">build.gradle</span></strong><span class="koboSpan" id="kobo.1684.1"> file to make </span><span class="No-Break"><span class="koboSpan" id="kobo.1685.1">it work.</span></span></p>
<p><span class="koboSpan" id="kobo.1686.1">The previous code adds the execution result metrics provided by the DGS framework to GraphQL API responses. </span><span class="koboSpan" id="kobo.1686.2">This metric includes the tracing time and duration, validation time and duration, the resolver’s information, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1688.1">Once you have this instrumentation in place and execute any query or mutation, the result will include the extension fields consisting of the result metrics instrumented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">Instrumentation</span></strong><span class="koboSpan" id="kobo.1690.1"> bean (GraphQL Tracing) created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1691.1">previous code.</span></span></p>
<p><span class="koboSpan" id="kobo.1692.1">Let’s execute the following mutation in </span><span class="No-Break"><span class="koboSpan" id="kobo.1693.1">GraphiQL (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1694.1">http://localhost:8080/graphiql</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1695.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1696.1">
mutation {  addQuantity(productId: "a1s2d3f4-0", quantity: 10) {
    id
    name
    price
    count
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1697.1">The previous mutation will provide</span><a id="_idIndexMarker1370"/><span class="koboSpan" id="kobo.1698.1"> the following response with </span><span class="No-Break"><span class="koboSpan" id="kobo.1699.1">instrumented </span></span><span class="No-Break"><a id="_idIndexMarker1371"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1700.1">metrics:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1701.1">
{  "data": {
    "addQuantity": {
      "id": "a1s2d3f4-0",
      // output truncated for brevity
    }
  },
  "</span><strong class="bold"><span class="koboSpan" id="kobo.1702.1">extensions</span></strong><span class="koboSpan" id="kobo.1703.1">": {
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1704.1">tracing</span></strong><span class="koboSpan" id="kobo.1705.1">": {
      "version": 1,
      "startTime": "2023-05-07T19:04:42.032422Z",
      "endTime": "2023-05-07T19:04:42.170516Z",
      "duration": 138103974,
      "</span><strong class="bold"><span class="koboSpan" id="kobo.1706.1">parsing</span></strong><span class="koboSpan" id="kobo.1707.1">": {
        "startOffset": 11023640,
        "duration": 7465319
      },
      "</span><strong class="bold"><span class="koboSpan" id="kobo.1708.1">validation</span></strong><span class="koboSpan" id="kobo.1709.1">": {
        "startOffset": 31688145,
        "duration": 20146090
      },
      "</span><strong class="bold"><span class="koboSpan" id="kobo.1710.1">execution</span></strong><span class="koboSpan" id="kobo.1711.1">": {
        "</span><strong class="bold"><span class="koboSpan" id="kobo.1712.1">resolvers</span></strong><span class="koboSpan" id="kobo.1713.1">": [
          {
            "path": [
              "addQuantity"
            ],
            "parentType": "Mutation",
            "returnType": "Product",
            "fieldName": "addQuantity",
            "startOffset": 92045595,
            "duration": 24507328
          },
          // output truncated for brevity
        ]
     }
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1714.1">Here, you can see</span><a id="_idIndexMarker1372"/><span class="koboSpan" id="kobo.1715.1"> that it not only returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1716.1">data</span></strong><span class="koboSpan" id="kobo.1717.1"> but also provides</span><a id="_idIndexMarker1373"/><span class="koboSpan" id="kobo.1718.1"> the instrumented metrics in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1719.1">extensions</span></strong><span class="koboSpan" id="kobo.1720.1"> field. </span><span class="koboSpan" id="kobo.1720.2">Please note that you should keep this instrumentation enabled only for the development environment to fine-tune the GraphQL implementation and benchmarking, and keep</span><a id="_idIndexMarker1374"/><span class="koboSpan" id="kobo.1721.1"> it disabled for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1722.1">production</span></span><span class="No-Break"><a id="_idIndexMarker1375"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1723.1"> environment.</span></span></p>
<p><span class="koboSpan" id="kobo.1724.1">Let’s find out more about the instrumentation metrics in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1725.1">next subsection.</span></span></p>
<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.1726.1">Integration with Micrometer</span></h2>
<p><span class="koboSpan" id="kobo.1727.1">You have</span><a id="_idIndexMarker1376"/><span class="koboSpan" id="kobo.1728.1"> added </span><strong class="source-inline"><span class="koboSpan" id="kobo.1729.1">graphql-dgs-spring-boot-micrometer</span></strong><span class="koboSpan" id="kobo.1730.1"> as one of the dependencies</span><a id="_idIndexMarker1377"/><span class="koboSpan" id="kobo.1731.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1732.1">build.gradle</span></strong><span class="koboSpan" id="kobo.1733.1">. </span><span class="koboSpan" id="kobo.1733.2">This library provides GraphQL metrics out of the box such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">gql.query</span></strong><span class="koboSpan" id="kobo.1735.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1736.1">gql-resolver</span></strong><span class="koboSpan" id="kobo.1737.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1739.1">You can expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1740.1">metrics</span></strong><span class="koboSpan" id="kobo.1741.1"> endpoint by adding the following line in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1742.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1743.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1744.1">
management.endpoints.web.</span><strong class="bold"><span class="koboSpan" id="kobo.1745.1">exposure.include</span></strong><span class="koboSpan" id="kobo.1746.1">=health,</span><strong class="bold"><span class="koboSpan" id="kobo.1747.1">metrics</span></strong></pre> <p><span class="koboSpan" id="kobo.1748.1">You can fire the following endpoint to find out the available GraphQL metrics. </span><span class="koboSpan" id="kobo.1748.2">Please note that it displays only triggered GraphQL metrics. </span><span class="koboSpan" id="kobo.1748.3">For example, if there is no error while calling GraphQL APIs, it won’t </span><span class="No-Break"><span class="koboSpan" id="kobo.1749.1">show </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1750.1">gql.error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1751.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1752.1">
http://localhost:8080/</span><strong class="bold"><span class="koboSpan" id="kobo.1753.1">actuator/metrics</span></strong></pre> <p><span class="koboSpan" id="kobo.1754.1">This endpoint displays the list of available metrics in your application, including </span><span class="No-Break"><span class="koboSpan" id="kobo.1755.1">GraphQL metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.1756.1">The following four types of GraphQL metrics are provided by the DGS framework, which may help you to find out the code responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.1757.1">poor performance:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1758.1">gql.query</span></strong><span class="koboSpan" id="kobo.1759.1">: This captures the time taken by the GraphQL query </span><span class="No-Break"><span class="koboSpan" id="kobo.1760.1">or mutation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1761.1">gql.resolver</span></strong><span class="koboSpan" id="kobo.1762.1">: This captures the time taken by each data </span><span class="No-Break"><span class="koboSpan" id="kobo.1763.1">fetcher invocation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">gql.error</span></strong><span class="koboSpan" id="kobo.1765.1">: A single GraphQL request can have multiple errors. </span><span class="koboSpan" id="kobo.1765.2">This metric captures the number of errors encountered during the GraphQL request execution. </span><span class="koboSpan" id="kobo.1765.3">It will only be available when there are errors </span><span class="No-Break"><span class="koboSpan" id="kobo.1766.1">in execution.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1767.1">gql.dataLoader</span></strong><span class="koboSpan" id="kobo.1768.1">: This captures the time taken by the data loader invocation for the batch </span><span class="No-Break"><span class="koboSpan" id="kobo.1769.1">of queries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1770.1">The available GraphQL metrics from the actuator metrics endpoint output can be accessed using the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1771.1">endpoint call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1772.1">
http://localhost:8080/</span><strong class="bold"><span class="koboSpan" id="kobo.1773.1">actuator/metrics/gql.query</span></strong></pre> <p><span class="koboSpan" id="kobo.1774.1">It may</span><a id="_idIndexMarker1378"/><span class="koboSpan" id="kobo.1775.1"> provide output</span><a id="_idIndexMarker1379"/><span class="koboSpan" id="kobo.1776.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.1777.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1778.1">
{  "name": "gql.query",
  "baseUnit": "seconds",
  "measurements": [{
    "statistic": "COUNT",  "value": 4.0
  }, {
    "statistic": "TOTAL_TIME", "value": 1.403888175
  }, {
    "statistic": "MAX", "value": 0.0
  }],
  "availableTags": [{
    "tag": "gql.query.sig.hash",
    "values": ["10e750742768cb7c428699…",
               "a750f4b9bb5d40f2d23b01…"]
  }, {
    "tag": "gql.operation",
    "values": ["SUBSCRIPTION", "MUTATION"]
  }, {
    "tag": "gql.query.complexity", "values": ["10"]
  }, {
    "tag": "gql.operation.name", "values": ["anonymous"]
  }, {
    "tag": "outcome", "values": ["success", "failure"]
  }]
}</span></pre>
<p><span class="koboSpan" id="kobo.1779.1">You can see that it provides the total elapsed time, a number of requests count, and the max time taken by the query/mutation. </span><span class="koboSpan" id="kobo.1779.2">It also provides tags. </span><span class="koboSpan" id="kobo.1779.3">These tags can be customized if required by implementing the following interfaces – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1780.1">DgsContextualTagCustomizer</span></strong><span class="koboSpan" id="kobo.1781.1"> (to customize common tags such as application profile and version or deployment environment), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1782.1">DgsExecutionTagCustomizer</span></strong><span class="koboSpan" id="kobo.1783.1"> (to customize the tags related to execution results), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1784.1">DgsFieldFetchTagCustomizer</span></strong><span class="koboSpan" id="kobo.1785.1"> (to customize the tags related to </span><span class="No-Break"><span class="koboSpan" id="kobo.1786.1">data fetchers).</span></span></p>
<p><span class="koboSpan" id="kobo.1787.1">You have learned</span><a id="_idIndexMarker1380"/><span class="koboSpan" id="kobo.1788.1"> how to instrument the GraphQL APIs </span><a id="_idIndexMarker1381"/><span class="koboSpan" id="kobo.1789.1">in this section. </span><span class="koboSpan" id="kobo.1789.2">Let’s explore automating the testing of GraphQL code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1790.1">next section.</span></span></p>
<h1 id="_idParaDest-337"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.1791.1">Test automation</span></h1>
<p><span class="koboSpan" id="kobo.1792.1">The DGS framework</span><a id="_idIndexMarker1382"/><span class="koboSpan" id="kobo.1793.1"> provides classes and utilities that facilitate the automation</span><a id="_idIndexMarker1383"/><span class="koboSpan" id="kobo.1794.1"> of GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.1795.1">API tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1796.1">Create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1798.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1799.1">datafetchers</span></strong><span class="koboSpan" id="kobo.1800.1"> package in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">test</span></strong><span class="koboSpan" id="kobo.1802.1"> directory and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1803.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1804.1">@SpringBootTest(classes = { DgsAutoConfiguration.class, </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1805.1">    ProductDatafetcher.class,BigDecimalScalar.class })</span></strong><span class="koboSpan" id="kobo.1806.1">
public class ProductDatafetcherTest {
  private final InMemRepository repo = new InMemRepository();
  private final int TEN = 10;
  @Autowired
  private </span><strong class="bold"><span class="koboSpan" id="kobo.1807.1">DgsQueryExecutor</span></strong><span class="koboSpan" id="kobo.1808.1"> dgsQueryExecutor;
  </span><strong class="bold"><span class="koboSpan" id="kobo.1809.1">@MockBean</span></strong><span class="koboSpan" id="kobo.1810.1">
  private ProductService productService;
  </span><strong class="bold"><span class="koboSpan" id="kobo.1811.1">@MockBean</span></strong><span class="koboSpan" id="kobo.1812.1">
  private TagService tagService;
  // continue …</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/test/java/com/packt/modern/api/datafetchers/ProductDatafetcherTest.java"><span class="No-Break"><span class="koboSpan" id="kobo.1813.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/test/java/com/packt/modern/api/datafetchers/ProductDatafetcherTest.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1814.1">Here, you are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">@SpringBootTest</span></strong><span class="koboSpan" id="kobo.1816.1"> annotation to auto-configure a Spring Boot based test. </span><span class="koboSpan" id="kobo.1816.2">You are limiting the Spring context by providing specific classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">DgsAutoConfiguration</span></strong><span class="koboSpan" id="kobo.1818.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1819.1">ProductDatafetcher</span></strong><span class="koboSpan" id="kobo.1820.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1821.1">BigDecimalScalar</span></strong><span class="koboSpan" id="kobo.1822.1">. </span><span class="koboSpan" id="kobo.1822.2">You should add only those classes here that are required to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">the test.</span></span></p>
<p><span class="koboSpan" id="kobo.1824.1">Then, you are auto-wiring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1825.1">DgsQueryExecutor</span></strong><span class="koboSpan" id="kobo.1826.1"> class, which provides the query execution capability to your test. </span><span class="koboSpan" id="kobo.1826.2">After that, you add two Spring-injected mock beans for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1827.1">Product</span></strong><span class="koboSpan" id="kobo.1828.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1829.1">Tag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1830.1"> services.</span></span></p>
<p><span class="koboSpan" id="kobo.1831.1">You are ready</span><a id="_idIndexMarker1384"/><span class="koboSpan" id="kobo.1832.1"> with the configuration</span><a id="_idIndexMarker1385"/><span class="koboSpan" id="kobo.1833.1"> and instances you need to run </span><span class="No-Break"><span class="koboSpan" id="kobo.1834.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1835.1">Let’s add the setup method that is required before running the tests. </span><span class="koboSpan" id="kobo.1835.2">You can add the following method for this purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.1836.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1837.1">ProductDatafetcherTest.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1838.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1839.1">@BeforeEach</span></strong><span class="koboSpan" id="kobo.1840.1">public void beforeEach() {
 List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();
 tags.add(Tag.newBuilder().id("tag1").name("Tag 1").build());
 Product product = Product.newBuilder().id("any")
      .name("mock title").description("mock description")
      .price(BigDecimal.valueOf(20.20)).count(100)
      .tags(tags).build();
 </span><strong class="bold"><span class="koboSpan" id="kobo.1841.1">given</span></strong><span class="koboSpan" id="kobo.1842.1">(productService.getProduct
    ("any")).</span><strong class="bold"><span class="koboSpan" id="kobo.1843.1">willReturn</span></strong><span class="koboSpan" id="kobo.1844.1">(product);
 tags.add(Tag.newBuilder().id("tag2")
       .name("addTags").build());
 product.setTags(tags);
 </span><strong class="bold"><span class="koboSpan" id="kobo.1845.1">given</span></strong><span class="koboSpan" id="kobo.1846.1">(tagService.addTags("any",
    List.of(TagInput.newBuilder().name("addTags").build())))
       .</span><strong class="bold"><span class="koboSpan" id="kobo.1847.1">willAnswer</span></strong><span class="koboSpan" id="kobo.1848.1">(invocation -&gt; product);
}</span></pre>
<p><span class="koboSpan" id="kobo.1849.1">Here, you are using Mockito to stub the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1850.1">productService.getProduct()</span></strong><span class="koboSpan" id="kobo.1851.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1852.1">tagService.addTags()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1853.1"> calls.</span></span></p>
<p><span class="koboSpan" id="kobo.1854.1">You are done</span><a id="_idIndexMarker1386"/><span class="koboSpan" id="kobo.1855.1"> with the setup. </span><span class="koboSpan" id="kobo.1855.2">Let’s run our first test, which will fetch the JSON object</span><a id="_idIndexMarker1387"/><span class="koboSpan" id="kobo.1856.1"> after running the GraphQL </span><strong class="source-inline"><span class="koboSpan" id="kobo.1857.1">product</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1858.1">query next.</span></span></p>
<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.1859.1">Testing GraphQL queries</span></h2>
<p><span class="koboSpan" id="kobo.1860.1">Let’s add the following</span><a id="_idIndexMarker1388"/><span class="koboSpan" id="kobo.1861.1"> code to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1862.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1863.1"> to test the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1864.1">product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1865.1"> query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1866.1">
@Test@DisplayName("Verify JSON returned by the query 'product'")
public void </span><strong class="bold"><span class="koboSpan" id="kobo.1867.1">product</span></strong><span class="koboSpan" id="kobo.1868.1">() {
  String name = </span><strong class="bold"><span class="koboSpan" id="kobo.1869.1">dgsQueryExecutor.executeAndExtractJsonPath</span></strong><span class="koboSpan" id="kobo.1870.1">(
      "{</span><strong class="bold"><span class="koboSpan" id="kobo.1871.1">product</span></strong><span class="koboSpan" id="kobo.1872.1">(id: \"any\"){ name }}",
          "data.product.name");
  assertThat(name).contains("mock title");
}</span></pre>
<p><span class="koboSpan" id="kobo.1873.1">Here, the code is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1874.1">DgsQueryExecutor</span></strong><span class="koboSpan" id="kobo.1875.1"> instance to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">product</span></strong><span class="koboSpan" id="kobo.1877.1"> query and extract the JSON property. </span><span class="koboSpan" id="kobo.1877.2">Then, it validates the name extracted from the JSON and compares it with the value set in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1878.1">beforeEach()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1879.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1880.1">Next, you’ll test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1881.1">product</span></strong><span class="koboSpan" id="kobo.1882.1"> query again, but this time, to test </span><span class="No-Break"><span class="koboSpan" id="kobo.1883.1">the exception.</span></span></p>
<p><span class="koboSpan" id="kobo.1884.1">You can add</span><a id="_idIndexMarker1389"/><span class="koboSpan" id="kobo.1885.1"> the following code to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1886.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1887.1"> to test the exception thrown by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1888.1">product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1889.1"> query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1890.1">
@Test@DisplayName("Verify exception to query product – invalid ID")
public void </span><strong class="bold"><span class="koboSpan" id="kobo.1891.1">productWithException</span></strong><span class="koboSpan" id="kobo.1892.1">() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1893.1">given</span></strong><span class="koboSpan" id="kobo.1894.1">(productService.getProduct("any"))
     .</span><strong class="bold"><span class="koboSpan" id="kobo.1895.1">willThrow</span></strong><span class="koboSpan" id="kobo.1896.1">(new RuntimeException
          ("Invalid Product ID."));
  </span><strong class="bold"><span class="koboSpan" id="kobo.1897.1">ExecutionResult</span></strong><span class="koboSpan" id="kobo.1898.1"> res = </span><strong class="bold"><span class="koboSpan" id="kobo.1899.1">dgsQueryExecutor.execute</span></strong><span class="koboSpan" id="kobo.1900.1">(
         "{ product (id: \"any\") { name }}");
  verify(productService, </span><strong class="bold"><span class="koboSpan" id="kobo.1901.1">times(1)</span></strong><span class="koboSpan" id="kobo.1902.1">).getProduct("any");
  assertThat(res.getErrors()).</span><strong class="bold"><span class="koboSpan" id="kobo.1903.1">isNotEmpty</span></strong><span class="koboSpan" id="kobo.1904.1">();
  </span><strong class="bold"><span class="koboSpan" id="kobo.1905.1">assertThat</span></strong><span class="koboSpan" id="kobo.1906.1">(res.getErrors().get(0).getMessage()).</span><strong class="bold"><span class="koboSpan" id="kobo.1907.1">isEqualTo</span></strong><span class="koboSpan" id="kobo.1908.1">(
         "java.lang.RuntimeException:
             Invalid Product ID.");
}</span></pre>
<p><span class="koboSpan" id="kobo.1909.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1910.1">productService</span></strong><span class="koboSpan" id="kobo.1911.1"> method is stubbed to throw the exception. </span><span class="koboSpan" id="kobo.1911.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.1912.1">DgsQueryExecutor</span></strong><span class="koboSpan" id="kobo.1913.1"> runs, the Spring-injected mock bean uses the stubbed method to throw the exception that is being </span><span class="No-Break"><span class="koboSpan" id="kobo.1914.1">asserted here.</span></span></p>
<p><span class="koboSpan" id="kobo.1915.1">Next, let’s query </span><strong class="source-inline"><span class="koboSpan" id="kobo.1916.1">product</span></strong><span class="koboSpan" id="kobo.1917.1"> again, this time</span><a id="_idIndexMarker1390"/><span class="koboSpan" id="kobo.1918.1"> to explore </span><strong class="source-inline"><span class="koboSpan" id="kobo.1919.1">GraphQLQueryRequest</span></strong><span class="koboSpan" id="kobo.1920.1">, which allows you to form the GraphQL query in a fluent way. </span><span class="koboSpan" id="kobo.1920.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">GraphQLQueryRequest</span></strong><span class="koboSpan" id="kobo.1922.1"> construction takes two arguments – first, the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1923.1">GraphVQLQuery</span></strong><span class="koboSpan" id="kobo.1924.1">, which can be a query/mutation or subscription, and second, the projection root type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1925.1">BaseProjectionNode</span></strong><span class="koboSpan" id="kobo.1926.1">, which allows you to select </span><span class="No-Break"><span class="koboSpan" id="kobo.1927.1">the fields.</span></span></p>
<p><span class="koboSpan" id="kobo.1928.1">Let’s add the following code to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1929.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1930.1"> to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1931.1">product</span></strong><span class="koboSpan" id="kobo.1932.1"> query </span><span class="No-Break"><span class="koboSpan" id="kobo.1933.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1934.1">GraphQLQueryRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1935.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1936.1">
@Test@DisplayName("Verify JSON using GraphQLQueryRequest")
void productsWithQueryApi() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1937.1">GraphQLQueryRequest</span></strong><span class="koboSpan" id="kobo.1938.1"> gqlRequest = new GraphQLQueryRequest(
    </span><strong class="bold"><span class="koboSpan" id="kobo.1939.1">ProductGraphQLQuery</span></strong><span class="koboSpan" id="kobo.1940.1">.newRequest().id("any").build(),
    new </span><strong class="bold"><span class="koboSpan" id="kobo.1941.1">ProductProjectionRoot</span></strong><span class="koboSpan" id="kobo.1942.1">().id().name());
  String name = dgsQueryExecutor.executeAndExtractJsonPath(
      </span><strong class="bold"><span class="koboSpan" id="kobo.1943.1">gqlRequest.serialize()</span></strong><span class="koboSpan" id="kobo.1944.1">, "data.product.name");
  assertThat(name).contains("mock title");
}</span></pre>
<p><span class="koboSpan" id="kobo.1945.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1946.1">ProductGraphQLQuery</span></strong><span class="koboSpan" id="kobo.1947.1"> class is part of the auto-generated code by the DGS GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.1948.1">Gradle plugin.</span></span></p>
<p><span class="koboSpan" id="kobo.1949.1">One thing we have not yet tested</span><a id="_idIndexMarker1391"/><span class="koboSpan" id="kobo.1950.1"> in previous tests is verifying the subfields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">tags</span></strong><span class="koboSpan" id="kobo.1952.1"> field </span><span class="No-Break"><span class="koboSpan" id="kobo.1953.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1954.1">product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1955.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1956.1">Let’s verify it in the next test case. </span><span class="koboSpan" id="kobo.1956.2">Add the following code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1957.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1958.1"> to verify </span><span class="No-Break"><span class="koboSpan" id="kobo.1959.1">the tags:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1960.1">
@Test@DisplayName("Verify Tags returned by the query 'product'")
void productsWithTags() {
  GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
      </span><strong class="bold"><span class="koboSpan" id="kobo.1961.1">ProductGraphQLQuery</span></strong><span class="koboSpan" id="kobo.1962.1">.newRequest().id("any").build(),
      new ProductProjectionRoot().id().name().tags()
      .id().name());
  Product product = dgsQueryExecutor
    .executeAndExtractJsonPathAsObject(gqlRequest.serialize(),
       "data.product", </span><strong class="bold"><span class="koboSpan" id="kobo.1963.1">new TypeRef&lt;&gt;() {}</span></strong><span class="koboSpan" id="kobo.1964.1">);
  assertThat(product.getId()).isEqualTo("any");
  assertThat(product.getName()).isEqualTo("mock title");
  assertThat(product.getTags().size()).isEqualTo(2);
  assertThat(product.getTags().get(0).getName())
    .isEqualTo("Tag 1");
}</span></pre>
<p><span class="koboSpan" id="kobo.1965.1">Here, you can see that you have to use a third argument (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1966.1">TypeRef</span></strong><span class="koboSpan" id="kobo.1967.1">) in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1968.1">executeAndExtractJsonPathAsObject()</span></strong><span class="koboSpan" id="kobo.1969.1"> method if you want to query the subfields. </span><span class="koboSpan" id="kobo.1969.2">If you don’t use it, you will get </span><span class="No-Break"><span class="koboSpan" id="kobo.1970.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.1971.1">You are done with GraphQL query</span><a id="_idIndexMarker1392"/><span class="koboSpan" id="kobo.1972.1"> testing. </span><span class="koboSpan" id="kobo.1972.2">Let’s move on to testing the mutations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1973.1">next subsection.</span></span></p>
<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.1974.1">Testing GraphQL mutations</span></h2>
<p><span class="koboSpan" id="kobo.1975.1">Testing a GraphQL mutation</span><a id="_idIndexMarker1393"/><span class="koboSpan" id="kobo.1976.1"> is no different from testing </span><span class="No-Break"><span class="koboSpan" id="kobo.1977.1">GraphQL queries.</span></span></p>
<p><span class="koboSpan" id="kobo.1978.1">Let’s test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1979.1">addTag</span></strong><span class="koboSpan" id="kobo.1980.1"> mutation to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1981.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1982.1"> as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1983.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1984.1">
@Test@DisplayName("Verify the mutation 'addTags'")
void addTagsMutation() {
  GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
      </span><strong class="bold"><span class="koboSpan" id="kobo.1985.1">AddTagGraphQLQuery</span></strong><span class="koboSpan" id="kobo.1986.1">.newRequest().productId("any")
          .tags(List.of(TagInput.newBuilder()
          .name("addTags").build())).build(),
        new AddTagProjectionRoot().name().count());
  ExecutionResult exeResult = dgsQueryExecutor.execute(
      gqlRequest.serialize());
  assertThat(exeResult.getErrors()).isEmpty();
  verify(tagService).addTags("any", List.of(
        TagInput.newBuilder().name("addTags").build()));
}</span></pre>
<p><span class="koboSpan" id="kobo.1987.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1988.1">AddTagGraphQLQuery</span></strong><span class="koboSpan" id="kobo.1989.1"> class is part of the code auto-generated by the DGS GraphQL Gradle plugin. </span><span class="koboSpan" id="kobo.1989.2">You fire the request and then validate the results based on the existing configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.1990.1">and setup.</span></span></p>
<p><span class="koboSpan" id="kobo.1991.1">Similarly, you can test</span><a id="_idIndexMarker1394"/><span class="koboSpan" id="kobo.1992.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1993.1">addQuantity</span></strong><span class="koboSpan" id="kobo.1994.1"> mutation. </span><span class="koboSpan" id="kobo.1994.2">Only the arguments and assertions will change; the core logic and classes will remain </span><span class="No-Break"><span class="koboSpan" id="kobo.1995.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.1996.1">You can add the test to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1997.1">ProductDatafetcherTest.java</span></strong><span class="koboSpan" id="kobo.1998.1"> as shown in the next code block to test the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1999.1">addQuantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1"> mutation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2001.1">
@Test@DisplayName("Verify the mutation 'addQuantity'")
void addQuantityMutation() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.2002.1">given</span></strong><span class="koboSpan" id="kobo.2003.1">(productService.addQuantity("a1s2d3f4-1", TEN))
      .</span><strong class="bold"><span class="koboSpan" id="kobo.2004.1">willReturn</span></strong><span class="koboSpan" id="kobo.2005.1">(repo.addQuantity("a1s2d3f4-1", TEN));
  GraphQLQueryRequest </span><strong class="bold"><span class="koboSpan" id="kobo.2006.1">gqlRequest</span></strong><span class="koboSpan" id="kobo.2007.1"> = new GraphQLQueryRequest(
       AddQuantityGraphQLQuery.newRequest()
      .productId("a1s2d3f4-1").quantity(TEN).build(),
        new AddQuantityProjectionRoot().name().count());
  ExecutionResult </span><strong class="bold"><span class="koboSpan" id="kobo.2008.1">exeResult</span></strong><span class="koboSpan" id="kobo.2009.1"> = dgsQueryExecutor
                           .execute(gqlRequest.serialize());
  assertThat(executionResult.getErrors()).isEmpty();
  Object obj = executionResult.getData();
  assertThat(obj).isNotNull();
  Map&lt;String, Object&gt; data = (Map)((Map
      )exeResult.getData()).get(MUTATION.AddQuantity);
  org.hamcrest.MatcherAssert.assertThat(
       (Integer) data.get("count"), greaterThan(TEN));
}</span></pre>
<p><span class="koboSpan" id="kobo.2010.1">You are done with GraphQL mutation</span><a id="_idIndexMarker1395"/><span class="koboSpan" id="kobo.2011.1"> testing. </span><span class="koboSpan" id="kobo.2011.2">Let’s move on to testing subscriptions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2012.1">next subsection.</span></span></p>
<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.2013.1">Testing GraphQL subscriptions using automated test code</span></h2>
<p><span class="koboSpan" id="kobo.2014.1">Testing a subscription</span><a id="_idIndexMarker1396"/><span class="koboSpan" id="kobo.2015.1"> needs extra effort and care, as you can see</span><a id="_idIndexMarker1397"/><span class="koboSpan" id="kobo.2016.1"> in the following code, which performs the test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2017.1">quantityChanged</span></strong><span class="koboSpan" id="kobo.2018.1"> subscription. </span><span class="koboSpan" id="kobo.2018.2">It uses the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.2019.1">addQuantity</span></strong><span class="koboSpan" id="kobo.2020.1"> mutation to trigger the subscription publisher that sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2021.1">product</span></strong><span class="koboSpan" id="kobo.2022.1"> object on each call. </span><span class="koboSpan" id="kobo.2022.2">You capture the product of the first call and store the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2023.1">count</span></strong><span class="koboSpan" id="kobo.2024.1"> field. </span><span class="koboSpan" id="kobo.2024.2">Then, use it to perform the assertion as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2025.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2026.1">
@Test@DisplayName("Verify the subscription 'quantityChanged'")
void reviewSubscription() {
  given(productService.gerProductPublisher())
      .willReturn(repo.getProductPublisher());
  ExecutionResult exeResult = </span><strong class="bold"><span class="koboSpan" id="kobo.2027.1">dgsQueryExecutor.execute</span></strong><span class="koboSpan" id="kobo.2028.1">(
     "subscription {quantityChanged
        {id name price count}}");
  </span><strong class="bold"><span class="koboSpan" id="kobo.2029.1">Publisher</span></strong><span class="koboSpan" id="kobo.2030.1">&lt;ExecutionResult&gt; pub = </span><strong class="bold"><span class="koboSpan" id="kobo.2031.1">exeResult.getData()</span></strong><span class="koboSpan" id="kobo.2032.1">;
  List&lt;Product&gt; products = new CopyOnWriteArrayList&lt;&gt;();
  </span><strong class="bold"><span class="koboSpan" id="kobo.2033.1">pub.subscribe(new Subscriber&lt;&gt;() {</span></strong><span class="koboSpan" id="kobo.2034.1">
    @Override
    public void onSubscribe(Subscription s) {s.request(2);}
    @Override
    public void </span><strong class="bold"><span class="koboSpan" id="kobo.2035.1">onNext</span></strong><span class="koboSpan" id="kobo.2036.1">(ExecutionResult result) {
        if (result.getErrors().size() &gt; 0) {
          System.out.println(result.getErrors());
        }
        Map&lt;String, Object&gt; data = result.getData();
        products.add(
          new ObjectMapper().convertValue(data.get(
          SUBSCRIPTION.QuantityChanged), Product.class));
    }
    @Override
    public void onError(Throwable t) {}
    @Override
    public void onComplete() {}
  });
  </span><strong class="bold"><span class="koboSpan" id="kobo.2037.1">addQuantityMutation()</span></strong><span class="koboSpan" id="kobo.2038.1">;
  Integer count = products.get(0).getCount();
  </span><strong class="bold"><span class="koboSpan" id="kobo.2039.1">addQuantityMutation()</span></strong><span class="koboSpan" id="kobo.2040.1">;
  assertThat(products.get(0).getId())
      .isEqualTo(products.get(1).getId());
  assertThat(products.get(1).getCount())
      .isEqualTo(count + TEN);
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.2041.1">Here, the core logic lies in the subscription that is done by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2042.1">publisher.subscribe()</span></strong><span class="koboSpan" id="kobo.2043.1"> method (check the highlighted line). </span><span class="koboSpan" id="kobo.2043.2">You know that the GraphQL </span><strong class="source-inline"><span class="koboSpan" id="kobo.2044.1">quantityChanged</span></strong><span class="koboSpan" id="kobo.2045.1"> subscription returns the publisher. </span><span class="koboSpan" id="kobo.2045.2">This publisher is received from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2046.1">data</span></strong><span class="koboSpan" id="kobo.2047.1"> field of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2048.1">execution result.</span></span></p>
<p><span class="koboSpan" id="kobo.2049.1">The publisher subscribes</span><a id="_idIndexMarker1398"/><span class="koboSpan" id="kobo.2050.1"> to the stream by passing</span><a id="_idIndexMarker1399"/><span class="koboSpan" id="kobo.2051.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2052.1">Subscriber</span></strong><span class="koboSpan" id="kobo.2053.1"> object, which is created on the fly. </span><span class="koboSpan" id="kobo.2053.2">The subscriber’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.2054.1">onNext()</span></strong><span class="koboSpan" id="kobo.2055.1"> method is used to receive the product sent by the GraphQL server. </span><span class="koboSpan" id="kobo.2055.2">These objects are pushed into the list. </span><span class="koboSpan" id="kobo.2055.3">Then, you use this list to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.2056.1">the assertion.</span></span></p>
<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.2057.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2058.1">In this chapter, you learned about the different ways of implementing the GraphQL server, including federated GraphQL services. </span><span class="koboSpan" id="kobo.2058.2">You have also explored the complete standalone GraphQL server implementation, which performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.2059.1">following operations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2060.1">Writing the </span><span class="No-Break"><span class="koboSpan" id="kobo.2061.1">GraphQL schema</span></span></li>
<li><span class="koboSpan" id="kobo.2062.1">Implementing the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.2063.1">query APIs</span></span></li>
<li><span class="koboSpan" id="kobo.2064.1">Implementing the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.2065.1">mutation APIs</span></span></li>
<li><span class="koboSpan" id="kobo.2066.1">Implementing the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.2067.1">subscription APIs</span></span></li>
<li><span class="koboSpan" id="kobo.2068.1">Writing the data loaders to solve the </span><span class="No-Break"><span class="koboSpan" id="kobo.2069.1">N+1 problem</span></span></li>
<li><span class="koboSpan" id="kobo.2070.1">Adding custom </span><span class="No-Break"><span class="koboSpan" id="kobo.2071.1">scalar types</span></span></li>
<li><span class="koboSpan" id="kobo.2072.1">Adding the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.2073.1">API’s instrumentation</span></span></li>
<li><span class="koboSpan" id="kobo.2074.1">Writing the GraphQL API’s test automation using Netflix’s </span><span class="No-Break"><span class="koboSpan" id="kobo.2075.1">DGS framework</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2076.1">You learned about GraphQL API implementation using Spring and Spring Boot skills that will help you implement GraphQL APIs for your work assignments and </span><span class="No-Break"><span class="koboSpan" id="kobo.2077.1">personal projects.</span></span></p>
<h1 id="_idParaDest-342"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.2078.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.2079.1">Why should you prefer frameworks such as Netflix’s DGS in place of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2080.1">graphql-java</span></strong><span class="koboSpan" id="kobo.2081.1"> library to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.2082.1">GraphQL APIs?</span></span></li>
<li><span class="koboSpan" id="kobo.2083.1">What are federated </span><span class="No-Break"><span class="koboSpan" id="kobo.2084.1">GraphQL services?</span></span></li>
</ol>
<h1 id="_idParaDest-343"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.2085.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.2086.1">You should prefer a framework such as Netflix DGS in place of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2087.1">graphql-java</span></strong><span class="koboSpan" id="kobo.2088.1"> library to implement GraphQL APIs because it bootstraps the development and avoids writing </span><span class="No-Break"><span class="koboSpan" id="kobo.2089.1">boilerplate code.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.2090.1">Apart from the ease of development, the framework uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.2091.1">graphql-java</span></strong><span class="koboSpan" id="kobo.2092.1"> internally; therefore, it keeps itself in sync with the GraphQL specification’s Java implementation. </span><span class="koboSpan" id="kobo.2092.2">It also supports developing federated </span><span class="No-Break"><span class="koboSpan" id="kobo.2093.1">GraphQL services.</span></span></p>
<p><span class="koboSpan" id="kobo.2094.1">It also provides plugins, the Java client, and testing utilities that help you to automate the development. </span><span class="koboSpan" id="kobo.2094.2">The Netflix DGS framework is well tested and has been used by Netflix in production for quite </span><span class="No-Break"><span class="koboSpan" id="kobo.2095.1">some time.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.2096.1">A federated GraphQL service contains a single distributed graph exposed using a gateway. </span><span class="koboSpan" id="kobo.2096.2">Clients call the gateway, which is an entry point to the system. </span><span class="koboSpan" id="kobo.2096.3">A data graph will be distributed among multiple services and each service can maintain its own development and release cycle independently. </span><span class="koboSpan" id="kobo.2096.4">Having said that, federated GraphQL services still follow the OneGraph principle. </span><span class="koboSpan" id="kobo.2096.5">Therefore, the client would query a single endpoint for fetching any part of </span><span class="No-Break"><span class="koboSpan" id="kobo.2097.1">the graph.</span></span></li>
</ol>
<h1 id="_idParaDest-344"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.2098.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.2099.1">GraphQL Java implementation: </span><a href="https://www.graphql-java.com/"><span class="koboSpan" id="kobo.2100.1">https://www.graphql-java.com/</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.2101.1">and </span></span><a href="https://github.com/graphql-java/graphql-java"><span class="No-Break"><span class="koboSpan" id="kobo.2102.1">https://github.com/graphql-java/graphql-java</span></span></a></li>
<li><span class="koboSpan" id="kobo.2103.1">Netflix DGS </span><span class="No-Break"><span class="koboSpan" id="kobo.2104.1">documentation: </span></span><a href="https://netflix.github.io/dgs/getting-started/"><span class="No-Break"><span class="koboSpan" id="kobo.2105.1">https://netflix.github.io/dgs/getting-started/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.2106.1">Full-Stack Web Development with GraphQL and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2107.1">React</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2108.1">: </span></span><a href="https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880"><span class="No-Break"><span class="koboSpan" id="kobo.2109.1">https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880</span></span></a></li>
</ul>
</div>
</body></html>