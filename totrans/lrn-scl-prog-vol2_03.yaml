- en: Giving Meaning to Programs with Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数为程序赋予意义
- en: '"Object-oriented programming makes code understandable by encapsulating moving
    parts; functional programming makes code understandable by minimizing moving parts."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"面向对象编程通过封装移动部分使代码易于理解；函数式编程通过最小化移动部分使代码易于理解。"'
- en: '- Michael Feathers'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 迈克尔·费思'
- en: Scala, as a mixed paradigm language, motivates you to reuse the code that you
    write and, at the same time, expects you to follow the motive behind functional
    programming. That motive is that your program should be decomposed into smaller
    abstractions to complete a well-defined task. This can be achieved using functions.
    A function is nothing but a logical construct that performs a certain task and
    can be reused as needed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种混合范式语言，Scala鼓励你重用你编写的代码，同时期望你遵循函数式编程背后的动机。这个动机是，你的程序应该被分解成更小的抽象来完成一个定义良好的任务。这可以通过使用函数来实现。函数不过是一个执行特定任务并可以按需重用的逻辑构造。
- en: 'There are certain ways these functions can be introduced and applied into our
    programs. There are many reasons why functions can be used in our programs. Functions,
    well-written with the exact number of needed arguments, with well-defined scope
    and privacy make your code look good. Moreover, these functions give meaning to
    your program. There are specific evaluation strategies based on our needs that
    can be incorporated using some syntactical changes. For example, evaluation of
    a function if, and only if, it is needed, or lazy evaluation, means expressions
    are going to be evaluated when they are first accessed. Let''s get ready to be
    introduced to functions in Scala. In this chapter, we''ll become familiar with:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以将这些函数引入并应用到我们的程序中。有许多原因可以在我们的程序中使用函数。编写得好的函数，具有确切数量的所需参数，具有明确定义的作用域和隐私性，可以使你的代码看起来很好。此外，这些函数给你的程序赋予了意义。根据我们的需求，可以采用一些语法变化来采用特定的评估策略。例如，只有在需要时才评估函数，或者惰性评估，意味着表达式将在首次访问时进行评估。让我们准备好了解Scala中的函数。在本章中，我们将熟悉以下内容：
- en: Function syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数语法
- en: Calling a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数
- en: Function literals/anonymous functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数字面量/匿名函数
- en: Evaluation strategies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估策略
- en: Partial functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分函数
- en: So let's start our discussion with what it takes to write a function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从编写函数所需的内容开始我们的讨论。
- en: Function syntax
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数语法
- en: 'Functions in Scala can be written using the `def` keyword, followed by the
    name of the function, with some arguments supplied as inputs to the function.
    Let''s take a look at the generic syntax for a function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的函数可以使用`def`关键字来编写，后面跟函数名，并给函数提供一些作为输入的参数。让我们看看函数的通用语法：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding syntax shows the generic function signature in Scala. First,
    we give modifiers for the function. Modifiers can be understood as properties
    defined for the function. Modifiers come in different forms. A few of them are
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法显示了Scala中通用的函数签名。首先，我们给出函数的修饰符。修饰符可以理解为为函数定义的属性。修饰符有多种形式。其中一些如下：
- en: Annotations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解
- en: Override modifier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖修饰符
- en: Access modifiers (`private`, and so on)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符（`private`等）
- en: The `final` keyword
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final`关键字'
- en: 'It''s recommended practice to use the preceding modifiers on an as-needed basis
    and in the given order. After specifying modifiers, we use the `def` keyword to
    denote a function followed by the name of the function. After giving the function
    name, we specify the parameters. The parameters are specified in parenthesis:
    first, the name of the parameter and then its type. This is a bit different from
    Java. In Java, this order is the exact opposite. Finally, we specify the return
    type of our function. We can also omit the return type, as Scala can infer it.
    Apart from some exceptional cases, it''ll work fine. For good readability of our
    programs, we can make it a practice to have the return type be a part of your
    function signature. After declaring the function, we can give the definition body.
    Let''s take a look at some concrete examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的做法是按需且按照给定顺序使用前面的修饰符。在指定修饰符后，我们使用`def`关键字来表示函数，然后跟函数名。在给出函数名之后，我们指定参数。参数在括号中指定：首先，参数名然后是其类型。这与Java有所不同。在Java中，这个顺序正好相反。最后，我们指定函数的返回类型。我们也可以省略返回类型，因为Scala可以推断它。除了某些特殊情况外，它将正常工作。为了提高我们程序的可读性，我们可以将返回类型作为函数签名的一部分。在声明函数之后，我们可以给出定义体。让我们看看一些具体的例子：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding example simply defines a function that expects two integer values,
    compares them, and returns an integer response. The definition is also simple
    where we are checking equality for inputs provided. If the values are equal, then
    `0` is returned; if the first value is greater than the second one we return `1`,
    otherwise we return `-1`. Here, we've not used any modifiers for our function.
    By default, Scala treats its functions as `public`, which means you can access
    them from any other class and override them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例简单地定义了一个期望两个整数值、比较它们并返回整数响应的函数。定义也很简单，我们正在检查输入的相等性。如果值相等，则返回`0`；如果第一个值大于第二个值，则返回`1`，否则返回`-1`。在这里，我们没有为我们的函数使用任何修饰符。默认情况下，Scala将其函数视为`public`，这意味着你可以从任何其他类访问它们并覆盖它们。
- en: 'If you take a closer look at the function body, it''s inline. We defined the
    function directly, and there are two reasons for this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察函数体，它是行内的。我们直接定义了函数，这样做有两个原因：
- en: To make our code simple and readable
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使我们的代码简单易读
- en: The definition was small enough to define on one line
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义足够小，可以放在一行中
- en: 'A recommended practice to define your function definition inline is when your
    function signature, along with the definition, is 30 characters or so. If it''s
    more but still concise, we can start the definition on the next line, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数定义行内的一个推荐做法是，当你的函数签名及其定义大约有30个字符时。如果它更长但仍然简洁，我们可以在下一行开始定义，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So the choice is yours; to make your code more readable, you may choose to
    define functions inline. If there are multiple lines in a function body, you may
    choose to encapsulate them within a pair of curly braces:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以选择权在你；为了使你的代码更易读，你可以选择在行内定义函数。如果函数体中有多行，你可以选择将它们封装在一对大括号内：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we have two statements in the function definition. The first is printing
    and the latter is evaluating the comparison. Hence, we encapsulated them using
    a pair of curly braces. Let''s take a look at the whole program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数定义中有两个语句。第一个是打印，后者是评估比较。因此，我们使用一对大括号将它们封装起来。让我们看看整个程序：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the result:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we define a function's body, the very last expression works as the return
    type for the function. In our case, the evaluation of `if else` expression, that
    is, an integer, will be the return type for the `compareIntegers` function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数体时，最后一个表达式作为函数的返回类型。在我们的例子中，`if else`表达式的评估，即一个整数，将是`compareIntegers`函数的返回类型。
- en: Nesting of functions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数嵌套
- en: 'Wherever we have the possibility of wrapping our logic, we transform the snippet
    into a function. If we do so a number of times, we may pollute our code. Also,
    when we decompose our functions into smaller helper units, we tend to give almost
    similar names. Let''s take an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们有封装逻辑的可能性，我们都将代码片段转换为一个函数。如果我们这样做很多次，可能会污染我们的代码。此外，当我们将函数分解成更小的辅助单元时，我们倾向于给出几乎相同的名字。让我们举一个例子：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding program, we defined the `compareIntegersV4` function, in which,
    after the evaluation of a comparison between two integers, we called a helper
    function named `giveAMeaningFullResult`*, *passing a result and two values. This
    function responds back with a meaningful string based on the result. The code
    works fine, but if you take a closer look and think about it, you may find that
    this private method is only meaningful to `compareIntegersV4`*,* hence it's better
    if the definition of `giveAMeaningFullResult` can be defined inside the function
    itself. Let's refactor our code to define the helper function in a nested manner
    inside `compareIntegersV5`*:*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们定义了`compareIntegersV4`函数，在该函数中，在评估两个整数的比较之后，我们调用了一个名为`giveAMeaningFullResult`的辅助函数，传递了一个结果和两个值。这个函数根据结果返回一个有意义的字符串。代码运行正常，但如果你仔细思考，可能会发现这个私有方法只对`compareIntegersV4`有意义，因此最好将`giveAMeaningFullResult`的定义放在函数内部。让我们重构我们的代码，以嵌套方式在`compareIntegersV5`内部定义辅助函数：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the preceding code, we defined the nested function as `giveAMeaningFullResult`*,*
    which has also been changed a bit. Now it's expecting only one parameter of integer
    type that responds back with a meaningful string. We're allowed to access all
    the variables of the enclosing function; that's why we omitted passing `value1`
    and `value2` to our nested helper function*.* This has made our code look cleaner.
    We were able to make a call to our function directly passing arguments, in our
    case `2` and `1`. There are a variety of ways we can make a function call; why
    don't we go ahead and take a look at them?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上述代码中所见，我们定义了一个嵌套函数`giveAMeaningFullResult`*，*并且也做了一些修改。现在它只期望接收一个整数类型的参数，并返回一个有意义的字符串。我们可以访问外部函数的所有变量；这就是为什么我们没有将`value1`和`value2`传递给我们的嵌套辅助函数*.*
    这使得我们的代码看起来更简洁。我们能够直接传递参数调用我们的函数，在我们的例子中是`2`和`1`。我们可以以多种方式调用函数；我们为什么不看看这些方式呢？
- en: Calling a function
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'We can call a function to perform the task we defined for it. While calling,
    we pass the arguments that the function takes as input parameters. This can be
    achieved in a variety of ways: we can specify a variable number of arguments,
    we can specify the name of the argument, or we can specify a default value to
    consider in case the argument is not passed while calling the function. Let''s
    take a scenario where we are not sure about the number of arguments to be passed
    to a function for evaluation but we are sure about the type of it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用一个函数来执行我们为其定义的任务。在调用时，我们传递函数作为输入参数的参数。这可以通过多种方式实现：我们可以指定可变数量的参数，我们可以指定参数的名称，或者我们可以指定一个默认值，以防在调用函数时未传递参数。让我们考虑一个场景，我们不确定要传递给函数进行评估的参数数量，但我们确定它的类型。
- en: Passing a variable number of arguments
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递可变数量的参数
- en: 'If you remember, we''ve already seen an example for functions that take a variable
    number of arguments and perform operations on them in the previous chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们在上一章已经看到了一个关于接受可变数量参数并在其上执行操作的函数的例子：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our method takes index numbers and prints those pages from the document passed
    as the first parameter. Here, the parameter `indexes` is called a **vararg***.*
    This indicates that we can pass any number of arguments of the type specified;
    in this case, we specified `Int`*.* While calling this function, we can pass any
    number of arguments of type `Int`*.* We've already tried that. Now, let's think
    of a mathematical function that expects a number of integers and responds back
    with the average of all the numbers. How should it look?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法接受索引数字，并打印出作为第一个参数传递的文档中的那些页面。在这里，参数`indexes`被称为**可变参数***.* 这表示我们可以传递任何指定类型的参数数量；在这种情况下，我们指定了`Int`*.*
    在调用此函数时，我们可以传递任何类型的`Int`*.* 我们已经尝试过了。现在，让我们考虑一个期望接收多个整数并返回所有数字平均值的数学函数。它应该是什么样子呢？
- en: 'It may be a signature with the `def` keyword, with a name and parameters, or
    just one *vararg*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能是一个带有`def`关键字、名称和参数的签名，或者只是一个*可变参数*：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is the signature for our `average` function. The body for
    the function is yet to be defined:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是`average`函数的签名。函数的主体尚未定义：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at the first `average` function; it expects a variable argument
    of type `Int`*.* It has been called with arguments `2` and `2`. Here the number
    of arguments was 2\. We''re allowed to provide any number of arguments to perform
    the operation. The definition of our function uses the `fold` operation to perform
    summing of all the numbers passed. We''ll see the details of how `fold` works
    in the next chapter, when we discuss the functions for our collections. For now,
    just understand that it traverses through each element of a collection and performs
    operations with a supplied argument, that is, `0` in our case. We called the function
    with a different number of arguments. In the same way, we can define our function
    to support a variable number of arguments of any type. We can call the function
    accordingly. The only requirement is that the *vararg* parameter should come last
    in the function signature''s parameters list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个 `average` 函数；它期望一个类型为 `Int`* 的可变参数。它已经用参数 `2` 和 `2` 被调用。这里参数的数量是 2。我们可以提供任意数量的参数来执行操作。我们函数的定义使用了
    `fold` 操作来对所有传递的数字进行求和。我们将在下一章讨论我们的集合函数时看到 `fold` 的工作细节。现在，只需理解它遍历集合中的每个元素并与提供的参数执行操作即可，在我们的例子中，即
    `0`。我们用不同数量的参数调用了函数。同样，我们可以定义我们的函数以支持任意类型的可变数量参数。我们可以相应地调用函数。唯一的要求是 *可变参数* 参数应该在函数签名参数列表的末尾：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means that `numbers`*,* that is, a variable parameter, should be declared
    last and declaring `wrongArgument` after that will give a *compile time error.*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `numbers`*，* 即一个可变参数，应该放在最后声明，之后声明 `wrongArgument` 将会导致 *编译时错误*。
- en: Calling a function with a default parameter value
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认参数值调用函数
- en: 'We''re allowed to give default parameter values at the time of declaring a
    function. If we do so, we can avoid passing an argument for that parameter while
    calling the function. Let''s see how this works with an example. We''ve already
    seen this example, where we''re going to compare two integers. Let''s give the
    second parameter a default value of `10`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在声明函数时提供默认参数值。如果我们这样做，在调用函数时可以避免为该参数传递参数。让我们通过一个例子看看这是如何工作的。我们已经看到了这个例子，我们将比较两个整数。让我们给第二个参数一个默认值
    `10`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, while declaring the `compareIntegersV6` function, we gave a default value
    of `10` to parameter `value2`*.* At the end while calling the function, we passed
    only one argument:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们声明 `compareIntegersV6` 函数时，我们给参数 `value2`* 提供了一个默认值 `10`。在调用函数的末尾，我们只传递了一个参数：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While calling the function, we passed only one argument, `12`, which is the
    value for `value1`*.* In these situations the Scala compiler looks for a value
    bound to the other argument. In our case, the compiler was able to infer that
    for the other parameter there''s already a value of 10 by default, so the function
    application will evaluate based on these two values. Giving default values and
    using them works only if the Scala compiler can infer the values. In cases of
    ambiguity, it does not allow you to call a function. Let''s take an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，我们只传递了一个参数 `12`，这是 `value1`* 的值。在这些情况下，Scala 编译器会寻找绑定到其他参数的值。在我们的例子中，编译器能够推断出对于其他参数，默认值已经是
    10，所以函数应用将基于这两个值进行评估。提供默认值并使用它们仅在 Scala 编译器能够推断值的情况下才有效。在存在歧义的情况下，它不允许你调用函数。让我们举一个例子：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For this function, let''s try to call using the following function call:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，让我们尝试使用以下函数调用方式来调用：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Scala compiler will throw an error if we try to call a function in this
    way, because the compiler was not able to bind the value `12` to `value2`*,* because
    of the ordering of the argument. If somehow we can tell the compiler that the
    argument that we passed is bound to the parameter named `value2`, our function
    will work. To achieve this, we call the function passing the argument by name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试以这种方式调用函数，Scala 编译器将会抛出一个错误，因为编译器无法将值 `12` 绑定到 `value2`*，* 这是因为参数的顺序问题。如果我们能以某种方式告诉编译器我们传递的参数绑定到了名为
    `value2` 的参数上，我们的函数就能正常工作。为了实现这一点，我们通过命名传递参数来调用函数。
- en: Calling a function while passing named arguments
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在传递命名参数时调用函数
- en: 'Yes, while calling a function, we can directly name the arguments. This ensures
    freedom from the correct ordering of arguments passed. Let''s call our function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，在调用函数时，我们可以直接命名参数。这确保了参数传递的正确顺序不受限制。让我们调用我们的函数：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The reason behind this is simple: the only thing to ensure is that the Scala
    compiler is able to infer. This can also allow you to pass arguments regardless
    of the order in which they appear in the function signature. So it''s possible
    to call our function like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：唯一要确保的是Scala编译器能够推断。这也允许你无论函数签名中出现的顺序如何，都可以传递参数。因此，我们可以这样调用我们的函数：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the result:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This gives us more than one way to define and call our functions. The good news
    is that you can also pass functions into a function in the form of literals; we
    call them function literals. Let's go through what function literals look like.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了定义和调用函数的多种方式。好消息是，你还可以以字面量的形式将函数传递给函数；我们称之为函数字面量。让我们看看函数字面量是什么样的。
- en: Function literals
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量
- en: 'We can pass a function in the form of a literal to another function, to work
    for us. Let''s take the same `compareIntegers` function example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个函数以字面量的形式传递给另一个函数，让它为我们工作。让我们以相同的 `compareIntegers` 函数为例：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We know what our function is supposed to do: take two integer numbers as input
    and return an integer response telling us the result of our comparison. If we
    take a look at the abstract form of our function, it will look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的函数应该做什么：接收两个整数作为输入，并返回一个整数响应，告诉我们比较的结果。如果我们看一下我们函数的抽象形式，它将看起来像这样：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This means that the function is expecting two integers, and returning an integer
    response; our need is the same. It''s an abstract form that indicates that elements
    on the left are inputs and elements on the right are the response type for our
    function. We can say that this is in its literal form, also called **function
    literals***.* Hence, it''s also possible to assign this literal to any variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该函数期望两个整数，并返回一个整数响应；我们的需求是相同的。这是一个抽象形式，表示左侧的元素是输入，右侧的元素是函数的响应类型。我们可以说这是它的字面量形式，也称为**函数字面量**。因此，它也可以分配给任何变量：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remember in `PagePrinter` from the last chapter, we had a `print` function
    that took an index and printed that page:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在上一章的`PagePrinter`中，我们有一个接受索引并打印该页面的`print`函数：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we look at the form our function takes, it takes an integer and prints pages.
    So the form will look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看我们的函数的形式，它接受一个整数并打印页面。所以形式将如下所示：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Unit` keyword here represents that our literal does not respond back with
    any value. Now let''s take a scenario where the requirement is to tell the printer
    to print a page in color or simple. We''ll refactor our code to support using
    function literals:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Unit`关键字表示我们的字面量不会返回任何值。现在让我们考虑一个场景，要求告诉打印机以彩色或简单的方式打印一页。我们将重构我们的代码以支持使用函数字面量：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We refactored our `printPages` method and now it takes a *function literal.*
    The function literal represents our `print` function's form. We represented two
    forms of our `print` function, the first one prints *colored* pages and the latter
    prints *simple* pages. This made it simple to call the same function of `printPages`
    and pass a *function literal* as needed. All we had to do was tell the function
    this form of function can be passed and, while calling the function, we can pass
    a *function literal* of the same form.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构了`printPages`方法，现在它接受一个*函数字面量*。函数字面量代表我们的`print`函数的形式。我们表示了两种`print`函数的形式，第一种打印*彩色*页面，第二种打印*简单*页面。这使得调用相同的`printPages`函数并按需传递一个*函数字面量*变得简单。我们只需要告诉函数这种函数可以被传递，在调用函数时，我们可以传递相同形式的函数字面量。
- en: 'Scala also uses *function literals* in default constructs. One example is the
    `filter` function for collections. The `filter` function expects a predicate that
    checks for a condition and responds with a Boolean response, based on which we
    filter out elements in a list or collection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Scala在默认构造中也使用*函数字面量*。一个例子是集合的`filter`函数。`filter`函数期望一个谓词，该谓词检查条件并返回一个布尔响应，基于此，我们可以从列表或集合中过滤出元素：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The part where we checked if the name starts with `A` is an example of a *function **literal:*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查名称是否以`A`开头的那部分是一个*函数字面量*的例子：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Scala compiler only requires extra information where it is needed to infer
    type information; with this, it allows us to omit the parts that are just extra
    syntax, hence it''s possible to write the proceeding syntax as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编译器只在需要推断类型信息的地方需要额外信息；有了这个，它允许我们省略只是额外语法的部分，因此可以写成以下语法：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Evaluation strategies
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估策略
- en: When functions have some parameters defined in them, those function calls expect
    us to pass arguments while calling. And as we know, we can pass a *function literal*
    that gets evaluated at the time of the call or at the time when it is used. Scala
    supports *call by value* and *call by name* for functions. Let's discuss them
    in detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数中定义了一些参数时，这些函数调用期望我们在调用时传递参数。正如我们所知，我们可以传递一个在调用或使用时被评估的*函数字面量*。Scala支持函数的*按值调用*和*按名调用*。让我们详细讨论一下。
- en: Call by name
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按名调用
- en: 'Call by name is an evaluation strategy where we substitute the literal at the
    place from where we call our function. The literal gets evaluated when it first
    appears and gets called. We can understand this with a simple example. First,
    let''s take our `ColorPrinter` application and pass a Boolean function literal
    that checks if the printer is switched on. For that we can refactor our function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按名调用是一种评估策略，其中我们用调用函数的位置处的字面量来替换。字面量在第一次出现并被调用时进行评估。我们可以用一个简单的例子来理解这一点。首先，让我们以我们的`ColorPrinter`应用程序为例，并传递一个检查打印机是否开启的布尔函数字面量。为此，我们可以重构我们的函数：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To call this function, we can use:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个函数，我们可以使用：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two problems with this kind of approach. First, it looks odd; using
    a `() => expression` here, when we already know that it''s going to be a Boolean
    function literal. Second, we may not want our expression to get evaluated until
    it''s used. For that, we''ll make a small change in our `printPages` function
    signature:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个问题。首先，它看起来很奇怪；在这里使用``() => expression`，因为我们已经知道它将是一个布尔函数字面量。其次，我们可能不希望我们的表达式在它被使用之前被评估。为此，我们将在`printPages`函数签名中进行一些小的修改：
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为结果：
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Take a closer look and you''ll be able to see that we removed the `()` parenthesis
    and added `*=>*` in our function signature. This makes our code understand that
    this is a *by name* parameter, and to evaluate it only when it''s called. This
    is the reason we are allowed to make this call:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会发现我们在函数签名中移除了`()`括号，并添加了`*=>*`。这使得我们的代码理解这是一个*按名*参数，并且只有在调用时才会对其进行评估。这就是我们允许进行这种调用的原因：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This call consists of a Boolean expression as a last argument. And because our
    function expects it to be of *by name* type, it's going to be evaluated later
    when the call is actually made.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用由一个布尔表达式作为最后一个参数组成。由于我们的函数期望它是一个*按名*类型，它将在实际调用时被评估。
- en: Call by value
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按值调用
- en: '*Call by value* is a simple and common evaluation strategy, where an expression
    is evaluated and the result is bound to the parameter. At the place where the
    parameter is used, the bound value is simply substituted with that. We''ve already
    seen many examples for this strategy:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*按值调用*是一种简单且常见的评估策略，其中表达式被评估，结果被绑定到参数上。在参数被使用的地方，绑定的值简单地被替换。我们已经看到了许多这种策略的例子：'
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Calls made to this function are examples of the *call by value* strategy. We
    simply give values as arguments that get substituted in the function by parameter
    values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个函数的调用是*按值调用*策略的例子。我们简单地给出作为参数的值，这些值在函数中被参数值所替代。
- en: These strategies give us a variety of ways we can call a function. Also, evaluating
    an expression only when it's needed is characteristic of functional languages;
    it's called *lazy evaluation.* We'll learn about *lazy evaluation* in more detail
    in [Chapter 9](https://cdp.packtpub.com/learning_scala_programming/wp-admin/post.php?post=157&action=edit),
    *Using Powerful Functional Constructs*, when we'll discuss *powerful functional
    constructs.*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略为我们提供了多种调用函数的方式。此外，仅在需要时评估表达式是函数式语言的特征；这被称为*惰性评估*。我们将在第9章[使用强大的函数式构造](https://cdp.packtpub.com/learning_scala_programming/wp-admin/post.php?post=157&action=edit)中更详细地学习*惰性评估*，我们将讨论*强大的函数式构造*。
- en: Functional programming supports this analogy of writing functions that are valid
    and work for input values rather than failing them with an error. And to support
    this, Scala has a feature to define partial functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程支持这种编写函数的类比，这些函数对输入值有效且能正常工作，而不是通过错误来失败。为了支持这一点，Scala有一个定义部分函数的功能。
- en: Partial functions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数
- en: 'Partial functions do not suffice for every input given, which means these are
    defined to serve a purpose for a specific set of input parameters. To understand
    more, let''s first define a partial function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数对于给定的每个输入都不够用，这意味着这些函数是为特定的一组输入参数定义的，以实现特定目的。为了更好地理解，让我们首先定义一个部分函数：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we defined a partial function named `oneToFirst`*.*
    We also specified type parameters for our partial function; in our case we passed
    `Int`, `String`. The `PartialFunction` function is a trait in Scala, defined as:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为 `oneToFirst` 的部分函数*。我们还为我们的部分函数指定了类型参数；在我们的例子中，我们传递了 `Int`
    和 `String`。`PartialFunction` 函数是 Scala 中的一个特质，定义为：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The trait as shown expects two parameters `A` and `B`, that become the input
    and output types of our partial function. Our `oneToFirst` partial function simply
    expects `1` and returns a string representation for 1 as first. That''s why when
    we try to call the function by passing 1, it works fine; but if we try to pass
    any other argument, let''s say `2`, it''ll throw a `MatchError`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性显示期望两个参数 `A` 和 `B`，它们将成为我们部分函数的输入和输出类型。我们的 `oneToFirst` 部分函数仅期望 `1` 并返回 1
    的字符串表示形式作为第一个。这就是为什么当我们尝试通过传递 1 调用该函数时，它运行良好；但如果我们尝试传递任何其他参数，比如说 `2`，它将抛出一个 `MatchError`：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is because our partial function is only applicable for a single value,
    that is, `1`; and for others it''s not. To ensure that our function does not throw
    an error, we can check whether the partial function is applicable for a value
    or not using the `isDefinedAt` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的部分函数仅适用于单个值，即 `1`；对于其他值则不适用。为了确保我们的函数不会抛出错误，我们可以使用 `isDefinedAt` 方法检查部分函数是否适用于某个值：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For values that our partial function supports, `isDefinedAt` gives `true`; for
    other values, it returns `false`. These partial functions can also be composed.
    For that, the trait `PartialFunction` defines two methods: `orElse` and `andThen`*:*
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的部分函数支持的值，`isDefinedAt` 返回 `true`；对于其他值，它返回 `false`。这些部分函数也可以组合。为此，`PartialFunction`
    特质定义了两个方法：`orElse` 和 `andThen`*：*
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following is the result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为结果：
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding program, we defined the partial functions named `isPrimeEligible`
    and `amountMoreThan500`*,* and then composed another partial function using the `orElse` method ,
    which checks if the item is deliverable for free or not. Thus, partial functions
    provide us with ways to compose and define functions to serve specific purposes
    for a set of values. Moreover, partial functions give us a way to define separate
    logic from a given set of input values based on some distinction. It's important
    to keep in mind that our partial function works on only one operand. Hence, this
    is a form of unary function and it's the programmer's responsibility to check
    whether for a specific value, the function is defined or not.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们定义了名为 `isPrimeEligible` 和 `amountMoreThan500` 的部分函数*，然后使用 `orElse`
    方法组合了另一个部分函数，该方法检查项目是否可以免费交付。因此，部分函数为我们提供了组合和定义函数的方法，以服务于特定值集的特定目的。此外，部分函数还为我们提供了一种根据某些区分定义从给定输入值集合中分离逻辑的方法。重要的是要记住，我们的部分函数仅对一个操作数起作用。因此，这是一种一元函数的形式，程序员有责任检查对于特定值，函数是否已定义。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It's time to conclude our chapter. In this chapter, we had a brief introduction
    to the important concept of *functions* in Scala. We started with the syntax for
    defining a function. It is important to know that we're allowed to nest functions
    and make our code look cleaner. We learned about how we can make function calls
    in a variety of ways, for example with a variable number of arguments, with a
    default parameter value, and with a named argument. Then we learned how to write
    function literals in Scala. Afterwards, we discussed a couple of evaluation strategies
    for functions in Scala, where we talked about *call by name* and *call by value.*
    Finally, we discussed another important concept of defining a *partial function*
    in Scala.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候总结本章内容了。在本章中，我们对 Scala 中重要的 *函数* 概念进行了简要介绍。我们从定义函数的语法开始。重要的是要知道，我们可以嵌套函数并使我们的代码看起来更整洁。我们学习了如何以各种方式调用函数，例如使用可变数量的参数、默认参数值和使用命名参数。然后我们学习了如何在
    Scala 中编写函数字面量。之后，我们讨论了 Scala 中函数的几种评估策略，其中我们讨论了 *按名调用* 和 *按值调用*。最后，我们讨论了在 Scala
    中定义 *部分函数* 的另一个重要概念。
- en: With this chapter, we have completed the first part of our journey. Learning
    all these concepts has certainly increased our ability to write and understand
    a mature piece of Scala code. In later parts, we will continue to do so. The second
    part is about Scala's rich collections hierarchy. In the next chapter, we'll learn
    about the number of collections Scala provides and various methods to use collections
    in a variety of ways.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们完成了旅程的第一部分。学习所有这些概念无疑增加了我们编写和理解成熟Scala代码的能力。在后面的部分，我们将继续这样做。第二部分是关于Scala丰富的集合层次结构。在下一章，我们将学习Scala提供的集合数量以及以各种方式使用集合的各种方法。
