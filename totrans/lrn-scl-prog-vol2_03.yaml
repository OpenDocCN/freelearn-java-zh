- en: Giving Meaning to Programs with Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Object-oriented programming makes code understandable by encapsulating moving
    parts; functional programming makes code understandable by minimizing moving parts."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Michael Feathers'
  prefs: []
  type: TYPE_NORMAL
- en: Scala, as a mixed paradigm language, motivates you to reuse the code that you
    write and, at the same time, expects you to follow the motive behind functional
    programming. That motive is that your program should be decomposed into smaller
    abstractions to complete a well-defined task. This can be achieved using functions.
    A function is nothing but a logical construct that performs a certain task and
    can be reused as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain ways these functions can be introduced and applied into our
    programs. There are many reasons why functions can be used in our programs. Functions,
    well-written with the exact number of needed arguments, with well-defined scope
    and privacy make your code look good. Moreover, these functions give meaning to
    your program. There are specific evaluation strategies based on our needs that
    can be incorporated using some syntactical changes. For example, evaluation of
    a function if, and only if, it is needed, or lazy evaluation, means expressions
    are going to be evaluated when they are first accessed. Let''s get ready to be
    introduced to functions in Scala. In this chapter, we''ll become familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: Function syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function literals/anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's start our discussion with what it takes to write a function.
  prefs: []
  type: TYPE_NORMAL
- en: Function syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in Scala can be written using the `def` keyword, followed by the
    name of the function, with some arguments supplied as inputs to the function.
    Let''s take a look at the generic syntax for a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax shows the generic function signature in Scala. First,
    we give modifiers for the function. Modifiers can be understood as properties
    defined for the function. Modifiers come in different forms. A few of them are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access modifiers (`private`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `final` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s recommended practice to use the preceding modifiers on an as-needed basis
    and in the given order. After specifying modifiers, we use the `def` keyword to
    denote a function followed by the name of the function. After giving the function
    name, we specify the parameters. The parameters are specified in parenthesis:
    first, the name of the parameter and then its type. This is a bit different from
    Java. In Java, this order is the exact opposite. Finally, we specify the return
    type of our function. We can also omit the return type, as Scala can infer it.
    Apart from some exceptional cases, it''ll work fine. For good readability of our
    programs, we can make it a practice to have the return type be a part of your
    function signature. After declaring the function, we can give the definition body.
    Let''s take a look at some concrete examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example simply defines a function that expects two integer values,
    compares them, and returns an integer response. The definition is also simple
    where we are checking equality for inputs provided. If the values are equal, then
    `0` is returned; if the first value is greater than the second one we return `1`,
    otherwise we return `-1`. Here, we've not used any modifiers for our function.
    By default, Scala treats its functions as `public`, which means you can access
    them from any other class and override them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a closer look at the function body, it''s inline. We defined the
    function directly, and there are two reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: To make our code simple and readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition was small enough to define on one line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A recommended practice to define your function definition inline is when your
    function signature, along with the definition, is 30 characters or so. If it''s
    more but still concise, we can start the definition on the next line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So the choice is yours; to make your code more readable, you may choose to
    define functions inline. If there are multiple lines in a function body, you may
    choose to encapsulate them within a pair of curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have two statements in the function definition. The first is printing
    and the latter is evaluating the comparison. Hence, we encapsulated them using
    a pair of curly braces. Let''s take a look at the whole program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we define a function's body, the very last expression works as the return
    type for the function. In our case, the evaluation of `if else` expression, that
    is, an integer, will be the return type for the `compareIntegers` function.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting of functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wherever we have the possibility of wrapping our logic, we transform the snippet
    into a function. If we do so a number of times, we may pollute our code. Also,
    when we decompose our functions into smaller helper units, we tend to give almost
    similar names. Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we defined the `compareIntegersV4` function, in which,
    after the evaluation of a comparison between two integers, we called a helper
    function named `giveAMeaningFullResult`*, *passing a result and two values. This
    function responds back with a meaningful string based on the result. The code
    works fine, but if you take a closer look and think about it, you may find that
    this private method is only meaningful to `compareIntegersV4`*,* hence it's better
    if the definition of `giveAMeaningFullResult` can be defined inside the function
    itself. Let's refactor our code to define the helper function in a nested manner
    inside `compareIntegersV5`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we defined the nested function as `giveAMeaningFullResult`*,*
    which has also been changed a bit. Now it's expecting only one parameter of integer
    type that responds back with a meaningful string. We're allowed to access all
    the variables of the enclosing function; that's why we omitted passing `value1`
    and `value2` to our nested helper function*.* This has made our code look cleaner.
    We were able to make a call to our function directly passing arguments, in our
    case `2` and `1`. There are a variety of ways we can make a function call; why
    don't we go ahead and take a look at them?
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can call a function to perform the task we defined for it. While calling,
    we pass the arguments that the function takes as input parameters. This can be
    achieved in a variety of ways: we can specify a variable number of arguments,
    we can specify the name of the argument, or we can specify a default value to
    consider in case the argument is not passed while calling the function. Let''s
    take a scenario where we are not sure about the number of arguments to be passed
    to a function for evaluation but we are sure about the type of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a variable number of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember, we''ve already seen an example for functions that take a variable
    number of arguments and perform operations on them in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our method takes index numbers and prints those pages from the document passed
    as the first parameter. Here, the parameter `indexes` is called a **vararg***.*
    This indicates that we can pass any number of arguments of the type specified;
    in this case, we specified `Int`*.* While calling this function, we can pass any
    number of arguments of type `Int`*.* We've already tried that. Now, let's think
    of a mathematical function that expects a number of integers and responds back
    with the average of all the numbers. How should it look?
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be a signature with the `def` keyword, with a name and parameters, or
    just one *vararg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the signature for our `average` function. The body for
    the function is yet to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the first `average` function; it expects a variable argument
    of type `Int`*.* It has been called with arguments `2` and `2`. Here the number
    of arguments was 2\. We''re allowed to provide any number of arguments to perform
    the operation. The definition of our function uses the `fold` operation to perform
    summing of all the numbers passed. We''ll see the details of how `fold` works
    in the next chapter, when we discuss the functions for our collections. For now,
    just understand that it traverses through each element of a collection and performs
    operations with a supplied argument, that is, `0` in our case. We called the function
    with a different number of arguments. In the same way, we can define our function
    to support a variable number of arguments of any type. We can call the function
    accordingly. The only requirement is that the *vararg* parameter should come last
    in the function signature''s parameters list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This means that `numbers`*,* that is, a variable parameter, should be declared
    last and declaring `wrongArgument` after that will give a *compile time error.*
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function with a default parameter value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re allowed to give default parameter values at the time of declaring a
    function. If we do so, we can avoid passing an argument for that parameter while
    calling the function. Let''s see how this works with an example. We''ve already
    seen this example, where we''re going to compare two integers. Let''s give the
    second parameter a default value of `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, while declaring the `compareIntegersV6` function, we gave a default value
    of `10` to parameter `value2`*.* At the end while calling the function, we passed
    only one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'While calling the function, we passed only one argument, `12`, which is the
    value for `value1`*.* In these situations the Scala compiler looks for a value
    bound to the other argument. In our case, the compiler was able to infer that
    for the other parameter there''s already a value of 10 by default, so the function
    application will evaluate based on these two values. Giving default values and
    using them works only if the Scala compiler can infer the values. In cases of
    ambiguity, it does not allow you to call a function. Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For this function, let''s try to call using the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Scala compiler will throw an error if we try to call a function in this
    way, because the compiler was not able to bind the value `12` to `value2`*,* because
    of the ordering of the argument. If somehow we can tell the compiler that the
    argument that we passed is bound to the parameter named `value2`, our function
    will work. To achieve this, we call the function passing the argument by name.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function while passing named arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes, while calling a function, we can directly name the arguments. This ensures
    freedom from the correct ordering of arguments passed. Let''s call our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason behind this is simple: the only thing to ensure is that the Scala
    compiler is able to infer. This can also allow you to pass arguments regardless
    of the order in which they appear in the function signature. So it''s possible
    to call our function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This gives us more than one way to define and call our functions. The good news
    is that you can also pass functions into a function in the form of literals; we
    call them function literals. Let's go through what function literals look like.
  prefs: []
  type: TYPE_NORMAL
- en: Function literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can pass a function in the form of a literal to another function, to work
    for us. Let''s take the same `compareIntegers` function example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We know what our function is supposed to do: take two integer numbers as input
    and return an integer response telling us the result of our comparison. If we
    take a look at the abstract form of our function, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the function is expecting two integers, and returning an integer
    response; our need is the same. It''s an abstract form that indicates that elements
    on the left are inputs and elements on the right are the response type for our
    function. We can say that this is in its literal form, also called **function
    literals***.* Hence, it''s also possible to assign this literal to any variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember in `PagePrinter` from the last chapter, we had a `print` function
    that took an index and printed that page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the form our function takes, it takes an integer and prints pages.
    So the form will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Unit` keyword here represents that our literal does not respond back with
    any value. Now let''s take a scenario where the requirement is to tell the printer
    to print a page in color or simple. We''ll refactor our code to support using
    function literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We refactored our `printPages` method and now it takes a *function literal.*
    The function literal represents our `print` function's form. We represented two
    forms of our `print` function, the first one prints *colored* pages and the latter
    prints *simple* pages. This made it simple to call the same function of `printPages`
    and pass a *function literal* as needed. All we had to do was tell the function
    this form of function can be passed and, while calling the function, we can pass
    a *function literal* of the same form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala also uses *function literals* in default constructs. One example is the
    `filter` function for collections. The `filter` function expects a predicate that
    checks for a condition and responds with a Boolean response, based on which we
    filter out elements in a list or collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The part where we checked if the name starts with `A` is an example of a *function **literal:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala compiler only requires extra information where it is needed to infer
    type information; with this, it allows us to omit the parts that are just extra
    syntax, hence it''s possible to write the proceeding syntax as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When functions have some parameters defined in them, those function calls expect
    us to pass arguments while calling. And as we know, we can pass a *function literal*
    that gets evaluated at the time of the call or at the time when it is used. Scala
    supports *call by value* and *call by name* for functions. Let's discuss them
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Call by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Call by name is an evaluation strategy where we substitute the literal at the
    place from where we call our function. The literal gets evaluated when it first
    appears and gets called. We can understand this with a simple example. First,
    let''s take our `ColorPrinter` application and pass a Boolean function literal
    that checks if the printer is switched on. For that we can refactor our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this function, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two problems with this kind of approach. First, it looks odd; using
    a `() => expression` here, when we already know that it''s going to be a Boolean
    function literal. Second, we may not want our expression to get evaluated until
    it''s used. For that, we''ll make a small change in our `printPages` function
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a closer look and you''ll be able to see that we removed the `()` parenthesis
    and added `*=>*` in our function signature. This makes our code understand that
    this is a *by name* parameter, and to evaluate it only when it''s called. This
    is the reason we are allowed to make this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This call consists of a Boolean expression as a last argument. And because our
    function expects it to be of *by name* type, it's going to be evaluated later
    when the call is actually made.
  prefs: []
  type: TYPE_NORMAL
- en: Call by value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Call by value* is a simple and common evaluation strategy, where an expression
    is evaluated and the result is bound to the parameter. At the place where the
    parameter is used, the bound value is simply substituted with that. We''ve already
    seen many examples for this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Calls made to this function are examples of the *call by value* strategy. We
    simply give values as arguments that get substituted in the function by parameter
    values.
  prefs: []
  type: TYPE_NORMAL
- en: These strategies give us a variety of ways we can call a function. Also, evaluating
    an expression only when it's needed is characteristic of functional languages;
    it's called *lazy evaluation.* We'll learn about *lazy evaluation* in more detail
    in [Chapter 9](https://cdp.packtpub.com/learning_scala_programming/wp-admin/post.php?post=157&action=edit),
    *Using Powerful Functional Constructs*, when we'll discuss *powerful functional
    constructs.*
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming supports this analogy of writing functions that are valid
    and work for input values rather than failing them with an error. And to support
    this, Scala has a feature to define partial functions.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Partial functions do not suffice for every input given, which means these are
    defined to serve a purpose for a specific set of input parameters. To understand
    more, let''s first define a partial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined a partial function named `oneToFirst`*.*
    We also specified type parameters for our partial function; in our case we passed
    `Int`, `String`. The `PartialFunction` function is a trait in Scala, defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The trait as shown expects two parameters `A` and `B`, that become the input
    and output types of our partial function. Our `oneToFirst` partial function simply
    expects `1` and returns a string representation for 1 as first. That''s why when
    we try to call the function by passing 1, it works fine; but if we try to pass
    any other argument, let''s say `2`, it''ll throw a `MatchError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because our partial function is only applicable for a single value,
    that is, `1`; and for others it''s not. To ensure that our function does not throw
    an error, we can check whether the partial function is applicable for a value
    or not using the `isDefinedAt` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For values that our partial function supports, `isDefinedAt` gives `true`; for
    other values, it returns `false`. These partial functions can also be composed.
    For that, the trait `PartialFunction` defines two methods: `orElse` and `andThen`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we defined the partial functions named `isPrimeEligible`
    and `amountMoreThan500`*,* and then composed another partial function using the `orElse` method ,
    which checks if the item is deliverable for free or not. Thus, partial functions
    provide us with ways to compose and define functions to serve specific purposes
    for a set of values. Moreover, partial functions give us a way to define separate
    logic from a given set of input values based on some distinction. It's important
    to keep in mind that our partial function works on only one operand. Hence, this
    is a form of unary function and it's the programmer's responsibility to check
    whether for a specific value, the function is defined or not.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to conclude our chapter. In this chapter, we had a brief introduction
    to the important concept of *functions* in Scala. We started with the syntax for
    defining a function. It is important to know that we're allowed to nest functions
    and make our code look cleaner. We learned about how we can make function calls
    in a variety of ways, for example with a variable number of arguments, with a
    default parameter value, and with a named argument. Then we learned how to write
    function literals in Scala. Afterwards, we discussed a couple of evaluation strategies
    for functions in Scala, where we talked about *call by name* and *call by value.*
    Finally, we discussed another important concept of defining a *partial function*
    in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we have completed the first part of our journey. Learning
    all these concepts has certainly increased our ability to write and understand
    a mature piece of Scala code. In later parts, we will continue to do so. The second
    part is about Scala's rich collections hierarchy. In the next chapter, we'll learn
    about the number of collections Scala provides and various methods to use collections
    in a variety of ways.
  prefs: []
  type: TYPE_NORMAL
