<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Scaling with Spring Batch"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Scaling with Spring Batch</h1></div></div></div><p>In the previous chapter, we learned about monitoring, accessing the execution information and administering the configurations, using listeners, reporting the batch job problems, and understanding the Spring Batch Administration features. The Spring Batch job execution deals with huge data that changes time-to-time. This detailed processing consumes huge infrastructure. It is obvious to expect these jobs to perform efficiently and meet the scaling needs with the growing size of the organization's data.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The batch scaling model</li><li class="listitem" style="list-style-type: disc">The thread model</li><li class="listitem" style="list-style-type: disc">Parallel processing</li><li class="listitem" style="list-style-type: disc">Remote chunking</li><li class="listitem" style="list-style-type: disc">Partitioning</li></ul></div><div class="section" title="The batch scaling model"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>The batch scaling model</h1></div></div></div><p>So far we have <a id="id401" class="indexterm"/>seen how to handle different types of batch jobs, configurations, and <a id="id402" class="indexterm"/>executions. As the organization size is growing day-by-day, the data to be processed per batch job also gets increased accordingly. It is important to design and configure our batch jobs to meet these performance and scaling expectations.</p><p>The batch jobs we write with certain business logic, keeping different resources interacting in between, cannot be changed every time we see change in data load or performance issues. Spring Batch offers rich configuration infrastructure to be able to scale jobs without altering them, by just tuning the configuration information.</p><p>Scaling the infrastructure can be done in either of the following two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>By increasing the capacity of the system hardware</strong></span>: In this way of scaling, we can replace the existing slow infrastructure with more powerful infrastructure.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adding more servers</strong></span>: In this way of scaling, we can add more processing systems of the same capacity in parallel to the existing infrastructure. These additional nodes share the work and increase the scaling of the total system.</li></ul></div><p>Spring Batch offers the <a id="id403" class="indexterm"/>following ways to scale the batch applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Thread model</strong></span>: This is a multithreaded step with a single process</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Parallel processing</strong></span>: This <a id="id404" class="indexterm"/>is a parallel step execution with a single process</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Remote chunking</strong></span>: This is the remote chunking of a step with multi process</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Partitioning</strong></span>: This is the partitioning of a step; it can be a single or multi process</li></ul></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="The thread model"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>The thread model</h1></div></div></div><p>By default, step execution is a single-thread model. Spring Batch lets us configure the step to execute in multiple <a id="id405" class="indexterm"/>chunks to let the single step execute in a multithread model with the help of <code class="literal">org.springframework.core.task.TaskExecutor</code>.</p><p>The following <a id="id406" class="indexterm"/>diagram depicts the multithread model of a step execution:</p><div class="mediaobject"><img src="Images/3372OS_08_01.jpg" alt="The thread model" width="600" height="215"/></div><p>The following is the sample configuration for the multithread step with <code class="literal">TaskExecutor</code>:</p><div class="informalexample"><pre class="programlisting">&lt;step id="employeePayProcessing"&gt;
&lt;tasklet task-executor="taskExecutor"&gt;
&lt;chunk reader="employeeWorkingDaysReader" processor="employeePayProcessor"
writer="employeeSalariesWriter"/&gt;
&lt;/tasklet&gt;
&lt;/step&gt;
&lt;beans:bean id="taskExecutor"
class="org.springframework.core.task.SimpleAsyncTaskExecutor"&gt;
&lt;beans:property name="concurrencyLimit" value="20"/&gt;
&lt;/beans:bean&gt;</pre></div><p>With the preceding <a id="id407" class="indexterm"/>configuration, the <code class="literal">employeePayProcessing</code> step considers the configured reader, processor, and writers for the tasklets and task execution, with the help of <code class="literal">org.springframework.core.task.SimpleAsyncTaskExecutor</code> having a thread pool of 20 threads, each executing in parallel with chunks of data being processed in each thread.</p><p>Just like any other <a id="id408" class="indexterm"/>multithread model, the Spring Batch multithread models also take into account the resources used by the multiple threads, and whether they are thread safe. <code class="literal">ItemReader</code> is one such process that is not thread safe.</p><p>To configure a thread-safe operation, the recommendation is to synchronize the <code class="literal">ItemReader</code> process by synchronizing the read method.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Parallel processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Parallel processing</h1></div></div></div><p>While multithreading <a id="id409" class="indexterm"/>allows a single step to be processed in multiple threads of chunks, Spring Batch allows us to process multiple steps and flows <a id="id410" class="indexterm"/>simultaneously with the help of parallel processing. This feature enables the independent steps to execute in parallel and ensures a faster processing.</p><p>The following figure shows the multiple steps under execution in parallel:</p><div class="mediaobject"><img src="Images/3372OS_08_02.jpg" alt="Parallel processing" width="500" height="270"/></div><p>With parallel processing, the independent steps need not wait for the other steps to complete before execution.</p><p>The following is the <a id="id411" class="indexterm"/>sample configuration for the parallel steps <a id="id412" class="indexterm"/>in processing:</p><div class="informalexample"><pre class="programlisting">&lt;job id="employeePayProcessing"&gt;
&lt;split id="splitProcess" task-executor="taskExecutor" next="payCalculations"&gt;
&lt;flow&gt;
&lt;step id="readEmployeeData" parent="stepOne" next="processEmployeeData"/&gt;
&lt;step id="processEmployeeData" parent="stepTwo"/&gt;
&lt;/flow&gt;
&lt;flow&gt;
&lt;step id="organizationDataSetup" parent="stepThree"/&gt;
&lt;/flow&gt;
&lt;/split&gt;
&lt;step id="payCalculations" parent="stepFour"/&gt;
&lt;/job&gt;
&lt;beans:bean id="taskExecutor" class=" org.springframework.core.task.SimpleAsyncTaskExecutor"/&gt;</pre></div><p>In the preceding configuration, the <code class="literal">readEmployeeData</code> and <code class="literal">processEmployeeData</code> steps get executed in parallel with <code class="literal">organizationDataSetup</code>. By default, the <code class="literal">taskExecutor</code> is <code class="literal">SyncTaskExecutor</code>; with the preceding configuration we changed it to <code class="literal">SimpleAsyncTaskExecutor</code> to <a id="id413" class="indexterm"/>support parallel step <a id="id414" class="indexterm"/>processing.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Remote chunking"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Remote chunking</h1></div></div></div><p>Remote chunking <a id="id415" class="indexterm"/>is the process in which the original step reads the data calls from remote process to process and writes or receives the processed data back to write on to the system. As the remote chunking deals with the data transmission to <a id="id416" class="indexterm"/>another system that is remotely located, we should also consider the cost in building this infrastructure versus the advantage we are getting in remote processing. The actual step (master) executes the read process, and the remote slaves (listeners) could be the JMS listeners that execute the process and write steps, or return the processed information to the master.</p><p>The following figure depicts the steps in remote chunking:</p><div class="mediaobject"><img src="Images/3372OS_08_03.jpg" alt="Remote chunking" width="600" height="190"/></div><p>The <code class="literal">ChunkProvider</code> interface <a id="id417" class="indexterm"/>returns chunks from <code class="literal">ItemReader</code>:</p><div class="informalexample"><pre class="programlisting">public interface ChunkProvider&lt;T&gt; {
void postProcess(StepContribution contribution, Chunk&lt;T&gt; chunk);
Chunk&lt;T&gt; provide(StepContribution contribution) throws Exception;
}</pre></div><p>The <code class="literal">ChunkProcessor</code> interface <a id="id418" class="indexterm"/>processes the chunks:</p><div class="informalexample"><pre class="programlisting">public interface ChunkProcessor&lt;I&gt; {
void process(StepContribution contribution, Chunk&lt;I&gt; chunk) throws Exception;
}</pre></div><p>To be able to effectively <a id="id419" class="indexterm"/>perform the remote interactions, the remote <a id="id420" class="indexterm"/>chunking process can have the Spring Integration project included to deal with the integration of resources.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Partitioning"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Partitioning</h1></div></div></div><p>While the remote <a id="id421" class="indexterm"/>chunking reads the data at master node and handles the processing to another remote system (slave), partitioning executes the entire process (reading, processing, and writing) in parallel, by having the multiple systems having the entire <a id="id422" class="indexterm"/>processing ability. Here, the master step takes care of understanding the job and handing over the task to multiple slaves, and slaves have to take care of the rest of the tasks (reading, processing, and writing). Essentially, the slaves constitute the steps that take care of the read, process, and write in their own world.</p><p>The advantages of partitioning over remote chunking include the data transmission not being there, as the slave system takes care of the read step as well.</p><div class="mediaobject"><img src="Images/3372OS_08_04.jpg" alt="Partitioning" width="600" height="350"/></div><p>Even though the communication sent by the master to the slaves in this pattern fails to deliver, batch metadata in the <code class="literal">JobRepository</code> ensures that each slave gets executed only once per job execution.</p><p>The <a id="id423" class="indexterm"/>Spring Batch partitioning <span class="strong"><strong>Service </strong></span><a id="id424" class="indexterm"/>
<span class="strong"><strong>Provider Interface</strong></span> (<span class="strong"><strong>SPI</strong></span>) has the following infrastructure for effective partitioning:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PartitionHandler</code>: This sends <code class="literal">StepExecution</code> a request to the remote steps. It doesn't <a id="id425" class="indexterm"/>have to know how to split or integrate the data, and <code class="literal">TaskExecutorPartitionHandler</code> is the default implementation of <code class="literal">PartitionHandler</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Partitioner</code>: This generates the step executions for the partitioned steps (only for new step executions). <code class="literal">SimplePartitioner</code> is the default implementation <a id="id426" class="indexterm"/>of <code class="literal">Partitioner</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">StepExecutionSplitter</code>: This generates the input execution contexts for the partitioned <a id="id427" class="indexterm"/>step execution, and <code class="literal">SimpleStepExecutionSplitter</code> is the default implementation.</li></ul></div><p>The following is the <a id="id428" class="indexterm"/>sample partitioned step execution configuration:</p><div class="informalexample"><pre class="programlisting">&lt;step id="initialStep"&gt;
&lt;partition step="stepPartition" handler="handler"/&gt;
&lt;/step&gt;
&lt;beans:bean class="org.springframework.batch.core.partition.support.TaskExecutorPartitionHandler"&gt;
&lt;beans:property name="taskExecutor" ref="taskExecutor"/&gt;
&lt;beans:property name="step" ref="stepPartition"/&gt;
&lt;beans:property name="gridSize" value="10"/&gt;
&lt;/beans:bean&gt;</pre></div><p>The preceding configuration starts its execution with <code class="literal">initialStep</code> and hands over the execution to the partitioned step. The grid size indicates the number of different steps to be created.</p><p>While the multithread model fits for the basic tuning of chunk processing, parallel processing lets us configure independent steps to execute in parallel. Remote chunking needs comparatively larger infrastructure and configuration but fits for distributed nodes processing. Partitioning helps quickly replicate the batch infrastructure and configure the entire process to execute in parallel nodes, with a single point of the repository acting as master.</p><p>Based on the system requirement and feasibility of the available infrastructure, one can choose either of the earlier mentioned scaling strategies for batch job execution.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>Through this chapter we learned the importance of performance and scaling of the batch. We also learned Spring Batch offerings to scale the batch applications. In addition, we learned about the details and configurations of a thread model, parallel processing, remote chunking, and partitioning techniques. We finished this chapter with an understanding of choosing the right strategy to scale the batch application with the available infrastructure.</p><p>In the next chapter, we will learn in detail about performing different types of testing on Spring Batch applications.</p></div></div>



  </body></html>