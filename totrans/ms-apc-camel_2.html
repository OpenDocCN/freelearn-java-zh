<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Core Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Core Concepts</h1></div></div></div><p>This chapter introduces the core concepts of Camel. These concepts are the key basis of all functionalities provided by Camel. We will use them in the next chapters. As we have seen in the previous chapter, Camel is an integration framework. This means that it provides everything to implement your mediation logic: messaging, routing, transformation, and connectivity.</p><p>We will look at the following concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Messages</li><li class="listitem" style="list-style-type: disc">Exchanges</li><li class="listitem" style="list-style-type: disc">Camel contexts</li></ul></div><div class="section" title="Messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Messages</h1></div></div></div><p>Messages <a id="id25" class="indexterm"/>transport the data between the different parts of the mediation logic. Your mediation logic will define the flow of messages between different nodes.</p><p>A message flows in one direction, from a sender to a receiver. It's not possible to use the same message to answer the sender, we will have to use another message. A message is described in the <code class="literal">org.apache.camel.Message</code> interface.</p><p>The javadoc<a id="id26" class="indexterm"/> is available at <a class="ulink" href="http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html">http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html</a>.</p><p>A message contains the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ID: A message ID<a id="id27" class="indexterm"/> of type <code class="literal">String</code>. Camel creates an ID for you. This ID identifies the message and can be used for correlation or storage. For instance, we will see that the message ID is used in the idempotent consumer pattern to identify the message in a store.</li><li class="listitem" style="list-style-type: disc">Header: A set of <a id="id28" class="indexterm"/>headers, allowing you to store any kind of data associated with a message. The headers are stored as <code class="literal">org.apache.camel.util.CaseInsensitiveMap</code> by default. The<a id="id29" class="indexterm"/> <code class="literal">CaseInsensitiveMap</code> (<a class="ulink" href="http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html">http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html</a>) extends <code class="literal">HashMap&lt;String,Object&gt;</code>. This means you can store any kinds of objects (including very large objects) in the header. To access the map use a <code class="literal">String</code> key, which is case insensitive. The lifetime of the headers is the same as the message (as the headers are part of the message itself). The purpose of the headers is to add hints about the content encoding, authentication information, and so on. As we will see in the next chapters, Camel itself uses and populates the headers for its own needs and configurations.</li><li class="listitem" style="list-style-type: disc">Attachment: A set of <a id="id30" class="indexterm"/>attachments is mostly to match the requirements of some protocols and components: WebService component (to provide SOAP Message Transmission Optimization Mechanism (MTOM) support) or the e-mail component (to provide support for e-mail attachments). The attachments are only used by some dedicated components, they are not as heavily used as the headers. The attachments are stored in the message as <code class="literal">Map&lt;String,DataHandler&gt;</code>. An attachment name is a <code class="literal">String</code>, which is case sensitive. An attachment is stored using <code class="literal">DataHandler</code> providing support of MIME type and consistent access to the data.</li><li class="listitem" style="list-style-type: disc">Fault flag: A fault flag<a id="id31" class="indexterm"/> Boolean that allows you to distinguish whether the message is a normal message or a faulted message. It allows some components or patterns to treat the message in a different way. For instance, instead of a SOAP Response, a message may contain a SOAP Fault. In that case, we have to inform the component that a message containing a SOAP Fault is not a normal message.</li><li class="listitem" style="list-style-type: disc">Body: The body<a id="id32" class="indexterm"/> is the actual payload of the message. The body is stored as an <code class="literal">Object</code> in the message, allowing you to store any kind of data. In <a class="link" href="ch01.html" title="Chapter 1. Key Features">Chapter 1</a>, <span class="emphasis"><em>Key Features</em></span> we saw that one of the Camel key features is to be payload-agnostic. The fact that the body is directly an <code class="literal">Object</code> is the implementation of the payload-agnostic feature.<div class="mediaobject"><img src="graphics/3151EN_02_01.jpg" alt="Messages"/></div></li></ul></div></div></div>
<div class="section" title="Exchange"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Exchange</h1></div></div></div><p>Camel doesn't transport a message<a id="id33" class="indexterm"/> directly. The main reason is that a message flows only in one direction. When dealing with messaging, there are many Message Exchange Patterns (MEP)<a id="id34" class="indexterm"/> that we can use.</p><p>Depending on the use cases, we can send a message without expecting any return from the destination: this pattern is named event message and uses InOnlyMEP. For instance, when you read a file from the filesystem, you just process the file content, without returning anything to the endpoint that read the file. In that case, the component responsible for reading the filesystem will define an InOnlyMEP.</p><p>On the other hand, you may want to implement a request reply pattern: a response message should be returned to the sender of the request message, and so it uses an InOutMEP. For instance, you receive a SOAP Request from a WebService component, so you should return a SOAP Response (or SOAP Fault) to the message sender.</p><p>In Camel, MEP are described in the <code class="literal">org.apache.camel.ExchangePattern</code> <a id="id35" class="indexterm"/>enumeration (<a class="ulink" href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html">http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html</a>). We can see that Camel supports the following MEP:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">InOnly</li><li class="listitem" style="list-style-type: disc">InOptionalOut</li><li class="listitem" style="list-style-type: disc">InOut</li><li class="listitem" style="list-style-type: disc">OutIn</li><li class="listitem" style="list-style-type: disc">OutOptionalIn</li><li class="listitem" style="list-style-type: disc">RobustInOnly</li><li class="listitem" style="list-style-type: disc">RobustOutOnly</li></ul></div><p>As a message flows in only one direction, in order to support the different MEPs, we need two messages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first message is mandatory as it's the <code class="literal">in</code> message</li><li class="listitem" style="list-style-type: disc">The second message is optional (depending on the MEP) as it's the <code class="literal">out</code> message</li></ul></div><p>That's why Camel <span class="strong"><strong>wraps</strong></span> the messages into an Exchange object: the actual object transported is the Exchange, acting as a messages container with all meta-data required for the routing logic.</p><p>This Exchange object is used for the complete mediation process execution.</p><p>The <code class="literal">org.apache.camel.Exchange</code> interface describes an exchange.</p><p>Basically, an exchange contains the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exchange ID: An exchange ID <a id="id36" class="indexterm"/>as a <code class="literal">String</code>. This is a unique identifier for the exchange. Camel creates it for you.</li><li class="listitem" style="list-style-type: disc">MEP: The Message Exchange Pattern (MEP)<a id="id37" class="indexterm"/> defines the exchange pattern.</li><li class="listitem" style="list-style-type: disc">Exception: The <code class="literal">Exception</code> is used by<a id="id38" class="indexterm"/> the error handler, as we will see later. It stores the current cause of an exchange failure. If an error occurs at any time during routing, it will be set in this exception field.</li><li class="listitem" style="list-style-type: disc">Properties: The properties<a id="id39" class="indexterm"/> is a <code class="literal">Map&lt;String, Object&gt;</code> and may look like message headers. The main difference is their lifetime: the properties exist during the whole exchange execution, whereas the headers are limited to the message duration (and a message can change a lot during routing, so during the exchange execution). Camel itself may add some properties for some use cases.</li><li class="listitem" style="list-style-type: disc">Finally, we have the <code class="literal">in</code> and <code class="literal">out</code> messages.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In Message: The <code class="literal">in</code> message<a id="id40" class="indexterm"/> is mandatory and always set. It's the only message populated in the exchange with InOnlyMEP.</li><li class="listitem" style="list-style-type: disc">Out Message: The <code class="literal">out</code> message<a id="id41" class="indexterm"/> is optional and is only used with InOutMEP.</li></ul></div><p>With InOutMEP, at the end of the processing of the exchange, the <code class="literal">out</code> message will be used and returned to the mediation beginner (the first endpoint of the routing who created the exchange).</p></li></ul></div><div class="mediaobject"><img src="graphics/3151EN_02_02.jpg" alt="Exchange"/></div></div>
<div class="section" title="Camel context"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Camel context</h1></div></div></div><p>The Camel context<a id="id42" class="indexterm"/> is the runtime system and the loading container of all resources required for the execution of the routing. It keeps everything together to allow the user to execute the routing logic. When the context starts, it also starts various components and endpoints, and activates the routing rules.</p><p>The Camel context is <a id="id43" class="indexterm"/>described by the <code class="literal">org.apache.camel.CamelContext</code> interface (<a class="ulink" href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html">http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html</a>).</p><div class="mediaobject"><img src="graphics/3151EN_02_03.jpg" alt="Camel context"/></div><p>A Camel context <a id="id44" class="indexterm"/>contains the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The components and endpoints used in the routing (see later for the details about components and endpoints)</li><li class="listitem" style="list-style-type: disc">The type converters used to transform a message of one type to another</li><li class="listitem" style="list-style-type: disc">The data formats used to define the format of a message body</li><li class="listitem" style="list-style-type: disc">The registry where Camel will look for the beans used in the routing</li><li class="listitem" style="list-style-type: disc">The languages describing expressions and predicates used in the routing by a language (xpath, xquery, PHP, and so on)</li><li class="listitem" style="list-style-type: disc">The routes definition itself allowing you to design your mediation logic</li></ul></div><p>Most of these resources are automatically loaded by Camel for you; most of the time, as an end user, you specify the routes definitions. However, we will see in the next chapters that we can tweak the <a id="id45" class="indexterm"/>Camel context.</p><p>A Camel context also has its own life cycle. As it's the runtime system of your routing, you have a control on this life cycle.</p><p>A Camel context can be started, loading all resources needed and activating the routing logic. </p><div class="mediaobject"><img src="graphics/3151EN_02_04.jpg" alt="Camel context"/></div><p>
</p><p>Once started, a context can be stopped: it's a cold stop. This means that all routes, components, endpoints, and other resources loaded by this context will be stopped, and all internal cache, metrics, and states will be lost.</p><p>Instead of stopped, from the started state, a context can be suspended. Suspend stops the routing of the messages, but keeps context resources loaded and the internal data (metrics, cache, states, and so on). That's why a suspended context can return to the started state very quickly using resume: it just resumes the processing of the messages.</p><p>The end users are supposed to use only suspend and resume operations.</p><p>To restart a context, you can do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A hot restart using suspend operation first, and resume operation after. It's a fast restart, keeping all the internal data of the context.</li><li class="listitem" style="list-style-type: disc">A cold restart <a id="id46" class="indexterm"/>using the stop operation first, and the start operation later. In that case, all internal data (cache, states, and metrics) is lost.</li></ul></div><p>Both stop and resume operations will ensure that all inflight messages (messages currently in process) are completely processed.</p><p>Stopping or suspending a context will stop or suspend all the routing defined in this context. In order to guarantee a graceful and reliable shutdown of your routing, you can define a shutdown strategy.</p><p>A shutdown strategy is described using the <code class="literal">org.apache.camel.spi.ShutdownStrategy</code> interface.</p><p>Camel provides the <code class="literal">org.apache.camel.impl.DefaultShutdownStrategy</code> interface.</p><p>This default shutdown strategy <a id="id47" class="indexterm"/>works in two phases:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, it does a graceful shutdown, by suspending or stopping all consumer (the first endpoint that creates the exchanges), and waiting for the completion of all inflight messages.</li><li class="listitem">After a timeout (5 minutes by default), if there are still some inflight messages, the strategy kills the exchanges, forcing a suspend or stop.</li></ol></div><p>We will see in the next chapters how to create and use our own shutdown strategy.</p></div>
<div class="section" title="Processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Processor</h1></div></div></div><p>A processor<a id="id48" class="indexterm"/> is a node in the routing which is able to use, create, or modify an incoming exchange. During routing, the exchanges flow from one processor to another. This means all Enterprise Integration Patterns (EIP) are implemented using processors in Camel. The exchanges get in and out of a processor by using components and endpoints, as we will see later in this chapter.</p><p>A processor is described using the <code class="literal">org.apache.camel.Processor</code> interface. To create your own processor, you just have to implement the <code class="literal">Processor</code> interface and override the <code class="literal">process()</code> method:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support ">http://www.packtpub.com/support </a>and register to have the files e-mailed directly to you.</p></div></div><div class="informalexample"><pre class="programlisting">public class MyProcessor implements Processor {

  public void process(Exchange exchange) {
System.out.println("Hello " + exchange.getIn().getBody(String.class));
  }

}</pre></div><p>Thanks to <a id="id49" class="indexterm"/>the <code class="literal">Exchange</code> argument of the <code class="literal">process()</code> method, you have complete access to the exchange: in and out messages, properties, and so on.</p><p>The <code class="literal">exchange.getIn()</code> gets the <code class="literal">in</code> message of the current exchange. As we want to get the body of this message, we use the <code class="literal">getBody()</code> method. This method accepts a type argument, casting the body in the destination class (a string in our example).</p></div>
<div class="section" title="Routes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Routes</h1></div></div></div><p>The Camel route is the routing definition. It's a graph of processors. The routes<a id="id50" class="indexterm"/> (routing definition) are loaded in the Camel context. The execution and flow of the exchange in a route is performed by the routing engine. The routes are used to decouple clients from servers, and producers from consumers: an exchange consumer doesn't know where the exchange comes from, and on the other hand an exchange producer doesn't know the destination of the exchange. Thanks to that, it provides a flexible way to add extra processing or change the routing with limited impact on the logic.</p><p>Each route has a unique identifier that you can specify (or Camel will create one for you). This identifier is used to easily find the route, especially when you want to log, debug, monitor, or manage a route (start or stop).</p><p>A route has exactly one input source (the input endpoint). A route has a life cycle similar to the Camel context with the same states: started, stopped, and suspended. To Camel, a context controls the life cycle of the routes that it contains.</p></div>
<div class="section" title="Channels"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Channels</h1></div></div></div><p>In every Camel route, there is a channel<a id="id51" class="indexterm"/> that sits between each processor in the route graph. It's responsible for the routing of an Exchange to the next Processor in the graph. The channel acts as a controller that monitors and controls the routing at runtime. It allows Camel to enrich the route with interceptors. For instance, the Camel tracer or the error handling are functionalities implemented using an interceptor on the channel.</p><p>The channel is described by the <code class="literal">org.apache.camel.Channel</code> interface. You can configure your own interceptor on the channels by describing it in Camel context.</p><p>Camel supports three kinds of interceptors on the channels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Global interceptors: This intercepts all exchanges on the channels</li><li class="listitem" style="list-style-type: disc">Interceptors on the incoming exchanges: This has limited the scope of the interceptor only on the first channel (the one just after the first endpoint)</li><li class="listitem" style="list-style-type: disc">Interceptors on<a id="id52" class="indexterm"/> the exchanges going to one specific endpoint: This limits the interceptor to the channel just before a given endpoint</li></ul></div></div>
<div class="section" title="Domain Specific Languages (DSL)"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Domain Specific Languages (DSL)</h1></div></div></div><p>Using the Camel API directly <a id="id53" class="indexterm"/>would need you to write a lot of plumbing code. You will need to create all the objects and load a lot of objects into different ones.</p><p>Therefore, the direct usage of API would be very time consuming. Moreover, as a flexible and easy-to-use integration framework, Camel doesn't have to force the use of one language (Java) to write the routing logic. Users may not be familiar with Java and might prefer to write their routing logic using another language.</p><p>That's why Camel provides a set of languages to directly write the routes: the Camel Domain Specific Languages (DSL).</p><p>Using a DSL, the user directly writes their routes and describes the Camel context using a DSL. Camel will load and interpret the DSL to create and instantiate all the objects.</p><p>The DSL is used to wire processors and endpoints together to define and form routes.</p><p>Using a DSL, you mostly define the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Camel context containing the routing rule base and resources</li><li class="listitem" style="list-style-type: disc">The routes definition</li></ul></div><p>Camel supports the following DSL:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Java DSL, allowing you to<a id="id54" class="indexterm"/> define the routes using a fluent Java API</li><li class="listitem" style="list-style-type: disc">Spring XML, allowing you <a id="id55" class="indexterm"/>to define the routes using XML and the Spring framework</li><li class="listitem" style="list-style-type: disc">Blueprint XML is similar to <a id="id56" class="indexterm"/>Spring XML but uses OSGi Blueprint instead of the Spring framework</li><li class="listitem" style="list-style-type: disc">REST DSL, allowing <a id="id57" class="indexterm"/>you to define the routes using a REST style API (in Java or XML)</li><li class="listitem" style="list-style-type: disc">Groovy DSL, allowing <a id="id58" class="indexterm"/>you to define the routes using the Groovy language</li><li class="listitem" style="list-style-type: disc">Scala DSL, allowing<a id="id59" class="indexterm"/> you to define the routes using the Scala language</li><li class="listitem" style="list-style-type: disc">Annotation DSL,<a id="id60" class="indexterm"/> allowing you to define the routes directly using annotations on Beans</li></ul></div><p>The following routes are exactly the same, but written using two different DSLs.</p><p>Using Java DSL:</p><div class="informalexample"><pre class="programlisting">from("file:/inbox").to("jms:queue:orders")</pre></div><p>Using Spring or Blueprint DSL:</p><div class="informalexample"><pre class="programlisting">&lt;route&gt;
&lt;from uri="file:/inbox"/&gt;
&lt;to uri="jms:queue:orders"/&gt;
&lt;/route&gt;</pre></div></div>
<div class="section" title="Component, endpoint, producer, and consumer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Component, endpoint, producer, and consumer</h1></div></div></div><p>The components<a id="id61" class="indexterm"/> are the main extension points in Camel. We don't directly use a component in a route, we define an endpoint from the component. This means a component acts as a factory for endpoints as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, you load the component in the Camel context</li><li class="listitem" style="list-style-type: disc">Then, in the route definition, you define an endpoint on a component loaded in the Camel context</li></ul></div><p>You can explicitly instantiate a component and load it in the Camel context (using code), or Camel will try to create and load the component (discover) for you based on the endpoint definition.</p><p>Camel provides about 100 <a id="id62" class="indexterm"/>components (file, ftp, http, CXF, JMS, and so on) as you can see at <a class="ulink" href="http://camel.apache.org/components.html">http://camel.apache.org/components.html</a>. You can create your own component, as we will see in the next chapters.</p><p>Using a component, we create the <a id="id63" class="indexterm"/>endpoints. An endpoint represents the end of a channel through which an external system can send or receive messages. It allows your Camel route to communicate with the environment.</p><div class="mediaobject"><img src="graphics/3151EN_02_05.jpg" alt="Component, endpoint, producer, and consumer"/></div><p>Depending on the location in the route, an endpoint can act as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A producer<a id="id64" class="indexterm"/> receives a Camel Exchange, transforms it into an external message and communicates (sends the message) to the external system (environment)</li><li class="listitem" style="list-style-type: disc">A consumer<a id="id65" class="indexterm"/> receives a message from an external system (environment), wraps it as a Camel Exchange, and sends to the route</li></ul></div><p>We identify two kinds of consumers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Event Driven Consumers<a id="id66" class="indexterm"/> who will listen for incoming <a id="id67" class="indexterm"/>messages and create a Camel exchange at this time. For instance, consumer endpoints using the CXF component will <span class="strong"><strong>react</strong></span> when they receive a SOAP Request.</li><li class="listitem" style="list-style-type: disc">Polling Consumers<a id="id68" class="indexterm"/> who periodically check for new resources <a id="id69" class="indexterm"/>and create a Camel exchange at this time. For instance, consumer endpoints using the File component will periodically poll the filesystem and create a Camel exchange for the new files.</li></ul></div><p>The endpoints are described using a URI in the following format:</p><div class="informalexample"><pre class="programlisting">component:option?option=value&amp;option=value</pre></div><p>For instance, we can define an endpoint of the file component using the following code:</p><div class="informalexample"><pre class="programlisting">file:data/inbox?delay=5000&amp;noop=true</pre></div><p>At runtime, Camel will look up an endpoint based on the URI, check whether the component defined as prefix is in the Camel context (eventually load it, if it's not there), and use this component to actually create the endpoint.</p></div>
<div class="section" title="Data format"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Data format</h1></div></div></div><p>Camel supports a pluggable data format<a id="id70" class="indexterm"/> allowing you to marshall and unmarshall the messages.</p><p>For instance, if you receive an XML message from an endpoint, you can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Directly manipulate and transport the XML message in the route</li><li class="listitem" style="list-style-type: disc">Translate the XML to a POJO using JAXB, for instance, JAXB is a data format</li></ul></div><p>Unmarshalling allows you to use a data format to convert from a raw format (XML in the previous example) into a Java object. On the other hand, when you send an exchange to an endpoint, you can marshall the transported object into another format. You specify where you want to unmarshall or marshall and the data format to use.</p><p>For instance, you can consume an XML message from a JMS queue, unmarshall using JAXB, and send the resulting object to another JMS queue:</p><div class="informalexample"><pre class="programlisting">from("jms:queue:orders").unmarshal("jaxb").to("jms:queue:other")</pre></div><p>You can also unmarshall files containing a serialized object, and then marshall using JAXB to send the resulting XML message to a JMS queue:</p><div class="informalexample"><pre class="programlisting">from("file:data/inbox").unmarshal().serialization().marshall("jaxb").to("jms:queue:orders")</pre></div><p>Camel provides a lot of ready-to-use data formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For JVM native serialization marshalling, you can use the serialization or Stringdata formats</li><li class="listitem" style="list-style-type: disc">For object marshalling, you can use Avro, JSON, or Protobuf data formats</li><li class="listitem" style="list-style-type: disc">For XML data formats (marshalling and unmarshalling), you can use JAXB, XmlBeans, XStream, JiBX, or Castor libraries</li><li class="listitem" style="list-style-type: disc">For XML or WebService marshalling, you can use the SOAP data format</li><li class="listitem" style="list-style-type: disc">For XML or JSON marshalling, you can use the XmlJson data format</li><li class="listitem" style="list-style-type: disc">For flat data structure marshalling (CSV, DelimitedLength, and so on), you can use BeanIO, Bindy, CSV, EDI, or Flatpack data formats</li><li class="listitem" style="list-style-type: disc">For compression marshalling, you can use GZip or Zip data formats</li><li class="listitem" style="list-style-type: disc">For security marshalling, you can use PGP, Crypto, or XML Sec data formats</li><li class="listitem" style="list-style-type: disc">For other marshalling, you can use Base64, RSS, TidyMarkup (with HTML, for instance), or Syslog data formats</li></ul></div><p>You can also <a id="id71" class="indexterm"/>create your own data format, providing the custom marshalling and unmarshalling mechanism.</p></div>
<div class="section" title="Type converter"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Type converter</h1></div></div></div><p>Even without a data format, when you route <a id="id72" class="indexterm"/>a message from one endpoint to another, it's common to convert the body of the message from one type to another. For instance, in an exchange created by a file endpoint, the body of the in message will be an InputStream. Depending on the target endpoint or processor, we may want to convert this InputStream to a String.</p><p>When you use the <code class="literal">getBody()</code> method on a message, you can specify the expected type. Camel will use a type converter to try to convert the actual body of the message into the specified type.</p><p>For instance, in a processor, if you do the following:</p><div class="informalexample"><pre class="programlisting">Message in = exchange.getIn();
Document document = in.getBody(Document.class);</pre></div><p>Camel will try to convert the body of the in message into a DOM document. A type converter is defined by the <code class="literal">org.apache.camel.TypeConverter</code> interface. The type converters are loaded into the Camel context, in a type converter's registry.</p><p>The type converter's registry contains the type converter with the supported types. In this registry, for each type converter, we have:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id73" class="indexterm"/><span class="strong"><strong>source</strong></span> type</li><li class="listitem" style="list-style-type: disc">The <a id="id74" class="indexterm"/><span class="strong"><strong>destination</strong></span> type</li><li class="listitem" style="list-style-type: disc">The actual type converter instance</li></ul></div><p>For instance, we can add our own type converter in the Camel context as follows:</p><div class="informalexample"><pre class="programlisting">context.getTypeConverterRegistry().addTypeConverter(MyOrder.class, String.class, new MyOrderTypeConverter());</pre></div><p>We can see that the source type is <code class="literal">MyOrder</code>, the destination type is <code class="literal">String</code>, and to convert from a type <code class="literal">MyOrder</code> to <code class="literal">String</code>, I will use the <code class="literal">MyOrderTypeConverter()</code> method.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Summary</h1></div></div></div><p>We can see that even if the Camel core is light, the provided features are rich and it provides all the basics to extend Camel to match your needs.</p><p>This chapter is an introduction to the Camel core concepts. It allows you to easily understand the next chapters, where we will get into the details of Camel.</p></div></body></html>