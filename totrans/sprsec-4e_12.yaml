- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Access Control Lists
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制列表
- en: In this chapter, we will address the complex topic of **Access Control Lists**
    (**ACLs**), which can provide a rich model of domain object instance-level authorization.
    Spring Security ships with a robust, but complicated, ACL module that can serve
    the needs of small to medium-sized implementations reasonably well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论复杂主题 **访问控制列表**（**ACLs**），它可以提供丰富的域对象实例级授权模型。Spring Security 随带了一个强大但复杂的
    ACL 模块，可以很好地满足从小型到中型实施的需求。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the conceptual model of an ACL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ACL 的概念模型
- en: Reviewing the terminology and application of ACL concepts in the Spring Security
    ACL module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Spring Security ACL 模块中 ACL 概念的术语和应用
- en: Building and reviewing the database schema required to support Spring ACL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和审查支持 Spring ACL 所需的数据库模式
- en: Configuring the **Jim Bob CP Calendar** (**JBCP**) calendar to use ACL-secured
    business methods via annotations and Spring beans
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 **Jim Bob CP 日历**（**JBCP**）日历以使用通过注解和 Spring 容器配置的 ACL-安全业务方法
- en: Performing advanced configuration, including customized ACL permissions, ACL-enabled
    **JavaServer Page** (**JSP**) tag checks and method security, mutable ACLs, and
    smart caching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行高级配置，包括自定义 ACL 权限、启用 ACL 的 **JavaServer Page**（**JSP**）标签检查和方法安全、可变 ACL 和智能缓存
- en: Examining architectural considerations and planning scenarios for ACL deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 ACL 在 ACL 部署中的架构考虑因素和规划场景
- en: 'This chapter’s code in action link is here: [https://packt.link/hRby2](https://packt.link/hRby2).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的实际链接在此：[https://packt.link/hRby2](https://packt.link/hRby2)。
- en: The conceptual module of an ACL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACL 的概念模块
- en: The final piece of the non-web tier security puzzle is security at the business
    object level, applied at or below the business tier. Security at this level is
    implemented using a technique known as ACL, or ACLs. To sum up the objective of
    ACLs in a single sentence, ACLs allow the specification of a set of group permissions
    based on the unique combination of a group, business object, and logical operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 非网络层安全难题的最后一部分是在业务对象级别应用的安全，位于或低于业务层。这一级别的安全是通过称为 ACL 的技术实现的，或称为 ACLs。用一句话总结
    ACL 的目标，ACL 允许根据组、业务对象和逻辑操作的独特组合来指定一组组权限。
- en: 'For example, an ACL declaration for the JBCP calendar might declare that a
    given user must write access to his or her own event. This can be shown as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JBCP 日历的 ACL 声明可能声明特定用户必须对其自己的事件有写入访问权限。这可以表示如下：
- en: '| **Username** | **Group** | **Object** | **Permissions** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **组** | **对象** | **权限** |'
- en: '| josh |  | event_01 | read, write |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| josh |  | event_01 | 读取，写入 |'
- en: '|  | ROLE_USER | event_123 | read |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  | 角色用户 | event_123 | 读取 |'
- en: '|  | ANONYMOUS | Any event | none |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  | 匿名用户 | 任何事件 | 无 |'
- en: Table 12.1 – Example of user ACL declaration
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1 – 用户 ACL 声明示例
- en: You can see that this ACL is eminently readable by a human—`josh` has `read`
    and `write` access to his own event (`event_01`); other registered users can read
    the events of `josh`, but anonymous users cannot.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个 ACL 对人类来说非常易于阅读——`josh` 对他自己的事件（`event_01`）有`read`和`write`访问权限；其他注册用户可以读取`josh`的事件，但匿名用户不能。
- en: This type of rule matrix is, in a nutshell, what ACL attempts to synthesize
    about a secured system and its business data into a combination of code, access
    checking, and metadata. Most true ACL-enabled systems have extremely complex ACL
    lists and may conceivably have millions of entries across the entire system. Although
    this sounds frighteningly complex, proper up-front reasoning and implementation
    with a capable security library can make ACL management quite feasible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这种规则矩阵就是 ACL 尝试将受保护系统及其业务数据综合成代码、访问检查和元数据的组合。大多数真正的 ACL 启用系统具有极其复杂的 ACL
    列表，整个系统可能包含数百万条记录。尽管这听起来令人恐惧地复杂，但通过适当的初步推理和具备能力的安全库的实施，可以使 ACL 管理变得相当可行。
- en: 'If you use a Microsoft Windows or Unix/Linux-based computer, you experience
    the magic of ACLs every single day. Most modern computer **Operating Systems**
    (**OSs**) use ACL directives as part of their file storage systems, allowing permission
    granting based on a combination of a user or group, file, or directory, and permission.
    In Microsoft Windows, you can view some of the ACL capabilities of a file by right-clicking
    on a file and examining its security properties (**Properties** | **Security**),
    as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用基于Microsoft Windows或Unix/Linux的计算机，你每天都会体验到ACL的魔力。大多数现代计算机**操作系统**（**OSs**）将ACL指令作为其文件存储系统的一部分，允许基于用户或组、文件或目录和权限的组合进行权限授予。在Microsoft
    Windows中，你可以通过右键单击文件并检查其安全属性（**属性** | **安全**）来查看文件的一些ACL能力，如下面的截图所示：
- en: '![Figure 12.1 – An example of ACL capabilities with Microsoft Windows](img/B21757_12_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 使用Microsoft Windows的ACL能力示例](img/B21757_12_1.jpg)'
- en: Figure 12.1 – An example of ACL capabilities with Microsoft Windows
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 使用Microsoft Windows的ACL能力示例
- en: You will be able to see that the combinations of inputs to the ACL are visible
    and intuitive as you navigate through the various groups or users and permissions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览各种组或用户和权限时，你会看到ACL的输入组合是可见且直观的。
- en: In this section, we’ve explored the conceptual module of ACL. In the following
    section, we will proceed to delve into the workings of ACLs in Spring Security.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了ACL的概念模块。在下一节中，我们将继续深入研究Spring Security中ACL的工作原理。
- en: ACLs in Spring Security
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security中的ACL
- en: Spring Security supports ACL-driven authorization checks against access to individual
    domain objects by individual users of the secured system. As in the OS filesystem
    example, it is possible to use the Spring Security ACL components to build logical
    tree structures of both business objects and groups or principals. The intersection
    of permissions (inherited or explicit) on both the requestor and the requestee
    is used to determine allowed access.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security支持通过ACL驱动的授权检查，以对受保护系统中个别用户的单个域对象访问进行控制。正如在操作系统文件系统示例中，可以使用Spring
    Security ACL组件来构建业务对象、组或主体的逻辑树结构。请求者和请求者之间权限（继承或显式）的交集用于确定允许的访问。
- en: It’s quite common for users approaching the ACL capability of Spring Security
    to be overwhelmed by its complexity, combined with a relative dearth of documentation
    and examples. This is compounded by the fact that setting up the ACL infrastructure
    can be quite complicated, with many interdependencies and reliance on bean-based
    configuration mechanisms, which are quite unlike much of the rest of Spring Security
    (as you’ll see in a moment when we set up the initial configuration).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接近Spring Security ACL能力的用户来说，其复杂性是很常见的，结合相对缺乏的文档和示例。这种情况由于ACL基础设施的设置可能相当复杂，存在许多相互依赖性和对基于bean的配置机制的依赖而加剧，这与Spring
    Security的大部分其他部分相当不同（正如我们在设置初始配置时将看到的）。
- en: The Spring Security ACL module was written to be a reasonable baseline, but
    users intending to build extensively on the functionality will likely run into
    a series of frustrating limitations and design choices, which have gone (for the
    most part) uncorrected as they were first introduced in the early days of Spring
    Security. Don’t let these limitations discourage you! The ACL module is a powerful
    way to embed rich access controls in your application, and further scrutinize
    and secure user actions and data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security ACL模块被编写为合理的基线，但打算在功能上大量构建的用户可能会遇到一系列令人沮丧的限制和设计选择，这些限制和设计选择在Spring
    Security早期阶段首次引入时（大部分未得到纠正）。不要让这些限制让你气馁！ACL模块是嵌入丰富访问控制到你的应用程序的强大方式，并进一步审查和确保用户行为和数据的安全。
- en: Before we dig into configuring Spring Security ACL support, we need to review
    some key terminology and concepts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入配置Spring Security ACL支持之前，我们需要回顾一些关键术语和概念。
- en: The main unit of secured actor identity in the Spring ACL system is the `GrantedAuthority`).
    The SID object defined by the ACL data model you construct is used as the basis
    for explicit and derived access control rules when determining the allowed level
    of access for a particular principal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring ACL系统中受保护行为身份的主要单元是`GrantedAuthority`。你构建的ACL数据模型中定义的SID对象用作确定特定主体允许访问级别的显式和派生访问控制规则的基础。
- en: If SIDs are used to define actors in the ACL system, the opposite half of the
    security equation is the definition of the secured objects themselves. The identification
    of individual secured objects is called (unsurprisingly) an **Object Identity**.
    The default Spring ACL implementation of an object identity requires ACL rules
    to be defined at the individual object instance level, which means, if desired,
    every object in the system can have an individual access rule.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 SIDs 在 ACL 系统中定义操作者，那么安全等式的另一半是对受保护对象的定义。单个受保护对象的识别被称为（不出所料）**对象标识**。默认的
    Spring ACL 对象标识实现要求在单个对象实例级别定义 ACL 规则，这意味着，如果需要，系统中的每个对象都可以有一个单独的访问规则。
- en: 'Individual access rules are known as **Access control Entries** (**ACEs**).
    An ACE is the combination of the following factors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单个访问规则被称为**访问控制条目**（**ACEs**）。ACE 是以下因素的组合：
- en: The SID for the actor to which the rule applies
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用该规则的操作者的 SID
- en: The object identity to which the rule applies
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用该规则的对象标识
- en: The permission that should be applied to the given `SID` and the stated object
    identity
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应应用于给定 `SID` 和指定对象标识的权限
- en: Whether or not the stated permission should be allowed or denied for the given
    `SID` and object identity
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的 `SID` 和对象标识，是否允许或拒绝指定的权限
- en: The purpose of the Spring ACL system is to evaluate each secured method invocation
    and determine whether the object or objects being acted on in the method should
    be allowed as per the applicable ACEs. Applicable ACEs are evaluated at runtime,
    based on the caller and the objects in play.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring ACL 系统的目的是评估每个受保护方法的调用，并确定在方法中操作的对象是否应允许根据适用的 ACEs。适用的 ACEs 在运行时根据调用者和参与的对象进行评估。
- en: Spring Security ACL is flexible in its implementation. Although most of this
    chapter details the out-of-the-box functionality of the Spring Security ACL module,
    keep in mind, however, that many of the rules indicated represent default implementations,
    which in many cases can be overridden based on more complex requirements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security ACL 在其实现上具有灵活性。尽管本章的大部分内容详细介绍了 Spring Security ACL 模块开箱即用的功能，但请记住，其中许多规则表示默认实现，在许多情况下可以根据更复杂的需求进行覆盖。
- en: 'Spring Security uses helpful value objects to represent the data associated
    with each of these conceptual entities. These are listed in the following table:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 使用有用的值对象来表示与这些概念实体相关的数据。以下表格列出了这些对象：
- en: '| **ACL** **conceptual object** | **Java object** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **ACL** **概念对象** | **Java 对象** |'
- en: '| SID | `o.s.s.acls.model.Sid` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| SID | `o.s.s.acls.model.Sid` |'
- en: '| Object identity | `o.s.s.acls.model.ObjectIdentity` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 对象标识 | `o.s.s.acls.model.ObjectIdentity` |'
- en: '| ACL | `o.s.s.acls.model.Acl` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| ACL | `o.s.s.acls.model.Acl` |'
- en: '| ACE | `o.s.s.acls.model.AccessControlEntry` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| ACE | `o.s.s.acls.model.AccessControlEntry` |'
- en: Table 12.2 – Spring Security ACL java objects
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.2 – Spring Security ACL Java 对象
- en: Let’s work through the process of enabling Spring Security ACL components for
    a simple demonstration in the JBCP calendar application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 JBCP 日历应用程序中启用 Spring Security ACL 组件的过程来进行一个简单的演示。
- en: Basic configuration of Spring Security ACL support
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security ACL 支持的基本配置
- en: Although we hinted previously that configuring ACL support in Spring Security
    requires bean-based configuration (which it does), you can use ACL support while
    retaining the simpler security XML namespace configuration if you choose. In the
    remaining examples in this chapter, we will be focusing on Java-based configuration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前暗示过，在 Spring Security 中配置 ACL 支持需要基于 bean 的配置（确实如此），但如果你选择，你可以在保留更简单的安全
    XML 命名空间配置的同时使用 ACL 支持。在本章的剩余示例中，我们将专注于基于 Java 的配置。
- en: Gradle dependencies
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle 依赖项
- en: 'As with most of the chapters, we will need to add some dependencies in order
    to use the functionality in this chapter. A list of the dependencies we have added
    with comments about when they are needed can be checked as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数章节一样，我们需要添加一些依赖项才能使用本章中的功能。以下是如何检查我们添加的依赖项及其所需情况的列表和注释：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you’ve updated your project dependencies, we can investigate the implementation
    of fine-grained permission access controls in our JBCP calendar application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新了你的项目依赖项，我们就可以研究在 JBCP 日历应用程序中实现细粒度权限访问控制的具体实现。
- en: Defining a simple target scenario
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个简单的目标场景
- en: Our simple target scenario is to grant `user2@example`.com read access to only
    the birthday party event.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的目标场景是授予 `user2@example.com` 只能访问生日派对活动的读取权限。
- en: All other users will not have any access to any events. You will observe that
    this differs from our other examples since `user2@example.com` is not otherwise
    associated with the birthday party event.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他用户将无法访问任何事件。您会注意到这与我们的其他示例不同，因为`user2@example.com`与生日派对事件没有其他关联。
- en: Although there are several ways to set up ACL checking, our preference is to
    follow the annotation-based approach that we used in this chapter’s method-level
    annotations. This nicely abstracts the use of ACLs away from the actual interface
    declarations and allows for replacement (if you want) of the role declarations
    with something other than ACLs at a later date (should you so choose).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种设置ACL检查的方法，但我们的偏好是遵循本章方法级注解中使用的基于注解的方法。这很好地抽象了ACL的使用，使其远离实际的接口声明，并允许（如果您想）在以后（如果您选择）用非ACL的其他东西替换角色声明。
- en: 'We’ll add an annotation to the `CalendarService.getEvents` method, which filters
    each event based upon the current user’s permission to the event:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`CalendarService.getEvents`方法上添加一个注解，该注解根据当前用户对事件的权限来过滤每个事件：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter12.00-calendar`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter12.00-calendar`的代码开始。
- en: Adding ACL tables to the H2 database
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ACL表添加到H2数据库
- en: The first thing we’ll need to do is add the required tables and data to support
    persistent ACL entries in our in-memory H2 database. To do this, we’ll add a new
    SQL `schema.sql`. We will break down each of these files later in the chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是在我们的内存H2数据库中添加所需的表和数据，以支持持久的ACL条目。为此，我们将添加一个新的SQL `schema.sql`。我们将在本章后面详细说明这些文件。
- en: 'We have included the following `schema.sql` file with this chapter’s source
    code, which is based upon the schema files included in the Spring Security reference’s
    [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional* *Reference Material*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个`schema.sql`文件，该文件与本章源代码一起提供，基于Spring Security参考的[*附录*](B21757_20.xhtml#_idTextAnchor642)中的*附加*
    *参考资料*：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code will result in the following database schema:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致以下数据库模式：
- en: '![Figure 12.2 – ACL database schema](img/B21757_12_2.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – ACL数据库模式](img/B21757_12_2.jpg)'
- en: Figure 12.2 – ACL database schema
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – ACL数据库模式
- en: You can see how the concepts of `SIDs`, `OBJECT_IDENTITY`, and `ACEs` map directly
    to the database schema. Conceptually, this is convenient, as we can map our mental
    model of the ACL system and how it is enforced directly to the database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`SIDs`、`OBJECT_IDENTITY`和`ACEs`的概念如何直接映射到数据库模式。从概念上讲，这是方便的，因为我们可以直接将我们对ACL系统的心理模型及其执行方式映射到数据库。
- en: 'If you’ve cross-referenced this with the H2 database schema supplied with the
    Spring Security documentation, you’ll note that we’ve made a few tweaks that commonly
    bite users. These are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经将此与Spring Security文档中提供的H2数据库模式进行了交叉引用，您会注意到我们对一些常见问题进行了调整。具体如下：
- en: Change the `ACL_CLASS.CLASS` column to `500` characters, from the default value
    of `100`. Some long, fully qualified class names don’t fit in `100` characters.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ACL_CLASS.CLASS`列的长度从默认值`100`更改为`500`字符。一些长而完全限定的类名无法放入`100`个字符内。
- en: Name the foreign keys with something meaningful so that failures are more easily
    diagnosed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有意义的名称命名外键，以便更容易诊断故障。
- en: If you are using another database, such as Oracle, you’ll have to translate
    the DDL into DDL and data types specific to your database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是其他数据库，例如Oracle，您必须将DDL翻译成您数据库特定的DDL和数据类型。
- en: Once we configure the remainder of the ACL system, we’ll return to the database
    to set up some basic ACEs to prove the ACL functionality in its most primitive
    form.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了ACL系统的其余部分，我们将返回数据库以设置一些基本的ACEs，以证明ACL功能在最原始的形式。
- en: Configuring SecurityExpressionHandler
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置SecurityExpressionHandler
- en: We’ll need to configure `@EnableMethodSecurity` to enable annotations (where
    we’ll annotate based on the expected ACL privilege) and reference a custom access
    decision manager.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置`@EnableMethodSecurity`以启用注解（我们将根据预期的ACL权限进行注解）并引用一个自定义访问决策管理器。
- en: 'We will also need to provide an `o.s.s.access.expression.SecurityExpressionHandler`
    implementation that is aware of how to evaluate permissions. Update your `SecurityConfig.java`
    configuration, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供一个`o.s.s.access.expression.SecurityExpressionHandler`实现，该实现了解如何评估权限。更新您的`SecurityConfig.java`配置，如下所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a bean reference to the `DefaultMethodSecurityExpressionHandler` object
    that we have defined in `AclConfig.java` file for you, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对我们在 `AclConfig.java` 文件中定义的 `DefaultMethodSecurityExpressionHandler` 对象的
    bean 引用，如下所示：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With even a relatively straightforward ACL configuration, as we have in our
    scenario, there are a number of required dependencies to set up. As we mentioned
    previously, the Spring Security ACL module comes out of the box with a number
    of components that you can assemble to provide a decent set of ACL capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是相对简单的 ACL 配置，正如我们在我们的场景中所做的那样，也有许多必需的依赖项需要设置。正如我们之前提到的，Spring Security ACL
    模块自带了许多组件，您可以将它们组装起来以提供一套合理的 ACL 功能。
- en: The AclPermissionCacheOptimizer object
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AclPermissionCacheOptimizer` 对象'
- en: 'The `DefaultMethodSecurityExpressionHandler` object has two dependencies. The
    `AclPermissionCacheOptimizer` object is used to prime the cache with all of the
    ACLs for a collection of objects in a single JDBC select statement. The relatively
    simple configuration included with this chapter can be checked, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultMethodSecurityExpressionHandler` 对象有两个依赖项。`AclPermissionCacheOptimizer`
    对象用于使用单个 JDBC 选择语句为对象集合中的所有 ACL 预填充缓存。本章中包含的相对简单的配置可以按以下方式进行检查：'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Optimizing AclPermission Cache
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 AclPermission 缓存
- en: 'The `DefaultMethodSecurityExpressionHandler` object then delegates to a `PermissionEvalulator`
    instance. For the purposes of this chapter, we are using ACLs so that the bean
    we will use `AclPermissionEvaluator`, which will read the ACLs that we define
    in our database. You can view the provided configuration for `permissionEvaluator`,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultMethodSecurityExpressionHandler` 对象随后委托给一个 `PermissionEvalulator` 实例。在本章的目的上，我们使用
    ACL，因此我们将使用 `AclPermissionEvaluator`，它将读取我们在数据库中定义的 ACL。您可以查看提供的 `permissionEvaluator`
    配置，如下所示：'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The JdbcMutableAclService object
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService` 对象'
- en: 'At this point, we have seen a reference to `th` with the `aclService` ID twice.
    The `aclService` ID resolves to an implementation of `o.s.s.acls.model.AclService`
    that is responsible (through delegation) for translating information about the
    object being secured by ACLs into expected ACEs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经两次看到了带有 `aclService` ID 的 `th` 的引用。`aclService` ID 解析为 `o.s.s.acls.model.AclService`
    的一个实现，该实现通过委托负责将关于由 ACL 保护的对象的信息转换为预期的 ACE：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ll use `o.s.s.acls.jdbc.JdbcMutableAclService`, which is the default implementation
    of `o.s.s.acls.model.AclService`. This implementation comes out of the box and
    is ready to use the schema that we defined in the last step of this exercise.
    The `JdbcMutableAclService` object will additionally use recursive SQL and post-processing
    to understand the object and `SID` hierarchies and ensure that representations
    of these hierarchies are passed back to `AclPermissionEvaluator`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `o.s.s.acls.jdbc.JdbcMutableAclService`，这是 `o.s.s.acls.model.AclService`
    的默认实现。这个实现自带，并且已经准备好使用我们在本练习的最后一步中定义的模式。`JdbcMutableAclService` 对象将使用递归 SQL 和后处理来理解对象和
    `SID` 层次结构，并确保这些层次结构的表示被传递回 `AclPermissionEvaluator`。
- en: The BasicLookupStrategy class
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`BasicLookupStrategy` 类'
- en: 'The `JdbcMutableAclService` class uses the same JDBC `dataSource` instance
    that we’ve defined with the embedded database declaration, and it also delegates
    to an implementation of `o.s.s.acls.jdbc.LookupStrategy`, which is solely responsible
    for actually making database queries and resolving requests for ACLs. The only
    `LookupStrategy` implementation supplied with Spring Security is `o.s.s.acls.jdbc.BasicLookupStrategy`,
    and is defined as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService` 类使用与嵌入式数据库声明中定义的相同的 JDBC `dataSource` 实例，并且它还委托给 `o.s.s.acls.jdbc.LookupStrategy`
    的一个实现，该实现负责实际执行数据库查询并解决对 ACL 的请求。Spring Security 供应的唯一 `LookupStrategy` 实现是 `o.s.s.acls.jdbc.BasicLookupStrategy`，其定义如下：'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, `BasicLookupStrategy` is a relatively complex beast. Remember that its
    purpose is to translate a list of the `ObjectIdentity` declarations to be protected
    into the actual, applicable ACE list from the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`BasicLookupStrategy` 是一个相对复杂的实体。记住，它的目的是将需要保护的 `ObjectIdentity` 声明列表转换为数据库中的实际、适用的
    ACE 列表。
- en: As `ObjectIdentity` declarations can be recursive, this proves to be quite a
    challenging problem, and a system that is likely to experience heavy use should
    consider the SQL’s, which is generated for performance, impact on the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ObjectIdentity` 声明可能是递归的，这证明是一个相当具有挑战性的问题，一个可能会经历大量使用的系统应该考虑 SQL 的性能影响，这些
    SQL 是为了性能而生成的。
- en: Querying with the lowest common denominator
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用最低公倍数进行查询
- en: Be aware that `BasicLookupStrategy` is intended to be compatible with all databases
    by strictly sticking with `left [outer] joins`. Some older databases do not support
    this join syntax, so, ensure that you verify that the syntax and structure of
    SQL are compatible with your database!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`BasicLookupStrategy`旨在通过严格遵循`left [outer] joins`与所有数据库兼容。一些较旧的数据库不支持这种连接语法，因此，请确保验证SQL的语法和结构与你所使用的数据库兼容！
- en: There are also most certainly more efficient database-dependent methods of performing
    hierarchical queries using non-standard SQL, for example, Oracle’s `CONNECT BY`
    statement and the **common table expression** (**CTE**) capability of many other
    databases, including PostgreSQL and Microsoft SQL Server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多更有效的基于数据库的方法来使用非标准SQL执行分层查询，例如Oracle的`CONNECT BY`语句和许多其他数据库（包括PostgreSQL和Microsoft
    SQL Server）的**公共表表达式**（**CTE**）功能。
- en: Much as you learned in the example in [*Chapter 4*](B21757_04.xhtml#_idTextAnchor106),
    *JDBC-based Authentication*, using a custom schema for the `JdbcDaoImpl` implementation
    of the `UserDetailsService` properties are exposed to allow for configuration
    of the SQL utilized by `BasicLookupStrategy`. Consult the Javadoc and the source
    code itself to see how they are used so that they can be correctly applied to
    your custom schema.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在[*第4章*](B21757_04.xhtml#_idTextAnchor106)的示例中学习的那样，*基于JDBC的认证*，使用自定义模式为`JdbcDaoImpl`实现`UserDetailsService`属性暴露出来，以便配置`BasicLookupStrategy`使用的SQL。查阅Javadoc和源代码本身，以了解它们是如何使用的，以便正确应用于你的自定义模式。
- en: We can see that `LookupStrategy` requires a reference to the same JDBC `dataSource`
    instance that `AclService` utilizes. The other three references bring us almost
    to the end of the dependency chain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`LookupStrategy`需要一个引用与`AclService`使用的相同JDBC `dataSource`实例。其他三个引用几乎带我们到达依赖链的尽头。
- en: AclCache interface
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AclCache接口
- en: The `o.s.s.acls.model.AclCache` interface declares an interface for a caching
    `ObjectIdentity` to ACL mappings, to prevent redundant (and expensive) database
    lookups. Spring Security supports any implementation of `JCache (JSR-107)`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.s.acls.model.AclCache`接口声明了一个用于缓存`ObjectIdentity`到ACL映射的接口，以防止冗余（且昂贵）的数据库查找。Spring
    Security支持`JCache (JSR-107)`的任何实现。'
- en: 'For example, to enable third-party support for `Ehcache`, which is an open-source,
    memory- and disk-based caching library that is widely used in many open-source
    and commercial Java products, you need to add the following Gradle dependency:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了启用对开源、基于内存和磁盘的缓存库`Ehcache`的支持，该库在许多开源和商业Java产品中得到广泛使用，你需要添加以下Gradle依赖项：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will set up `ConcurrentMapCache` in our example by updating the configuration
    in `AclConfig.java`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过更新`AclConfig.java`中的配置来在我们的示例中设置`ConcurrentMapCache`：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The ConsoleAuditLogger class
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConsoleAuditLogger类
- en: 'The next simple dependency hanging off of `o.s.s.acls.jdbc.BasicLookupStrategy`
    is an implementation of the `o.s.s.acls.domain.AuditLogger` interface, which is
    used by the `BasicLookupStrategy` class to audit ACL and ACE lookups. Similar
    to the `AclCache` interface, only one implementation is supplied with Spring Security,
    and it simply logs to the console. We’ll configure it with another one-line bean
    declaration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，与`o.s.s.acls.jdbc.BasicLookupStrategy`相关的简单依赖项是一个`o.s.s.acls.domain.AuditLogger`接口的实现，该接口被`BasicLookupStrategy`类用于审计ACL和ACE查找。类似于`AclCache`接口，Spring
    Security只提供了一个实现，它只是简单地记录到控制台。我们将通过另一行bean声明来配置它：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The AclAuthorizationStrategyImpl interface
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AclAuthorizationStrategyImpl接口
- en: The final dependency to resolve is an implementation of the `o.s.s.acls.domain.AclAuthorizationStrategy`
    interface, which actually has no immediate responsibility at all during the load
    of the ACL from the database. Instead, the implementation of this interface is
    responsible for determining whether a runtime change to an ACL or ACE is allowed,
    based on the type of change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的最后一个依赖项是实现`o.s.s.acls.domain.AclAuthorizationStrategy`接口，这个接口在从数据库加载ACL时实际上没有任何直接责任。相反，该接口的实现负责确定是否允许对ACL或ACE的运行时更改，这取决于更改的类型。
- en: 'We’ll explain this more later when we cover mutable ACLs, as the logical flow
    is both somewhat complicated and not pertinent to getting our initial configuration
    complete. The final configuration requirements are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后当我们介绍可变ACLs时进一步解释这一点，因为逻辑流程既有些复杂，又与完成我们的初始配置不相关。最终的配置要求如下：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might wonder what the reference to the bean with the `adminAuthority` ID
    is for—`AclAuthorizationStrategyImpl` provides the ability to specify `GrantedAuthority`,
    which is required to allow specific operations at runtime on mutable ACLs. We’ll
    cover these later in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道对具有`adminAuthority` ID的bean的引用是为什么——`AclAuthorizationStrategyImpl`提供了指定`GrantedAuthority`的能力，这是在运行时对可变ACL执行特定操作所必需的。我们将在本章后面介绍这些内容。
- en: We’re finally done with the basic configuration of an out-of-the-box Spring
    Security ACL implementation. The next and final step requires that we insert a
    simple ACL and ACE into the H2 database and test it out!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了Spring Security ACL实现的初始配置。接下来的最后一步需要我们在H2数据库中插入一个简单的ACL和ACE，并对其进行测试！
- en: Creating a simple ACL entry
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建简单的ACL条目
- en: Recall that our very simple scenario is to only allow `user2@example.com` access
    to the birthday party event and ensure that no other events are accessible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的非常简单的场景是仅允许`user2@example.com`访问生日派对活动，并确保其他活动不可访问。
- en: You may find it helpful to refer back several pages (*Figure 12**.2*) to the
    database schema diagram to follow which data we are inserting and why.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要参考数据库模式图（**图12**.2）的几页，以了解我们正在插入哪些数据以及为什么。
- en: We have already included a file named `data.sql` in the sample application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在示例应用程序中包含了一个名为`data.sql`的文件。
- en: All of the SQL explained in this section will be from the file—you may feel
    free to experiment and add more test cases based on the sample SQL we’ve provided.
    In fact, we encourage you experiment with sample data!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中解释的所有SQL都将来自文件——你可以自由地实验并基于我们提供的示例SQL添加更多测试用例。实际上，我们鼓励你使用示例数据进行实验！
- en: 'Let’s take a look at the following steps for creating a simple ACL entry:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建简单ACL条目的以下步骤：
- en: 'First, we’ll need to populate the `ACL_CLASS` table with any or all of the
    domain object classes, which may have ACL rules—in the case of our example, this
    is simply our `Event` class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要用任何或所有具有ACL规则的域对象类填充`ACL_CLASS`表，在我们的例子中，这仅仅是我们的`Event`类：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We chose to use primary keys that are between 10 and 19 for the `ACL_CLASS`
    table, 20 and 29 for the `ACL_SID` table, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用`ACL_CLASS`表的10到19之间的主键，`ACL_SID`表的20到29之间，依此类推。
- en: This will help make it easier to understand which data associates with which
    table. Note that our `Event` table starts with a primary key of `100`. These conveniences
    are done for example purposes and are not suggested for production purposes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于更容易地理解哪些数据与哪些表相关联。请注意，我们的`Event`表以`100`为主键。这些便利性是为了示例目的而做的，并不建议用于生产目的。
- en: Next, the `ACL_SID` table is seeded with SIDs that will be associated with the
    ACEs. Remember that SIDs can either be roles or users—we’ll populate the roles
    and `user2@example.com` here.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`ACL_SID`表被注入了将与ACE关联的SIDs。记住，SIDs可以是角色或用户——我们在这里填充角色和`user2@example.com`。
- en: 'While the SID object for roles is straightforward, the SID object for a user
    is not quite as clear cut. For our purposes, the username is used for the SID.
    To learn more about how the SIDs are resolved for roles and users, refer to `o.s.s.acls.domain.SidRetrievalStrategyImpl`.
    If the defaults do not meet your needs, a custom `o.s.s.acls.model.SidRetrievalStrategy`
    default can be injected into `AclPermissionCacheOptimizer` and `AclPermissionEvaluator`.
    We will not need this sort of customization for our example, but it is good to
    know that it is available if necessary:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然角色的SID对象很简单，但用户的SID对象并不那么明确。在我们的用途中，用户名用于SID。要了解更多关于如何解析角色和用户的SIDs的信息，请参考`o.s.s.acls.domain.SidRetrievalStrategyImpl`。如果默认值不符合你的需求，可以将自定义的`o.s.s.acls.model.SidRetrievalStrategy`默认值注入到`AclPermissionCacheOptimizer`和`AclPermissionEvaluator`中。在我们的例子中，我们不需要这种定制，但了解它在必要时是可用的总是好的：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The table where things start getting complicated is the `ACL_OBJECT_IDENTITY`
    table, which is used to declare individual domain object instances, their parent
    (if any), and owning `SID`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 开始变得复杂的是`ACL_OBJECT_IDENTITY`表，它用于声明单个域对象实例、其父对象（如果有）以及拥有`SID`。
- en: 'For example, this table represents the `Event` objects that we are securing.
    We’ll insert a row with the following properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个表代表我们正在保护的对象`Event`。我们将插入具有以下属性的一行：
- en: A domain object of the `Event` type that is a foreign key, `10`, to our `ACL_CLASS`
    table via the `OBJECT_ID_CLASS` column.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Event`类型的域对象，它是通过`OBJECT_ID_CLASS`列指向我们的`ACL_CLASS`表的外键，值为`10`。
- en: A domain object primary key of `100` (the `OBJECT_ID_IDENTITY` column). This
    is a foreign key (although not enforced with a database constraint) to our `Event`
    object.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个域对象的`100`（`OBJECT_ID_IDENTITY`列）主键。这是一个外键（尽管不是通过数据库约束强制执行）到我们的`Event`对象。
- en: The `SID` owner of `user2@example.com`, which is a foreign key, `20`, to `ACL_SID`
    via the `OWNER_SID` column.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user2@example.com`的`SID`所有者，这是一个外键，通过`OWNER_SID`列指向`ACL_SID`，其值为`20`。'
- en: 'The SQL to represent our events with IDs of `100` (birthday event), `101`,
    and `102` is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表示具有ID为`100`（生日事件）、`101`和`102`的事件的SQL语句如下：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Keep in mind that the owning `SID` could also represent a role—both types of
    rules function equally well as far as the ACL system is concerned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，拥有`SID`的所有者也可能代表一个角色——这两种类型的规则在ACL系统中都同样有效。
- en: 'Finally, we’ll add an ACE related to this object instance, which declares that
    `user2@example.com` is allowed read access to the birthday event:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个与该对象实例相关的ACE，声明`user2@example.com`被允许读取生日事件的访问权限：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `MASK` column here represents a bitmask, which is used to grant permission
    assigned to the stated `SID` on the object in question. We’ll explain the details
    of this later in this chapter—unfortunately, it doesn’t tend to be as useful as
    it may sound.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`MASK`列代表一个位掩码，用于在相关对象上授予指定`SID`的权限。我们将在本章后面详细解释这一点——不幸的是，它可能不像听起来那么有用。
- en: Now, we can start the application and run through our sample scenario. Try logging
    in with `user2@example.com/user2` and accessing the **All Events** page. You will
    see that only the birthday event is listed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动应用程序并运行我们的示例场景。尝试使用`user2@example.com/user2`登录并访问**所有事件**页面。你会看到只有生日事件被列出。
- en: When logged in with `admin1@example.com/admin1` and viewing the **All Events**
    page, no events will be displayed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当以`admin1@example.com/admin1`登录并查看**所有事件**页面时，不会显示任何事件。
- en: However, if we navigated directly to an event, it would not be protected. Can
    you figure out how to secure direct access to an event based on what you learned
    in this chapter?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们直接导航到一个事件，它将不会受到保护。你能根据本章所学的内容想出如何确保直接访问一个事件的方法吗？
- en: 'If you have not figured it out yet, you can secure direct access to an event
    by making the following update to `CalendarService.java`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有想出来，你可以通过以下方式更新`CalendarService.java`来确保直接访问一个事件：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now have a basic working setup of ACL-based security (albeit, a very simple
    scenario).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基于ACL的安全的基本工作设置（尽管，场景非常简单）。
- en: Let’s move on to some more explanations of concepts we saw during this walkthrough,
    and then review a couple of considerations in a typical Spring ACL implementation
    that you should consider before using it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续解释我们在这次演练中看到的一些概念，然后回顾一下典型的Spring ACL实现中的一些考虑事项，在使用它之前你应该考虑这些事项。
- en: Important note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: You should start with the code from `chapter12.01-calendar`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter12.01-calendar`的代码开始。
- en: 'It is worth noting that we have not created new ACL entries when we create
    events. Thus, in the current state, if you create an event, you will receive an
    error similar to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在创建事件时没有创建新的ACL条目。因此，在当前状态下，如果你创建一个事件，你将收到一个类似于以下错误的错误：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After examining the process of creating a straightforward ACL entry, let’s now
    delve into a comprehensive understanding of how permissions operate, focusing
    on advanced ACL configurations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查创建简单ACL条目的过程之后，我们现在深入理解权限如何运作，重点关注高级ACL配置。
- en: Advanced ACL topics
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级ACL主题
- en: Some high-level topics that we skimmed over during the configuration of our
    ACL environment had to do with ACE permissions and the use of the `GrantedAuthority`
    indicators to assist the ACL environment in determining whether certain types
    of runtime changes to ACLs were allowed. Now that we have a working environment,
    we’ll review these more advanced topics.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置ACL环境时略过的一些高级主题与ACE权限和`GrantedAuthority`指示器的使用有关，这些指示器有助于ACL环境确定是否允许某些类型的ACL运行时更改。现在我们有了工作环境，我们将回顾这些更高级的主题。
- en: How permissions work
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限如何工作
- en: Permissions are no more than single logical identifiers represented by bits
    in an integer. An ACE grants permissions to `SIDs` based on the bitmask, which
    comprises the logical and of all permissions applicable to that ACE.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 权限不过是整数中由位表示的单个逻辑标识符。ACE基于位掩码授予`SIDs`权限，该位掩码包含所有适用于该ACE的权限的逻辑或。
- en: The default permission implementation, `o.s.s.acls.domain.BasePermission`, defines
    a series of integer values representing common ACL authorization verbs. These
    integer values correspond to single bits set in an integer, so a value of `BasePermission`,
    `WRITE`, with an integer value of `1` has a bitwise value of `21` or `2`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认权限实现 `o.s.s.acls.domain.BasePermission` 定义了一系列表示常见 ACL 授权动词的整数值。这些整数值对应于整数中设置的单一位，因此
    `BasePermission` 的 `WRITE` 值为 `1` 的位运算值为 `21` 或 `2`。
- en: 'These are illustrated in the following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在以下图中进行了说明：
- en: '![Figure 12.3 – Default and custom permissions bitmask](img/B21757_12_3.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 默认和自定义权限掩码](img/B21757_12_3.jpg)'
- en: Figure 12.3 – Default and custom permissions bitmask
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 默认和自定义权限掩码
- en: We can see that the `Sample` permission bitmask would have an integer value
    of `3`, due to the application of both the `Read` and `Write` permissions to the
    permission value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于将 `Read` 和 `Write` 权限应用于权限值，`Sample` 权限掩码将具有整数值 `3`。
- en: All of the standard integer single permission values shown in the preceding
    diagram are defined in the `BasePermission` object as static constants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图中展示的所有标准整数单一权限值都在 `BasePermission` 对象中定义为静态常量。
- en: The logical constants that are included in `BasePermission` are just a sensible
    baseline of commonly used permissions in ACE and have no semantic meaning within
    the Spring Security framework. It’s quite common for very complex ACL implementations
    to invent their own custom permissions, augmenting best practice examples with
    domain- or business-dependent ones.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在 `BasePermission` 中的逻辑常量只是 ACE 中常用权限的合理基线，在 Spring Security 框架中没有任何语义意义。对于非常复杂的
    ACL 实现，发明自己的自定义权限是很常见的，这些权限补充了最佳实践示例，并依赖于领域或业务依赖性。
- en: One issue that often confuses users is how the bitmasks are used in practice,
    given that many databases either do not support bitwise logic or do not support
    it in a scalable way. Spring ACL intends to solve this problem by putting more
    of the load of calculating appropriate permissions related to bitmasks on the
    application rather than on the database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常混淆的一个问题是，在实际应用中位掩码是如何使用的，因为许多数据库要么不支持位逻辑，要么不支持可扩展的方式。Spring ACL 旨在通过将计算与位掩码相关的适当权限的负载更多地放在应用程序上而不是数据库上来解决这个问题。
- en: It’s important to review the resolution process, where we see how `AclPermissionEvaluator`
    resolves permissions declared on the method itself (in our example, with the `@PostFilter`
    annotation) to real ACL permissions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 审查解析过程是很重要的，我们可以看到 `AclPermissionEvaluator` 是如何将方法本身上声明的权限（在我们的例子中，使用 `@PostFilter`
    注解）解析为实际的 ACL 权限的。
- en: 'The following diagram illustrates the process that Spring ACL performs to evaluate
    the declared permission against the relevant ACEs for the requesting principal:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Spring ACL 对声明权限与请求主体相关的相关 ACE 进行评估的过程：
- en: '![Figure 12.4 – Spring ACL permissions evaluation process](img/B21757_12_4.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – Spring ACL 权限评估过程](img/B21757_12_4.jpg)'
- en: Figure 12.4 – Spring ACL permissions evaluation process
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Spring ACL 权限评估过程
- en: We see that `AclPermissionEvaluator` relies on classes implementing two interfaces,
    `o.s.s.acls.model.ObjectIdentityRetrievalStrategy` and `o.s.s.acls.model.SidRetrievalStrategy`,
    to retrieve `ObjectIdentity` and SIDs appropriate for the authorization check.
    The important thing to note about these strategies is how the default implementation
    classes actually determine the `ObjectIdentity` and SIDs objects to return, based
    on the context of the authorization check.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`AclPermissionEvaluator` 依赖于实现两个接口的类，即 `o.s.s.acls.model.ObjectIdentityRetrievalStrategy`
    和 `o.s.s.acls.model.SidRetrievalStrategy`，以检索适合授权检查的 `ObjectIdentity` 和 SIDs。关于这些策略需要注意的是，默认实现类实际上是如何根据授权检查的上下文来确定要返回的
    `ObjectIdentity` 和 SIDs 对象的。
- en: The `ObjectIdentity` object has two properties, `type` and `identifier`, that
    are derived from the object being checked at runtime and used to declare ACE entries.
    The default `ObjectIdentityRetrievalStrategy` interface uses the fully-qualified
    class name to populate the `type` property. The `identifier` property is populated
    with the result of a method with the `Serializable getId()` signature, invoked
    on the actual object instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectIdentity` 对象有两个属性，`type` 和 `identifier`，它们是从运行时检查的对象派生出来的，并用于声明 ACE
    条目。默认的 `ObjectIdentityRetrievalStrategy` 接口使用完全限定的类名来填充 `type` 属性。`identifier`
    属性则填充了在实际对象实例上调用具有 `Serializable getId()` 签名的方 法的结果。'
- en: As your object isn’t required to implement an interface to be compatible with
    ACL checks, the requirement to implement a method with a specific signature can
    be surprising for developers implementing Spring Security ACL. Plan ahead and
    ensure that your domain objects contain this method! You may also implement your
    own `ObjectIdentityRetrievalStrategy` class (or implement the out-of-the-box subclass)
    to call a method of your choice. The name and type signature of the method is,
    unfortunately, not configurable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的对象不需要实现接口以与ACL检查兼容，因此对于实现具有特定签名的方法的必要性可能会让实现Spring Security ACL的开发者感到惊讶。请提前规划并确保你的域对象包含此方法！你也可以实现自己的`ObjectIdentityRetrievalStrategy`类（或实现现成的子类）来调用你选择的方法。不幸的是，该方法的名字和类型签名是无法配置的。
- en: Unfortunately, the actual implementation of `AclImpl` directly compares the
    permission specified in our `@PostFilter` annotation, and the permission stored
    on the ACE in the database, without using bitwise logic. You will need to take
    care when declaring a user with a combination of permissions, as either `AclEntryVoter`
    must be configured with all combinations of permissions or the ACEs need to ignore
    the fact that the permission field is intended to store multiple values and instead
    store a single permission per ACE.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`AclImpl`的实际实现直接比较了我们`@PostFilter`注解中指定的权限和数据库中ACE上存储的权限，而没有使用位运算逻辑。在声明具有权限组合的用户时，你需要注意，要么必须配置`AclEntryVoter`以包含所有权限组合，或者ACE需要忽略权限字段旨在存储多个值的事实，并改为每个ACE存储单个权限。
- en: 'If you want to verify this with our simple scenario, change the `READ` permission
    we granted to the `user2@example.com` SID to the bitmask combination of `Read
    and Write`, which translates to a value of `3`. This would be updated in the `data.sql`
    file, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要通过我们的简单场景验证这一点，将授予`user2@example.com` SID的`READ`权限更改为`读和写`的位掩码组合，这相当于值`3`。这将更新到`data.sql`文件中，如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Important note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter12.02-calendar`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter12.02-calendar`的代码开始。
- en: The custom ACL permission declaration
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义ACL权限声明
- en: As stated in the earlier discussion on permission declarations, permissions
    are nothing but logical names for integer bit values. As such, it’s possible to
    extend the `o.s.s.acls.domain.BasePermission` class and declare your own permissions.
    We’ll cover a very straightforward scenario here, where we create a new ACL permission
    called `ADMIN_READ`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在权限声明讨论中，权限不过是整数位值的逻辑名称。因此，可以扩展`o.s.s.acls.domain.BasePermission`类并声明你自己的权限。在这里，我们将涵盖一个非常直接的场景，其中我们创建一个新的ACL权限，称为`ADMIN_READ`。
- en: This is a permission that will be granted only to administrative users and will
    be assigned to protect resources that only administrators can read. Although a
    contrived example for the JBCP calendar application, this type of use of custom
    permissions occurs quite often in situations dealing with **Personally Identifiable
    Information** (**PII**) (for example, social security number, and so on—recall
    that we covered PII in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy
    of an* *Unsafe Application*).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅授予管理用户的权限，并将分配以保护只有管理员才能读取的资源。尽管这是一个针对JBCP日历应用的虚构示例，但这种自定义权限的使用在处理**个人身份信息**（**PII**）的情况中相当常见（例如，社会保险号等——回想一下我们在[*第1章*](B21757_01.xhtml#_idTextAnchor015)，*不安全应用程序的解剖*）中讨论了PII）。
- en: 'Let’s get started with making the changes required to support this by performing
    the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始进行必要的更改以支持此操作，按照以下步骤操作：
- en: 'The first step is to extend the `BasePermission` class with our own `com.packtpub.springsecurity.acls.domain.CustomPermission`
    class, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是使用我们的`com.packtpub.springsecurity.acls.domain.CustomPermission`类扩展`BasePermission`类，如下所示：
- en: '[PRE20]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we will need to configure the `o.s.s.acls.domain.PermissionFactory` default
    implementation, `o.s.s.acls.domain.DefaultPermissionFactory`, to register our
    custom permission logical value. The role of `PermissionFactory` is to resolve
    permission bitmasks into logical permission values (which can be referenced by
    the constant value, or by name, such as `ADMIN_READ`, in other areas of the application).
    The `PermissionFactory` instance requires that any custom permission is registered
    with it for proper lookup. We have included the following configuration that registers
    our `CustomPermission` class, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置`o.s.s.acls.domain.PermissionFactory`默认实现，`o.s.s.acls.domain.DefaultPermissionFactory`，以注册我们的自定义权限逻辑值。`PermissionFactory`的作用是将权限掩码解析为逻辑权限值（可以在应用程序的其他区域通过常量值或名称，如`ADMIN_READ`进行引用）。`PermissionFactory`实例要求任何自定义权限都必须注册到其中以进行适当的查找。我们已包含以下配置，如下注册我们的`CustomPermission`类：
- en: '[PRE21]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will need to override the default `PermissionFactory` instance for
    our `BasicLookupStrategy` and `AclPermissionEvaluator` interfaces with the customized
    `DefaultPermissionFactory` interface:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的`BasicLookupStrategy`和`AclPermissionEvaluator`接口覆盖默认的`PermissionFactory`实例，使用自定义的`DefaultPermissionFactory`接口：
- en: '[PRE22]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also need to add the SQL query to utilize the new permission to grant access
    to the conference call (`acl_object_identity ID of 31`) event to `admin1@example.com`.
    Make the following updates to `data.sql`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加SQL查询以利用新的权限，允许访问会议电话（`acl_object_identity ID为31`）事件给`admin1@example.com`。请在`data.sql`中进行以下更新：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that the new integer bitmask value of `32` has been referenced in
    the ACE data. This intentionally corresponds to our new `ADMIN_READ ACL` permission,
    as defined in Java code. The conference call event is referenced by its primary
    key (stored in the `object_id_identity` column) value of `31`, in the `ACL_OBJECT_IDENTITY`
    table.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到新的整数掩码值`32`已在ACE数据中引用。这有意对应于我们在Java代码中定义的新`ADMIN_READ ACL`权限。会议电话事件通过其在`ACL_OBJECT_IDENTITY`表中的主键（存储在`object_id_identity`列中）值`31`进行引用。
- en: 'The last step is to update our `CalendarService''s getEvents()` method to utilize
    our new permission, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是更新我们的`CalendarService`的`getEvents()`方法，以便利用我们新的权限，如下所示：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With all of these configurations in place, we can start up the site again and
    test out the custom ACL permission. Based on the sample data we have configured,
    here is what should happen when the various available users click on categories:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些配置到位后，我们可以再次启动网站并测试自定义ACL权限。根据我们配置的样本数据，以下是当各种可用用户点击类别时应该发生的情况：
- en: '| **Username/password** | **Birthday** **party event** | **Conference** **call
    event** | **Other events** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **用户名/密码** | **生日派对活动** | **会议电话活动** | **其他活动** |'
- en: '| `user2@example.com/user2` | Allowed via`READ` | Denied | Denied |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `user2@example.com/user2` | 通过`READ`允许 | 拒绝 | 拒绝 |'
- en: '| `admin1@example.com/admin1` | Denied | Allowed via`ADMIN_READ` | Denied |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `admin1@example.com/admin1` | 拒绝 | 通过`ADMIN_READ`允许 | 拒绝 |'
- en: '| `user1@example.com/user1` | Denied | Denied | Denied |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `user1@example.com/user1` | 拒绝 | 拒绝 | 拒绝 |'
- en: Table 12.3 – Users ACL Java objects
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.3 – 用户ACL Java对象
- en: We can see that, even with the use of our simple cases, we’ve now been able
    to extend the Spring ACL functionality in a very limited way to illustrate the
    power of this fine-grained access control system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使使用我们简单的情况，我们现在已经能够以非常有限的方式扩展Spring ACL功能，以展示这个细粒度访问控制系统的能力。
- en: Important note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter12.03-calendar`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter12.03-calendar`的代码开始。
- en: Enabling ACL permission evaluation
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用ACL权限评估
- en: We saw in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*, that the Spring Security JSP tag library offers functionality
    to expose authentication-related data to the user and to restrict what the user
    can see based on a variety of rules. So far in this book, we have used the `Thymeleaf
    Security tag libraries`, which are built on top of Spring Security.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B21757_02.xhtml#_idTextAnchor043)《Spring Security入门》中，我们了解到Spring Security
    JSP标签库提供了向用户暴露与认证相关的数据以及根据各种规则限制用户可见性的功能。到目前为止，在这本书中，我们使用了建立在Spring Security之上的`Thymeleaf
    Security标签库`。
- en: 'The very same tag library can also interact with an ACL-enabled system right
    out of the box! From our simple experiments, we have configured a simple ACL authorization
    scenario around the first two categories in the list on the home page. Let’s look
    at the following steps and learn how to enable ACL permission evaluation in our
    Thymeleaf pages:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的标签库也可以直接与一个ACL启用的系统交互！从我们的简单实验中，我们已经在主页列表的前两个类别周围配置了一个简单的ACL授权场景。让我们看看以下步骤，学习如何在我们的Thymeleaf页面中启用ACL权限评估：
- en: 'First, we will need to remove our `@PostFilter` annotation from the `getEvents()`
    method in our `CalendarService` interface in order to give our JSP tag library
    a chance to filter out the events that are not allowed for display. Go ahead and
    remove `@PostFilter` now, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从我们的`CalendarService`接口中的`getEvents()`方法移除`@PostFilter`注解，以便让我们的JSP标签库有机会过滤掉不允许显示的事件。现在就移除`@PostFilter`注解，如下所示：
- en: '[PRE25]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have removed `@PostFilter`, we can utilize the `<sec:authorize-acl>`
    tag to hide the events that the user doesn’t actually have access to. Refer to
    the table in the preceding section as a refresher on the access rules we’ve configured
    up to this point!
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经移除了`@PostFilter`，我们可以利用`<sec:authorize-acl>`标签来隐藏用户实际上没有访问权限的事件。参考前一个章节中的表格，以刷新我们对已配置的访问规则的了解！
- en: 'We’ll wrap the display of each event with the `<sec:authorize-acl>` tag, declaring
    the list of permissions to check on the object to be displayed:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`<sec:authorize-acl>`标签包装每个事件的显示，声明要检查显示对象上的权限列表：
- en: '[PRE26]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Think for a moment about what we want to occur here—we want the user to see
    only the items they actually have the `READ` or `ADMIN_READ` (our custom permission)
    access. However, to use the tag library, we need to use the permission mask, which
    can be referenced from the following table:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细思考一下我们在这里想要实现的目标——我们希望用户只能看到他们实际具有`READ`或`ADMIN_READ`（我们的自定义权限）访问权限的项目。然而，为了使用标签库，我们需要使用权限掩码，这可以从以下表中引用：
- en: '| **Name** | **Mask** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **掩码** |'
- en: '| `READ` | 1 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `READ` | 1 |'
- en: '| `WRITE` | 2 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE` | 2 |'
- en: '| `ADMIN_READ` | 32 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `ADMIN_READ` | 32 |'
- en: Table 12.4 – Permissions mask table
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.4 – 权限掩码表
- en: Behind the scenes, the tag implementation utilizes the same `SidRetrievalStrategy`
    and `ObjectIdentityRetrievalStrategy` interfaces that were discussed earlier in
    this chapter. So, the computation of access checking follows the same workflow
    as it does with ACL-enabled voting on method security. As we will see in a moment,
    the tag implementation will also use the same `PermissionEvaluator`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，标签实现使用了之前在本章中讨论过的相同的`SidRetrievalStrategy`和`ObjectIdentityRetrievalStrategy`接口。因此，访问检查的计算遵循与ACL启用的方法安全性投票相同的流程。正如我们一会儿将看到的，标签实现也将使用相同的`PermissionEvaluator`。
- en: We have already enabled our `@EnableMethodSecurity` annotation with an `expressionHandler`
    element that references `DefaultMethodSecurity` **ExpressionHandler**. The `DefaultMethodSecurityExpressionHandler`
    implementation is aware of our `AclPermissionEvaluator` interface, but we must
    also make Spring Security’s web tier aware of `AclPermissionEvalulator`. If you
    think about it, this symmetry makes sense, since securing methods and HTTP requests
    are protecting two very different resources. Fortunately, Spring Security’s abstractions
    make this rather simple.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过带有引用`DefaultMethodSecurity` **ExpressionHandler**的`expressionHandler`元素的`@EnableMethodSecurity`注解启用了我们的`@EnableMethodSecurity`。`DefaultMethodSecurityExpressionHandler`实现了解我们的`AclPermissionEvaluator`接口，但我们必须也让Spring
    Security的Web层了解`AclPermissionEvalulator`。如果你这么想，这种对称性是有意义的，因为保护方法和HTTP请求是在保护两种非常不同的资源。幸运的是，Spring
    Security的抽象使得这一点相当简单。
- en: '5. Add a `DefaultWebSecurityExpressionHandler` handler that references the
    bean with the ID of `permissionEvaluator`, which we have already defined:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 添加一个引用ID为`permissionEvaluator`的`DefaultWebSecurityExpressionHandler`处理器，因为我们已经定义了该bean：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see how these steps are very similar to how we added support for permission
    handling to our method security. This time, it was a bit simpler, since we were
    able to reuse the same bean with the ID of `PermissionEvaluator`, which we already
    configured.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些步骤与我们添加对方法安全性的权限处理支持的方式非常相似。这次，它稍微简单一些，因为我们能够重用具有`PermissionEvaluator`
    ID的同一个bean，我们之前已经配置了它。
- en: Start up our application and try accessing the `@``PostFilter` annotation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们的应用程序并尝试访问`@PostFilter`注解。
- en: We are still aware that accessing an event directly would allow a user to see
    it. However, this could easily be added by combining what you learned in this
    chapter with what you learned about the `@PostAuthorize` annotation in this chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然意识到，直接访问事件会允许用户看到它。然而，这可以通过结合你在本章中学到的内容以及关于本章中`@PostAuthorize`注解的内容轻松实现。
- en: Important note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter12.04-calendar`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter12.04-calendar`的代码开始。
- en: Mutable ACLs and authorization
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变ACL和授权
- en: Although the JBCP calendar application doesn’t implement full user administration
    functionality, it’s likely that your application will have common features, such
    as new user registration and administrative user maintenance. To this point, a
    lack of these features—which we have worked around using SQL inserts at application
    startup—hasn’t stopped us from demonstrating many of the features of Spring Security
    and Spring ACL.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JBCP日历应用没有实现完整的用户管理功能，但你的应用很可能会有一些常见功能，例如新用户注册和行政用户维护。到目前为止，这些功能的缺失——我们通过在应用启动时使用SQL插入来解决这个问题——并没有阻止我们展示Spring
    Security和Spring ACL的许多功能。
- en: However, the proper handling of runtime changes to declared ACLs, or the addition
    or removal of users in the system, is critical to maintaining the consistency
    and security of the ACL-based authorization environment. Spring ACL solves this
    issue through the concept of the mutable ACL (`o.s.s.acls.model.MutableAcl`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正确处理声明ACL的运行时更改，或者系统中用户的添加或删除，对于维护基于ACL的授权环境的一致性和安全性至关重要。Spring ACL通过可变ACL的概念（`o.s.s.acls.model.MutableAcl`）解决了这个问题。
- en: Extending the standard ACL interface, the `MutableAcl` interface allows for
    runtime manipulation of ACL fields to change the in-memory representation of a
    particular ACL. This additional functionality includes the ability to create,
    update, or delete ACEs, change ACL ownership, and other useful functions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展标准ACL接口，`MutableAcl`接口允许在运行时操作ACL字段以更改特定ACL的内存表示。这项附加功能包括创建、更新或删除ACE、更改ACL所有权以及其他有用功能。
- en: We might expect, then, that the Spring ACL module would come out of the box
    with a way to persist runtime ACL changes to the JDBC datastore, and indeed it
    does. The `o.s.s.acls.jdbc.JdbcMutableAclService` class may be used to create,
    update, and delete the `MutableAcl` instances in the database, as well as to do
    general maintenance on the other supporting tables for ACLs (handling `SIDs`,
    `ObjectIdentity`, and domain object class names).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能期望Spring ACL模块能够直接提供一种将运行时ACL更改持久化到JDBC数据存储的方式，确实如此。`o.s.s.acls.jdbc.JdbcMutableAclService`类可以用来在数据库中创建、更新和删除`MutableAcl`实例，以及进行ACL的其他支持表的常规维护（处理`SIDs`、`ObjectIdentity`和域对象类名）。
- en: 'Recall from earlier in the chapter that the `AclAuthorizationStrategyImpl`
    class allows us to specify the administrative role for actions on mutable ACLs.
    These are supplied to the constructor as part of the bean configuration. The constructor
    arguments and their meaning are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回想本章前面的内容，`AclAuthorizationStrategyImpl`类允许我们指定对可变ACL的操作的管理角色。这些作为bean配置的一部分提供给构造函数。构造函数参数及其含义如下：
- en: '| **Arg #** | **What** **it does** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **参数编号** | **功能** |'
- en: '| 1 | It indicates the authority that a principal is required to have to take
    ownership of an ACL-protected object at runtime |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 它表示主体在运行时对ACL保护对象拥有所有权的权限 |'
- en: '| 2 | It indicates the authority that a principal is required to have to change
    the auditing of an ACL-protected object at runtime |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 它表示主体在运行时更改ACL保护对象的审计所需的权限 |'
- en: '| 3 | It indicates the authority that a principal is required to have to make
    any other kind of change (create, update, and delete) to an ACL-protected object
    at runtime |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 它表示主体在运行时对ACL保护对象进行任何其他类型的更改（创建、更新和删除）所需的权限 |'
- en: Table 12.5 – Constructor arguments for AclAuthorizationStrategyImpl
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.5 – AclAuthorizationStrategyImpl构造函数的参数
- en: It may be confusing that we only specified a single constructor argument when
    there are three arguments listed. The `AclAuthorizationStrategyImpl` class can
    also accept a single `GrantedAuthority`, which will then be used for all three
    arguments. This is convenient if we want the same `GrantedAuthority` to be used
    for all of the operations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人困惑的是，当我们列出了三个参数时，我们只指定了一个构造函数参数。`AclAuthorizationStrategyImpl` 类也可以接受一个
    `GrantedAuthority`，然后它将被用于所有三个参数。如果我们想对所有操作使用相同的 `GrantedAuthority`，这将很方便。
- en: The `JdbcMutableAclService` interface contains a number of methods used to manipulate
    ACL and ACE data at runtime. While the methods themselves are fairly understandable
    (`createAcl`, `updateAcl`, and `deleteAcl`), the correct way to configure and
    use `JdbcMutableAclService` is often difficult for even advanced Spring Security
    users.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService` 接口包含许多用于在运行时操作 ACL 和 ACE 数据的方法。虽然这些方法本身相当容易理解（`createAcl`、`updateAcl`
    和 `deleteAcl`），但即使是高级 Spring Security 用户，正确配置和使用 `JdbcMutableAclService` 也往往很困难。'
- en: Let’s modify `CalendarService` to create a new ACL for newly created events.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `CalendarService` 以为新创建的事件创建一个新的 ACL。
- en: Currently, if a user creates a new event, it will not be visible to the user
    in the `<sec:authorize-acl>` tag to only display event objects that the user has
    access to. Let’s update our `DefaultCalendarService` interface so that when a
    user creates a new event, they are granted read access to that event and it will
    be displayed for them on the **All** **Events** page.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果用户创建了一个新事件，它将不会在 `<sec:authorize-acl>` 标签中对该用户可见，该标签仅显示用户有权访问的事件对象。让我们更新我们的
    `DefaultCalendarService` 接口，以便当用户创建一个新事件时，他们被授予对该事件的读取访问权限，并且它将在他们的 **所有事件** 页面上显示。
- en: 'Let’s look at the following steps to add ACLs to newly created events:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤，以将 ACL 添加到新创建的事件中：
- en: 'The first step is to update our constructor to accept `MutableAclService` and
    `UserContext`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是更新我们的构造函数以接受 `MutableAclService` 和 `UserContext`：
- en: '[PRE28]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we need to update our `createEvent` method to also create an ACL for
    the current user. Make the following changes:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的 `createEvent` 方法，以便为当前用户创建 ACL。进行以下更改：
- en: '[PRE29]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `JdbcMutableAclService` interface uses the current user as the default owner
    for the created `MutableAcl` interface. We chose to explicitly set the owner again
    to demonstrate how this can be overridden.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService` 接口使用当前用户作为创建的 `MutableAcl` 接口的默认所有者。我们选择再次显式设置所有者，以演示如何覆盖此设置。'
- en: We then add a new ACE and save our ACL. That’s all there is to it.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个新的 ACE 并保存我们的 ACL。就这么简单。
- en: Start the application and log in with `user1@example.com/user1`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并使用 `user1@example.com/user1` 登录。
- en: Visit the **All Events** page and see that there are no events currently listed.
    Then, create a new event and it will be displayed the next time you visit the
    **All Events** page. If you log in as any other user, the event will not be visible
    on the **All** **Events** page.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 **所有事件** 页面，并查看目前没有列出任何事件。然后创建一个新事件，下次您访问 **所有事件** 页面时，它将显示出来。如果您以任何其他用户登录，该事件将不会在
    **所有** **事件** 页面上可见。
- en: However, it will potentially be visible to the user since we have not applied
    security to other pages. Again, we encourage you to attempt to secure these pages
    on your own.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，由于我们没有对其他页面应用安全措施，它可能会对用户可见。我们再次鼓励您尝试自己保护这些页面。
- en: Important note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter12.05-calendar`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从 `chapter12.05-calendar` 中的代码开始。
- en: Upon grasping the workings of Spring Security ACL, the subsequent sections will
    address the factors to be considered in a standard ACL deployment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握 Spring Security ACL 的工作原理后，接下来的部分将讨论标准 ACL 部署中需要考虑的因素。
- en: Considerations for a typical ACL deployment
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型 ACL 部署的考虑因素
- en: Actually, deploying Spring ACL in a true business application tends to be quite
    involved. We wrap up coverage of Spring ACL with some considerations that arise
    in most Spring ACL implementation scenarios.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在真正的业务应用程序中部署 Spring ACL 通常相当复杂。我们通过考虑大多数 Spring ACL 实现场景中出现的考虑因素来结束对 Spring
    ACL 的介绍。
- en: ACL scalability and performance modeling
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACL 可扩展性和性能建模
- en: For small and medium-sized applications, the addition of ACLs is quite manageable,
    and while it adds overhead to database storage and runtime performance, the impact
    is not likely to be significant. However, depending on the granularity with which
    ACLs and ACEs are modeled, the numbers of database rows in a medium- to large-sized
    application can be truly staggering and can task even the most seasoned database
    administrator.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型和中型应用，ACL的添加是相当可控的，尽管它增加了数据库存储和运行时性能的负担，但影响不太可能显著。然而，根据ACL和ACE建模的粒度，中型到大型应用中的数据库行数可能会非常庞大，甚至可能让经验最丰富的数据库管理员感到压力。
- en: 'Let’s assume we were to extend ACLs to cover an extended version of the JBCP
    calendar application. Let’s assume that users can manage accounts, post pictures
    to events, and administer (add/remove users) from an event. We’ll model the data
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要将ACL扩展到覆盖JBCP日历应用的扩展版本。假设用户可以管理账户，将图片发布到事件中，并从事件中管理（添加/删除用户）。我们将数据建模如下：
- en: All users have accounts.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户都有账户。
- en: 10% of users are able to administer an event. The average number of events that
    a user can administer will be two.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10%的用户能够管理事件。一个用户可以管理的事件的平均数量将是两个。
- en: Events will be secured (read-only) per customer, but also need to be accessible
    (read/write) by administrators.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件将按客户进行保护（只读），但同时也需要由管理员可访问（读/写）。
- en: 10% of all customers will be allowed to post pictures. The average number of
    posts per user will be 20.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10%的客户将被允许发布图片。每个用户的平均帖子数将是20。
- en: Posted pictures will be secured (read/write) per user, as well as administrators.
    Posted pictures will be read-only for all other users.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布的图片将按用户以及管理员进行保护（读/写）。发布的图片对所有其他用户将是只读的。
- en: 'Given what we know about the ACL system, we know that the database tables have
    the following scalability attributes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对ACL系统的了解，我们知道数据库表具有以下可扩展属性：
- en: '| **Table** | **Scales** **with data** | **Scalability notes** |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **表** | **与数据**一起**扩展** | **可扩展性说明** |'
- en: '| `ACL_CLASS` | No | One row is required per domain class. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_CLASS` | 否 | 每个域类需要一个行。 |'
- en: '| `ACL_SID` | Yes (users) | One row is required per role (`GrantedAuthority`).
    One row is required for each user account (if individual domain objects are secured
    per user). |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_SID` | 是（用户） | 每个角色（`GrantedAuthority`）需要一个行。每个用户账户（如果域对象按用户进行保护）需要一个行。
    |'
- en: '| `ACL_OBJECT_IDENTITY` | Yes (domain class instances per class) | One row
    is required per instance of a secured domain object. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_OBJECT_IDENTITY` | 是（每个类的域类实例） | 每个受保护域对象的实例需要一个行。 |'
- en: '| `ACL_ENTRY` | Yes (domain object instances individual ACE entries) | One
    row is required per ACE; may require multiple rows for a single domain object.
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_ENTRY` | 是（域对象实例的ACE条目） | 每个ACE需要一个行；可能需要为单个域对象多个行。 |'
- en: Table 12.6 – Database table’s scalability attributes
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.6 – 数据库表的可扩展属性
- en: We can see that `ACL_CLASS` doesn’t really have scalability concerns (most systems
    will have fewer than 1,000 domain classes).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`ACL_CLASS`实际上没有可扩展性问题（大多数系统将拥有少于1,000个域类）。
- en: The `ACL_SID` table will scale linearly based on the number of users in the
    system. This is probably not a matter of concern because other user-related tables
    will scale in this fashion as well (user account, and so on).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_SID`表将根据系统中的用户数量线性扩展。这可能不是一个问题，因为其他与用户相关的表也将以这种方式扩展（用户账户等）。'
- en: 'The two tables of concern are `ACL_OBJECT_IDENTITY` and `ACL_ENTRY`. If we
    model the estimated rows required to model an order for an individual customer,
    we come up with the following estimates:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的两个表是`ACL_OBJECT_IDENTITY`和`ACL_ENTRY`。如果我们对为单个客户建模订单所需的估计行数进行建模，我们得到以下估计：
- en: '| **Table** | **ACL data** **per event** | **ACL data per** **picture post**
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **表** | **每个事件**的ACL数据 | **每个图片帖子**的ACL数据 |'
- en: '| `ACL_OBJECT_IDENTITY` | One row is required for a single event. | One row
    is required for a single post. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_OBJECT_IDENTITY` | 单个事件需要一个行。 | 单个帖子需要一个行。 |'
- en: '| `ACL_ENTRY` | Three rows—one row is required for read access by the owner
    (the user SID) and two rows are required (one for read access, one for write access)
    for the administrative group SID. | Four rows—one row is required for read access
    by the user group SID, one row is required for write access by the owner, and
    two rows are required for the administrative group SID (as with events). |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `ACL条目` | 三行——一行是所有者（用户SID）读取访问所需的，两行是管理组SID所需的（一行用于读取访问，一行用于写入访问）。 | 四行——一行是用户组SID读取访问所需的，一行是所有者写入访问所需的，两行是管理组SID所需的（与事件相同）。
    |'
- en: Table 12.7 – Scalability estimates per events or posted pictures
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.7 – 每个事件或发布的图片的可扩展性估计
- en: 'We can then take the usage assumptions from the previous page and calculate
    the following ACL scalability matrix as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从上一页的使用假设中计算出以下ACL可扩展性矩阵，如下所示：
- en: '| **Table/Object** | **Scale factor** | **Estimates (Low)** | **Estimates (High)**
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **表/对象** | **缩放因子** | **低估计** | **高估计** |'
- en: '| `Users` |  | `10,000` | `1,000,000` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `用户` |  | `10,000` | `1,000,000` |'
- en: '| `Events` | `#` `Users` `*` `0.1` `*` `2` | `2,000` | `200,000` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `事件` | `#` `用户` `*` `0.1` `*` `2` | `2,000` | `200,000` |'
- en: '| `Picture Posts` | `#` `Users` `*` `0.1` `*` `20` | `20,000` | `2,000,000`
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `图片帖子` | `#` `用户` `*` `0.1` `*` `20` | `20,000` | `2,000,000` |'
- en: '| `ACL_SID` | `#` `Users` | `10,000` | `1,000,000` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_SID` | `#` `用户` | `10,000` | `1,000,000` |'
- en: '| `ACL_OBJECT_IDENTITY` | `#` `Events` `+` `#` `Picture` `Posts` | `220,000`
    | `2,200,000` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_OBJECT_IDENTITY` | `#` `事件` `+` `#` `图片帖子` | `220,000` | `2,200,000`
    |'
- en: '| `ACL_ENTRY` | `(#` `Events` `*` `3)` `+` `(#` `Picture` `Posts` `*` `4)`
    | `86,000` | `8,600,000` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `ACL条目` | `(#` `事件` `*` `3)` `+` `(#` `图片帖子` `*` `4)` | `86,000` | `8,600,000`
    |'
- en: Table 12.8 – ACL scalability matrix
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.8 – ACL可扩展性矩阵
- en: From these projections based on only a subset of the business objects likely
    to be involved and secured in a typical ACL implementation, you can see that the
    number of database rows devoted to storing ACL information is likely to grow linearly
    (or faster) in relation to your actual business data. Especially in large system
    planning, forecasting the amount of ACL data that you are likely to use is extremely
    important. It is not uncommon for very complex systems to have hundreds of millions
    of rows related to ACL storage.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从仅基于典型ACL实现可能涉及和受保护的业务对象子集的预测来看，您可以看到，用于存储ACL信息的数据库行数可能会与您的实际业务数据成线性（或更快）增长。特别是在大型系统规划中，预测您可能使用的ACL数据量非常重要。对于非常复杂的系统来说，有数亿行与ACL存储相关的行数并不罕见。
- en: Do not discount custom development costs
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要低估定制开发成本
- en: 'Utilizing a Spring ACL-secured environment often requires significant development
    work above and beyond the configuration steps we’ve described to this point. Our
    sample configuration scenario has the following limitations:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Spring ACL安全环境通常需要比我们到目前为止所描述的配置步骤更多的开发工作。我们的示例配置场景有以下局限性：
- en: No facility is provided for responding to the manipulation modification of events
    or modification of permissions.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供对事件操作修改或权限修改进行响应的设施。
- en: Not all of the applications use permissions. For example, the **My Events**
    page and directly navigating to an event are both not secured.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有应用程序都使用权限。例如，**我的事件**页面和直接导航到事件都不是受保护的。
- en: The application does not effectively use ACL hierarchies. These limitations
    would significantly impact the functionality if we were to roll out ACL security
    to the whole site. This is why it is critical that when planning Spring ACL rollout
    across an application, you must carefully review all the places where the domain
    data is manipulated and ensure that these locations correctly update ACL, ACE
    rules, and invalidate caches. Typically, the securing of methods and data takes
    place at the service or business application layer, and the hooks required to
    maintain ACLs and ACEs occur at the data access layer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序没有有效地使用ACL层次结构。如果我们要将ACL安全推广到整个网站，这些局限性将严重影响功能。这就是为什么在计划在应用程序中推广Spring ACL时，您必须仔细审查所有处理域数据的位置，并确保这些位置正确更新ACL、ACE规则并使缓存失效。通常，方法和数据的安全发生在服务或业务应用层，而维护ACL和ACE所需的钩子发生在数据访问层。
- en: '![Figure 12.6 – Spring ACL permissions evaluation process](img/B21757_12_5.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – Spring ACL权限评估过程](img/B21757_12_5.jpg)'
- en: Figure 12.6 – Spring ACL permissions evaluation process
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – Spring ACL权限评估过程
- en: If you are dealing with a reasonably standard application architecture, with
    proper isolation and encapsulation of functionality, it’s likely that there’s
    an easily identified central location for these changes. On the other hand, if
    you’re dealing with an architecture that has devolved (or was never designed well
    in the first place), then adding ACL functionality and supporting hooks in data
    manipulation code can prove to be very difficult.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一个相对标准的应用程序架构，具有适当的功能隔离和封装，那么很可能存在一个易于识别的中心位置来处理这些更改。另一方面，如果你正在处理一个已经退化（或者一开始就没有设计得很好）的架构，那么在数据操作代码中添加ACL功能和支持钩子可能会非常困难。
- en: As previously hinted, it’s important to keep in mind that the Spring ACL architecture
    hasn’t changed significantly since the days of `Acegi 1.x (Parent project of`
    `Spring Security)`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，重要的是要记住，Spring ACL架构自`Acegi 1.x`（Spring Security的父项目）时代以来并没有发生重大变化。
- en: 'The following are some of the most important and commonly encountered issues
    with the Spring ACL architecture:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些与Spring ACL架构最常见和最重要的问题：
- en: The ACL infrastructure requires a numeric primary key. For applications that
    use a **globally unique identifier** (**GUID**) or **Universal Unique Identifier**
    (**UUID**) primary key (which occurs more frequently due to more efficient support
    in modern databases), this can be a significant limitation.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL基础设施需要一个数字主键。对于使用**全局唯一标识符**（**GUID**）或**通用唯一标识符**（**UUID**）主键的应用程序（由于现代数据库中更有效的支持，这种情况更为常见），这可能是一个重大的限制。
- en: Several inconsistencies exist between the method of configuring Spring ACL and
    the rest of Spring Security. In general, it is likely that you will run into areas
    where class delegates or properties are not exposed through **Dependency Injection**
    (**DI**), necessitating an override and rewrite strategy that can be time consuming
    and expensive to maintain.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置Spring ACL的方法和Spring Security的其他部分之间存在几个不一致之处。一般来说，你可能会遇到一些区域，其中类代理或属性没有通过**依赖注入**（**DI**）公开，这需要一种耗时且昂贵的覆盖和重写策略。
- en: The permission bitmask is implemented as an integer and thus has 32 possible
    bits. It’s somewhat common to expand the default bit assignments to indicate permissions
    on individual object properties (for example, assigning a bit to read the social
    security number of an employee). Complex deployments may have well over 32 properties
    per domain object, in which case the only alternative would be to remodel your
    domain objects around this limitation.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限掩码被实现为一个整数，因此有32个可能的位。将默认位分配扩展以表示单个对象属性的权限（例如，分配一个位来读取员工的社保号码）是相当常见的。复杂的部署可能每个域对象有超过32个属性，在这种情况下，唯一的替代方案可能是在这个限制下重新设计你的域对象。
- en: Depending on your application requirements, it is likely that you will encounter
    additional issues, especially with regard to the number of classes requiring change
    when implementing certain types of customizations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的应用程序需求，你可能会遇到更多的问题，特别是关于在实现某些类型的自定义时需要更改的类数量。
- en: Should I use Spring Security ACL?
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该使用Spring Security ACL吗？
- en: Just like the details of applying Spring Security are highly business dependent,
    so is the application of Spring ACL support. In fact, this tends to be even more
    true of ACL support due to its tight coupling to business methods and domain objects.
    We hope that this guide to Spring ACL has explained the important high-level and
    low-level configurations and concepts required to analyze Spring ACL for use in
    your application and can assist you in determining and matching its capabilities
    to real-world use.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如应用Spring Security的细节高度依赖于业务一样，Spring ACL支持的应用也是如此。事实上，由于它与业务方法和域对象的紧密耦合，ACL支持往往更是如此。我们希望本指南解释了分析Spring
    ACL以用于你的应用程序所需的重要高级和低级配置和概念，并可以帮助你确定和匹配其实际应用的能力。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on security based on ACLs and the specific details
    of how this type of security is implemented by the Spring ACL module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点介绍了基于ACL的安全性和Spring ACL模块实现这种类型安全性的具体细节。
- en: We reviewed the basic concept of ACLs, and many reasons why they can be very
    effective solutions to authorization. Also, we learned about the key concepts
    related to the Spring ACL implementation, including ACEs, SIDs, and object identity.
    We examined the database schema and logical design required to support a hierarchical
    ACL system. We configured all the required Spring beans to enable the Spring ACL
    module and enhanced one of the service interfaces to use annotated method authorization.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了ACLs的基本概念，以及为什么它们可以成为授权的有效解决方案的许多原因。我们还了解了与Spring ACL实现相关的关键概念，包括ACEs、SIDs和对象标识。我们检查了支持分层ACL系统所需的数据库模式和逻辑设计。我们配置了所有必需的Spring
    beans以启用Spring ACL模块，并增强了一个服务接口以使用注解方法授权。
- en: We then tied the existing users in our database, and business objects used by
    the site itself, into a sample set of ACE declarations and supporting data. We
    reviewed the concepts around Spring ACL permission handling. We expanded our knowledge
    of the Spring Security Thymeleaf tag library and SpEL (for method security) to
    utilize ACL checks.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将数据库中的现有用户和网站本身使用的业务对象与一组示例ACE声明和支持数据关联起来。我们回顾了Spring ACL权限处理的概念。我们扩展了我们对Spring
    Security Thymeleaf标签库和SpEL（用于方法安全）的知识，以利用ACL检查。
- en: We discussed the mutable ACL concept and reviewed the basic configuration and
    custom coding required in a mutable ACL environment. We developed a custom ACL
    permission and configured the application to demonstrate its effectiveness. We
    configured and analyzed the use of the `Spring` cache manager to reduce the database
    impact of Spring ACL. We analyzed the impact and design considerations of using
    the Spring ACL system in a complex business application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了可变ACL的概念，并回顾了在可变ACL环境中所需的基本配置和自定义编码。我们开发了一个自定义ACL权限，并配置了应用程序以展示其有效性。我们配置并分析了使用`Spring`缓存管理器以减少Spring
    ACL对数据库的影响。我们分析了在复杂业务应用程序中使用Spring ACL系统的影响和设计考虑因素。
- en: This wraps up our discussion about Spring Security ACLs. In the next chapter,
    we’ll dig a bit further into how Spring Security works.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Spring Security ACLs的讨论。在下一章中，我们将进一步探讨Spring Security的工作原理。
