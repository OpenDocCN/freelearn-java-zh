- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access Control Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will address the complex topic of **Access Control Lists**
    (**ACLs**), which can provide a rich model of domain object instance-level authorization.
    Spring Security ships with a robust, but complicated, ACL module that can serve
    the needs of small to medium-sized implementations reasonably well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the conceptual model of an ACL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the terminology and application of ACL concepts in the Spring Security
    ACL module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and reviewing the database schema required to support Spring ACL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the **Jim Bob CP Calendar** (**JBCP**) calendar to use ACL-secured
    business methods via annotations and Spring beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing advanced configuration, including customized ACL permissions, ACL-enabled
    **JavaServer Page** (**JSP**) tag checks and method security, mutable ACLs, and
    smart caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining architectural considerations and planning scenarios for ACL deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/hRby2](https://packt.link/hRby2).'
  prefs: []
  type: TYPE_NORMAL
- en: The conceptual module of an ACL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of the non-web tier security puzzle is security at the business
    object level, applied at or below the business tier. Security at this level is
    implemented using a technique known as ACL, or ACLs. To sum up the objective of
    ACLs in a single sentence, ACLs allow the specification of a set of group permissions
    based on the unique combination of a group, business object, and logical operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an ACL declaration for the JBCP calendar might declare that a
    given user must write access to his or her own event. This can be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Group** | **Object** | **Permissions** |'
  prefs: []
  type: TYPE_TB
- en: '| josh |  | event_01 | read, write |'
  prefs: []
  type: TYPE_TB
- en: '|  | ROLE_USER | event_123 | read |'
  prefs: []
  type: TYPE_TB
- en: '|  | ANONYMOUS | Any event | none |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Example of user ACL declaration
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this ACL is eminently readable by a human—`josh` has `read`
    and `write` access to his own event (`event_01`); other registered users can read
    the events of `josh`, but anonymous users cannot.
  prefs: []
  type: TYPE_NORMAL
- en: This type of rule matrix is, in a nutshell, what ACL attempts to synthesize
    about a secured system and its business data into a combination of code, access
    checking, and metadata. Most true ACL-enabled systems have extremely complex ACL
    lists and may conceivably have millions of entries across the entire system. Although
    this sounds frighteningly complex, proper up-front reasoning and implementation
    with a capable security library can make ACL management quite feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a Microsoft Windows or Unix/Linux-based computer, you experience
    the magic of ACLs every single day. Most modern computer **Operating Systems**
    (**OSs**) use ACL directives as part of their file storage systems, allowing permission
    granting based on a combination of a user or group, file, or directory, and permission.
    In Microsoft Windows, you can view some of the ACL capabilities of a file by right-clicking
    on a file and examining its security properties (**Properties** | **Security**),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – An example of ACL capabilities with Microsoft Windows](img/B21757_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – An example of ACL capabilities with Microsoft Windows
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to see that the combinations of inputs to the ACL are visible
    and intuitive as you navigate through the various groups or users and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve explored the conceptual module of ACL. In the following
    section, we will proceed to delve into the workings of ACLs in Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: ACLs in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security supports ACL-driven authorization checks against access to individual
    domain objects by individual users of the secured system. As in the OS filesystem
    example, it is possible to use the Spring Security ACL components to build logical
    tree structures of both business objects and groups or principals. The intersection
    of permissions (inherited or explicit) on both the requestor and the requestee
    is used to determine allowed access.
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite common for users approaching the ACL capability of Spring Security
    to be overwhelmed by its complexity, combined with a relative dearth of documentation
    and examples. This is compounded by the fact that setting up the ACL infrastructure
    can be quite complicated, with many interdependencies and reliance on bean-based
    configuration mechanisms, which are quite unlike much of the rest of Spring Security
    (as you’ll see in a moment when we set up the initial configuration).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Security ACL module was written to be a reasonable baseline, but
    users intending to build extensively on the functionality will likely run into
    a series of frustrating limitations and design choices, which have gone (for the
    most part) uncorrected as they were first introduced in the early days of Spring
    Security. Don’t let these limitations discourage you! The ACL module is a powerful
    way to embed rich access controls in your application, and further scrutinize
    and secure user actions and data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into configuring Spring Security ACL support, we need to review
    some key terminology and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The main unit of secured actor identity in the Spring ACL system is the `GrantedAuthority`).
    The SID object defined by the ACL data model you construct is used as the basis
    for explicit and derived access control rules when determining the allowed level
    of access for a particular principal.
  prefs: []
  type: TYPE_NORMAL
- en: If SIDs are used to define actors in the ACL system, the opposite half of the
    security equation is the definition of the secured objects themselves. The identification
    of individual secured objects is called (unsurprisingly) an **Object Identity**.
    The default Spring ACL implementation of an object identity requires ACL rules
    to be defined at the individual object instance level, which means, if desired,
    every object in the system can have an individual access rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual access rules are known as **Access control Entries** (**ACEs**).
    An ACE is the combination of the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The SID for the actor to which the rule applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object identity to which the rule applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The permission that should be applied to the given `SID` and the stated object
    identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the stated permission should be allowed or denied for the given
    `SID` and object identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of the Spring ACL system is to evaluate each secured method invocation
    and determine whether the object or objects being acted on in the method should
    be allowed as per the applicable ACEs. Applicable ACEs are evaluated at runtime,
    based on the caller and the objects in play.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security ACL is flexible in its implementation. Although most of this
    chapter details the out-of-the-box functionality of the Spring Security ACL module,
    keep in mind, however, that many of the rules indicated represent default implementations,
    which in many cases can be overridden based on more complex requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security uses helpful value objects to represent the data associated
    with each of these conceptual entities. These are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ACL** **conceptual object** | **Java object** |'
  prefs: []
  type: TYPE_TB
- en: '| SID | `o.s.s.acls.model.Sid` |'
  prefs: []
  type: TYPE_TB
- en: '| Object identity | `o.s.s.acls.model.ObjectIdentity` |'
  prefs: []
  type: TYPE_TB
- en: '| ACL | `o.s.s.acls.model.Acl` |'
  prefs: []
  type: TYPE_TB
- en: '| ACE | `o.s.s.acls.model.AccessControlEntry` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.2 – Spring Security ACL java objects
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through the process of enabling Spring Security ACL components for
    a simple demonstration in the JBCP calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic configuration of Spring Security ACL support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we hinted previously that configuring ACL support in Spring Security
    requires bean-based configuration (which it does), you can use ACL support while
    retaining the simpler security XML namespace configuration if you choose. In the
    remaining examples in this chapter, we will be focusing on Java-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with most of the chapters, we will need to add some dependencies in order
    to use the functionality in this chapter. A list of the dependencies we have added
    with comments about when they are needed can be checked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve updated your project dependencies, we can investigate the implementation
    of fine-grained permission access controls in our JBCP calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a simple target scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our simple target scenario is to grant `user2@example`.com read access to only
    the birthday party event.
  prefs: []
  type: TYPE_NORMAL
- en: All other users will not have any access to any events. You will observe that
    this differs from our other examples since `user2@example.com` is not otherwise
    associated with the birthday party event.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are several ways to set up ACL checking, our preference is to
    follow the annotation-based approach that we used in this chapter’s method-level
    annotations. This nicely abstracts the use of ACLs away from the actual interface
    declarations and allows for replacement (if you want) of the role declarations
    with something other than ACLs at a later date (should you so choose).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add an annotation to the `CalendarService.getEvents` method, which filters
    each event based upon the current user’s permission to the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter12.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ACL tables to the H2 database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we’ll need to do is add the required tables and data to support
    persistent ACL entries in our in-memory H2 database. To do this, we’ll add a new
    SQL `schema.sql`. We will break down each of these files later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have included the following `schema.sql` file with this chapter’s source
    code, which is based upon the schema files included in the Spring Security reference’s
    [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional* *Reference Material*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following database schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – ACL database schema](img/B21757_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – ACL database schema
  prefs: []
  type: TYPE_NORMAL
- en: You can see how the concepts of `SIDs`, `OBJECT_IDENTITY`, and `ACEs` map directly
    to the database schema. Conceptually, this is convenient, as we can map our mental
    model of the ACL system and how it is enforced directly to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve cross-referenced this with the H2 database schema supplied with the
    Spring Security documentation, you’ll note that we’ve made a few tweaks that commonly
    bite users. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `ACL_CLASS.CLASS` column to `500` characters, from the default value
    of `100`. Some long, fully qualified class names don’t fit in `100` characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name the foreign keys with something meaningful so that failures are more easily
    diagnosed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using another database, such as Oracle, you’ll have to translate
    the DDL into DDL and data types specific to your database.
  prefs: []
  type: TYPE_NORMAL
- en: Once we configure the remainder of the ACL system, we’ll return to the database
    to set up some basic ACEs to prove the ACL functionality in its most primitive
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SecurityExpressionHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll need to configure `@EnableMethodSecurity` to enable annotations (where
    we’ll annotate based on the expected ACL privilege) and reference a custom access
    decision manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to provide an `o.s.s.access.expression.SecurityExpressionHandler`
    implementation that is aware of how to evaluate permissions. Update your `SecurityConfig.java`
    configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bean reference to the `DefaultMethodSecurityExpressionHandler` object
    that we have defined in `AclConfig.java` file for you, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With even a relatively straightforward ACL configuration, as we have in our
    scenario, there are a number of required dependencies to set up. As we mentioned
    previously, the Spring Security ACL module comes out of the box with a number
    of components that you can assemble to provide a decent set of ACL capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The AclPermissionCacheOptimizer object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DefaultMethodSecurityExpressionHandler` object has two dependencies. The
    `AclPermissionCacheOptimizer` object is used to prime the cache with all of the
    ACLs for a collection of objects in a single JDBC select statement. The relatively
    simple configuration included with this chapter can be checked, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing AclPermission Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DefaultMethodSecurityExpressionHandler` object then delegates to a `PermissionEvalulator`
    instance. For the purposes of this chapter, we are using ACLs so that the bean
    we will use `AclPermissionEvaluator`, which will read the ACLs that we define
    in our database. You can view the provided configuration for `permissionEvaluator`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The JdbcMutableAclService object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we have seen a reference to `th` with the `aclService` ID twice.
    The `aclService` ID resolves to an implementation of `o.s.s.acls.model.AclService`
    that is responsible (through delegation) for translating information about the
    object being secured by ACLs into expected ACEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use `o.s.s.acls.jdbc.JdbcMutableAclService`, which is the default implementation
    of `o.s.s.acls.model.AclService`. This implementation comes out of the box and
    is ready to use the schema that we defined in the last step of this exercise.
    The `JdbcMutableAclService` object will additionally use recursive SQL and post-processing
    to understand the object and `SID` hierarchies and ensure that representations
    of these hierarchies are passed back to `AclPermissionEvaluator`.
  prefs: []
  type: TYPE_NORMAL
- en: The BasicLookupStrategy class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `JdbcMutableAclService` class uses the same JDBC `dataSource` instance
    that we’ve defined with the embedded database declaration, and it also delegates
    to an implementation of `o.s.s.acls.jdbc.LookupStrategy`, which is solely responsible
    for actually making database queries and resolving requests for ACLs. The only
    `LookupStrategy` implementation supplied with Spring Security is `o.s.s.acls.jdbc.BasicLookupStrategy`,
    and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, `BasicLookupStrategy` is a relatively complex beast. Remember that its
    purpose is to translate a list of the `ObjectIdentity` declarations to be protected
    into the actual, applicable ACE list from the database.
  prefs: []
  type: TYPE_NORMAL
- en: As `ObjectIdentity` declarations can be recursive, this proves to be quite a
    challenging problem, and a system that is likely to experience heavy use should
    consider the SQL’s, which is generated for performance, impact on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Querying with the lowest common denominator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that `BasicLookupStrategy` is intended to be compatible with all databases
    by strictly sticking with `left [outer] joins`. Some older databases do not support
    this join syntax, so, ensure that you verify that the syntax and structure of
    SQL are compatible with your database!
  prefs: []
  type: TYPE_NORMAL
- en: There are also most certainly more efficient database-dependent methods of performing
    hierarchical queries using non-standard SQL, for example, Oracle’s `CONNECT BY`
    statement and the **common table expression** (**CTE**) capability of many other
    databases, including PostgreSQL and Microsoft SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Much as you learned in the example in [*Chapter 4*](B21757_04.xhtml#_idTextAnchor106),
    *JDBC-based Authentication*, using a custom schema for the `JdbcDaoImpl` implementation
    of the `UserDetailsService` properties are exposed to allow for configuration
    of the SQL utilized by `BasicLookupStrategy`. Consult the Javadoc and the source
    code itself to see how they are used so that they can be correctly applied to
    your custom schema.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `LookupStrategy` requires a reference to the same JDBC `dataSource`
    instance that `AclService` utilizes. The other three references bring us almost
    to the end of the dependency chain.
  prefs: []
  type: TYPE_NORMAL
- en: AclCache interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `o.s.s.acls.model.AclCache` interface declares an interface for a caching
    `ObjectIdentity` to ACL mappings, to prevent redundant (and expensive) database
    lookups. Spring Security supports any implementation of `JCache (JSR-107)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to enable third-party support for `Ehcache`, which is an open-source,
    memory- and disk-based caching library that is widely used in many open-source
    and commercial Java products, you need to add the following Gradle dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will set up `ConcurrentMapCache` in our example by updating the configuration
    in `AclConfig.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The ConsoleAuditLogger class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next simple dependency hanging off of `o.s.s.acls.jdbc.BasicLookupStrategy`
    is an implementation of the `o.s.s.acls.domain.AuditLogger` interface, which is
    used by the `BasicLookupStrategy` class to audit ACL and ACE lookups. Similar
    to the `AclCache` interface, only one implementation is supplied with Spring Security,
    and it simply logs to the console. We’ll configure it with another one-line bean
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The AclAuthorizationStrategyImpl interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final dependency to resolve is an implementation of the `o.s.s.acls.domain.AclAuthorizationStrategy`
    interface, which actually has no immediate responsibility at all during the load
    of the ACL from the database. Instead, the implementation of this interface is
    responsible for determining whether a runtime change to an ACL or ACE is allowed,
    based on the type of change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explain this more later when we cover mutable ACLs, as the logical flow
    is both somewhat complicated and not pertinent to getting our initial configuration
    complete. The final configuration requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder what the reference to the bean with the `adminAuthority` ID
    is for—`AclAuthorizationStrategyImpl` provides the ability to specify `GrantedAuthority`,
    which is required to allow specific operations at runtime on mutable ACLs. We’ll
    cover these later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’re finally done with the basic configuration of an out-of-the-box Spring
    Security ACL implementation. The next and final step requires that we insert a
    simple ACL and ACE into the H2 database and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple ACL entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that our very simple scenario is to only allow `user2@example.com` access
    to the birthday party event and ensure that no other events are accessible.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it helpful to refer back several pages (*Figure 12**.2*) to the
    database schema diagram to follow which data we are inserting and why.
  prefs: []
  type: TYPE_NORMAL
- en: We have already included a file named `data.sql` in the sample application.
  prefs: []
  type: TYPE_NORMAL
- en: All of the SQL explained in this section will be from the file—you may feel
    free to experiment and add more test cases based on the sample SQL we’ve provided.
    In fact, we encourage you experiment with sample data!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps for creating a simple ACL entry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to populate the `ACL_CLASS` table with any or all of the
    domain object classes, which may have ACL rules—in the case of our example, this
    is simply our `Event` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We chose to use primary keys that are between 10 and 19 for the `ACL_CLASS`
    table, 20 and 29 for the `ACL_SID` table, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This will help make it easier to understand which data associates with which
    table. Note that our `Event` table starts with a primary key of `100`. These conveniences
    are done for example purposes and are not suggested for production purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `ACL_SID` table is seeded with SIDs that will be associated with the
    ACEs. Remember that SIDs can either be roles or users—we’ll populate the roles
    and `user2@example.com` here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While the SID object for roles is straightforward, the SID object for a user
    is not quite as clear cut. For our purposes, the username is used for the SID.
    To learn more about how the SIDs are resolved for roles and users, refer to `o.s.s.acls.domain.SidRetrievalStrategyImpl`.
    If the defaults do not meet your needs, a custom `o.s.s.acls.model.SidRetrievalStrategy`
    default can be injected into `AclPermissionCacheOptimizer` and `AclPermissionEvaluator`.
    We will not need this sort of customization for our example, but it is good to
    know that it is available if necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The table where things start getting complicated is the `ACL_OBJECT_IDENTITY`
    table, which is used to declare individual domain object instances, their parent
    (if any), and owning `SID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this table represents the `Event` objects that we are securing.
    We’ll insert a row with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A domain object of the `Event` type that is a foreign key, `10`, to our `ACL_CLASS`
    table via the `OBJECT_ID_CLASS` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A domain object primary key of `100` (the `OBJECT_ID_IDENTITY` column). This
    is a foreign key (although not enforced with a database constraint) to our `Event`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SID` owner of `user2@example.com`, which is a foreign key, `20`, to `ACL_SID`
    via the `OWNER_SID` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SQL to represent our events with IDs of `100` (birthday event), `101`,
    and `102` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the owning `SID` could also represent a role—both types of
    rules function equally well as far as the ACL system is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll add an ACE related to this object instance, which declares that
    `user2@example.com` is allowed read access to the birthday event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `MASK` column here represents a bitmask, which is used to grant permission
    assigned to the stated `SID` on the object in question. We’ll explain the details
    of this later in this chapter—unfortunately, it doesn’t tend to be as useful as
    it may sound.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start the application and run through our sample scenario. Try logging
    in with `user2@example.com/user2` and accessing the **All Events** page. You will
    see that only the birthday event is listed.
  prefs: []
  type: TYPE_NORMAL
- en: When logged in with `admin1@example.com/admin1` and viewing the **All Events**
    page, no events will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we navigated directly to an event, it would not be protected. Can
    you figure out how to secure direct access to an event based on what you learned
    in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not figured it out yet, you can secure direct access to an event
    by making the following update to `CalendarService.java`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We now have a basic working setup of ACL-based security (albeit, a very simple
    scenario).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to some more explanations of concepts we saw during this walkthrough,
    and then review a couple of considerations in a typical Spring ACL implementation
    that you should consider before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter12.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that we have not created new ACL entries when we create
    events. Thus, in the current state, if you create an event, you will receive an
    error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After examining the process of creating a straightforward ACL entry, let’s now
    delve into a comprehensive understanding of how permissions operate, focusing
    on advanced ACL configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced ACL topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some high-level topics that we skimmed over during the configuration of our
    ACL environment had to do with ACE permissions and the use of the `GrantedAuthority`
    indicators to assist the ACL environment in determining whether certain types
    of runtime changes to ACLs were allowed. Now that we have a working environment,
    we’ll review these more advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: How permissions work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions are no more than single logical identifiers represented by bits
    in an integer. An ACE grants permissions to `SIDs` based on the bitmask, which
    comprises the logical and of all permissions applicable to that ACE.
  prefs: []
  type: TYPE_NORMAL
- en: The default permission implementation, `o.s.s.acls.domain.BasePermission`, defines
    a series of integer values representing common ACL authorization verbs. These
    integer values correspond to single bits set in an integer, so a value of `BasePermission`,
    `WRITE`, with an integer value of `1` has a bitwise value of `21` or `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Default and custom permissions bitmask](img/B21757_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Default and custom permissions bitmask
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the `Sample` permission bitmask would have an integer value
    of `3`, due to the application of both the `Read` and `Write` permissions to the
    permission value.
  prefs: []
  type: TYPE_NORMAL
- en: All of the standard integer single permission values shown in the preceding
    diagram are defined in the `BasePermission` object as static constants.
  prefs: []
  type: TYPE_NORMAL
- en: The logical constants that are included in `BasePermission` are just a sensible
    baseline of commonly used permissions in ACE and have no semantic meaning within
    the Spring Security framework. It’s quite common for very complex ACL implementations
    to invent their own custom permissions, augmenting best practice examples with
    domain- or business-dependent ones.
  prefs: []
  type: TYPE_NORMAL
- en: One issue that often confuses users is how the bitmasks are used in practice,
    given that many databases either do not support bitwise logic or do not support
    it in a scalable way. Spring ACL intends to solve this problem by putting more
    of the load of calculating appropriate permissions related to bitmasks on the
    application rather than on the database.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to review the resolution process, where we see how `AclPermissionEvaluator`
    resolves permissions declared on the method itself (in our example, with the `@PostFilter`
    annotation) to real ACL permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the process that Spring ACL performs to evaluate
    the declared permission against the relevant ACEs for the requesting principal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Spring ACL permissions evaluation process](img/B21757_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Spring ACL permissions evaluation process
  prefs: []
  type: TYPE_NORMAL
- en: We see that `AclPermissionEvaluator` relies on classes implementing two interfaces,
    `o.s.s.acls.model.ObjectIdentityRetrievalStrategy` and `o.s.s.acls.model.SidRetrievalStrategy`,
    to retrieve `ObjectIdentity` and SIDs appropriate for the authorization check.
    The important thing to note about these strategies is how the default implementation
    classes actually determine the `ObjectIdentity` and SIDs objects to return, based
    on the context of the authorization check.
  prefs: []
  type: TYPE_NORMAL
- en: The `ObjectIdentity` object has two properties, `type` and `identifier`, that
    are derived from the object being checked at runtime and used to declare ACE entries.
    The default `ObjectIdentityRetrievalStrategy` interface uses the fully-qualified
    class name to populate the `type` property. The `identifier` property is populated
    with the result of a method with the `Serializable getId()` signature, invoked
    on the actual object instance.
  prefs: []
  type: TYPE_NORMAL
- en: As your object isn’t required to implement an interface to be compatible with
    ACL checks, the requirement to implement a method with a specific signature can
    be surprising for developers implementing Spring Security ACL. Plan ahead and
    ensure that your domain objects contain this method! You may also implement your
    own `ObjectIdentityRetrievalStrategy` class (or implement the out-of-the-box subclass)
    to call a method of your choice. The name and type signature of the method is,
    unfortunately, not configurable.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the actual implementation of `AclImpl` directly compares the
    permission specified in our `@PostFilter` annotation, and the permission stored
    on the ACE in the database, without using bitwise logic. You will need to take
    care when declaring a user with a combination of permissions, as either `AclEntryVoter`
    must be configured with all combinations of permissions or the ACEs need to ignore
    the fact that the permission field is intended to store multiple values and instead
    store a single permission per ACE.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to verify this with our simple scenario, change the `READ` permission
    we granted to the `user2@example.com` SID to the bitmask combination of `Read
    and Write`, which translates to a value of `3`. This would be updated in the `data.sql`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter12.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The custom ACL permission declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated in the earlier discussion on permission declarations, permissions
    are nothing but logical names for integer bit values. As such, it’s possible to
    extend the `o.s.s.acls.domain.BasePermission` class and declare your own permissions.
    We’ll cover a very straightforward scenario here, where we create a new ACL permission
    called `ADMIN_READ`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a permission that will be granted only to administrative users and will
    be assigned to protect resources that only administrators can read. Although a
    contrived example for the JBCP calendar application, this type of use of custom
    permissions occurs quite often in situations dealing with **Personally Identifiable
    Information** (**PII**) (for example, social security number, and so on—recall
    that we covered PII in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy
    of an* *Unsafe Application*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with making the changes required to support this by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to extend the `BasePermission` class with our own `com.packtpub.springsecurity.acls.domain.CustomPermission`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will need to configure the `o.s.s.acls.domain.PermissionFactory` default
    implementation, `o.s.s.acls.domain.DefaultPermissionFactory`, to register our
    custom permission logical value. The role of `PermissionFactory` is to resolve
    permission bitmasks into logical permission values (which can be referenced by
    the constant value, or by name, such as `ADMIN_READ`, in other areas of the application).
    The `PermissionFactory` instance requires that any custom permission is registered
    with it for proper lookup. We have included the following configuration that registers
    our `CustomPermission` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will need to override the default `PermissionFactory` instance for
    our `BasicLookupStrategy` and `AclPermissionEvaluator` interfaces with the customized
    `DefaultPermissionFactory` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add the SQL query to utilize the new permission to grant access
    to the conference call (`acl_object_identity ID of 31`) event to `admin1@example.com`.
    Make the following updates to `data.sql`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the new integer bitmask value of `32` has been referenced in
    the ACE data. This intentionally corresponds to our new `ADMIN_READ ACL` permission,
    as defined in Java code. The conference call event is referenced by its primary
    key (stored in the `object_id_identity` column) value of `31`, in the `ACL_OBJECT_IDENTITY`
    table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to update our `CalendarService''s getEvents()` method to utilize
    our new permission, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of these configurations in place, we can start up the site again and
    test out the custom ACL permission. Based on the sample data we have configured,
    here is what should happen when the various available users click on categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username/password** | **Birthday** **party event** | **Conference** **call
    event** | **Other events** |'
  prefs: []
  type: TYPE_TB
- en: '| `user2@example.com/user2` | Allowed via`READ` | Denied | Denied |'
  prefs: []
  type: TYPE_TB
- en: '| `admin1@example.com/admin1` | Denied | Allowed via`ADMIN_READ` | Denied |'
  prefs: []
  type: TYPE_TB
- en: '| `user1@example.com/user1` | Denied | Denied | Denied |'
  prefs: []
  type: TYPE_TB
- en: Table 12.3 – Users ACL Java objects
  prefs: []
  type: TYPE_NORMAL
- en: We can see that, even with the use of our simple cases, we’ve now been able
    to extend the Spring ACL functionality in a very limited way to illustrate the
    power of this fine-grained access control system.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter12.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling ACL permission evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*, that the Spring Security JSP tag library offers functionality
    to expose authentication-related data to the user and to restrict what the user
    can see based on a variety of rules. So far in this book, we have used the `Thymeleaf
    Security tag libraries`, which are built on top of Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very same tag library can also interact with an ACL-enabled system right
    out of the box! From our simple experiments, we have configured a simple ACL authorization
    scenario around the first two categories in the list on the home page. Let’s look
    at the following steps and learn how to enable ACL permission evaluation in our
    Thymeleaf pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to remove our `@PostFilter` annotation from the `getEvents()`
    method in our `CalendarService` interface in order to give our JSP tag library
    a chance to filter out the events that are not allowed for display. Go ahead and
    remove `@PostFilter` now, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have removed `@PostFilter`, we can utilize the `<sec:authorize-acl>`
    tag to hide the events that the user doesn’t actually have access to. Refer to
    the table in the preceding section as a refresher on the access rules we’ve configured
    up to this point!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll wrap the display of each event with the `<sec:authorize-acl>` tag, declaring
    the list of permissions to check on the object to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Think for a moment about what we want to occur here—we want the user to see
    only the items they actually have the `READ` or `ADMIN_READ` (our custom permission)
    access. However, to use the tag library, we need to use the permission mask, which
    can be referenced from the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Name** | **Mask** |'
  prefs: []
  type: TYPE_TB
- en: '| `READ` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ADMIN_READ` | 32 |'
  prefs: []
  type: TYPE_TB
- en: Table 12.4 – Permissions mask table
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, the tag implementation utilizes the same `SidRetrievalStrategy`
    and `ObjectIdentityRetrievalStrategy` interfaces that were discussed earlier in
    this chapter. So, the computation of access checking follows the same workflow
    as it does with ACL-enabled voting on method security. As we will see in a moment,
    the tag implementation will also use the same `PermissionEvaluator`.
  prefs: []
  type: TYPE_NORMAL
- en: We have already enabled our `@EnableMethodSecurity` annotation with an `expressionHandler`
    element that references `DefaultMethodSecurity` **ExpressionHandler**. The `DefaultMethodSecurityExpressionHandler`
    implementation is aware of our `AclPermissionEvaluator` interface, but we must
    also make Spring Security’s web tier aware of `AclPermissionEvalulator`. If you
    think about it, this symmetry makes sense, since securing methods and HTTP requests
    are protecting two very different resources. Fortunately, Spring Security’s abstractions
    make this rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: '5. Add a `DefaultWebSecurityExpressionHandler` handler that references the
    bean with the ID of `permissionEvaluator`, which we have already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see how these steps are very similar to how we added support for permission
    handling to our method security. This time, it was a bit simpler, since we were
    able to reuse the same bean with the ID of `PermissionEvaluator`, which we already
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: Start up our application and try accessing the `@``PostFilter` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: We are still aware that accessing an event directly would allow a user to see
    it. However, this could easily be added by combining what you learned in this
    chapter with what you learned about the `@PostAuthorize` annotation in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter12.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable ACLs and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the JBCP calendar application doesn’t implement full user administration
    functionality, it’s likely that your application will have common features, such
    as new user registration and administrative user maintenance. To this point, a
    lack of these features—which we have worked around using SQL inserts at application
    startup—hasn’t stopped us from demonstrating many of the features of Spring Security
    and Spring ACL.
  prefs: []
  type: TYPE_NORMAL
- en: However, the proper handling of runtime changes to declared ACLs, or the addition
    or removal of users in the system, is critical to maintaining the consistency
    and security of the ACL-based authorization environment. Spring ACL solves this
    issue through the concept of the mutable ACL (`o.s.s.acls.model.MutableAcl`).
  prefs: []
  type: TYPE_NORMAL
- en: Extending the standard ACL interface, the `MutableAcl` interface allows for
    runtime manipulation of ACL fields to change the in-memory representation of a
    particular ACL. This additional functionality includes the ability to create,
    update, or delete ACEs, change ACL ownership, and other useful functions.
  prefs: []
  type: TYPE_NORMAL
- en: We might expect, then, that the Spring ACL module would come out of the box
    with a way to persist runtime ACL changes to the JDBC datastore, and indeed it
    does. The `o.s.s.acls.jdbc.JdbcMutableAclService` class may be used to create,
    update, and delete the `MutableAcl` instances in the database, as well as to do
    general maintenance on the other supporting tables for ACLs (handling `SIDs`,
    `ObjectIdentity`, and domain object class names).
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from earlier in the chapter that the `AclAuthorizationStrategyImpl`
    class allows us to specify the administrative role for actions on mutable ACLs.
    These are supplied to the constructor as part of the bean configuration. The constructor
    arguments and their meaning are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arg #** | **What** **it does** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | It indicates the authority that a principal is required to have to take
    ownership of an ACL-protected object at runtime |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | It indicates the authority that a principal is required to have to change
    the auditing of an ACL-protected object at runtime |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | It indicates the authority that a principal is required to have to make
    any other kind of change (create, update, and delete) to an ACL-protected object
    at runtime |'
  prefs: []
  type: TYPE_TB
- en: Table 12.5 – Constructor arguments for AclAuthorizationStrategyImpl
  prefs: []
  type: TYPE_NORMAL
- en: It may be confusing that we only specified a single constructor argument when
    there are three arguments listed. The `AclAuthorizationStrategyImpl` class can
    also accept a single `GrantedAuthority`, which will then be used for all three
    arguments. This is convenient if we want the same `GrantedAuthority` to be used
    for all of the operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `JdbcMutableAclService` interface contains a number of methods used to manipulate
    ACL and ACE data at runtime. While the methods themselves are fairly understandable
    (`createAcl`, `updateAcl`, and `deleteAcl`), the correct way to configure and
    use `JdbcMutableAclService` is often difficult for even advanced Spring Security
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify `CalendarService` to create a new ACL for newly created events.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, if a user creates a new event, it will not be visible to the user
    in the `<sec:authorize-acl>` tag to only display event objects that the user has
    access to. Let’s update our `DefaultCalendarService` interface so that when a
    user creates a new event, they are granted read access to that event and it will
    be displayed for them on the **All** **Events** page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following steps to add ACLs to newly created events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to update our constructor to accept `MutableAclService` and
    `UserContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to update our `createEvent` method to also create an ACL for
    the current user. Make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `JdbcMutableAclService` interface uses the current user as the default owner
    for the created `MutableAcl` interface. We chose to explicitly set the owner again
    to demonstrate how this can be overridden.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add a new ACE and save our ACL. That’s all there is to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application and log in with `user1@example.com/user1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the **All Events** page and see that there are no events currently listed.
    Then, create a new event and it will be displayed the next time you visit the
    **All Events** page. If you log in as any other user, the event will not be visible
    on the **All** **Events** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, it will potentially be visible to the user since we have not applied
    security to other pages. Again, we encourage you to attempt to secure these pages
    on your own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter12.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Upon grasping the workings of Spring Security ACL, the subsequent sections will
    address the factors to be considered in a standard ACL deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for a typical ACL deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actually, deploying Spring ACL in a true business application tends to be quite
    involved. We wrap up coverage of Spring ACL with some considerations that arise
    in most Spring ACL implementation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: ACL scalability and performance modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For small and medium-sized applications, the addition of ACLs is quite manageable,
    and while it adds overhead to database storage and runtime performance, the impact
    is not likely to be significant. However, depending on the granularity with which
    ACLs and ACEs are modeled, the numbers of database rows in a medium- to large-sized
    application can be truly staggering and can task even the most seasoned database
    administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we were to extend ACLs to cover an extended version of the JBCP
    calendar application. Let’s assume that users can manage accounts, post pictures
    to events, and administer (add/remove users) from an event. We’ll model the data
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All users have accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10% of users are able to administer an event. The average number of events that
    a user can administer will be two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events will be secured (read-only) per customer, but also need to be accessible
    (read/write) by administrators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10% of all customers will be allowed to post pictures. The average number of
    posts per user will be 20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posted pictures will be secured (read/write) per user, as well as administrators.
    Posted pictures will be read-only for all other users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given what we know about the ACL system, we know that the database tables have
    the following scalability attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Scales** **with data** | **Scalability notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_CLASS` | No | One row is required per domain class. |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_SID` | Yes (users) | One row is required per role (`GrantedAuthority`).
    One row is required for each user account (if individual domain objects are secured
    per user). |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_OBJECT_IDENTITY` | Yes (domain class instances per class) | One row
    is required per instance of a secured domain object. |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_ENTRY` | Yes (domain object instances individual ACE entries) | One
    row is required per ACE; may require multiple rows for a single domain object.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.6 – Database table’s scalability attributes
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `ACL_CLASS` doesn’t really have scalability concerns (most systems
    will have fewer than 1,000 domain classes).
  prefs: []
  type: TYPE_NORMAL
- en: The `ACL_SID` table will scale linearly based on the number of users in the
    system. This is probably not a matter of concern because other user-related tables
    will scale in this fashion as well (user account, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The two tables of concern are `ACL_OBJECT_IDENTITY` and `ACL_ENTRY`. If we
    model the estimated rows required to model an order for an individual customer,
    we come up with the following estimates:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **ACL data** **per event** | **ACL data per** **picture post**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_OBJECT_IDENTITY` | One row is required for a single event. | One row
    is required for a single post. |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_ENTRY` | Three rows—one row is required for read access by the owner
    (the user SID) and two rows are required (one for read access, one for write access)
    for the administrative group SID. | Four rows—one row is required for read access
    by the user group SID, one row is required for write access by the owner, and
    two rows are required for the administrative group SID (as with events). |'
  prefs: []
  type: TYPE_TB
- en: Table 12.7 – Scalability estimates per events or posted pictures
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then take the usage assumptions from the previous page and calculate
    the following ACL scalability matrix as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table/Object** | **Scale factor** | **Estimates (Low)** | **Estimates (High)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Users` |  | `10,000` | `1,000,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Events` | `#` `Users` `*` `0.1` `*` `2` | `2,000` | `200,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Picture Posts` | `#` `Users` `*` `0.1` `*` `20` | `20,000` | `2,000,000`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_SID` | `#` `Users` | `10,000` | `1,000,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_OBJECT_IDENTITY` | `#` `Events` `+` `#` `Picture` `Posts` | `220,000`
    | `2,200,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_ENTRY` | `(#` `Events` `*` `3)` `+` `(#` `Picture` `Posts` `*` `4)`
    | `86,000` | `8,600,000` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.8 – ACL scalability matrix
  prefs: []
  type: TYPE_NORMAL
- en: From these projections based on only a subset of the business objects likely
    to be involved and secured in a typical ACL implementation, you can see that the
    number of database rows devoted to storing ACL information is likely to grow linearly
    (or faster) in relation to your actual business data. Especially in large system
    planning, forecasting the amount of ACL data that you are likely to use is extremely
    important. It is not uncommon for very complex systems to have hundreds of millions
    of rows related to ACL storage.
  prefs: []
  type: TYPE_NORMAL
- en: Do not discount custom development costs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Utilizing a Spring ACL-secured environment often requires significant development
    work above and beyond the configuration steps we’ve described to this point. Our
    sample configuration scenario has the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: No facility is provided for responding to the manipulation modification of events
    or modification of permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all of the applications use permissions. For example, the **My Events**
    page and directly navigating to an event are both not secured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application does not effectively use ACL hierarchies. These limitations
    would significantly impact the functionality if we were to roll out ACL security
    to the whole site. This is why it is critical that when planning Spring ACL rollout
    across an application, you must carefully review all the places where the domain
    data is manipulated and ensure that these locations correctly update ACL, ACE
    rules, and invalidate caches. Typically, the securing of methods and data takes
    place at the service or business application layer, and the hooks required to
    maintain ACLs and ACEs occur at the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Spring ACL permissions evaluation process](img/B21757_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Spring ACL permissions evaluation process
  prefs: []
  type: TYPE_NORMAL
- en: If you are dealing with a reasonably standard application architecture, with
    proper isolation and encapsulation of functionality, it’s likely that there’s
    an easily identified central location for these changes. On the other hand, if
    you’re dealing with an architecture that has devolved (or was never designed well
    in the first place), then adding ACL functionality and supporting hooks in data
    manipulation code can prove to be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: As previously hinted, it’s important to keep in mind that the Spring ACL architecture
    hasn’t changed significantly since the days of `Acegi 1.x (Parent project of`
    `Spring Security)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the most important and commonly encountered issues
    with the Spring ACL architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The ACL infrastructure requires a numeric primary key. For applications that
    use a **globally unique identifier** (**GUID**) or **Universal Unique Identifier**
    (**UUID**) primary key (which occurs more frequently due to more efficient support
    in modern databases), this can be a significant limitation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several inconsistencies exist between the method of configuring Spring ACL and
    the rest of Spring Security. In general, it is likely that you will run into areas
    where class delegates or properties are not exposed through **Dependency Injection**
    (**DI**), necessitating an override and rewrite strategy that can be time consuming
    and expensive to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The permission bitmask is implemented as an integer and thus has 32 possible
    bits. It’s somewhat common to expand the default bit assignments to indicate permissions
    on individual object properties (for example, assigning a bit to read the social
    security number of an employee). Complex deployments may have well over 32 properties
    per domain object, in which case the only alternative would be to remodel your
    domain objects around this limitation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your application requirements, it is likely that you will encounter
    additional issues, especially with regard to the number of classes requiring change
    when implementing certain types of customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Should I use Spring Security ACL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the details of applying Spring Security are highly business dependent,
    so is the application of Spring ACL support. In fact, this tends to be even more
    true of ACL support due to its tight coupling to business methods and domain objects.
    We hope that this guide to Spring ACL has explained the important high-level and
    low-level configurations and concepts required to analyze Spring ACL for use in
    your application and can assist you in determining and matching its capabilities
    to real-world use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on security based on ACLs and the specific details
    of how this type of security is implemented by the Spring ACL module.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed the basic concept of ACLs, and many reasons why they can be very
    effective solutions to authorization. Also, we learned about the key concepts
    related to the Spring ACL implementation, including ACEs, SIDs, and object identity.
    We examined the database schema and logical design required to support a hierarchical
    ACL system. We configured all the required Spring beans to enable the Spring ACL
    module and enhanced one of the service interfaces to use annotated method authorization.
  prefs: []
  type: TYPE_NORMAL
- en: We then tied the existing users in our database, and business objects used by
    the site itself, into a sample set of ACE declarations and supporting data. We
    reviewed the concepts around Spring ACL permission handling. We expanded our knowledge
    of the Spring Security Thymeleaf tag library and SpEL (for method security) to
    utilize ACL checks.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the mutable ACL concept and reviewed the basic configuration and
    custom coding required in a mutable ACL environment. We developed a custom ACL
    permission and configured the application to demonstrate its effectiveness. We
    configured and analyzed the use of the `Spring` cache manager to reduce the database
    impact of Spring ACL. We analyzed the impact and design considerations of using
    the Spring ACL system in a complex business application.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our discussion about Spring Security ACLs. In the next chapter,
    we’ll dig a bit further into how Spring Security works.
  prefs: []
  type: TYPE_NORMAL
