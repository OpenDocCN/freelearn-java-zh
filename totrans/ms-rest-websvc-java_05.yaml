- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Generating Code with OpenAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenAPI生成代码
- en: In this chapter, we will start the development of a completely new API called
    Order Management that will interact with the Product API developed in [*Chapter
    2*](B21843_02.xhtml#_idTextAnchor050) and evolved in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)
    .
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始开发一个全新的API，称为订单管理，该API将与在[*第2章*](B21843_02.xhtml#_idTextAnchor050)中开发的Product
    API以及在第[*第3章*](B21843_03.xhtml#_idTextAnchor076)中演化的API进行交互。
- en: In the previous chapter, the Product API was developed following the *code-first*
    approach, wherein the API was implemented before the documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，产品API是按照*代码优先*的方法开发的，即在文档之前实现API。
- en: In this chapter, we will adopt a *specification-first* approach, also known
    as API-first, wherein we will have the specification of the whole API done first,
    and then have the API implemented.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采用*规范优先*的方法，也称为API-first，即首先完成整个API的规范，然后实现API。
- en: Firstly, we will build the OpenAPI specification for the Order Management API,
    declaring the paths, methods, and request and response schemas (some of them using
    polymorphism) for it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为订单管理API构建OpenAPI规范，声明其路径、方法和请求及响应模式（其中一些使用多态）。
- en: Then, we will use OpenAPI tools to generate Java code stubs from the API specification.
    This generated code speeds up the implementation process, reduces manual maintenance
    of boilerplate code, and, most importantly, makes it easier to maintain consistency
    between the API specification and the service implementation for future changes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用OpenAPI工具从API规范生成Java代码存根。此生成的代码加快了实现过程，减少了样板代码的手动维护，最重要的是，使得在API规范和服务实现之间保持一致性更容易，以便于未来的更改。
- en: Next, we will go through the package structure of the service and the code implementation
    bullet points for the build of this API, delivering it in a ready-to-work state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍服务的包结构和API构建的代码实现要点，将其交付为可工作的状态。
- en: Finally, we will look into establishing communication between the Order Management
    and Product APIs to validate the products that will be registered in the orders
    created in this service, by calling an external API and responding accordingly
    to the received condition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨在订单管理和产品API之间建立通信，通过调用外部API并根据接收到的条件相应地做出响应，以验证在此服务中创建的订单中将要注册的产品。
- en: By the end of this chapter, you will have built all the knowledge you need to
    get started with the design, development, and integration of specification-first
    APIs to greatly empower you and speed up your design and development phases in
    an unbelievable manner.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将构建出开始设计、开发和集成规范优先API所需的所有知识，这将极大地增强您的实力，并以令人难以置信的方式加快您的设计和开发阶段。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Specification of the Order Management API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理API规范
- en: Generating code from the specification
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从规范生成代码
- en: Package structure of the Order Management API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理API的包结构
- en: Implementing the Order Management API controller
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现订单管理API控制器
- en: Communicating with the Product API
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与产品API通信
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will implement an example Order Management API. To be able
    to follow along and use the code examples as they are printed in the book, you
    should have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个示例订单管理API。为了能够跟随本书中的代码示例进行操作，您应该具备以下条件：
- en: Intermediate knowledge of the Java language and platform
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Java语言和平台有中级知识
- en: At least a basic knowledge of Spring Boot or a similar framework
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要了解Spring Boot或类似框架的基本知识
- en: Java 21 and Maven 3.9.0 installed
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Java 21和Maven 3.9.0
- en: In this chapter, we are going to apply API-first REST principles to create our
    API; you can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将应用API-first REST原则来创建我们的API；您可以在GitHub上找到本章的代码，网址为[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)。
- en: Specifying the Order Management API
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范订单管理API
- en: In this section, you will develop the specification of the operations and data
    structures of the Order Management API. The Order Management API, as part of the
    project we are building over the course of this book, will handle the orders of
    products managed by the Product API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将开发订单管理API的操作和数据结构的规范。订单管理API作为我们在本书中构建的项目的一部分，将处理由产品API管理的产品的订单。
- en: As explained in the previous chapter, *specification-first* means an abstract
    API specification is created before the actual implementation of the API. Instead
    of starting with executable code in a programming language, you begin by defining
    the structure, behavior, and functionality of the API. That is why this is also
    known as API-first development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，*规范优先*意味着在API的实际实现之前创建一个抽象的API规范。您不是从编程语言中的可执行代码开始，而是首先定义API的结构、行为和功能。这就是为什么这也被称为API优先开发。
- en: In [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015) , we visited many key principles
    that should be considered when designing RESTful APIs. Let us look at how to apply
    those principles with the API-first approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B21843_01.xhtml#_idTextAnchor015)中，我们探讨了在设计RESTful API时应考虑的许多关键原则。让我们看看如何使用API优先的方法应用这些原则。
- en: Implementing HTTP principles in API-first development
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在API优先开发中实施HTTP原则
- en: 'When adopting an API-first approach, it is crucial to think in HTTP terms right
    from the design phase. Let us look at some of the principles:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用API优先的方法时，从设计阶段开始就考虑HTTP术语至关重要。让我们看看一些原则：
- en: '**Define API contracts first** : Use tools such as OpenAPI/Swagger to define
    your API structure, including endpoints, request/response formats, and data models.
    This contract serves as a blueprint for developers and helps ensure consistency
    and clarity. We are going to build an API contract with an OpenAPI specification
    file for the Order Management API in the next section.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首先定义API合约**：使用OpenAPI/Swagger等工具定义您的API结构，包括端点、请求/响应格式和数据模型。此合约作为开发者的蓝图，有助于确保一致性和清晰性。在下一节中，我们将使用OpenAPI规范文件为订单管理API构建API合约。'
- en: '**Consistent use of HTTP methods and status codes** : Follow conventions for
    HTTP methods and status codes, as seen in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    . For example, use `GET` for retrieving resources, `POST` for creating, `PUT`
    for updating, and `DELETE` for removing resources. Use appropriate status codes
    to communicate the result of the request. These should also be described in the
    specification file.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致使用HTTP方法和状态码**：遵循如[*第2章*](B21843_02.xhtml#_idTextAnchor050)中看到的HTTP方法和状态码的约定。例如，使用`GET`检索资源，`POST`创建，`PUT`更新，`DELETE`删除资源。使用适当的状态码来传达请求的结果。这些也应在规范文件中描述。'
- en: '**Emphasize resource modeling** : Focus on accurately modeling your domain
    as resources. This involves identifying key entities and their relationships,
    identifying them by URLs that can be accessed using HTTP methods. For example,
    in our Order Management API, resources are `Customers` , `Products` , and `Orders`
    .'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强调资源建模**：关注准确地将您的领域建模为资源。这包括识别关键实体及其关系，通过可以使用HTTP方法访问的URL来识别它们。例如，在我们的订单管理API中，资源是`Customers`、`Products`和`Orders`。'
- en: '**Plan for versioning** : Implement versioning strategies to handle API evolution.
    This can be done through URL path versioning (e.g., `/v2/books` ) and standard
    or custom request headers. Versioning supports backward compatibility and smooth
    transitions as the API grows and changes. This will be defined in the Common API
    metadata of our specification file.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规划版本控制**：实施版本控制策略以处理API的演变。这可以通过URL路径版本控制（例如，`/v2/books`）和标准或自定义请求头来完成。版本控制支持向后兼容性和随着API的增长和变化而平稳过渡。这将在我们的规范文件的通用API元数据中定义。'
- en: '**Consider security** : Define authentication and authorization mechanisms,
    such as OAuth, API keys, or JSON Web Tokens (JWTs), to secure your API. We will
    briefly look at how to add a security scheme to our specification, and you will
    learn how to implement it in depth in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176)
    .'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑安全性**：定义认证和授权机制，例如OAuth、API密钥或JSON Web Tokens (JWTs)，以保护您的API。我们将简要介绍如何将安全方案添加到我们的规范中，您将学习如何在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中深入实现它。'
- en: Now that we have a clearer picture of the principles we aim to achieve with
    this definition, let us start writing into the specification itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对通过此定义要实现的原则有了更清晰的了解，让我们开始编写规范本身。
- en: Designing the OpenAPI specification
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 OpenAPI 规范
- en: 'We will write the Order Management API specification using the YAML syntax.
    You can use any editor of your personal preference to follow along: you can use
    the online Swagger Editor available at [https://editor.swagger.io/](https://editor.swagger.io/)
    , or if you work using IDEs such as JetBrains IntelliJ or Microsoft VS Code, you
    can use plugins to get a similar experience to the Swagger website and validate
    your specification while writing it inside your IDE.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 YAML 语法编写订单管理 API 规范。您可以使用您个人偏好的任何编辑器来跟随：您可以使用在线 Swagger 编辑器 [https://editor.swagger.io/](https://editor.swagger.io/)，或者如果您使用
    JetBrains IntelliJ 或 Microsoft VS Code 等 IDE 工作，您可以使用插件来获得类似 Swagger 网站的经验，并在
    IDE 内部编写规范时验证您的规范。
- en: The full specification that we will create is available on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的完整规范可在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)。
- en: Let us begin the specification file by defining the API’s common metadata.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义 API 的公共元数据开始编写规范文件。
- en: Common API metadata
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共 API 元数据
- en: 'We will start by defining the top-level context of the specification with the
    metadata about the API, defining the title, the description, and the version of
    the API. Also, here we describe the servers where the application will be running.
    In our case, since we want to run it locally, we will use `localhost` for testing
    purposes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 API 的元数据定义规范的最高层上下文，包括 API 的标题、描述和版本。此外，我们在这里描述应用程序将运行的服务器。在我们的案例中，因为我们想本地运行它，所以我们将使用
    `localhost` 进行测试目的：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Order Management API paths
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单管理 API 路径
- en: 'This API will have three paths:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 将有三个路径：
- en: '`/orders` with the `POST` and `GET` methods for creating and retrieving orders,
    respectively'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders` 使用 `POST` 和 `GET` 方法分别用于创建和检索订单'
- en: '`/orders/{orderId}` with the `GET` , `PUT` , and `DELETE` methods for accessing,
    editing, and removing specific orders, respectively'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{orderId}` 使用 `GET`、`PUT` 和 `DELETE` 方法分别用于访问、编辑和删除特定订单'
- en: '`/orders/{orderId}/status` with the `PATCH` method to change the status of
    an existing order'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{orderId}/status` 使用 `PATCH` 方法来更改现有订单的状态'
- en: Methods for the /orders path
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`/orders` 路径的方法'
- en: 'Let us start by defining the `POST` method with its request and response. Remember,
    the `$ref` notation is used to refer to the schema definitions in a separate section
    of the specification document. This allows the schemas to be reused, and the `paths`
    section to be shorter and more readable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 `POST` 方法及其请求和响应。记住，`$ref` 符号用于引用规范文档中单独部分的规范定义。这允许规范可重用，并且使 `paths`
    部分更短、更易读：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this `POST` definition, we are defining that when the controller receives
    a `POST` request with the `/orders` path, the request should contain a body as
    specified in the `OrderRequestBody` schema definition. If everything goes well,
    the API will respond with the `201 Created` HTTP status code, with the body defined
    in the `OrderResponse` schema. If the request body does not match `OrderRequestBody`
    , the API will respond with a `400 Bad Request` HTTP response code. We are going
    to define the request and response bodies later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `POST` 定义中，我们定义了当控制器接收到带有 `/orders` 路径的 `POST` 请求时，请求应包含 `OrderRequestBody`
    规范定义中的主体。如果一切顺利，API 将以 `201 Created` HTTP 状态码响应，主体由 `OrderResponse` 规范定义。如果请求主体不匹配
    `OrderRequestBody`，API 将以 `400 Bad Request` HTTP 响应代码响应。我们将在本章后面定义请求和响应主体。
- en: Also, to help the OpenAPI generator name the classes that will be generated
    from our specification, we are specifying a tag in each method operation. In this
    case, the tag will be named `OrderManagement` . If we omit the tag, the generated
    class will be named `DefaultApi` . We will cover this in detail in the *Generating
    code from the specification* section when we have configured the generator and
    start generating code from the specification.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了帮助 OpenAPI 生成器命名从我们的规范中生成的类，我们在每个方法操作中指定了一个标签。在这种情况下，标签将被命名为 `OrderManagement`。如果我们省略标签，生成的类将被命名为
    `DefaultApi`。我们将在配置生成器并开始从规范生成代码的 *从规范生成代码* 部分详细说明这一点。
- en: 'Next, we will define the `GET` method for the `/orders` path endpoint:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `/orders` 路径端点定义 `GET` 方法：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a `GET` method and, when called, it returns the list of orders, if any,
    with HTTP status `200` , and with an array of objects of type `OrderResponse`
    that contains all the orders in the system. If there are none, the returned list
    will be empty still with HTTP status `200` , meaning that the request was successfully
    completed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We will also specify an endpoint to retrieve a single order from the system
    in the next path.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Methods for the /orders/{orderId} path
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, we are going to define another path to access specific orders, and we
    will define a `GET` , a `PUT` , and a `DELETE` method for this path, starting
    with the `GET` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `GET` method, we are defining a path to retrieve data from a single
    order. Here, we are receiving a single parameter in the path, to be able to get
    the data from a specific order, defined as the `/orders/{orderId}` path, containing
    the order ID in the `{orderId}` placeholder. We also need to have the parameter
    defined in `parameters` , under the `in: path` flag. This is where we specify
    that `orderId` is a parameter to be received.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: In a successful case, an `OrderResponse` object will be returned containing
    the order itself with a `200 OK` HTTP status response. A `404 Not Found` HTTP
    status will be returned if there is no order with the given ID.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us have a look at the `PUT` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar to the `GET` method, with the `PUT` method, we are defining an operation
    to update a single order. Please note that we are demonstrating an approach different
    from that adopted when building the Product API, where we used the `PUT` method
    for creating entities. In the Order Management API, we use a separate `POST` method
    (without an ID in the request) for creating orders.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` is an idempotent method, meaning it can be called multiple times (with
    the same order ID) without affecting the result. On the other hand, `POST` is
    not idempotent, so every time you call it, it creates a new order in our service.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: For the `PUT` method, we receive the order ID in the path, defined in the `/orders/{orderId}`
    path, receiving the order ID through the `orderId` parameter defined in the list
    of parameters and `OrderRequestBody` , the same way as seen in the `POST` method,
    containing all the details of the order to be updated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In case of success, it will return a `200 OK` HTTP status code and `OrderResponse`
    containing the details of the persisted order. If the order is not found, `404
    Not Found` will be returned. In case of a wrong format in the request, `400 Bad
    Request` will be returned.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us see the `DELETE` method to cancel a specific order:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this method, we are required to pass a parameter named `orderId` , which
    is the ID of the order to be cancelled, the same way we did with the `GET` and
    `PUT` methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In case of success, a response HTTP status code of `204 No Content` will be
    returned to the caller because there is no response body. `404 Not Found` will
    be returned if there is no order with the specified ID.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Method for the /orders/{orderId}/status
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /orders/{orderId}/status 的方法
- en: 'Finally, let us have a look at the last defined endpoint path to change the
    status of the orders, with the `PATCH` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看最后一个定义的端点路径，使用 `PATCH` 方法来更改订单的状态：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The goal of this endpoint is to update the status of an order. In a real-world
    production environment, the status of an order depends on external circumstances
    defined by other services in business logic, for example, the payment approval
    validated by a payment provider, availability of the items in a warehouse, or
    even fraud detection; it’s important to have a way to change the status of the
    orders with external calls, and this endpoint is specifically to accomplish this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点的目标是更新订单的状态。在现实世界的生产环境中，订单的状态取决于由其他服务在业务逻辑中定义的外部情况，例如，由支付提供商验证的支付批准、仓库中物品的可用性，甚至欺诈检测；有一个方法来通过外部调用更改订单的状态是很重要的，而这个端点正是为了完成这个任务。
- en: Note that the body of this request is being defined by reference, using `$ref`
    , to the `OrderStatus` schema that will be defined in the next section. This exemplifies
    the reusability of the specification-first design, where you define a reusable
    schema that can be referenced across multiple path definitions, parameters, and
    endpoints in the OpenAPI schema definition file, eliminating the need to repeat
    any definitions. The next section covers this topic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此请求的正文是通过引用来定义的，使用 `$ref` 指向下一节将要定义的 `OrderStatus` 架构。这展示了规范优先设计的可重用性，其中你定义一个可重用的架构，可以在
    OpenAPI 架构定义文件中的多个路径定义、参数和端点中引用，从而消除重复定义的需要。下一节将涵盖这个主题。
- en: Now, we are going to define the schemas used as a body for the requests and
    responses and as params in the operations we have just finished defining.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义用于请求和响应正文以及作为我们刚刚定义的操作参数的架构。
- en: Defining the API schemas
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 API 架构
- en: Now that we have finished defining the paths that identify the resources of
    our API, we are going to define the schemas that we use in the operations defined
    in the previous section. The schemas describe the structure of the request and
    response bodies for those operations and can also be used as parameters in the
    operations as seen before.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了定义识别我们 API 资源路径的路径，我们将定义我们在上一节中定义的操作中使用的架构。这些架构描述了这些操作的请求和响应正文的结构，也可以像之前看到的那样用作操作的参数。
- en: '![Figure 4.1: Entity-Relationship diagram from the defined API schema](img/B21843_04_1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：从定义的 API 架构生成的实体-关系图](img/B21843_04_1.png)'
- en: 'Figure 4.1: Entity-Relationship diagram from the defined API schema'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：从定义的 API 架构生成的实体-关系图
- en: In the preceding diagram, you can see the relationship between the entities
    that will be created later by extending from the schema definitions we are about
    to write and generate – that is why they differ in the name definition. This way,
    you can have the whole entity structure defined from the OpenAPI schema, reinforcing
    the API-first principle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到将要由我们即将编写的架构定义扩展而创建的实体之间的关系。这就是为什么它们在名称定义上有所不同。这样，你可以从 OpenAPI 架构中定义整个实体结构，从而加强
    API 优先原则。
- en: Schema definitions are located under the `components` section of the OpenAPI
    specification.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 架构定义位于 OpenAPI 规范的 `components` 部分下。
- en: 'OpenAPI schemas use a language that supports defining complex structures of
    JSON data and the relationships between the structures. The schemas are entries
    inside the `schemas` section, with the first ones being `Product` and `Customer`
    :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 架构使用一种支持定义 JSON 数据的复杂结构和结构之间关系的语言。架构位于 `schemas` 部分的条目中，首先是 `Product`
    和 `Customer`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Product` is the simplest schema in our specification. It just defines that
    its type is a JSON object with two properties: `productSKU` of type `string` ,
    which will be the ID for our products, and `quantity` of type `integer` , which
    will represent the availability of this product.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 是我们规范中最简单的架构。它仅仅定义了其类型是一个具有两个属性的 JSON 对象：`productSKU` 类型为 `string`，它将成为我们产品的
    ID，以及 `quantity` 类型为 `integer`，它将表示该产品的可用性。'
- en: 'Moving to the `Customer` schema, it is an object containing four properties:
    `customerType` , `streetAddress` , `city` , and `postalCode` . All the properties
    are of type `string` . But here, we also start to introduce the concept of inheritance
    and polymorphism.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `Customer` schema will serve as a parent (base) schema, which will be extended
    by two other schemas— `PersonCustomer` and `CompanyCustomer` —that we will introduce
    later. This setup demonstrates inheritance, with one parent and two child schemas,
    and polymorphism, allowing `Customer` to represent either `PersonCustomer` or
    a `CompanyCustomer` .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `discriminator` property comes into play. The `discriminator`
    property is used by the JSON parser to indicate which of the child schemas it
    is inheriting from when it tries to deserialize the JSON data into the generated
    object while loading from JSON and converting it into an object in runtime. In
    our case, the discriminator will be the `customerType` property. This property
    will define whether `Customer` will be of type `PersonCustomer` or type `CompanyCustomer`
    .
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: This property is used when you place an order, as part of the `POST` request
    body that we previously defined. With the discriminator, a single endpoint can
    accept two different bodies, one with `Customer` of type `PersonCustomer` for
    individual customers, and another one with `Customer` of type `CompanyCustomer`
    for companies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us define the child schemas, `PersonCustomer` and `CompanyCustomer`
    , and relate them to the parent `Customer` schema:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both schema definitions look similar; both of them use the `allOf` keyword that
    refers to the `Customer` schema. It defines that the child schema should contain
    (inherit) all the properties of the `Customer` schema.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Since we have implemented hierarchy in our specification, let us briefly look
    at how to create new orders in this structure, using the `OrderRequestBody` that
    will be used for `POST` and `PUT` methods to create and update resources in the
    application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – OrderRequestBody schema in OpenAPI Swagger UI](img/B21843_04_2.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – OrderRequestBody schema in OpenAPI Swagger UI
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` method expects `OrderRequestBody` in the body of the request. Since
    we have used `discriminator` in the definition, here we will need to select one
    of the bodies in the request, as specified by `oneOf->` in the preceding figure:
    `PersonCustomer` , `CompanyCustomer` , or `Customer` . The value for the `customerType`
    field needs to be one of `person` , `company` , or `customer` to match one of
    the bodies defined. The usage of `Customer` alone is discouraged since it does
    not benefit from the hierarchy and the polymorphism, but it is important to know
    that you can use it alone too without the extra fields from `PersonCustomer` or
    `CompanyCustomer` if needed.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can add the corresponding fields of each of these, so if it is a company,
    you will have fields such as `vatId` and `companyName` in your request body, and
    if it is a person, you will have fields such as `firstName` and `lastName` in
    your request. The fields mentioned in the `Customer` specification are common
    to both types of customers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以添加这些每个对应的字段，所以如果是一个公司，你将在请求体中拥有`vatId`和`companyName`等字段，如果是个人，你将在请求中拥有`firstName`和`lastName`等字段。在`Customer`规范中提到的字段对两种客户类型都是通用的。
- en: 'To finish the schema section of our API specification, we will define the request
    and response bodies used by the Order Management API:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们API规范中的模式部分，我们将定义由订单管理API使用的请求和响应体：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `OrderRequestBody` object definition, there are two properties – one
    that is of the `Customer` type defined above, using `$ref` to refer to its definition,
    and the `products` property, which is a JSON array that will represent a list
    of `Product` JSON objects within `OrderRequestBody` .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OrderRequestBody`对象定义中，有两个属性——一个是上面定义的`Customer`类型，使用`$ref`来引用其定义，以及`products`属性，它是一个JSON数组，将在`OrderRequestBody`中表示一个`Product`
    JSON对象的列表。
- en: 'In the response schema definition, `OrderResponse` contains an array of `Product`
    JSON objects, containing every product for a particular order, the `customer`
    property that references the `Customer` schema and returns the customer data for
    this order, the `orderCreatedDate` and `orderUpdatedDate` properties with the
    date and time of the order creation and update if any, and the `status` property
    that references the `OrderStatus` defined, which references the `Status` `enum`
    , containing all the possible statuses for an order: `Pending` , `Approved` ,
    or `Cancelled` . Since we can reuse these definitions anywhere around the specification,
    the `OrderStatus` schema is also referenced in the order change status endpoint
    as the request body definition for allowed values in the request.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应模式定义中，`OrderResponse`包含一个`Product` JSON对象的数组，包含特定订单的每个产品，`customer`属性引用`Customer`模式并返回此订单的客户数据，`orderCreatedDate`和`orderUpdatedDate`属性包含订单创建和更新的日期和时间（如果有），以及`status`属性，它引用定义的`OrderStatus`，该`OrderStatus`引用`Status`
    `enum`，包含订单的所有可能状态：`Pending`、`Approved`或`Cancelled`。由于我们可以在规范中的任何地方重用这些定义，因此`OrderStatus`模式也在订单状态更改端点作为请求体定义中引用，以允许请求中的值。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Sharing schemas across APIs
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在API之间共享模式
- en: With Java and other programming languages, we are used to defining reusable
    libraries to avoid repeating the same code in multiple projects. OpenAPI specifications
    can also refer to external files, so it is possible to share common parts among
    multiple APIs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java和其他编程语言，我们习惯于定义可重用的库以避免在多个项目中重复相同的代码。OpenAPI规范也可以引用外部文件，因此可以在多个API之间共享公共部分。
- en: However, you should be aware that this approach creates coupling among the APIs.
    In case the common part changes, it can lead to unexpected inconsistencies. So,
    it is advisable to try to keep the individual API specifications self-contained.
    If you want to reuse schemas, you should ensure that they are very stable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该意识到这种方法会在API之间创建耦合。如果公共部分发生变化，可能会导致意外的不一致。因此，建议尽量保持单个API规范的自包含。如果你想要重用模式，你应该确保它们非常稳定。
- en: One such example could be the structure used for reporting errors. But in our
    example APIs, we use the `ProblemDetail` schema based on the RFC 7807 internet
    standard. This way, we avoid maintaining the shared schema.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的一个例子可能是用于报告错误的结构。但在我们的示例API中，我们使用基于RFC 7807互联网标准的`ProblemDetail`模式。这样，我们避免了维护共享模式。
- en: Defining security schemes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义安全方案
- en: 'Besides schemas, the components section of the OpenAPI specification can be
    used to specify security-related requirements for our API. Here, we will specify
    the authentication mechanism to use: OpenID Connect with JWT. You will learn more
    about security in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176) .'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模式之外，OpenAPI规范的组件部分也可以用来指定我们API的安全相关要求。在这里，我们将指定要使用的身份验证机制：OpenID Connect配合JWT。你将在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中了解更多关于安全的信息。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `securitySchemes` defines a security scheme named `JWTAuth` and applies
    it globally to all operations in the API. Here is a breakdown of its components
    and their implications:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`securitySchemes`定义了一个名为`JWTAuth`的安全方案，并将其全局应用于API中的所有操作。以下是其组件及其影响的分析：'
- en: '`JWTAuth` : This is the identifier for the security scheme'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JWTAuth`：这是安全方案的标识符。'
- en: '`type: http` : This specifies that the security scheme is HTTP-based'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: http`：这指定了安全方案是基于HTTP的。'
- en: '`scheme: bearer` : This indicates that the scheme uses bearer tokens'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheme: bearer`：这表示该方案使用携带令牌。'
- en: '`bearerFormat: JWT` : This specifies that the bearer tokens are in JWT format'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bearerFormat: JWT`：这指定了携带令牌的格式为JWT。'
- en: 'With all that defined, we can move away from the `components` keyword and get
    to know our last keyword in this definition, the `security` keyword:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有这些之后，我们可以从`components`关键字移开，了解这个定义中的最后一个关键字，即`security`关键字：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This security definition is at the root level, and it indicates that there are
    no specific scopes or permissions required within the JWT for accessing the API.
    So, a valid JWT must be provided in the Authorization header for all API calls,
    but the token itself does n ot need to specify any particular scopes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个安全定义处于根级别，它表明在JWT中访问API不需要特定的作用域或权限。因此，所有API调用都必须在授权头中提供有效的JWT，但令牌本身不需要指定任何特定的作用域。
- en: If you prefer not to use JWTs for authentication, you can consider using session
    state IDs as an alternative. They were widely used before the advent of JWTs,
    which replaced session state IDs for many reasons.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用JWT进行认证，可以考虑使用会话状态ID作为替代方案。在JWT出现之前，它们被广泛使用，并且由于许多原因，JWT取代了会话状态ID。
- en: 'Before looking at how to use session state IDs, let us see the key reasons
    that JWTs became the preferred authentication method for microservices:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看如何使用会话状态ID之前，让我们看看JWT成为微服务首选认证方法的关键原因：
- en: '**Statelessness** : JWTs are stateless, meaning they do not require the server
    to maintain session state. This is beneficial for microservices, which are designed
    to be stateless and scalable.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：JWT是无状态的，这意味着它们不需要服务器维护会话状态。这对微服务有益，因为微服务被设计成无状态和可扩展的。'
- en: '**Scalability** : Since JWTs are self-contained and do not require server-side
    storage, they are more scalable in distributed systems compared to session state
    IDs, which require centralized session storage.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：由于JWT是自包含的，并且不需要服务器端存储，与需要集中式会话存储的会话状态ID相比，它们在分布式系统中具有更高的可扩展性。'
- en: '**Decentralized authentication** : JWTs can be verified by any service that
    has a public key, allowing for decentralized authentication across multiple microservices
    without the need for a central session store.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化认证**：JWT可以被任何拥有公钥的服务验证，允许在多个微服务之间进行去中心化认证，而无需中央会话存储。'
- en: '**Interoperability** : JWTs are a standard (RFC 7519) and are widely supported
    across different platforms and languages, making them suitable for heterogeneous
    microservice environments.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：JWT是一个标准（RFC 7519），并且在不同的平台和语言中得到广泛支持，这使得它们适合异构微服务环境。'
- en: '**Security** : JWTs can be signed and optionally encrypted, providing integrity
    and confidentiality. They can also include claims that provide additional context
    about the user or the session.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：JWT可以进行签名和可选加密，提供完整性和机密性。它们还可以包含提供有关用户或会话的额外上下文的声明。'
- en: But for specific circumstances, which could be dealing with legacy services
    and integrations with already existing services that make use of session state
    IDs, this approach may be necessary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但在特定情况下，例如处理遗留服务和与已使用会话状态ID的现有服务的集成时，这种方法可能是必要的。
- en: Session state IDs involve maintaining a session on the server side, where each
    session is identified by a unique session ID. This session ID is stored on the
    client side, typically in a cookie, and sent with each request to the server.
    The server then validates the session ID and retrieves the associated session
    data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态ID涉及在服务器端维护会话，其中每个会话由一个唯一的会话ID标识。这个会话ID存储在客户端，通常在cookie中，并随每个请求发送到服务器。然后服务器验证会话ID并检索相关的会话数据。
- en: Some of the advantages of session state IDs are that the server has full control
    over the session, including the ability to invalidate sessions at any time and
    there is no need to handle token expiration and renewal as with JWT.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态ID的一些优点是服务器对会话拥有完全控制权，包括在任何时候使会话失效的能力，并且与JWT相比，无需处理令牌过期和续订。
- en: On the other hand, it requires maintaining session state on the server, which
    can be challenging in a distributed environment, and, unlike JWT, which is stateless,
    session state IDs require the server to maintain state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you can define session state IDs in your OpenAPI
    schema:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the `SessionIDAuth` security scheme specifies that the session
    ID will be sent in a cookie named `SESSIONID` . The server will then validate
    this session ID to authenticate the user.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We will not be covering session state IDs in our services since they break the
    stateless goal of a RESTful microservice and having JWTs with all the advantages
    explained above, but it is good to know how you can use them with the specification-first
    approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Also, as mentioned before, we will go into the security subject in more depth
    in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176) .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have our specification completed. You can save your file with
    a name that represents your API, ending with the `.yml` extension (short for YAML).
    In our example, the file will be named `Order_Management_API.yml` .
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, you can see the complete file in the GitHub repository
    at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to generate code from this specification, using `openapi-generator-maven-plugin`
    . Let us find out how.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Generating code from the specification
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to generate code from a specification, the application needs to be
    prepared for it. In this section, you will configure a plugin and generate code
    from what we have specified in the specification file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The following XML fragment configures `openapi-generator-maven-plugin` for our
    Maven project, specifically designed to generate Spring-based Java code from the
    OpenAPI specification defined in the previous section. This plugin facilitates
    the automatic creation of API endpoints, models, and configuration classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to configure the plugin in the `pom.xml` file inside our project.
    You can refer to the GitHub repository to see the full file, but here we will
    focus on the specific changes to accomplish our goals. Let us look at this configuration
    now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a breakdown of its key components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugin identification** : `groupId` and `artifactId` identify the plugin
    within the Maven ecosystem:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Plugin version** : Specifies the version of the plugin to use, ensuring compatibility
    and access to specific features available in this version:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Execution configuration** : The `executions` block defines when and how the
    plugin should run. The goal named `generate` triggers the code generation process:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Specification input** : The `inputSpec` configuration points to the OpenAPI
    specification file. This path is relative to the project’s base directory, indicating
    where the plugin should look for the API definition elaborated in the previous
    section:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Generator configuration** : The `generatorName` specifies that the generated
    code should be tailored for Spring, influencing the structure and annotations
    used in the output:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Package names** : The `apiPackage` and `modelPackage` configurations define
    the Java package names for generated API interfaces (API operations) and model
    classes (data structures), respectively. This helps in organizing the generated
    code within the project structure. Also, having a suffix added by `modelNameSuffix`
    helps to have the DTOs generated with this suffix in the name:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Additional options** : The `configOptions` section provides further customization
    of the generated code. Let us briefly describe each of the options we are using
    here and their functionality:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`documentationProvider` : This specifies the documentation provider to use.
    In this case, `springdoc` is used to generate API documentation.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interfaceOnly` : When set to `true` , only interfaces for the API are generated,
    without any implementation.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oas3` : This indicates that the OpenAPI 3.0 specification is being used.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openApiNullable` : When set to `false` , the generator will not use the `@Nullable`
    annotation for optional fields.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serializableModel` : When set to `true` , the generated models will implement
    the `Serializable` interface.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useBeanValidation` : When set to `true` , the generated models will include
    annotations for bean validation (e.g., `@NotNull` , `@Size` ).'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useSpringBoot3` : When set to `true` , the generator will produce code compatible
    with Spring Boot 3.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useTags` : When set to `true` , the generator will use tags defined in the
    OpenAPI specification to group API operations.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With that, we have covered every aspect of the configuration of the plugin in
    our `pom.xml` file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us execute the build and have the implementation generated:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If your build was successful, you will note that you have the DTOs and an interface
    generated in your target folder.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Implementation generated in the target folder](img/B21843_04_3.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Implementation generated in the target folder
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use IntelliJ IDEA, switch to the **Packages** view, so you can see the
    generated sources along with the structure of the project and work seamlessly
    with the generated sources and your own implementation, as seen in the following
    screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Implementation generated along with the project structure](img/B21843_04_4.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Implementation generated along with the project structure
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: By generating the code in the `target` folder, we clearly separate it from the
    manually written code in the `src` folder. The generated code should not be stored
    in a version control system (Git or another) to avoid inconsistencies with the
    source specification it should be generated from. Instead, fresh code is generated
    during every Maven build.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the results in the generated `PersonCustomerDto` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we can see that for every field that was specified in the specification
    schema, a Java class field was generated accordingly, including the relationships
    with other schemas, such as the inheritance from the `Customer` schema, proving
    that we can also model object-oriented programming concepts using the API-first
    approach if we define the relationships in the specification file properly. The
    other classes look similar, each one generated according to its own schema definition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the implementation of the operations listed in the API
    specification, let us see what our API paths and methods were translated to. For
    example, let us see the `DELETE` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see that the generated default implementation code does nothing;
    it only returns a response entity with the status `NOT_IMPLEMENTED` . If we tried
    to invoke the API with this default code, the client would see a `501 Not Implemented`
    HTTP status.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation is expected to be overridden by the actual implementation.
    The path, its parameters, and responses are already defined and documented. The
    API documentation of the running API application is accessible using the Swagger
    UI interface or by downloading the OpenAPI JSON definition through the auto-generated
    `/v3/api-docs` path, like with the code-first API we developed in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Just keep in mind that you will need to add the `springdoc-openapi-starter-webmvc-ui`
    dependency into your `pom.xml` file to be able to use the Swagger UI graphical
    interface. Please refer to the GitHub repository of *Chapter 4* to get the full
    list of dependencies needed to run the project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This is what makes the specification-first approach handy, since after the design
    is defined, developers can focus on the implementation while consumers can start
    the integration with the system even before the actual development is finished.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Now that our specification is generated, let us have an overview of the package
    structure of this service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Package structure of the Order Management API
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a look at what our package structure looks like for the Order Management
    API:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Package structure of implemented Order Management API](img/B21843_04_5.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Package structure of implemented Order Management API
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that the Order Management API follows the same architectural
    approach as described in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050) , following
    the principles of clean architecture. Let us look at the contained packages:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`adapter` : This package contains the four following packages:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception` : This contains all class exceptions and exception handlers'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inbound.rest` : This is responsible for handling all the inputs, transformations,
    and generated data from the specification'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapper` : This contains all the mapper transformations between objects, such
    as `toOrderRequest` from `OrderRequestBodyDto` , and the custom-defined mappers.'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound` : This package contains all elements that interact with external
    services, such as databases and other services. In this service, we will have
    two subpackages within it:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound.database` : This contains all the elements that will interact with
    the database itself, the implementation of use cases that contain operations such
    as `createOrder` and `updateOrderStatus` , and the repositories also go here.
    It contains an internal package within it.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound.database.entity` : This contains all the defined entities for the
    service that declares the tables and interacts with the database.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound.rest` : This package contains all the elements required to interact
    with external services through REST calls. In this service, we have the elements
    required to interact with the Product API, created in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain` : This package contains the POJOs that define the base structure for
    each domain contained by this service. Its structure will be inherited mostly
    by the entities, but they are not the entities themselves (those are defined in
    the `adapter.outbound.database.entity` package), so it contains POJOs from the
    `Order` , `Customer` (also `PersonCustomer` and `CompanyCustomer` ), and `Product`
    definitions, along with the `StatusEnum` definitions as well.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usecase` : This contains the interface definitions for the use cases, containing
    the actions that will be implemented. In this service, we have two use cases:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersCommandUseCase` : This contains the definitions of actions like `createOrder`
    and `updateOrder` that are implemented by the class `OrdersCommandUseCaseImpl`
    in the `adapter.outbound.database`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersQueryUseCase` : This contains the definition of the actions that happen
    with the database through queries and is implemented by `OrdersQueryUseCaseImpl`
    in the `adapter.inbound.rest` package.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are aware of the package structure of the service, let us jump into
    the implementation of the controller itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Order Management API controller
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Order Management API will follow the same architecture and package structure
    used in the Product API, so the controllers will be created within the `adapter.inbound.rest`
    package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create the `OrderManagementApiController` class, implementing
    the methods of the `OrderManagementApi` interface. Here is a sample of the code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, there is no concrete implementation yet, but we are
    defining the methods that were specified previously in our specification file
    and generated in the `OrderManagementApi` interface. If we keep the `super` calls
    (invoking the default implementation of the parent interface), the server returns
    a `501 Not Implemented` HTTP status code to the caller. It can be useful when
    you want to deploy your application partially to let the users know that this
    feature is not yet available.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: All the definitions in the OpenAPI specification file serve as documentation
    for the API. If you paste the specification into the online [editor.swagger.io](https://www.editor.swagger.io)
    tool or run the application and open the Swagger UI with your browser at the URL
    [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)
    , you will be able to see every operation and schema defined until now. This documentation
    represents the API contract, describing all the available resources, methods available
    to interact with them, and what data the API is expected to receive and return.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Swagger UI from the Order Management API specification](img/B21843_04_6.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Swagger UI from the Order Management API specification
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: This is the first step toward a concrete implementation of the operations defined
    in our API specification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we are not going to look at every step of the implementation
    process here, since the goal of this chapter is to show you how to have the code
    generated from the specification, as we saw in the previous sections. Feel free
    to refer to the source code in the GitHub repository for *Chapter 4* to have a
    deeper understanding of the implementation details, since this goes much deeper
    than what we are going to describe in this section alone.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the controller looks like after being implemented:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Looking at the implementation of the controller, we can notice some similar
    patterns as were implemented in the Product API, especially the usage of use cases
    and mappers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: But unlike the Product API, here we override the generated code of the `OpenManagementAPI`
    interface where all the paths and operations are defined. Unlike the code-first
    approach, the documentation that has been already defined previously in the OpenAPI
    specification does not need to be repeated manually here, since it is contained
    within the generated `OpenManagementAPI` . This is the power of a specification-first
    (API-first) implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In this controller, we are injecting three main interfaces that are used for
    the processing of all the business logic, persistence, and data layer transformation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '`OrdersCommandUseCase`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersQueryUseCase`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderMapper`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first focus on the use case implementations of this service, which are
    `OrdersCommandUseCase` and `OrdersQueryUseCase` , and their purpose within the
    Order Management API, starting with `OrdersCommandUseCaseImpl` .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OrdersCommandUseCase
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start by implementing `OrdersCommandUseCase` with the `OrdersCommandUseCaseImpl`
    class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As described earlier in the package structure, the `OrdersCommandUseCaseImpl`
    class contains the business logic of the service itself, the actions, and interactions
    with other components such as the repository and mapper, and even other services
    such as the Product API, as we will see in detail in the *Communicating with the
    Product API* section. That is why this class is annotated with the `@Service`
    annotation from Spring, indicating that it is a `Service` stereotype of Bean.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OrdersQueryUseCase
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Moving to the implementation of `OrdersQueryUseCase` , we will have `OrdersQueryUseCaseImpl`
    :'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `OrdersQueryUseCaseImpl` , we have a much smaller implementation, since here
    the focus is the interaction with the database. Any custom queries or requests
    that you would have just go into this class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OrderMapper with MapStruct
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And finally, there’s the `OrderMapper` interface. Unlike the use case classes,
    we do not implement any class here; instead, we define an interface with the mappings
    we want to have in our project. Since this project uses MapStruct for object mapping,
    we define the mapping within this interface and any custom mappings separately.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: '**MapStruct**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: MapStruct is a code generator that simplifies the process of mapping between
    Java bean types by relying on a convention-over-configuration strategy. That is
    why we are defining this interface; it contains the configuration that MapStruct
    needs to generate the mapping code. Also, we are going to define a custom mapping
    for the cases when the basic generated mapping code is not enough.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with the interface definition:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is what the `OrderMapper` interface looks like. We are defining the mapping
    operations that we want MapStruct to perform, such as the `toOrderRequest` operation,
    which is a mapping from an `OrderRequestBodyDto` object to an `OrderRequest` object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Simple mapping with `Mapstruct` is straightforward, but when things get complicated,
    there is a need to introduce a custom mapping implementation for it. This is where
    the `CustomerCustomMapper` class gets into our mapping definition.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: To have a custom mapping used with MapStruct, you need to create a custom mapping
    class and tell the interface to use it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are adding the `CustomerCustomMapper` class in the `uses` property
    within the `@Mapper` annotation at the class level. This way, MapStruct knows
    that there is a custom implementation mapper that it needs to refer to.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows for partial or complete object mapping, depending on your
    requirements. In this case, we will perform partial mapping by using parts of
    the generated mapping from MapStruct and applying custom mapping to handle a specific
    complex object that the simple mapping cannot handle correctly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: For every mapping operation, such as `toOrder` , `toOrderRequest` , and `toOrderResponse`
    , if you have a custom mapping that changes the default mapping behavior from
    MapStruct, you need to specify it with the `@Mapping` annotation at the method
    level to tell MapStruct that you have a custom mapping.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In our custom mapping example, both `target` and `source` properties specify
    that the `customer` property within the received parameter ( `orderRequestBody`
    in the `toOrderRequest` method and `order` in the `toOrderResponse` method) is
    going to be mapped in a custom way that needs to refer to the custom mapper implementation
    that is implemented by the `CustomerCustomMapper` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `qualifiedByName` property tells MapStruct which method to refer
    to for the mapping into the custom mapper, being identified by the `@Named` annotation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complexity and polymorphism introduced to have distinct types of
    customers with inheritance, this custom map was needed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us look at this custom mapping specification:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since this is a MapStruct component, it is annotated `@Component` so it can
    be created as a Bean in the Spring context and made available to be detected by
    the mapping generator during the build process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: But the key aspect of it is the `@Named` method-level annotation, as mentioned
    earlier. It specifies the unique qualifier mentioned in the `qualifiedByName`
    MapStruct interface we just saw. The `customer` object is the only object being
    custom-mapped in the `CustomerCustomMapper` implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, when you generate your project using MapStruct, it will generate
    the mappings as specified in the `OrderMapper` interface, but it will call this
    custom-mapping implementation, as we can see in the generated code snippet in
    the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Generated mapping to OrderRequest calling customer custom mapping](img/B21843_04_7.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Generated mapping to OrderRequest calling customer custom mapping
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: You can find the generated code from the preceding screenshot in the `OrderMapperImpl`
    generated class after building your project under the `target` folder, within
    the `classes` folder, in the `mapper` package, where the `OrderMapper` interface
    and the `CustomerCustomMapper` class are also defined. But if you are using the
    **Packages** view in IntelliJ, the generated classes will be shown to you automatically
    in the `mapper` package with your own implemented classes, as seen before in this
    chapter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at how the Order Management API can communicate with the Product
    API to validate the products in the received orders.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Product API
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To validate whether the products of an order exist, the Order Management API
    validates the inserted product SKUs against the Product API through an API call
    either when a new order is created or when an order update contains an insertion
    of a new product into the order.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In real-world production applications, the Product API may need to validate
    whether there are enough products available in stock to be added to the order
    and respond properly if there are not. For our purposes of demonstrating how to
    create APIs, we will show how to validate whether the products of an order exist
    within Product API service data and retrieve their prices to be added to our order.
    If a product is not found, the Order Management API will return a proper message
    with a `404 Not Found` HTTP status code and the error message `Product not found`
    , explaining that the order cannot be placed because that product does not exist
    and needs to be created in the Product API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: To make this call, we will generate the client from the Product API specification.
    Since this chapter is about generating code, why not generate the client to retrieve
    the data from the Product API itself?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: You saw in the previous section, in the `OrdersCommandUseCaseImpl` implementation,
    the `updateProductPrice` method. This private method makes use of `productsQueryUseCase.getProductById`
    to retrieve the data of the product with the generated client and calculate the
    total value of the order based on the products it contains.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: To have this client generated, we will need to update our generator plugin,
    adding the Product API specification to it, and generating a new build.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with updating the OpenAPI generator plugin. We will be adding
    a second execution to it, below the first execution created at the beginning of
    this chapter. This is what it looks like:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The configuration here is similar to what we did in the first generator using
    the Order Management API specification, in the *Generating code from the specification*
    section, but now we will point to the Product API specification instead. There
    are only a few differences that we will detail now and, as we did for the first
    generator, let us go through each of the items to have them detailed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '`<execution>` : This defines a specific execution of the plugin. Each execution
    can have its own configuration and goals. Here, we are adding a new one.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<id>` : This is a unique identifier for this execution. In this case, it is
    `generate-client` . In the previous execution, we used `generate-server` as the
    ID.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<goals>` : This specifies the goals to be executed. Here, the goal is `generate`
    , which triggers the code generation process.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<configuration>` : This contains the configuration options for this execution.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<inputSpec>` : This specifies the path to the OpenAPI specification file.
    Here, it is `${project.basedir}/src/main/resources/Product_API.json` , which is
    where the Product API specification is contained within this service. The specification
    is in the JSON format that we could download using the Product API Swagger UI.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<generatorName>` : This defines the generator to use. In this case, it is
    `java` , indicating that Java client code will be generated.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<library>` : This specifies the library to use for the generated code. Here,
    it is `restclient` , which generates a REST client.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<apiPackage>` : This defines the package for the generated API classes. Here,
    it is `com.packt.ordermanagementapi.adapter.outbound.rest` .'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<modelPackage>` : This defines the package for the generated model classes.
    Here, it is `com.packt.ordermanagementapi.adapter.outbound.rest.dto` .'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<modelNameSuffix>` : This adds a suffix to the names of the generated model
    classes. Here, it is `Dto` .'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<generateApiTests>` : When set to `false` , API test classes will not be generated.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<generateModelTests>` : When set to `false` , model test classes will not
    be generated.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<configOptions>` : This contains additional configuration options for the
    generator.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<interfaceOnly>` : When set to `true` , only interfaces for the API are generated,
    without any implementation.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<useJakartaEe>` : When set to `true` , the generated code will use Jakarta
    EE instead of Java EE.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<openApiNullable>` : When set to `false` , the generator will not use the
    `@Nullable` annotation for optional fields.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having our plugin configured and pointing to the Product API specification,
    we can proceed to generate a new build that will generate the REST client from
    the specification, along with the DTOs needed for it. Again, we will run the Maven
    command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After a successful build, this will generate the DTOs and the API classes into
    the specified packages that were configured in the plugin, as you can see in the
    following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Generated Product API client and DTO classes](img/B21843_04_8.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Generated Product API client and DTO classes
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: This approach is extremely powerful since we already have the specification
    of the service that our API is going to consume. This can save hours of development
    time just by having the code and the client generated quickly for you.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: You could think of an alternative solution where the client code would be generated
    as a module by the service providing the (Product) API and a client interested
    in consuming the API would just use the code as a library in the form of a JAR
    file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This may look like making the life of the consumer implementers even easier,
    but it has serious drawbacks. It would force the consumer to be compatible with
    the library (and a particular version of it) used inside the JAR file. It would
    not support non-Java consumers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of microservices architecture is the loose coupling between
    the services. Depending on JAR files to consume APIs of different microservices
    creates unwanted coupling and defeats the purpose of making the application distributed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'If you noticed when we looked at the `OrdersCommandUseCaseImpl` class in the
    previous section, there was a private method that uses this generated Product
    API client called `updateProductPrice` . Let us look at how it works and how to
    make the best use of it inside the Order Management API:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `productsQueryUseCase` is injected into `OrdersCommandUseCaseImpl` , where
    all related calls to the external Product API are handled. Within the `updateProductPrice`
    method, the `getProductById` method from `ProductsQueryUseCase` is called for
    each product in the order request, passing the unique product identifier (product
    SKU) to retrieve the product details.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to validate whether these products exist in the Product API and
    get their value to be added to the total of the order.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: If the product is found, it will be returned and attributed to the `ProductDetails`
    variable named `catalogueProduct` , and the price of the individual product will
    be set in the products list.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: If any of the products in the order are not found in the Products API, `404
    Not Found` will be returned from this external API call and will be caught by
    the `GlobalExceptionHandler` of the application, interrupting the order creation.
    This is the expected behavior since we do not want to allow any order to be created
    with a product that does not exist.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about the code generated by the plugin and how the REST client
    was built, we encourage you to generate your own code to see it in action following
    these steps. You can also always refer to the chapter code in the official repository
    of this book at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the main differences between specification-first,
    (API-first), and code-first development. We developed an OpenAPI specification
    from scratch in detail, going through each part of its structure, creating paths
    and methods with parameters, defining schemas for generating the DTOs to use in
    the requests, responses, and as parameters, and defining a security scheme.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Then we configured the Order Management API service with the OpenAPI code generator
    plugin for Maven and looked at each necessary parameter to have the code generated
    properly as expected and ran a successful build using the OpenAPI plugin.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: After that, we started to look at the generated code, where it is located, and
    how to see it along with your own code implementation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We went through an overview of the architectural package structure for the project
    and the objective of each package in the structure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implemented our controller, using the generated interface from the
    specification, initially by overriding the methods and then by creating a real
    working implementation with all the features expected for this service, with a
    deep dive into the code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to expand our code generator by adding a new execution
    into the OpenAPI plugin and generated a REST client to call the Product API.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We used the generated Product API client to call and validate the products in
    the creation or update flow of an order, checking whether it exists in the Product
    API and computing the total of the order. If any product is not found, it just
    aborts the creation or update of the order.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will get to know more about some advanced API concepts
    – how to handle timeouts, retries, and more – that could be used in a scenario
    where the Product API is unavailable at a certain request of the Order Management
    API, and how to handle it properly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
