- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating Code with OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start the development of a completely new API called
    Order Management that will interact with the Product API developed in [*Chapter
    2*](B21843_02.xhtml#_idTextAnchor050) and evolved in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, the Product API was developed following the *code-first*
    approach, wherein the API was implemented before the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will adopt a *specification-first* approach, also known
    as API-first, wherein we will have the specification of the whole API done first,
    and then have the API implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we will build the OpenAPI specification for the Order Management API,
    declaring the paths, methods, and request and response schemas (some of them using
    polymorphism) for it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will use OpenAPI tools to generate Java code stubs from the API specification.
    This generated code speeds up the implementation process, reduces manual maintenance
    of boilerplate code, and, most importantly, makes it easier to maintain consistency
    between the API specification and the service implementation for future changes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go through the package structure of the service and the code implementation
    bullet points for the build of this API, delivering it in a ready-to-work state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will look into establishing communication between the Order Management
    and Product APIs to validate the products that will be registered in the orders
    created in this service, by calling an external API and responding accordingly
    to the received condition.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have built all the knowledge you need to
    get started with the design, development, and integration of specification-first
    APIs to greatly empower you and speed up your design and development phases in
    an unbelievable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Specification of the Order Management API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code from the specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package structure of the Order Management API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Order Management API controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with the Product API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement an example Order Management API. To be able
    to follow along and use the code examples as they are printed in the book, you
    should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of the Java language and platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least a basic knowledge of Spring Boot or a similar framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 21 and Maven 3.9.0 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to apply API-first REST principles to create our
    API; you can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Order Management API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will develop the specification of the operations and data
    structures of the Order Management API. The Order Management API, as part of the
    project we are building over the course of this book, will handle the orders of
    products managed by the Product API.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous chapter, *specification-first* means an abstract
    API specification is created before the actual implementation of the API. Instead
    of starting with executable code in a programming language, you begin by defining
    the structure, behavior, and functionality of the API. That is why this is also
    known as API-first development.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015) , we visited many key principles
    that should be considered when designing RESTful APIs. Let us look at how to apply
    those principles with the API-first approach.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HTTP principles in API-first development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When adopting an API-first approach, it is crucial to think in HTTP terms right
    from the design phase. Let us look at some of the principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define API contracts first** : Use tools such as OpenAPI/Swagger to define
    your API structure, including endpoints, request/response formats, and data models.
    This contract serves as a blueprint for developers and helps ensure consistency
    and clarity. We are going to build an API contract with an OpenAPI specification
    file for the Order Management API in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent use of HTTP methods and status codes** : Follow conventions for
    HTTP methods and status codes, as seen in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    . For example, use `GET` for retrieving resources, `POST` for creating, `PUT`
    for updating, and `DELETE` for removing resources. Use appropriate status codes
    to communicate the result of the request. These should also be described in the
    specification file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emphasize resource modeling** : Focus on accurately modeling your domain
    as resources. This involves identifying key entities and their relationships,
    identifying them by URLs that can be accessed using HTTP methods. For example,
    in our Order Management API, resources are `Customers` , `Products` , and `Orders`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan for versioning** : Implement versioning strategies to handle API evolution.
    This can be done through URL path versioning (e.g., `/v2/books` ) and standard
    or custom request headers. Versioning supports backward compatibility and smooth
    transitions as the API grows and changes. This will be defined in the Common API
    metadata of our specification file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consider security** : Define authentication and authorization mechanisms,
    such as OAuth, API keys, or JSON Web Tokens (JWTs), to secure your API. We will
    briefly look at how to add a security scheme to our specification, and you will
    learn how to implement it in depth in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a clearer picture of the principles we aim to achieve with
    this definition, let us start writing into the specification itself.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the OpenAPI specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write the Order Management API specification using the YAML syntax.
    You can use any editor of your personal preference to follow along: you can use
    the online Swagger Editor available at [https://editor.swagger.io/](https://editor.swagger.io/)
    , or if you work using IDEs such as JetBrains IntelliJ or Microsoft VS Code, you
    can use plugins to get a similar experience to the Swagger website and validate
    your specification while writing it inside your IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: The full specification that we will create is available on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let us begin the specification file by defining the API’s common metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Common API metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by defining the top-level context of the specification with the
    metadata about the API, defining the title, the description, and the version of
    the API. Also, here we describe the servers where the application will be running.
    In our case, since we want to run it locally, we will use `localhost` for testing
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Order Management API paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This API will have three paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/orders` with the `POST` and `GET` methods for creating and retrieving orders,
    respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/orders/{orderId}` with the `GET` , `PUT` , and `DELETE` methods for accessing,
    editing, and removing specific orders, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/orders/{orderId}/status` with the `PATCH` method to change the status of
    an existing order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods for the /orders path
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let us start by defining the `POST` method with its request and response. Remember,
    the `$ref` notation is used to refer to the schema definitions in a separate section
    of the specification document. This allows the schemas to be reused, and the `paths`
    section to be shorter and more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this `POST` definition, we are defining that when the controller receives
    a `POST` request with the `/orders` path, the request should contain a body as
    specified in the `OrderRequestBody` schema definition. If everything goes well,
    the API will respond with the `201 Created` HTTP status code, with the body defined
    in the `OrderResponse` schema. If the request body does not match `OrderRequestBody`
    , the API will respond with a `400 Bad Request` HTTP response code. We are going
    to define the request and response bodies later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to help the OpenAPI generator name the classes that will be generated
    from our specification, we are specifying a tag in each method operation. In this
    case, the tag will be named `OrderManagement` . If we omit the tag, the generated
    class will be named `DefaultApi` . We will cover this in detail in the *Generating
    code from the specification* section when we have configured the generator and
    start generating code from the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the `GET` method for the `/orders` path endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a `GET` method and, when called, it returns the list of orders, if any,
    with HTTP status `200` , and with an array of objects of type `OrderResponse`
    that contains all the orders in the system. If there are none, the returned list
    will be empty still with HTTP status `200` , meaning that the request was successfully
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: We will also specify an endpoint to retrieve a single order from the system
    in the next path.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for the /orders/{orderId} path
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, we are going to define another path to access specific orders, and we
    will define a `GET` , a `PUT` , and a `DELETE` method for this path, starting
    with the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GET` method, we are defining a path to retrieve data from a single
    order. Here, we are receiving a single parameter in the path, to be able to get
    the data from a specific order, defined as the `/orders/{orderId}` path, containing
    the order ID in the `{orderId}` placeholder. We also need to have the parameter
    defined in `parameters` , under the `in: path` flag. This is where we specify
    that `orderId` is a parameter to be received.'
  prefs: []
  type: TYPE_NORMAL
- en: In a successful case, an `OrderResponse` object will be returned containing
    the order itself with a `200 OK` HTTP status response. A `404 Not Found` HTTP
    status will be returned if there is no order with the given ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us have a look at the `PUT` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `GET` method, with the `PUT` method, we are defining an operation
    to update a single order. Please note that we are demonstrating an approach different
    from that adopted when building the Product API, where we used the `PUT` method
    for creating entities. In the Order Management API, we use a separate `POST` method
    (without an ID in the request) for creating orders.
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` is an idempotent method, meaning it can be called multiple times (with
    the same order ID) without affecting the result. On the other hand, `POST` is
    not idempotent, so every time you call it, it creates a new order in our service.'
  prefs: []
  type: TYPE_NORMAL
- en: For the `PUT` method, we receive the order ID in the path, defined in the `/orders/{orderId}`
    path, receiving the order ID through the `orderId` parameter defined in the list
    of parameters and `OrderRequestBody` , the same way as seen in the `POST` method,
    containing all the details of the order to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: In case of success, it will return a `200 OK` HTTP status code and `OrderResponse`
    containing the details of the persisted order. If the order is not found, `404
    Not Found` will be returned. In case of a wrong format in the request, `400 Bad
    Request` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us see the `DELETE` method to cancel a specific order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we are required to pass a parameter named `orderId` , which
    is the ID of the order to be cancelled, the same way we did with the `GET` and
    `PUT` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In case of success, a response HTTP status code of `204 No Content` will be
    returned to the caller because there is no response body. `404 Not Found` will
    be returned if there is no order with the specified ID.
  prefs: []
  type: TYPE_NORMAL
- en: Method for the /orders/{orderId}/status
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, let us have a look at the last defined endpoint path to change the
    status of the orders, with the `PATCH` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this endpoint is to update the status of an order. In a real-world
    production environment, the status of an order depends on external circumstances
    defined by other services in business logic, for example, the payment approval
    validated by a payment provider, availability of the items in a warehouse, or
    even fraud detection; it’s important to have a way to change the status of the
    orders with external calls, and this endpoint is specifically to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the body of this request is being defined by reference, using `$ref`
    , to the `OrderStatus` schema that will be defined in the next section. This exemplifies
    the reusability of the specification-first design, where you define a reusable
    schema that can be referenced across multiple path definitions, parameters, and
    endpoints in the OpenAPI schema definition file, eliminating the need to repeat
    any definitions. The next section covers this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to define the schemas used as a body for the requests and
    responses and as params in the operations we have just finished defining.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the API schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have finished defining the paths that identify the resources of
    our API, we are going to define the schemas that we use in the operations defined
    in the previous section. The schemas describe the structure of the request and
    response bodies for those operations and can also be used as parameters in the
    operations as seen before.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Entity-Relationship diagram from the defined API schema](img/B21843_04_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Entity-Relationship diagram from the defined API schema'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see the relationship between the entities
    that will be created later by extending from the schema definitions we are about
    to write and generate – that is why they differ in the name definition. This way,
    you can have the whole entity structure defined from the OpenAPI schema, reinforcing
    the API-first principle.
  prefs: []
  type: TYPE_NORMAL
- en: Schema definitions are located under the `components` section of the OpenAPI
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenAPI schemas use a language that supports defining complex structures of
    JSON data and the relationships between the structures. The schemas are entries
    inside the `schemas` section, with the first ones being `Product` and `Customer`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Product` is the simplest schema in our specification. It just defines that
    its type is a JSON object with two properties: `productSKU` of type `string` ,
    which will be the ID for our products, and `quantity` of type `integer` , which
    will represent the availability of this product.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving to the `Customer` schema, it is an object containing four properties:
    `customerType` , `streetAddress` , `city` , and `postalCode` . All the properties
    are of type `string` . But here, we also start to introduce the concept of inheritance
    and polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Customer` schema will serve as a parent (base) schema, which will be extended
    by two other schemas— `PersonCustomer` and `CompanyCustomer` —that we will introduce
    later. This setup demonstrates inheritance, with one parent and two child schemas,
    and polymorphism, allowing `Customer` to represent either `PersonCustomer` or
    a `CompanyCustomer` .
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `discriminator` property comes into play. The `discriminator`
    property is used by the JSON parser to indicate which of the child schemas it
    is inheriting from when it tries to deserialize the JSON data into the generated
    object while loading from JSON and converting it into an object in runtime. In
    our case, the discriminator will be the `customerType` property. This property
    will define whether `Customer` will be of type `PersonCustomer` or type `CompanyCustomer`
    .
  prefs: []
  type: TYPE_NORMAL
- en: This property is used when you place an order, as part of the `POST` request
    body that we previously defined. With the discriminator, a single endpoint can
    accept two different bodies, one with `Customer` of type `PersonCustomer` for
    individual customers, and another one with `Customer` of type `CompanyCustomer`
    for companies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us define the child schemas, `PersonCustomer` and `CompanyCustomer`
    , and relate them to the parent `Customer` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both schema definitions look similar; both of them use the `allOf` keyword that
    refers to the `Customer` schema. It defines that the child schema should contain
    (inherit) all the properties of the `Customer` schema.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have implemented hierarchy in our specification, let us briefly look
    at how to create new orders in this structure, using the `OrderRequestBody` that
    will be used for `POST` and `PUT` methods to create and update resources in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – OrderRequestBody schema in OpenAPI Swagger UI](img/B21843_04_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – OrderRequestBody schema in OpenAPI Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` method expects `OrderRequestBody` in the body of the request. Since
    we have used `discriminator` in the definition, here we will need to select one
    of the bodies in the request, as specified by `oneOf->` in the preceding figure:
    `PersonCustomer` , `CompanyCustomer` , or `Customer` . The value for the `customerType`
    field needs to be one of `person` , `company` , or `customer` to match one of
    the bodies defined. The usage of `Customer` alone is discouraged since it does
    not benefit from the hierarchy and the polymorphism, but it is important to know
    that you can use it alone too without the extra fields from `PersonCustomer` or
    `CompanyCustomer` if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can add the corresponding fields of each of these, so if it is a company,
    you will have fields such as `vatId` and `companyName` in your request body, and
    if it is a person, you will have fields such as `firstName` and `lastName` in
    your request. The fields mentioned in the `Customer` specification are common
    to both types of customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the schema section of our API specification, we will define the request
    and response bodies used by the Order Management API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `OrderRequestBody` object definition, there are two properties – one
    that is of the `Customer` type defined above, using `$ref` to refer to its definition,
    and the `products` property, which is a JSON array that will represent a list
    of `Product` JSON objects within `OrderRequestBody` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the response schema definition, `OrderResponse` contains an array of `Product`
    JSON objects, containing every product for a particular order, the `customer`
    property that references the `Customer` schema and returns the customer data for
    this order, the `orderCreatedDate` and `orderUpdatedDate` properties with the
    date and time of the order creation and update if any, and the `status` property
    that references the `OrderStatus` defined, which references the `Status` `enum`
    , containing all the possible statuses for an order: `Pending` , `Approved` ,
    or `Cancelled` . Since we can reuse these definitions anywhere around the specification,
    the `OrderStatus` schema is also referenced in the order change status endpoint
    as the request body definition for allowed values in the request.'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: Sharing schemas across APIs
  prefs: []
  type: TYPE_NORMAL
- en: With Java and other programming languages, we are used to defining reusable
    libraries to avoid repeating the same code in multiple projects. OpenAPI specifications
    can also refer to external files, so it is possible to share common parts among
    multiple APIs.
  prefs: []
  type: TYPE_NORMAL
- en: However, you should be aware that this approach creates coupling among the APIs.
    In case the common part changes, it can lead to unexpected inconsistencies. So,
    it is advisable to try to keep the individual API specifications self-contained.
    If you want to reuse schemas, you should ensure that they are very stable.
  prefs: []
  type: TYPE_NORMAL
- en: One such example could be the structure used for reporting errors. But in our
    example APIs, we use the `ProblemDetail` schema based on the RFC 7807 internet
    standard. This way, we avoid maintaining the shared schema.
  prefs: []
  type: TYPE_NORMAL
- en: Defining security schemes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides schemas, the components section of the OpenAPI specification can be
    used to specify security-related requirements for our API. Here, we will specify
    the authentication mechanism to use: OpenID Connect with JWT. You will learn more
    about security in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176) .'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `securitySchemes` defines a security scheme named `JWTAuth` and applies
    it globally to all operations in the API. Here is a breakdown of its components
    and their implications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JWTAuth` : This is the identifier for the security scheme'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: http` : This specifies that the security scheme is HTTP-based'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheme: bearer` : This indicates that the scheme uses bearer tokens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bearerFormat: JWT` : This specifies that the bearer tokens are in JWT format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all that defined, we can move away from the `components` keyword and get
    to know our last keyword in this definition, the `security` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This security definition is at the root level, and it indicates that there are
    no specific scopes or permissions required within the JWT for accessing the API.
    So, a valid JWT must be provided in the Authorization header for all API calls,
    but the token itself does n ot need to specify any particular scopes.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer not to use JWTs for authentication, you can consider using session
    state IDs as an alternative. They were widely used before the advent of JWTs,
    which replaced session state IDs for many reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking at how to use session state IDs, let us see the key reasons
    that JWTs became the preferred authentication method for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statelessness** : JWTs are stateless, meaning they do not require the server
    to maintain session state. This is beneficial for microservices, which are designed
    to be stateless and scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : Since JWTs are self-contained and do not require server-side
    storage, they are more scalable in distributed systems compared to session state
    IDs, which require centralized session storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralized authentication** : JWTs can be verified by any service that
    has a public key, allowing for decentralized authentication across multiple microservices
    without the need for a central session store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability** : JWTs are a standard (RFC 7519) and are widely supported
    across different platforms and languages, making them suitable for heterogeneous
    microservice environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : JWTs can be signed and optionally encrypted, providing integrity
    and confidentiality. They can also include claims that provide additional context
    about the user or the session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But for specific circumstances, which could be dealing with legacy services
    and integrations with already existing services that make use of session state
    IDs, this approach may be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Session state IDs involve maintaining a session on the server side, where each
    session is identified by a unique session ID. This session ID is stored on the
    client side, typically in a cookie, and sent with each request to the server.
    The server then validates the session ID and retrieves the associated session
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the advantages of session state IDs are that the server has full control
    over the session, including the ability to invalidate sessions at any time and
    there is no need to handle token expiration and renewal as with JWT.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it requires maintaining session state on the server, which
    can be challenging in a distributed environment, and, unlike JWT, which is stateless,
    session state IDs require the server to maintain state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you can define session state IDs in your OpenAPI
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `SessionIDAuth` security scheme specifies that the session
    ID will be sent in a cookie named `SESSIONID` . The server will then validate
    this session ID to authenticate the user.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be covering session state IDs in our services since they break the
    stateless goal of a RESTful microservice and having JWTs with all the advantages
    explained above, but it is good to know how you can use them with the specification-first
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as mentioned before, we will go into the security subject in more depth
    in [*Chapter 7*](B21843_07.xhtml#_idTextAnchor176) .
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have our specification completed. You can save your file with
    a name that represents your API, ending with the `.yml` extension (short for YAML).
    In our example, the file will be named `Order_Management_API.yml` .
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, you can see the complete file in the GitHub repository
    at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to generate code from this specification, using `openapi-generator-maven-plugin`
    . Let us find out how.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code from the specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to generate code from a specification, the application needs to be
    prepared for it. In this section, you will configure a plugin and generate code
    from what we have specified in the specification file.
  prefs: []
  type: TYPE_NORMAL
- en: The following XML fragment configures `openapi-generator-maven-plugin` for our
    Maven project, specifically designed to generate Spring-based Java code from the
    OpenAPI specification defined in the previous section. This plugin facilitates
    the automatic creation of API endpoints, models, and configuration classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to configure the plugin in the `pom.xml` file inside our project.
    You can refer to the GitHub repository to see the full file, but here we will
    focus on the specific changes to accomplish our goals. Let us look at this configuration
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown of its key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugin identification** : `groupId` and `artifactId` identify the plugin
    within the Maven ecosystem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Plugin version** : Specifies the version of the plugin to use, ensuring compatibility
    and access to specific features available in this version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Execution configuration** : The `executions` block defines when and how the
    plugin should run. The goal named `generate` triggers the code generation process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Specification input** : The `inputSpec` configuration points to the OpenAPI
    specification file. This path is relative to the project’s base directory, indicating
    where the plugin should look for the API definition elaborated in the previous
    section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Generator configuration** : The `generatorName` specifies that the generated
    code should be tailored for Spring, influencing the structure and annotations
    used in the output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Package names** : The `apiPackage` and `modelPackage` configurations define
    the Java package names for generated API interfaces (API operations) and model
    classes (data structures), respectively. This helps in organizing the generated
    code within the project structure. Also, having a suffix added by `modelNameSuffix`
    helps to have the DTOs generated with this suffix in the name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Additional options** : The `configOptions` section provides further customization
    of the generated code. Let us briefly describe each of the options we are using
    here and their functionality:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`documentationProvider` : This specifies the documentation provider to use.
    In this case, `springdoc` is used to generate API documentation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interfaceOnly` : When set to `true` , only interfaces for the API are generated,
    without any implementation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oas3` : This indicates that the OpenAPI 3.0 specification is being used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openApiNullable` : When set to `false` , the generator will not use the `@Nullable`
    annotation for optional fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serializableModel` : When set to `true` , the generated models will implement
    the `Serializable` interface.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useBeanValidation` : When set to `true` , the generated models will include
    annotations for bean validation (e.g., `@NotNull` , `@Size` ).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useSpringBoot3` : When set to `true` , the generator will produce code compatible
    with Spring Boot 3.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useTags` : When set to `true` , the generator will use tags defined in the
    OpenAPI specification to group API operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have covered every aspect of the configuration of the plugin in
    our `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us execute the build and have the implementation generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If your build was successful, you will note that you have the DTOs and an interface
    generated in your target folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Implementation generated in the target folder](img/B21843_04_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Implementation generated in the target folder
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use IntelliJ IDEA, switch to the **Packages** view, so you can see the
    generated sources along with the structure of the project and work seamlessly
    with the generated sources and your own implementation, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Implementation generated along with the project structure](img/B21843_04_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Implementation generated along with the project structure
  prefs: []
  type: TYPE_NORMAL
- en: By generating the code in the `target` folder, we clearly separate it from the
    manually written code in the `src` folder. The generated code should not be stored
    in a version control system (Git or another) to avoid inconsistencies with the
    source specification it should be generated from. Instead, fresh code is generated
    during every Maven build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the results in the generated `PersonCustomerDto` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that for every field that was specified in the specification
    schema, a Java class field was generated accordingly, including the relationships
    with other schemas, such as the inheritance from the `Customer` schema, proving
    that we can also model object-oriented programming concepts using the API-first
    approach if we define the relationships in the specification file properly. The
    other classes look similar, each one generated according to its own schema definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the implementation of the operations listed in the API
    specification, let us see what our API paths and methods were translated to. For
    example, let us see the `DELETE` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the generated default implementation code does nothing;
    it only returns a response entity with the status `NOT_IMPLEMENTED` . If we tried
    to invoke the API with this default code, the client would see a `501 Not Implemented`
    HTTP status.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation is expected to be overridden by the actual implementation.
    The path, its parameters, and responses are already defined and documented. The
    API documentation of the running API application is accessible using the Swagger
    UI interface or by downloading the OpenAPI JSON definition through the auto-generated
    `/v3/api-docs` path, like with the code-first API we developed in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Just keep in mind that you will need to add the `springdoc-openapi-starter-webmvc-ui`
    dependency into your `pom.xml` file to be able to use the Swagger UI graphical
    interface. Please refer to the GitHub repository of *Chapter 4* to get the full
    list of dependencies needed to run the project.
  prefs: []
  type: TYPE_NORMAL
- en: This is what makes the specification-first approach handy, since after the design
    is defined, developers can focus on the implementation while consumers can start
    the integration with the system even before the actual development is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our specification is generated, let us have an overview of the package
    structure of this service.
  prefs: []
  type: TYPE_NORMAL
- en: Package structure of the Order Management API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a look at what our package structure looks like for the Order Management
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Package structure of implemented Order Management API](img/B21843_04_5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Package structure of implemented Order Management API
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that the Order Management API follows the same architectural
    approach as described in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050) , following
    the principles of clean architecture. Let us look at the contained packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`adapter` : This package contains the four following packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception` : This contains all class exceptions and exception handlers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inbound.rest` : This is responsible for handling all the inputs, transformations,
    and generated data from the specification'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapper` : This contains all the mapper transformations between objects, such
    as `toOrderRequest` from `OrderRequestBodyDto` , and the custom-defined mappers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound` : This package contains all elements that interact with external
    services, such as databases and other services. In this service, we will have
    two subpackages within it:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound.database` : This contains all the elements that will interact with
    the database itself, the implementation of use cases that contain operations such
    as `createOrder` and `updateOrderStatus` , and the repositories also go here.
    It contains an internal package within it.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound.database.entity` : This contains all the defined entities for the
    service that declares the tables and interacts with the database.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outbound.rest` : This package contains all the elements required to interact
    with external services through REST calls. In this service, we have the elements
    required to interact with the Product API, created in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain` : This package contains the POJOs that define the base structure for
    each domain contained by this service. Its structure will be inherited mostly
    by the entities, but they are not the entities themselves (those are defined in
    the `adapter.outbound.database.entity` package), so it contains POJOs from the
    `Order` , `Customer` (also `PersonCustomer` and `CompanyCustomer` ), and `Product`
    definitions, along with the `StatusEnum` definitions as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usecase` : This contains the interface definitions for the use cases, containing
    the actions that will be implemented. In this service, we have two use cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersCommandUseCase` : This contains the definitions of actions like `createOrder`
    and `updateOrder` that are implemented by the class `OrdersCommandUseCaseImpl`
    in the `adapter.outbound.database`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersQueryUseCase` : This contains the definition of the actions that happen
    with the database through queries and is implemented by `OrdersQueryUseCaseImpl`
    in the `adapter.inbound.rest` package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are aware of the package structure of the service, let us jump into
    the implementation of the controller itself.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Order Management API controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Order Management API will follow the same architecture and package structure
    used in the Product API, so the controllers will be created within the `adapter.inbound.rest`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create the `OrderManagementApiController` class, implementing
    the methods of the `OrderManagementApi` interface. Here is a sample of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, there is no concrete implementation yet, but we are
    defining the methods that were specified previously in our specification file
    and generated in the `OrderManagementApi` interface. If we keep the `super` calls
    (invoking the default implementation of the parent interface), the server returns
    a `501 Not Implemented` HTTP status code to the caller. It can be useful when
    you want to deploy your application partially to let the users know that this
    feature is not yet available.
  prefs: []
  type: TYPE_NORMAL
- en: All the definitions in the OpenAPI specification file serve as documentation
    for the API. If you paste the specification into the online [editor.swagger.io](https://www.editor.swagger.io)
    tool or run the application and open the Swagger UI with your browser at the URL
    [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)
    , you will be able to see every operation and schema defined until now. This documentation
    represents the API contract, describing all the available resources, methods available
    to interact with them, and what data the API is expected to receive and return.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Swagger UI from the Order Management API specification](img/B21843_04_6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Swagger UI from the Order Management API specification
  prefs: []
  type: TYPE_NORMAL
- en: This is the first step toward a concrete implementation of the operations defined
    in our API specification.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we are not going to look at every step of the implementation
    process here, since the goal of this chapter is to show you how to have the code
    generated from the specification, as we saw in the previous sections. Feel free
    to refer to the source code in the GitHub repository for *Chapter 4* to have a
    deeper understanding of the implementation details, since this goes much deeper
    than what we are going to describe in this section alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the controller looks like after being implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the implementation of the controller, we can notice some similar
    patterns as were implemented in the Product API, especially the usage of use cases
    and mappers.
  prefs: []
  type: TYPE_NORMAL
- en: But unlike the Product API, here we override the generated code of the `OpenManagementAPI`
    interface where all the paths and operations are defined. Unlike the code-first
    approach, the documentation that has been already defined previously in the OpenAPI
    specification does not need to be repeated manually here, since it is contained
    within the generated `OpenManagementAPI` . This is the power of a specification-first
    (API-first) implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this controller, we are injecting three main interfaces that are used for
    the processing of all the business logic, persistence, and data layer transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrdersCommandUseCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersQueryUseCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderMapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us first focus on the use case implementations of this service, which are
    `OrdersCommandUseCase` and `OrdersQueryUseCase` , and their purpose within the
    Order Management API, starting with `OrdersCommandUseCaseImpl` .
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OrdersCommandUseCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start by implementing `OrdersCommandUseCase` with the `OrdersCommandUseCaseImpl`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As described earlier in the package structure, the `OrdersCommandUseCaseImpl`
    class contains the business logic of the service itself, the actions, and interactions
    with other components such as the repository and mapper, and even other services
    such as the Product API, as we will see in detail in the *Communicating with the
    Product API* section. That is why this class is annotated with the `@Service`
    annotation from Spring, indicating that it is a `Service` stereotype of Bean.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OrdersQueryUseCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Moving to the implementation of `OrdersQueryUseCase` , we will have `OrdersQueryUseCaseImpl`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In `OrdersQueryUseCaseImpl` , we have a much smaller implementation, since here
    the focus is the interaction with the database. Any custom queries or requests
    that you would have just go into this class.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OrderMapper with MapStruct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And finally, there’s the `OrderMapper` interface. Unlike the use case classes,
    we do not implement any class here; instead, we define an interface with the mappings
    we want to have in our project. Since this project uses MapStruct for object mapping,
    we define the mapping within this interface and any custom mappings separately.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: '**MapStruct**'
  prefs: []
  type: TYPE_NORMAL
- en: MapStruct is a code generator that simplifies the process of mapping between
    Java bean types by relying on a convention-over-configuration strategy. That is
    why we are defining this interface; it contains the configuration that MapStruct
    needs to generate the mapping code. Also, we are going to define a custom mapping
    for the cases when the basic generated mapping code is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with the interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is what the `OrderMapper` interface looks like. We are defining the mapping
    operations that we want MapStruct to perform, such as the `toOrderRequest` operation,
    which is a mapping from an `OrderRequestBodyDto` object to an `OrderRequest` object.
  prefs: []
  type: TYPE_NORMAL
- en: Simple mapping with `Mapstruct` is straightforward, but when things get complicated,
    there is a need to introduce a custom mapping implementation for it. This is where
    the `CustomerCustomMapper` class gets into our mapping definition.
  prefs: []
  type: TYPE_NORMAL
- en: To have a custom mapping used with MapStruct, you need to create a custom mapping
    class and tell the interface to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are adding the `CustomerCustomMapper` class in the `uses` property
    within the `@Mapper` annotation at the class level. This way, MapStruct knows
    that there is a custom implementation mapper that it needs to refer to.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows for partial or complete object mapping, depending on your
    requirements. In this case, we will perform partial mapping by using parts of
    the generated mapping from MapStruct and applying custom mapping to handle a specific
    complex object that the simple mapping cannot handle correctly.
  prefs: []
  type: TYPE_NORMAL
- en: For every mapping operation, such as `toOrder` , `toOrderRequest` , and `toOrderResponse`
    , if you have a custom mapping that changes the default mapping behavior from
    MapStruct, you need to specify it with the `@Mapping` annotation at the method
    level to tell MapStruct that you have a custom mapping.
  prefs: []
  type: TYPE_NORMAL
- en: In our custom mapping example, both `target` and `source` properties specify
    that the `customer` property within the received parameter ( `orderRequestBody`
    in the `toOrderRequest` method and `order` in the `toOrderResponse` method) is
    going to be mapped in a custom way that needs to refer to the custom mapper implementation
    that is implemented by the `CustomerCustomMapper` class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `qualifiedByName` property tells MapStruct which method to refer
    to for the mapping into the custom mapper, being identified by the `@Named` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complexity and polymorphism introduced to have distinct types of
    customers with inheritance, this custom map was needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us look at this custom mapping specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a MapStruct component, it is annotated `@Component` so it can
    be created as a Bean in the Spring context and made available to be detected by
    the mapping generator during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: But the key aspect of it is the `@Named` method-level annotation, as mentioned
    earlier. It specifies the unique qualifier mentioned in the `qualifiedByName`
    MapStruct interface we just saw. The `customer` object is the only object being
    custom-mapped in the `CustomerCustomMapper` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, when you generate your project using MapStruct, it will generate
    the mappings as specified in the `OrderMapper` interface, but it will call this
    custom-mapping implementation, as we can see in the generated code snippet in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Generated mapping to OrderRequest calling customer custom mapping](img/B21843_04_7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Generated mapping to OrderRequest calling customer custom mapping
  prefs: []
  type: TYPE_NORMAL
- en: You can find the generated code from the preceding screenshot in the `OrderMapperImpl`
    generated class after building your project under the `target` folder, within
    the `classes` folder, in the `mapper` package, where the `OrderMapper` interface
    and the `CustomerCustomMapper` class are also defined. But if you are using the
    **Packages** view in IntelliJ, the generated classes will be shown to you automatically
    in the `mapper` package with your own implemented classes, as seen before in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at how the Order Management API can communicate with the Product
    API to validate the products in the received orders.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Product API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To validate whether the products of an order exist, the Order Management API
    validates the inserted product SKUs against the Product API through an API call
    either when a new order is created or when an order update contains an insertion
    of a new product into the order.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world production applications, the Product API may need to validate
    whether there are enough products available in stock to be added to the order
    and respond properly if there are not. For our purposes of demonstrating how to
    create APIs, we will show how to validate whether the products of an order exist
    within Product API service data and retrieve their prices to be added to our order.
    If a product is not found, the Order Management API will return a proper message
    with a `404 Not Found` HTTP status code and the error message `Product not found`
    , explaining that the order cannot be placed because that product does not exist
    and needs to be created in the Product API.
  prefs: []
  type: TYPE_NORMAL
- en: To make this call, we will generate the client from the Product API specification.
    Since this chapter is about generating code, why not generate the client to retrieve
    the data from the Product API itself?
  prefs: []
  type: TYPE_NORMAL
- en: You saw in the previous section, in the `OrdersCommandUseCaseImpl` implementation,
    the `updateProductPrice` method. This private method makes use of `productsQueryUseCase.getProductById`
    to retrieve the data of the product with the generated client and calculate the
    total value of the order based on the products it contains.
  prefs: []
  type: TYPE_NORMAL
- en: To have this client generated, we will need to update our generator plugin,
    adding the Product API specification to it, and generating a new build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with updating the OpenAPI generator plugin. We will be adding
    a second execution to it, below the first execution created at the beginning of
    this chapter. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration here is similar to what we did in the first generator using
    the Order Management API specification, in the *Generating code from the specification*
    section, but now we will point to the Product API specification instead. There
    are only a few differences that we will detail now and, as we did for the first
    generator, let us go through each of the items to have them detailed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<execution>` : This defines a specific execution of the plugin. Each execution
    can have its own configuration and goals. Here, we are adding a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<id>` : This is a unique identifier for this execution. In this case, it is
    `generate-client` . In the previous execution, we used `generate-server` as the
    ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<goals>` : This specifies the goals to be executed. Here, the goal is `generate`
    , which triggers the code generation process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<configuration>` : This contains the configuration options for this execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<inputSpec>` : This specifies the path to the OpenAPI specification file.
    Here, it is `${project.basedir}/src/main/resources/Product_API.json` , which is
    where the Product API specification is contained within this service. The specification
    is in the JSON format that we could download using the Product API Swagger UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<generatorName>` : This defines the generator to use. In this case, it is
    `java` , indicating that Java client code will be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<library>` : This specifies the library to use for the generated code. Here,
    it is `restclient` , which generates a REST client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<apiPackage>` : This defines the package for the generated API classes. Here,
    it is `com.packt.ordermanagementapi.adapter.outbound.rest` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<modelPackage>` : This defines the package for the generated model classes.
    Here, it is `com.packt.ordermanagementapi.adapter.outbound.rest.dto` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<modelNameSuffix>` : This adds a suffix to the names of the generated model
    classes. Here, it is `Dto` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<generateApiTests>` : When set to `false` , API test classes will not be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<generateModelTests>` : When set to `false` , model test classes will not
    be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<configOptions>` : This contains additional configuration options for the
    generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<interfaceOnly>` : When set to `true` , only interfaces for the API are generated,
    without any implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<useJakartaEe>` : When set to `true` , the generated code will use Jakarta
    EE instead of Java EE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<openApiNullable>` : When set to `false` , the generator will not use the
    `@Nullable` annotation for optional fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having our plugin configured and pointing to the Product API specification,
    we can proceed to generate a new build that will generate the REST client from
    the specification, along with the DTOs needed for it. Again, we will run the Maven
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful build, this will generate the DTOs and the API classes into
    the specified packages that were configured in the plugin, as you can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Generated Product API client and DTO classes](img/B21843_04_8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Generated Product API client and DTO classes
  prefs: []
  type: TYPE_NORMAL
- en: This approach is extremely powerful since we already have the specification
    of the service that our API is going to consume. This can save hours of development
    time just by having the code and the client generated quickly for you.
  prefs: []
  type: TYPE_NORMAL
- en: You could think of an alternative solution where the client code would be generated
    as a module by the service providing the (Product) API and a client interested
    in consuming the API would just use the code as a library in the form of a JAR
    file.
  prefs: []
  type: TYPE_NORMAL
- en: This may look like making the life of the consumer implementers even easier,
    but it has serious drawbacks. It would force the consumer to be compatible with
    the library (and a particular version of it) used inside the JAR file. It would
    not support non-Java consumers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of microservices architecture is the loose coupling between
    the services. Depending on JAR files to consume APIs of different microservices
    creates unwanted coupling and defeats the purpose of making the application distributed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you noticed when we looked at the `OrdersCommandUseCaseImpl` class in the
    previous section, there was a private method that uses this generated Product
    API client called `updateProductPrice` . Let us look at how it works and how to
    make the best use of it inside the Order Management API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `productsQueryUseCase` is injected into `OrdersCommandUseCaseImpl` , where
    all related calls to the external Product API are handled. Within the `updateProductPrice`
    method, the `getProductById` method from `ProductsQueryUseCase` is called for
    each product in the order request, passing the unique product identifier (product
    SKU) to retrieve the product details.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to validate whether these products exist in the Product API and
    get their value to be added to the total of the order.
  prefs: []
  type: TYPE_NORMAL
- en: If the product is found, it will be returned and attributed to the `ProductDetails`
    variable named `catalogueProduct` , and the price of the individual product will
    be set in the products list.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the products in the order are not found in the Products API, `404
    Not Found` will be returned from this external API call and will be caught by
    the `GlobalExceptionHandler` of the application, interrupting the order creation.
    This is the expected behavior since we do not want to allow any order to be created
    with a product that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about the code generated by the plugin and how the REST client
    was built, we encourage you to generate your own code to see it in action following
    these steps. You can also always refer to the chapter code in the official repository
    of this book at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the main differences between specification-first,
    (API-first), and code-first development. We developed an OpenAPI specification
    from scratch in detail, going through each part of its structure, creating paths
    and methods with parameters, defining schemas for generating the DTOs to use in
    the requests, responses, and as parameters, and defining a security scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Then we configured the Order Management API service with the OpenAPI code generator
    plugin for Maven and looked at each necessary parameter to have the code generated
    properly as expected and ran a successful build using the OpenAPI plugin.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we started to look at the generated code, where it is located, and
    how to see it along with your own code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We went through an overview of the architectural package structure for the project
    and the objective of each package in the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implemented our controller, using the generated interface from the
    specification, initially by overriding the methods and then by creating a real
    working implementation with all the features expected for this service, with a
    deep dive into the code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to expand our code generator by adding a new execution
    into the OpenAPI plugin and generated a REST client to call the Product API.
  prefs: []
  type: TYPE_NORMAL
- en: We used the generated Product API client to call and validate the products in
    the creation or update flow of an order, checking whether it exists in the Product
    API and computing the total of the order. If any product is not found, it just
    aborts the creation or update of the order.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will get to know more about some advanced API concepts
    – how to handle timeouts, retries, and more – that could be used in a scenario
    where the Product API is unavailable at a certain request of the Order Management
    API, and how to handle it properly.
  prefs: []
  type: TYPE_NORMAL
