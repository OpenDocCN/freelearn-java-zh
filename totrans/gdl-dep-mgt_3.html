<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Resolving Dependencies"><div class="titlepage" id="aid-MSDG2"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Resolving Dependencies</h1></div></div></div><p>In <a class="link" title="Chapter 1. Defining Dependencies" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <span class="emphasis"><em>Defining Dependencies</em></span>, you learned how to add dependencies to your projects. We have seen different ways of specifying dependencies, such as module or project dependencies. In the previous chapter, we explored how to define the repositories that host our dependencies. Gradle will use this information to do the actual dependency resolution. In this chapter, we will see how Gradle resolves dependencies.</p><p>Gradle has a different way of resolving version conflicts than other build tools, so we will take a good look at what happens when a dependency is resolved. We will see how we can customize the resolution process in Gradle so that we can have the exact dependencies we want and have reliable and repeatable builds.</p><div class="section" title="Understanding dependency resolution"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Understanding dependency resolution</h1></div></div></div><p>Gradle will use the <a id="id102" class="indexterm"/>information in the <code class="literal">repositories</code> and <code class="literal">dependencies</code> configuration blocks to gather and download all dependencies. This process is also called <span class="strong"><strong>dependency resolution</strong></span>. The following steps are taken by Gradle to resolve dependencies:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The module descriptor file for a dependency is searched in the defined repositories. The order of the repository definitions is used for searching. So, repositories defined before other repositories are searched first, and so on. If a POM or Ivy descriptor file is found, it is used. If no descriptor file is found, then the artifact file for the dependency is searched. If either the descriptor file or the artifact file is found, then Gradle knows this repository can be used to download the dependencies.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If a POM descriptor file is found with a parent POM descriptor file, then the parent POM is resolved by Gradle.</li><li class="listitem">A dynamic version, like <span class="emphasis"><em>4.1.+</em></span>, is resolved to the highest available static version in the repository. For example if the repository contains versions <span class="emphasis"><em>4.1.0</em></span> and <span class="emphasis"><em>4.1.1</em></span> then the <span class="emphasis"><em>4.1.1</em></span> version is used.</li></ul></div></li><li class="listitem">Gradle will determine which repository is the best to use based on the following criteria:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Module descriptor files, like POM and Ivy descriptor files, are preferred over artifact file only.</li><li class="listitem">Dependencies found in earlier repositories are preferred over later repositories.</li><li class="listitem">If a dynamic version like <span class="emphasis"><em>2.+</em></span> is used, than a higher static version is preferred over a lower static version.</li></ul></div></li><li class="listitem">The artifacts for the module dependency are downloaded from the repository that is chosen by Gradle. This means that artifacts are not downloaded from a different repository than where the descriptor file or artifact file for the defined dependency are found.</li></ol><div style="height:10px; width: 1px"/></div><p>If a dependency is defined with a static version, and Gradle finds a module descriptor file for this dependency in a repository, then the search for this dependency is complete, and other repositories will <a id="id103" class="indexterm"/>not be used for the search. The process cannot come up with a better repository candidate, so the dependency resolution is finished for the dependency.</p><div class="section" title="Configuring transitive dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Configuring transitive dependencies</h2></div></div></div><p>Most of the <a id="id104" class="indexterm"/>time dependencies in our project are also dependent on other libraries. So, the dependencies have dependencies of their own. These are so-called transitive dependencies. Gradle must be able to resolve the transitive dependencies as well.</p><p>In the following example <a id="id105" class="indexterm"/>build file, we define the <code class="literal">logback-classic</code> module dependency with the version <code class="literal">1.1.2</code> and the group name <code class="literal">ch.qos.logback</code>:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

dependencies {
  // Dependency definition for Logback classic
  // library, used as implementation for SLF4J API.
  compile 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>When we run the Gradle <code class="literal">dependencies</code> task, we can see that our defined dependency for <code class="literal">logback-classic</code> depends on <code class="literal">ch.qos.logback:logback-core:1.1.2</code> and <code class="literal">org.slf4j:slf4j-api:1.7.6</code>. The following code shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration compile</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>  +--- ch.qos.logback:logback-core:1.1.2</strong></span>
<span class="strong"><strong>  \--- org.slf4j:slf4j-api:1.</strong></span>
<span class="strong"><strong>7.6</strong></span>
</pre></div></div><div class="section" title="Disabling transitive dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Disabling transitive dependencies</h2></div></div></div><p>If we don't <a id="id106" class="indexterm"/>want to have transitive <a id="id107" class="indexterm"/>dependencies in our project, we must reconfigure the dependency or configuration. With Gradle, we have different ways to disable transitive behavior for dependencies. First, we can add a configuration closure to our dependency definition, use the <code class="literal">transitive</code> property, and set the value to <code class="literal">false</code>. By default, all dependencies are treated as transitive, as we saw in our example build file.</p><p>In the following example build file, we specify that we want to treat or use the <code class="literal">logback-classic</code> dependency as nontransitive:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

dependencies {
  // Dependency definition for Logback classic.
  compile 'ch.qos.logback:logback-classic:1.1.2', {
    // We don't want to have the transitive dependencies.
    transitive = false
  }
}</pre></div><p>If we run the <code class="literal">dependencies</code> task again, we can see in the output that the transitive dependencies are no longer resolved:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration compile</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
</pre></div><p>We can also disable <a id="id108" class="indexterm"/>transitive dependencies <a id="id109" class="indexterm"/>for a dependency configuration as a whole. So, this means that any dependencies defined with the configuration will not have transitive dependencies. Single dependencies within the configuration can use the <code class="literal">transitive</code> property in the configuration closure to enable transitive behavior again for that dependency. To accomplish this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we will disable transitive dependencies for the <code class="literal">compile</code> configuration in the next example build file:<div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  // Disable transitive dependencies for
  // all dependencies defined in this
  // configuration.
  // Configurations extended
  // from the compile configuration will not
  // inherit this transitive property value.
  compile.transitive = false
}

dependencies {
  // Dependency definition for Logback classic
  compile 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div></li><li class="listitem">Next, we will <a id="id110" class="indexterm"/>execute <a id="id111" class="indexterm"/>the <code class="literal">dependencies</code> task and see that transitive dependencies are no longer resolved:<div class="informalexample"><pre class="programlisting">$ gradle -q dependencies --configuration compile

------------------------------------------------------------
Root project
------------------------------------------------------------

compile - Compile classpath for source set 'main'.
\--- ch.qos.logback:logback-classic:1.1.2</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="Excluding transitive dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Excluding transitive dependencies</h2></div></div></div><p>We can also have <a id="id112" class="indexterm"/>more fine-grained control of transitive dependencies. We can exclude certain transitive dependencies in our dependency definition. This way, we can choose to use only certain transitive dependencies and leave others out. To define which transitive dependencies we want to exclude, we use <a id="id113" class="indexterm"/>the <code class="literal">exclude</code> method in the configuration closure of our dependency.</p><p>Let's see how we can include the <code class="literal">logback-core</code> transitive dependency but remove the <code class="literal">slf4j-api</code> dependency. We use the <code class="literal">exclude</code> method in the configuration closure. The <code class="literal">exclude</code> method takes <code class="literal">Map</code> as an argument with one or both of the keys: <code class="literal">module</code> and <code class="literal">group</code>. In the following build file, we include the <code class="literal">logback-core</code> transitive dependency:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

dependencies {
  // Dependency definition for Logback classic
  compile('ch.qos.logback:logback-classic:1.1.2') {
    // Exclude slf4j-api transitive dependency.
    exclude module: 'slf4j-api'
    // Alternative syntax:
    // Exclude all modules in the group org.slf4j:
    // exclude group: 'org.slf4j'
    // Or specify both group and module name:
    // exclude group: 'org.slf4j', module: 'slf4j-api'
  }
}</pre></div><p>We execute the <code class="literal">dependencies</code> task to see whether our configuration definition has the desired effect:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration compile</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    \--- ch.qos.logback:logback-core:1.1.2</strong></span>
</pre></div><p>Notice that in the output, the transitive dependency, <code class="literal">org.slf4j:slf4j-api:1.7.6</code>, is no longer part of our transitive dependencies.</p><p>We can also set exclude <a id="id114" class="indexterm"/>rules on a <a id="id115" class="indexterm"/>configuration in addition to a single dependency. The exclude rule on a configuration will be used for all dependencies defined within the configuration. In the next example Gradle build file, we will exclude the <code class="literal">slf4j-api</code> module from all dependencies in the <code class="literal">compile</code> configuration:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  compile {
    // Exclude slf4j-api transitive dependency.
    exclude module: 'slf4j-api'
    // Alternative syntax:
    // Exclude all modules in the group org.slf4j:
    // exclude group: 'org.slf4j'
    // Or specify both group and module name:
    // exclude group: 'org.slf4j', module: 'slf4j-api'
  }

  // To exclude a module and/or group from all configurations
  // we can use the all method:
  // all { exclude module: 'slf4j-api' }
}

dependencies {
  // Dependency definition for Logback classic.
  compile('ch.qos.logback:logback-classic:1.1.2')
}</pre></div><p>Any exclude rule that we add to either the configuration or the dependency is accessible again via the <code class="literal">excludeRules</code> property of the corresponding objects. We can use this to find out the <a id="id116" class="indexterm"/>configuration or dependency that is responsible for excluding a certain dependency. In the following example <a id="id117" class="indexterm"/>build file, we create a new task, <code class="literal">showExcludeRules</code>, where we loop through all configurations and dependencies and collect exclude rules. At the end of the task, we print all the information to standard output. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  compile {
    exclude module: 'slf4j-api'
  }
}

dependencies {
  compile('ch.qos.logback:logback-classic:1.1.2') {
    exclude group: 'ch.qos.logback', module: 'logback-core'
  }
}

task showExcludeRules {
  description 'Show exclude rules for configurations and dependencies'

  doFirst {
    // Store found exclude rules.
    def excludes = []

    // Go through all configurations to find exclude rules
    // defined at configuration level and at
    // dependency level for dependencies in the configuration.
    configurations.all.each { configuration -&gt;
      def configurationExcludes = configuration.excludeRules
      configurationExcludes.findAll().each { rule -&gt;
        // Add found excludeRule to excludes collection.
        excludes &lt;&lt; [type: 'container',
              id: configuration.name,
              excludes: rule]
      }

      def dependencies = configuration.allDependencies
      dependencies.all { dependency -&gt;
        def excludeRules = dependency.excludeRules

        excludeRules.findAll().each { rule -&gt;
          def dep = dependency
          def id = "${dep.group}:${dep.name}:${dep.version}"
          // Add found excludeRule to excludes collection.
          excludes &lt;&lt; [type: 'dependency', id: id, excludes: rule]
        }
      }
    }

    // Printing exclude rule information for output.
    def printExcludeRule = {
      def rule = "${it.excludes.group ?: '*'}:${it.excludes.module ?: '*'}"
      println "$it.id &gt;&gt; $rule"
    }

    // Print formatted header for output.
    def printHeader = { header -&gt;
      println()
      println '-' * 60
      println header
      println '-' * 60
    }

    // Group rules by organisation or dependency.
    def excludeRules = excludes.groupBy { it.type }

    printHeader 'Configurations'
    excludeRules.container.toSet().each(printExcludeRule)

    printHeader 'Dependencies'
    excludeRules.dependency.toSet().each(printExcludeRule)
  }
}</pre></div><p>When we run the <a id="id118" class="indexterm"/>task, we get the <a id="id119" class="indexterm"/>following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q showExcludeRules</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Configurations</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>compile &gt;&gt; *:slf4j-api</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Dependencies</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>ch.qos.logback:logback-classic:1.1.2 &gt;&gt; ch.qos.log</strong></span>
<span class="strong"><strong>back:logback-core</strong></span>
</pre></div></div><div class="section" title="Using artifact-only dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Using artifact-only dependencies</h2></div></div></div><p>Finally, we can use the <code class="literal">ext</code> attribute for an external module dependency if we know we only want to include a single artifact from the dependency. With this attribute, no transitive <a id="id120" class="indexterm"/>dependencies are <a id="id121" class="indexterm"/>resolved because we specify that we specifically want the artifact specified by the <code class="literal">ext</code> attribute.</p><p>In our example, we can use the <code class="literal">ext</code> attribute with the <code class="literal">jar</code> value to resolve only the JAR artifact for the <code class="literal">logback-classic</code> dependency. In the next example build file, we will use the <code class="literal">ext</code> attribute for our <code class="literal">logback-classic</code> dependency:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

dependencies {
  // Dependency definition for Logback classic library
  compile 'ch.qos.logback:logback-classic:1.1.2@jar'

  // Alternative syntax:
  //compile group: 'ch.qos.logback',
  //        name: 'logback-classic',
  //        version: '1.1.2',
  //        ext: 'jar'
}</pre></div></div></div></div>
<div class="section" title="Resolving version conflicts"><div class="titlepage" id="aid-NQU22"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Resolving version conflicts</h1></div></div></div><p>Our previous examples <a id="id122" class="indexterm"/>were simple and only contained one dependency with some transitive dependencies. When we add more dependencies to our <a id="id123" class="indexterm"/>project, or have a multimodule project where each project has a lot of dependencies, then it can happen that the same dependency or transitive dependency is included multiple times. Gradle detects this and makes sure that the dependency is only downloaded once. We will see more about the advanced dependency cache management in Gradle later.</p><p>The trouble begins when the same dependency is included multiple times but with different versions. Which version of the dependency should be used? This is where Gradle's resolution strategy comes into play. The next table shows the resolution strategies that Gradle has:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Name</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>Newest</p>
</td><td valign="top">
<p>The newest version of a conflicting dependency is used. This is the default strategy used by Gradle. If the versions of the conflicting dependency are backward compatible, this works fine.</p>
</td></tr><tr><td valign="top">
<p>Fail</p>
</td><td valign="top">
<p>The build process fails when there is a version conflict with dependencies. We must explicitly add code to our build file that will resolve the version conflict. We will see later in this chapter how we can customize the resolution strategy to solve version conflicts explicitly.</p>
</td></tr></tbody></table></div><div class="section" title="Using the newest version"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Using the newest version</h2></div></div></div><p>Let's see what <a id="id124" class="indexterm"/>happens if we have a version conflict and use the default resolution strategy of Gradle. Gradle will use the newest version of the dependency that has a version conflict. To accomplish this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the next build file, we define a dependency on <code class="literal">slf4j-api</code> in the <code class="literal">compile</code> configuration and on <code class="literal">logback-classic</code> in the <code class="literal">runtime</code> configuration:<div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

dependencies {
  // Define dependency on SLF4J API for
  // compiling source files.
  compile 'org.slf4j:slf4j-api:1.7.7'

  // Define implementation Logback classic
  // of SLF4J API in runtime configuration.
  // This has a transitive dependency on
  // org.slf4j:slf4j-api:1.7.6, which is a version
  // conflict with org.slf4j:slf4j-api:1.7.7
  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div></li><li class="listitem">We run the <code class="literal">dependencies</code> task to see which versions of the dependencies are used. The following output shows that the <code class="literal">org.slf4j:slf4j-api:1.7.6</code> transitive dependency of <code class="literal">logback-classic</code> is changed, so the version <code class="literal">1.7.7</code> is <a id="id125" class="indexterm"/>used, which is defined in the <code class="literal">compile</code> configuration:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration runtime</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>+--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    +--- ch.qos.logback:logback-core:1.1.2</strong></span>
<span class="strong"><strong>    \--- org.slf4j:slf4j-api:1.7.6 -&gt; 1.7.7</strong></span>

<span class="strong"><strong>(*) - dependencies omitted (listed previously)</strong></span>
</pre></div><p>Notice the line <code class="literal">org.slf4j:slf4j-api:1.7.6 → 1.7.7</code>, where it visually shows that the version is increased for this dependency from <code class="literal">1.7.6</code> to <code class="literal">1.7.7</code>.</p></li><li class="listitem">The <code class="literal">dependencies</code> task shows a hierarchical tree view of the dependencies and transitive dependencies. To get a view from a specific dependency, and to see how it got in the dependency graph, we use the <code class="literal">dependencyInsight</code> task. With this task, we can see how the dependency is resolved and whether any conflict resolution has happened.</li><li class="listitem">We must use the following two options when we invoke the <code class="literal">dependencyInsight</code> task from the command line:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We specify the configuration of the dependency with the <code class="literal">--configuration</code> option.</li><li class="listitem">Then, we use the <code class="literal">--dependency</code> option to specify the name of the dependency.</li></ol><div style="height:10px; width: 1px"/></div></li><li class="listitem">The name of the dependency doesn't have to be the full name; we can even use part of the name. For example, we can use <code class="literal">org.slf4j:slf4j-api</code>, <code class="literal">slf4j-api</code>, and <code class="literal">slf4j</code> to gain insight into a dependency.</li><li class="listitem">We execute the <code class="literal">dependencyInsight</code> task to see more information about the <code class="literal">slf4j-api</code> <a id="id126" class="indexterm"/>dependency in our example build file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencyInsight --configuration runtime --dependency slf4j-api</strong></span>
<span class="strong"><strong>org.slf4j:slf4j-api:1.7.7 (conflict resolution)</strong></span>
<span class="strong"><strong>\--- runtime</strong></span>

<span class="strong"><strong>org.slf4j:slf4j-api:1.7.6 -&gt; 1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    \--- runtime</strong></span>
</pre></div><p>In the output, we see that the <code class="literal">org.slf4j:slf4j-api:1.7.7</code> dependency is resolved for the <code class="literal">runtime</code> configuration and that conflict resolution has happened for the dependency. In the next lines, we will see that the <code class="literal">org.slf4j:slf4j-api:1.7.6</code> transitive dependency has its version increased from <code class="literal">1.7.6</code> to <code class="literal">1.7.7</code>. The <code class="literal">dependencyInsight</code> task already tells us more about the dependency resolution that is applied. We will probably start with a broad overview using the <code class="literal">dependencies</code> task, and if we want to get more information about a particular dependency, we will use the <code class="literal">dependencyInsight</code> task.</p></li><li class="listitem">There is another task that we can use that will combine both the <code class="literal">dependencies</code> and <code class="literal">dependencyInsight</code> tasks. The <code class="literal">htmlDependencyReport</code> task is part of the <code class="literal">project-report</code> plugin. With this task, we get an HTML report showing all dependencies, and we can click on dependencies to get more insight. To use the task, we first add the <code class="literal">project-report</code> plugin to our example project file. The following code shows this:<div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'project-report'

repositories.jcenter()

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div></li><li class="listitem">We execute the <code class="literal">htmlDependencyReport</code> task for this build file. The following <a id="id127" class="indexterm"/>code shows this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle htmlDependencyReport</strong></span>
<span class="strong"><strong>:htmlDependencyReport</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 1.645 secs</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div></li><li class="listitem">After the task is executed, new files are created in <code class="literal">build/reports/project/dependencies/</code>.</li><li class="listitem">When we open the <code class="literal">index.html</code> file in a web browser, we can see the name of our project. If we had a multimodule project, we would see all project names here. We can click on the name and get an overview of all configurations. In the next screenshot, we see an overview of all the configuration in our project:<div class="mediaobject"><img src="../Images/image00128.jpeg" alt="Using the newest version"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">When we click on the <code class="literal">runtime</code> configuration link, all dependencies are shown. We can <a id="id128" class="indexterm"/>see that there is a version conflict because the <code class="literal">org.sfl4j:slf4j-api:1.7.6 </code>dependency is orange in color. This view is what we also see when the dependencies task from the command line is invoked:<div class="mediaobject"><img src="../Images/image00129.jpeg" alt="Using the newest version"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">To get the <a id="id129" class="indexterm"/>dependency insight view, we click on the <code class="literal">org.sfl4j:slf4j-api:1.7.6 → 1.7.7</code> link. A pop-up window is opened in our web browser, and we see the following screenshot:<div class="mediaobject"><img src="../Images/image00130.jpeg" alt="Using the newest version"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>Now, we see what we normally see if we run the <code class="literal">dependencyInsight</code> task from the command line.</p><p>The <code class="literal">htmlDependencyReport</code> is very useful to get a graphical and interactive view of the dependencies in our <a id="id130" class="indexterm"/>project. It is also easy to get more details about a dependency by just clicking on it in the generated HTML reports.</p></div><div class="section" title="Failing on version conflict"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Failing on version conflict</h2></div></div></div><p>If the default Gradle <a id="id131" class="indexterm"/>resolution strategy of using the newest version of a (transitive) dependency is not solving the problem, we can choose to let the build fail if there is a version conflict. To run the build successfully again, we must explicitly solve the version conflict in our build file.</p><p>In the following example build file, we configure the resolution strategy for the <code class="literal">runtime</code> configuration to fail if there is a version conflict. The <code class="literal">resolutionStrategy</code> method accepts a configuration closure where we invoke the <code class="literal">failOnVersionConflict</code> method. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      // If there is a version conflict,
      // then the build must fail.
      failOnVersionConflict()
    }
  }

  // Alternatively we could apply
  // this to all configurations:
  // all {
  //     resolutionStrategy {
  //         failOnVersionConflict()
  //     }
  // }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>The build is now configured to fail on a version conflict. We know from the previous examples in this chapter that there is a version conflict on <code class="literal">slf4j-api</code>. We now execute the <code class="literal">dependencies</code> task to see what happens:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>

<span class="strong"><strong>FAILURE: Build failed with an exception.</strong></span>

<span class="strong"><strong>* What went wrong:</strong></span>
<span class="strong"><strong>Execution failed for task ':dependencies'.</strong></span>
<span class="strong"><strong>&gt; Could not resolve all dependencies for configuration ':runtime'.</strong></span>
<span class="strong"><strong>  &gt; A conflict was found between the following modules:</strong></span>
<span class="strong"><strong>      - org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>      - org.slf4j:slf4j-api:1.7.6</strong></span>

<span class="strong"><strong>* Try:</strong></span>
<span class="strong"><strong>Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</strong></span>
</pre></div><p>We see that the build has <a id="id132" class="indexterm"/>failed this time. In the output, we see why. There is a conflict between the <code class="literal">org.slf4j:slf4j-api:1.7.7</code> and <code class="literal">org.slf4j:slf4j-api:1.7.6</code> modules.</p></div><div class="section" title="Forcing a version"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Forcing a version</h2></div></div></div><p>We can force Gradle to <a id="id133" class="indexterm"/>use a specific version for a dependency in our project. The dependency can also be transitive. We use the configuration closure for a dependency and set the <code class="literal">force</code> property with the value <code class="literal">true</code>. This instructs the Gradle dependency resolution process to always use the specified version for this dependency, even when the dependency is a transitive dependency in the dependency graph.</p><p>In our example build file, we have a version conflict. We can fix this by forcing Gradle to use the version <code class="literal">1.7.7</code> for the <code class="literal">org.slf4j:slf4j-api</code> dependency. The following example build file applies the <code class="literal">force</code> property:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      failOnVersionConflict()
    }
  }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7', {
    // Force Gradle to use this version
    // for this dependency (even transtive).
    force = true
  }

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>Let's run the <code class="literal">dependencies</code> <a id="id134" class="indexterm"/>task to see whether the version conflict is now resolved:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration runtime</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>+--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    +--- ch.qos.logback:logback-core:1.1.2</strong></span>
<span class="strong"><strong>    \--- org.slf4j:slf4j-api:1.7.6 -&gt; 1.7.7</strong></span>

<span class="strong"><strong>(*) - dependencies omitted (listed previously)</strong></span>
</pre></div><p>We have resolved the version conflict, and the build is now successful again. We can also see in the output that for the <code class="literal">org.slf4j:slf4j-api:1.7.6</code> transitive dependency, the version is now the version <code class="literal">1.7.7</code>.</p><p>Instead of setting the <code class="literal">force</code> property in the dependency configuration, we can also force a version for a dependency as part of the <code class="literal">resolutionStrategy</code> method in the <code class="literal">configurations</code> configuration block. We use the <code class="literal">force</code> method to add a dependency with a forced version. Alternatively, we can use the <code class="literal">forcedModules</code> property to define all forced dependencies. This might be a better solution because we can have multiple dependencies with a forced version and put them all together in the <code class="literal">resolutionStrategy</code> configuration closure for a more readable and maintainable build file.</p><p>In the next example build <a id="id135" class="indexterm"/>file, we will force the version of the <code class="literal">org.slf4j:slf4j-api</code> dependency to be <code class="literal">1.7.7</code>, but this time as part of the <code class="literal">resolutionStrategy</code> configuration:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      failOnVersionConflict()

      // Make sure version 1.7.7 is used for
      // (transitive) dependency org.slf4j:slf4j-api.
      force 'org.slf4j:slf4j-api:1.7.7'

      // Alternate syntax is to define the
      // forced module collection.
      // forcedModules = ['org.slf4j:slf4j-api:1.7.7']
    }
  }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>When we execute the <code class="literal">dependencies</code> task from the command line, we see that the version <code class="literal">1.7.7</code> is used for all <code class="literal">org.slf4j:slf4j-api</code> dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration runtime</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>+--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    +--- ch.qos.logback:logback-core:1.1.2</strong></span>
<span class="strong"><strong>    \--- org.slf4j:slf4j-api:1.7.6 -&gt; 1.7.7</strong></span>

<span class="strong"><strong>(*) - dependencies omitted (listed previously)</strong></span>
</pre></div></div></div>
<div class="section" title="Customizing dependency resolution rules"><div class="titlepage" id="aid-OPEK2"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Customizing dependency resolution rules</h1></div></div></div><p>For each <a id="id136" class="indexterm"/>dependency we define in our build file, there is a dependency resolution rule. This rule is executed when the dependency needs to be resolved. We can customize this rule in our build file, so we can change certain parts of the rule before the dependency is actually resolved. Gradle allows us to change the dependency group, name, and version with a customized resolution rule. This way, we can even completely replace dependencies with other dependencies or force a particular version.</p><p>Dependency resolution rule details are implemented in the <code class="literal">org.gradle.api.artifacts.DependencyResolveDetails</code> class. Inside the <code class="literal">resolutionStrategy</code> configuration block, we use the <code class="literal">eachDependency</code> method to customize a resolution rule. This method accepts a closure, and the closure argument is an instance of <code class="literal">DependencyResolveDetails</code>. We use the <code class="literal">useVersion</code> and <code class="literal">useTarget</code> methods of <code class="literal">DependencyResolveDetails</code> to change either the version or the complete group, name, and version for a requested dependency.</p><p>Let's change our previous example build file and define a customized resolution rule for the <code class="literal">org.slf4j:slf4j-api</code> dependency so that the version <code class="literal">1.7.7</code> is always used. In the next example build file, we will see how to achieve this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      failOnVersionConflict()

      // Customize dependency resolve rules.
      eachDependency { DependencyResolveDetails details -&gt;
        def requestedModule = details.requested

        // Force version for 
        // org.slf4j:slf4j-api dependency.
        if (requestedModule.group == 'org.slf4j'
          &amp;&amp; requestedModule.name == 'slf4j-api') {

          // Force version 1.7.7.
          details.useVersion '1.7.7'
        }
      }
    }
  }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>This mechanism is very powerful. Besides forcing a particular version, we can use the dependency resolution rules to replace a complete dependency with another. Let's suppose we have a dependency in our project and this dependency has a transitive dependency on the <a id="id137" class="indexterm"/>Log4j logging framework. We don't want this dependency, and instead want to use the log4j-over-slf4j bridge. This bridge contains alternative implementations for Log4j classes, so we can use an SLF4J API implementation. The log4j-over-slf4j bridge is defined by the <code class="literal">org.slf4j:log4j-over-slf4j:1.7.7</code> dependency. We use the <code class="literal">useTarget</code> method of the resolution rule details to set a new target. The method accepts both string notations and map notations for dependencies.</p><p>The following example build file contains the dependency resolution rule to replace a dependency on the <code class="literal">Log4j to the log4j-over-slf4j</code> bridge:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      eachDependency { DependencyResolveDetails details -&gt;
        def requestedModule = details.requested

        // Change resolve rule for log4j:log4j
        // (transitive) dependency.
        if (requestedModule.group == 'log4j'
          &amp;&amp; requestedModule.name == 'log4j') {

          // Replace log4j:log4j:&lt;version&gt; with
          // org.slf4j:log4j-over-slf4j:1.7.7.
          details.useTarget group: 'org.slf4j',
                  name: 'log4j-over-slf4j',
                  version: '1.7.7'
          // Alternative syntax:
          // useTarget 'org.slf4j:log4j-over-slf4j:1.7.7'
        }
      }
    }
  }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  // In real life this is probably a transitive
  // dependency from a dependency we need in our project.
  // We put it here as an example to show we
  // can completely replace a dependency with
  // another.
  runtime 'log4j:log4j:1.2.17'

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>We can verify that the Log4j dependency is replaced with the <code class="literal">dependencies</code> task from the command line. This <a id="id138" class="indexterm"/>is shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration runtime</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>+--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>+--- log4j:log4j:1.2.17 -&gt; org.slf4j:log4j-over-slf4j:1.7.7</strong></span>
<span class="strong"><strong>|    \--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    +--- ch.qos.logback:logback-core:1.1.2</strong></span>
<span class="strong"><strong>    \--- org.slf4j:slf4j-api:1.7.6 -&gt; 1.7.7</strong></span>

<span class="strong"><strong>(*) - dependencies omitted (listed previously)</strong></span>
</pre></div><p>Notice the <code class="literal">log4j:log4j:1.2.17 → org.slf4j:log4j-over-slf4j:1.7.7</code> line, which visually shows the replacement of the dependency with a new dependency.</p><p>Custom dependency resolution rules also allow us to define a custom version scheme. For example, in our organization, we can define that if the version of a dependency is set to the <code class="literal">fixed</code> value, the actual version is fetched from a central location on the corporate intranet. This way, all projects in the organization can share the same version for dependencies.</p><p>In the next example build file, we will implement a custom version scheme. If the <code class="literal">version</code> attribute is omitted or has the <code class="literal">fixed</code> value, then the version information is fetched from a <a id="id139" class="indexterm"/>predefined list of versions. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      eachDependency { DependencyResolveDetails details -&gt;
        def requestedModule = details.requested

        // If version is not set or version 
        // has value 'fixed' set
        // version based on external definition.
        if (!requestedModule.version
          || requestedModule.version == 'fixed') {
          def moduleVersion = findModuleVersion(requestedModule.name)
          details.useVersion moduleVersion
        }
      }
    }
  }
}

dependencies {
  // Version is not defined for this dependency,
  // is resolved via custom dependency resolve rule.
  compile 'org.slf4j:slf4j-api'

  // Version is set to 'fixed', so version can
  // be resolved via custom dependency resolve rule.
  runtime 'ch.qos.logback:logback-classic:fixed'
}

/**
* Find version for given module name. In real life
* this could be part of a company Gradle plugin
* or intranet resource with version information.
*
* @param name Module descriptor name
* @return Version for given module name
*/
def findModuleVersion(String name) {
  ['slf4j-api': '1.7.7', 'logback-classic': '1.1.2']
  .find { it.key == name}
  .value
}</pre></div><p>It is interesting to see <a id="id140" class="indexterm"/>what the output of the <code class="literal">dependencies</code> task is when we run it from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration runtime</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>+--- org.slf4j:slf4j-api: -&gt; 1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic: -&gt; 1.1.2</strong></span>
<span class="strong"><strong>    +--- ch.qos.logback:logback-core:1.1.2</strong></span>
<span class="strong"><strong>    \--- org.slf4j:slf4j-api:1.7.6 -&gt; 1.7.7</strong></span>

<span class="strong"><strong>(*) - dependencies omitted (listed previously)</strong></span>
</pre></div><p>In the output, we clearly see how the <code class="literal">org.slf4j:slf4j-api</code> dependency without a version is now using the version <code class="literal">1.7.7</code>. The <code class="literal">fixed</code> version of the <code class="literal">ch.qos.logback:logback-classic</code> dependency is resolved to the version <code class="literal">1.1.2</code>.</p><div class="section" title="Using client modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Using client modules</h2></div></div></div><p>Instead of relying on the <a id="id141" class="indexterm"/>module descriptor found in the repository for our external module dependency, we can define the metadata for the module in our build file as a client module. Remember from <a class="link" title="Chapter 1. Defining Dependencies" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <span class="emphasis"><em>Defining Dependencies</em></span>, that with a client module, we define the module descriptor in our build file and still get the artifacts from the repository.</p><p>Let's use a client module in the following example build file. We redefine the transitive dependencies for the <code class="literal">logback-classic</code> dependency and use the version <code class="literal">1.7.7</code> for the <code class="literal">slf4j-api</code> dependency. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      failOnVersionConflict()
    }
  }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  // Use a client module to redefine the transitive
  // dependencies for the logback-classic.
  runtime module('ch.qos.logback:logback-classic:1.1.2') {
    dependency 'ch.qos.logback:logback-core:1.1.2'

    // Force the correct version of
    // the slf4j-api dependency/
    dependency 'org.slf4j:slf4j-api:1.7.7'
  }
}</pre></div><p>We invoke the <a id="id142" class="indexterm"/>
<code class="literal">dependencies</code> task from the command line to check whether the correct dependencies are used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration runtime</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>+--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>\--- ch.qos.logback:logback-classic:1.1.2</strong></span>
<span class="strong"><strong>    +--- org.slf4j:slf4j-api:1.7.7</strong></span>
<span class="strong"><strong>    \--- ch.qos.logback:logback-core:1.1.2</strong></span>

<span class="strong"><strong>(*) - dependencies omitted (listed previously)</strong></span>
</pre></div><p>We see in the output that the dependency on <code class="literal">org.slf4j:slf4j-api</code> is now <code class="literal">1.7.7</code> and we don't have version conflict anymore.</p></div></div>
<div class="section" title="Using dynamic versions and changing modules" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Using dynamic versions and changing modules</h1></div></div></div><p>In <a class="link" title="Chapter 1. Defining Dependencies" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <span class="emphasis"><em>Defining Dependencies</em></span>, we already learned about dynamic versions. For example, we can use a range of versions such as <code class="literal">[4.0.1.RELEASE,4.0.4.RELEASE[</code>. When the dependency is resolved by Gradle, the latest available static version in the range is selected.</p><p>A changing module is <a id="id143" class="indexterm"/>different than a dynamic version. A changing module references a dependency with the same version but with changing artifacts. For example, in a Maven repository, a changing module is the snapshot <a id="id144" class="indexterm"/>module indicated by <code class="literal">-SNAPSHOT</code> in the <code class="literal">version</code> attribute. Gradle can resolve a changing module dependency and get the latest artifact for the given version. However, the next time, a new artifact might be downloaded because the content has changed.</p><p>Gradle caches dynamic versions and changing modules for 24 hours. We will see how we can customize this behavior in our Gradle build file and from the command line. However, before we take a look at the options, we will first see how Gradle caching works.</p></div>
<div class="section" title="Understanding the dependency cache" id="aid-QMFO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Understanding the dependency cache</h1></div></div></div><p>The dependency <a id="id145" class="indexterm"/>cache of Gradle tries to minimize the number of remote requests and downloads so that builds can be fast and reliable. The cache has two parts to perform proper dependency caching:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First, it has a cache for dependency metadata (POM or Ivy descriptor files) for a dependency group, name, and version. Gradle keeps a separate cache for each repository. So, if the same dependency is found in multiple repositories, then the metadata information is cached in multiple dependency metadata caches.</li><li class="listitem">The dependency cache also has a single cache with downloaded artifacts for the dependencies. The multiple metadata caches share the same cache for downloaded artifacts. The artifacts are stored by the SHA1 hash code of their contents and not by metadata, such as group, name, or version.</li></ul></div><p>The separation of a metadata cache based on the repository and the artifact cache provides enough flexibility to perform repeatable and reliable dependency resolution. If the dependency metadata cannot be resolved by Gradle, then the dependency resolution will stop, even if the local cache has a copy of the artifact that was downloaded from a different repository (not defined in our build). This repository independence isolates builds from each other and prevents problems with dependency artifacts.</p><p>Gradle first tries to determine the SHA1 checksum for an artifact file before downloading the artifact. If the checksum can be determined, the file will not be downloaded if it is already in the cache with the same checksum. Gradle also tries to reuse artifacts from the local Maven repository. If the checksum for an artifact in the local Maven repository matches the checksum for the artifact from the remote repository, then the artifact doesn't need to be downloaded and can be copied from the local Maven repository.</p><p>Because Gradle uses an SHA1 checksum for the artifact contents, different versions for the same artifact can be stored. For example, when an artifact is part of a changing module or the contents of the artifact have changed in the repository without a change in the version number.</p><p>Both the metadata cache and artifact cache are stored in the directory defined by the <code class="literal">GRADLE_USER_HOME</code> environment variable that is, by default, the <code class="literal">.gradle/caches</code> directory in the user home directory. Gradle uses a sophisticated locking mechanism for the caches, so multiple <a id="id146" class="indexterm"/>projects can use the cache directories and files simultaneously. In the next example build file, we create the <code class="literal">artifactsLocation</code> task to print out where the downloaded artifacts are stored:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories.jcenter()

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'
  runtime 'ch.qos.logback:logback-classic:1.1.2'
}

task artifactsLocation {
  description 'Show location of artifact on disk'

  doFirst {
    configurations.runtime.each { println it }
  }
}</pre></div><p>When we execute the <code class="literal">artifactsLocation</code> task, we see in the output that the files are stored in the <code class="literal">.gradle/caches</code> directory in the user home directory (<code class="literal">/Users/mrhaki</code>). We also see the SHA1 checksums with which the directory names are used. The following code shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q artifactsLocation</strong></span>
<span class="strong"><strong>/Users/mrhaki/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/1.7.7/2b8019b6249bb05d81d3a3094e468753e2b21311/slf4j-api-1.7.7.jar</strong></span>
<span class="strong"><strong>/Users/mrhaki/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.1.2/b316e9737eea25e9ddd6d88eaeee76878045c6b2/logback-classic-1.1.2.jar</strong></span>
<span class="strong"><strong>/Users/mrhaki/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.1.2/2d23694879c2c12f125dac5076bdfd5d771cc4cb/logback-core-1.1.2.jar</strong></span>
</pre></div><div class="section" title="Command-line options for caching"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Command-line options for caching</h2></div></div></div><p>We can use the <code class="literal">--offline</code> command-line option to skip any network requests. So, with this option, Gradle <a id="id147" class="indexterm"/>never tries to access remote repositories and all information is fetched from the Gradle dependency caches. If the information in the caches is not sufficient for a build, then the build fails.</p><p>With the <code class="literal">--refresh-dependencies</code> option, we can refresh the metadata caches. If, for some reason, we expect the metadata to be no longer correct, we can use this option. Gradle will then refresh all information in the metadata caches for each repository. Artifacts are only downloaded when the SHA1 checksum is different than the checksum for artifacts in the artifacts cache.</p></div><div class="section" title="Changing cache expiration"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Changing cache expiration</h2></div></div></div><p>A dependency with a <a id="id148" class="indexterm"/>static version can be easily cached. The contents of the artifact has a checksum, and this can be used to either use the cache or download the artifact (and place it in the artifact cache). A dependency with a dynamic version or changing module can have a changing artifact, so we need to be able to customize the cache settings. We can change the expiration time for cached dependencies with a dynamic version and changing modules. The default expiration time is 24 hours. After the expiration time, Gradle will invalidate the cache and determine whether an artifact needs to be downloaded again.</p><p>We change the expiration time for dependencies with a dynamic version using the <code class="literal">cacheDynamicVersionsFor</code> method of the <code class="literal">resolutionStrategy</code> configuration closure. The method accepts a number and time unit to set the value for the cache expiration. The time unit can be either of the <code class="literal">java.util.concurrent.TimeUnit</code> type or a string that is converted to <code class="literal">TimeUnit</code>.</p><p>To change modules, we use the <code class="literal">cacheChangingModulesFor</code> method to change the expiration time. This method also accepts a number and time unit just as the <code class="literal">cacheDynamicVersionsFor</code> method does.</p><p>In the next example build file, we change the cache expiration for both dynamic versions and changing modules for <code class="literal">runtime</code> configurations. We can also set it for all configurations with the <code class="literal">all</code> method and configuration block. The following code shows this:</p><div class="informalexample"><pre class="programlisting">// Import needed for cache methods time unit.
import java.util.concurrent.TimeUnit

apply plugin: 'java'

repositories.jcenter()

configurations {
  runtime {
    resolutionStrategy {
      // Change expiration time for caching
      // dynamic version to 30 minutes.
      cacheDynamicVersionsFor 30, 'minutes'

      // Alternative syntax is using TimeUnit:
      // cacheDynamicVersionsFor 1, TimeUnit.HOURS

      // Change expiration time for cached
      // changing modules to 5 minutes using
      // java.util.concurrent.TimeUnit.
      cacheChangingModulesFor 5, TimeUnit.MINUTES

      // Or we could use string notation.
      // cacheChangingModulesFor 1, 'minutes'
    }
  }

  // Alternatively we could apply
  // this to all configurations:
  // all {
  //     resolutionStrategy {
  //         cacheDynamicVersionsFor 4, 'hours'
  //         cacheChangingModulesFor 10, 'minutes'
  //     }
  // }
}

dependencies {
  compile 'org.slf4j:slf4j-api:1.7.7'

  runtime 'ch.qos.logback:logback-classic:1.1.2'
}</pre></div><p>Gradle knows about <a id="id149" class="indexterm"/>artifacts that are stored in a Maven repository, and that if the version attribute ends with <code class="literal">-SNAPSHOT</code>, the module is a changing module. We can also define in our build script whether a dependency is a changing module, for example, if this cannot be derived from the version attribute. We must set the <code class="literal">changing</code> property to the value <code class="literal">true</code> in the configuration closure for a dependency.</p><p>In the following example build file, we have the <code class="literal">com.vehicles:cars</code> dependency, which is a changing <a id="id150" class="indexterm"/>module, but we use the static version <code class="literal">1.0</code>:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories {
  maven {
    url 'http://ourcompany.com/maven'
  }
}

dependencies {
  compile('com.vehicles:cars:1.0') {
    // Instruct Gradle this a changing
    // module, although it cannot
    // be derived from the version attribute.
    changing = true
  }

  // Other syntax using the map notation:
  // compile group: 'com.vehicles', name: 'cars',
  //         version: '1.0', changing: true
}</pre></div></div></div>
<div class="section" title="Summary" id="aid-RL0A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, you learned how Gradle resolves dependencies and how to customize this. You saw how to reconfigure your build scripts to handle transitive dependencies and how to resolve version conflicts between dependencies in your builds. Gradle offers some fine-grained control on how we define dependencies and allows very explicit dependency definitions.</p><p>For transitive dependencies, we have several ways to redefine which dependencies need to be used by either disabling or excluding transitive dependencies.</p><p>When a version conflict arises between dependencies in our build, we can either rely on the default strategy of using the newest version or implement a custom strategy. Gradle has several ways to customize dependency resolution rules by redefining the resolution strategy. For example, we can override the version attribute for a dependency or even totally replace it with a compatible but different dependency.</p><p>Finally, you saw how the dependency cache of Gradle works. It is designed to reduce network requests and provide reliable and repeatable builds that have dependencies. You learned how you can customize the expiration time for dependency modules that are changing or are defined with dynamic versions.</p><p>Up until now, we saw how to include dependencies in our projects, but in the next chapter, we will see how we can publish artifacts that we created as dependencies for other projects.</p></div></body></html>