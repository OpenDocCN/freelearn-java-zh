<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Thread Synchronization Utilities</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Controlling concurrent access to one or more copies of a resource</li>
<li class="calibre18">Waiting for multiple concurrent events</li>
<li class="calibre18">Synchronizing tasks at a common point</li>
<li class="calibre18">Running concurrent-phased tasks</li>
<li class="calibre18">Controlling phase change in concurrent-phased tasks</li>
<li class="calibre18">Exchanging data between concurrent tasks</li>
<li class="calibre18">Completing and linking tasks asynchronously</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">In <a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em>, you learned the concepts of synchronization and critical sections. Basically, we talk about synchronization when more than one concurrent task shares a resource, for example, an object or an attribute of an object. The blocks of code that access this shared resource are called critical sections.</p>
<p class="calibre4">If you don't use appropriate mechanisms, you might have incorrect results, data inconsistencies, or error conditions. Therefore, we have to adopt one of the synchronization mechanisms provided by the Java language to avoid these problems.</p>
<p class="calibre4"><a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em>, taught you about the following basic synchronization mechanisms:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">synchronized</kbd> keyword</li>
<li class="calibre18">The Lock interface and its implementation classes: <kbd class="calibre15">ReentrantLock</kbd>, <kbd class="calibre15">ReentrantReadWriteLock.ReadLock</kbd>, and <kbd class="calibre15">ReentrantReadWriteLock.WriteLock</kbd></li>
<li class="calibre18">The <kbd class="calibre15">StampedLock</kbd> class</li>
</ul>
<p class="calibre4">In this chapter, you will learn how to use high-level mechanisms to synchronize multiple threads. These high-level mechanisms are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Semaphores</strong>: A semaphore is a counter that controls access to one or more shared resources. This mechanism is one of the basic tools of concurrent programming and is provided by most programming languages.</li>
<li class="calibre18"><strong class="calibre1">CountDownLatch</strong>: The <kbd class="calibre15">CountDownLatch</kbd> class is a mechanism provided by the Java language that allows a thread to wait for the finalization of multiple operations.</li>
<li class="calibre18"><strong class="calibre1">CyclicBarrier</strong>: The <kbd class="calibre15">CyclicBarrier</kbd> class is another mechanism provided by the Java language that allows the synchronization of multiple threads at a common point.</li>
<li class="calibre18"><strong class="calibre1">Phaser</strong>: The <kbd class="calibre15">Phaser</kbd> class is another mechanism provided by the Java language that controls the execution of concurrent tasks divided in phases. All the threads must finish one phase before they can continue with the next one.</li>
<li class="calibre18"><strong class="calibre1">Exchanger</strong>: The <kbd class="calibre15">Exchanger</kbd> class is another mechanism provided by the Java language that provides a point of data interchange between two threads.</li>
<li class="calibre18"><strong class="calibre1">CompletableFuture</strong>: The <kbd class="calibre15">CompletableFuture</kbd> class provides a mechanism where one or more tasks can wait for the finalization of another task that will be explicitly completed in an asynchronous way in future.Â This class was introduced in Java 8 and has introduced new methods in Java 9.</li>
</ul>
<p class="calibre4">Semaphores are generic synchronization mechanisms that you can use to protect any critical section in any problem. Other mechanisms are thought to be used in applications with specific features, as described previously. Be sure to select the appropriate mechanism according to the characteristics of your application.</p>
<p class="calibre4">This chapter presents seven recipes that will show you how to use the mechanisms described.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Controlling concurrent access to one or more copies of a resource</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you will learn how to use the semaphore mechanism provided by the Java language. A semaphore is a counter that protects access to one or more shared resources.</p>
<div class="packt_infobox">The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was used for the first time in the THEOS operating system.</div>
<p class="calibre4">When a thread wants to access one of the shared resources, it must first acquire the semaphore. If the internal counter of the semaphore is greater than 0, the semaphore decrements the counter and allows access to the shared resource. A counter bigger than 0 implies that there are free resources that can be used, so the thread can access and use one of them.</p>
<p class="calibre4">Otherwise, if the counter is 0, the semaphore puts the thread to sleep until the counter is greater than 0. A value of 0 in the counter means all the shared resources are used by other threads, so the thread that wants to use one of them must wait until one is free.</p>
<p class="calibre4">When the thread has finished using the shared resource, it must release the semaphore so that another thread can access the resource. This operation increases the internal counter of the semaphore.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">Semaphore</kbd> class to protect more than one copy of a resource. You are going to implement an example, which has a print queue that could print documents in three different printers.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">PrintQueue</kbd> that will implement the print queue:</li>
</ol>
<pre class="calibre23">
        public class PrintQueue {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">This class will have three private attributes. A semaphore named <kbd class="calibre15">semaphore</kbd>, an array of Booleans named <kbd class="calibre15">freePrinters</kbd>, and a lock named <kbd class="calibre15">lockPrinters</kbd>, as shown in the following code snippet:</li>
</ol>
<pre class="calibre23">
        private final Semaphore semaphore; <br class="title-page-name"/>        private final boolean freePrinters[]; <br class="title-page-name"/>        private final Lock lockPrinters;
</pre>
<ol start="3" class="calibre19">
<li class="calibre18" value="3">Implement the constructor of the class. It initializes the three attributes of the class, as shown in the following code snippet:</li>
</ol>
<pre class="calibre23">
        public PrintQueue(){ <br class="title-page-name"/>          semaphore=new Semaphore(3); <br class="title-page-name"/>          freePrinters=new boolean[3]; <br class="title-page-name"/>          for (int i=0; i&lt;3; i++){ <br class="title-page-name"/>            freePrinters[i]=true; <br class="title-page-name"/>          } <br class="title-page-name"/>          lockPrinters=new ReentrantLock(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li class="calibre18" value="4">Implement the <kbd class="calibre15">printJob()</kbd> method that will simulate the printing of a document. It receives an object called <kbd class="calibre15">document</kbd> as a parameter:</li>
</ol>
<pre class="calibre23">
        public void printJob (Object document){
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">First of all, the <kbd class="calibre15">printJob()</kbd> method calls the <kbd class="calibre15">acquire()</kbd> method to acquire access to the semaphore. As this method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, you must include the code to process it:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          semaphore.acquire();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, get the number of the printers assigned to print this job, using the private method <kbd class="calibre15">getPrinter()</kbd>:</li>
</ol>
<pre class="calibre23">
        int assignedPrinter=getPrinter();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Then, implement the lines that simulate the printing of a document waiting for a random period of time:</li>
</ol>
<pre class="calibre23">
        long duration=(long)(Math.random()*10); <br class="title-page-name"/>        System.out.printf("%s - %s: PrintQueue: Printing a Job in<br class="title-page-name"/>                           Printer %d during %d seconds\n",<br class="title-page-name"/>                          new Date(), Thread.currentThread().getName(),<br class="title-page-name"/>                          assignedPrinter,duration);<br class="title-page-name"/>        TimeUnit.SECONDS.sleep(duration);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Finally, release the semaphore by calling the <kbd class="calibre15">release()</kbd> method and marking the printer used as free, and assign <kbd class="calibre15">true</kbd> to the corresponding index in the <kbd class="calibre15">freePrinters</kbd> array:</li>
</ol>
<pre class="calibre23">
          freePrinters[assignedPrinter]=true; <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } finally { <br class="title-page-name"/>          semaphore.release();       <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Next, implement the <kbd class="calibre15">getPrinter()</kbd> method. It's a private method that returns an <kbd class="calibre15">int</kbd> value and has no parameters:</li>
</ol>
<pre class="calibre23">
        private int getPrinter() {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">First, declare an <kbd class="calibre15">int</kbd> variable to store the index of the printer:</li>
</ol>
<pre class="calibre23">
        int ret=-1;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Then, get access to the <kbd class="calibre15">lockPrinters</kbd> object:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          lockPrinters.lock();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Post this, find the first true value in the <kbd class="calibre15">freePrinters</kbd> array and save its index in a variable. Modify this value to <kbd class="calibre15">false</kbd> because this printer will be busy:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;freePrinters.length; i++) { <br class="title-page-name"/>          if (freePrinters[i]){ <br class="title-page-name"/>            ret=i; <br class="title-page-name"/>            freePrinters[i]=false; <br class="title-page-name"/>            break; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Finally, free the <kbd class="calibre15">lockPrinters</kbd> object and return the index of the true value:</li>
</ol>
<pre class="calibre23">
        } catch (Exception e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } finally { <br class="title-page-name"/>          lockPrinters.unlock(); <br class="title-page-name"/>        } <br class="title-page-name"/>        return ret;
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Next, create a class called <kbd class="calibre15">Job</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class implements the job that will send a document to the printer:</li>
</ol>
<pre class="calibre23">
        public class Job implements Runnable {
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Declare a <kbd class="calibre15">PrintQueue</kbd> object. Call it <kbd class="calibre15">printQueue</kbd>:</li>
</ol>
<pre class="calibre23">
        private PrintQueue printQueue;
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the constructor of the class. It initializes the <kbd class="calibre15">PrintQueue</kbd> object declared in the class:</li>
</ol>
<pre class="calibre23">
        public Job(PrintQueue printQueue){ <br class="title-page-name"/>          this.printQueue=printQueue; <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>          public void run() {
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">First, this method writes a message to the console that shows that the job has started its execution:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Going to print a job\n",<br class="title-page-name"/>                          Thread.currentThread().getName());
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Then, it calls the <kbd class="calibre15">printJob()</kbd> method of the <kbd class="calibre15">PrintQueue</kbd> object:</li>
</ol>
<pre class="calibre23">
        printQueue.printJob(new Object());
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Finally, the method writes a message to the console that shows that it has finished its execution:</li>
</ol>
<pre class="calibre23">
          System.out.printf("%s: The document has been printed\n",<br class="title-page-name"/>                            Thread.currentThread().getName());         <br class="title-page-name"/>        }
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Next, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and implementing the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main (String args[]){
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Create a <kbd class="calibre15">PrintQueue</kbd> object named <kbd class="calibre15">printQueue</kbd>:</li>
</ol>
<pre class="calibre23">
        PrintQueue printQueue=new PrintQueue();
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Create 12 threads. Each one of these threads will execute a <kbd class="calibre15">Job</kbd> object that will send a document to the print queue:</li>
</ol>
<pre class="calibre23">
        Thread[] threads=new Thread[12]; <br class="title-page-name"/>        for (int i=0; I &lt; threads.length i++){ <br class="title-page-name"/>          thread[i]=new Thread(new Job(printQueue),"Thread"+i); <br class="title-page-name"/>        }
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Finally, start the 12 threads:</li>
</ol>
<pre class="calibre23">
        for (int i=0; I &lt; threads.length; i++){ <br class="title-page-name"/>          thread[i].start(); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key to this example is the <kbd class="calibre15">printJob()</kbd> method of the <kbd class="calibre15">PrintQueue</kbd> class. This method shows three steps you must follow when you use a semaphore to implement a critical section and protect access to a shared resource:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, you acquire the semaphore with the <kbd class="calibre15">acquire()</kbd> method.</li>
<li value="2" class="calibre18">Then, you do the necessary operations with the shared resource.</li>
<li value="3" class="calibre18">Finally, release the semaphore with the <kbd class="calibre15">release()</kbd> method.</li>
</ol>
<p class="calibre4">Another important point in this example is the constructor of the <kbd class="calibre15">PrintQueue</kbd> class and the initialization of the <kbd class="calibre15">Semaphore</kbd> object. You pass the value <kbd class="calibre15">3</kbd> as the parameter of this constructor, so you are creating a semaphore that will protect three resources. The first three threads that call the <kbd class="calibre15">acquire()</kbd> method will get access to the critical section of this example, while the rest will be blocked. When a thread finishes a critical section and releases the semaphore, another thread will acquire it.</p>
<p class="calibre4">The following screenshot shows the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone9" src="../images/00020.gif"/></div>
<p class="calibre4">You can see how the first three print jobs start at the same time. Then, when one printer finishes its job, another one begins.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Semaphore</kbd> class has three additional versions of the <kbd class="calibre15">acquire()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">acquireUninterruptibly()</kbd>: The <kbd class="calibre15">acquire()</kbd> method, when the internal counter of the semaphore is <kbd class="calibre15">0</kbd>, blocks the thread until the semaphore is released. During this period, the thread may be interrupted; if this happens, the method will throw an <kbd class="calibre15">InterruptedException</kbd> exception. This version of the <kbd class="calibre15">acquire</kbd> operation ignores the interruption of the thread and doesn't throw any exceptions.</li>
<li class="calibre18"><kbd class="calibre15">tryAcquire()</kbd>: This method tries to acquire the semaphore. If it can, it returns the <kbd class="calibre15">true</kbd> value. But if it can't, it returns <kbd class="calibre15">false</kbd> instead of being blocked and waits for the release of the semaphore. It's your responsibility to take correct action based on the return value.</li>
</ul>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">tryAcquire(long timeout, TimeUnit unit)</kbd>: This method is equivalent to the previous one, but it waits for the semaphore for the period of time specified in the parameters. If the period of time ends and the method hasn't acquired the semaphore, it will return <kbd class="calibre15">false</kbd>.</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">acquire()</kbd>, <kbd class="calibre15">acquireUninterruptibly()</kbd>, <kbd class="calibre15">tryAcquire()</kbd>, and <kbd class="calibre15">release()</kbd> methods have an additional version, which has an <kbd class="calibre15">int</kbd> parameter. This parameter represents the number of permits the thread that uses them wants to acquire or release, in other words, the number of units that this thread wants to delete or add to the internal counter of the semaphore.</p>
<p class="calibre4">In the case of the <kbd class="calibre15">acquire()</kbd>, <kbd class="calibre15">acquireUninterruptibly()</kbd>, and <kbd class="calibre15">tryAcquire()</kbd> methods, if the value of the counter is less than the number passed as parameter<span>Â </span><span>value, the thread will be blocked until the counter gets the same value or a greater one.</span></p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Fairness in semaphores</h1>
            

            <article>
                
<p class="calibre4">The concept of fairness is used by the Java language in all classes that can have various threads blocked and are waiting for the release of a synchronization resource (for example, a semaphore). The default mode is called <strong class="calibre1">non-fair mode</strong>. In this mode, when the synchronization resource is released, one of the waiting threads is selected and is given this resource; however, it's selected without any criteria. Fair mode, on the other hand, changes this behavior and selects the thread that has been waiting for the longest period of time.</p>
<p class="calibre4">As it occurs with other classes, the <kbd class="calibre15">Semaphore</kbd> class admits a second parameter in its constructor. This parameter must take a Boolean value. If you give it a false value, you are creating a semaphore that will work in non-fair mode. You will get the same behavior if you don't use this parameter. If you give it a true value, you are creating a semaphore that will work in fair mode.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Monitoring a Lock interface</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
<li class="calibre18">The <em class="calibre14">Synchronizing a block of code with a lock</em>Â recipe in <a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Waiting for multiple concurrent events</h1>
            

            <article>
                
<p class="calibre4">The Java concurrency API provides a class that allows one or more threads to wait until a set of operations are made. It's called the <kbd class="calibre15">CountDownLatch</kbd> class. This class is initialized with an integer number, which is the number of operations the threads are going to wait for. When a thread wants to wait for the execution of these operations, it uses the <kbd class="calibre15">await()</kbd> method. This method puts the thread to sleep until the operations are completed. When one of these operations finishes, it uses the <kbd class="calibre15">countDown()</kbd> method to decrement the internal counter of the <kbd class="calibre15">CountDownLatch</kbd> class. When the counter arrives at <kbd class="calibre15">0</kbd>, the class wakes up all the threads that were sleeping in the <kbd class="calibre15">await()</kbd> method.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">CountDownLatch</kbd> class to implement a video conference system. The video conference system should wait for the arrival of all the participants before it begins.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Videoconference</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class will implement the video conference system:</li>
</ol>
<pre class="calibre23">
        public class Videoconference implements Runnable{
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a <kbd class="calibre15">CountDownLatch</kbd> object named controller:</li>
</ol>
<pre class="calibre23">
        private final CountDownLatch controller;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that initializes the <kbd class="calibre15">CountDownLatch</kbd> attribute. The <kbd class="calibre15">Videoconference</kbd> class will wait for the arrival of the number of participants received as a parameter:</li>
</ol>
<pre class="calibre23">
        public Videoconference(int number) { <br class="title-page-name"/>          controller=new CountDownLatch(number); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">arrive()</kbd> method. This method will be called each time a participant arrives for the video conference. It receives a <kbd class="calibre15">String</kbd> type named <kbd class="calibre15">name</kbd> as the parameter:</li>
</ol>
<pre class="calibre23">
        public void arrive(String name){
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">First, it writes a message with the parameter it has received:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s has arrived.",name);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, it calls the <kbd class="calibre15">countDown()</kbd> method of the <kbd class="calibre15">CountDownLatch</kbd> object:</li>
</ol>
<pre class="calibre23">
        controller.countDown();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, it writes another message with the number of participants whose arrival is pending, using the <kbd class="calibre15">getCount()</kbd> method of the <kbd class="calibre15">CountDownLatch</kbd> object:</li>
</ol>
<pre class="calibre23">
        System.out.printf("VideoConference: Waiting for %d<br class="title-page-name"/>                           participants.\n",controller.getCount());
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Next, implement the main method of the video conference system. It's the <kbd class="calibre15">run()</kbd> method that every <kbd class="calibre15">Runnable</kbd> object must have:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">First, use the <kbd class="calibre15">getCount()</kbd> method to write a message with the number of participants in the video conference:</li>
</ol>
<pre class="calibre23">
        System.out.printf("VideoConference: Initialization: %d<br class="title-page-name"/>                           participants.\n",controller.getCount());
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, use the <kbd class="calibre15">await()</kbd> method to wait for all the participants. As this method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, you must include the code to process it:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          controller.await();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Finally, write a message to indicate that all the participants have arrived:</li>
</ol>
<pre class="calibre23">
          System.out.printf("VideoConference: All the participants have<br class="title-page-name"/>                             come\n"); <br class="title-page-name"/>          System.out.printf("VideoConference: Let's start...\n"); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Next, create the <kbd class="calibre15">Participant</kbd> class and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class represents each participant in the video conference:</li>
</ol>
<pre class="calibre23">
        public class Participant implements Runnable {
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Declare a private <kbd class="calibre15">Videoconference</kbd> attribute named <kbd class="calibre15">conference</kbd>:</li>
</ol>
<pre class="calibre23">
        private Videoconference conference;
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">name</kbd>:</li>
</ol>
<pre class="calibre23">
        private String name;
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the constructor of the class that initializes both the preceding attributes:</li>
</ol>
<pre class="calibre23">
        public Participant(Videoconference conference, String name) { <br class="title-page-name"/>          this.conference=conference; <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the participants:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">First, put the thread to sleep for a random period of time:</li>
</ol>
<pre class="calibre23">
        long duration=(long)(Math.random()*10); <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Then, use the <kbd class="calibre15">arrive()</kbd> method of the <kbd class="calibre15">Videoconference</kbd> object to indicate the arrival of this participant:</li>
</ol>
<pre class="calibre23">
        conference.arrive(name);
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Finally, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Next, create a <kbd class="calibre15">Videoconference</kbd> object named <kbd class="calibre15">conference</kbd> that waits for 10 participants:</li>
</ol>
<pre class="calibre23">
        Videoconference conference=new Videoconference(10);
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Create <kbd class="calibre15">Thread</kbd> to run this <kbd class="calibre15">Videoconference</kbd> object and start it:</li>
</ol>
<pre class="calibre23">
        Thread threadConference=new Thread(conference); <br class="title-page-name"/>        threadConference.start();
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Create 10 <kbd class="calibre15">Participant</kbd> objects, a <kbd class="calibre15">Thread</kbd> object to run each of them, and start all the threads:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          Participant p=new Participant(conference, "Participant "+i); <br class="title-page-name"/>          Thread t=new Thread(p); <br class="title-page-name"/>          t.start(); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">CountDownLatch</kbd> class has three basic elements:</p>
<ul class="calibre17">
<li class="calibre18">The initialization value that determines how many events the <kbd class="calibre15">CountDownLatch</kbd> object waits for</li>
<li class="calibre18">The <kbd class="calibre15">await()</kbd> method, called by the threads that wait for the finalization of all the events</li>
<li class="calibre18">The <kbd class="calibre15">countDown()</kbd> method, called by the events when they finish their execution</li>
</ul>
<p class="calibre4">When you create a <kbd class="calibre15">CountDownLatch</kbd> object, it uses the constructor's parameter to initialize an internal counter. Every time a thread calls the <kbd class="calibre15">countDown()</kbd> method, the <kbd class="calibre15">CountDownLatch</kbd> object decrements the internal counter in one unit. When the internal counter reaches 0, the <kbd class="calibre15">CountDownLatch</kbd> object wakes up all the threads that were waiting in the <kbd class="calibre15">await()</kbd> method.</p>
<p class="calibre4">There's no way to re-initialize the internal counter of the <kbd class="calibre15">CountDownLatch</kbd> object or modify its value. Once the counter is initialized, the only method you can use to modify its value is the <kbd class="calibre15">countDown()</kbd> method explained earlier. When the counter reaches <kbd class="calibre15">0</kbd>, all the calls to the <kbd class="calibre15">await()</kbd> method are returned immediately and all subsequent calls to the <kbd class="calibre15">countDown()</kbd> method have no effect.</p>
<p class="calibre4">However, there are some differences with respect to other synchronization methods, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">CountDownLatch</kbd> mechanism is not used to protect a shared resource or a critical section. It is used to synchronize one or more threads with the execution of various tasks.</li>
<li class="calibre18">It only admits one use. As explained earlier, once the counter of <kbd class="calibre15">CountDownLatch</kbd> arrives at <kbd class="calibre15">0</kbd>, all the calls to its methods have no effect. You have to create a new object if you want to do the same synchronization again.</li>
</ul>
<p class="calibre4">The following screenshot shows the output of an execution of the example:</p>
<div class="cdpaligncenter"><img class="alignnone10" src="../images/00021.jpeg"/></div>
<p class="calibre4">You can see how participants arrive, and once the internal counter arrives at <kbd class="calibre15">0</kbd>, the <kbd class="calibre15">CountDownLatch</kbd> object wakes up the <kbd class="calibre15">Videoconference</kbd> object that writes the messages indicating that the video conference should start.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">CountDownLatch</kbd> class has another version of the <kbd class="calibre15">await()</kbd> method, which is as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">await(long time, TimeUnit unit)</kbd>: In this method, the thread will continue to sleep until it's interrupted, that is, either the internal counter of <kbd class="calibre15">CountDownLatch</kbd> arrives at <kbd class="calibre15">0</kbd> or the specified time passes. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Synchronizing tasks in a common point</h1>
            

            <article>
                
<p class="calibre4">The Java concurrency API provides a synchronizing utility that allows the synchronization of two or more threads at a determined point. It's the <kbd class="calibre15">CyclicBarrier</kbd> class. This class is similar to the <kbd class="calibre15">CountDownLatch</kbd> class explained in the <em class="calibre14">Waiting for multiple concurrent events</em> recipe in this chapter, but it presents some differences that make it a more powerful class.</p>
<p class="calibre4">The <kbd class="calibre15">CyclicBarrier</kbd> class is initialized with an integer number, which is the number of threads that will be synchronized at a determined point. When one of these threads arrives at the determined point, it calls the <kbd class="calibre15">await()</kbd> method to wait for the other threads. When the thread calls this method, the <kbd class="calibre15">CyclicBarrier</kbd> class blocks the thread that is sleeping until the other threads arrive. When the last thread calls the <kbd class="calibre15">await()</kbd> method of the <kbd class="calibre15">CyclicBarrier</kbd> object, it wakes up all the threads that were waiting and continues with its job.</p>
<p class="calibre4">One interesting advantage of the <kbd class="calibre15">CyclicBarrier</kbd> class is that you can pass an additional <kbd class="calibre15">Runnable</kbd> object as an initialization parameter, and the <kbd class="calibre15">CyclicBarrier</kbd> class executes this object as a thread when all the threads arrive at the common point. This characteristic makes this class adequate for parallelization of tasks using the divide and conquer programming technique.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">CyclicBarrier</kbd> class to synchronize a set of threads at a determined point. You will also use a <kbd class="calibre15">Runnable</kbd> object that will be executed after all the threads arrive at this point. In the example, you will look for a number in a matrix of numbers. The matrix will be divided into subsets (using the divide and conquer technique), so each thread will look for the number in one subset. Once all the threads have finished their respective jobs, a final task will unify their results.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Start the example by implementing two auxiliary classes. First, create a class named <kbd class="calibre15">MatrixMock</kbd>. This class will generate a random matrix of numbers between one and 10, where the threads will look for a number:</li>
</ol>
<pre class="calibre23">
        public class MatrixMock {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> matrix named <kbd class="calibre15">data</kbd>:</li>
</ol>
<pre class="calibre23">
        private final int data[][];
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class. This constructor will receive the number of rows of the matrix, the length of each row, and the number we are going to look for as parameters. All the three parameters are of the type <kbd class="calibre15">int</kbd>:</li>
</ol>
<pre class="calibre23">
        public MatrixMock(int size, int length, int number){
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Initialize the variables and objects used in the constructor:</li>
</ol>
<pre class="calibre23">
        int counter=0; <br class="title-page-name"/>        data=new int[size][length]; <br class="title-page-name"/>        Random random=new Random();
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Fill the matrix with random numbers. Each time you generate a number, compare it with the number you are going to look for. If they are equal, increment the counter:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;size; i++) { <br class="title-page-name"/>          for (int j=0; j&lt;length; j++){ <br class="title-page-name"/>            data[i][j]=random.nextInt(10); <br class="title-page-name"/>            if (data[i][j]==number){ <br class="title-page-name"/>              counter++; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Finally, print a message in the console, which shows the number of occurrences of the number you are going to look for in the generated matrix. This message will be used to check that the threads get the correct result:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Mock: There are %d ocurrences of number in<br class="title-page-name"/>                           generated data.\n",counter,number);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">getRow()</kbd> method. This method receives an <kbd class="calibre15">int</kbd> parameter with the number of a rows in the matrix; it returns the row if it exists and returns <kbd class="calibre15">null</kbd> if it doesn't:</li>
</ol>
<pre class="calibre23">
        public int[] getRow(int row){ <br class="title-page-name"/>          if ((row&gt;=0)&amp;&amp;(row&lt;data.length)){ <br class="title-page-name"/>            return data[row]; <br class="title-page-name"/>          } <br class="title-page-name"/>          return null; <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Now implement a class named <kbd class="calibre15">Results</kbd>. This class will store, in an array, the number of occurrences of the searched number in each row of the matrix:</li>
</ol>
<pre class="calibre23">
        public class Results {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> array named <kbd class="calibre15">data</kbd>:</li>
</ol>
<pre class="calibre23">
        private final int data[];
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the constructor of the class. This constructor receives an integer parameter with the number of elements of the array:</li>
</ol>
<pre class="calibre23">
        public Results(int size){ <br class="title-page-name"/>          data=new int[size]; <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">setData()</kbd> method. This method receives a position in the array and a value as a parameter, and it establishes the value of that position in the array:</li>
</ol>
<pre class="calibre23">
        public void  setData(int position, int value){ <br class="title-page-name"/>          data[position]=value; <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">getData()</kbd> method. This method returns the array with the array of the results:</li>
</ol>
<pre class="calibre23">
        public int[] getData(){ <br class="title-page-name"/>          return data; <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Now that you have the auxiliary classes, it's time to implement threads. First, implement the <kbd class="calibre15">Searcher</kbd> class. This class will look for a number in the determined rows of the matrix of random numbers. Create a class named <kbd class="calibre15">Searcher</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Searcher implements Runnable {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes, namely <kbd class="calibre15">firstRow</kbd> and <kbd class="calibre15">lastRow</kbd>. These two attributes will determine the subset of rows where this object will look for the number:</li>
</ol>
<pre class="calibre23">
        private final int firstRow; <br class="title-page-name"/>        private final int lastRow;
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Declare a private <kbd class="calibre15">MatrixMock</kbd> attribute named <kbd class="calibre15">mock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final MatrixMock mock;
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Declare a private <kbd class="calibre15">Results</kbd> attribute named <kbd class="calibre15">results</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Results results;
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">number</kbd>, which will store the number we are going to look for:</li>
</ol>
<pre class="calibre23">
        private final int number;
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Declare a <kbd class="calibre15">CyclicBarrier</kbd> object named <kbd class="calibre15">barrier</kbd>:</li>
</ol>
<pre class="calibre23">
        private final CyclicBarrier barrier;
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Implement the constructor of the class that initializes all the attributes declared previously:</li>
</ol>
<pre class="calibre23">
        public Searcher(int firstRow, int lastRow, MatrixMock mock,<br class="title-page-name"/>                   Results results, int number, CyclicBarrier barrier){ <br class="title-page-name"/>          this.firstRow=firstRow; <br class="title-page-name"/>          this.lastRow=lastRow; <br class="title-page-name"/>          this.mock=mock; <br class="title-page-name"/>          this.results=results; <br class="title-page-name"/>          this.number=number; <br class="title-page-name"/>          this.barrier=barrier; <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method that will search for the number. It uses an internal variable called <kbd class="calibre15">counter</kbd> that will store the number of occurrences of the number in each row:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          int counter;
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Print a message in the console with the rows assigned to this task:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Processing lines from %d to %d.\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),<br class="title-page-name"/>                          firstRow,lastRow);
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Process all the rows assigned to this thread. For each row, count the number of occurrences of the number you are searching for and store this number in the corresponding position of the <kbd class="calibre15">Results</kbd> object:</li>
</ol>
<pre class="calibre23">
        for (int i=firstRow; i&lt;lastRow; i++){ <br class="title-page-name"/>          int row[]=mock.getRow(i); <br class="title-page-name"/>          counter=0; <br class="title-page-name"/>          for (int j=0; j&lt;row.length; j++){ <br class="title-page-name"/>            if (row[j]==number){ <br class="title-page-name"/>              counter++; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          results.setData(i, counter); <br class="title-page-name"/>        }
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Print a message in the console to indicate that this object has finished searching:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Lines processed.\n",<br class="title-page-name"/>                          Thread.currentThread().getName());
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Call the <kbd class="calibre15">await()</kbd> method of the <kbd class="calibre15">CyclicBarrier</kbd> object and add the necessary code to process the <kbd class="calibre15">InterruptedException</kbd> and <kbd class="calibre15">BrokenBarrierException</kbd> exceptions that this method can throw:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          barrier.await(); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } catch (BrokenBarrierException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Now implement the class that calculates the total number of occurrences of the number in the matrix. This classÂ uses the <kbd class="calibre15">Results</kbd> object that stores the number of appearances of the number in each row of the matrix to make the calculation. Create a class named <kbd class="calibre15">Grouper</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Grouper implements Runnable {
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Declare a private <kbd class="calibre15">Results</kbd> attribute named <kbd class="calibre15">results</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Results results;
</pre>
<ol start="27" class="calibre19">
<li value="27" class="calibre18">Implement the constructor of the class that initializes the <kbd class="calibre15">Results</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public Grouper(Results results){ <br class="title-page-name"/>          this.results=results; <br class="title-page-name"/>        }
</pre>
<ol start="28" class="calibre19">
<li value="28" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method that will calculate the total number of occurrences of the number in the array of results:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="29" class="calibre19">
<li value="29" class="calibre18">Declare an <kbd class="calibre15">int</kbd> variable and write a message to the console to indicate the start of the process:</li>
</ol>
<pre class="calibre23">
        int finalResult=0; <br class="title-page-name"/>        System.out.printf("Grouper: Processing results...\n");
</pre>
<ol start="30" class="calibre19">
<li value="30" class="calibre18">Get the number of occurrences of the number in each row using the <kbd class="calibre15">getData()</kbd> method of the <kbd class="calibre15">results</kbd> object. Then, process all the elements of the array and add their value to the <kbd class="calibre15">finalResult</kbd> variable:</li>
</ol>
<pre class="calibre23">
        int data[]=results.getData(); <br class="title-page-name"/>        for (int number:data){ <br class="title-page-name"/>          finalResult+=number; <br class="title-page-name"/>        }
</pre>
<ol start="31" class="calibre19">
<li value="31" class="calibre18">Print the result in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Grouper: Total result: %d.\n", finalResult);
</pre>
<ol start="32" class="calibre19">
<li value="32" class="calibre18">Finally, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="33" class="calibre19">
<li value="33" class="calibre18">Declare and initialize five constants to store the parameters of the application:</li>
</ol>
<pre class="calibre23">
        final int ROWS=10000; <br class="title-page-name"/>        final int NUMBERS=1000; <br class="title-page-name"/>        final int SEARCH=5;  <br class="title-page-name"/>        final int PARTICIPANTS=5; <br class="title-page-name"/>        final int LINES_PARTICIPANT=2000;
</pre>
<ol start="34" class="calibre19">
<li value="34" class="calibre18">Create a <kbd class="calibre15">MatrixMock</kbd> object named <kbd class="calibre15">mock</kbd>. It will have 10,000 rows of 1,000 elements. Now, you are going to search for the number five:</li>
</ol>
<pre class="calibre23">
        MatrixMock mock=new MatrixMock(ROWS, NUMBERS,SEARCH);
</pre>
<ol start="35" class="calibre19">
<li value="35" class="calibre18">Create a <kbd class="calibre15">Results</kbd> object named <kbd class="calibre15">results</kbd>. It will have 10,000 elements:</li>
</ol>
<pre class="calibre23">
        Results results=new Results(ROWS);
</pre>
<ol start="36" class="calibre19">
<li value="36" class="calibre18">Create a <kbd class="calibre15">Grouper</kbd> object named <kbd class="calibre15">grouper</kbd>:</li>
</ol>
<pre class="calibre23">
        Grouper grouper=new Grouper(results);
</pre>
<ol start="37" class="calibre19">
<li value="37" class="calibre18">Create a <kbd class="calibre15">CyclicBarrier</kbd> object called <kbd class="calibre15">barrier</kbd>. This object will wait for five threads. When these five threads finish, it will execute the <kbd class="calibre15">Grouper</kbd> object created previously:</li>
</ol>
<pre class="calibre23">
        CyclicBarrier barrier=new CyclicBarrier(PARTICIPANTS,grouper);
</pre>
<ol start="38" class="calibre19">
<li value="38" class="calibre18">Create five <kbd class="calibre15">Searcher</kbd> objects, five threads to execute them, and start the five threads:</li>
</ol>
<pre class="calibre23">
        Searcher searchers[]=new Searcher[PARTICIPANTS]; <br class="title-page-name"/>        for (int i=0; i&lt;PARTICIPANTS; i++){ <br class="title-page-name"/>          searchers[i]=new Searcher(i*LINES_PARTICIPANT,<br class="title-page-name"/>                               (i*LINES_PARTICIPANT)+LINES_PARTICIPANT,<br class="title-page-name"/>                               mock, results, 5,barrier); <br class="title-page-name"/>          Thread thread=new Thread(searchers[i]); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("Main: The main thread has finished.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the result of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone11" src="../images/00022.jpeg"/></div>
<p class="calibre4">The problem resolved in the example is simple. We have a big matrix of random integers, and you want to know the total number of occurrences of a number in this matrix. To get better performance, we used the divide and conquer technique. We divided the matrix into five subsets and used a thread to look for the number in each subset. These threads are objects of the <kbd class="calibre15">Searcher</kbd> class.</p>
<p class="calibre4">We used a <kbd class="calibre15">CyclicBarrier</kbd> object to synchronize the completion of the five threads and execute the <kbd class="calibre15">Grouper</kbd> task to process partial results and calculate the final one.</p>
<p class="calibre4">As mentioned earlier, the <kbd class="calibre15">CyclicBarrier</kbd> class has an internal counter to control how many threads need to arrive at the synchronization point. Each time a thread arrives at the synchronization point, it calls the <kbd class="calibre15">await()</kbd> method to notify the <kbd class="calibre15">CyclicBarrier</kbd> object that a thread has arrived at its synchronization point. <kbd class="calibre15">CyclicBarrier</kbd> puts the thread to sleep until all the threads reach the synchronization point.</p>
<p class="calibre4">When all the threads have arrived, the <kbd class="calibre15">CyclicBarrier</kbd> object wakes up all the threads that were waiting in the <kbd class="calibre15">await()</kbd> method. Optionally, it creates a new thread that executes a <kbd class="calibre15">Runnable</kbd> object passed as the parameter in the construction of <kbd class="calibre15">CyclicBarrier</kbd> (in our case, a <kbd class="calibre15">Grouper</kbd> object) to do additional tasks.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">CyclicBarrier</kbd> class has another version of the <kbd class="calibre15">await()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">await(long time, TimeUnit unit)</kbd>: In this method, the thread will continue to sleep until it's interrupted, that is, either the internal counter of <kbd class="calibre15">CyclicBarrier</kbd> arrives at <kbd class="calibre15">0</kbd> or the specified time passes. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>
<p class="calibre4">This class also provides the <kbd class="calibre15">getNumberWaiting()</kbd> method that returns the number of threads that are blocked in the <kbd class="calibre15">await()</kbd> method and the <kbd class="calibre15">getParties()</kbd> method that returns the number of tasks that are going to be synchronized with <kbd class="calibre15">CyclicBarrier</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Resetting a CyclicBarrier object</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">CyclicBarrier</kbd> class has some points in common with the <kbd class="calibre15">CountDownLatch</kbd> class, but they also have some differences. One of the most important differences is that a <kbd class="calibre15">CyclicBarrier</kbd> object can be reset to its initial state, assigning to its internal counter the value with which it was initialized.</p>
<p class="calibre4">This reset operation can be done using the <kbd class="calibre15">reset()</kbd> method of the <kbd class="calibre15">CyclicBarrier</kbd> class. When this occurs, all the threads that were waiting in the <kbd class="calibre15">await()</kbd> method receive a <kbd class="calibre15">BrokenBarrierException</kbd> exception. This exception was processed in the example presented in this recipe by printing the stack trace; however, in a more complex application, it could perform some other operation, such as restarting the execution or recovering the operation at the point it was interrupted.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Broken CyclicBarrier objects</h1>
            

            <article>
                
<p class="calibre4">A <kbd class="calibre15">CyclicBarrier</kbd> object can be in a special state denoted by the broken state. When there are various threads waiting in the <kbd class="calibre15">await()</kbd> method and one of them is interrupted, the one that is interrupted receives an <kbd class="calibre15">InterruptedException</kbd> exception, but other threads receive a <kbd class="calibre15">BrokenBarrierException</kbd> exception; <kbd class="calibre15">CyclicBarrier</kbd> is placed in the broken state.</p>
<p class="calibre4">The <kbd class="calibre15">CyclicBarrier</kbd> class provides the <kbd class="calibre15">isBroken()</kbd> method. It returns <kbd class="calibre15">true</kbd> if the object is in the broken state; otherwise, it returns <kbd class="calibre15">false</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Waiting for multiple concurrent events</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running concurrent-phased tasks</h1>
            

            <article>
                
<p class="calibre4">One of the most complex and powerful functionalities offered by the Java concurrency API is the ability to execute concurrent-phased tasks using the <kbd class="calibre15">Phaser</kbd> class. This mechanism is useful when we have some concurrent tasks divided into steps. The <kbd class="calibre15">Phaser</kbd> class provides us with a mechanism to synchronize threads at the end of each step, so no thread will start with the second step until all the threads have finished the first one.</p>
<p class="calibre4">As with other synchronization utilities, we have to initialize the <kbd class="calibre15">Phaser</kbd> class with the number of tasks that participate in the synchronization operation, but we can dynamically modify this number by either increasing or decreasing it.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">Phaser</kbd> class to synchronize three concurrent tasks. The three tasks look for files with the extension <kbd class="calibre15">.log</kbd> modified in the last 24 hours in three different folders and their subfolders. This task is divided into three steps:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Get a list of the files with the extension <kbd class="calibre15">.log</kbd> in the assigned folder and its subfolders.</li>
<li value="2" class="calibre18">Filter the list created in the first step by deleting the files modified more than 24 hours ago.</li>
<li value="3" class="calibre18">Print the results in the console.</li>
</ol>
<p class="calibre4">At the end of step 1 and step 2, we check whether the list has any elements or not. If it doesn't, the thread ends its execution and is eliminated from the <kbd class="calibre15">Phaser</kbd> class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">FileSearch</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class implements the operation of searching for files with a determined extension modified in the last 24 hours in a folder and its subfolders:</li>
</ol>
<pre class="calibre23">
        public class FileSearch implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute to store the folder in which the search operation will begin:</li>
</ol>
<pre class="calibre23">
        private final String initPath;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare another private <kbd class="calibre15">String</kbd> attribute to store the extension of the files we are going to look for:</li>
</ol>
<pre class="calibre23">
        private final String fileExtension
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Declare a private <kbd class="calibre15">List</kbd> attribute to store the full path of the files we will find with the desired characteristics:</li>
</ol>
<pre class="calibre23">
        private List&lt;String&gt; results;
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Finally, declare a private <kbd class="calibre15">Phaser</kbd> attribute to control the synchronization of the different phases of the task:</li>
</ol>
<pre class="calibre23">
        private Phaser phaser;
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Next, implement the constructor of the class that will initialize the attributes of the class. It receives the full path of the initial folder as parameters, the extension of the files, and <kbd class="calibre15">phaser</kbd>:</li>
</ol>
<pre class="calibre23">
        public FileSearch(String initPath, String fileExtension,<br class="title-page-name"/>                          Phaser phaser) { <br class="title-page-name"/>          this.initPath = initPath; <br class="title-page-name"/>          this.fileExtension = fileExtension; <br class="title-page-name"/>          this.phaser=phaser; <br class="title-page-name"/>          results=new ArrayList&lt;&gt;(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Now, implement some auxiliary methods that will be used by the <kbd class="calibre15">run()</kbd> method. The first one is the <kbd class="calibre15">directoryProcess()</kbd> method. It receives a <kbd class="calibre15">File</kbd> object as a parameter and it processes all its files and subfolders. For each folder, the method will make a recursive call while passing the folder as a parameter. For each file, the method will call the <kbd class="calibre15">fileProcess()</kbd> method:</li>
</ol>
<pre class="calibre23">
        private void directoryProcess(File file) { <br class="title-page-name"/> <br class="title-page-name"/>          File list[] = file.listFiles(); <br class="title-page-name"/>          if (list != null) { <br class="title-page-name"/>            for (int i = 0; i &lt; list.length; i++) { <br class="title-page-name"/>              if (list[i].isDirectory()) { <br class="title-page-name"/>                directoryProcess(list[i]); <br class="title-page-name"/>              } else { <br class="title-page-name"/>                fileProcess(list[i]); <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, implement the <kbd class="calibre15">fileProcess()</kbd> method. It receives a <kbd class="calibre15">File</kbd> object as a parameter and checks whether its extension is equal to the one we are looking for. If they are equal, this method adds the absolute path of the file to the list of results:</li>
</ol>
<pre class="calibre23">
        private void fileProcess(File file) { <br class="title-page-name"/>          if (file.getName().endsWith(fileExtension)) { <br class="title-page-name"/>            results.add(file.getAbsolutePath()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now implement the <kbd class="calibre15">filterResults()</kbd> method. It doesn't receive any parameter and filters the list of files obtained in the first phase; it deletes files that were modified more than 24 hours ago. First, create a new empty list and get the actual date:</li>
</ol>
<pre class="calibre23">
        private void filterResults() { <br class="title-page-name"/>          List&lt;String&gt; newResults=new ArrayList&lt;&gt;(); <br class="title-page-name"/>          long actualDate=new Date().getTime();
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, go through all the elements of the results list. For each path in the list of results, create a <kbd class="calibre15">File</kbd> object for the file and get its last modified date:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;results.size(); i++){ <br class="title-page-name"/>          File file=new File(results.get(i)); <br class="title-page-name"/>          long fileDate=file.lastModified();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Then, compare this date with the actual date, and if the difference is less than 1 day, add the full path of the file to the new list of results:</li>
</ol>
<pre class="calibre23">
          if (actualDate-fileDate&lt; TimeUnit.MILLISECONDS<br class="title-page-name"/>                                        .convert(1,TimeUnit.DAYS)){ <br class="title-page-name"/>            newResults.add(results.get(i)); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Finally, change the old results list to the new ones:</li>
</ol>
<pre class="calibre23">
          results=newResults; <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Next, implement the <kbd class="calibre15">checkResults()</kbd> method. This method will be called at the end of the first and second phase, and it will check whether the results list is empty or not. This method doesn't have any parameters:</li>
</ol>
<pre class="calibre23">
        private boolean checkResults() {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">First, check the size of the results list. If it's 0, the object writes a message to the console indicating this. After this, it calls the <kbd class="calibre15">arriveAndDeregister()</kbd> method of the <kbd class="calibre15">Phaser</kbd> object to notify that this thread has finished the actual phase and it leaves the phased operation:</li>
</ol>
<pre class="calibre23">
        if (results.isEmpty()) { <br class="title-page-name"/>          System.out.printf("%s: Phase %d: 0 results.\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            phaser.getPhase()); <br class="title-page-name"/>          System.out.printf("%s: Phase %d: End.\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            phaser.getPhase()); <br class="title-page-name"/>          phaser.arriveAndDeregister(); <br class="title-page-name"/>          return false;
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">If the results list has elements, the object writes a message to the console indicating this. Then, it calls the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of the <kbd class="calibre15">Phaser</kbd> object to notify that this thread has finished the actual phase and it wants to be blocked until all the participant threads in the phased operation finish the actual phase:</li>
</ol>
<pre class="calibre23">
          } else { <br class="title-page-name"/>            System.out.printf("%s: Phase %d: %d results.\n",<br class="title-page-name"/>                              Thread.currentThread().getName(),<br class="title-page-name"/>                              phaser.getPhase(),results.size()); <br class="title-page-name"/>            phaser.arriveAndAwaitAdvance(); <br class="title-page-name"/>            return true; <br class="title-page-name"/>          }<br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">The last auxiliary method is the <kbd class="calibre15">showInfo()</kbd> method that prints the elements of the results list to the console:</li>
</ol>
<pre class="calibre23">
        private void showInfo() { <br class="title-page-name"/>          for (int i=0; i&lt;results.size(); i++){ <br class="title-page-name"/>            File file=new File(results.get(i)); <br class="title-page-name"/>            System.out.printf("%s: %s\n",<br class="title-page-name"/>                               Thread.currentThread().getName(),<br class="title-page-name"/>                               file.getAbsolutePath()); <br class="title-page-name"/>          } <br class="title-page-name"/>          phaser.arriveAndAwaitAdvance(); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">It's time to implement the <kbd class="calibre15">run()</kbd> method that executes the operation using the auxiliary methods described earlier. We'll also implement the <kbd class="calibre15">Phaser</kbd> object to control the change between phases. First, call the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of the <kbd class="calibre15">Phaser</kbd> object. The search won't begin until all the threads have been created:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          phaser.arriveAndAwaitAdvance();
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Then, write a message to the console indicating the start of the search task:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Starting.\n",<br class="title-page-name"/>                          Thread.currentThread().getName());
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Check that the <kbd class="calibre15">initPath</kbd> attribute stores the name of a folder and use the <kbd class="calibre15">directoryProcess()</kbd> method to find the files with the specified extension in that folder and all its subfolders:</li>
</ol>
<pre class="calibre23">
        File file = new File(initPath); <br class="title-page-name"/>        if (file.isDirectory()) { <br class="title-page-name"/>          directoryProcess(file); <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Check whether there are any results using the <kbd class="calibre15">checkResults()</kbd> method. If there are no results, finish the execution of the thread with the <kbd class="calibre15">return</kbd> keyword:</li>
</ol>
<pre class="calibre23">
        if (!checkResults()){ <br class="title-page-name"/>          return; <br class="title-page-name"/>        }
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Filter the list of results using the <kbd class="calibre15">filterResults()</kbd> method:</li>
</ol>
<pre class="calibre23">
        filterResults();
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Check whether there are any results using the <kbd class="calibre15">checkResults()</kbd> method once again. If there are no results, finish the execution of the thread with the <kbd class="calibre15">return</kbd> keyword:</li>
</ol>
<pre class="calibre23">
        if (!checkResults()){ <br class="title-page-name"/>          return; <br class="title-page-name"/>        }
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Print the final list of results to the console with the <kbd class="calibre15">showInfo()</kbd> method, deregister the thread, and print a message indicating the finalization of the thread:</li>
</ol>
<pre class="calibre23">
        showInfo(); <br class="title-page-name"/>        phaser.arriveAndDeregister(); <br class="title-page-name"/>        System.out.printf("%s: Work completed.\n",<br class="title-page-name"/>                          Thread.currentThread().getName());
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Now, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Create a <kbd class="calibre15">Phaser</kbd> object with three participants:</li>
</ol>
<pre class="calibre23">
        Phaser phaser=new Phaser(3);
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Create three <kbd class="calibre15">FileSearch</kbd> objects with a different initial folder for each one. Look for the files with the <kbd class="calibre15">.log</kbd> extension:</li>
</ol>
<pre class="calibre23">
        FileSearch system=new FileSearch("C:\\Windows", "log", phaser); <br class="title-page-name"/>        FileSearch apps= new FileSearch("C:\\Program Files",<br class="title-page-name"/>                                        "log",phaser); <br class="title-page-name"/>        FileSearch documents= new FileSearch("C:\\Documents And Settings",<br class="title-page-name"/>                                             "log",phaser);
</pre>
<ol start="27" class="calibre19">
<li value="27" class="calibre18">Create and start a thread to execute the first <kbd class="calibre15">FileSearch</kbd> object:</li>
</ol>
<pre class="calibre23">
        Thread systemThread=new Thread(system,"System"); <br class="title-page-name"/>        systemThread.start();
</pre>
<ol start="28" class="calibre19">
<li value="28" class="calibre18">Create and start a thread to execute the second <kbd class="calibre15">FileSearch</kbd> object:</li>
</ol>
<pre class="calibre23">
        Thread appsThread=new Thread(apps,"Apps"); <br class="title-page-name"/>        appsThread.start();
</pre>
<ol start="29" class="calibre19">
<li value="29" class="calibre18">Create and start a thread to execute the third <kbd class="calibre15">FileSearch</kbd> object:</li>
</ol>
<pre class="calibre23">
        Thread documentsThread=new Thread(documents, "Documents"); <br class="title-page-name"/>        documentsThread.start();
</pre>
<ol start="30" class="calibre19">
<li value="30" class="calibre18">Wait for the finalization of the three threads:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          systemThread.join(); <br class="title-page-name"/>          appsThread.join(); <br class="title-page-name"/>          documentsThread.join(); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="31" class="calibre19">
<li value="31" class="calibre18">Write the value of the finalized flag of the <kbd class="calibre15">Phaser</kbd> object using the <kbd class="calibre15">isFinalized()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.println("Terminated: "+ phaser.isTerminated());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The program starts creating a <kbd class="calibre15">Phaser</kbd> object that will control the synchronization of the threads at the end of each phase. The constructor of <kbd class="calibre15">Phaser</kbd> receives the number of participants as a parameter. In our case, <kbd class="calibre15">Phaser</kbd> has three participants. This number indicates <kbd class="calibre15">Phaser</kbd> the number of threads that need to execute the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method before <kbd class="calibre15">Phaser</kbd> could change the phase and wake up the threads that have been sleeping.</p>
<p class="calibre4">Once <kbd class="calibre15">Phaser</kbd> has been created, we launch three threads that are executed using three different <kbd class="calibre15">FileSearch</kbd> objects.</p>
<div class="packt_infobox">In this example, we use paths of the Windows operating system. If you work with another operating system, modify the paths to adapt them to existing paths in your environment, such as <kbd class="calibre25">/var/log</kbd>, or similar.</div>
<p class="calibre4">The first instruction in the <kbd class="calibre15">run()</kbd> method of this <kbd class="calibre15">FileSearch</kbd> object is a call to the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of the <kbd class="calibre15">Phaser</kbd> object. As mentioned earlier, <kbd class="calibre15">Phaser</kbd> knows the number of threads that we want to synchronize. When a thread calls this method, <kbd class="calibre15">Phaser</kbd> decreases the number of threads that have to finalize the actual phase and puts this thread to sleep until all the remaining threads finish this phase. Calling this method at the beginning of the <kbd class="calibre15">run()</kbd> method ensures that none of the <kbd class="calibre15">FileSearch</kbd> threads begin their job until all the threads are created.</p>
<p class="calibre4">At the end of phase one and phase two, we check whether the phase has generated results and the list with the results has elements or the phase hasn't generated results and the list is empty. In the first case, the <kbd class="calibre15">checkResults()</kbd> method calls <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> as explained earlier. In the second case, if the list is empty, there's no point in the thread continuing with its execution, so it ends its execution. But you have to notify the <kbd class="calibre15">Phaser</kbd> object that there will be one less participant. For this, we used <kbd class="calibre15">arriveAndDeregister()</kbd>. This notifies <kbd class="calibre15">phaser</kbd> that the thread has finished the actual phase, but it won't participate in future phases, therefore, <kbd class="calibre15">phaser</kbd> won't have to wait for it to continue.</p>
<p class="calibre4">At the end of the phase three implemented in the <kbd class="calibre15">showInfo()</kbd> method, there is a call to the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of <kbd class="calibre15">phaser</kbd>. With this call, we guarantee that all the threads finish at the same time. When this method ends its execution, there is a call to the <kbd class="calibre15">arriveAndDeregister()</kbd> method of <kbd class="calibre15">phaser</kbd>. With this call, we deregister the threads of <kbd class="calibre15">phaser</kbd>, as explained before, so when all the threads finish, <kbd class="calibre15">phaser</kbd> will have zero participants.</p>
<p class="calibre4">Finally, the <kbd class="calibre15">main()</kbd> method waits for the completion of the three threads and calls the <kbd class="calibre15">isTerminated()</kbd> method of <kbd class="calibre15">phaser</kbd>. When <kbd class="calibre15">phaser</kbd> has zero participants, it enters the so-called termination state, and this method returns <kbd class="calibre15">true</kbd>. As we deregister all the threads of <kbd class="calibre15">phaser</kbd>, it will be in the termination state, and this call will print <kbd class="calibre15">true</kbd> to the console.</p>
<p class="calibre4">A <kbd class="calibre15">Phaser</kbd> object can be in two states:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Active</strong>: <kbd class="calibre15">Phaser</kbd> enters this state when it accepts the registration of new participants and its synchronization at the end of each phase. In this state, <kbd class="calibre15">Phaser</kbd> works as it has been explained in this recipe. This state is not mentioned in the Java concurrency API.</li>
<li class="calibre18"><strong class="calibre1">Termination</strong>: By default, <kbd class="calibre15">Phaser</kbd> enters this state when all the participants in <kbd class="calibre15">Phaser</kbd> have been deregistered, which means it has zero participants. Further, <kbd class="calibre15">Phaser</kbd> is in the termination state when the method <kbd class="calibre15">onAdvance()</kbd> returns <kbd class="calibre15">true</kbd>. If you override this method, you can change the default behavior. When <kbd class="calibre15">Phaser</kbd> is in this state, the synchronization method <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> returns immediately without doing any synchronization operation.</li>
</ul>
<p class="calibre4">A notable feature of the <kbd class="calibre15">Phaser</kbd> class is that you haven't had to control any exception from the methods related to <kbd class="calibre15">phaser</kbd>. Unlike other synchronization utilities, threads that are sleeping in <kbd class="calibre15">phaser</kbd> don't respond to interruption events and don't throw an <kbd class="calibre15">InterruptedException</kbd> exception. There is only one exception, which is explained in the next section.</p>
<p class="calibre4">The following screenshot shows the results of one execution of the example:</p>
<div class="cdpaligncenter"><img class="alignnone12" src="../images/00023.jpeg"/></div>
<p class="calibre4">It shows the first two phases of the execution. You can see how the <kbd class="calibre15">Apps</kbd> thread finishes its execution in phase two because its results list is empty. When you execute the example, you will see how some threads finish a phase before the rest and how they wait until all have finished one phase before continuing with the rest.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Phaser</kbd> class provides other methods related to the change of phase. These methods are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">arrive()</kbd>: This method notifies the <kbd class="calibre15">Phaser</kbd> class that one participant has finished the actual phase but it should not wait for the rest of the participants to continue with their execution. Be careful with the utilization of this method because it doesn't synchronize with other threads.</li>
<li class="calibre18"><kbd class="calibre15">awaitAdvance(int phase)</kbd>: This method puts the current thread to sleep until all the participants of the <kbd class="calibre15">phaser</kbd> parameter have finished the current phase, that is, if the number we pass as the parameter is equal to the actual phase of <kbd class="calibre15">phaser</kbd>. If the parameter and the actual phase of <kbd class="calibre15">phaser</kbd> aren't equal, the method Â ends its execution.</li>
<li class="calibre18"><kbd class="calibre15">awaitAdvanceInterruptibly(int phaser)</kbd>: This method is equal to the method explained earlier, but it throws an <kbd class="calibre15">InterruptedException</kbd> exception if the thread that is sleeping in this method is interrupted.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Registering participants in Phaser</h1>
            

            <article>
                
<p class="calibre4">When you create a <kbd class="calibre15">Phaser</kbd> object, you indicate how many participants will have that <kbd class="calibre15">phaser</kbd>. But the <kbd class="calibre15">Phaser</kbd> class has two methods to increment the number of participants of <kbd class="calibre15">phaser</kbd>. These methods are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">register()</kbd>: This method adds a new participant to <kbd class="calibre15">Phaser</kbd>. This new participant will be considered unarrived to the actual phase.</li>
<li class="calibre18"><kbd class="calibre15">bulkRegister(int Parties)</kbd>: This method adds the specified number of participants to <kbd class="calibre15">phaser</kbd>. These new participants will be considered unarrived to the actual phase.</li>
</ul>
<p class="calibre4">The only method provided by the <kbd class="calibre15">Phaser</kbd> class to decrement the number of participants is the <kbd class="calibre15">arriveAndDeregister()</kbd> method that notifies <kbd class="calibre15">phaser</kbd> that the thread has finished the actual phase and it doesn't want to continue with the phased operation.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Forcing the termination of Phaser</h1>
            

            <article>
                
<p class="calibre4">When <kbd class="calibre15">phaser</kbd> has zero participants, it enters a state denoted by termination. The <kbd class="calibre15">Phaser</kbd> class provides <kbd class="calibre15">forceTermination()</kbd> to change the status of <kbd class="calibre15">phaser</kbd> and makes it enter the termination state independently of the number of participants registered in <kbd class="calibre15">phaser</kbd>. This mechanism may be useful when one of the participants has an error situation, where the best thing to do would be to terminate <kbd class="calibre15">phaser</kbd>.</p>
<p class="calibre4">When <kbd class="calibre15">phaser</kbd> is in the termination state, the <kbd class="calibre15">awaitAdvance()</kbd> and <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> methods immediately return a negative number, instead of a positive one that is returned normally. If you know that your <kbd class="calibre15">phaser</kbd> could be terminated, you should verify the return value of those methods (<kbd class="calibre15">awaitAdvance()</kbd> and <kbd class="calibre15">arriveAndAwaitAdvance()</kbd>) to know whether <kbd class="calibre15">phaser</kbd> has been terminated.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Monitoring a Phaser class</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Controlling phase change in concurrent-phased tasks</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Phaser</kbd> class provides a method that is executed each time <kbd class="calibre15">phaser</kbd> changes the phase. It's the <kbd class="calibre15">onAdvance()</kbd> method. It receives two parameters: the number of the current phases and the number of registered participants. It returns a Boolean value <kbd class="calibre15">false</kbd> if <kbd class="calibre15">Phaser</kbd> continues its execution or the value <kbd class="calibre15">true</kbd> if <kbd class="calibre15">Phaser</kbd> has finished and has to enter the termination state.</p>
<p class="calibre4">The default implementation of this method returns <kbd class="calibre15">true</kbd> if the number of registered participants is zero, and <kbd class="calibre15">false</kbd> otherwise. But you can modify this behavior if you extend the <kbd class="calibre15">Phaser</kbd> class and override this method. Normally, you will be interested in doing this when you have to execute some actions when you advance from one phase to the next.</p>
<p class="calibre4">In this recipe, you will learn how to control phase change in a phaser that is implementing your own version of the <kbd class="calibre15">Phaser</kbd> class that overrides the <kbd class="calibre15">onAdvance()</kbd> method to execute some actions in every phase change. You are going to implement a simulation of an exam, where there will be some students who have to do three exercises. All the students have to finish one exercise before they proceed with the next one.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyPhaser</kbd> and specify that it extends from the <kbd class="calibre15">Phaser</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyPhaser extends Phaser {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Override the <kbd class="calibre15">onAdvance()</kbd> method. According to the value of the <kbd class="calibre15">phase</kbd> attribute, we call it a different auxiliary method. If the <kbd class="calibre15">phase</kbd> attribute is equal to zero, you have to call the <kbd class="calibre15">studentsArrived()</kbd> method. If the <kbd class="calibre15">phase</kbd> is equal to one, you have to call the <kbd class="calibre15">finishFirstExercise()</kbd> method. If the phase is equal to two, you have to call the <kbd class="calibre15">finishSecondExercise()</kbd> method. Finally, if the phase is equal to three, you have to call the <kbd class="calibre15">finishExam()</kbd> method. Otherwise, return the true value to indicate that <kbd class="calibre15">phaser</kbd> has terminated:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected boolean onAdvance(int phase, int registeredParties) { <br class="title-page-name"/>          switch (phase) { <br class="title-page-name"/>            case 0: <br class="title-page-name"/>              return studentsArrived(); <br class="title-page-name"/>            case 1: <br class="title-page-name"/>              return finishFirstExercise(); <br class="title-page-name"/>            case 2: <br class="title-page-name"/>              return finishSecondExercise(); <br class="title-page-name"/>            case 3: <br class="title-page-name"/>              return finishExam(); <br class="title-page-name"/>            default: <br class="title-page-name"/>              return true; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the auxiliary method <kbd class="calibre15">studentsArrived()</kbd>. It writes two log messages to the console and returns false to indicate that <kbd class="calibre15">phaser</kbd> is continuing with its execution:</li>
</ol>
<pre class="calibre23">
        private boolean studentsArrived() { <br class="title-page-name"/>          System.out.printf("Phaser: The exam are going to start.<br class="title-page-name"/>                             The students are ready.\n"); <br class="title-page-name"/>          System.out.printf("Phaser: We have %d students.\n",<br class="title-page-name"/>                            getRegisteredParties()); <br class="title-page-name"/>          return false; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the auxiliary method <kbd class="calibre15">finishFirstExercise()</kbd>. It writes two messages to the console and returns false to indicate that <kbd class="calibre15">phaser</kbd> is continuing with its execution:</li>
</ol>
<pre class="calibre23">
        private boolean finishFirstExercise() { <br class="title-page-name"/>          System.out.printf("Phaser: All the students have finished the<br class="title-page-name"/>                             first exercise.\n"); <br class="title-page-name"/>          System.out.printf("Phaser: It's time for the second one.\n"); <br class="title-page-name"/>          return false; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the auxiliary method <kbd class="calibre15">finishSecondExercise()</kbd>. It writes two messages to the console and returns false to indicate that <kbd class="calibre15">phaser</kbd> is continuing with its execution:</li>
</ol>
<pre class="calibre23">
        private boolean finishSecondExercise() { <br class="title-page-name"/>          System.out.printf("Phaser: All the students have finished the<br class="title-page-name"/>                             second exercise.\n"); <br class="title-page-name"/>          System.out.printf("Phaser: It's time for the third one.\n"); <br class="title-page-name"/>          return false; <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the auxiliary method <kbd class="calibre15">finishExam()</kbd>. It writes two messages to the console and returns true to indicate that <kbd class="calibre15">phaser</kbd> has finished its work:</li>
</ol>
<pre class="calibre23">
        private boolean finishExam() { <br class="title-page-name"/>          System.out.printf("Phaser: All the students have finished<br class="title-page-name"/>                             the exam.\n"); <br class="title-page-name"/>          System.out.printf("Phaser: Thank you for your time.\n"); <br class="title-page-name"/>          return true; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">Student</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class will simulate the students of an exam:</li>
</ol>
<pre class="calibre23">
        public class Student implements Runnable {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a <kbd class="calibre15">Phaser</kbd> object named <kbd class="calibre15">phaser</kbd>:</li>
</ol>
<pre class="calibre23">
        private Phaser phaser;
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class that initializes the <kbd class="calibre15">Phaser</kbd> object:</li>
</ol>
<pre class="calibre23">
        public Student(Phaser phaser) { <br class="title-page-name"/>          this.phaser=phaser; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method that will simulate the realization of the exam:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">First, the method writes a message in the console to indicate that a student has arrived at the exam hall and calls the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of <kbd class="calibre15">phaser</kbd> to wait for the rest of the threads:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Has arrived to do the exam. %s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),new Date()); <br class="title-page-name"/>        phaser.arriveAndAwaitAdvance();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Then, write a message to the console and call the private <kbd class="calibre15">doExercise1()</kbd> method that simulates the realization of the first exercise of the exam. Post this, write another message to the console and the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of <kbd class="calibre15">phaser</kbd> to wait for the rest of the students to finish the first exercise:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Is going to do the first exercise.%s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),new Date()); <br class="title-page-name"/>        doExercise1(); <br class="title-page-name"/>        System.out.printf("%s: Has done the first exercise.%s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),new Date()); <br class="title-page-name"/>        phaser.arriveAndAwaitAdvance();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the same code for the second and third exercises:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Is going to do the second exercise. <br class="title-page-name"/>                          %s\n",Thread.currentThread().getName(),<br class="title-page-name"/>                          new Date()); <br class="title-page-name"/>        doExercise2(); <br class="title-page-name"/>        System.out.printf("%s: Has done the second exercise.%s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),new Date()); <br class="title-page-name"/>        phaser.arriveAndAwaitAdvance(); <br class="title-page-name"/>        System.out.printf("%s: Is going to do the third exercise.%s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),new Date()); <br class="title-page-name"/>        doExercise3(); <br class="title-page-name"/>        System.out.printf("%s: Has finished the exam.%s\n",<br class="title-page-name"/>                          Thread.currentThread().getName(),new Date()); <br class="title-page-name"/>        phaser.arriveAndAwaitAdvance();
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the auxiliary method <kbd class="calibre15">doExercise1()</kbd>. This method putsÂ the current thread or the thread that executes the method toÂ <span>sleep for a random period of time:</span></li>
</ol>
<pre class="calibre23">
        private void doExercise1() { <br class="title-page-name"/>          try { <br class="title-page-name"/>            long duration=(long)(Math.random()*10); <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the auxiliary method <kbd class="calibre15">doExercise2()</kbd>. This method puts the current thread or the thread that executes the method to sleep for a random period of time:</li>
</ol>
<pre class="calibre23">
        private void doExercise2() { <br class="title-page-name"/>          try { <br class="title-page-name"/>            long duration=(long)(Math.random()*10); <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the auxiliary method <kbd class="calibre15">doExercise3()</kbd>. This method puts the thread to sleep for a random period of time:</li>
</ol>
<pre class="calibre23">
        private void doExercise3() { <br class="title-page-name"/>          try { <br class="title-page-name"/>            long duration=(long)(Math.random()*10); <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(duration); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a <kbd class="calibre15">MyPhaser</kbd> object:</li>
</ol>
<pre class="calibre23">
        MyPhaser phaser=new MyPhaser();
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create five <kbd class="calibre15">Student</kbd> objects and register them in the <kbd class="calibre15">phaser</kbd> attribute using the <kbd class="calibre15">register()</kbd> method:</li>
</ol>
<pre class="calibre23">
        Student students[]=new Student[5]; <br class="title-page-name"/>        for (int i=0; i&lt;students.length; i++){ <br class="title-page-name"/>          students[i]=new Student(phaser); <br class="title-page-name"/>          phaser.register(); <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create five threads to run students and start them:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[students.length]; <br class="title-page-name"/>        for (int i=0; i&lt;students.length; i++){ <br class="title-page-name"/>          threads[i]=new Thread(students[i],"Student "+i); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Wait for the finalization of the five threads:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Write a message to show that <kbd class="calibre15">phaser</kbd> is in the termination state, using the <kbd class="calibre15">isTerminated()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: The phaser has finished: %s.\n",<br class="title-page-name"/>                          phaser.isTerminated());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">This exercise simulates the realization of an exam that has three exercises. All the students have to finish one exercise before they can start the next one. To implement this synchronization requirement, we use the <kbd class="calibre15">Phaser</kbd> class; however, in this case, you implemented your own <kbd class="calibre15">phaser</kbd>, extending the original class to override the <kbd class="calibre15">onAdvance()</kbd> method.</p>
<p class="calibre4">This method is called by <kbd class="calibre15">Phaser</kbd> before making a phase change and waking up all the threads that were sleeping in the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method. The method is invoked by the last thread that finishes a phase as part of the code of the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method. This method receives the number of the actual phase as parameters, where 0 is the number of the first phase and the number of registered participants. The most useful parameter is the actual phase. If you execute a different operation depending on the actual phase, you have to use an alternative structure (<kbd class="calibre15">if...else</kbd> or <kbd class="calibre15">switch</kbd>) to select the operation you want to execute. In the example, we used a <kbd class="calibre15">switch</kbd> structure to select a different method for each change of phase.</p>
<p class="calibre4">The <kbd class="calibre15">onAdvance()</kbd> method returns a Boolean value that indicates whether <kbd class="calibre15">phaser</kbd> has terminated or not. If <kbd class="calibre15">phaser</kbd> returns false, it indicates that it hasn't terminated; if this happens, the threads will continue with the execution of other phases. If <kbd class="calibre15">phaser</kbd> returns <kbd class="calibre15">true</kbd>, then <kbd class="calibre15">phaser</kbd> still wakes up the pending threads but moves <kbd class="calibre15">phaser</kbd> to the terminated state. With this, all future calls to any method of <kbd class="calibre15">phaser</kbd> will return immediately, and the <kbd class="calibre15">isTerminated()</kbd> method will return <kbd class="calibre15">true</kbd>.</p>
<p class="calibre4">In the <kbd class="calibre15">Main</kbd> class, when you created the <kbd class="calibre15">MyPhaser</kbd> object, you didn't specify the number of participants in the phaser. You made a call to the <kbd class="calibre15">register()</kbd> method for every <kbd class="calibre15">Student</kbd> object created to register a participant in <kbd class="calibre15">phaser</kbd>. This calling doesn't establish a relation between the <kbd class="calibre15">Student</kbd> object or the thread that executes it and <kbd class="calibre15">phaser</kbd>. Really, the number of participants in a phaser is only a number. There is no relationship between <kbd class="calibre15">phaser</kbd> and the participants.</p>
<p class="calibre4">The following screenshot shows the results of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone13" src="../images/00024.jpeg"/></div>
<p class="calibre4">You can see how the students finished the first exercise at different times. When all of them finish the first exercise, <kbd class="calibre15">phaser</kbd> calls the <kbd class="calibre15">onAdvance()</kbd> method that writes the log messages in the console, then all the students start the second exercise at the same time.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Running concurrent-phased tasks</em> recipe in this chapter</li>
<li class="calibre18">The <em class="calibre14">Monitoring a Phaser class</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Exchanging data between concurrent tasks</h1>
            

            <article>
                
<p class="calibre4">The Java concurrency API provides a synchronization utility that allows interchange of data between two concurrent tasks. In more detail, the <kbd class="calibre15">Exchanger</kbd> class allows you to have a definition of a synchronization point between two threads. When the two threads arrive at this point, they interchange a data structure such that the data structure of the first thread goes to the second one and vice versa.</p>
<p class="calibre4">This class may be very useful in a situation similar to the producer-consumer problem. This is a classic concurrent problem where you have a common buffer of data, one or more producers of data, and one or more consumers of data. As the <kbd class="calibre15">Exchanger</kbd> class synchronizes only two threads, you can use it if you have a producer-consumer problem with one producer and one consumer.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">Exchanger</kbd> class to solve the producer-consumer problem with one producer and one consumer.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, begin by implementing the producer. Create a class named <kbd class="calibre15">Producer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Producer implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a <kbd class="calibre15">List&lt;String&gt;</kbd> field named <kbd class="calibre15">buffer</kbd>. This will be the data structure that the producer will interchange with the consumer:</li>
</ol>
<pre class="calibre23">
        private List&lt;String&gt; buffer;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare an <kbd class="calibre15">Exchanger&lt;List&lt;String&gt;&gt;</kbd> field named <kbd class="calibre15">exchanger</kbd>. This will be the exchanger object that will be used to synchronize the producer and consumer:</li>
</ol>
<pre class="calibre23">
        private final Exchanger&lt;List&lt;String&gt;&gt; exchanger;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class that will initialize the two attributes:</li>
</ol>
<pre class="calibre23">
        public Producer (List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt;<br class="title-page-name"/>                         exchanger){ <br class="title-page-name"/>          this.buffer=buffer; <br class="title-page-name"/>          this.exchanger=exchanger; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Inside it, implement 10 cycles of interchange:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int cycle = 1; cycle &lt;= 10; cycle++){ <br class="title-page-name"/>            System.out.printf("Producer: Cycle %d\n",cycle);
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">In each cycle, add 10 strings to the buffer:</li>
</ol>
<pre class="calibre23">
        for (int j=0; j&lt;10; j++){ <br class="title-page-name"/>          String message="Event "+(((cycle-1)*10)+j); <br class="title-page-name"/>          System.out.printf("Producer: %s\n",message); <br class="title-page-name"/>          buffer.add(message); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Call the <kbd class="calibre15">exchange()</kbd> method to interchange data with the consumer. As this method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, you have to add some code to process it.</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          buffer=exchanger.exchange(buffer); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>          System.out.println("Producer: "+buffer.size()); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Now, implement the consumer. Create a class named <kbd class="calibre15">Consumer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Consumer implements Runnable {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a <kbd class="calibre15">List&lt;String&gt;</kbd> field named <kbd class="calibre15">buffer</kbd>. This will be the data structure that the producer will interchange with the consumer:</li>
</ol>
<pre class="calibre23">
        private List&lt;String&gt; buffer;
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare an <kbd class="calibre15">Exchanger&lt;List&lt;String&gt;&gt;</kbd> field named <kbd class="calibre15">exchanger</kbd>. This will be the <kbd class="calibre15">exchanger</kbd> object that will be used to synchronize the producer and consumer:</li>
</ol>
<pre class="calibre23">
        private final Exchanger&lt;List&lt;String&gt;&gt; exchanger;
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the constructor of the class that will initialize the two attributes:</li>
</ol>
<pre class="calibre23">
        public Consumer(List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt;<br class="title-page-name"/>                        exchanger){ <br class="title-page-name"/>          this.buffer=buffer; <br class="title-page-name"/>          this.exchanger=exchanger; <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Inside it, implement 10 cycles of interchange:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int cycle=1; cycle &lt;= 10; cycle++){ <br class="title-page-name"/>            System.out.printf("Consumer: Cycle %d\n",cycle);
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">In each cycle, begin with a call to the <kbd class="calibre15">exchange()</kbd> method to synchronize with the producer. The consumer needs data to consume. As this method can throw an <kbd class="calibre15">InterruptedException</kbd> exception, you have to add some code to process it:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          buffer=exchanger.exchange(buffer); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Write the 10 strings the producer sent in its buffer to the console and delete them from the buffer to leave it empty:</li>
</ol>
<pre class="calibre23">
          System.out.println("Consumer: "+buffer.size()); <br class="title-page-name"/>          for (int j=0; j&lt;10; j++){ <br class="title-page-name"/>            String message=buffer.get(0); <br class="title-page-name"/>            System.out.println("Consumer: "+message); <br class="title-page-name"/>            buffer.remove(0); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Now, implement the <kbd class="calibre15">main</kbd> class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create two buffers that will be used by the producer and consumer:</li>
</ol>
<pre class="calibre23">
        List&lt;String&gt; buffer1=new ArrayList&lt;&gt;(); <br class="title-page-name"/>        List&lt;String&gt; buffer2=new ArrayList&lt;&gt;();
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create the <kbd class="calibre15">Exchanger</kbd> object that will be used to synchronize the producer and consumer:</li>
</ol>
<pre class="calibre23">
        Exchanger&lt;List&lt;String&gt;&gt; exchanger=new Exchanger&lt;&gt;();
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create the <kbd class="calibre15">Producer</kbd> and <kbd class="calibre15">Consumer</kbd> objects:</li>
</ol>
<pre class="calibre23">
        Producer producer=new Producer(buffer1, exchanger); <br class="title-page-name"/>        Consumer consumer=new Consumer(buffer2, exchanger);
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create the threads to execute the producer and consumer and start the threads:</li>
</ol>
<pre class="calibre23">
        Thread threadProducer=new Thread(producer); <br class="title-page-name"/>        Thread threadConsumer=new Thread(consumer); <br class="title-page-name"/>          <br class="title-page-name"/>        threadProducer.start(); <br class="title-page-name"/>        threadConsumer.start();
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The consumer begins with an empty buffer and calls <kbd class="calibre15">Exchanger</kbd> to synchronize with the producer. It needs data to consume. The producer begins its execution with an empty buffer. It creates 10 strings, stores them in the buffer, and uses the <kbd class="calibre15">Exchanger</kbd> to synchronize with the consumer.</p>
<p class="calibre4">At this point, both the threads (producer and consumer) are in <kbd class="calibre15">Exchanger</kbd>, which changes the data structures. So when the consumer returns from the <kbd class="calibre15">exchange()</kbd> method, it will have a buffer with 10 strings. When the producer returns from the <kbd class="calibre15">exchange()</kbd> method, it will have an empty buffer to fill again. This operation will be repeated 10 times.</p>
<p class="calibre4">If you execute the example, you will see how producer and consumer do their jobs concurrently and how the two objects interchange their buffers in every step. As it occurs with other synchronization utilities, the first thread that calls the <kbd class="calibre15">exchange()</kbd> method is put to sleep until the other threads arrive.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Exchanger</kbd> class has another version of the <kbd class="calibre15">exchange</kbd> method: <kbd class="calibre15">exchange(V data, long time, TimeUnit unit)</kbd>. where, <kbd class="calibre15">V</kbd> is the type used as a parameter in the declaration of <kbd class="calibre15">Phaser</kbd> (<kbd class="calibre15">List&lt;String&gt;</kbd> in our case). The thread will sleep until it's interrupted, another thread arrives, or the specified time passes. In this case, a <kbd class="calibre15">TimeoutException</kbd> is thrown. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Completing and linking tasks asynchronously</h1>
            

            <article>
                
<p class="calibre4">Java 8 Concurrency API includes a new synchronization mechanism with the <kbd class="calibre15">CompletableFuture</kbd> class. This class implements the <kbd class="calibre15">Future</kbd> object and the <kbd class="calibre15">CompletionStage</kbd> interface that gives it the following two characteristics:</p>
<ul class="calibre17">
<li class="calibre18">As the <kbd class="calibre15">Future</kbd> object, a <kbd class="calibre15">CompletableFuture</kbd> object will return a result sometime in future</li>
<li class="calibre18">As the <kbd class="calibre15">CompletionStage</kbd> object, you can execute more asynchronous tasks after the completion of one or more <kbd class="calibre15">CompletableFuture</kbd> objects</li>
</ul>
<p class="calibre4">You can work with a <kbd class="calibre15">CompletableFuture</kbd> class in different ways:</p>
<ul class="calibre17">
<li class="calibre18">You can create a <kbd class="calibre15">CompletableFuture</kbd> object explicitly and use it as a synchronization point between tasks. One task will establish the value returned by <kbd class="calibre15">CompletableFuture</kbd>, using the <kbd class="calibre15">complete()</kbd> method, and the other tasks will wait for this value, using the <kbd class="calibre15">get()</kbd> or <kbd class="calibre15">join()</kbd> methods.</li>
<li class="calibre18">You can use a static method of the <kbd class="calibre15">CompletableFuture</kbd> class to execute <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Supplier</kbd> with the <kbd class="calibre15">runAsync()</kbd> and <kbd class="calibre15">supplyAsync()</kbd> methods. These methods will return a <kbd class="calibre15">CompletableFuture</kbd> object that will be completed when these tasks end their execution. In the second case, the value returned by <kbd class="calibre15">Supplier</kbd> will be the completion value of <kbd class="calibre15">CompletableFuture</kbd>.</li>
<li class="calibre18">You can specify other tasks to be executed in an asynchronous way after the completion of one or more <kbd class="calibre15">CompletableFuture</kbd> objects. This task can implement the <kbd class="calibre15">Runnable</kbd>, <kbd class="calibre15">Function</kbd>, <kbd class="calibre15">Consumer</kbd> or <kbd class="calibre15">BiConsumer</kbd> interfaces.</li>
</ul>
<p class="calibre4">These characteristics make the <kbd class="calibre15">CompletableFuture</kbd> class very flexible and powerful. In this chapter, you will learn how to use this class to organize different tasks. The main purpose of the example is that the tasks will be executed, as specified in the following diagram:</p>
<div class="cdpaligncenter"><img class="alignnone14" src="../images/00025.jpeg"/></div>
<p class="calibre4">First, we're going to create a task that will generate a seed. Using this seed, the next task will generate a list of random numbers. Then, we will execute three parallel tasks:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Step 1 will calculate the nearest number to 1,000, in a list of random numbers.</li>
<li value="2" class="calibre18">Step 2 will calculate the biggest number in a list of random numbers.</li>
<li value="3" class="calibre18">Step 3 will calculate the average number between the largest and smallest numbers in a list of random numbers.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we're going to implement the auxiliary tasks we will use in the example. Create a class named <kbd class="calibre15">SeedGenerator</kbd>Â  that implements the <kbd class="calibre15">Runnable</kbd> interface. It will have a <kbd class="calibre15">CompletableFuture</kbd> object as an attribute, and it will be initialized in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        public class SeedGenerator implements Runnable { <br class="title-page-name"/> <br class="title-page-name"/>          private CompletableFuture&lt;Integer&gt; resultCommunicator; <br class="title-page-name"/>            <br class="title-page-name"/>          public SeedGenerator (CompletableFuture&lt;Integer&gt; completable) { <br class="title-page-name"/>            this.resultCommunicator=completable; <br class="title-page-name"/>          }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Then, implement the <kbd class="calibre15">run()</kbd> method. It will sleep the current thread for 5 seconds (to simulate a long operation), calculate a random number between 1 and 10, and then use the <kbd class="calibre15">complete()</kbd> method of the <kbd class="calibre15">resultCommunicator</kbd> object to complete <kbd class="calibre15">CompletableFuture</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/> <br class="title-page-name"/>          System.out.printf("SeedGenerator: Generating seed...\n"); <br class="title-page-name"/>          // Wait 5 seconds <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(5); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>            int seed=(int) Math.rint(Math.random() * 10); <br class="title-page-name"/>               <br class="title-page-name"/>            System.out.printf("SeedGenerator: Seed generated: %d\n",<br class="title-page-name"/>                              seed); <br class="title-page-name"/>               <br class="title-page-name"/>            resultCommunicator.complete(seed); <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a class named <kbd class="calibre15">NumberListGenerator</kbd>Â that implements the <kbd class="calibre15">Supplier</kbd> interface parameterized with the <kbd class="calibre15">List&lt;Long&gt;</kbd> data type. This means that the <kbd class="calibre15">get()</kbd> method provided by the <kbd class="calibre15">Supplier</kbd> interface will return a list of large numbers. This class will have an integer number as a private attribute, which will be initialized in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        public class NumberListGenerator implements Supplier&lt;List&lt;Long&gt;&gt; { <br class="title-page-name"/>         <br class="title-page-name"/>          private final int size; <br class="title-page-name"/>            <br class="title-page-name"/>          public NumberListGenerator (int size) { <br class="title-page-name"/>            this.size=size; <br class="title-page-name"/>          }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Then, implement the <kbd class="calibre15">get()</kbd> method that will return a list with millions of numbers, as specified in the size parameter of larger random numbers:</li>
</ol>
<pre class="calibre23">
          @Override <br class="title-page-name"/>          public List&lt;Long&gt; get() { <br class="title-page-name"/>            List&lt;Long&gt; ret = new ArrayList&lt;&gt;(); <br class="title-page-name"/>            System.out.printf("%s : NumberListGenerator : Start\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/> <br class="title-page-name"/>            for (int i=0; i&lt; size*1000000; i++) { <br class="title-page-name"/>              long number=Math.round(Math.random()*Long.MAX_VALUE); <br class="title-page-name"/>              ret.add(number); <br class="title-page-name"/>            } <br class="title-page-name"/>            System.out.printf("%s : NumberListGenerator : End\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/> <br class="title-page-name"/>            return ret; <br class="title-page-name"/>          }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Finally, create a class named <kbd class="calibre15">NumberSelector</kbd>Â that implements the <kbd class="calibre15">Function</kbd> interface parameterized with the <kbd class="calibre15">List&lt;Long&gt;</kbd> and <kbd class="calibre15">Long</kbd> data types. This means that the <kbd class="calibre15">apply()</kbd> method provided by the <kbd class="calibre15">Function</kbd> interface will receive a list of large numbers and will return a <kbd class="calibre15">Long</kbd> number:</li>
</ol>
<pre class="calibre23">
        public class NumberSelector implements Function&lt;List&lt;Long&gt;, Long&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public Long apply(List&lt;Long&gt; list) { <br class="title-page-name"/> <br class="title-page-name"/>            System.out.printf("%s: Step 3: Start\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>            long max=list.stream().max(Long::compare).get(); <br class="title-page-name"/>            long min=list.stream().min(Long::compare).get(); <br class="title-page-name"/>            long result=(max+min)/2; <br class="title-page-name"/>            System.out.printf("%s: Step 3: Result - %d\n",<br class="title-page-name"/>                              Thread.currentThread().getName(), result); <br class="title-page-name"/>            return result; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now it's time to implement the <kbd class="calibre15">Main</kbd> class and the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">First, create a <kbd class="calibre15">CompletableFuture</kbd> object and a <kbd class="calibre15">SeedGenerator</kbd> task and execute it as a <kbd class="calibre15">Thread</kbd>:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Start\n"); <br class="title-page-name"/>        CompletableFuture&lt;Integer&gt; seedFuture = new CompletableFuture&lt;&gt;(); <br class="title-page-name"/>        Thread seedThread = new Thread(new SeedGenerator(seedFuture)); <br class="title-page-name"/>        seedThread.start();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, wait for the seed generated by the <kbd class="calibre15">SeedGenerator</kbd> task, using the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">CompletableFuture</kbd> object:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Getting the seed\n"); <br class="title-page-name"/>        int seed = 0; <br class="title-page-name"/>        try { <br class="title-page-name"/>          seed = seedFuture.get(); <br class="title-page-name"/>        } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("Main: The seed is: %d\n", seed);
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now create another <kbd class="calibre15">CompletableFuture</kbd> object to control the execution of a <kbd class="calibre15">NumberListGenerator</kbd> task, but in this case, use the static method <kbd class="calibre15">supplyAsync()</kbd>:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Launching the list of numbers<br class="title-page-name"/>                           generator\n"); <br class="title-page-name"/>        NumberListGenerator task = new NumberListGenerator(seed); <br class="title-page-name"/>        CompletableFuture&lt;List&lt;Long&gt;&gt; startFuture = CompletableFuture<br class="title-page-name"/>                                                    .supplyAsync(task);
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, configure the three parallelized tasks that will make calculations based on the list of numbers generated in the previous task. These three steps can't start their execution until the <kbd class="calibre15">NumberListGenerator</kbd> task has finished its execution, so we use the <kbd class="calibre15">CompletableFuture</kbd> object generated in the previous step and the <kbd class="calibre15">thenApplyAsync()</kbd> method to configure these tasks. The first two steps are implemented in a functional way, and the third one is an object of the <kbd class="calibre15">NumberSelector</kbd> class:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Launching step 1\n"); <br class="title-page-name"/>        CompletableFuture&lt;Long&gt; step1Future = startFuture<br class="title-page-name"/>                                              .thenApplyAsync(list -&gt; { <br class="title-page-name"/>          System.out.printf("%s: Step 1: Start\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          long selected = 0; <br class="title-page-name"/>          long selectedDistance = Long.MAX_VALUE; <br class="title-page-name"/>          long distance; <br class="title-page-name"/>          for (Long number : list) { <br class="title-page-name"/>            distance = Math.abs(number - 1000); <br class="title-page-name"/>            if (distance &lt; selectedDistance) { <br class="title-page-name"/>              selected = number; <br class="title-page-name"/>              selectedDistance = distance; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("%s: Step 1: Result - %d\n",<br class="title-page-name"/>                            Thread.currentThread().getName(), selected); <br class="title-page-name"/>          return selected; <br class="title-page-name"/>        }); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("Main: Launching step 2\n"); <br class="title-page-name"/>        CompletableFuture&lt;Long&gt; step2Future = startFuture <br class="title-page-name"/>        .thenApplyAsync(list -&gt; list.stream().max(Long::compare).get()); <br class="title-page-name"/> <br class="title-page-name"/>        CompletableFuture&lt;Void&gt; write2Future = step2Future<br class="title-page-name"/>                                              .thenAccept(selected -&gt; { <br class="title-page-name"/>          System.out.printf("%s: Step 2: Result - %d\n",<br class="title-page-name"/>                            Thread.currentThread().getName(), selected); <br class="title-page-name"/>        }); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("Main: Launching step 3\n"); <br class="title-page-name"/>        NumberSelector numberSelector = new NumberSelector(); <br class="title-page-name"/>        CompletableFuture&lt;Long&gt; step3Future = startFuture<br class="title-page-name"/>                                        .thenApplyAsync(numberSelector);
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">We wait for the finalization of the three parallel steps with the <kbd class="calibre15">allOf()</kbd> static method of the <kbd class="calibre15">CompletableFuture</kbd> class:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Waiting for the end of the three<br class="title-page-name"/>                           steps\n"); <br class="title-page-name"/>        CompletableFuture&lt;Void&gt; waitFuture = CompletableFuture<br class="title-page-name"/>                                      .allOf(step1Future, write2Future,<br class="title-page-name"/>                                             step3Future);
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Also, we execute a final step to write a message in the console:</li>
</ol>
<pre class="calibre23">
        CompletableFuture&lt;Void&gt; finalFuture = waitFuture<br class="title-page-name"/>                                           .thenAcceptAsync((param) -&gt; { <br class="title-page-name"/>          System.out.printf("Main: The CompletableFuture example has<br class="title-page-name"/>                             been completed."); <br class="title-page-name"/>        }); <br class="title-page-name"/>        finalFuture.join();
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">We can use a <kbd class="calibre15">CompletableFuture</kbd> object with two main purposes:</p>
<ul class="calibre17">
<li class="calibre18">Wait for a value or an event that will be produced in future (creating an object and using the <kbd class="calibre15">complete()</kbd> and <kbd class="calibre15">get()</kbd> or <kbd class="calibre15">join()</kbd> methods).</li>
<li class="calibre18">To organize a set of tasks to be executed in a determined order so one or more tasks won't start their execution until others have finished their execution.</li>
</ul>
<p class="calibre4">In this example, we made both uses of the <kbd class="calibre15">CompletableFuture</kbd> class. First, we created an instance of this class and sent it as a parameter to a <kbd class="calibre15">SeedGenerator</kbd> task. This task uses the <kbd class="calibre15">complete()</kbd> method to send the calculated value, and the <kbd class="calibre15">main()</kbd> method uses the <kbd class="calibre15">get()</kbd> method to obtain the value. The <kbd class="calibre15">get()</kbd> method sleeps the current thread until <kbd class="calibre15">CompletableFuture</kbd> has been completed.</p>
<p class="calibre4">Then, we used the <kbd class="calibre15">supplyAsync()</kbd> method to generate a <kbd class="calibre15">CompletableFuture</kbd> object. This method receives an implementation of the <kbd class="calibre15">Supplier</kbd> interface as a parameter. This interface provides the <kbd class="calibre15">get()</kbd> method that must return a value. The <kbd class="calibre15">supplyAsync()</kbd> method returns <kbd class="calibre15">CompletableFuture</kbd>, which will be completed when the <kbd class="calibre15">get()</kbd> method finishes its execution; the value of completion is the value returned by that method. The <kbd class="calibre15">CompletableFuture</kbd> object returned will be executed by a task in the <kbd class="calibre15">ForkJoinPool</kbd> returns the static method <kbd class="calibre15">commonPool()</kbd>.</p>
<p class="calibre4">Then, we used the <kbd class="calibre15">thenApplyAsync()</kbd> method to link some tasks. You call this method in a <kbd class="calibre15">CompletableFuture</kbd> object, and you must pass an implementation of the <kbd class="calibre15">Function</kbd> interface as a parameter that can be expressed directly in the code using a functional style or an independent object. One powerful characteristic is that the value generated by <kbd class="calibre15">CompletableFuture</kbd> will be passed as a parameter to the <kbd class="calibre15">Function</kbd>. That is to say, in our case, all the three steps will receive a random list of numbers as parameters. The <kbd class="calibre15">CompletableFuture</kbd> class returned will be executed by a task in the <kbd class="calibre15">ForkJoinPool</kbd> returns the static method <kbd class="calibre15">commonPool()</kbd>.</p>
<p class="calibre4">Finally, we used the <kbd class="calibre15">allOf()</kbd> static method of the <kbd class="calibre15">CompletableFuture</kbd> class to wait for the finalization of various tasks. This method receives a variable list of <kbd class="calibre15">CompletableFuture</kbd> objects and returns a <kbd class="calibre15">CompletableFuture</kbd> class that will be completed when all the <kbd class="calibre15">CompletableFuture</kbd> class passed as parameters are completed. We also used the <kbd class="calibre15">thenAcceptAsync()</kbd> method as another way to synchronize tasks because this method receives <kbd class="calibre15">Consumer</kbd> as a parameter that is executed by the default executor when the <kbd class="calibre15">CompletableFuture</kbd> object used to call the method is completed. Finally, we used the <kbd class="calibre15">join()</kbd> method to wait for the finalization of the last <kbd class="calibre15">CompletableFuture</kbd> object.</p>
<p class="calibre4">The following screenshot shows the execution of the example. You can see how the tasks are executed in the order we organized:</p>
<div class="cdpaligncenter"><img class="alignnone15" src="../images/00026.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">In the example of this recipe, we used the <kbd class="calibre15">complete()</kbd>, <kbd class="calibre15">get()</kbd>, <kbd class="calibre15">join()</kbd>, <kbd class="calibre15">supplyAsync()</kbd>, <kbd class="calibre15">thenApplyAsync()</kbd>, <kbd class="calibre15">thenAcceptAsync()</kbd>, and <kbd class="calibre15">allOf()</kbd> methods of the <kbd class="calibre15">CompletableFuture</kbd> class. However, this class has a lot of useful methods that help increase the power and flexibility of this class. These are the most interesting ones:</p>
<ul class="calibre17">
<li class="calibre18">Methods to complete a <kbd class="calibre15">CompletableFuture</kbd> object: In addition to the <kbd class="calibre15">complete()</kbd> method, the <kbd class="calibre15">CompletableFuture</kbd> class provides the following three methods:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">cancel()</kbd>: This completes <kbd class="calibre15">CompletableFuture</kbd> with a <kbd class="calibre15">CancellationException</kbd> exception.</li>
<li class="calibre18"><kbd class="calibre15">completeAsync()</kbd>: This completes <kbd class="calibre15">CompletableFuture</kbd> with the result of the <kbd class="calibre15">Supplier</kbd> object passed as a parameter. The <kbd class="calibre15">Supplier</kbd> object is executed in a different thread by the default executor.</li>
<li class="calibre18"><kbd class="calibre15">completeExceptionally()</kbd>: This method completes <kbd class="calibre15">CompletableFuture</kbd> with the exception passed as a parameter.</li>
</ul>
</li>
</ul>
<ul class="calibre17">
<li class="calibre18">Methods to execute a task: In addition to the <kbd class="calibre15">supplyAsync()</kbd> method, the <kbd class="calibre15">CompletableFuture</kbd> class provides the following method:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">runAsync()</kbd>: This is a static method of the <kbd class="calibre15">CompletableFuture</kbd> class that returns a <kbd class="calibre15">CompletableFuture</kbd> object. This object will be completed when the <kbd class="calibre15">Runnable</kbd> interface is passed as a parameter to finish its execution. It will be completed with a void result.</li>
</ul>
</li>
<li class="calibre18">Methods to synchronize the execution of different tasks: In addition to the <kbd class="calibre15">allOf()</kbd>, <kbd class="calibre15">thenAcceptAsync()</kbd>, and <kbd class="calibre15">thenApplyAsync()</kbd> methods, the <kbd class="calibre15">CompletableFuture</kbd> class provides the following methods to synchronize the execution of tasks:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">anyOf()</kbd>: This is a static method of the <kbd class="calibre15">CompletableFuture</kbd> class. It receives a list of <kbd class="calibre15">CompletableFuture</kbd> objects and returns a new <kbd class="calibre15">CompletableFuture</kbd> object. This object will be completed with the result of the first <kbd class="calibre15">CompletableFuture</kbd> parameter that is completed.</li>
<li class="calibre18"><kbd class="calibre15">runAfterBothAsync()</kbd>: This method receives <kbd class="calibre15">CompletionStage</kbd> and <kbd class="calibre15">Runnable</kbd> objects as parameters and returns a new <kbd class="calibre15">CompletableFuture</kbd> object. When <kbd class="calibre15">CompletableFuture</kbd> (which does the calling) and <kbd class="calibre15">CompletionStage</kbd> (which is received as a parameter)Â are completed, the <kbd class="calibre15">Runnable</kbd> object is executed by the default executor and then the <kbd class="calibre15">CompletableFuture</kbd> object returned is completed.</li>
<li class="calibre18"><kbd class="calibre15">runAfterEitherAsync()</kbd>: This method is similar to the previous one, but here, the <kbd class="calibre15">Runnable</kbd> interface is executed after one of the two (<kbd class="calibre15">CompletableFuture</kbd> or <kbd class="calibre15">CompletionStage</kbd>) are completed.</li>
<li class="calibre18"><kbd class="calibre15">thenAcceptBothAsync()</kbd>: This method receives <kbd class="calibre15">CompletionStage</kbd> and <kbd class="calibre15">BiConsumer</kbd> objects as parameters and returns <kbd class="calibre15">CompetableFuture</kbd> as a parameter. When <kbd class="calibre15">CompletableFuture</kbd> (which does the calling) and <kbd class="calibre15">CompletionStage</kbd> (which is passed as a parameter), <kbd class="calibre15">BiConsumer</kbd> is executed by the default executor. It receives the results of the two <kbd class="calibre15">CompletionStage</kbd> objects as parameters but it won't return any result. When <kbd class="calibre15">BiConsumer</kbd> finishes its execution, the returned <kbd class="calibre15">CompletableFuture</kbd> class is completed without a result.</li>
<li class="calibre18"><kbd class="calibre15">thenCombineAsync()</kbd>: This method receives a <kbd class="calibre15">CompletionStage</kbd> object and a <kbd class="calibre15">BiFunction</kbd> object as parameters and returns a new <kbd class="calibre15">CompletableFuture</kbd> object. When <kbd class="calibre15">CompletableFuture</kbd> (which does the calling) and <kbd class="calibre15">CompletionStage</kbd> (which is passed as a parameter)Â are completed, the <kbd class="calibre15">BiFunction</kbd> object is executed; it receives the completion values of both the objects and returns a new result that will be the completion value of the returned <kbd class="calibre15">CompletableFuture</kbd> class.</li>
<li class="calibre18"><kbd class="calibre15">thenComposeAsync()</kbd>:This method is analogous to <kbd class="calibre15">thenApplyAsync()</kbd>, but it is useful when the supplied function returns <kbd class="calibre15">CompletableFuture</kbd> too.</li>
<li class="calibre18"><kbd class="calibre15">thenRunAsync()</kbd>: This method is analogous to the <kbd class="calibre15">thenAcceptAsync()</kbd> method, but in this case, it receives a <kbd class="calibre15">Runnable</kbd> object as a parameter instead of a <kbd class="calibre15">Consumer</kbd> object.</li>
</ul>
</li>
<li class="calibre18">Methods to obtain the completion value: In addition to the <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">join()</kbd> methods, the <kbd class="calibre15">CompletableFuture</kbd> object provides the following method to get the completion value:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">getNow()</kbd>: This receives a value of the same type of the completion value of <kbd class="calibre15">CompletableFuture</kbd>. If the object is completed, it returns the completion value. Else, it returns the value passed as the parameter.</li>
</ul>
</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also...</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">TheÂ <em class="calibre14">Creating a thread executor and controlling its rejected tasks</em>Â and <em class="calibre14">Executing tasks in an executor that returns a result</em> recipes in <a href="part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre14">Thread Executors</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>