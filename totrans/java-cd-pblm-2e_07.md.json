["```java\npackage modern.challenge;\npublic class Main {\n  static { \n    System.loadLibrary(\"math\");\n  }\n  private native long sumTwoInt(int x, int y);\n  public static void main(String[] args) {\n    long result = new Main().sumTwoInt(3, 9);\n    System.out.println(\"Result: \" + result);\n  } \n} \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P144_EngagingJNI>\n  javac –h src/main/java/modern/challenge/cpp –d target/classes src/main/java/modern/challenge/Main.java \n```", "```java\n/*\n * Class:     modern_challenge_Main\n * Method:    sumTwoInt\n * Signature: (II)J\n */\nJNIEXPORT jlong JNICALL Java_modern_challenge_Main_sumTwoInt\n  (JNIEnv *, jobject, jint, jint); \n```", "```java\n#include <iostream>\n#include \"modern_challenge_Main.h\"\nJNIEXPORT jlong JNICALL Java_modern_challenge_Main_sumTwoInt\n  (JNIEnv* env, jobject thisObject, jint x, jint y) {\n    std::cout << \"C++: The received arguments are : \" \n      << x << \" and \" << y << std::endl;\n  return (long)x + (long)y;\n} \nx + y as a long result.\n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P144_EngagingJNI>\n  g++ -c \"-I%JAVA_HOME%\\include\" \"-I%JAVA_HOME%\\include\\win32\" \n  src/main/java/modern/challenge/cpp/modern_challenge_Main.cpp  \n  –o jni/cpp/modern_challenge_Main.o \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P144_EngagingJNI>\n  g++ -shared –o jni/cpp/math.dll jni/cpp/modern_challenge_Main.o \n  –static –m64 –Wl,--add-stdcall-alias \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P144_EngagingJNI>  java –Djava.library.path=jni/cpp \n  –classpath target/classes modern.challenge.Main \n```", "```java\n<dependency>\n  <groupId>net.java.dev.jna</groupId>\n  <artifactId>jna-platform</artifactId>\n  <version>5.8.0</version>\n</dependency> \n```", "```java\npublic interface SimpleMath extends Library { \n  long sumTwoInt(int x, int y);\n} \n```", "```java\n package modern.challenge;\npublic class Main {\n  public static void main(String[] args) {\n    System.setProperty(\"jna.library.path\", \"./jna/cpp\");\n    SimpleMath math = Native.load(Platform.isWindows() \n      ? \"math\" : \"NOT_WINDOWS\", SimpleMath.class);\n    long result = math.sumTwoInt(3, 9);\n    System.out.println(\"Result: \" + result);\n  }\n} \n```", "```java\n#include <iostream>\n#include \"Arithmetic.h\"\nlong sumTwoInt(int x, int y) {\n  std::cout << \"C++: The received arguments are : \" << x <<\n     \" and \" << y << std::endl;\n  return (long)x + (long)y;\n} \n```", "```java\n#ifndef FUNCTIONS_H_INCLUDED\n#define FUNCTIONS_H_INCLUDED\n  long sumTwoInt(int x, int y);  \n#endif \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P145_EngagingJNA>\n  g++ -c \"-I%JAVA_HOME%\\include\" \"-I%JAVA_HOME%\\include\\win32\" \n  src/main/java/modern/challenge/cpp/Arithmetic.cpp \n  –o jna/cpp/Arithmetic.o \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P145_EngagingJNA>g++ -shared –o jna/cpp/math.dll jna/cpp/Arithmetic.o –static –m64             –Wl,--add-stdcall-alias \n```", "```java\npublic class Main {\n  private static final Map MAPPINGS;\n  static {\n    MAPPINGS = Map.of(\n      Library.OPTION_FUNCTION_MAPPER,\n      new StdCallFunctionMapper() {\n      Map<String, String> methodNames\n        = Map.of(\"sumTwoInt\", \"_Z9sumTwoIntii\");\n      @Override\n      public String getFunctionName(\n             NativeLibrary library, Method method) {\n        String methodName = method.getName();\n        return methodNames.get(methodName);\n      }\n    });\n  }\n  public static void main(String[] args) { \n    System.setProperty(\"jna.library.path\", \"./jna/cpp\");\n    SimpleMath math = Native.load(Platform.isWindows() \n      ? \"math\" : \"NOT_WINDOWS\", SimpleMath.class, MAPPINGS);\n    long result = math.sumTwoInt(3, 9);\n    System.out.println(\"Result: \" + result);\n  }\n} \n```", "```java\n<dependency>\n    <groupId>com.github.jnr</groupId>\n    <artifactId>jnr-ffi</artifactId>\n    <version>2.2.13</version>\n</dependency> \n```", "```java\npublic interface SimpleMath { \n  @IgnoreError\n  long sumTwoInt(int x, int y);\n} \n```", "```java\npublic class Main {\n public static void main(String[] args) {\n  LibraryLoader<SimpleMath> loader = \n            FFIProvider.getSystemProvider()\n  .createLibraryLoader(SimpleMath.class)\n  .search(\"./jnr/cpp\")\n  .map(\"sumTwoInt\", \"_Z9sumTwoIntii\");\n  loader = loader.map(\"sumTwoInt\", \"_Z9sumTwoIntii\");\n  if (Platform.getNativePlatform().getOS() \n   == Platform.OS.WINDOWS) {\n   SimpleMath simpleMath = loader.load(\"math\"); \n   long result = simpleMath.sumTwoInt(3, 9);\n   System.out.println(\"Result: \" + result);\n  }\n }\n} \n```", "```java\nMemorySegment globalSegment = Arena.global().allocate(8); \n```", "```java\nMemorySegment autoSegment = Arena.ofAuto().allocate(8); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  // current thread work with memory segments (MS1, MS2, …)\n}\n// here, memory segments MS1, MS2, …, have been deallocated \n```", "```java\ntry (Arena arena = Arena.ofShared()) {\n  // any thread work with memory segments (MS1, MS2, …)\n}\n// here, memory segments MS1, MS2, …, have been deallocated \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment arenaSegment = arena.allocate(8);\n} \n```", "```java\nMemorySegment segment = arena.allocate(4, 4); \n```", "```java\nMemorySegment segment = arena.allocate(ValueLayout.JAVA_INT);\nMemorySegment segment = arena\n  .allocate(ValueLayout.JAVA_INT.byteSize(),\n            ValueLayout.JAVA_INT.byteAlignment()); \n```", "```java\nMemorySegment segment = arena.allocate(4);\nMemorySegment segment = arena\n  .allocate(ValueLayout.JAVA_INT.byteSize()); \n```", "```java\nMemorySegment segment\n  = arena.allocate(ValueLayout.JAVA_DOUBLE);\nMemorySegment segment = arena.allocate(\n  ValueLayout.JAVA_DOUBLE.byteSize(),\n  ValueLayout.JAVA_DOUBLE.byteAlignment()); \n```", "```java\nMemorySegment segment = arena.allocate(ValueLayout.JAVA_CHAR);\nMemorySegment segment = MemorySegment.allocate(\n  ValueLayout.JAVA_CHAR.byteSize(),\n  ValueLayout.JAVA_CHAR.byteAlignment()); \n```", "```java\nMemorySegment segment = arena.allocate(\n  ValueLayout.JAVA_INT, Integer.MAX_VALUE); \n```", "```java\nMemorySegment segment = arena.allocate(\n  ValueLayout.JAVA_CHAR, 'a'); \n```", "```java\nMemorySegment segment = ...;\nsegment.set(ValueLayout.JAVA_INT, 0, Integer.MAX_VALUE); \n```", "```java\nsegment.setAtIndex(\n  ValueLayout.JAVA_INT, 0, Integer.MAX_VALUE); \n```", "```java\nint val = segment.get(ValueLayout.JAVA_INT, 0); \n```", "```java\nint val = segment.getAtIndex(ValueLayout.JAVA_INT, 0); \n```", "```java\nMemorySegment segment = arena.allocateUtf8String(\"abcd\"); \n```", "```java\nMemorySegment segment = arena.allocate(5); \n```", "```java\nMemorySegment segment = arena.allocate(\"abcd\".length() + 1); \n```", "```java\nsegment.setUtf8String(0, \"abcd\"); \nIndexOutOfBoundsException:\n```", "```java\nsegment.setUtf8String(1, \"abcd\"); \n```", "```java\nString str = segment.getUtf8String(0); \n```", "```java\nMemorySegment segment = arena.allocate(32);\nMemorySegment segment = arena.allocate(4 * 8);\nMemorySegment segment = arena.allocate(\n  ValueLayout.JAVA_INT.byteSize() * 8);\nMemorySegment segment = arena.allocate(Integer.SIZE/8 * 8);\nMemorySegment segment = arena.allocate(Integer.BYTES * 8); \n```", "```java\nsegment.set(ValueLayout.JAVA_INT, 0, 11);\nsegment.set(ValueLayout.JAVA_INT, 4, 21);\nsegment.set(ValueLayout.JAVA_INT, 8, 12);\nsegment.set(ValueLayout.JAVA_INT, 12, 7);\nsegment.set(ValueLayout.JAVA_INT, 16, 33);\nsegment.set(ValueLayout.JAVA_INT, 20, 1);\nsegment.set(ValueLayout.JAVA_INT, 24, 3);\nsegment.set(ValueLayout.JAVA_INT, 28, 6); \n```", "```java\nsegment.setAtIndex(ValueLayout.JAVA_INT, 0, 11);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 1, 21);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 2, 12);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 3, 7);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 4, 33);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 5, 1);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 6, 3);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 7, 6); \n```", "```java\nIntVector v = IntVector.fromMemorySegment(\n  VS256, segment, 0, ByteOrder.nativeOrder()); \n```", "```java\nMemorySegment segment = arena.allocateArray(\n  ValueLayout.JAVA_INT, 11, 21, 12, 7, 33, 1, 3, 6);\n// or, like this\nMemorySegment segment = arena.allocateArray(\n  ValueLayout.JAVA_INT, \n  new int[]{11, 21, 12, 7,  33, 1, 3,  6}); \n```", "```java\nMemorySegment segment = arena.allocateArray(\n  ValueLayout.JAVA_CHAR,\"abcd\".toCharArray()); \n```", "```java\nMemorySegment segment = MemorySegment\n  .ofArray(new int[]{11, 21, 12, 7, 33, 1, 3, 6}); \n```", "```java\nMemorySegment segment = arena\n  .allocate(ValueLayout.JAVA_INT, 1000);\nlong addr = segment.address(); // 2620870760384 \n```", "```java\nMemorySegment i1 = arena.allocate(ValueLayout.JAVA_INT, 1);\nMemorySegment i2 = arena.allocate(ValueLayout.JAVA_INT, 3);\nMemorySegment i3 = arena.allocate(ValueLayout.JAVA_INT, 2); \n```", "```java\nMemorySegment addrs = arena\n  .allocateArray(ValueLayout.ADDRESS, 3); \n```", "```java\naddrs.setAtIndex(ValueLayout.ADDRESS, 0, i1);\naddrs.setAtIndex(ValueLayout.ADDRESS, 1, i2);\naddrs.setAtIndex(ValueLayout.ADDRESS, 2, i3); \n```", "```java\nMemorySegment addr1 = addrs.getAtIndex(ValueLayout.ADDRESS, 0);\nMemorySegment addr2 = addrs.getAtIndex(ValueLayout.ADDRESS, 1);\nMemorySegment addr3 = addrs.getAtIndex(ValueLayout.ADDRESS, 2); \n```", "```java\naddr1.get(ValueLayout.JAVA_INT, 0); DON'T DO THIS! \n```", "```java\nint v1 = MemorySegment.ofAddress(addr1.address())\n  .reinterpret(ValueLayout.JAVA_INT.byteSize())\n  .get(ValueLayout.JAVA_INT, 0); \n```", "```java\nint v2 = MemorySegment.ofAddress(addr2.address())\n  .reinterpret(ValueLayout.JAVA_INT.byteSize())\n  .get(ValueLayout.JAVA_INT, 0);\nint v3 = MemorySegment.ofAddress(addr3.address())\n  .reinterpret(ValueLayout.JAVA_INT.byteSize())\n  .get(ValueLayout.JAVA_INT, 0); \n```", "```java\naddr1.address() == i1.address() // true \n```", "```java\naddr1.equals(i1) // true \n```", "```java\nlong i2Addr = i2.address(); \n```", "```java\ni2 = MemorySegment.ofAddress(i3.address())\n  .reinterpret(ValueLayout.JAVA_INT.byteSize()); \n```", "```java\ni3 = MemorySegment.ofAddress(i2Addr)\n  .reinterpret(ValueLayout.JAVA_INT.byteSize()); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(\n    ValueLayout.JAVA_DOUBLE.byteSize() * 10,\n    ValueLayout.JAVA_DOUBLE.byteAlignment());\n  for (int i = 0; i < 10; i++) {\n    segment.setAtIndex(ValueLayout.JAVA_DOUBLE,\n      i, Math.random());\n  }\n  for (int i = 0; i < 10; i++) {\n    System.out.printf(\"\\nx = %.2f\",\n      segment.getAtIndex(ValueLayout.JAVA_DOUBLE, i));\n  }\n} \n```", "```java\nSequenceLayout seq = MemoryLayout.sequenceLayout(\n  10, ValueLayout.JAVA_DOUBLE); \n```", "```java\n// VarHandle[varType=double, \n// coord=[interface java.lang.foreign.MemorySegment, long]]\nVarHandle sphandle = seq.varHandle(\n  PathElement.sequenceElement()); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(seq);\n  for (int i = 0; i < seq.elementCount(); i++) {\n    sphandle.set(segment, i, Math.random());\n  }\n  ... \n```", "```java\n for (int i = 0; i < seq.elementCount(); i++) {\n    System.out.printf(\"\\nx = %.2f\", sphandle.get(segment, i));\n  }\n} \n```", "```java\nSequenceLayout nestedseq = MemoryLayout.sequenceLayout(5,\n  MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_DOUBLE)); \n```", "```java\n// VarHandle[varType=double, coord=[interface \n// java.lang.foreign.MemorySegment, long, long]]\nVarHandle nphandle = nestedseq.varHandle(\n  PathElement.sequenceElement(),\n  PathElement.sequenceElement()); \n```", "```java\nlong outer = nestedseq.elementCount(); \n```", "```java\nlong inner = ((SequenceLayout) nestedseq.select(\n  PathElement.sequenceElement())).elementCount(); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(nestedseq);\n  long outer = nestedseq.elementCount();\n  long inner = ((SequenceLayout) nestedseq.select(\n    PathElement.sequenceElement())).elementCount();\n  for (int i = 0; i < outer; i++) {\n    for (int j = 0; j < inner; j++) {\n      nphandle.set(segment, i, j, Math.random());\n    }\n  }\n  for (int i = 0; i < outer; i++) {\n    System.out.print(\"\\n-----\" + i + \"-----\");\n    for (int j = 0; j < inner; j++) {\n      System.out.printf(\"\\nx = %.2f\",\n        nphandle.get(segment, i, j));\n    }\n  }\n} \n```", "```java\nMemorySegment segment = arena.allocate(\n  2 * ValueLayout.JAVA_DOUBLE.byteSize() * 5,\n  ValueLayout.JAVA_DOUBLE.byteAlignment()); \n```", "```java\nx, *y*) pairs:\n```", "```java\nfor (int i = 0; i < 5; i++) {\n  segment.setAtIndex(\n    ValueLayout.JAVA_DOUBLE, i * 2, Math.random());\n  segment.setAtIndex(\n    ValueLayout.JAVA_DOUBLE, i * 2 + 1, Math.random());\n} \n```", "```java\nStructLayout struct = MemoryLayout.structLayout(\n  ValueLayout.JAVA_DOUBLE.withName(\"x\"), \n  ValueLayout.JAVA_DOUBLE.withName(\"y\")); \n```", "```java\nSequenceLayout struct\n  = MemoryLayout.sequenceLayout(5,\n      MemoryLayout.structLayout(\n        ValueLayout.JAVA_DOUBLE.withName(\"x\"),\n        ValueLayout.JAVA_DOUBLE.withName(\"y\"))); \n```", "```java\n// VarHandle[varType=double, \n// coord=[interface java.lang.foreign.MemorySegment, long]]\nVarHandle xHandle = struct.varHandle(\n  PathElement.sequenceElement(),\n  PathElement.groupElement(\"x\"));\n// VarHandle[varType=double, \n// coord=[interface java.lang.foreign.MemorySegment, long]]\nVarHandle yHandle = struct.varHandle(\n  PathElement.sequenceElement(),\n  PathElement.groupElement(\"y\")); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(struct);\n  for (int i = 0; i < struct.elementCount(); i++) {\n    xHandle.set(segment, i, Math.random());\n    yHandle.set(segment, i, Math.random());\n  }\n  ... \n```", "```java\n for (int i = 0; i < struct.elementCount(); i++) {\n    System.out.printf(\"\\nx = %.2f\", xHandle.get(segment, i));\n    System.out.printf(\"\\ny = %.2f\", yHandle.get(segment, i));\n  }\n} \n```", "```java\nMemorySegment segment = arena.allocate(\n  ValueLayout.JAVA_DOUBLE.byteSize(),\n  ValueLayout.JAVA_DOUBLE.byteAlignment()); \n```", "```java\nsegment.setAtIndex(ValueLayout.JAVA_DOUBLE, 0, 500.99);\nsegment.setAtIndex(ValueLayout.JAVA_INT, 0, 101000); \n```", "```java\nUnionLayout union = MemoryLayout.unionLayout(\n  ValueLayout.JAVA_DOUBLE.withName(\"price\"),\n  ValueLayout.JAVA_INT.withName(\"sku\")); \n```", "```java\n// VarHandle[varType=double, \n// coord=[interface java.lang.foreign.MemorySegment]]\nVarHandle pHandle = union.varHandle(\n  PathElement.groupElement(\"price\"));\n// VarHandle[varType=double, \n// coord=[interface java.lang.foreign.MemorySegment]]\nVarHandle sHandle = union.varHandle(\n  PathElement.groupElement(\"sku\")); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(union);\n  pHandle.set(segment, 500.99);\n  sHandle.set(segment, 101000);\n} \n```", "```java\nStructLayout npStruct = MemoryLayout.structLayout( \n  ValueLayout.JAVA_INT.withName(\"x\"), \n  ValueLayout.JAVA_INT.withName(\"y\")\n); \n```", "```java\nVarHandle xpHandle = npStruct.varHandle(\n  PathElement.groupElement(\"x\"));\nVarHandle ypHandle = npStruct.varHandle(\n  PathElement.groupElement(\"y\"));\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(npStruct);\n  xnHandle.set(segment, 23); // offset 0\n  ynHandle.set(segment, 54); // offset 4\n} \n```", "```java\npaddingLayout()):\n```", "```java\nStructLayout wpStruct = MemoryLayout.structLayout(\n  MemoryLayout.paddingLayout(4), // 4 bytes\n  ValueLayout.JAVA_INT.withName(\"x\"),\n  MemoryLayout.paddingLayout(4), // 4 bytes\n  ValueLayout.JAVA_INT.withName(\"y\")\n); \n```", "```java\nVarHandle xpHandle = wpStruct.varHandle(\n  PathElement.groupElement(\"x\"));\nVarHandle ypHandle = wpStruct.varHandle(\n  PathElement.groupElement(\"y\"));\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(wpStruct);\n  xpHandle.set(segment, 23); // offset 4\n  ypHandle.set(segment, 54); // offset 12\n} \n```", "```java\nlong size = ValueLayout.JAVA_INT.byteSize();   // 4\nlong size = ValueLayout.JAVA_BYTE.byteSize();  // 1\nlong size = npStruct.byteSize();               // 8\nlong size = wpStruct.byteSize();               // 16 \n```", "```java\nlong align = ValueLayout.JAVA_INT.byteAlignment();   // 4\nlong align = ValueLayout.JAVA_BYTE.byteAlignment();  // 1\nlong align = npStruct.byteAlignment();               // 4\nlong align = wpStruct.byteAlignment();               // 4 \n```", "```java\nMemorySegment segment = Arena.ofAuto().allocate(12);\nsegment.set(ValueLayout.JAVA_INT, 0, 1000);\nsegment.set(ValueLayout.JAVA_CHAR, 4, 'a'); \n```", "```java\nsegment.set(ValueLayout.JAVA_INT, 6, 2000); \n```", "```java\nsegment.set(ValueLayout.JAVA_INT, 8, 2000); \n```", "```java\nStructLayout product = MemoryLayout.structLayout(\n  ValueLayout.JAVA_INT.withName(\"sku\"),\n  ValueLayout.JAVA_CHAR.withName(\"energy\"),\n  ValueLayout.JAVA_BYTE.withName(\"weight\")); \n```", "```java\nlong boSku =product.byteOffset(        // 0\n  PathElement.groupElement(\"sku\"));\nlong boEnergy =product.byteOffset(     // 4\n  PathElement.groupElement(\"energy\"));\nlong boWeight =product.byteOffset(     // 6\n  PathElement.groupElement(\"weight\")); \n```", "```java\nStructLayout product = MemoryLayout.structLayout( \n  ValueLayout.JAVA_CHAR.withName(\"energy\"),\n  ValueLayout.JAVA_INT.withName(\"sku\"),\n  ValueLayout.JAVA_BYTE.withName(\"weight\")); \n```", "```java\nStructLayout product = MemoryLayout.structLayout(\n  ValueLayout.JAVA_CHAR.withName(\"energy\"),\n  **MemoryLayout.paddingLayout(****2****),**\n  ValueLayout.JAVA_INT.withName(\"sku\"),\n  ValueLayout.JAVA_BYTE.withName(\"weight\")); \n```", "```java\nSequenceLayout product = MemoryLayout.sequenceLayout(\n  2, MemoryLayout.structLayout(\n    ValueLayout.JAVA_CHAR.withName(\"energy\"),\n    MemoryLayout.paddingLayout(2),\n    ValueLayout.JAVA_INT.withName(\"sku\"),\n    ValueLayout.JAVA_BYTE.withName(\"weight\"))); \n```", "```java\nSequenceLayout product = MemoryLayout.sequenceLayout(\n  2, MemoryLayout.structLayout(\n    ValueLayout.JAVA_CHAR.withName(\"energy\"),\n    MemoryLayout.paddingLayout(2),\n    ValueLayout.JAVA_INT.withName(\"sku\"),\n    ValueLayout.JAVA_BYTE.withName(\"weight\"),\n    **MemoryLayout.paddingLayout(****3****)**)); \n```", "```java\nMemorySegment srcSegment = arena.allocateArray(\n  ValueLayout.JAVA_INT, 1, 2, 3, 4, -1, -1, -1, \n                        52, 22, 33, -1, -1, -1, -1, -1, 4); \n```", "```java\nMemorySegment copySegment = srcSegment.copyFrom(srcSegment); \n```", "```java\nSystem.out.println(\"Data: \" + Arrays.toString(\n  copySegment.toArray(ValueLayout.JAVA_INT))); \n```", "```java\nMemorySegment dstSegment\n  = arena.allocateArray(ValueLayout.JAVA_INT, 8); \n```", "```java\nMemorySegment.copy(srcSegment, 32, dstSegment, 0, 32); \n```", "```java\nint[] dstArray = new int[8]; \n```", "```java\nMemorySegment.copy(\n  srcSegment, ValueLayout.JAVA_INT, 32, dstArray, 0, 8); \n```", "```java\nint[] srcArray = new int[]{10, 44, 2, 6, 55, 65, 7, 89}; \n```", "```java\nMemorySegment dstSegment\n  = arena.allocateArray(ValueLayout.JAVA_INT, 16); \n```", "```java\nMemorySegment.copy(\n  srcArray, 0, dstSegment, ValueLayout.JAVA_INT, 32, 8); \n```", "```java\nMemorySegment.copy(srcSegment, 32, dstSegment, 0, 32); \n```", "```java\nMemorySegment.copy(srcSegment, ValueLayout.JAVA_INT, \n  32, dstSegment, ValueLayout.JAVA_INT, 0, 8); \n```", "```java\nVectorSpecies<Integer> VS128 = IntVector.SPECIES_128; \n```", "```java\nIntVector v1, v2, v3;\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment srcSegment = arena.allocateArray(\n    ValueLayout.JAVA_INT, 1, 2, 3, 4, -1, -1, -1, 52, 22, 33,\n                         -1, -1, -1, -1, -1, 4);\nv1 = IntVector.fromMemorySegment(VS128,\n  srcSegment.asSlice(0, 16), 0, ByteOrder.nativeOrder());\nv2 = IntVector.fromMemorySegment(VS128,\n  srcSegment.asSlice(28, 12), 0, ByteOrder.nativeOrder(),\n  VS128.indexInRange(0, 3));\nv3 = IntVector.fromMemorySegment(VS128,\n  srcSegment.asSlice(60), 0, ByteOrder.nativeOrder(),\n  VS128.indexInRange(0, 1));\n} \n```", "```java\nint[] jv1, jv2, jv3;\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment srcSegment = arena.allocateArray(\n    ValueLayout.JAVA_INT, 1, 2, 3, 4, -1, -1, -1, 52, 22, 33,\n                         -1, -1, -1, -1, -1, 4);\n  jv1 = srcSegment\n    .asSlice(0, 16).toArray(ValueLayout.JAVA_INT);\n  jv2 = srcSegment\n    .asSlice(28, 12).toArray(ValueLayout.JAVA_INT);\n  jv3 = srcSegment\n    .asSlice(60).toArray(ValueLayout.JAVA_INT);\n} \n```", "```java\nMemorySegment segment = arena.allocateArray(\n  ValueLayout.JAVA_INT, new int[]{1, 2, 3, 4, 6, 8, 4, 5, 3}); \n```", "```java\nMemorySegment subsegment = segment.asSlice(12); \n```", "```java\nint[] subarray = segment.asOverlappingSlice(subsegment)\n  .orElse(MemorySegment.NULL).toArray(ValueLayout.JAVA_INT); \n```", "```java\nMemorySegment segment = arena.allocateArray(\n  ValueLayout.JAVA_INT, new int[]{1, 2, 3, 4, 6, 8, 4, 5, 3}); \n```", "```java\nMemorySegment subsegment = segment.asSlice(16); \n```", "```java\n// 16\nlong offset = segment.segmentOffset(subsegment);\n// 6\nsegment.get(ValueLayout.JAVA_INT, offset) \n```", "```java\nint[] arr1 = new int[]{1, 2, 3, 4, 5, 6};\nint[] arr2 = new int[]{7, 8, 9};\nint[] arr3 = new int[]{10, 11, 12, 13, 14}; \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment1 \n    = arena.allocateArray(ValueLayout.JAVA_INT, arr1);\n  MemorySegment segment2 \n    = arena.allocateArray(ValueLayout.JAVA_INT, arr2);\n  MemorySegment segment3 \n    = arena.allocateArray(ValueLayout.JAVA_INT, arr3);\n} \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  SegmentAllocator allocator = \n    SegmentAllocator.slicingAllocator(arena.allocate(10 * 4)); \n  ... \n```", "```java\n MemorySegment segment1 = allocator.allocateArray(\n    ValueLayout.JAVA_INT, arr1);\n  ... \n```", "```java\n MemorySegment segment2 = allocator.allocateArray(\n    ValueLayout.JAVA_INT, arr2);\n  ... \n```", "```java\n MemorySegment segment3 = allocator.allocateArray(\n    ValueLayout.JAVA_INT, arr3);\n} catch (IndexOutOfBoundsException e) {\n  System.out.println(\n    \"There is not enough memory to fit all data\");\n    // handle exception\n} \n```", "```java\nSegmentAllocator allocator = SegmentAllocator\n  .slicingAllocator(arena.allocate(10 * 4 + 4 * 4)); \n```", "```java\nSequenceLayout innerSeq\n  = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_DOUBLE);\nSequenceLayout outerSeq\n  = MemoryLayout.sequenceLayout(10, innerSeq); \n```", "```java\nVarHandle handle = outerSeq.varHandle(\n  PathElement.sequenceElement(),\n  PathElement.sequenceElement());\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(outerSeq);\n  for (int i = 0; i < outerSeq.elementCount(); i++) {\n    for (int j = 0; j < innerSeq.elementCount(); j++) {\n      handle.set(segment, i, j, Math.random());\n    }\n  }\n} \n```", "```java\nMethodHandle mHandle = outerSeq.sliceHandle(\n  PathElement.sequenceElement());\nSystem.out.println(\"\\n The third sequence of 10: \" \n  + Arrays.toString(\n    ((MemorySegment) mHandle.invoke(segment, 3))\n      .toArray(ValueLayout.JAVA_DOUBLE))); \n```", "```java\nSequenceLayout innerSeq\n  = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_DOUBLE);\nSequenceLayout outerSeq\n  = MemoryLayout.sequenceLayout(10, innerSeq); \n```", "```java\nSequenceLayout flatten = outerSeq.flatten();\nVarHandle fhandle = flatten.varHandle(\n  PathElement.sequenceElement());\nfor (int i = 0; i < flatten.elementCount(); i++) {\n  System.out.printf(\"\\nx = %.2f\", fhandle.get(segment, i));\n} \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segment = arena.allocate(flatten);\n  for (int i = 0; i < flatten.elementCount(); i++) {\n    fhandle.set(segment, i, Math.random());\n  }\n} \n```", "```java\nSequenceLayout innerSeq\n  = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_DOUBLE);\nSequenceLayout outerSeq\n  = MemoryLayout.sequenceLayout(10, innerSeq); \n```", "```java\nSequenceLayout innerSeq\n  = MemoryLayout.sequenceLayout(25, ValueLayout.JAVA_DOUBLE);\nSequenceLayout outerSeq\n  = MemoryLayout.sequenceLayout(2, innerSeq); \n```", "```java\nSequenceLayout reshaped = outerSeq.reshape(25, 2); \n```", "```java\nSequenceLayout innerSeq\n  = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_DOUBLE);\nSequenceLayout outerSeq\n  = MemoryLayout.sequenceLayout(10, innerSeq); \n```", "```java\nMethodHandle mHandle = outerSeq.sliceHandle(\n  PathElement.sequenceElement(),\n  PathElement.sequenceElement());\nMemorySegment ms = (MemorySegment)     \n  mHandle.invokeExact(segment, 7L, 3L);\nSystem.out.println(ms.get(ValueLayout.JAVA_DOUBLE, 0)); \n```", "```java\nMemorySegment ms = (MemorySegment) mHandle\n  .asSpreader(Long[].class, 2)\n  .invokeExact(segment, new Long[]{7L, 3L}); \n```", "```java\nMemorySegment segment = arena.allocate(ValueLayout.JAVA_INT); \n```", "```java\n// VarHandle[varType=int, \n// coord=[interface java.lang.foreign.MemorySegment]]\nVarHandle handle = ValueLayout.JAVA_INT.varHandle(); \n```", "```java\n// VarHandle[varType=int, \n// coord=[interface java.lang.foreign.MemorySegment, long]]\nVarHandle arrhandle\n  = ValueLayout.JAVA_INT.arrayElementVarHandle(); \n```", "```java\n// VarHandle[varType=int, \n// coord=[interface java.lang.foreign.MemorySegment, long]]\nVarHandle viewhandle = MethodHandles\n  .memorySegmentViewVarHandle(ValueLayout.JAVA_INT); \n```", "```java\nviewhandle = MethodHandles\n  .insertCoordinates(viewhandle, 1, 0); \n```", "```java\nviewhandle.set(segment, 75); \nSystem.out.println(\"Value: \" + viewhandle.get(segment)); \n```", "```java\nSequenceLayout xy = MemoryLayout\n  .sequenceLayout(2, MemoryLayout.structLayout(\n    ValueLayout.JAVA_INT.withName(\"x\"),\n    ValueLayout.JAVA_INT.withName(\"y\"))); \n```", "```java\nVarHandle xHandle = xy.varHandle(\n  PathElement.sequenceElement(),\n  PathElement.groupElement(\"x\"));\nVarHandle yHandle = xy.varHandle(\n  PathElement.sequenceElement(), \n  PathElement.groupElement(\"y\"));\ntry (Arena arena = Arena.ofShared()) {\n  MemorySegment segment = arena.allocate(xy);\n  xHandle.set(segment, 0, 5);\n  yHandle.set(segment, 0, 9);\n  xHandle.set(segment, 1, 6);\n  yHandle.set(segment, 1, 8);\n  // stream operations\n} \n```", "```java\nint sum = segment.elements(xy)\n  .map(t -> t.toArray(ValueLayout.JAVA_INT))\n  .flatMapToInt(t -> Arrays.stream(t))\n  .sum(); \n```", "```java\nint sum = segment.elements(ValueLayout.JAVA_INT)\n  .parallel()\n  .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n  .sum(); \n```", "```java\nMethodHandle xyHandle\n  = xy.sliceHandle(PathElement.sequenceElement()); \n```", "```java\nMemorySegment subsegment \n  = (MemorySegment) xyHandle.invoke(segment, 0); \n```", "```java\nint sum = subsegment.elements(ValueLayout.JAVA_INT)\n  .parallel()\n  .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n  .sum(); \n```", "```java\nvar sum = segment.elements(xy)\n  .parallel()\n  .map(t -> t.asSlice(4).toArray(ValueLayout.JAVA_INT)) \n  .flatMapToInt(t -> Arrays.stream(t))\n  .sum(); \n```", "```java\ntry (FileChannel file = FileChannel.open(\n  Path.of(\"readme.txt\"), CREATE, READ, WRITE);   \n  Arena arena = Arena.ofConfined()) {\n    MemorySegment segment\n      = file.map(READ_WRITE, 0, 1048576, arena);  \n    // write the data\n    segment.setUtf8String(0, \"This is a readme file ...\");\n    segment.setUtf8String(1048576/2, \n      \"Here is the middle of the file ...\");\n    segment.setUtf8String(1048576-32, \n      \"Here is the end of the file ...\");\n    // read some data\n    System.out.println(segment.getUtf8String(1048576/2));\n} \n```", "```java\ntry (FileChannel file = FileChannel.open(\n  Path.of(\"sparse_readme.txt\"), \n    CREATE_NEW, SPARSE, READ, WRITE);\n  Arena arena = Arena.ofConfined()) {\n   MemorySegment segment\n      = file.map(READ_WRITE, 0, 1048576, arena);\n    // write the data \n    segment.setUtf8String(0, \"This is a readme file ...\");\n    segment.setUtf8String(1048576/2, \n      \"Here is the middle of the file ...\");\n    segment.setUtf8String(1048576-32, \n      \"Here is the end of the file ...\");\n    // read some data\n    System.out.println(segment.getUtf8String(0));\n} \n```", "```java\npublic class MappedArena implements Arena {\n  private final String fileName;\n  private final Arena shared;\n  public MappedArena(String fileName) {\n    this.fileName = fileName;\n    this.shared = Arena.ofShared();\n  }\n  @Override\n  public MemorySegment allocate(\n    long byteSize, long byteAlignment) {\n    try (FileChannel file = FileChannel.open(\n      Path.of(fileName + System.currentTimeMillis() + \".txt\"),\n        CREATE_NEW, SPARSE, READ, WRITE)) {\n      return file.map(\n        READ_WRITE, 0, byteSize, shared);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  // more overridden methods\n} \n```", "```java\ntry (Arena arena = new MappedArena(\"readme\")) {\n  MemorySegment segment1 = arena.allocate(100);\n  MemorySegment segment2 = arena.allocate(50);\n  segment1.setUtf8String(0, \"Hello\");\n  segment2.setUtf8String(0, \"World\");\n  System.out.println(segment1.getUtf8String(0) \n    + \" \" + segment2.getUtf8String(0));\n} \n```", "```java\nLinker linker = Linker.nativeLinker();\nSymbolLookup lookup = linker.defaultLookup(); \n```", "```java\nSystem.loadLibrary(\"fooLib\"); // fooLib.dll is loaded here\nSymbolLookup lookup = SymbolLookup.loaderLookup(); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) { \n  SymbolLookup lookup = SymbolLookup.libraryLookup(\n    libName/libPath, arena);\n} \n```", "```java\nMemorySegment fooFunc = mathLookup.find(\"fooFunc\").get(); \n```", "```java\nMethodHandle downcallHandle(\n  FunctionDescriptor function, Linker.Option... options)\ndefault MethodHandle downcallHandle(MemorySegment symbol, \n  FunctionDescriptor function, Linker.Option... options) \n```", "```java\nMemorySegment upcallStub(MethodHandle target, \n  FunctionDescriptor function, Arena arena) \n```", "```java\n// get the Linker of the underlying native platform \n// (operating system + processor that runs the JVM)\nLinker linker = Linker.nativeLinker();\n// \"_getpid\" is part of the Universal C Runtime (UCRT) Library\nSymbolLookup libLookup = linker.defaultLookup();\n// find the \"_getpid\" foreign function\nMemorySegment segmentGetpid = libLookup.find(\"_getpid\").get();\n// create a method handle for \"_getpid\"\nMethodHandle func = linker.downcallHandle(segmentGetpid,\n  FunctionDescriptor.of(ValueLayout.JAVA_INT));\n// invoke the foreign function, \"_getpid\" and get the result\nint result = (int) func.invokeExact(); \nSystem.out.println(result); \n```", "```java\nLinker linker = Linker.nativeLinker();\nPath path = Paths.get(\"lib/cpp/math.dll\");\ntry (Arena arena = Arena.ofConfined()) { \n  SymbolLookup libLookup = SymbolLookup.libraryLookup(\n    path, arena);\n  ... \n```", "```java\n MemorySegment segmentSumTwoInt\n    = libLookup.find(\"_Z9sumTwoIntii\").get();\n  ... \n```", "```java\n MethodHandle func = linker.downcallHandle(segmentSumTwoInt,\n  FunctionDescriptor.of(ValueLayout.JAVA_LONG, \n    ValueLayout.JAVA_INT, ValueLayout.JAVA_INT));\n  ... \n```", "```java\n long result = (long) func.invokeExact(3, 9);\n  System.out.println(result);\n} \n```", "```java\ndouble modf(double x, double *intptr); \n```", "```java\nLinker linker = Linker.nativeLinker();\nSymbolLookup libLookup = linker.defaultLookup();\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segmentModf = libLookup.find(\"modf\").get();\n  ... \n```", "```java\n MethodHandle func = linker.downcallHandle(segmentModf,   \n    FunctionDescriptor.of(ValueLayout.JAVA_DOUBLE, \n      ValueLayout.JAVA_DOUBLE, ValueLayout.ADDRESS));\n  ... \n```", "```java\n MemorySegment segmentIntptr\n    = arena.allocate(ValueLayout.JAVA_DOUBLE);\n  double fractional\n    = (double) func.invokeExact(x, segmentIntptr);\n  ... \n```", "```java\n System.out.println(\"Fractional part: \" + fractional \n    + \" Integer part: \" + segmentIntptr.get(\n     ValueLayout.JAVA_DOUBLE, 0));\n} \n```", "```java\nFractional part: 0.7665499999999952 Integer part: 89.0 \n```", "```java\nchar *strcat(char *strDestination, const char *strSource); \n```", "```java\nLinker linker = Linker.nativeLinker();\nSymbolLookup libLookup = linker.defaultLookup();\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segmentStrcat\n    = libLookup.find(\"strcat\").get();\n  MethodHandle func = linker.downcallHandle(\n    segmentStrcat, FunctionDescriptor.ofVoid(\n      ValueLayout.ADDRESS, ValueLayout.ADDRESS));\n  ... \n```", "```java\n String strDestination = \"Hello \";\n  String strSource = \"World\";\n  MemorySegment segmentStrSource\n    = arena.allocate(strSource.length() + 1);\n  segmentStrSource.setUtf8String(0, strSource);\n  MemorySegment segmentStrDestination = arena.allocate(\n    strSource.length() + 1 + strDestination.length() + 1);\n  segmentStrDestination.setUtf8String(0, strDestination);\n  ... \n```", "```java\nfunc.invokeExact(segmentStrDestination, segmentStrSource); \n```", "```java\n// Hello World\nSystem.out.println(segmentStrDestination.getUtf8String(0)); \n```", "```java\nvoid *bsearch(\n  const void *key,\n  const void *base,\n  size_t num,\n  size_t width,\n  int ( __cdecl *compare ) (\n    const void *key, const void *datum)\n); \n```", "```java\nstatic int comparator(MemorySegment i1, MemorySegment i2) {\n  return Integer.compare(i1.get(ValueLayout.JAVA_INT, 0),\n    i2.get(ValueLayout.JAVA_INT, 0));\n} \n```", "```java\nMethodHandle comparatorHandle = MethodHandles.lookup()\n  .findStatic(Main.class, \"comparator\", MethodType.methodType(\n    int.class, MemorySegment.class, MemorySegment.class)); \n```", "```java\nLinker linker = Linker.nativeLinker();\nSymbolLookup libLookup = linker.defaultLookup(); \n```", "```java\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment comparatorFunc =   \n    linker.upcallStub(comparatorHandle,\n      FunctionDescriptor.of(ValueLayout.JAVA_INT,\n        ValueLayout.ADDRESS.withTargetLayout(\n          MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)),\n        ValueLayout.ADDRESS.withTargetLayout(\n          MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT))), \n      arena);\n  MemorySegment segmentBsearch\n    = libLookup.find(\"bsearch\").get();\n  MethodHandle func = linker.downcallHandle(\n    segmentBsearch, FunctionDescriptor.of(\n      ValueLayout.ADDRESS, ValueLayout.ADDRESS, \n      ValueLayout.ADDRESS, ValueLayout.JAVA_INT,\n      ValueLayout.JAVA_LONG, ValueLayout.ADDRESS));\n  ... \n```", "```java\n int elem = 14;\n  int[] arr = new int[]{1, 3, 6, 8, 10, 12, 14, 16, 20, 22};\n  MemorySegment key = arena.allocate(\n    ValueLayout.JAVA_INT, elem);\n  MemorySegment array \n    = arena.allocateArray(ValueLayout.JAVA_INT, arr);\n  ... \n```", "```java\n MemorySegment result = (MemorySegment) func.invokeExact(\n    key, array, 10, ValueLayout.JAVA_INT.byteSize(), \n      comparatorFunc);\n  ... \n```", "```java\n if (result.equals(MemorySegment.NULL)) {\n    System.out.println(\"Element \" + elem\n      + \" not found in the given array \"\n      + Arrays.toString(arr));\n  } else {\n    ... \n```", "```java\n long offset = array.segmentOffset(result);\n    System.out.println(\"Element found in the given array at \n      offset: \" + offset);\n    System.out.println(\"Element value: \"\n      + array.get(ValueLayout.JAVA_INT, offset));\n  }\n} \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P171_JextractAndModf>\n  jextract --source --output src\\main\\java -t c.lib.math\n  -I C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include \n  C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include\\math.h \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P171_JextractAndModf>\n  jextract --dump-includes includes.txt \n  -I C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include \n  C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include\\math.h \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P171_JextractAndModf>\n  jextract --source @includes.txt --output src\\main\\java -t c.lib.math\n  -I C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include \n  C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include\\math.h \n```", "```java\nC:\\SBPBP\\GitHub\\Java-Coding-Problems-Second-Edition\\Chapter07\\P171_JextractAndModf>\n  jextract @includes.txt --output target\\classes -t c.lib.math\n  -I C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include \n  C:\\MinGW64\\mingw64\\x86_64-w64-mingw32\\include\\math.h \n```", "```java\ndouble x = 89.76655;\ntry (Arena arena = Arena.ofConfined()) {\n  MemorySegment segmentIntptr\n    = arena.allocate(ValueLayout.JAVA_DOUBLE);\n  double fractional = modf(x, segmentIntptr);\n  System.out.println(\"Fractional part: \" + fractional\n    + \" Integer part: \" + segmentIntptr.get(\n      ValueLayout.JAVA_DOUBLE, 0));\n} \n```"]