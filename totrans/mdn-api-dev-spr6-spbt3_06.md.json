["```java\nINFO [Chapter06,,,] [null] [null] [null] [null] 31975 --- [           main] o.s.s.web.DefaultSecurityFilterChain:\n\n1.  `WebAsyncManagerIntegrationFilter`\n2.  `SecurityContextPersistenceFilter`\n3.  `HeaderWriterFilter`\n4.  `CorsFilter`\n5.  `CsrfFilter`\n6.  `LogoutFilter`\n7.  `BearerTokenAuthenticationFilter`\n8.  `RequestCacheAwareFilter`\n9.  `SecurityContextHolderAwareRequestFilter`\n10.  `AnonymousAuthenticationFilter`\n11.  `SessionManagementFilter`\n12.  `ExceptionTranslationFilter`\n13.  `FilterSecurityInterceptor`\n\nThis filter chain may change in future releases. Also, the security filter chain will be different if you just used `spring-boot-starter-security` or changed the configuration. You can find all the filters available in `springSecurityFilterChain` at [https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-security-filters](https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-security-filters).\nNow, you know about the different filters and their order in the default security chain. Next, let’s add the required dependencies, making use of the Spring OAuth 2.0 resource server for authentication in the following subsections.\nAdding the required Gradle dependencies\nLet’s add the following dependencies to the `build.gradle` file, as shown next:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/build.gradle)\nThe Spring Boot Starter OAuth 2 resource server dependency will add the following JARs:\n\n*   `spring-security-core`\n*   `spring-security-config`\n*   `spring-security-web`\n*   `spring-security-cropto`\n*   `spring-security-oauth2-core`\n*   `spring-security-oauth2-jose`\n*   `spring-security-oauth2-resource-server`\n\nFor JWT implementation, we will use the `java-jwt` library from [auth0.com](http://auth0.com).\nWe will now explore how to code these two filters – through login and token-based authentication.\nAuthentication using the OAuth 2.0 resource server\nThe Spring Security OAuth 2.0 resource server allows you to implement authentication and authorization using `BearerTokenAuthenticationFilter`. This contains the bearer token authentication logic. However, you still need to write the REST endpoint to generate the token. Let’s explore how the authentication flow works in the OAuth2.0 resource server. Take a look at the following diagram:\n![Figure 6.1 – A token authentication flow using the OAuth 2.0 resource server](img/Figure_06.1_B19349.jpg)\n\nFigure 6.1 – A token authentication flow using the OAuth 2.0 resource server\nLet’s understand the flow depicted in *Figure 6**.1*:\n\n1.  The client sends a `GET` HTTP request to `/api/v1/addresses`.\n2.  `BearerTokenAuthenticationFilter` comes into action. If the request doesn’t contain the `Authorization` header, then `BearerTokenAuthenticationFilter` does not authenticate the request since it did not find the bearer token. It passes the call to `FilterSecurityInterceptor`, which does the authorization. It throws an `AccessDeniedException` exception (marked as `ExceptionTranslationFilter` springs into action. Control is moved to `BearerTokenAuthenticationEntryPoint`, which responds with a `401 Unauthorized` status and a `WWW-Authenticate` header, with a `Bearer` value. If the client receives a `WWW-Authenticate` header with a `Bearer` value in response, it means it must retry with the `Authorization` header that holds the valid bearer token. At this stage, the request cache is `NullRequestCache` (that is, empty) due to security reasons – the client can replay the request.\n3.  Let’s assume the HTTP request contains an `Authorization` header. It extracts the `Authorization` header from the HTTP request and, apparently, the token from the `Authorization` header. It creates an instance of `BearerTokenAuthentication`` Token` using the token value. `BearerTokenAuthenticationToken` is a type of `AbstractAuthenticationToken` class that implements an `Authentication` interface, representing the token/principal for the authenticated request.\n4.  The HTTP request is passed to `AuthenticationManagerResolver`, which provides the `AuthenticationManager` based on the configuration. `AuthenticationManager` verifies the `BearerTokenAuthenticationToken` token.\n5.  If authentication is successful, then `Authentication` is set on the `SecurityContext` instance. This instance is then passed to `SecurityContextHolder.setContext()`. The request is passed to the remaining filters for processing, then routes to `DispatcherServlet`, and then, finally, to `AddressController`.\n6.  If authentication fails, then `SecurityContextHolder.clearContext()` is called to clear the context value. `ExceptionTranslationFilter` springs into action. Control is moved to `BearerTokenAuthenticationEntryPoint`, which responds with a `401 Unauthorized` status and a `WWW-Authenticate` header, with a value that contains the appropriate error message, such as the following:\n\n    ```", "```java\n\nNow that you have learned about the complete authentication flow using the OAuth 2.0 resource server, let’s learn the fundamentals of JWT.\nExploring the structure of JWT\nYou need authority in the form of permissions or rights to carry out any activity or access any information in general. This authority is known as a claim with respect to JWT. A claim is represented as a key-value pair. The key contains the claim name and the value contains the claim, which can be a valid JSON value. A claim can also be metadata about the JWT.\nHow to pronounce JWT\nAs per [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519), the suggested pronunciation of *JWT* is the same as the English word *jot*.\nA JWT is an encoded string that contains a set of claims. These claims are either digitally signed by a **JSON Web Signature** (**JWS**) or encrypted by **JSON Web Encryption** (**JWE**). *JWT is a self-contained way to transmit claims securely between parties*. The links to these **Request for Comments** (**RFC**)-proposed standards are provided in the *Further reading* section of this chapter.\nA JWT is an encoded string such as `aaa.bbb.ccc`, consisting of the following three parts, separated by dots (`.`):\n\n*   Header\n*   Payload\n*   Signature\n\nA few websites, such as [https://jwt.io](https://jwt.io), allow you to view the content of a JWT and generate one.\nLet’s have a look at the following sample JWT string. You can paste it into one of the aforementioned websites to decode the content:\n\n```", "```java\n\n This sample token demonstrates how a JWT is formed and divided into three parts using dots.\nHeader\nA `typ` key) and a signing algorithm (with an `alg` key).\nThis sample JWT string contains the following header:\n\n```", "```java\n\nThe preceding header contains the `typ` and `alg` fields, representing the type and algorithm, respectively.\nPayload\nA **payload** is the second part of the JWT, which contains the claims and also comprises a Base64URL-encoded JSON string. There are three types of claims – registered, public, and private. These are outlined as follows:\n\n*   `iss` key): This claim identifies the principal who issued a token*   `sub` key): This should be a unique value that represents the subject of the JWT*   `exp` key): This is a numeric value representing the expiration time on or after which a JWT should be rejected*   `iat` key): This claim identifies the time at which a JWT is issued*   `jti` key): This claim represents the unique identifier for a JWT*   `aud` key): This claim identifies the recipients, which JWT is intended for*   `nbf` key): This represents the time before which a JWT must be rejected\n**Public claims**: These are defined by JWT issuers and must not collide with registered claims. Therefore, these should either be registered with the IANA JWT Claims registry or defined as a URI with a collision-resistant namespace.\n**Private claims**: These are custom claims defined and used by the issuer and audience. They are neither registered nor public.\n\nHere is a sample JWT string containing a payload:\n\n```", "```java\n\nThe preceding payload contains `sub` (subject), `iss` (issuer), `roles` (custom claim roles), `exp` (expires), `iat` (issued at), and `jti` (JWT ID) fields.\nSignature\nA **signature** is also a Base64-encoded string and makes up the third part of a JWT-encoded string. A signature is there to protect the content of the JWT. The content is visible but cannot be modified if the token is signed. A Base64-encoded header and payload are passed to the signature’s algorithm, along with either a secret or a public key to make the token a signed token. If you wish to include any sensitive or secret information in the payload, then it’s better to encrypt it before assigning it to the payload.\nA signature makes sure that the content is not modified once it is received. The use of a public/private key enhances the security step by verifying the sender.\nYou can use a combination of both a JWT and JWE. However, the recommended way is to first encrypt the payload using JWE and then sign it.\nWe’ll use public/private keys to sign the token in the next section. Let’s jump into coding in the next section.\nSecuring REST APIs with JWT\nIn this section, you’ll secure the REST endpoints exposed in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097), *Writing Business Logic for APIs*. Therefore, we’ll use the code from [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097) and enhance it to secure the APIs.\nThe REST APIs should be protected using the following techniques:\n\n*   No secure API should be accessed without a JWT.\n*   A JWT can be generated using sign-in/sign-up or a refresh token.\n*   A JWT and a refresh token should only be provided for a valid user’s username/password combination or a valid user sign-up.\n*   The password should be stored in an encoded format using a `bcrypt` strong hashing function.\n*   The JWT should be signed with **Rivest-Shamir-Adleman** (**RSA**) keys with a strong algorithm.\n\nRSA\nRSA is an algorithm approved by the **Federal Information Processing Standards**(**FIPS**) (FIPS 186) for digital signatures and in **Special Publication** (**SP**) (SP800-56B) for key establishment.\n\n*   Claims in the payload should not store sensitive or secured information. If they do, then they should be encrypted.\n*   You should be able to authorize API access for certain roles.\n\nWe need to include new APIs for the authorization flow. Let’s add them first.\nAdding new APIs\nYou will enhance the existing APIs by adding four new APIs – sign-up, sign-in, sign-out, and a refresh token. The sign-up, sign-in, and sign-out operations are self-explanatory.\nThe refresh token provides a new access token (JWT) once the existing token expires. This is the reason why the sign-up/sign-in API provides two types of tokens – an access token and a refresh token as a part of its response. The JWT access token self-expires; therefore, a sign-out operation would only remove the refresh token.\nLet’s add these APIs to the `openapi.yaml` document next.\nApart from adding the new APIs, you also need to add a new user tag for these APIs that will expose all these APIs through the `UserApi` interface. Let’s first add a sign-up endpoint.\nSign-up endpoint\nAdd the following specification for the sign-up endpoint in `openapi.yaml`:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/api/openapi.yaml)\nThe sign-up API call returns the new `SignedInUser` model. This contains `accessToken`, `refreshToken`, `username`, and user ID fields. The code to add the model is shown in the following snippet:\n\n```", "```java\n\nNow, let’s add the sign-in endpoint.\nSign-in endpoint definition\nAdd the following specification for the sign-in endpoint to `openapi.yaml`:\n\n```", "```java\n\nThe sign-in API uses the new request payload object – `SignInReq`. The object just contains the username and password fields. Let’s add it, as follows:\n\n```", "```java\n\nNow, let’s add the sign-out endpoint.\nSign-out endpoint\nAdd the following specification for the sign-out endpoint to `openapi.yaml`:\n\n```", "```java\n\nIn an ideal scenario, you should remove the refresh token of a user received from the request. You can fetch the user ID from the token itself and then use that ID to remove the refresh token from the `USER_TOKEN` table. This endpoint requires you to send a valid access token.\nWe have opted for an easy way to remove the token, which is for it to be sent by the user as a payload. Therefore, this endpoint needs the following new model, `RefreshToken`. Here is the code to add the model:\n\n```", "```java\n\nFinally, let’s add an endpoint to refresh the access token.\nRefresh token endpoint\nAdd the following specification for the refresh token endpoint to `openapi.yaml`:\n\n```", "```java\n\nHere, we have used an exception by defining the refresh endpoint, in terms of forming a URI that represents the refresh token resources. Ideally, a `POST` call generates the new resource defined in URI. However, this endpoint generates the access token in place of the refresh token inside the response object, `SignedInUser`.\nIn the existing code, we don’t have a table to store the refresh token. Therefore, let’s add one.\nStoring the refresh token using a database table\nYou can modify the Flyway database script to add a new table, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/db/migration/V1.0.0__Init.sql](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/db/migration/V1.0.0__Init.sql)\nHere, the table contains three fields – `id`, `refresh_token`, and `user_id` – for storing the row identifier (primary key), the refresh token, and the user’s ID, respectively. Also, we have put the table name `user` in double quotation marks because the H2 database also makes use of the term `\"user\"`.\nNow, you have completed the API specification modification for authentication and authorization. Next, let’s start writing the implementation code for JWT-based authentication.\nImplementing the JWT manager\nLet’s add a constant class that contains all the constants related to the security functionality before we implement the JWT manager class, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/Constants.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/Constants.java)\nThese constants are self-explanatory, except the `EXPIRATION_TIME` long value (`900_000`), which represents 15 minutes as a time unit.\nNow, we can define the JWT manager class – `JwtManager`. `java-jwt` library from [auth0.com](http://auth0.com). We will use public/private keys to sign the token. Let’s define this class, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/JwtManager.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/JwtManager.java)\nHere, `JWT` is a class from the `java-jwt` library that provides a fluent API to generate the token. It adds issuer (`iss`), subject (`sub`), issued at (`iat`), and expired at (`exp`) claims.\nIt also adds a custom claim, `ROLE_CLAIM` (`roles`), which is populated using authorities from `UserDetails`. This is an interface provided by Spring Security. You can use the `org.springframework.security. core.userdetails.User.builder()` method to create a `UserBuilder` class. `UserBuilder` is a final builder class that allows you to build an instance of `UserDetails`.\nFinally, this method (`JwtManager.create()`) signs the JWT, using `SHA256` with the RSA algorithm by calling the `sign` operation, which uses the provided public and private RSA keys. The JWT header specifies an `HS256` value for the algorithm (`alg`) claim.\nSigning is done using the public and private RSA keys. Let’s add the code for RSA key management in our sample e-commerce application.\nGenerating the public/private keys\nYou can use JDK’s keytool to create a key store and generate public/private keys, as shown in the following code snippet:\n\n```", "```java\n\nThe generated key store should be placed under the `src/main/resources` directory.\nImportant note\nPublic/private keys are valid only for 90 days from the time they are generated. Therefore, make sure that you create a new set of public/private keys before you run this chapter’s code.\nRequired values used in the `keytool` command should also be configured in the `application.properties` file, as shown here:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/application.properties)\nNow, we can configure the key store and public/private keys in the security configuration class.\nConfiguring the key store and keys\nLet’s add a `SecurityConfig` configuration class to configure the security relation configurations. This class extends the `WebSecurityConfigurerAdapter` class. Here’s the code to do this:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java)\nHere, we have added all the properties defined in `application.properties`.\nNow, we can make use of the properties defined in `application.properties` to configure the `KeyStore`, `RSAPrivateKey`, and `RSAPublicKey` beans in the security configuration class, as shown in the following few subsections.\nKeyStore bean\nYou can create a new bean for KeyStore by adding the following method and annotating it with `@Bean` in `SecurityConfig.java`:\n\n```", "```java\n\nThis creates a `KeyStore` instance, using the `KeyStore` class from the `java.security` package. It loads the key store from the `src/main/resources` package and uses the password configuration in the `application.properties` file.\nLet’s define the `RSAPrivateKey` bean next.\nRSAPrivateKey bean\nYou can create a new bean for `RSAPrivateKey` by adding the following method and annotating it with `@Bean` in `SecurityConfig.java`:\n\n```", "```java\n\nThis method uses a key alias and a private key password to retrieve the private key, which is used to return the `RSAPrivateKey` bean.\nLet’s define the `RSAPublicKey` bean next.\nRSAPublicKey bean\nYou can create a new bean for `RSAPublicKey` by adding the following method and annotating it with `@Bean` in `SecurityConfig.java`:\n\n```", "```java\n\nAgain, a key alias is used to retrieve the certificate from the key store. Then, the public key is retrieved from the certificate and returned.\nAs you know, `JwtManager` uses these public and private RSA keys to sign the JWT; therefore, a JWT decoder should use the same public key to decode the token. The Spring OAuth 2.0 resource server uses the `org.springframework.security.oauth2.jwt. JwtDecoder` interface to decode the token. Therefore, we need to create an instance of the `JwtDecoder` implementation and set the same public key in it to decode the token.\nThe Spring OAuth 2.0 resource server provides a `NimbusJwtDecoder` implementation class of `JwtDecoder`. Let’s now create a bean of it with the public key.\nJwtDecoder bean\nYou can create a new bean for `JwtDecoder` by adding the following method and annotating it with `@Bean` in `SecurityConfig.java`:\n\n```", "```java\n\nYou have defined all the beans required to sign the JWT token. Now, you can implement the newly added REST APIs.\nImplementing new APIs\nLet’s implement the APIs exposed using `UserApi`. This is a code part that was autogenerated using OpenAPI Codegen. First, you need to define a new entity mapped to the `user_token` table.\nCoding user token functionality\nYou can create `UserTokenEntity` based on the `user_token` table, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/UserTokenEntity.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/UserTokenEntity.java)\nSimilarly, we can expose the following CRUD repository for `UserTokenEntity` with the following two methods – `deleteByUserId()`, which will remove the `UserToken` table record based on a given user ID, and `findByRefreshToken()`, which will find the `UserToken` table record based on a given refresh token. The code is illustrated in the following snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserTokenRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserTokenRepository.java)\nYou have defined both the entity and its repository. Now, you will add new operations in `UserService` that will consume these new classes.\nEnhancing the UserService class\nWe also need to add new methods to `UserService` for the `UserApi` interface. Let’s add new methods to the service, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserService.java)\nHere, each method performs a specific operation, as outlined here:\n\n*   `findUserByUsername()`: This finds and returns a user based on a given username.\n*   `createUser()`: This adds a new signed-up user to the database.\n*   `getSignedInUser()`: This creates a new model instance of `SignedInUser` that holds the refresh token, access token (JWT), user ID, and username.\n*   `getAccessToken()`: This generates and returns a new access token (JWT) for a given valid refresh token.\n*   `removeRefreshToken()`: This removes the refresh token from the database. It is called when the user wants to sign out.\n\nLet’s implement each of these methods in the `UserServiceImpl` class.\nImplementing findUserByUsername()\nFirst, you can add the implementation for `findUserByUsername()` in `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserServiceImpl.java)\nThis is a straightforward operation. You query the database based on a given username. If the username is found, then it returns the user; otherwise, it throws a `UsernameNotFoundException` exception.\ncreateUser() implementation\nNext, you can add the implementation for the `createUser()` method to the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nHere, we first check whether an existing user was assigned the same username or email in the sign-up request. If there was, an exception is simply raised; otherwise, a new user is created in the database and a `SignedInUser` instance is returned with refresh and access tokens, using the `createSignedUserWithRefreshToken()` method.\nFirst, we can add a private `createSignedUserWithRefreshToken()` method in the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nThis also uses another private method, `createSignedInUser()`, which returns `SignedInUser`; then, it adds the refresh token by calling the `createRefreshToken()` method.\nLet’s define the two `createSignedInUser()` and `createRefreshToken()` private methods in the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nHere, `tokenManager` is used in the `createSignedIn()` method to create the JWT. `tokenManager` is an instance of `JwtManager`. The `User.builder()` method is used to create a `UserBuilder` class. `UserBuilder`, which is a final builder class, is used to create an instance of `UserDetails`. The `JwtManager.create()` method uses this `UserDetails` instance to create a token.\nThe `createRefreshToken()` method uses the `RandomHolder` private static class to generate a refresh token. This token is not a JWT; we can use a longer-lasting valid token, such as one valid for a day, as a refresh token. Saving a JWT as a refresh token in the database removes the sole purpose of using the JWT because it expires by the configured time, and it should not be stored in the database, as it automatically becomes invalid. Therefore, we should think carefully before using a JWT as a refresh token and then saving it in the database.\nLet’s add the `RandomHolder` private static class to the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nThis class uses a `SecureRandom` instance to generate a random `BigInteger` instance. Then, this random `BigInteger` value is converted into a string with a radix size of `32`. Finally, the space is replaced with `0` if found in a converted string.\nYou can also use the `org.apache.commons.lang3.RandomStringUtils. randomAlphanumeric()` method, or use any other secured random key generator, to generate a refresh token.\nWe also need to modify the `UserRepository` class to add a new method that returns the count of users with a given username or email.\ngetSignedInUser() implementation\nThe implementation of the `getSignedInUser()` method is straightforward. Add it to the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nHere, this method first removes the existing token from the database associated with the given user, and then it returns the new instance of `SignedInUser` that was created using `createSignedUserWithRefreshToken()`, defined previously in the *createUser()* *implementation* subsection.\ngetAccessToken() implementation\nThe implementation of the `getAccessToken()` method is, again, straightforward. Add it to the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nFirst, the `getAccessToke()` method finds the user’s token entity using the `UserTokenRepository` instance. Then, it populates the `SignedInUser` POJO using the retrieved `UserToken` entity. The `createSignedInUser()` method does not populate the refresh token; therefore, we assign the same refresh token back. If it does find the user token entry in the database based on the refresh token, it throws an exception.\nAlso, you can add a validation for time that will remove/invalidate the refresh token, which has not been added here for simplicity.\nYou can also add a time validation logic for the refresh token – for example, storing the refresh token creation time in the database and using the configured valid time for refresh token validation, which is a kind of expiration logic for JWTs.\nremoveRefreshToken() implementation\nYou can add the `removeRefreshToken()` method to the `UserServiceImpl` class, as shown in the following code snippet:\n\n```", "```java\n\nFirst, the method finds the given refresh token in the database. If this is not found, then it throws an exception. If the given refresh token is found in the database, then it deletes it.\nYou have implemented all the extra methods added to the `UserService` class. Now, you will add additional methods in `UserRespository` too in the following section.\nEnhancing the UserRepository class\nLet’s add the `findByUsername()` and `findByUsernameOrEmail()` methods to `UserRepository`, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserRepository.java)\nThe `findByUsernameOrEmail` method returns a count of the records matching the given username or email.\nYou are now ready to implement the new APIs added to the `UserApi` interface to write the REST controllers. Let’s do that next.\nImplementing the REST controllers\nIn the previous section, you developed and enhanced the services and repositories required to implement the APIs defined in the `UserApi` interface, generated by OpenAPI Codegen. The only pending dependency is `PasswordEncoder`. `PasswordEncoder` is required to encode the password before storing and matching the given password in the sign-in request.\nAdding a bean for PasswordEncoder\nYou should expose the `PasswordEncoder` bean because Spring Security needs to know which encoding you want to use for password encoding, as well as for decoding the passwords. Let’s add a `PasswordEncoder` bean to `AppConfig`, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/AppConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/AppConfig.java)\nHere, you can directly create a new instance of `BcryptPasswordEncoder` and return it for `bcrypt` encoding. However, the use of `DelegatingPasswordEncoder` not only allows you to support existing passwords but also facilitates migration to a new, better encoder if one is available in the future. This code uses `Bcrypt` as a default password encoder, which is the best among the currently available encoders.\nFor `DelegatingPasswordEncoder` to work, you need to add a hashing algorithm prefix such as `{bcrypt}` to encoded passwords – for example, add `{bcrypt}$2a$10$neR0EcYY5./tLVp4litNyuBy/ kfrTsqEv8hiyqEKX0TXIQQwC/5Rm` to the persistent store if you already have a hashed password in the database, or if you’re adding any seed/test users to the database script. The new password will store the password with a prefix anyway, as configured in the `DelegatingPasswordEncoder` constructor. You have passed `bcrypt` into the constructor; therefore, all new passwords will be stored with a `{``bcrypt}` prefix.\n`PasswordEncoder` reads the password from the persistence store and removes the prefix before matching. It uses the same prefix to find out which encoder it needs to use for matching. Now, you can start implementing the new APIs based on `UserApi`.\nImplementing the Controller class\nFirst, create a new `AuthController` class, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/controller/AuthController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/controller/AuthController.java)\nThe `AuthController` class is annotated with `@RestController` to mark it as a REST controller. Then, it uses two beans, `UserService` and `PasswordEncoder`, which will be injected at the time of the `AuthController` construction.\nFirst, let’s add the sign-in operation, as follows:\n\n```", "```java\n\nThe operation first finds the user and matches the password using the `PasswordEncoder` instance. If everything goes through successfully, it returns the `SignedInUser` instance with refresh and access tokens; otherwise, it throws an exception.\nLet’s add other operations to `AuthController`, as follows:\n\n```", "```java\n\nAll operations such as `signOut()`, `signUp()`, and `getAccessToken()` are straightforward, as outlined here:\n\n*   `signOut()` uses the user service to remove the given refresh token. Ideally, you would like to get the user ID from the logged-in user’s request and remove the refresh token, based on the retrieved user ID from the request.\n*   `signUp()` creates a valid new user and returns the `SignedInUser` instance as a response. Here, we haven’t added the validation of the payload for simplicity. In a real-world application, you must validate the request payload.\n*   `getAccessToken()` returns `SignedInUser` with a new access token if the given refresh token is valid.\n\nWe have finished coding the controllers. Let’s configure security in the next subsection.\nConfiguring web-based security\nThis is the last puzzle to sort out the authentication and authorization piece. The `SecurityConfig` class is also annotated with `@EnableWebSecurity`. With the new version of Spring Security, you now don’t need to extend `WebSecurityConfigurerAdapter` and override the `configure()` method, as we did in the last edition of this book. Instead, you now create a bean that returns the configured instance of the `SecurityFilterChain` class.\nThe method (`filterChain`) that returns `SecurityFilterChain` takes `HttpSecurity` as a parameter. `HttpSecurity` contains DSL (fluent methods). You can make use of these methods to configure web-based security, such as which web paths to allow and which method to allow. Let’s make the following configurations using these fluent methods to return the `SecurityFilterChain` instance, as shown in the following code snippet from `SecurityConfig.java`:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java)\nHere, you configure the following security settings:\n\n1.  First of all, you disable the basic authentication and form login using the `disable()` method.\n2.  Then, you ignore the CSRF configuration for the API base path and H2 console URLs.\n3.  Then, you set the headers setting for frame options that have the same origin to allow the H2 console application to work fine in the browser. The H2 console UI is based on HTML frames. The H2 console UI won’t display in browsers because, by default, the security header (`X-Frame-Options`) is not sent with permission to allow frames with the same origin. Therefore, you need to configure `headers().frameOptions().sameOrigin()`.\n4.  Then, you enable the CORS setting. You’ll learn more about this in the next section.\n5.  Then, you configure the authorization of the request, which takes the request object as a parameter. You use this request object to restrict access, based on URL patterns, by using the `requestMatchers()` method and an instance of the `AntPathRequestMatcher` class:\n    *   Configure URL patterns and respective HTTP methods using `mvcMatchers()`, which uses the same pattern-matching style as a Spring `Static method toH2Console()` is a utility that provides a matcher that includes the H2 console location.\n    *   The `/api/v1/addresses/** ` pattern has been configured to be accessed only by the user who has the `ADMIN` role, by calling `hasAuthority()` and passing the admin authority in it. You’ll learn more about it in the *Understanding authorization* section of this chapter.\n6.  All URLs, except those configured explicitly by `authorizeHttpRequests()`, should be allowed by any authenticated user (by using `anyRequest(). authenticated()`).\n    *   Enable JWT bearer token support for the OAuth 2.0 resource server (`oauth2ResourceServer.jwt()`).\n    *   Enable the `STATELESS` session creation policy (that is, `sessionManagement().sessionCreationPolicy` won’t create any `HTTPSession`)\n7.  Finally, the `filterChain` method returns `SecurityFilterChain` by building the instance from the configured `HttpSecurity` instance (the `http.build()` call).\n\nIn this section, you learned how to configure Spring security for authentication and authorization. Next, we will learn about the CORS and CSRF.\nConfiguring CORS and CSRF\nBrowsers restrict cross-origin requests from scripts for security reasons. For example, a call from `http://mydomain.com` to `http://mydomain-2.com` can’t be made using a script. Also, an origin not only indicates a domain but also includes a scheme and a port.\nBefore hitting any endpoint, the browser sends a pre-flight request using the HTTP method option to check whether the server will permit the actual request. This request contains the following headers:\n\n*   The actual request’s headers (`Access-Control-Request-Headers`).\n*   A header containing the actual request’s HTTP method (`Access-Control- Request-Method`).\n*   An `Origin` header that contains the requesting origin (scheme, domain, and port).\n*   If the response from the server is successful, then only the browser allows the actual request to fire. The server responds with other headers, such as `Access- Control-Allow-Origin`, which contains the allowed origins (an asterisk `*` value means any origin), `Access-Control-Allow-Methods` (allowed methods), `Access-Control-Allow-Headers` (allowed headers), and `Access-Control-Max-Age` (allowed time in seconds).\n\nYou can configure CORS to take care of cross-origin requests. For that, you need to make the following two changes:\n\n*   Add a `CorsConfigurationSource` bean that takes care of the CORS configuration using a `CorsConfiguration` instance.\n*   Add the `cors()` method to `HTTPSecurity` in the `configure()` method. The `cors()` method uses `CorsFilter` if a `corsFilter` bean is added; otherwise, it uses `CorsConfigurationSource`. If neither is configured, then it uses the Spring MVC pattern inspector handler.\n\nLet’s now add the `CorsConfigurationSource` bean to the `SecurityConfig` class.\nThe default permitted values (`new CorsConfiguraton(). applyPermitDefaultValues()`) configure CORS for any origin (`*`), all headers, and simple methods (`GET`, `HEAD`, and `POST`), which have an allowed max age of `30` minutes.\nYou need to allow mostly all of the HTTP methods, including the `DELETE` method, and you need more custom configuration; therefore, we will use the following bean definition in `SecurityConfig.java`:\n\n```", "```java\n\nHere, you create a `CorsConfiguration` instance using the default constructor and then set the allowed origins, allowed methods, and response headers. Finally, you pass it as an argument while registering it to the `UrlBasedCorsConfigurationSource` instance and returning it.\nIn the previous section, inside the `SecurityChainFilter` method annotated with `@Bean`, you have configured CSRF using the `csrf()` DSL. We have applied CSRF protection to all URLs, except URLs starting with `/api/v1` and the `/h2-console` H2 database console URLs. You can change the configuration based on your requirement.\nLet’s first understand what CSRF/XSRF is. **CSRF** or **XSRF** stands for **cross-site request forgery**, which is a web security vulnerability. To understand how this vulnerability comes into effect, let’s assume you are a bank customer and are currently signed in to your account online. While you are logged in, you may receive an email and click on a link in it, or on any other malicious website’s link, that contains a malicious script. This script can then send a request to your bank for a fund transfer. The bank then transfers the funds to a perpetrator’s account because the bank thinks that the request has been sent by you, as you are signed in. Hackers can use this vulnerability similarly for different hacking activities.\nTo prevent such attacks, the application sends new unique CSRF tokens associated with the signed-in user for each new request. These tokens are stored in hidden form fields. When a user submits a form, the same token should be sent back with the request. The application then verifies the CSRF token and only processes the request if the verification is successful. This works because malicious scripts can’t read the token due to the same origin policy.\nHowever, if a perpetrator also tricks you into revealing the CSRF token, then it is very difficult to prevent such attacks. You can disable CSRF protection for this web service by using `csrf().disable()` because we only expose REST endpoints.\nNow, let’s move on to the final section, where you will configure the authorization based on the user’s role.\nUnderstanding authorization\nYour valid username/password or access token for authentication gives you access to secure resources, such as URLs, web resources, or secure web pages. Authorization is one step ahead; it allows you to configure access security further with scopes such as read, write, or roles such as Admin, User, and Manager. Spring Security allows you to configure any custom authority.\nWe will configure three types of roles for our sample e-commerce app – namely, Customer (user), Admin, and Customer Support Representative (CSR). Obviously, each user will have their own specific authority. For example, a user can place an order and buy stuff online but should not be able to access the CSR or admin resources. Similarly, a CSR should not be able to have access to admin-only resources. A security configuration that allows authority or role-based access to resources is known as authorization. A failed authentication should return an HTTP `401` status (unauthorized), and a failed authorization should return an HTTP `403` status (forbidden), which means the user is authenticated but does not have the required authority/role to access the resource.\nLet’s introduce these three roles in a sample e-commerce app, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/RoleEnum.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/RoleEnum.java)\nHere, we declared an `enum` that implements Spring Security’s `GrantedAuthority` interface to override the `getAuthority()` method. `GrantedAuthority` is an authority granted to an `Authentication` (interface) object. As you know, `BearerTokenAuthenticationToken` is a type of `AbstractAuthenticationToken` class that implements the authentication interface, which represents the token/principal for an authenticated request. We have used the string constants for the user’s roles in this `enum`, as we need these when we configure the role-based restriction at a method level.\nLet’s discuss the role and authority in detail.\nRole and authority\nAn authority can be assigned for fine-grained control, whereas roles should be applied to large sets of permissions. A role is an authority that has the `ROLE_` prefix. This prefix is configurable in Spring Security.\nSpring Security provides the `hasRole()` and `hasAuthority()` methods to apply role- and authority-based restrictions. `hasRole()` and `hasAuthority()` are almost identical, but the `hasRole()` method maps with `Authority` without the `ROLE_` prefix. If you use `hasRole` (`'ADMIN'`), your `Admin` enum must be `ROLE_ADMIN` instead of `ADMIN` because a role is an authority and should have a `ROLE_` prefix, whereas if you use `hasAuthority` (`'ADMIN'`), your `Admin` enum must be only `ADMIN`.\nThe OAuth 2.0 resource server, by default, populates authorities based on the scope (`scp`) claim. If you provide access to a user’s resources, such as order history for integration with another application, then you can limit an application’s access to a user’s account before granting access to other applications for third-party integration. Third-party applications can request one or more scopes; this information is then presented to the user on the consent screen, and the access token issued to the application will be limited to the scopes granted. However, in this chapter, we haven't provided OAuth 2.0 authorization flows and will limit security access to REST endpoints.\nIf the JWT contains a claim with the name *scope* (`scp`), then Spring Security will use the value in that claim to construct the authorities by prefixing each value with `SCOPE_`. For example, if a payload contains a `scp=[\"READ\",\"WRITE\"]` claim, this means that an `Authority` list will consist of `SCOPE_READ` and `SCOPE_WRITE`.\nWe need to change the default authority mapping behavior because a scope (`scp`) claim is the default authority for the OAuth2.0 resource server in Spring. We can do that by adding a custom authentication converter to `JwtConfigurer` in `OAuth2ResourceServer` in your security configuration. Let’s add a method that returns the converter, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java)\nHere, we first create a new instance of `JwtGrantedAuthorityConverter` and then assign an authority prefix (`ROLE_`) and authority claim name (the key of the claim in JWT) as `roles`.\nNow, we can use this private method to configure the OAuth 2.0 resource server. You can now modify the existing configuration with the following code. We can also add configuration to add role-based restrictions to the `POST` `/api/v1/addresses` API call, in the following code snippet in `SecurityConfig.java`:\n\n```", "```java\n\nAfter setting this configuration to add an address (`POST /api/v1/addresses`), it now requires both authentication and authorization. This means the logged-in user must have the `ADMIN` role to call this endpoint successfully. Also, we changed the default claim from scope to role.\nNow, we can proceed further with method-level, role-based restrictions. Spring Security provides a feature that allows you to place authority- and role-based restrictions on public methods of Spring beans, using a set of annotations such as `@PreAuthorize`, `@Secured`, and `@RolesAllowed`. By default, these are disabled; therefore, you need to enable them explicitly.\nLet’s enable these by adding the `@EnableGlobalMethodSecurity(prePostEnabled = true)` annotation to the Spring Security configuration class, as follows:\n\n```", "```java\n\nNow, you can use the `@PreAuthorize` (the given access-control expression would be evaluated before the method invocation) and `@PostAuthorize` (the given access-control expression would be evaluated after the method invocation) annotations to place restrictions on public methods of Spring beans because you have set the `prePostEnabled` property to `true` when enabling the global method-level security.\n`@EnableGlobalMethodSecurity` also supports the following properties:\n\n*   `securedEnabled`: This allows you to use `@Secured` annotation on public methods.\n*   `jsr250Enabled`: This allows you to use JSR-250 annotations such as `@RolesAllowed`, which can be applied to both public classes and methods. As the name suggests, you can use a list of roles for access restrictions.\n\n`@PreAuthorize` and `@PostAuthorize` are more powerful than the other security annotations because not only can they be configured for authorities/roles but also for any valid **Spring Expression Language** (**SpEL**) expression:\n\n```", "```java\n\nLet’s break down the preceding code snippet:\n\n*   `hasRole()` is a built-in `SpEL` expression. We need to pass a valid `SpEL` expression, and it should be a string. Any variable used to form this `SpEL` expression should be final. Therefore, we have declared the final string constants in the `RoleEnum` enum (for example, `Const.ADMIN`).\n*   Now, the `DELETE /api/v1/addresses/{id}` REST API can only be invoked if the user has the `ADMIN` role.\n*   Spring Security provides various built-in `SpEL` expressions, such as `hasRole()`. Here are some others:\n    *   `hasAnyRole(String… roles)`: This returns `true` if the principal’s role matches any of the given roles.\n    *   `hasAuthority(String authority)`: This returns `true` if the principal has given authority. Similarly, you can also use `hasAnyAuthority(String… authorities)`.\n    *   `permitAll`: This returns `true`.\n    *   `denyAll`: This returns `false`.\n*   `isAnonymous()`: This returns `true` if the current user is anonymous.\n*   `isAuthenticated()`: This returns `true` if the current user is not anonymous.\n\nA full list of these expressions is available at [https://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html](https://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html).\nSimilarly, you can apply access restrictions for other APIs. Let’s test security in the next section.\nTesting security\nBy now, you must be looking forward to testing. You can find the API client collection at the following location. You can import it and then test the APIs, using any API client that supports the HAR type file import: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har).\nImportant note\nMake sure to generate the keys again, as keys generated by the JDK keytool are only valid for 90 days.\nBuilding and running the Chapter 06 code\nYou can build the code by running `gradlew clean build` from the root of the project, and you can run the service using `java -jar build/libs/Chapter06-0.0.1-SNAPSHOT.jar`. Make sure to use Java 17 in the path.\nNow, let’s test our first use case.\nLet’s fire the `GET /api/vi/addresses` API without the `Authorization` header, as shown in the following command:\n\n```", "```java\n\nThis returns the HTTP `401` status (`unauthorized`) and a `WWW-Authenticate: Bearer` response header, which suggests the request should be sent with an `Authorization` header.\nLet’s send the request again with an invalid token, as shown in the following command:\n\n```", "```java\n\nAgain, it returns the `401` response.\nWe have created two users using a Flyway database migration script – `scott/tiger` and `scott2/tiger`. Now, let’s perform a sign-in with the username `scott` to get the valid JWT, as follows:\n\n```", "```java\n\nThis returns with both a refresh and an access token. Let’s use this access token to call the `GET /api/v1/addresses` API again (please note that the `Bearer` token value in the `Authorization` header is taken from the response of the previous `POST /api/v1/ auth/token` API call). The command is shown in the following block:\n\n```", "```java\n\nThis command execution returns `403`. It means that the user was authenticated successfully. However, the user doesn’t contain the required role to access the endpoint.\nLet’s try again, with user `scott2` this time, who has an ADMIN role:\n\n```", "```java\n\nThis time, the call is successful. Now, let’s use the refresh token to get a new access token, as follows:\n\n```", "```java\n\nThis time, it returns a new access token with the same refresh token given in the payload.\nIf you pass an invalid refresh token while calling the refresh token API, it will provide the following response:\n\n```", "```java\n\nSimilarly, you can call other API endpoints. Alternatively, you can import the following HAR file in an API client, such as Insomnia, and then test the remaining APIs: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har).\nSummary\nIn this chapter, you learned about JWTs, Spring Security, authentication using filters, and JWT token validation, using filters and authentication with the Spring OAuth 2.0 resource server. You also learned how you can add CORS and CSRF protection and why these are necessary.\nYou also learned about access protection based on roles and authorities. You have now the skills to implement JWTs, Spring Security, and the Spring Security OAuth 2.0 resource server to protect your web resources.\nIn the next chapter, you will develop a sample e-commerce app’s UI using the Spring Security framework and APIs used in this chapter. This integration will allow you to understand the UI flows and how to consume REST APIs using JavaScript.\nQuestions\n\n1.  What is a security context and a principal?\n2.  Which is the preferred way to secure a JWT – signing or encrypting a token?\n3.  What are the best practices to use a JWT?\n\nAnswers\n\n1.  The security context stores the principal using `SecurityContextHolder` and is always available in the same thread of execution. The security context allows you to extract the principal during the flow execution and use it wherever you want. This is where a security annotation such as `@PreAuthorize` makes use of it for validation. The principal is the currently logged-in user. It can either be an instance of `UserDetails` or a string carrying a username. You can use the following code to extract it:\n\n    ```", "```java\n\n     2.  This is a subjective question. However, it is recommended to use the signing of tokens (JWS) if a JWT doesn’t contain sensitive and private information, such as date of birth or credit card information. In such cases, you should make use of JWE to encrypt the information. If you want to use both together, then the preferred way is to use encryption for information carried by the token and then sign it with keys.\n3.  You can follow the following guidelines and add to them if you discover any new ones:\n    *   Make sure that JWT always has issuer and audience validations.\n    *   Make sure that a JWT validation does not allow a `none` algorithm (i.e., no algorithm mentioned in JWT or when the `alg` field in the JWT header contains a `none` value). Instead, make sure that you have verification in place that checks the specific algorithm (whatever you configured) and a key.\n    *   Keep an eye on the **National Vulnerability** **Database** (**NVD**).\n    *   Don’t use a weak key (secret). Instead, use the asymmetric private/public keys with SHA 256, SHA 384, and SHA 512.\n    *   Use a minimum key size of 2,048 for normal cases and 3,072 for business cases.\n    *   A private key should be used for authentication, and the verification server should use a public key.\n    *   Make sure clients use the security guidelines to store the tokens, and web applications should use HTTPS for communication with servers.\n    *   Make sure the web application is tested thoroughly for **cross-site scripting** (**XSS**) attacks. It is always best to use a **content security** **policy** (**CSP**).\n    *   Keep a short expiration time, and use a refresh token to refresh an access token.\n    *   Keep an eye on OWASP security guidelines and new threats.\n\nFurther reading\n\n*   *Hands-On Spring Security 5.x* (video course): [https://www.packtpub.com/product/hands-on-spring-security-5-x-video/9781789802931](https://www.packtpub.com/product/hands-on-spring-security-5-x-video/9781789802931)\n*   Spring Security documentation: [https://docs.spring.io/spring-security/site/docs/current/reference/html5/](https://docs.spring.io/spring-security/site/docs/current/reference/html5/)\n*   JWT: [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)\n*   JWS: [https://www.rfc-editor.org/info/rfc7515](https://www.rfc-editor.org/info/rfc7515)\n*   JWE: [https://www.rfc-editor.org/info/rfc7516](https://www.rfc-editor.org/info/rfc7516)\n*   Spring Security in-built `SpEL` expressions: [https://docs.spring.io/spring-security/site/docs/3.0.x/refsseerence/el-access.html](https://docs.spring.io/spring-security/site/docs/3.0.x/refsseerence/el-access.html)\n\n```"]