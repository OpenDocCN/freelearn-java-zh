- en: Consideration of Structural and Behavioral Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构和行为模式的考虑
- en: You have seen implementations and examples of the creational design pattern
    from the GOF pattern family in [Chapter 2](75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml),
    *Overview of GOF Design Patterns - Core Design Patterns.* Now, in this chapter,
    you'll be given an overview of other parts of GOF Design Patterns, they are the
    structural and behavioral design patterns, including some best practices for application
    design. You'll also get an overview of common problem solving with these design
    patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在[第2章](75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml)中看到了GOF模式家族的创建型设计模式的实现和示例，*GOF设计模式概述
    - 核心设计模式*。现在，在本章中，您将获得GOF设计模式其他部分的概述，它们是结构和行为设计模式，包括一些应用设计的最佳实践。您还将了解如何使用这些设计模式解决常见的问题。
- en: At the end of this chapter, you will understand how these design patterns provide
    the best solution to address the design and development related issues in the
    object composition and delegating responsibilities between the working objects
    in the application. You will get information about how the Spring Framework implements
    the structural and behavioral designs pattern internally to provide best enterprise
    solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解这些设计模式如何提供最佳解决方案来解决对象组合以及应用中工作对象之间责任委派的设计和开发相关的问题。您将了解Spring框架如何内部实现结构和行为设计模式以提供最佳企业解决方案。
- en: 'This chapter will cover the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下要点：
- en: Implementing the structural design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现结构设计模式
- en: Implementing the behavioral design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现行为设计模式
- en: J2EE design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J2EE设计模式
- en: Examining the core design patterns
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查核心设计模式
- en: 'Let''s continue our journey into the core design patterns:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的核心设计模式之旅：
- en: '**Structural design pattern**: Patterns under this category deal with the composition
    of classes or objects. In the enterprise application, there are two common techniques
    for reusing functionality in object-oriented systems as follows:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构设计模式**：这个类别下的模式处理类或对象的组合。在企业应用中，有两种常见的技巧用于在面向对象系统中重用功能，如下所示：'
- en: '**Inheritance**: It is used to inherit commonly used states and behaviors from
    other classes.'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：它用于从其他类继承常用的状态和行为。'
- en: '**Composition**: It is used to compose the other objects as instance variables
    of classes. It defines ways to compose objects to obtain new functionalities.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：它用于将其他对象作为类的实例变量来组合。它定义了如何组合对象以获得新的功能。'
- en: '**Behavioral design pattern**: Patterns under this category characterize the
    ways in which classes or objects interact with and distribute responsibility.
    These patterns define the methods of communication between the objects in the
    enterprise application. So here, you will learn how to use behavioral patterns
    to reduce complicated flow control. Furthermore, you will use behavioral patterns
    to encapsulate algorithms and dynamically select them at runtime.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为设计模式**：这个类别下的模式描述了类或对象如何相互交互和分配责任。这些模式定义了企业应用中对象之间的通信方法。因此，在这里，您将学习如何使用行为模式来简化复杂的流程控制。此外，您还将使用行为模式来封装算法并在运行时动态选择它们。'
- en: Structural design patterns
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: In the previous section, we discussed creational design patterns and how they
    provide the best solutions for object creation according to business demands.
    Creational design patterns only provide a solution for creating objects in the
    application with how these objects merge with each other in the application for
    a specific business goal, the structural design pattern comes into the picture.
    In this chapter, we will be exploring structural patterns, and how these patterns
    are useful to define the relationship between the objects either using inheritance
    or composition for larger structures of an application. Structural patterns allow
    you to solve many problems related to structuring the relationship between the
    objects. They show you how to glue different parts of a system together in a flexible
    and extensible fashion. Structural patterns help you guarantee that when one of
    the parts changes, the entire structure does not need to change; in a car you
    could replace the tyres with different vendors without impacting the other parts
    of that car. They also show you how to recast parts of the system that do not
    fit (but that you need to use) into parts that do fit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了创建型设计模式以及它们如何根据业务需求提供最佳的对象创建解决方案。创建型设计模式只为在应用中创建对象提供了解决方案，但对于这些对象如何在应用中合并以实现特定的业务目标，结构型设计模式就派上用场了。在本章中，我们将探讨结构型模式，以及这些模式如何通过继承或组合来定义应用中对象之间的关系。结构型模式可以帮助你解决许多与对象结构相关的问题。它们展示了如何以灵活和可扩展的方式将系统的不同部分粘合在一起。结构型模式帮助你确保当某个部分发生变化时，整个结构不需要改变；例如，在汽车中，你可以更换不同供应商的轮胎，而不会影响汽车的其他部分。它们还展示了如何将系统中的某些部分（虽然不兼容但需要使用）重新塑造成兼容的部分。
- en: The adapter design pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: Convert the interface of a class into another interface clients expect. Adapter
    lets classes work together that couldn't otherwise because of incompatible interfaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类的接口转换为客户端期望的另一个接口。适配器使得原本因为接口不兼容而无法协作的类能够一起工作。
- en: '-GoF Design Patterns: Elements of Reusable Object-Oriented Software'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: -GoF 设计模式：可重用面向对象软件的元素
- en: Adapter design patterns come under the structural design pattern, according
    to this design pattern two incompatible classes work together that couldn't otherwise
    because of incompatible interfaces. This pattern works as a bridge between two
    incompatible interfaces. This pattern is used when two inferences of the application
    are incompatible in their functionalities, but these functionalities need to be
    integrated as a business requirement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个设计模式，适配器设计模式属于结构型设计模式。根据这个设计模式，两个不兼容的类因为接口不兼容而无法协作，这个模式充当了两个不兼容接口之间的桥梁。当应用中的两个功能在功能上不兼容，但根据业务需求需要集成时，就会使用这个模式。
- en: 'There are many real-life examples where we can use the adapter pattern. Suppose
    you have different types of electric plugs such as cylindrical and rectangular
    plugs, as shown in the following figure. You can use an adapter in between to
    fit a rectangular plug in a cylindrical socket assuming voltage requirements are
    met:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，有许多我们可以使用适配器模式的例子。假设你有不同类型的电源插头，如圆柱形和矩形插头，如下图所示。如果你需要将矩形插头插入圆柱形插座，并且满足电压要求，可以使用适配器：
- en: '![](img/5000d228-a61c-4e20-b993-7e743f469815.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![适配器设计模式示例](img/5000d228-a61c-4e20-b993-7e743f469815.jpg)'
- en: Benefits of the adapter pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式的好处
- en: Let's look at the following benefits of using the adapter design pattern in
    the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在应用中使用适配器设计模式的好处。
- en: The adapter pattern allows you to communicate and interact with two or more
    incompatible objects
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式允许你与两个或更多不兼容的对象进行通信和交互
- en: This pattern promotes the reusability of older existing functionalities in your
    application
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模式促进了你应用中现有功能的可重用性
- en: Common requirements for the adapter pattern
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式的一般要求
- en: 'The following are the common requirements for this design pattern to addresses
    the design problems:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个设计模式解决设计问题的常见要求：
- en: If you are to use this pattern in your application, there is a need to use an
    existing class with an incompatible interface.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你打算在你的应用中使用这个模式，就需要使用一个具有不兼容接口的现有类。
- en: Another use of this pattern in your application is when you want to create a
    reusable class that collaborates with classes that have incompatible interfaces.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用中，这个模式还有另一个用途，那就是当你想要创建一个与具有不兼容接口的类协作的可重用类时。
- en: There are several existing subclasses to be used, but it's impractical to adapt
    their interface by sub classing each one. An object adapter can adapt the interface
    of its parent class.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个现有的子类可供使用，但通过为每个子类创建子类来适配它们的接口是不切实际的。一个对象适配器可以适配其父类的接口。
- en: Let's see how Spring implements the adapter design pattern internally.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring是如何在内部实现适配器设计模式的。
- en: Implementation of the adapter design pattern in the Spring Framework
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架中适配器设计模式的实现
- en: 'Spring Framework uses the adapter design pattern to implement a lot of functionality
    across the framework transparently. The following are some listed classes based
    on the adapter design pattern in the Spring Framework:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架使用适配器设计模式在框架中透明地实现了很多功能。以下是根据Spring框架中的适配器设计模式列出的一些类：
- en: '`JpaVendorAdapter`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpaVendorAdapter`'
- en: '`HibernateJpaVendorAdapter`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HibernateJpaVendorAdapter`'
- en: '`HandlerInterceptorAdapter`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandlerInterceptorAdapter`'
- en: '`MessageListenerAdapter`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageListenerAdapter`'
- en: '`SpringContextResourceAdapter`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpringContextResourceAdapter`'
- en: '`ClassPreProcessorAgentAdapter`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassPreProcessorAgentAdapter`'
- en: '`RequestMappingHandlerAdapter`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestMappingHandlerAdapter`'
- en: '`AnnotationMethodHandlerAdapter`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationMethodHandlerAdapter`'
- en: '`WebMvcConfigurerAdapter`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebMvcConfigurerAdapter`'
- en: '**The UML diagram for the adapter pattern**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器模式的UML图**'
- en: 'Let''s understand the preceding UML diagram that illustrates the components
    of the adapter design pattern:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的UML图，该图说明了适配器设计模式的组件：
- en: '![](img/d434b73f-a719-4594-a789-0f07fdfa5ccb.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d434b73f-a719-4594-a789-0f07fdfa5ccb.jpg)'
- en: '**The Target Interface**: This is the desired interface class that will be
    used by the clients'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标接口**：这是将被客户端使用的期望接口类'
- en: '**The Adapter class**: This class is a wrapper class that implements the desired
    target interface and modifies the specific request available from the Adaptee
    class'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器类**：这个类是一个包装类，它实现了期望的目标接口，并修改了从适配者类可用的特定请求'
- en: '**The Adaptee class**: This is the class that is used by the Adapter class
    to reuse the existing functionalities and modify them for desired use'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配者类**：这是适配器类用来重用现有功能并对其进行修改以适应所需用途的类'
- en: '**Client**: This class will interact with the Adapter class'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这个类将与适配器类交互'
- en: Let's look at the following sample implementation of the adapter design pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下适配器设计模式的示例实现。
- en: Sample implementation of the adapter design pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式的示例实现
- en: 'I am going to create an example that shows the actual demonstration of the
    adapter design pattern, so let''s discuss this example, I am creating this example
    based on making payment through a payment gateway. Suppose I have one old payment
    gateway and also have the latest advanced payment gateway, and both gateways are
    unrelated to each other, so my requirement is, I want to migrate from the old
    payment gateway to an advanced payment gateway while changing my existing source
    code. I am creating an adapter class to solve this problem. This adapter class
    is working as a bridge between two different payment gateways, let''s look at
    the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个示例来展示适配器设计模式的实际演示，所以让我们讨论这个示例，我创建这个示例是基于通过支付网关进行支付。假设我有一个旧的支付网关和最新的高级支付网关，这两个网关之间没有关系，所以我的需求是，我想在更改现有源代码的同时，从旧的支付网关迁移到高级支付网关。我创建了一个适配器类来解决这个问题。这个适配器类作为两个不同支付网关之间的桥梁，让我们看看以下代码：
- en: 'Let''s now create an interface for the old payment gateway:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为旧的支付网关创建一个接口：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s now create an implementation class for the old payment gateway `PaymentGateway.java`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为旧的支付网关`PaymentGateway.java`创建一个实现类：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following interface and its implementation have new and advanced functionalities
    for the payment gateway:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下接口及其实现为支付网关提供了新的和高级的功能：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now create an implementation class for the advance payment gateway interface:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为高级支付网关接口创建一个实现类：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see a demo class for this pattern as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下这个模式的演示类：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding class, we have the old payment gateway object as the `PaymentGateway`
    interface, but we convert this old payment gateway implementation to the advanced
    form of the payment gateway by using the `AdvancedPaymentGatewayAdapter` adapter
    class. Let''s run this demo class and see the output as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，我们有旧的支付网关对象作为`PaymentGateway`接口，但我们通过使用`AdvancedPaymentGatewayAdapter`适配器类将这个旧的支付网关实现转换为高级支付网关形式。让我们运行这个演示类并查看以下输出：
- en: '![](img/a227c50d-f5fc-4ab5-8d81-13819b77e63d.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a227c50d-f5fc-4ab5-8d81-13819b77e63d.png)'
- en: Now that we've seen the adapter design pattern, let's turn to a different variant
    of it--the Bridge design pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了适配器设计模式，让我们转向它的一个不同变体——桥接设计模式。
- en: The Bridge design pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接设计模式
- en: Decouple an abstraction from its implementation so that the two can vary independently
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将抽象与其实现解耦，以便它们可以独立变化
- en: '- GoF Design Patterns: Elements of Reusable Object-Oriented Software'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '- GoF 设计模式：可重用面向对象软件的元素'
- en: In software engineering, one of the most popular notions is preferred composition
    over inheritance. Bridge design pattern promotes this popular notion. Similar
    to the adapter pattern, this pattern also comes under the structural design pattern
    family of the GoF Design Pattern. The approach of the Bridge pattern is to decouple
    an abstraction used by the client code from its implementation; that means it
    separates the abstraction and its implementation in to separate class hierarchies.
    And also, Bridge pattern prefers composition over inheritance because inheritance
    isn't always flexible and it breaks the encapsulation, so any change made in the
    implementer affects the abstraction used by the client code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，最受欢迎的观念之一是首选组合而非继承。桥接设计模式促进了这一流行观念。类似于适配器模式，这个模式也属于GoF设计模式中的结构设计模式家族。桥接模式的方法是将客户端代码使用的抽象与其实现解耦；这意味着它将抽象和其实现分离成独立的类层次。此外，桥接模式偏好组合而非继承，因为继承并不总是灵活的，它会破坏封装，所以对实现者所做的任何更改都会影响客户端代码使用的抽象。
- en: The bridge provides a way to communicate between two different independent components
    in software development, and a bridge structure provides you with a way to decouple
    the abstract class and the implementer class. So any change made in either the
    implementation class or the implementer (that is, the interface) doesn't affect
    the abstract class or its refined abstraction class. It makes this possible by
    using composition between the interface and the abstraction. Bridge pattern uses
    an interface as a bridge between the concrete classes of an abstract class and
    implementing classes of that interface. You can make changes in both types of
    class without any impact on the client code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接为软件开发中两个不同独立组件之间的通信提供了一种方式，桥接结构为你提供了解耦抽象类和实现类（即接口）的方式。所以对实现类或实现者（即接口）所做的任何更改都不会影响抽象类或其精炼的抽象类。它是通过在接口和抽象之间使用组合来实现的。桥接模式使用接口作为抽象类和实现类之间的桥梁。你可以在两种类型的类中做出更改，而不会对客户端代码产生影响。
- en: Benefits of the Bridge pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接模式的优点
- en: 'Following are the benefits of the Bridge design pattern:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为桥接设计模式的优点：
- en: The Bridge design pattern allows you to separate the implementation and the
    abstraction
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接设计模式允许你分离实现和抽象
- en: This design pattern provides the flexibility to change both types of classes
    without side effects in the client code
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此设计模式提供了在客户端代码中无副作用地更改两种类型类的灵活性
- en: This design pattern allows the hiding of actual implementation details from
    the client by using abstraction between them
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此设计模式允许通过它们之间的抽象来隐藏实际的实现细节
- en: Common problems solved by the Bridge design pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接设计模式解决的问题
- en: 'Following are the common problems addressed by the Bridge design pattern:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由桥接设计模式解决的常见问题：
- en: Removes a permanent binding between the functional abstraction and its implementation
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了功能抽象与其实现之间的永久绑定
- en: You can make changes to the implementing classes without affecting the abstraction
    and client code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在不影响抽象和客户端代码的情况下修改实现类
- en: You can extend the abstraction and its implementation using subclasses
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用子类扩展抽象及其实现
- en: Implementing the Bridge design pattern in the Spring Framework
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring框架中实现桥接设计模式
- en: 'The following Spring modules are based on the Bridge design pattern:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Spring模块基于桥接设计模式：
- en: '`ViewRendererServlet`: It is a bridge servlet, mainly for Portlet MVC support'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewRendererServlet`：它是一个桥接Servlet，主要用于Portlet MVC支持'
- en: '**The Bridge design pattern**: The Bridge design pattern is used in the Spring
    logging process'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接设计模式**：桥接设计模式用于Spring的日志处理过程'
- en: Let's see a sample implementation of the Bridge design pattern.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看桥接设计模式的示例实现。
- en: Sample implementation of the Bridge design pattern
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接设计模式的示例实现
- en: Let's look at the following example, where we will demonstrate the use of the
    Bridge design pattern. Suppose you want to open two types of accounts, one is
    a Savings Account and the other is a Current Account in the banking system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，我们将演示桥接设计模式的使用。假设你希望在银行系统中开设两种类型的账户，一种是储蓄账户，另一种是活期账户。
- en: '**System without using the Bridge design pattern**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**不使用桥接设计模式的系统**'
- en: 'Let''s look at an example without using the Bridge design pattern. In the following
    figure, you can see the relationship between the Bank and Account interfaces:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个不使用桥接设计模式的例子。在以下图中，你可以看到银行和账户接口之间的关系：
- en: '![](img/88b1a26b-0da1-4c49-8017-c40a7e3c6a19.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88b1a26b-0da1-4c49-8017-c40a7e3c6a19.png)'
- en: System without using the Bridge design pattern
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用桥接设计模式的系统
- en: 'Let''s create a design without using the Bridge design pattern. First create
    an interface or an abstract class, **Bank**. And then create its derived classes:
    **IciciBank** and **HdfcBank**. To open an account in the bank, first decide on
    the types of account classes--**Saving Account** and **Current Account**, these
    classes extend the specific banks classes (**HdfcBank** and **IciciBank**). There
    is a simple deep inheritance hierarchy in this application. So what is wrong with
    this design as compared to the preceding figure? You will notice that in this
    design, there are two parts, one is the abstraction part and the other is the
    implementation part. Client code interacts with the abstraction part. Client code
    can only access new changes or new functionalities of the implementation part
    when you will update the abstraction part, meaning the parts, the abstraction,
    and the implementation, are tightly coupled with each other.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个不使用桥接设计模式的设计。首先创建一个接口或一个抽象类，**Bank**。然后创建它的派生类：**IciciBank** 和 **HdfcBank**。要在银行开户，首先决定账户类的类型--**储蓄账户**和**活期账户**，这些类扩展了特定的银行类（**HdfcBank**
    和 **IciciBank**）。在这个应用程序中存在一个简单的深度继承层次结构。那么与前面的图相比，这个设计有什么问题呢？你会注意到，在这个设计中，有两部分，一部分是抽象部分，另一部分是实现部分。客户端代码与抽象部分交互。只有当更新抽象部分时，客户端代码才能访问实现部分的新更改或新功能，这意味着抽象、实现和部分之间是紧密耦合的。
- en: 'Now let''s see how to improve this example using the Bridge design pattern:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用桥接设计模式来改进这个例子：
- en: '**System with the Bridge design pattern**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用桥接设计模式的系统**'
- en: 'In the following figure, we create a relation between the `Bank` and `Account`
    interface by using the Bridge design pattern:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们使用桥接设计模式在`Bank`和`Account`接口之间建立关系：
- en: '![](img/90bfdc00-6b6a-42f8-89b2-334f66690e3b.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90bfdc00-6b6a-42f8-89b2-334f66690e3b.png)'
- en: System using Bridge Design Pattern
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用桥接设计模式的系统
- en: '**UML structure for the Bridge design pattern**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**桥接设计模式的UML结构**'
- en: 'Let''s look at the following figure of how the Bridge design pattern solves
    these design issues, as seen in the example where we did not use the Bridge design
    pattern. Bridge pattern separates the abstraction and implementation into two
    class hierarchies:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图，桥接设计模式是如何解决这些设计问题的，正如我们在没有使用桥接设计模式的例子中所看到的。桥接模式将抽象和实现分离成两个类层次结构：
- en: '![](img/219a9390-0d2f-4746-97f8-d85e68e87b2c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/219a9390-0d2f-4746-97f8-d85e68e87b2c.png)'
- en: UML for Bridge design pattern
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式的UML图
- en: We have an `Account` interface that is acting as a bridge implementer and the
    concrete classes `SavingAccount`, and `CurrentAccount` implementing the Account
    interface. The `Bank` is an abstract class and it will use object of Account.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Account`接口，它充当桥接实现者，具体的类`SavingAccount`和`CurrentAccount`实现了`Account`接口。`Bank`是一个抽象类，它将使用`Account`对象。
- en: Let's create a bridge implementer interface.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个桥接实现者接口。
- en: 'Following is the `Account.java` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Account.java`文件：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create concrete bridge implementer classes to implement the `implementer` interface.
    Let's create a `SavingAccount` class as an implementation of `Account`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具体的桥接实现类以实现`implementer`接口。让我们创建一个`SavingAccount`类作为`Account`的实现。
- en: 'Following is the `SavingAccount.java` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`SavingAccount.java`文件：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a `CurrentAccount` class that implements the `Account` interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个实现`Account`接口的`CurrentAccount`类。
- en: 'Following is the `CurrentAccount.java` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`CurrentAccount.java`文件：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create abstraction in the Bridge design pattern, but first, create the interface
    **Bank**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在桥接设计模式中创建抽象，但首先创建接口**Bank**。
- en: 'Following is the `Bank.java` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Bank.java`文件：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's implement the first abstraction for the `Bank` interface and see the following
    implementation class for the `Bank` interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`Bank`接口的第一个抽象，并查看以下`Bank`接口的实现类。
- en: 'Following is the `IciciBank.java` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`IciciBank.java`文件：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's implement the second abstraction for the `Bank` interface and look at
    the following implementation class for the `Bank` interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`Bank`接口的第二个抽象，并查看以下`Bank`接口的实现类。
- en: 'Following is the `HdfcBank.java` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`HdfcBank.java`文件：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a demonstration class of the Bridge design pattern.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个桥接设计模式的演示类。
- en: 'Following is the `BridgePatternMain.java` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`BridgePatternMain.java`文件：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s run this demo class and see the following output in the console:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个演示类，并在控制台看到以下输出：
- en: '![](img/478f1615-93b0-45d3-9a2d-15b422ed5002.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/478f1615-93b0-45d3-9a2d-15b422ed5002.png)'
- en: Now that we've seen the Bridge design pattern, let's turn to a different variant
    of it--the composite design pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了桥接设计模式，让我们转向它的一个不同变体——组合设计模式。
- en: Composite design pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式
- en: Compose objects into tree structures to represent part-whole hierarchies. Composite
    lets clients treat individual objects and compositions of objects uniformly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象组合成树结构以表示部分-整体层次结构。组合允许客户端以统一的方式处理单个对象和对象的组合。
- en: -GoF Design Patterns
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: -GoF设计模式
- en: In software engineering, the composite pattern comes under the structural design
    pattern. According to this pattern, a group of objects of the same type are treated
    as a single object by the client. The idea behind the Composite design pattern
    is to compose a set of objects into a tree structure to represent a module of
    a larger structural application. And this structure for clients is a single unit
    or instance uniformly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，组合模式属于结构设计模式。根据这个模式，客户端将同一类型的对象组作为一个单一对象处理。组合设计模式背后的思想是将一组对象组合成树结构，以表示更大结构应用的一个模块。并且对于客户端来说，这个结构是一个单一的单元或实例。
- en: The motivation behind the Composite design pattern is that objects in the system
    are grouped into the tree structure, and a tree structure is a combination of
    the node-leaf and branches. In the tree structure, nodes have a number of leaves
    and other nodes. Leaf doesn't have anything, which means there is no child of
    leaf in the tree. Leaf is treated as the end point of tree-structured data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式背后的动机是系统中的对象被分组到树结构中，而树结构是节点-叶子和分支的组合。在树结构中，节点有许多叶子和其他节点。叶子没有任何东西，这意味着在树中没有叶子的子节点。叶子被视为树结构数据的终点。
- en: 'Let''s look at the following figure, which represents data in the tree structure
    in the form of node and leaf:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图示，它以节点和叶子的形式表示树结构中的数据：
- en: '![](img/31cc8e59-1456-460a-980b-8e1c4547f63b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31cc8e59-1456-460a-980b-8e1c4547f63b.png)'
- en: Tree structured data using nodes and leaves
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用节点和叶子表示的树结构数据
- en: Common problems solved by the composite pattern
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式解决的问题
- en: As a developer, it is more difficult to design an application so that the client
    can access your objects uniformly across the application, even if that object
    was a composition of objects or an individual object. This design pattern resolves
    difficulties and allows you to design objects in such a way that you can use that
    object as a composition of objects and a single individual object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，设计一个应用程序以便客户端可以跨应用程序统一访问你的对象，即使这个对象是由对象组合而成的或是一个单独的对象，这会更加困难。这个设计模式解决了困难，并允许你以这样的方式设计对象，你可以将这个对象用作对象的组合以及单个个体对象。
- en: This pattern solves the challenges faced when creating hierarchical tree structures
    to provide clients with a uniform way to access and manipulate objects in the
    tree. The composite pattern is a good choice; it is less complex in this situation
    to treat primitives and composites as homogeneous.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式解决了在创建层次树结构时面临的挑战，为客户端提供了一个统一的方式来访问和操作树中的对象。组合模式是一个好的选择；在这种情况下，将原始数据和组合数据视为同质化的是更简单的。
- en: UML structure of the Composite design pattern
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式的UML结构
- en: Composite design pattern is based on the composition of similar types of objects
    into the tree structure, as you know that each tree has three main parts branch,
    node, and leaf. So let's have a look at the following terms used in this design
    pattern.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式基于将相似类型的对象组合成树结构，正如你所知，每个树有三个主要部分：分支、节点和叶子。因此，让我们看看以下在这个设计模式中使用的术语。
- en: '**Component**: It is basically a branch of the tree and the branch has other
    branches, nodes, and leaves. Component provides the abstraction for all components,
    including composite objects. In the composition pattern, component **is** basically
    declared as an interface for objects.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**：它基本上是树的分支，分支上有其他分支、节点和叶子。组件为所有组件提供抽象，包括组合对象。在组合模式中，组件**是**基本声明为对象的接口。'
- en: '**Leaf**: It is an object that implements all component methods.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**叶子**：它是实现所有组件方法的对象。'
- en: '**Composite**: It is represented as a node in the tree structure, it has other
    nodes and leaves, and it represents a composite component. It has methods to add
    the children, that is, it represents a collection of the same type of objects.
    It has other component methods for its children.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**：它在树结构中表示为一个节点，它包含其他节点和叶子，它代表一个组合组件。它有添加子节点的方法，即它代表同一类型对象的集合。它还有为子节点提供其他组件方法。'
- en: 'Let''s look at the following UML diagram for this design pattern:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下这个设计模式的UML图：
- en: '![](img/1d30f74d-8cb9-467d-8960-00ff63b5ae13.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d30f74d-8cb9-467d-8960-00ff63b5ae13.png)'
- en: UML diagram for the Composite Design Pattern
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式的UML图
- en: '**Benefits of the Composite design pattern**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合设计模式的优点**'
- en: This pattern provides the flexibility to add new component to process dynamically,
    with change in the existing components
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式提供了在现有组件更改的情况下动态添加新组件的灵活性。
- en: This pattern allows you to create a class hierarchy that contains individual
    and composite objects
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式允许您创建一个包含单个和组合对象的类层次结构
- en: Sample implementation of the Composite design pattern
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计模式的示例实现
- en: In the following example, I am implementing an `Account` interface, which can
    be either a `SavingAccount` and `CurrentAccount` or a composition of several accounts.
    I have a `CompositeBankAccount` class, which acts as a composite pattern actor
    class. Let's look at the following code for this example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我正在实现一个`Account`接口，它可以是一个`SavingAccount`或`CurrentAccount`，或者是由几个账户组成的组合。我有一个`CompositeBankAccount`类，它充当组合模式的行为类。让我们看看以下代码示例。
- en: 'Create an `Account` interface that will be treated as a component:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Account`接口，它将被视为组件：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `SavingAccount` class and `CurrentAccount` class as an implementation
    of the component and that will also be treated as a leaf:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SavingAccount`类和一个`CurrentAccount`类，作为组件的实现，并将它们也视为叶子：
- en: 'Following is the `SavingAccount.java` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`SavingAccount.java`文件：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Following is the `CurrentAccount.java` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`CurrentAccount.java`文件：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `CompositeBankAccount` class that will be treated as a Composite and
    implements the `Account` interface:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CompositeBankAccount`类，它将被视为组合类并实现`Account`接口：
- en: 'Following is the `CompositeBankAccount.java` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`CompositeBankAccount.java`文件：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `CompositePatternMain` class that will also be treated as a Client:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CompositePatternMain`类，它也将被视为客户端：
- en: 'Following is the `CompositePatternMain.java` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`CompositePatternMain.java`文件：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run this demo class and see the following output at the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个演示类，并在控制台看到以下输出：
- en: '![](img/42f4f28b-863a-4bf9-95ab-b0bbe993d9ee.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42f4f28b-863a-4bf9-95ab-b0bbe993d9ee.png)'
- en: Now that we have discussed the composite design pattern, let's turn to the decorator
    design pattern.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了组合设计模式，让我们转向装饰器设计模式。
- en: Decorator design pattern
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: Attach additional responsibilities to an object dynamically. Decorators provide
    a flexible alternative to sub classing for extending functionality.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 动态地为对象附加额外的职责。装饰器为扩展功能提供了灵活的替代子类化方法。
- en: '- GOF Design Pattern'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF 设计模式'
- en: In software engineering, the common intent of all GOF structural patterns is
    to simplify the complex relationship between objects and classes in a flexible
    enterprise application. The decorator pattern is a special type of design pattern
    among these that comes under the structural design pattern, which allows you to
    add and remove behaviors for an individual object at runtime dynamically or statically,
    without changing the existing behavior of other associated objects from the same
    class. This design pattern does this without violating the Single Responsibility
    Principle or the SOLID principle of object-oriented programming.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，所有GOF结构模式的共同意图是在灵活的企业应用程序中简化对象和类之间的复杂关系。装饰者模式是这些模式中的一种特殊类型的设计模式，它属于结构设计模式，允许你在运行时动态或静态地为单个对象添加和移除行为，而不会改变同一类中其他相关对象的现有行为。这种设计模式在不违反单一职责原则或面向对象编程的SOLID原则的情况下完成这一点。
- en: This design pattern uses the compositions over the inheritance for objects associations;
    it allows you to divide the functionality into different concrete classes with
    a unique area of concern.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计模式使用组合而不是继承来处理对象关联；它允许你将功能划分为具有独特关注区域的不同的具体类。
- en: '**Benefits of the Decorator design pattern**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰者设计模式的好处**'
- en: This pattern allows you to extend functionality dynamically and statically without
    altering the structure of existing objects
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式允许你动态和静态地扩展功能，而不改变现有对象的结构
- en: By using this pattern, you could add a new responsibility to an object dynamically
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用此模式，你可以动态地为对象添加新的责任
- en: This pattern is also known as ****Wrapper****
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式也被称为****包装者****
- en: This pattern uses the compositions for object relationships to maintain SOLID
    principles
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式使用组合来维护对象关系以保持SOLID原则
- en: This pattern simplifies coding by writing new classes for every new specific
    functionality rather than changing the existing code of your application
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式通过为每个新的特定功能编写新类来简化编码，而不是更改应用程序的现有代码
- en: Common problems solved by the Decorator pattern
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式解决的问题
- en: In an enterprise application, there is a business requirement or there might
    be a future plan to extend the behavior of the product by adding new functionalities.
    To achieve this, you could use inheritance to extend the behavior of an object.
    But inheritance should be done at compile time and methods are also available
    for other instances of that class. Because of the code modification, there is
    a violation of the Open Closed Principle. To avoid this violation of the SOLID
    principle, you can attach new responsibility to an object dynamically. This is
    the situation where the decorator design pattern comes into the picture and addresses
    this issue in a very flexible way. Let's look at the following example of how
    to implement this design pattern into a real case study.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，可能存在业务需求或未来计划通过添加新功能来扩展产品的行为。为了实现这一点，你可以使用继承来扩展对象的行为。但是，继承应该在编译时完成，并且该方法也适用于该类的其他实例。由于代码修改，违反了开闭原则。为了避免违反SOLID原则，你可以动态地为对象附加新的责任。这就是装饰者设计模式出现并以非常灵活的方式解决这个问题的情形。让我们看看以下如何将这种设计模式应用到实际案例研究中的例子。
- en: Consider that a bank offers multiple accounts with different benefits to customers.
    It divides the customers into three categories--senior citizens, privileged, and
    young. The bank launches a scheme on the savings account for senior citizens--if
    they open a savings account in this bank, they will be provided medical insurance
    of up to $1,000\. Similarly, the bank also provides a scheme for the privileged
    customers as an accident insurance of up to $1,600 and an overdraft facility of
    $84\. There is no scheme for the young.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到一家银行向客户提供多种具有不同优惠的账户。它将客户分为三个类别——老年人、特权客户和年轻人。银行为老年人推出储蓄账户计划——如果他们在该银行开设储蓄账户，他们将获得最高1000美元的医疗保险。同样，银行也为特权客户提供意外保险，最高可达1600美元，透支额度为84美元。年轻人没有这样的计划。
- en: 'To address the new requirement, we can add new subclasses of `SavingAccount`;
    one each to represent a saving account with additional benefits as decoration,
    and this is what our design looks like now:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决新的需求，我们可以为`SavingAccount`添加新的子类；每个子类代表一个具有额外优惠的储蓄账户装饰，这就是我们现在的设计看起来像这样：
- en: '![](img/1f5bb028-442a-4fae-9f5e-54403523bae7.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f5bb028-442a-4fae-9f5e-54403523bae7.png)'
- en: Application design with inheritance without using the Decorator Design Pattern
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用装饰器设计模式进行继承的应用程序设计
- en: 'This design will be very complex as I will add more benefit schemes to the
    **SavingAccount**, but what would happen when the bank launches the same scheme
    for **CurrentAccount**? Clearly, this design is flawed, but this is an ideal use
    case for the decorator pattern. This pattern allows you to add runtime dynamic
    behavior. In this case, I will create an abstract **AccountDecorator** class to
    implement **Account**. And furthermore, I will create the **SeniorCitizen** class
    and **Privilege** class, which extends **AccountDecorator** because young does
    not have any extra benefits, so the SavingAccount class does not extend **AccountDecorator**.
    This is how the design will be:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将为**SavingAccount**添加更多福利方案，因此此设计将非常复杂，但银行推出相同的方案时会发生什么情况针对**CurrentAccount**？显然，这种设计是有缺陷的，但这是装饰器模式的理想用例。此模式允许您添加运行时动态行为。在这种情况下，我将创建一个抽象的**AccountDecorator**类来实现**Account**。此外，我将创建**SeniorCitizen**类和**Privilege**类，它们扩展了**AccountDecorator**，因为年轻人没有额外的福利，所以SavingAccount类没有扩展**AccountDecorator**。这就是设计将如何进行：
- en: '![](img/ef7b6378-ece3-4d56-abfd-5c7c81794b74.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef7b6378-ece3-4d56-abfd-5c7c81794b74.png)'
- en: Application design with composition using the decorator design pattern
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器设计模式进行应用程序设计
- en: 'The preceding figure follows the Decorator design pattern by creating **AccountDecorator**
    as a **Decorator** in this pattern, and focuses on important things to observe
    the relationship between **Account** and **AccountDecorator**. This relationship
    is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示通过创建**AccountDecorator**作为模式中的**装饰器**，关注观察**Account**和**AccountDecorator**之间的关系。这种关系如下：
- en: '**Is-a** relationship between the `AccountDecorator` and `Account`, that is,
    inheritance for the correct type'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountDecorator`和`Account`之间存在**is-a**关系，即正确的类型继承'
- en: '**Has-a** relationship between the `AccountDecorator` and `Account`, that is,
    composition in order to add new behavior without changing the existing code'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountDecorator`和`Account`之间存在**has-a**关系，即为了在不更改现有代码的情况下添加新行为而进行的组合'
- en: Let's look at the UML structure**:**
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看UML结构**：**
- en: '![](img/577f047c-f03e-46a7-a6e4-4495bd2971ab.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/577f047c-f03e-46a7-a6e4-4495bd2971ab.png)'
- en: UML for the Decorator design pattern
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式的UML图
- en: 'The classes and objects participating in this pattern are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 参与该模式的类和对象包括：
- en: '**Component** (**Account**): It is an interface for objects that can have responsibilities
    added to them dynamically'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**（**Account**）：它是为可以动态添加责任的对象提供的接口'
- en: '**ConcreteComponent** (**SavingAccount**): It is a concrete class of component
    interface and it defines an object to which additional responsibilities can be
    attached'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体组件**（**SavingAccount**）：它是组件接口的具体类，并定义了一个可以附加额外责任的对象'
- en: '**Decorator** (**AccountDecorator**): It has a reference to a **Component**
    object and defines an interface that conforms to the interface of the component'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**（**AccountDecorator**）：它有一个指向**Component**对象的引用，并定义了一个符合组件接口的接口'
- en: '**ConcreteDecorator** (**SeniorCitizen and Privilege**): It is a concrete implementation
    of **Decorator** and it adds responsibilities to the component'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体装饰器**（**SeniorCitizen和Privilege**）：它是装饰器的具体实现，并为组件添加了责任'
- en: Implementing the Decorator pattern
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现装饰器模式
- en: Let's look at the following code to demonstrate the Decorator design pattern.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码来演示装饰器设计模式。
- en: 'Create a component class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个组件类：
- en: 'Following is the `Account.java` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`Account.java`文件：
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create concrete components classes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具体的组件类：
- en: 'Following is the `SavingAccount.java` file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`SavingAccount.java`文件：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s create another concrete class for Account component:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Account组件创建另一个具体类：
- en: 'Following is the `CurrentAccount.java` file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`CurrentAccount.java`文件：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's create a `Decorator` class for Account component. This decorator class
    apply other run time behavior to the Account component classes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Account组件创建一个`Decorator`类。这个装饰器类将其他运行时行为应用到Account组件类中。
- en: 'Following is the `AccountDecorator.java` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`AccountDecorator.java`文件：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's create a `ConcreteDecorator` class to implement the AccountDecorator class.
    Following class `SeniorCitizen` is extended `AccountDecorator` class to access
    other run time behavior such as `applyOtherBenefits()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`ConcreteDecorator`类来实现AccountDecorator类。以下类`SeniorCitizen`扩展了`AccountDecorator`类，以访问其他运行时行为，如`applyOtherBenefits()`。
- en: 'Following is the `SeniorCitizen.java` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`SeniorCitizen.java`文件：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's create another `ConcreteDecorator` class to implement the `AccountDecorator`
    class. Following class `Privilege` is extended `AccountDecorator` class to access
    other run time behavior such as `applyOtherBenefits(`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个`ConcreteDecorator`类来实现`AccountDecorator`类。以下类`Privilege`扩展了`AccountDecorator`类，以便访问其他运行时行为，如`applyOtherBenefits(`)。
- en: 'Following is the `Privilege.java` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`Privilege.java`文件：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s now write some test code to see how the Decorator pattern works at runtime:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一些测试代码，看看装饰器模式在运行时是如何工作的：
- en: 'Following is the `DecoratorPatternMain.java` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`DecoratorPatternMain.java`文件：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s run this demo class and see the following output at the console:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个演示类，并在控制台看到以下输出：
- en: '**![](img/b59232d4-7614-48e2-8273-161735ffa0f2.png)**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/b59232d4-7614-48e2-8273-161735ffa0f2.png)**'
- en: Decorator design pattern in the Spring Framework
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架中的装饰器设计模式
- en: 'The Spring Framework uses the Decorator design pattern to build important functionalities
    such as transactions, cache synchronization, and security-related tasks. Let''s
    look at some functionalities where Spring implements this pattern transparently:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架使用装饰器设计模式构建重要的功能，如事务、缓存同步和安全相关任务。让我们看看Spring如何透明地实现此模式的一些功能：
- en: Weaving the advice into the Spring application. It uses the Decorator pattern
    via the CGLib proxy. It works by generating a subclass of the target class at
    runtime.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将建议编织到Spring应用程序中。它通过CGLib代理使用装饰器模式。它通过在运行时生成目标类的子类来工作。
- en: '`BeanDefinitionDecorator` : It is used to decorate the bean definition via
    applied custom attributes.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeanDefinitionDecorator`：它用于通过应用自定义属性来装饰bean定义。'
- en: '`WebSocketHandlerDecorator`: It is used to decorate a WebSocketHandler with
    additional behaviors.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSocketHandlerDecorator`：它用于使用附加行为装饰WebSocketHandler。'
- en: Now let's turn to another GOF Design Pattern - Facade design pattern.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向另一个GOF设计模式——外观设计模式。
- en: Facade Design Pattern
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观设计模式
- en: Provide a unified interface to a set of interfaces in a subsystem. Facade defines
    a higher-level interface that makes the subsystem easier to use.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为子系统中的一组接口提供一个统一的接口。外观定义了一个更高层次的接口，使得子系统更容易使用。
- en: '- GOF Design Patterns'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF设计模式'
- en: The Facade design pattern is nothing but an interface of interfaces to simplify
    interactions between the client code and subsystem classes. This design comes
    under the GOF structural design pattern.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式不过是接口的接口，用于简化客户端代码与子系统类之间的交互。这种设计属于GOF结构设计模式。
- en: 'Benefits of Facade Pattern:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式的优点：
- en: This pattern reduces the complexities for clients to interact with subsystems
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式简化了客户端与子系统交互的复杂性
- en: This pattern consolidates all the business services as single interfaces to
    make them more understandable
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式将所有业务服务合并为单个接口，以便使其更易于理解
- en: This pattern reduces dependencies of client code on the inner workings of a
    system
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式减少了客户端代码对系统内部工作的依赖
- en: Knowing when to use the Facade Pattern
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解何时使用外观模式
- en: Suppose you are designing a system, and this system has a very large number
    of independent classes and also has a set of services to be implemented. This
    system is going to be very complex, so the Facade pattern comes into the picture
    and reduces the complexities of the larger system and simplifies interactions
    of the client code with a set of classes from a subsystem of the large complex
    system.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在设计一个系统，这个系统拥有大量独立的类，并且还有一组要实现的服务。这个系统将会非常复杂，因此外观模式应运而生，简化了更大系统的复杂性，并简化了客户端代码与大型复杂系统的一个子系统中的类之间的交互。
- en: 'Suppose you want to develop a bank enterprise application with a large number
    of services to perform a task, for example, `AccountService` for getting the `Account`
    by `accountId`, `PaymentService` for payment gateway services, and `TransferService`
    for the amount transfer from one account to another account. A client code of
    the application interacts with all these services to transfer money from one account
    to another account. This is how different clients interact with the amount transfer
    process of the bank system. As shown in the following figure, here you can see
    client code that directly interacts with the subsystem classes and client also
    should aware about the internal working of subsystem classes, so it is simply
    a violation of the SOLID design principles because client code is tightly coupled
    with the classes of subsystem of your banking application:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想开发一个具有大量服务的银行企业应用程序以执行任务，例如，`AccountService`用于通过`accountId`获取`Account`，`PaymentService`用于支付网关服务，以及`TransferService`用于从一个账户向另一个账户转账。应用程序的客户端代码与所有这些服务交互，以将资金从一个账户转账到另一个账户。这就是不同的客户端如何与银行系统的转账过程交互。如下面的图所示，这里你可以看到直接与子系统类交互的客户端代码，客户端还应该了解子系统类的内部工作原理，因此这简单地违反了SOLID设计原则，因为客户端代码与银行应用程序的子系统类紧密耦合：
- en: '![](img/f793e18e-9f34-4e4b-a9fd-350cebfc824a.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f793e18e-9f34-4e4b-a9fd-350cebfc824a.png)'
- en: Banking Application Subsystem without Facade Design Pattern
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 没有外观设计模式的银行应用程序子系统
- en: 'Rather than client code directly interacting with the classes of a subsystem,
    you could introduce one more interface, which makes the subsystems easier to use,
    as shown in the following figure. This interface is known as a `Facade` interface,
    it is based on the Facade pattern, and it is a simple way to interact with the
    subsystems:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是客户端代码直接与子系统的类交互，你可以引入另一个接口，这使得子系统更容易使用，如下面的图所示。这个接口被称为“外观”接口，它基于外观模式，并且是与子系统交互的简单方式：
- en: '![](img/1bdbdb56-6b8d-4173-8697-349d257f6923.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bdbdb56-6b8d-4173-8697-349d257f6923.png)'
- en: Banking Application Subsystem with Facade design pattern
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 带有外观设计模式的银行应用程序子系统
- en: Implementing the Facade design pattern
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现外观设计模式
- en: Let's look into the following listings to demonstrate the Facade design pattern.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下列表以演示外观设计模式。
- en: 'Create subsystem service classes for your Bank application: Let''s see the
    following PaymentService class for the subsystem.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的银行应用程序创建子系统服务类：让我们看看以下子系统的`PaymentService`类。
- en: 'Following is the `PaymentService.java` file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`PaymentService.java`文件：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's create another service class AccountService for the subsystem.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为子系统创建另一个服务类`AccountService`。
- en: 'Following is the `AccountService.java` file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`AccountService.java`文件：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's create another service class TransferService for the subsystem.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为子系统创建另一个服务类`TransferService`。
- en: 'Following is the `TransferService.java` file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`TransferService.java`文件：
- en: '[PRE26]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a Facade Service class to interact with the subsystem: Let''s see the
    following Facade interface for the subsystem and then implement this Facade interface
    as a global banking service in the application.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个外观服务类以与子系统交互：让我们看看以下子系统的外观接口，然后将其实现为应用程序中的全局银行服务。
- en: 'Following is the `BankingServiceFacade.java` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`BankingServiceFacade.java`文件：
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Following is the `BankingServiceFacadeImpl.java` file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`BankingServiceFacadeImpl.java`文件：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the client of the Facade:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建外观的客户端：
- en: 'Following is the `FacadePatternClient.java` file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`FacadePatternClient.java`文件：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The UML structure for the Facade design pattern
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观设计模式的结构化建模语言（UML）结构
- en: 'The classes and objects participating in this pattern are:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 参与该模式的类和对象是：
- en: Facade (`BankingServiceFacade`)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观（`BankingServiceFacade`）
- en: This is a Facade interface that knows which subsystem classes are responsible
    for a request. This interface is responsible for delegating client requests to
    appropriate subsystem objects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个了解哪些子系统类负责请求的外观接口。该接口负责将客户端请求委派给适当的子系统对象。
- en: Subsystem classes (`AccountService`, `TransferService`, `PaymentService`)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统类（`AccountService`、`TransferService`、`PaymentService`）
- en: These interfaces are actually subsystem functionalities of the banking process
    system application. These are responsible for handling processes assigned by the
    Facade object. No interfaces in this category have a reference to the Facade object;
    they don't have implementation details of Facade. These are totally independent
    of Facade objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口实际上是银行流程系统应用的功能子系统。它们负责处理门面对象分配的过程。这个类别的接口没有对门面对象的引用；它们没有门面实现的细节。它们与门面对象完全独立。
- en: 'Let''s see the following UML diagram for this pattern:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于此模式的UML图：
- en: '![](img/5ac8fdbb-ec4e-4d2c-b2e9-fcc173631224.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ac8fdbb-ec4e-4d2c-b2e9-fcc173631224.png)'
- en: UML diagram for Facade design pattern
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 门面设计模式的UML图
- en: Facade Pattern in the Spring Framework
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架中的门面模式
- en: In the enterprise application, if you are working in Spring applications, the
    facade pattern is used commonly in the business service layer of the application
    to consolidate all services. And you could also apply this pattern on DAOs on
    the persistent layer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用中，如果你在Spring应用中工作，门面模式通常用于应用的业务服务层来整合所有服务。你还可以在持久层的DAO上应用此模式。
- en: Now that we've seen the Facade design pattern, let's turn to a different variant
    of it--Proxy design pattern.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了门面设计模式，让我们转向它的一个不同变体——代理设计模式。
- en: Proxy design pattern
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: Provide a surrogate or placeholder for another object to control access to it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为另一个对象提供一个代理或占位符，以控制对其的访问。
- en: -GOF Design Patterns
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF设计模式'
- en: Proxy design pattern provides an object of a class with the functionality of
    another class with having it. This pattern comes under the structural design pattern
    of GOF Design Patterns. The intent of this design pattern is to provide an alternate
    class for another class , along with its functionality, to the outside world.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式提供了一个具有另一个类功能的对象，同时拥有它。此模式属于GOF设计模式的结构设计模式。此设计模式的目的是向外界提供一个替代类，以及其功能。
- en: Purpose of the Proxy pattern
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式的用途
- en: 'Let''s look at the following points:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下要点：
- en: This pattern hides the actual object from the outside world.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式隐藏了实际对象对外界。
- en: This pattern can improve the performance because it is creating an object on
    demand.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式可以提高性能，因为它是在需要时创建对象。
- en: UML structure for the Proxy design pattern
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理设计模式的UML结构
- en: 'Let''s see the following UML diagram for this pattern:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于此模式的UML图：
- en: '![](img/05f5033a-1a34-4cd6-aace-e6cf6e6fb9ac.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05f5033a-1a34-4cd6-aace-e6cf6e6fb9ac.png)'
- en: UML diagram for Proxy design pattern
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式的UML图
- en: 'Now let''s look at the different components of this UML diagram:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个UML图的不同组件：
- en: '**Subject**: Actual interface to be implemented by Proxy and RealSubject.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Subject**：代理和真实主题需要实现的实际接口。'
- en: '**RealSubject**: Real implementation of **Subject**. It is a real object that
    represented by the proxy.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RealSubject**：**Subject**的真实实现。它是由代理表示的真实对象。'
- en: '**Proxy**: It is a proxy object and it is also the implementation of the real
    object **Subject**. It maintains the references to the real object.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：它是一个代理对象，也是真实对象**Subject**的实现。它维护对真实对象的引用。'
- en: Implementing the Proxy design pattern
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现代理设计模式
- en: Let's look into following code to demonstrate the Proxy pattern.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码来演示代理模式。
- en: Create a Subject.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Subject。
- en: 'Following is the `Account.java` file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`Account.java`文件：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a RealSubject class that implements Subject, let's see the following
    class as RealSubject class for the Proxy design pattern.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个实现Subject的RealSubject类，让我们看看以下类作为代理设计模式的RealSubject类。
- en: 'Following is the `SavingAccount.java` file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`SavingAccount.java`文件：
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create a Proxy class which implements Subject and having the Real Subject
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个实现Subject并具有真实主题的代理类
- en: 'Following is the `ProxySavingAccount.java` file:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`ProxySavingAccount.java`文件：
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Proxy pattern in the Spring Framework
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架中的代理模式
- en: Spring Framework uses the Proxy design pattern in the Spring AOP module transparently.
    As I have discussed in [Chapter 1](18f63847-961b-45a2-bef0-30602dcabed3.xhtml),
    *Getting Started with Spring Framework 5.0 and Design Patterns*. In Spring AOP,
    you create proxies of the object to apply cross cutting concern across the point
    cut in the Spring application. In the Spring, other modules also implement the
    Proxy pattern, such as RMI, Spring's HTTP Invoker, Hessian, and Burlap.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架在 Spring AOP 模块中透明地使用了代理设计模式。正如我在[第 1 章](18f63847-961b-45a2-bef0-30602dcabed3.xhtml)，“Spring
    Framework 5.0 入门与设计模式”中讨论的那样。在 Spring AOP 中，你创建对象的代理以在 Spring 应用程序中的切入点处应用横切关注点。在
    Spring 中，其他模块也实现了代理模式，例如 RMI、Spring 的 HTTP Invoker、Hessian 和 Burlap。
- en: Let's see the next section about Behavioral design pattern with its underlying
    patterns and example.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节关于行为设计模式及其底层模式和示例。
- en: Behavioral design patterns
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: The intent of Behavioral design pattern is the interaction and cooperation between
    a set of objects to perform a task that no single object can carry out by itself.
    The interaction between the objects should be such that they should be loosely
    coupled. Patterns under this category, characterize the ways in which classes
    or objects interact and distribute responsibility. Let's see in the next sections,
    different variants of the Behavioral design patterns.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式的目的是一组对象之间的交互和协作，以执行单个对象无法独立完成的任务。对象之间的交互应该是松耦合的。此类别下的模式描述了类或对象之间交互和分配责任的方式。让我们在下一节中看看行为设计模式的不同变体。
- en: Chain of Responsibility design pattern
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链设计模式
- en: Avoid coupling the sender of a request to its receiver by giving more than one
    object a chance to handle the request. Chain the receiving objects and pass the
    request along the chain until an object handles it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给多个对象一个处理请求的机会，避免将请求的发送者与其接收者耦合。将接收对象链式连接，并将请求沿着链传递，直到某个对象处理它。
- en: -GOF Design Patterns
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF 设计模式'
- en: Chain of responsibility design pattern comes under the Behavioral design pattern
    of GOF patterns family. According to this pattern, sender and receiver of a request
    are decoupled. The sender sends a request to the chain of receivers and any one
    of receivers in the chain can handle the request. In this pattern, the receiver
    object has the reference of another receiver object so that if it does not handle
    the request then it passes the same request to the other receiver object.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链设计模式属于 GOF 模式家族中的行为设计模式。根据此模式，请求的发送者和接收者是解耦的。发送者将请求发送到接收者链，链中的任何接收者都可以处理请求。在此模式中，接收者对象具有另一个接收者对象的引用，以便如果它不处理请求，则将相同的请求传递给其他接收者对象。
- en: For example, in a banking System, you could use any ATM to withdraw the money
    in any place, so it is one of the live examples of the Chain of Responsibility
    design pattern.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在银行系统中，你可以在任何地方使用任何自动柜员机提取现金，因此它是责任链设计模式的一个活生生的例子。
- en: 'There are following benefits of this pattern:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式有以下优点：
- en: This pattern reduces the coupling between sender and receiver objects in the
    system to handle a request.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式减少了系统中发送者和接收者对象之间的耦合，以处理请求。
- en: This pattern is more flexible to assign the responsibility to another referenced
    object.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式更灵活地分配责任给另一个引用对象。
- en: This pattern makes a chain of objects using composition, and this set of objects
    work as a single unit.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式通过组合使用对象链，这些对象作为一个单一单元工作。
- en: 'Let''s see the following UML diagram showing all components of a chain of responsibility
    design pattern:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 UML 图，它显示了责任链设计模式的所有组件：
- en: '![](img/b759bfd8-4afb-4bc7-a381-d7c2b5ba9eec.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b759bfd8-4afb-4bc7-a381-d7c2b5ba9eec.png)'
- en: UML Diagram for Chain of Responsibility design pattern
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链设计模式的 UML 图
- en: '**Handler**: This is an abstract class or interface in the system to handle
    request.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理者**：这是系统中处理请求的抽象类或接口。'
- en: '**ConcreteHandler**: These are concrete classes which implement **Handler**
    to handle the request, or it passes same request to the next successor of the
    handler chain.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体处理者**：这些是具体类，它们实现**处理者**以处理请求，或者将相同的请求传递给处理链中的下一个后续处理者。'
- en: '**Client**: It is main application class to initiate the request to the handler
    objects on the chain.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这是主应用程序类，用于向链上的处理对象发起请求。'
- en: Chain of Responsibility pattern in the Spring Framework
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架中的责任链模式
- en: Spring Security project implemented the Chain of Responsibility pattern in the
    Spring Framework. Spring Security allows you to implement authentication and authorization
    functionality in your application by using chains of security filters. This is
    a highly configurable framework. You can add your custom filter with this chain
    of filters to customize the functionality because of Chain of Responsibility design
    pattern.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 项目在 Spring 框架中实现了责任链模式。Spring Security 允许你通过使用安全过滤器链在你的应用程序中实现身份验证和授权功能。这是一个高度可配置的框架。你可以通过这个过滤器链添加你的自定义过滤器来自定义功能，因为责任链设计模式。
- en: Now that we've seen the Chain of responsibility design pattern, let's turn to
    a different variant of it--Command design pattern.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了责任链设计模式，让我们转向它的一个不同变体--命令设计模式。
- en: Command design pattern
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: Encapsulate a request as an object, thereby letting you parameterize clients
    with different requests, queue or log requests, and support undoable operations
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求封装为一个对象，从而让你用不同的请求参数化客户端，排队或记录请求，并支持可撤销操作
- en: -GOF Design Patterns
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: -GOF 设计模式
- en: The Command design pattern falls under the Behavioral pattern family of the
    GOF patterns, this pattern is a very simple data-driven pattern which allows you
    to encapsulate your request data into an object and pass that object as a command
    to the invoker method, and it return the command as another object to the caller.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式属于 GOF 模式中的行为模式家族，这是一个非常简单的数据驱动模式，它允许你将请求数据封装到对象中，并将该对象作为命令传递给调用者方法，然后作为另一个对象返回给调用者。
- en: 'The following lists the benefits of using the Command pattern:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了使用命令模式的优点：
- en: This pattern enables you to transfer data as an object between the system components
    sender and receiver.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式使你能够在系统组件发送者和接收者之间传输数据。
- en: This pattern allows you to parameterize objects by an action to perform.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式允许你通过执行操作来参数化对象。
- en: You could easily add new commands in the system without changing existing classes.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松地在系统中添加新命令，而无需更改现有类。
- en: 'Let''s look at the following UML diagram showing all components of Command
    design pattern:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 UML 图，展示了命令设计模式的所有组件：
- en: '![](img/3065e0ae-3e83-4601-9104-726bfe750cde.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3065e0ae-3e83-4601-9104-726bfe750cde.png)'
- en: UML Diagram for Command Design Pattern
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式的 UML 图
- en: '**Command**: It is an interface or abstract class having an action to perform
    in the system.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**: 它是一个接口或抽象类，在系统中执行一个操作。'
- en: '**ConcreteCommand**: It is a concrete implementation of the `Command` interface
    and defining an action will be performed.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体命令**: 它是 `Command` 接口的具体实现，并定义了一个将要执行的操作。'
- en: '**Client**: This is a main class, it creates a `ConcreteCommand` object and
    sets its receiver.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 这是一个主类，它创建一个 `ConcreteCommand` 对象并设置其接收者。'
- en: '**Invoker**: It is a caller to invoke the request to carry the command object.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用者**: 它是一个调用者，用于调用请求以携带命令对象。'
- en: '**Receiver**: It is simple handler method which performs the actual operation
    by `ConcreteCommand`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收者**: 它是一个简单的处理方法，通过 `ConcreteCommand` 执行实际操作。'
- en: Command design pattern in the Spring Framework
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架中的命令设计模式
- en: Spring MVC has implemented the Command design pattern in the Spring Framework.
    In your enterprise applications using the Spring Framework, you often see the
    concepts of the Command pattern applied through the use of Command objects.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 在 Spring 框架中实现了命令设计模式。在你的企业应用程序中使用 Spring 框架时，你经常看到通过使用命令对象应用命令模式的理念。
- en: Now that we've seen Command design pattern, let's turn to a different variant
    of it--Interpreter design pattern.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了命令设计模式，让我们转向它的一个不同变体--解释器设计模式。
- en: Interpreter Design pattern
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器设计模式
- en: Given a language, define a representation for its grammar along with an interpreter
    that uses the representation to interpret sentences in the language.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一种语言，定义其语法的表示，以及一个使用该表示来解释该语言句子的解释器。
- en: -GOF Design Pattern
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: -GOF 设计模式
- en: Interpreter design pattern allows you to interpret an expression language in
    the programming to define a representation for its grammar. This type of a pattern
    comes under the Behavioral design pattern family of GOF patterns.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式允许你在编程中解释表达式语言，为它的语法定义一个表示。这种模式属于 GOF 模式中的行为设计模式家族。
- en: 'The following lists the benefits of using the Interpreter pattern:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了使用解释器模式的优点：
- en: This pattern allows you to change and extend the grammar easily.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模式允许你轻松地更改和扩展语法。
- en: Using the expression language is very easy
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式语言非常简单
- en: 'Let''s see the following UML diagram is showing all components of Interpreter
    design pattern:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下UML图展示了解释器设计模式的所有组件：
- en: '![](img/2cf328c2-4671-4233-a791-fb66bdea1f72.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cf328c2-4671-4233-a791-fb66bdea1f72.png)'
- en: UML diagram for Interpreter design pattern
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式的UML图
- en: '**AbstractExpression:** It is an interface to execute a task by using `interpret()`
    operation.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象表达式:** 它是一个接口，通过使用`interpret()`操作执行任务。'
- en: '**TerminalExpression:** It is an implementation of above interface and it implements
    `interpret()` operation for terminal expressions.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终结表达式:** 它是上述接口的一个实现，并为终结表达式实现了`interpret()`操作。'
- en: '**NonterminalExpression:** It is also an implementation of above interface
    and it implements `interpret()` operation for non-terminal expressions.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非终结表达式:** 它也是上述接口的一个实现，并为非终结表达式实现了`interpret()`操作。'
- en: '**Context:** It is a `String` expression and contains information that is global
    to the interpreter.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文:** 它是一个`String`表达式，包含对解释器全局的信息。'
- en: '**Client:** It is the main class to invoke the Interpret operation.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端:** 它是调用解释器操作的主要类。'
- en: Interpreter design pattern in the Spring Framework
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架中的解释器设计模式
- en: In the Spring Framework, Interpreter pattern is used with the **Spring Expression
    Language** (**SpEL**). Spring added this new feature from Spring 3.0, you can
    use it in your enterprise application using the Spring Framework.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，解释器模式与**Spring表达式语言**（**SpEL**）一起使用。Spring从3.0版本开始添加了这个新特性，你可以在使用Spring框架的企业应用程序中使用它。
- en: Now that we've seen Interpreter design pattern, let's turn to a different variant
    of it--Iterator design pattern.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了解释器设计模式，让我们转向它的另一个变体--迭代器设计模式。
- en: Iterator Design Pattern
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器设计模式
- en: Provide a way to access the elements of an aggregate object sequentially without
    Exposing its underlying representation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一种按顺序访问聚合对象元素的方法，而不暴露其底层表示。
- en: -GOF Design Pattern
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: -GOF设计模式
- en: This is a very commonly used design pattern in the programming language as like
    in Java. This pattern comes from the Behavioral Design Pattern family of GOF pattern.
    This pattern allows you to access the items from the collection object in sequence
    without information its internal representation.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，这是一个非常常用的设计模式，就像在Java中一样。这个模式来自GOF模式的行为设计模式家族。这个模式允许你在不知道其内部表示的情况下，按顺序访问集合对象中的项。
- en: 'These are following benefits of the Iterator pattern:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式有以下优点：
- en: Easily access the items of the collection.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易访问集合中的项。
- en: You can use multiple to access the item from the collection because it support
    lot of variations in the traversal.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用多个来访问集合中的项，因为它支持大量的遍历变体。
- en: It provides a uniform interface for traversing different structures in a collection.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个统一的接口来遍历集合中的不同结构。
- en: 'Let''s see the following UML diagram is showing all components of Iterator
    design pattern:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下UML图展示了迭代器设计模式的所有组件：
- en: '![](img/6cbed143-241f-488a-bec5-4cd6418c5270.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cbed143-241f-488a-bec5-4cd6418c5270.png)'
- en: UML Diagram for Iterator Design Pattern
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式的UML图
- en: '**Iterator:** It is an interface or abstract class for accessing and traversing
    items of the collections.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器:** 它是一个用于访问和遍历集合中项的接口或抽象类。'
- en: '**ConcreteIterator:** It is an implementation of the **Iterator** interface.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体迭代器:** 它是**迭代器**接口的一个实现。'
- en: '**Aggregate:** It is an interface to create an Iterator object.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合:** 它是一个用于创建迭代器对象的接口。'
- en: '**ConcreteAggregate:** It is the implementation of the **Aggregate** interface,
    it implements the **Iterator** creation interface to return an instance of the
    proper **ConcreteIterator**.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体聚合:** 它是**聚合**接口的实现，它实现了**迭代器**创建接口，以返回适当的**具体迭代器**的实例。'
- en: Iterator design pattern in the Spring Framework
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架中的迭代器设计模式
- en: The Spring Framework also extends the Iterator pattern through the **CompositeIterator**
    class. Mainly this pattern used in the Collection Framework of Java for iterating
    the elements in sequence.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架还通过**CompositeIterator**类扩展了迭代器模式。主要这个模式用于Java集合框架中按顺序迭代元素。
- en: Now that we've seen Iterator design pattern, let's turn to a different variant
    of it--Observer design pattern.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了迭代器设计模式，让我们转向它的一个不同变体--观察者设计模式。
- en: '**Observer** **Design Pattern**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者** **设计模式**'
- en: Define a one-to-many dependency between objects so that when one object changes
    state, all its dependents are notified and updated automatically
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖对象都会被通知并自动更新
- en: -GOF Design Pattern
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '- GOF 设计模式'
- en: Observer pattern is one of very common design pattern, This pattern is a part
    of the Behavioral design pattern family of GOF pattern that addresses responsibilities
    of objects in an application and how they communicate between them at runtime.
    According to this pattern, sometimes objects make a one-to-many relationship between
    the objects in your application, such that if one object is modified, it's notified
    to other dependent objects automatically.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是非常常见的设计模式之一，这种模式是 GOF 模式中行为设计模式家族的一部分，它处理应用程序中对象的责任以及它们在运行时如何相互通信。根据这种模式，有时对象会在应用程序中的对象之间建立一对多的关系，即如果一个对象被修改，它将自动通知其他依赖对象。
- en: For example, Facebook post comments are one of the examples of the observer
    design pattern. If you comment on a post of your friend then you are always notified
    by this post whenever anyone else comments on the same post again.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Facebook 的帖子评论是观察者设计模式的一个例子。如果你评论了你朋友的帖子，那么每次有人再次评论同一帖子时，你都会收到这个帖子的通知。
- en: 'The Observer pattern provides communication between decoupled objects. It makes
    a relationship between objects mostly a one-to-many relationship. In this pattern,
    there is an object which is known as the subject. Whenever there is any change
    in the state of this subject, it will be notified to its list of dependents accordingly.
    This list of dependents is known as observers. The following figure illustrates
    the Observer pattern:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式提供了解耦对象之间的通信。它使对象之间的关系主要是一对多的关系。在这个模式中，有一个被称为主题的对象。每当这个主题的状态发生变化时，它将相应地通知其依赖对象列表。这个依赖对象列表被称为观察者。以下图示说明了观察者模式：
- en: '![](img/8368e46a-cf78-4b1b-a6a8-a2b40e03ae8c.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8368e46a-cf78-4b1b-a6a8-a2b40e03ae8c.png)'
- en: Use case of the Observer design pattern
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式的使用场景
- en: 'There are following lists of the benefits of using the Observer pattern:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的以下列表列出了其优点：
- en: This pattern provides decoupled relationship between the subject and observer
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式为主体和观察者之间提供了解耦的关系
- en: It provides support for broadcasting
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了广播支持
- en: 'Let''s see the following UML diagram is showing all components of Observer
    design pattern:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 UML 图展示了观察者设计模式的所有组件：
- en: '![](img/90e6cd43-41bf-43f1-8b0d-a21741e91510.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90e6cd43-41bf-43f1-8b0d-a21741e91510.png)'
- en: UML Diagram for Observer Design Pattern
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式的 UML 图
- en: '**Subject**: It is an interface. It has information about its observers.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题（Subject）**：它是一个接口。它知道其观察者的信息。'
- en: '**ConcreteSubject**: It is a concrete implementation of **Subject**, it has
    information about all its observers to be notified when its state changes.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体主题（ConcreteSubject）**：它是主题的具体实现，它在其状态变化时知道所有需要通知的观察者。'
- en: '**Observer**: It is an interface to be notified of changes in a subject.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者（Observer）**：它是一个接口，用于通知主题的变化。'
- en: '**ConcreteObserver**: It is a concrete implementation of Observer, it keeps
    its state consistent with the subject''s state.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体观察者（ConcreteObserver）**：它是观察者的具体实现，它保持其状态与主题状态的一致性。'
- en: Observer pattern in the Spring Framework
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架中的观察者模式
- en: In the Spring Framework, the Observer design pattern is used to implement event
    handling function of `ApplicationContext`. Spring provides us the `ApplicationEvent`
    class and `ApplicationListener` interface to enable event handling in Spring `ApplicationContext`.
    Any bean in your Spring application implements the `ApplicationListener` interface,
    it will receive an `ApplicationEvent` every time the `ApplicationEvent` is published
    by an event publisher. Here, the event publisher is the subject and the bean that
    implements ApplicationListener is the observer.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 框架中，观察者设计模式用于实现 `ApplicationContext` 的事件处理功能。Spring 提供了 `ApplicationEvent`
    类和 `ApplicationListener` 接口，以在 Spring `ApplicationContext` 中启用事件处理。任何实现 `ApplicationListener`
    接口的 Spring 应用程序中的 bean，每当事件发布者发布 `ApplicationEvent` 时，它都会收到一个 `ApplicationEvent`。在这里，事件发布者是主题，实现
    ApplicationListener 的 bean 是观察者。
- en: Now that we've seen Observer design pattern, let's turn to a different variant
    of it--Template design pattern.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了观察者设计模式，让我们转向它的一个不同变体——模板设计模式。
- en: Template Design Pattern
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板设计模式
- en: Define the skeleton of an algorithm in an operation, deferring some steps to
    subclasses. Template Method lets subclasses redefine certain steps of an algorithm
    without changing the algorithm's structure.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作中定义算法的骨架，将一些步骤推迟到子类。模板方法允许子类重新定义算法的某些步骤，而不改变算法的结构。
- en: 60; -GOF Design Patterns
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 60; -GOF 设计模式
- en: In Template design pattern, an abstract class wraps some defined ways to its
    method. That method allows you to override parts of the method without rewriting
    it. You could use its concrete class to your application to perform similar type
    actions. This design pattern comes under the Behavior design pattern family of
    GOF pattern.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板设计模式中，一个抽象类封装了一些定义到其方法中。该方法允许你在不重写它的前提下覆盖方法的部分。你可以使用其具体类将类似类型的行为应用于你的应用程序。这个设计模式属于
    GOF 模式的行为设计模式家族。
- en: 'There are following lists the benefits of using the Template pattern:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了使用模板模式的益处：
- en: It reduces the boilerplate codes in the application by reusing code.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重用代码，它减少了应用程序中的样板代码。
- en: This pattern creates a template or way to reuse multiple similar algorithms
    to perform some business requirements.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模式创建了一个模板或方式，用于重用多个类似算法以执行某些业务需求。
- en: 'Let''s see the following UML diagram is showing the components of Template
    design pattern:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 UML 图展示了模板设计模式的组件：
- en: '![](img/a46a5f03-e61f-49be-892f-f3a1c9f16669.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a46a5f03-e61f-49be-892f-f3a1c9f16669.png)'
- en: UML Diagram for Template design pattern
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 模板设计模式的 UML 图
- en: '**AbstractClass**: This is an abstract class that contains a template method
    defining the skeleton of an algorithm.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类（AbstractClass）**：这是一个包含定义算法骨架的模板方法的抽象类。'
- en: '**ConcreteClass:** This is a concrete subclass of **AbstractClass** that implements
    the operations to carry out the algorithm-specific primitive steps.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体类（ConcreteClass）**：这是一个具体子类，实现了执行算法特定基本步骤的操作。'
- en: Let's see the next section about J2EE design patterns in the enterprise distributed
    applications
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节关于企业分布式应用中的 J2EE 设计模式。
- en: JEE design patterns
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEE 设计模式
- en: 'It is other main category of design patterns. Application design can be immensely
    simplified by applying Java EE design patterns. Java EE design patterns have been
    documented in Sun''s Java Blueprints. These Java EE design patterns provide time-tested
    solution guidelines and best practices for object interaction in the different
    layer of a Java EE application. These design patterns are specifically concerned
    with the following listed layers:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 它是设计模式的主要类别之一。通过应用 Java EE 设计模式，应用设计可以极大地简化。Java EE 设计模式已在 Sun 的 Java Blueprints
    中进行了记录。这些 Java EE 设计模式提供了经过时间考验的解决方案指南和最佳实践，用于指导 Java EE 应用程序不同层中的对象交互。这些设计模式特别关注以下列出的层：
- en: Design pattern at presentation layer
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示层的设计模式
- en: Design pattern at business layer
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务层的设计模式
- en: Design pattern at integration layer
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成层的设计模式
- en: These design patterns are specifically concerned with the following listed layers.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计模式特别关注以下列出的层。
- en: '**Design pattern at presentation layer**:'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展示层的设计模式**：'
- en: '**View Helper**: It separates views from the business logic of an enterprise
    J2EE application.'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图助手（View Helper）**：它将视图与企业 J2EE 应用程序的业务逻辑分离。'
- en: '**Front Controller**: It provides a single point of action to handle the all
    coming requests to the J2EE web application, it forwards the request to specific
    application controller to access model and view for presentation tier resources.'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器（Front Controller）**：它提供了一个处理所有传入 J2EE Web 应用程序请求的单一点，它将请求转发到特定的应用程序控制器以访问表示层资源。'
- en: '**Application Controller**-The request actually handled by the Application
    Controller, it acts as a front controller helper. It responsible for the coordination
    with the business models and view components.'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序控制器（Application Controller）**：请求实际上由应用程序控制器处理，它充当前端控制器助手。它负责与业务模型和视图组件的协调。'
- en: '**Dispatcher View**-It is related to the view only and it executes without
    business logic to prepare a response to the next view.'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发视图（Dispatcher View）**：它与视图相关，它执行时没有业务逻辑，为下一个视图准备响应。'
- en: '**Intercepting filters** -In the J2EE web application, you could configure
    multiple interceptors for pre and post processing an user''s request such as tracking
    and auditing user''s requests.'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拦截过滤器（Intercepting filters）** -在 J2EE Web 应用程序中，你可以配置多个拦截器来预处理和后处理用户的请求，例如跟踪和审计用户的请求。'
- en: '**Design pattern at business layer**:'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务层的设计模式：
- en: '**Business Delegate**-It acts as a bridge between application controllers and
    business logic'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务代表**-它作为应用程序控制器和业务逻辑之间的桥梁。'
- en: '**Application Service**-It provides business logics to implement the model
    as simple Java objects for presentation layer'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**-它提供业务逻辑，以实现模型作为简单的Java对象，用于表示层'
- en: '**Design pattern at integration layer**:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成层的设计模式**:'
- en: '**Data Access Object**-It is implemented for accessing business data and it
    separates data access logic from business logic in the enterprise application.'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问对象**-它是为了访问业务数据而实现的，它将企业应用程序中的数据访问逻辑与业务逻辑分开。'
- en: '**Web Service Broke**r-It encapsulates the logic to access the external application''s
    resources and it is exposed as web services.'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务断路器**-它封装了访问外部应用程序资源的逻辑，并且作为Web服务公开。'
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, the reader should now have a good idea about GOF
    Design Patterns and their best practices. I highlighted the problems that come
    if you don't implement design patterns in your enterprise application and how
    Spring solves these problems by using lots of design patterns and good practices
    to create an application. In the preceding chapter too, I have mentioned the three
    main categories of GOF Design Patterns such as Creational Design Pattern; it is
    useful for creation of object instances and also to apply some constraints at
    the creation time of the enterprise application by specific manner by Factory,
    Abstract Factory, Builder, Prototype and Singleton pattern. The second main category
    is the Structural design pattern, it is used for design structure of the enterprise
    application by dealing with the composition of classes or objects so that it reduces
    application complexity and improve the reusability and performance of the application.
    They are Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern,
    and Facade pattern come under this category of patterns. Finally, one more main
    category of the pattern is Behavioral design pattern, it characterizes the ways
    in which classes or objects interact and distribute responsibility. Patterns come
    under this category are specifically concerned with communication between objects.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，读者现在应该对GOF设计模式和它们的最佳实践有一个很好的了解。我强调了如果你在企业的应用程序中没有实现设计模式会出现的各种问题，以及Spring如何通过使用许多设计模式和良好的实践来创建应用程序来解决这些问题。在前一章中，我也提到了GOF设计模式的三个主要类别，如创建型设计模式；它对于创建对象实例很有用，并且可以通过工厂、抽象工厂、建造者、原型和单例模式以特定方式在企业的应用程序创建时间应用一些约束。第二个主要类别是结构型设计模式，它通过处理类或对象的组合来设计企业的应用程序结构，从而减少应用程序的复杂性，并提高应用程序的可重用性和性能。适配器模式、桥接模式、组合模式、装饰器模式和外观模式都属于这个模式类别。最后，还有一个主要的设计模式类别是行为型设计模式，它描述了类或对象之间交互和分配责任的方式。属于这个类别的模式特别关注对象之间的通信。
