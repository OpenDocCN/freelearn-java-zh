- en: Consideration of Structural and Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen implementations and examples of the creational design pattern
    from the GOF pattern family in [Chapter 2](75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml),
    *Overview of GOF Design Patterns - Core Design Patterns.* Now, in this chapter,
    you'll be given an overview of other parts of GOF Design Patterns, they are the
    structural and behavioral design patterns, including some best practices for application
    design. You'll also get an overview of common problem solving with these design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will understand how these design patterns provide
    the best solution to address the design and development related issues in the
    object composition and delegating responsibilities between the working objects
    in the application. You will get information about how the Spring Framework implements
    the structural and behavioral designs pattern internally to provide best enterprise
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the structural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: J2EE design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the core design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue our journey into the core design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structural design pattern**: Patterns under this category deal with the composition
    of classes or objects. In the enterprise application, there are two common techniques
    for reusing functionality in object-oriented systems as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: It is used to inherit commonly used states and behaviors from
    other classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition**: It is used to compose the other objects as instance variables
    of classes. It defines ways to compose objects to obtain new functionalities.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral design pattern**: Patterns under this category characterize the
    ways in which classes or objects interact with and distribute responsibility.
    These patterns define the methods of communication between the objects in the
    enterprise application. So here, you will learn how to use behavioral patterns
    to reduce complicated flow control. Furthermore, you will use behavioral patterns
    to encapsulate algorithms and dynamically select them at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed creational design patterns and how they
    provide the best solutions for object creation according to business demands.
    Creational design patterns only provide a solution for creating objects in the
    application with how these objects merge with each other in the application for
    a specific business goal, the structural design pattern comes into the picture.
    In this chapter, we will be exploring structural patterns, and how these patterns
    are useful to define the relationship between the objects either using inheritance
    or composition for larger structures of an application. Structural patterns allow
    you to solve many problems related to structuring the relationship between the
    objects. They show you how to glue different parts of a system together in a flexible
    and extensible fashion. Structural patterns help you guarantee that when one of
    the parts changes, the entire structure does not need to change; in a car you
    could replace the tyres with different vendors without impacting the other parts
    of that car. They also show you how to recast parts of the system that do not
    fit (but that you need to use) into parts that do fit.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convert the interface of a class into another interface clients expect. Adapter
    lets classes work together that couldn't otherwise because of incompatible interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '-GoF Design Patterns: Elements of Reusable Object-Oriented Software'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter design patterns come under the structural design pattern, according
    to this design pattern two incompatible classes work together that couldn't otherwise
    because of incompatible interfaces. This pattern works as a bridge between two
    incompatible interfaces. This pattern is used when two inferences of the application
    are incompatible in their functionalities, but these functionalities need to be
    integrated as a business requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many real-life examples where we can use the adapter pattern. Suppose
    you have different types of electric plugs such as cylindrical and rectangular
    plugs, as shown in the following figure. You can use an adapter in between to
    fit a rectangular plug in a cylindrical socket assuming voltage requirements are
    met:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5000d228-a61c-4e20-b993-7e743f469815.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Benefits of the adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the following benefits of using the adapter design pattern in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern allows you to communicate and interact with two or more
    incompatible objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern promotes the reusability of older existing functionalities in your
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common requirements for the adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the common requirements for this design pattern to addresses
    the design problems:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are to use this pattern in your application, there is a need to use an
    existing class with an incompatible interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another use of this pattern in your application is when you want to create a
    reusable class that collaborates with classes that have incompatible interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several existing subclasses to be used, but it's impractical to adapt
    their interface by sub classing each one. An object adapter can adapt the interface
    of its parent class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how Spring implements the adapter design pattern internally.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the adapter design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework uses the adapter design pattern to implement a lot of functionality
    across the framework transparently. The following are some listed classes based
    on the adapter design pattern in the Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JpaVendorAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HibernateJpaVendorAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandlerInterceptorAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageListenerAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpringContextResourceAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassPreProcessorAgentAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequestMappingHandlerAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationMethodHandlerAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebMvcConfigurerAdapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The UML diagram for the adapter pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the preceding UML diagram that illustrates the components
    of the adapter design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d434b73f-a719-4594-a789-0f07fdfa5ccb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**The Target Interface**: This is the desired interface class that will be
    used by the clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Adapter class**: This class is a wrapper class that implements the desired
    target interface and modifies the specific request available from the Adaptee
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Adaptee class**: This is the class that is used by the Adapter class
    to reuse the existing functionalities and modify them for desired use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This class will interact with the Adapter class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the following sample implementation of the adapter design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the adapter design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am going to create an example that shows the actual demonstration of the
    adapter design pattern, so let''s discuss this example, I am creating this example
    based on making payment through a payment gateway. Suppose I have one old payment
    gateway and also have the latest advanced payment gateway, and both gateways are
    unrelated to each other, so my requirement is, I want to migrate from the old
    payment gateway to an advanced payment gateway while changing my existing source
    code. I am creating an adapter class to solve this problem. This adapter class
    is working as a bridge between two different payment gateways, let''s look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create an interface for the old payment gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create an implementation class for the old payment gateway `PaymentGateway.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following interface and its implementation have new and advanced functionalities
    for the payment gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create an implementation class for the advance payment gateway interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a demo class for this pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class, we have the old payment gateway object as the `PaymentGateway`
    interface, but we convert this old payment gateway implementation to the advanced
    form of the payment gateway by using the `AdvancedPaymentGatewayAdapter` adapter
    class. Let''s run this demo class and see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a227c50d-f5fc-4ab5-8d81-13819b77e63d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've seen the adapter design pattern, let's turn to a different variant
    of it--the Bridge design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Bridge design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decouple an abstraction from its implementation so that the two can vary independently
  prefs: []
  type: TYPE_NORMAL
- en: '- GoF Design Patterns: Elements of Reusable Object-Oriented Software'
  prefs: []
  type: TYPE_NORMAL
- en: In software engineering, one of the most popular notions is preferred composition
    over inheritance. Bridge design pattern promotes this popular notion. Similar
    to the adapter pattern, this pattern also comes under the structural design pattern
    family of the GoF Design Pattern. The approach of the Bridge pattern is to decouple
    an abstraction used by the client code from its implementation; that means it
    separates the abstraction and its implementation in to separate class hierarchies.
    And also, Bridge pattern prefers composition over inheritance because inheritance
    isn't always flexible and it breaks the encapsulation, so any change made in the
    implementer affects the abstraction used by the client code.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge provides a way to communicate between two different independent components
    in software development, and a bridge structure provides you with a way to decouple
    the abstract class and the implementer class. So any change made in either the
    implementation class or the implementer (that is, the interface) doesn't affect
    the abstract class or its refined abstraction class. It makes this possible by
    using composition between the interface and the abstraction. Bridge pattern uses
    an interface as a bridge between the concrete classes of an abstract class and
    implementing classes of that interface. You can make changes in both types of
    class without any impact on the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the Bridge pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the benefits of the Bridge design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The Bridge design pattern allows you to separate the implementation and the
    abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This design pattern provides the flexibility to change both types of classes
    without side effects in the client code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This design pattern allows the hiding of actual implementation details from
    the client by using abstraction between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common problems solved by the Bridge design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the common problems addressed by the Bridge design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Removes a permanent binding between the functional abstraction and its implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can make changes to the implementing classes without affecting the abstraction
    and client code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can extend the abstraction and its implementation using subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Bridge design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following Spring modules are based on the Bridge design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewRendererServlet`: It is a bridge servlet, mainly for Portlet MVC support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Bridge design pattern**: The Bridge design pattern is used in the Spring
    logging process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see a sample implementation of the Bridge design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sample implementation of the Bridge design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the following example, where we will demonstrate the use of the
    Bridge design pattern. Suppose you want to open two types of accounts, one is
    a Savings Account and the other is a Current Account in the banking system.
  prefs: []
  type: TYPE_NORMAL
- en: '**System without using the Bridge design pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example without using the Bridge design pattern. In the following
    figure, you can see the relationship between the Bank and Account interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88b1a26b-0da1-4c49-8017-c40a7e3c6a19.png)'
  prefs: []
  type: TYPE_IMG
- en: System without using the Bridge design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a design without using the Bridge design pattern. First create
    an interface or an abstract class, **Bank**. And then create its derived classes:
    **IciciBank** and **HdfcBank**. To open an account in the bank, first decide on
    the types of account classes--**Saving Account** and **Current Account**, these
    classes extend the specific banks classes (**HdfcBank** and **IciciBank**). There
    is a simple deep inheritance hierarchy in this application. So what is wrong with
    this design as compared to the preceding figure? You will notice that in this
    design, there are two parts, one is the abstraction part and the other is the
    implementation part. Client code interacts with the abstraction part. Client code
    can only access new changes or new functionalities of the implementation part
    when you will update the abstraction part, meaning the parts, the abstraction,
    and the implementation, are tightly coupled with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how to improve this example using the Bridge design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System with the Bridge design pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we create a relation between the `Bank` and `Account`
    interface by using the Bridge design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90bfdc00-6b6a-42f8-89b2-334f66690e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: System using Bridge Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**UML structure for the Bridge design pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following figure of how the Bridge design pattern solves
    these design issues, as seen in the example where we did not use the Bridge design
    pattern. Bridge pattern separates the abstraction and implementation into two
    class hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/219a9390-0d2f-4746-97f8-d85e68e87b2c.png)'
  prefs: []
  type: TYPE_IMG
- en: UML for Bridge design pattern
  prefs: []
  type: TYPE_NORMAL
- en: We have an `Account` interface that is acting as a bridge implementer and the
    concrete classes `SavingAccount`, and `CurrentAccount` implementing the Account
    interface. The `Bank` is an abstract class and it will use object of Account.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a bridge implementer interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `Account.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create concrete bridge implementer classes to implement the `implementer` interface.
    Let's create a `SavingAccount` class as an implementation of `Account`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `SavingAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Create a `CurrentAccount` class that implements the `Account` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `CurrentAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Create abstraction in the Bridge design pattern, but first, create the interface
    **Bank**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `Bank.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement the first abstraction for the `Bank` interface and see the following
    implementation class for the `Bank` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `IciciBank.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement the second abstraction for the `Bank` interface and look at
    the following implementation class for the `Bank` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `HdfcBank.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create a demonstration class of the Bridge design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `BridgePatternMain.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this demo class and see the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/478f1615-93b0-45d3-9a2d-15b422ed5002.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've seen the Bridge design pattern, let's turn to a different variant
    of it--the composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Composite design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compose objects into tree structures to represent part-whole hierarchies. Composite
    lets clients treat individual objects and compositions of objects uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: -GoF Design Patterns
  prefs: []
  type: TYPE_NORMAL
- en: In software engineering, the composite pattern comes under the structural design
    pattern. According to this pattern, a group of objects of the same type are treated
    as a single object by the client. The idea behind the Composite design pattern
    is to compose a set of objects into a tree structure to represent a module of
    a larger structural application. And this structure for clients is a single unit
    or instance uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation behind the Composite design pattern is that objects in the system
    are grouped into the tree structure, and a tree structure is a combination of
    the node-leaf and branches. In the tree structure, nodes have a number of leaves
    and other nodes. Leaf doesn't have anything, which means there is no child of
    leaf in the tree. Leaf is treated as the end point of tree-structured data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following figure, which represents data in the tree structure
    in the form of node and leaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31cc8e59-1456-460a-980b-8e1c4547f63b.png)'
  prefs: []
  type: TYPE_IMG
- en: Tree structured data using nodes and leaves
  prefs: []
  type: TYPE_NORMAL
- en: Common problems solved by the composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, it is more difficult to design an application so that the client
    can access your objects uniformly across the application, even if that object
    was a composition of objects or an individual object. This design pattern resolves
    difficulties and allows you to design objects in such a way that you can use that
    object as a composition of objects and a single individual object.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern solves the challenges faced when creating hierarchical tree structures
    to provide clients with a uniform way to access and manipulate objects in the
    tree. The composite pattern is a good choice; it is less complex in this situation
    to treat primitives and composites as homogeneous.
  prefs: []
  type: TYPE_NORMAL
- en: UML structure of the Composite design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composite design pattern is based on the composition of similar types of objects
    into the tree structure, as you know that each tree has three main parts branch,
    node, and leaf. So let's have a look at the following terms used in this design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Component**: It is basically a branch of the tree and the branch has other
    branches, nodes, and leaves. Component provides the abstraction for all components,
    including composite objects. In the composition pattern, component **is** basically
    declared as an interface for objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leaf**: It is an object that implements all component methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composite**: It is represented as a node in the tree structure, it has other
    nodes and leaves, and it represents a composite component. It has methods to add
    the children, that is, it represents a collection of the same type of objects.
    It has other component methods for its children.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following UML diagram for this design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d30f74d-8cb9-467d-8960-00ff63b5ae13.png)'
  prefs: []
  type: TYPE_IMG
- en: UML diagram for the Composite Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefits of the Composite design pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern provides the flexibility to add new component to process dynamically,
    with change in the existing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern allows you to create a class hierarchy that contains individual
    and composite objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample implementation of the Composite design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, I am implementing an `Account` interface, which can
    be either a `SavingAccount` and `CurrentAccount` or a composition of several accounts.
    I have a `CompositeBankAccount` class, which acts as a composite pattern actor
    class. Let's look at the following code for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `Account` interface that will be treated as a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `SavingAccount` class and `CurrentAccount` class as an implementation
    of the component and that will also be treated as a leaf:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `SavingAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `CurrentAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CompositeBankAccount` class that will be treated as a Composite and
    implements the `Account` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `CompositeBankAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CompositePatternMain` class that will also be treated as a Client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `CompositePatternMain.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this demo class and see the following output at the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42f4f28b-863a-4bf9-95ab-b0bbe993d9ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have discussed the composite design pattern, let's turn to the decorator
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attach additional responsibilities to an object dynamically. Decorators provide
    a flexible alternative to sub classing for extending functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '- GOF Design Pattern'
  prefs: []
  type: TYPE_NORMAL
- en: In software engineering, the common intent of all GOF structural patterns is
    to simplify the complex relationship between objects and classes in a flexible
    enterprise application. The decorator pattern is a special type of design pattern
    among these that comes under the structural design pattern, which allows you to
    add and remove behaviors for an individual object at runtime dynamically or statically,
    without changing the existing behavior of other associated objects from the same
    class. This design pattern does this without violating the Single Responsibility
    Principle or the SOLID principle of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern uses the compositions over the inheritance for objects associations;
    it allows you to divide the functionality into different concrete classes with
    a unique area of concern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefits of the Decorator design pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern allows you to extend functionality dynamically and statically without
    altering the structure of existing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using this pattern, you could add a new responsibility to an object dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is also known as ****Wrapper****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern uses the compositions for object relationships to maintain SOLID
    principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern simplifies coding by writing new classes for every new specific
    functionality rather than changing the existing code of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common problems solved by the Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an enterprise application, there is a business requirement or there might
    be a future plan to extend the behavior of the product by adding new functionalities.
    To achieve this, you could use inheritance to extend the behavior of an object.
    But inheritance should be done at compile time and methods are also available
    for other instances of that class. Because of the code modification, there is
    a violation of the Open Closed Principle. To avoid this violation of the SOLID
    principle, you can attach new responsibility to an object dynamically. This is
    the situation where the decorator design pattern comes into the picture and addresses
    this issue in a very flexible way. Let's look at the following example of how
    to implement this design pattern into a real case study.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that a bank offers multiple accounts with different benefits to customers.
    It divides the customers into three categories--senior citizens, privileged, and
    young. The bank launches a scheme on the savings account for senior citizens--if
    they open a savings account in this bank, they will be provided medical insurance
    of up to $1,000\. Similarly, the bank also provides a scheme for the privileged
    customers as an accident insurance of up to $1,600 and an overdraft facility of
    $84\. There is no scheme for the young.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address the new requirement, we can add new subclasses of `SavingAccount`;
    one each to represent a saving account with additional benefits as decoration,
    and this is what our design looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f5bb028-442a-4fae-9f5e-54403523bae7.png)'
  prefs: []
  type: TYPE_IMG
- en: Application design with inheritance without using the Decorator Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'This design will be very complex as I will add more benefit schemes to the
    **SavingAccount**, but what would happen when the bank launches the same scheme
    for **CurrentAccount**? Clearly, this design is flawed, but this is an ideal use
    case for the decorator pattern. This pattern allows you to add runtime dynamic
    behavior. In this case, I will create an abstract **AccountDecorator** class to
    implement **Account**. And furthermore, I will create the **SeniorCitizen** class
    and **Privilege** class, which extends **AccountDecorator** because young does
    not have any extra benefits, so the SavingAccount class does not extend **AccountDecorator**.
    This is how the design will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef7b6378-ece3-4d56-abfd-5c7c81794b74.png)'
  prefs: []
  type: TYPE_IMG
- en: Application design with composition using the decorator design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure follows the Decorator design pattern by creating **AccountDecorator**
    as a **Decorator** in this pattern, and focuses on important things to observe
    the relationship between **Account** and **AccountDecorator**. This relationship
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is-a** relationship between the `AccountDecorator` and `Account`, that is,
    inheritance for the correct type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Has-a** relationship between the `AccountDecorator` and `Account`, that is,
    composition in order to add new behavior without changing the existing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the UML structure**:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/577f047c-f03e-46a7-a6e4-4495bd2971ab.png)'
  prefs: []
  type: TYPE_IMG
- en: UML for the Decorator design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes and objects participating in this pattern are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component** (**Account**): It is an interface for objects that can have responsibilities
    added to them dynamically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteComponent** (**SavingAccount**): It is a concrete class of component
    interface and it defines an object to which additional responsibilities can be
    attached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator** (**AccountDecorator**): It has a reference to a **Component**
    object and defines an interface that conforms to the interface of the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteDecorator** (**SeniorCitizen and Privilege**): It is a concrete implementation
    of **Decorator** and it adds responsibilities to the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the following code to demonstrate the Decorator design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a component class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `Account.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create concrete components classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `SavingAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another concrete class for Account component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `CurrentAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a `Decorator` class for Account component. This decorator class
    apply other run time behavior to the Account component classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `AccountDecorator.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a `ConcreteDecorator` class to implement the AccountDecorator class.
    Following class `SeniorCitizen` is extended `AccountDecorator` class to access
    other run time behavior such as `applyOtherBenefits()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `SeniorCitizen.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's create another `ConcreteDecorator` class to implement the `AccountDecorator`
    class. Following class `Privilege` is extended `AccountDecorator` class to access
    other run time behavior such as `applyOtherBenefits(`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `Privilege.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now write some test code to see how the Decorator pattern works at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `DecoratorPatternMain.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this demo class and see the following output at the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/b59232d4-7614-48e2-8273-161735ffa0f2.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Decorator design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Framework uses the Decorator design pattern to build important functionalities
    such as transactions, cache synchronization, and security-related tasks. Let''s
    look at some functionalities where Spring implements this pattern transparently:'
  prefs: []
  type: TYPE_NORMAL
- en: Weaving the advice into the Spring application. It uses the Decorator pattern
    via the CGLib proxy. It works by generating a subclass of the target class at
    runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeanDefinitionDecorator` : It is used to decorate the bean definition via
    applied custom attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebSocketHandlerDecorator`: It is used to decorate a WebSocketHandler with
    additional behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's turn to another GOF Design Pattern - Facade design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Facade Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provide a unified interface to a set of interfaces in a subsystem. Facade defines
    a higher-level interface that makes the subsystem easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: '- GOF Design Patterns'
  prefs: []
  type: TYPE_NORMAL
- en: The Facade design pattern is nothing but an interface of interfaces to simplify
    interactions between the client code and subsystem classes. This design comes
    under the GOF structural design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits of Facade Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern reduces the complexities for clients to interact with subsystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern consolidates all the business services as single interfaces to
    make them more understandable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern reduces dependencies of client code on the inner workings of a
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing when to use the Facade Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you are designing a system, and this system has a very large number
    of independent classes and also has a set of services to be implemented. This
    system is going to be very complex, so the Facade pattern comes into the picture
    and reduces the complexities of the larger system and simplifies interactions
    of the client code with a set of classes from a subsystem of the large complex
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to develop a bank enterprise application with a large number
    of services to perform a task, for example, `AccountService` for getting the `Account`
    by `accountId`, `PaymentService` for payment gateway services, and `TransferService`
    for the amount transfer from one account to another account. A client code of
    the application interacts with all these services to transfer money from one account
    to another account. This is how different clients interact with the amount transfer
    process of the bank system. As shown in the following figure, here you can see
    client code that directly interacts with the subsystem classes and client also
    should aware about the internal working of subsystem classes, so it is simply
    a violation of the SOLID design principles because client code is tightly coupled
    with the classes of subsystem of your banking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f793e18e-9f34-4e4b-a9fd-350cebfc824a.png)'
  prefs: []
  type: TYPE_IMG
- en: Banking Application Subsystem without Facade Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than client code directly interacting with the classes of a subsystem,
    you could introduce one more interface, which makes the subsystems easier to use,
    as shown in the following figure. This interface is known as a `Facade` interface,
    it is based on the Facade pattern, and it is a simple way to interact with the
    subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bdbdb56-6b8d-4173-8697-349d257f6923.png)'
  prefs: []
  type: TYPE_IMG
- en: Banking Application Subsystem with Facade design pattern
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Facade design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look into the following listings to demonstrate the Facade design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create subsystem service classes for your Bank application: Let''s see the
    following PaymentService class for the subsystem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `PaymentService.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's create another service class AccountService for the subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `AccountService.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's create another service class TransferService for the subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `TransferService.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Facade Service class to interact with the subsystem: Let''s see the
    following Facade interface for the subsystem and then implement this Facade interface
    as a global banking service in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `BankingServiceFacade.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `BankingServiceFacadeImpl.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the client of the Facade:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `FacadePatternClient.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The UML structure for the Facade design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classes and objects participating in this pattern are:'
  prefs: []
  type: TYPE_NORMAL
- en: Facade (`BankingServiceFacade`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a Facade interface that knows which subsystem classes are responsible
    for a request. This interface is responsible for delegating client requests to
    appropriate subsystem objects.
  prefs: []
  type: TYPE_NORMAL
- en: Subsystem classes (`AccountService`, `TransferService`, `PaymentService`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These interfaces are actually subsystem functionalities of the banking process
    system application. These are responsible for handling processes assigned by the
    Facade object. No interfaces in this category have a reference to the Facade object;
    they don't have implementation details of Facade. These are totally independent
    of Facade objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram for this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ac8fdbb-ec4e-4d2c-b2e9-fcc173631224.png)'
  prefs: []
  type: TYPE_IMG
- en: UML diagram for Facade design pattern
  prefs: []
  type: TYPE_NORMAL
- en: Facade Pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the enterprise application, if you are working in Spring applications, the
    facade pattern is used commonly in the business service layer of the application
    to consolidate all services. And you could also apply this pattern on DAOs on
    the persistent layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the Facade design pattern, let's turn to a different variant
    of it--Proxy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provide a surrogate or placeholder for another object to control access to it.
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Proxy design pattern provides an object of a class with the functionality of
    another class with having it. This pattern comes under the structural design pattern
    of GOF Design Patterns. The intent of this design pattern is to provide an alternate
    class for another class , along with its functionality, to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose of the Proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern hides the actual object from the outside world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern can improve the performance because it is creating an object on
    demand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML structure for the Proxy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram for this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05f5033a-1a34-4cd6-aace-e6cf6e6fb9ac.png)'
  prefs: []
  type: TYPE_IMG
- en: UML diagram for Proxy design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the different components of this UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**: Actual interface to be implemented by Proxy and RealSubject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RealSubject**: Real implementation of **Subject**. It is a real object that
    represented by the proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: It is a proxy object and it is also the implementation of the real
    object **Subject**. It maintains the references to the real object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Proxy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look into following code to demonstrate the Proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `Account.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a RealSubject class that implements Subject, let's see the following
    class as RealSubject class for the Proxy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `SavingAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create a Proxy class which implements Subject and having the Real Subject
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `ProxySavingAccount.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Proxy pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework uses the Proxy design pattern in the Spring AOP module transparently.
    As I have discussed in [Chapter 1](18f63847-961b-45a2-bef0-30602dcabed3.xhtml),
    *Getting Started with Spring Framework 5.0 and Design Patterns*. In Spring AOP,
    you create proxies of the object to apply cross cutting concern across the point
    cut in the Spring application. In the Spring, other modules also implement the
    Proxy pattern, such as RMI, Spring's HTTP Invoker, Hessian, and Burlap.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the next section about Behavioral design pattern with its underlying
    patterns and example.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intent of Behavioral design pattern is the interaction and cooperation between
    a set of objects to perform a task that no single object can carry out by itself.
    The interaction between the objects should be such that they should be loosely
    coupled. Patterns under this category, characterize the ways in which classes
    or objects interact and distribute responsibility. Let's see in the next sections,
    different variants of the Behavioral design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of Responsibility design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid coupling the sender of a request to its receiver by giving more than one
    object a chance to handle the request. Chain the receiving objects and pass the
    request along the chain until an object handles it.
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility design pattern comes under the Behavioral design pattern
    of GOF patterns family. According to this pattern, sender and receiver of a request
    are decoupled. The sender sends a request to the chain of receivers and any one
    of receivers in the chain can handle the request. In this pattern, the receiver
    object has the reference of another receiver object so that if it does not handle
    the request then it passes the same request to the other receiver object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a banking System, you could use any ATM to withdraw the money
    in any place, so it is one of the live examples of the Chain of Responsibility
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are following benefits of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern reduces the coupling between sender and receiver objects in the
    system to handle a request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is more flexible to assign the responsibility to another referenced
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern makes a chain of objects using composition, and this set of objects
    work as a single unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram showing all components of a chain of responsibility
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b759bfd8-4afb-4bc7-a381-d7c2b5ba9eec.png)'
  prefs: []
  type: TYPE_IMG
- en: UML Diagram for Chain of Responsibility design pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**Handler**: This is an abstract class or interface in the system to handle
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteHandler**: These are concrete classes which implement **Handler**
    to handle the request, or it passes same request to the next successor of the
    handler chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: It is main application class to initiate the request to the handler
    objects on the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of Responsibility pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security project implemented the Chain of Responsibility pattern in the
    Spring Framework. Spring Security allows you to implement authentication and authorization
    functionality in your application by using chains of security filters. This is
    a highly configurable framework. You can add your custom filter with this chain
    of filters to customize the functionality because of Chain of Responsibility design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the Chain of responsibility design pattern, let's turn to
    a different variant of it--Command design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Command design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulate a request as an object, thereby letting you parameterize clients
    with different requests, queue or log requests, and support undoable operations
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Patterns
  prefs: []
  type: TYPE_NORMAL
- en: The Command design pattern falls under the Behavioral pattern family of the
    GOF patterns, this pattern is a very simple data-driven pattern which allows you
    to encapsulate your request data into an object and pass that object as a command
    to the invoker method, and it return the command as another object to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lists the benefits of using the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern enables you to transfer data as an object between the system components
    sender and receiver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern allows you to parameterize objects by an action to perform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could easily add new commands in the system without changing existing classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following UML diagram showing all components of Command
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3065e0ae-3e83-4601-9104-726bfe750cde.png)'
  prefs: []
  type: TYPE_IMG
- en: UML Diagram for Command Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: It is an interface or abstract class having an action to perform
    in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteCommand**: It is a concrete implementation of the `Command` interface
    and defining an action will be performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This is a main class, it creates a `ConcreteCommand` object and
    sets its receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoker**: It is a caller to invoke the request to carry the command object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receiver**: It is simple handler method which performs the actual operation
    by `ConcreteCommand`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC has implemented the Command design pattern in the Spring Framework.
    In your enterprise applications using the Spring Framework, you often see the
    concepts of the Command pattern applied through the use of Command objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen Command design pattern, let's turn to a different variant
    of it--Interpreter design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter Design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a language, define a representation for its grammar along with an interpreter
    that uses the representation to interpret sentences in the language.
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter design pattern allows you to interpret an expression language in
    the programming to define a representation for its grammar. This type of a pattern
    comes under the Behavioral design pattern family of GOF patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lists the benefits of using the Interpreter pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern allows you to change and extend the grammar easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the expression language is very easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram is showing all components of Interpreter
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cf328c2-4671-4233-a791-fb66bdea1f72.png)'
  prefs: []
  type: TYPE_IMG
- en: UML diagram for Interpreter design pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**AbstractExpression:** It is an interface to execute a task by using `interpret()`
    operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TerminalExpression:** It is an implementation of above interface and it implements
    `interpret()` operation for terminal expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NonterminalExpression:** It is also an implementation of above interface
    and it implements `interpret()` operation for non-terminal expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context:** It is a `String` expression and contains information that is global
    to the interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client:** It is the main class to invoke the Interpret operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Spring Framework, Interpreter pattern is used with the **Spring Expression
    Language** (**SpEL**). Spring added this new feature from Spring 3.0, you can
    use it in your enterprise application using the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen Interpreter design pattern, let's turn to a different variant
    of it--Iterator design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provide a way to access the elements of an aggregate object sequentially without
    Exposing its underlying representation.
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: This is a very commonly used design pattern in the programming language as like
    in Java. This pattern comes from the Behavioral Design Pattern family of GOF pattern.
    This pattern allows you to access the items from the collection object in sequence
    without information its internal representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are following benefits of the Iterator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Easily access the items of the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use multiple to access the item from the collection because it support
    lot of variations in the traversal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a uniform interface for traversing different structures in a collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram is showing all components of Iterator
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cbed143-241f-488a-bec5-4cd6418c5270.png)'
  prefs: []
  type: TYPE_IMG
- en: UML Diagram for Iterator Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterator:** It is an interface or abstract class for accessing and traversing
    items of the collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteIterator:** It is an implementation of the **Iterator** interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregate:** It is an interface to create an Iterator object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteAggregate:** It is the implementation of the **Aggregate** interface,
    it implements the **Iterator** creation interface to return an instance of the
    proper **ConcreteIterator**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator design pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Framework also extends the Iterator pattern through the **CompositeIterator**
    class. Mainly this pattern used in the Collection Framework of Java for iterating
    the elements in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen Iterator design pattern, let's turn to a different variant
    of it--Observer design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Observer** **Design Pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: Define a one-to-many dependency between objects so that when one object changes
    state, all its dependents are notified and updated automatically
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern is one of very common design pattern, This pattern is a part
    of the Behavioral design pattern family of GOF pattern that addresses responsibilities
    of objects in an application and how they communicate between them at runtime.
    According to this pattern, sometimes objects make a one-to-many relationship between
    the objects in your application, such that if one object is modified, it's notified
    to other dependent objects automatically.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Facebook post comments are one of the examples of the observer
    design pattern. If you comment on a post of your friend then you are always notified
    by this post whenever anyone else comments on the same post again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Observer pattern provides communication between decoupled objects. It makes
    a relationship between objects mostly a one-to-many relationship. In this pattern,
    there is an object which is known as the subject. Whenever there is any change
    in the state of this subject, it will be notified to its list of dependents accordingly.
    This list of dependents is known as observers. The following figure illustrates
    the Observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8368e46a-cf78-4b1b-a6a8-a2b40e03ae8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Use case of the Observer design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'There are following lists of the benefits of using the Observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern provides decoupled relationship between the subject and observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides support for broadcasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram is showing all components of Observer
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90e6cd43-41bf-43f1-8b0d-a21741e91510.png)'
  prefs: []
  type: TYPE_IMG
- en: UML Diagram for Observer Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**: It is an interface. It has information about its observers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteSubject**: It is a concrete implementation of **Subject**, it has
    information about all its observers to be notified when its state changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: It is an interface to be notified of changes in a subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteObserver**: It is a concrete implementation of Observer, it keeps
    its state consistent with the subject''s state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer pattern in the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Spring Framework, the Observer design pattern is used to implement event
    handling function of `ApplicationContext`. Spring provides us the `ApplicationEvent`
    class and `ApplicationListener` interface to enable event handling in Spring `ApplicationContext`.
    Any bean in your Spring application implements the `ApplicationListener` interface,
    it will receive an `ApplicationEvent` every time the `ApplicationEvent` is published
    by an event publisher. Here, the event publisher is the subject and the bean that
    implements ApplicationListener is the observer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen Observer design pattern, let's turn to a different variant
    of it--Template design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Template Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define the skeleton of an algorithm in an operation, deferring some steps to
    subclasses. Template Method lets subclasses redefine certain steps of an algorithm
    without changing the algorithm's structure.
  prefs: []
  type: TYPE_NORMAL
- en: 60; -GOF Design Patterns
  prefs: []
  type: TYPE_NORMAL
- en: In Template design pattern, an abstract class wraps some defined ways to its
    method. That method allows you to override parts of the method without rewriting
    it. You could use its concrete class to your application to perform similar type
    actions. This design pattern comes under the Behavior design pattern family of
    GOF pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are following lists the benefits of using the Template pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces the boilerplate codes in the application by reusing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern creates a template or way to reuse multiple similar algorithms
    to perform some business requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following UML diagram is showing the components of Template
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a46a5f03-e61f-49be-892f-f3a1c9f16669.png)'
  prefs: []
  type: TYPE_IMG
- en: UML Diagram for Template design pattern
  prefs: []
  type: TYPE_NORMAL
- en: '**AbstractClass**: This is an abstract class that contains a template method
    defining the skeleton of an algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConcreteClass:** This is a concrete subclass of **AbstractClass** that implements
    the operations to carry out the algorithm-specific primitive steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the next section about J2EE design patterns in the enterprise distributed
    applications
  prefs: []
  type: TYPE_NORMAL
- en: JEE design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is other main category of design patterns. Application design can be immensely
    simplified by applying Java EE design patterns. Java EE design patterns have been
    documented in Sun''s Java Blueprints. These Java EE design patterns provide time-tested
    solution guidelines and best practices for object interaction in the different
    layer of a Java EE application. These design patterns are specifically concerned
    with the following listed layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern at presentation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design pattern at business layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design pattern at integration layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These design patterns are specifically concerned with the following listed layers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design pattern at presentation layer**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Helper**: It separates views from the business logic of an enterprise
    J2EE application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Front Controller**: It provides a single point of action to handle the all
    coming requests to the J2EE web application, it forwards the request to specific
    application controller to access model and view for presentation tier resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Controller**-The request actually handled by the Application
    Controller, it acts as a front controller helper. It responsible for the coordination
    with the business models and view components.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatcher View**-It is related to the view only and it executes without
    business logic to prepare a response to the next view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intercepting filters** -In the J2EE web application, you could configure
    multiple interceptors for pre and post processing an user''s request such as tracking
    and auditing user''s requests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design pattern at business layer**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business Delegate**-It acts as a bridge between application controllers and
    business logic'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Service**-It provides business logics to implement the model
    as simple Java objects for presentation layer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design pattern at integration layer**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Access Object**-It is implemented for accessing business data and it
    separates data access logic from business logic in the enterprise application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Service Broke**r-It encapsulates the logic to access the external application''s
    resources and it is exposed as web services.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, the reader should now have a good idea about GOF
    Design Patterns and their best practices. I highlighted the problems that come
    if you don't implement design patterns in your enterprise application and how
    Spring solves these problems by using lots of design patterns and good practices
    to create an application. In the preceding chapter too, I have mentioned the three
    main categories of GOF Design Patterns such as Creational Design Pattern; it is
    useful for creation of object instances and also to apply some constraints at
    the creation time of the enterprise application by specific manner by Factory,
    Abstract Factory, Builder, Prototype and Singleton pattern. The second main category
    is the Structural design pattern, it is used for design structure of the enterprise
    application by dealing with the composition of classes or objects so that it reduces
    application complexity and improve the reusability and performance of the application.
    They are Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern,
    and Facade pattern come under this category of patterns. Finally, one more main
    category of the pattern is Behavioral design pattern, it characterizes the ways
    in which classes or objects interact and distribute responsibility. Patterns come
    under this category are specifically concerned with communication between objects.
  prefs: []
  type: TYPE_NORMAL
