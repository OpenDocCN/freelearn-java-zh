<html><head></head><body>
<div class="book" title="Chapter&#xA0;8.&#xA0;More About Search &#x2013; Search Trees and Hash Tables"><div class="book" id="1DOR02-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. More About Search – Search Trees and Hash Tables</h1></div></div></div><p class="calibre8">In the previous chapters, we had a look at both binary search and trees. In this chapter, we will see how they are related and how this helps us create some more flexible, searchable data structures. We will also look at a different kind of searchable structure called a hash table. The reason for using these structures is that they allow mutation and still remain searchable. Basically, we need to be able to insert and delete elements from the data structures with ease while still being able to conduct a search efficiently. These structures are relatively complicated, so we need to take a step-by-step approach toward understanding it.</p><p class="calibre8">We'll cover the following topics in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Binary search trees</li><li class="listitem">Balanced binary search trees</li><li class="listitem">Hash tables</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;More About Search &#x2013; Search Trees and Hash Tables">
<div class="book" title="Binary search tree"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec41" class="calibre1"/>Binary search tree</h1></div></div></div><p class="calibre8">You already know what binary search is. Let's go back to the sorted array from an earlier chapter<a id="id347" class="calibre1"/> and study it again. If you think about binary search, you know you need to start from the middle of the sorted array. Depending on the value to be searched, either we return if the middle element is the search item, or move to the left or right based on whether the search value is greater than or less than the middle value. After this, we continue the same process recursively. This means the landing points in each step are quite fixed; they are the middle values. We can draw all the search paths as in the next figure. In each step, the arrows connect to the mid points of both the right half and left half, considering the current position. In the bottom part, we disassemble the array and spread out the elements while keeping the sources and targets of the arrows similar. As one can see, this gives us a binary tree. Since each edge in this tree moves from the midpoint of one step to the midpoint of the next step in the binary search, the same search can be performed in the tree by simply following its edges. This tree is quite<a id="id348" class="calibre1"/> appropriately called a binary search tree. Each level of this tree represents a step in binary search:</p><div class="mediaobject"><img src="../images/00046.jpeg" alt="Binary search tree" class="calibre9"/><div class="caption"><p class="calibre15">Binary search tree</p></div></div><p class="calibre10"> </p><p class="calibre8">Say we want to search for item number <span class="strong"><strong class="calibre2">23</strong></span>. We start from the original midpoint, which is the root of the tree. The root has the value <span class="strong"><strong class="calibre2">50</strong></span>. <span class="strong"><strong class="calibre2">23</strong></span> is less than <span class="strong"><strong class="calibre2">50</strong></span>, so we must check the left-hand side; in the case of our tree, follow the left edge. We arrive at the value <span class="strong"><strong class="calibre2">17</strong></span>. <span class="strong"><strong class="calibre2">23</strong></span> is greater than <span class="strong"><strong class="calibre2">17</strong></span>, so we must follow the right edge and arrive at the value <span class="strong"><strong class="calibre2">23</strong></span>. We just found the element we have been searching for. This algorithm can be summarized as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start at the root.</li><li class="listitem" value="2">If the current element is equal to the search element, we are done.</li><li class="listitem" value="3">If the search element is less than the current element, we follow the left edge and start again from 2.</li><li class="listitem" value="4">If the search element is greater than the current element, we follow the right edge and start again from 2.</li></ol><div class="calibre13"/></div><p class="calibre8">To code <a id="id349" class="calibre1"/>this algorithm, we must first create a binary search tree. Create a <code class="email">BinarySearchTree</code> class extending the <code class="email">BinaryTree</code> class and then put your algorithm inside it:</p><div class="informalexample"><pre class="programlisting">public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; extends BinaryTree&lt;E&gt; {

    protected Node&lt;E&gt; searchValue(E value, Node&lt;E&gt; root){
        if(root==null){
            return null;
        }
        int comp = root.getValue().compareTo(value);
        if(comp == 0){
            return root;
        }else if(comp&gt;0){
            return searchValue(value, root.getLeft());
        }else{
            return  searchValue(value, root.getRight());
        }
    }</pre></div><p class="calibre8">Now wrap the method so that you don't need to pass the root. This method also checks whether the tree is an empty tree and fails the search if that is the case:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; searchValue(E value){
        if(getRoot()==null){
            return null;
        }else{
            return searchValue(value, getRoot());
        }
    }
    …

}</pre></div><p class="calibre8">So what exactly is the point of modifying an array in a binary tree? After all, are we not doing the same exact search still? Well, the point is that when we have this in a tree form, we can easily insert new values in the tree or delete some values. In the case of an array, insertion and <a id="id350" class="calibre1"/>deletion have linear time complexity and cannot go beyond the preallocated array size.</p></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;More About Search &#x2013; Search Trees and Hash Tables">
<div class="book" title="Binary search tree">
<div class="book" title="Insertion in a binary search tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec50" class="calibre1"/>Insertion in a binary search tree</h2></div></div></div><p class="calibre8">Insertion in a binary search tree is done by first searching for the value to be inserted. This either<a id="id351" class="calibre1"/> finds the element or ends the search unsuccessfully, where the new value is supposed to be if it were in that position. Once we reach this position, we can simply add the element to the tree. In the following code, we rewrite the search again because we need access to the parent node once we find the empty spot to insert our element:</p><div class="informalexample"><pre class="programlisting">    protected Node&lt;E&gt; insertValue(E value, Node&lt;E&gt; node){
        int comp = node.getValue().compareTo(value);
        Node&lt;E&gt; child;
        if(comp&lt;=0){
            child = node.getRight();
            if(child==null){
                return addChild(node,value,false);
            }else{
                return insertValue(value, child);
            }
        }else if(comp&gt;0){
            child = node.getLeft();
            if(child==null){
                return addChild(node,value,true);
            }else{
                return insertValue(value, child);
            }
        }else{
            return null;
        }
    }</pre></div><p class="calibre8">We can wrap this up into a method that does not need a starting node. It also makes sure that when we insert into an empty tree, we just add a root:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; insertValue(E value){
        if(getRoot()==null){
            addRoot(value);
            return getRoot();
        }else{
            return insertValue(value, getRoot());
        }
    }</pre></div><p class="calibre8">Suppose in our earlier tree, we want to insert the value <span class="strong"><strong class="calibre2">21</strong></span>. The following figure shows the search<a id="id352" class="calibre1"/> path using arrows and how the new value is inserted:</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Insertion in a binary search tree" class="calibre9"/><div class="caption"><p class="calibre15">Insertion of a new value into a binary tree</p></div></div><p class="calibre10"> </p><p class="calibre8">Now that we have the means to insert elements in the tree, we can build the tree simply by a successive insertion. The following code creates a random tree with 20 elements and then does an in-order traversal of it:</p><div class="informalexample"><pre class="programlisting">BinarySearchTree&lt;Integer&gt; tree = new BinarySearchTree&lt;&gt;();
for(int i=0;i&lt;20;i++){
    int value = (int) (100*Math.random());
    tree.insertValue(value);
}
tree.traverseDepthFirst((x)-&gt;System.out.print(""+x), tree.getRoot(), DepthFirstTraversalType.INORDER);</pre></div><p class="calibre8">If you run the preceding code, you will always find that the elements are sorted. Why is this the case? We will see this in the next section.</p><p class="calibre8">What to do if the<a id="id353" class="calibre1"/> element inserted is the same as the element already present in the search tree? It depends on that particular application. Generally, since we search by value, we don't want duplicate copies of the same value. For simplicity, we will not insert a value if it is already there.</p></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;More About Search &#x2013; Search Trees and Hash Tables">
<div class="book" title="Binary search tree">
<div class="book" title="Invariant of a binary search tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec51" class="calibre1"/>Invariant of a binary search tree</h2></div></div></div><p class="calibre8">An invariant is a <a id="id354" class="calibre1"/>property that stays the same irrespective<a id="id355" class="calibre1"/> of the modifications made in the structure it is related to. An in-order traversal of a binary search tree will always result in the traversal of the elements in a sorted order. To understand why this happens, let's consider another invariant of a binary tree: all descendants of the left child of a node have a value less than or equal to the value of the node, and all descendants of the right child of a node have a value greater than the value of the node. It is understandable why this is true if you think about how we formed the binary search tree using the binary search algorithm. This is why when we see an element bigger than our search value, we always move to the left child. This is because all the values that are descendants of the right child are bigger than the left child so there is no point investing time in checking them. We will use this to establish that an in-order traversal of a binary search tree will traverse elements in a sorted order of the values in the nodes.</p><p class="calibre8">We will use induction to argue for this. Suppose we have a tree with only one node. In this case, any traversal could be easily sorted. Now let's consider a tree with only three elements, as shown in the following figure:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Invariant of a binary search tree" class="calibre9"/><div class="caption"><p class="calibre15">A binary search tree with three nodes</p></div></div><p class="calibre10"> </p><p class="calibre8">An in-order traversal of this tree will first process the left child, then the parent, and finally, the right<a id="id356" class="calibre1"/> child. Since the search tree guarantees that the <a id="id357" class="calibre1"/>left child has a value that is less than or equal to the parent and the right child has a value greater than or equal to the value of the parent, the traversal is sorted.</p><p class="calibre8">Now let's consider our general case. Suppose this invariant we discussed is true for trees with maximum <span class="strong"><em class="calibre12">h-levels</em></span>. We will prove that, in such a case, it is also true for trees with maximum <span class="strong"><em class="calibre12">h+1</em></span> levels. We will consider a general search tree, as shown in the following figure:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Invariant of a binary search tree" class="calibre9"/><div class="caption"><p class="calibre15">A general binary search tree</p></div></div><p class="calibre10"> </p><p class="calibre8">The triangles represent subtrees with maximum <span class="strong"><em class="calibre12">n</em></span> levels. We assume that the invariant holds true for subtrees. Now, an in-order traversal would first traverse the left subtree in sorted order, then the parent, and finally, the right subtree in the same order. The sorted order traversal of the subtrees is implied by the assumption that the invariant holds true for these subtrees. This will result in the order <span class="strong"><em class="calibre12">[traversal of left descendants in sorted order][traversal of parents][traversal of right descendants in sorted order]</em></span>. Since the left descendants are all less than or equal to the parent and right descendants are all greater than or equal to the parent, the order mentioned is actually a sorted order. So a tree of the maximum level <span class="strong"><em class="calibre12">h+1</em></span> can be drawn, as shown in the preceding figure, with each sub-tree having <span class="strong"><em class="calibre12">n</em></span> levels maximum. If this the case and the invariant is true for all trees with level <span class="strong"><em class="calibre12">h</em></span>, it must also be true for trees with level <span class="strong"><em class="calibre12">h+1</em></span>.</p><p class="calibre8">We already know that the invariant is true for trees with maximum level 1 and 2. However, it must be true for trees with maximum level 3 as well. This implies it must be true for trees <a id="id358" class="calibre1"/>with maximum level 4 and so on up to infinity. This<a id="id359" class="calibre1"/> proves that the invariant is true for all <span class="strong"><em class="calibre12">h</em></span> and is universally true.</p></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;More About Search &#x2013; Search Trees and Hash Tables">
<div class="book" title="Binary search tree">
<div class="book" title="Deletion of an element from a binary search tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec52" class="calibre1"/>Deletion of an element from a binary search tree</h2></div></div></div><p class="calibre8">We are<a id="id360" class="calibre1"/> interested in all the modifications of a binary search tree where the resultant tree will remain a valid binary search tree. Other than insertion, we need to be able to carry out deletion as well. That is to say, we need to be able to remove an existing value from the tree:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Deletion of an element from a binary search tree" class="calibre9"/><div class="caption"><p class="calibre15">Three simple cases of deletion of nodes</p></div></div><p class="calibre10"> </p><p class="calibre8">The main<a id="id361" class="calibre1"/> concern is to know what to do with the children of the deleted node. We don't want to lose those values from the tree, and we still want to make sure the tree remains a search tree. There are four different cases we need to consider. The relatively easier three cases are shown in the preceding figure. Here's a <a id="id362" class="calibre1"/>brief description of these cases:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first case is where there is no child. This is the easiest case; we just delete the node.</li><li class="listitem">The second case is where there is only a right subtree. In this case, the subtree can take the place of the deleted node.</li><li class="listitem">The third case is very similar to the second case, except it is about the left subtree.</li></ul></div><p class="calibre8">The fourth case is, of course, when both the children are present for the node to be deleted. In this case, none of the children can take the place of the node that is to be deleted as the other one would also need to be attached somewhere. We resolve this by replacing the node that needs to be deleted by another node that can be a valid parent of both the children. This node is the least node of the right subtree. Why is this the case? It is because if we delete this node from the right subtree, the remaining nodes of the right subtree would be greater than or equal to this node. And this node is also, of course, greater than all the nodes of the left subtree. This makes this node a valid parent.</p><p class="calibre8">The next question is this: what is the least node in the right subtree? Remember that when we move to the left child of a node, we always get a value that is less than or equal to the current node. Hence, we must keep traversing left until we find no more left child. If we do this, we will reach the least node eventually. The least node of any subtree cannot have any left child, so it can be deleted using the first case or the second case of deletion. The delete operation of the fourth case is thus used to:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Copy the value of the least node in the right subtree to the node to be deleted</li><li class="listitem">Delete the least node in the right subtree</li></ul></div><p class="calibre8">To write the deletion code, we need to first add a few methods to our <code class="email">BinaryTree</code> class, which is meant for deleting nodes and rewriting node values. The method <code class="email">deleteNodeWithSubtree</code> simply deletes a node along with all its descendants. It simply forgets about all the descendants. It also has certain checks to confirm the validity of the input. Deletion of a root, as usual, must be handled separately:</p><div class="informalexample"><pre class="programlisting">    public void deleteNodeWithSubtree(Node&lt;E&gt; node){
        if(node == null){
            throw new NullPointerException("Cannot delete to null parent");
        }else if(node.containerTree != this){
            throw new IllegalArgumentException(
                "Node does not belong to this tree");
        }else {
            if(node==getRoot()){
                root=null;
                return;
            }else{
                Node&lt;E&gt; partent = node.getParent();
                if(partent.getLeft()==node){
                    partent.left = null;
            }else{
                partent.right = null;
            }
        }
    }
}</pre></div><p class="calibre8">Now we add <a id="id363" class="calibre1"/>another method to the <code class="email">BinaryTree</code> class for rewriting the value in a node. We don't allow this class to use public methods in the <code class="email">node</code> class to maintain encapsulation:</p><div class="informalexample"><pre class="programlisting">    public void setValue(Node&lt;E&gt; node, E value){
        if(node == null){
            throw new NullPointerException("Cannot add node to null parent");
        }else if(node.containerTree != this){
            throw new IllegalArgumentException(
                     "Parent does not belong to this tree");
        }else {
            node.value = value;
        }
    }</pre></div><p class="calibre8">The preceding code is self-explanatory. Finally, we write a method to replace a node's child with another node from the same tree. This is useful for cases 2 and 3:</p><div class="informalexample"><pre class="programlisting">    public Node&lt;E&gt; setChild(Node&lt;E&gt; parent, Node&lt;E&gt; child, boolean left){
        if(parent == null){
            throw new NullPointerException("Cannot set node to null parent");
        }else if(parent.containerTree != this){
            throw new IllegalArgumentException(
                "Parent does not belong to this tree");
        }else {
            if(left){
                parent.left = child;
            }else{
                parent.right = child;
            }
            if(child!=null) {
                child.parent = parent;
            }
            return child;
        }
    }</pre></div><p class="calibre8">Finally, we add <a id="id364" class="calibre1"/>a method to <code class="email">BinarySearchTree</code> to find the least node in the subtree. We walk keeping to the left until there is no more child on the left-hand side:</p><div class="informalexample"><pre class="programlisting">    protected Node&lt;E&gt; getLeftMost(Node&lt;E&gt; node){
        if(node==null){
            return null;
        }else if(node.getLeft()==null){
            return node;
        }else{
            return getLeftMost(node.getLeft());
        }
    }</pre></div><p class="calibre8">Now we can implement our deletion algorithm. First, we create a <code class="email">deleteNode</code> method that deletes a node. We can then use this method to delete a value:</p><div class="informalexample"><pre class="programlisting">    private Node&lt;E&gt; deleteNode(Node&lt;E&gt; nodeToBeDeleted) {
       
        boolean direction;
        if(nodeToBeDeleted.getParent()!=null
           &amp;&amp; nodeToBeDeleted.getParent().getLeft()==nodeToBeDeleted){
            direction = true;
        }else{
            direction = false;
        }</pre></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Case 1</strong></span>: There are no children. In this case, we can simply delete the node:</p><div class="informalexample"><pre class="programlisting">        if(nodeToBeDeleted.getLeft()==null &amp;&amp;
            nodeToBeDeleted.getRight()==null){
            deleteNodeWithSubtree(nodeToBeDeleted);
            return nodeToBeDeleted;
        }</pre></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Case 2</strong></span>: There is only a right child. The right child can take the place of the deleted node:</p><div class="informalexample"><pre class="programlisting">        else if(nodeToBeDeleted.getLeft()==null){
            if(nodeToBeDeleted.getParent() == null){
                root = nodeToBeDeleted.getRight();
            }else {
                setChild(nodeToBeDeleted.getParent(),
                nodeToBeDeleted.getRight(), direction);
            }
             return nodeToBeDeleted;
         }</pre></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Case 3</strong></span>: There is <a id="id365" class="calibre1"/>only a left child. The left child can take the place of the deleted node:</p><div class="informalexample"><pre class="programlisting">        else if(nodeToBeDeleted.getRight()==null){
            if(nodeToBeDeleted.getParent() == null){
                root = nodeToBeDeleted.getLeft();
            }else {
                setChild(nodeToBeDeleted.getParent(),
                nodeToBeDeleted.getLeft(), direction);
            }
            return nodeToBeDeleted;
        }</pre></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Case 4</strong></span>: Both left child and right child are present. In this case, first we copy the value of the leftmost child in the right subtree (or the successor) to the node that needs to be deleted. Once we do this, we delete the leftmost child in the right subtree:</p><div class="informalexample"><pre class="programlisting">        else{
         Node&lt;E&gt; nodeToBeReplaced = getLeftMost(nodeToBeDeleted.getRight());
            setValue(nodeToBeDeleted, nodeToBeReplaced.getValue());
            deleteNode(nodeToBeReplaced);
            return nodeToBeReplaced;
        }
    }</pre></div><p class="calibre8">The process of deleting a node turned out to be a little more complicated, but it is not difficult. In the next section, we will discuss the complexity of the operations of a binary search tree.</p></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;More About Search &#x2013; Search Trees and Hash Tables">
<div class="book" title="Binary search tree">
<div class="book" title="Complexity of the binary search tree operations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec53" class="calibre1"/>Complexity of the binary search tree operations</h2></div></div></div><p class="calibre8">The first operation <a id="id366" class="calibre1"/>we will consider is the search operation. It starts at the root and moves down one level every time we move from one node to either of its children. The maximum number of edges we have to traverse during the search operation must be equivalent to the maximum height of the tree—that is, the maximum distance between any node and root. If the height of the tree is <span class="strong"><em class="calibre12">h</em></span>, then the complexity of search is <span class="strong"><em class="calibre12">O(h)</em></span>.</p><p class="calibre8">Now what is the relation between the number of nodes <span class="strong"><em class="calibre12">n</em></span> of a tree and the height <span class="strong"><em class="calibre12">h</em></span> of a tree? It really depends on how the tree is built. Any level would require at least one node in it, so in the worst case scenario, <span class="strong"><em class="calibre12">h = n</em></span> and the search complexity is <span class="strong"><em class="calibre12">O(n)</em></span>. What is our best case? Or rather, what do we want <span class="strong"><em class="calibre12">h</em></span> to be in relation to <span class="strong"><em class="calibre12">n</em></span>? In other words, what is the minimum <span class="strong"><em class="calibre12">h</em></span>, given <a id="id367" class="calibre1"/>a particular <span class="strong"><em class="calibre12">n</em></span>. To answer this, we first ask, what is the maximum <span class="strong"><em class="calibre12">n</em></span> we can fit in a tree with height <span class="strong"><em class="calibre12">h</em></span>?</p><p class="calibre8">The root is just a single element. The children of the root make a complete level adding two more nodes for a tree of height 2. In the next level, we will have two children for any node in this level. So the next level or level three has a total of <span class="strong"><em class="calibre12">2X2=4</em></span> nodes. It can be easily seen that the level <span class="strong"><em class="calibre12">h</em></span> of the tree has a total of <span class="strong"><em class="calibre12">2<sup class="calibre14">(h-1)</sup></em></span> nodes. The total number of nodes that a tree of height <span class="strong"><em class="calibre12">h</em></span> can then have is as follows:</p><div class="informalexample"><pre class="programlisting">n = 1 + 2 + 4+ … + 2<sup class="calibre14">(h-1)</sup> = 2<sup class="calibre14">h</sup> – 1
=&gt; 2<sup class="calibre14">h</sup> = (n+1) 
=&gt; h = lg (n+ 1)</pre></div><p class="calibre8">This is our ideal case where the complexity of the search is <span class="strong"><em class="calibre12">O(lg n)</em></span>. This kind of a tree where all the levels are full is called a balanced binary tree. Our aim is to maintain the balanced nature of the tree even when insertion or deletion is carried out. However, in general, the tree would not remain balanced in the case of an arbitrary order of insertion of elements.</p><p class="calibre8">Insertion simply requires searching the element; once this is done, adding a new node is just a constant time operation. Therefore, it has the same complexity as that of a search. Deletion actually requires a maximum of two searches (in the fourth case), so it also has the same complexity as that of a search.</p></div></div></div>

<div class="book" title="Self-balancing binary search tree"><div class="book" id="1ENBI2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec42" class="calibre1"/>Self-balancing binary search tree</h1></div></div></div><p class="calibre8">A binary search tree that remains balanced to some extent when insertion and deletion is carried out is <a id="id368" class="calibre1"/>called a self-balancing binary search tree. To <a id="id369" class="calibre1"/>create a balanced version of an unbalanced tree, we use a peculiar operation called <span class="strong"><strong class="calibre2">rotation</strong></span>. We <a id="id370" class="calibre1"/>will discuss rotation in the following section:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Self-balancing binary search tree" class="calibre9"/><div class="caption"><p class="calibre15">Rotation of a binary search tree</p></div></div><p class="calibre10"> </p><p class="calibre8">This figure <a id="id371" class="calibre1"/>shows the rotation<a id="id372" class="calibre1"/> operation on nodes <span class="strong"><strong class="calibre2">A</strong></span> and <span class="strong"><strong class="calibre2">B</strong></span>. Left rotation on <span class="strong"><strong class="calibre2">A</strong></span> creates the right image, and right rotation on <span class="strong"><strong class="calibre2">B</strong></span> creates the left image. To visualize a rotation, first think about pulling out the subtree <span class="strong"><strong class="calibre2">D</strong></span>. This subtree is somewhere in the middle. Now the nodes are rotated in either the left or right direction. In the case of the left rotation, the right child becomes the parent and the parent becomes the left child of the original child. Once this rotation is done, the <span class="strong"><strong class="calibre2">D</strong></span> subtree is added to the right child's position of the original parent. The right rotation is exactly the same but in the opposite direction.</p><p class="calibre8">How does it help balance a tree? Notice the left-hand side of the diagram. You'll realize that the right side looks heavier, however, once you perform left rotation, the left-hand side will appear heavier. Actually, a left rotation decreases the depth of the right subtree by one and increases that of the left subtree by one. Even if, originally, the right-hand side had a depth of 2 when compared to the left-hand side, you could fix it using left rotation. The only exception is the subtree <span class="strong"><strong class="calibre2">D</strong></span> since the root of <span class="strong"><strong class="calibre2">D</strong></span> remains at the same level; its maximum depth does not change. A similar argument will hold true for the right rotation as well.</p><p class="calibre8">Rotation keeps the search-tree property of the tree unchanged. This is very important if we are going to use it to balance search trees. Let's consider the left rotation. From the positions, we can conclude the following inequalities:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Each node in <span class="strong"><strong class="calibre2">C</strong></span> ≤ <span class="strong"><strong class="calibre2">A</strong></span></li><li class="listitem">A  ≤ B</li><li class="listitem"><span class="strong"><strong class="calibre2">A</strong></span> ≤ Each node in <span class="strong"><strong class="calibre2">D</strong></span> ≤ <span class="strong"><strong class="calibre2">B</strong></span></li><li class="listitem"><span class="strong"><strong class="calibre2">B</strong></span> ≤ Each node in <span class="strong"><strong class="calibre2">E</strong></span></li></ul></div><p class="calibre8">After we perform the rotation, we check the inequalities the same way and we find they are exactly the same. This proves the fact that rotation keeps the search-tree property unchanged. A very similar argument can be made for the right rotation as well. The idea of the algorithm of a rotation is simple: first take the middle subtree out, do the rotation, and reattach the <a id="id373" class="calibre1"/>middle <a id="id374" class="calibre1"/>subtree. The following is the implementation in our <code class="email">BinaryTree</code> class:</p><div class="informalexample"><pre class="programlisting">    protected void rotate(Node&lt;E&gt; node, boolean left){</pre></div><p class="calibre8">First, let's do some parameter value checks:</p><div class="informalexample"><pre class="programlisting">        if(node == null){
            throw new IllegalArgumentException("Cannot rotate null node");
        }else if(node.containerTree != this){
            throw  new IllegalArgumentException(
                "Node does not belong to the current tree");
        }
        Node&lt;E&gt; child = null;
        Node&lt;E&gt; grandchild = null;
        Node&lt;E&gt; parent = node.getParent();
        boolean parentDirection;</pre></div><p class="calibre8">The child and grandchild we want to move depend on the direction of the rotation:</p><div class="informalexample"><pre class="programlisting">        if(left){
            child = node.getRight();
            if(child!=null){
                grandchild = child.getLeft();
            }
        }else{
            child = node.getLeft();
            if(child!=null){
                grandchild = child.getRight();
            }
        }</pre></div><p class="calibre8">The root node needs to be treated differently as usual:</p><div class="informalexample"><pre class="programlisting">        if(node != getRoot()){
            if(parent.getLeft()==node){
                parentDirection = true;
            }else{
                parentDirection = false;
            }
            if(grandchild!=null)
                deleteNodeWithSubtree(grandchild);
            if(child!=null)
                deleteNodeWithSubtree(child);
                deleteNodeWithSubtree(node);
            if(child!=null) {
                setChild(parent, child, parentDirection);
                setChild(child, node, left);
            }
            if(grandchild!=null)
                setChild(node, grandchild, !left);
        }else{
            if(grandchild!=null)
                deleteNodeWithSubtree(grandchild);
            if(child!=null)
                deleteNodeWithSubtree(child);
                deleteNodeWithSubtree(node);
            if(child!=null) {
                root = child;
                setChild(child, node, left);
            }
            if(grandchild!=null)
                setChild(node, grandchild, !left);
                root.parent = null;
        }
    }</pre></div><p class="calibre8">We now can<a id="id375" class="calibre1"/> look at our first <a id="id376" class="calibre1"/>self-balancing binary tree called the AVL tree.</p></div>

<div class="book" title="Self-balancing binary search tree">
<div class="book" title="AVL tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec54" class="calibre1"/>AVL tree</h2></div></div></div><p class="calibre8">AVL tree is our first self-binary search tree. The idea is simple: keep every subtree as balanced<a id="id377" class="calibre1"/> as possible. An ideal scenario would <a id="id378" class="calibre1"/>be for both the left and right subtrees, starting from every node, to have exactly the same height. However, since the number of nodes are not in the form of <span class="strong"><em class="calibre12">2<sup class="calibre14">p</sup></em></span>
<span class="strong"><em class="calibre12">-1</em></span>, where <span class="strong"><em class="calibre12">p</em></span> is a positive integer, we cannot always achieve this. Instead, we allow a little bit of wiggle room. It's important that the difference between the height of the left subtree and the right subtree must not be greater than one. If, during any insert or delete operation, we happen to break this condition, we will apply rotations to fix this. We only have to worry about a difference of two between the heights as we are only thinking of insertion and deletion of one element at a time, and inserting one element or deleting it cannot change the height by more than one. Therefore, our worst case is that there was already a difference of one and the new addition or deletion created one more difference requiring a rotation.</p><p class="calibre8">The simplest kind <a id="id379" class="calibre1"/>of rotation is shown in the<a id="id380" class="calibre1"/> following figure. The triangles represent subtrees of equal heights. Notice that the height of the left subtree is two less than the height of the right subtree:</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="AVL tree" class="calibre9"/><div class="caption"><p class="calibre15">AVL tree – simple rotation</p></div></div><p class="calibre10"> </p><p class="calibre8">So we do a left rotation to generate the subtree of the structure, as shown in the preceding diagram. You can see that the heights of the subtrees follow our condition. The simple right rotation case is exactly the same, just in the opposite direction. We must do this for all the ancestors of the node that were either inserted or deleted as the heights of subtrees rooted by these nodes were the only ones affected by it. Since rotations also cause heights to change, we must start from the bottom and walk our way up to the root while doing rotations.</p><p class="calibre8">There is one more kind of case called a double rotation. Notice that the height of the subtree rooted by the middle grandchild does not change due to the rotation. So, if this is the reason for the imbalance, a simple rotation will not fix it. It is shown in the following figure:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="AVL tree" class="calibre9"/><div class="caption"><p class="calibre15">Simple rotation does not fix this kind of imbalance</p></div></div><p class="calibre10"> </p><p class="calibre8">Here, the <a id="id381" class="calibre1"/>subtree that received an insertion is rooted<a id="id382" class="calibre1"/> by <span class="strong"><strong class="calibre2">D</strong></span> or a node is deleted from the subtree <span class="strong"><strong class="calibre2">C</strong></span>. In the case of an insertion, notice that there would be no rotation on <span class="strong"><strong class="calibre2">B</strong></span> as the left subtree of <span class="strong"><strong class="calibre2">B</strong></span> has a height of only one more than that of its right subtree. <span class="strong"><strong class="calibre2">A</strong></span> is however unbalanced. The height of the left subtree of <span class="strong"><strong class="calibre2">A</strong></span> is two less than that of its right subtree. However, if we do a rotation on <span class="strong"><strong class="calibre2">A</strong></span>, as shown in the preceding figure, it does not fix the problem; only the left-heavy condition is transformed into a right-heavy condition. To resolve this, we need a double rotation, as shown in the next figure. First, we do an opposite direction rotation of the middle grandchild so that it is not unbalanced in the opposite direction. A simple rotation after this will fix the imbalance.</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="AVL tree" class="calibre9"/><div class="caption"><p class="calibre15">AVL tree double rotation</p></div></div><p class="calibre10"> </p><p class="calibre8">So we create an <a id="id383" class="calibre1"/>AVL tree class, and we add an extra field <a id="id384" class="calibre1"/>to the <code class="email">Node</code> class to store the height of the subtree rooted by it:</p><div class="informalexample"><pre class="programlisting">public class AVLTree&lt;E extends Comparable&lt;E&gt;&gt; 
          extends BinarySearchTree&lt;E&gt;{
    public static class Node&lt;E extends Comparable&lt;E&gt;&gt; 
              extends BinaryTree.Node{
        protected int height = 0;
        public Node(BinaryTree.Node parent,
                    BinaryTree containerTree, E value) {
            super(parent, containerTree, value);
        }
    }</pre></div><p class="calibre8">We must <a id="id385" class="calibre1"/>override the <code class="email">newNode</code> method to return<a id="id386" class="calibre1"/> our extended node:</p><div class="informalexample"><pre class="programlisting">    @Override
    protected BinaryTree.Node&lt;E&gt; newNode(
      BinaryTree.Node&lt;E&gt; parent, BinaryTree&lt;E&gt; containerTree, E value) {
        return new Node(parent, containerTree, value);
    }</pre></div><p class="calibre8">We use a utility method to retrieve the height of a subtree with a null check. The height of a null subtree is zero:</p><div class="informalexample"><pre class="programlisting">    private int nullSafeHeight(Node&lt;E&gt; node){
        if(node==null){
            return 0;
        }else{
            return node.height;
        }
    }</pre></div><p class="calibre8">First, we include a method to compute and update the height of the subtree rooted by a node. The height is one more than that of the maximum height of its children:</p><div class="informalexample"><pre class="programlisting">    private void nullSafeComputeHeight(Node&lt;E&gt; node){
        Node&lt;E&gt; left = (Node&lt;E&gt;) node.getLeft();
        Node&lt;E&gt; right = (Node&lt;E&gt;) node.getRight();
        int leftHeight = left==null? 0 : left.height;
        int rightHeight = right==null? 0 :right.height;
        node.height =  Math.max(leftHeight, rightHeight)+1;
    }</pre></div><p class="calibre8">We also override the <code class="email">rotate</code> method in <code class="email">BinaryTree</code> to update the height of the subtrees after the rotation:</p><div class="informalexample"><pre class="programlisting">    @Override
    protected void rotate(BinaryTree.Node&lt;E&gt; node, boolean left) {
        Node&lt;E&gt; n = (Node&lt;E&gt;) node;
        Node&lt;E&gt; child;
        if(left){
            child = (Node&lt;E&gt;) n.getRight();
        }else{
            child = (Node&lt;E&gt;) n.getLeft();
        }
        super.rotate(node, left);
        if(node!=null){
            nullSafeComputeHeight(n);
        }
        if(child!=null){
            nullSafeComputeHeight(child);
        }
    }</pre></div><p class="calibre8">With the help<a id="id387" class="calibre1"/> of these methods, we implement the<a id="id388" class="calibre1"/> rebalancing of a node all the way up to the root, as described in the preceding code. The rebalancing bit is done by checking the difference in the height of the left and right subtrees. If the difference is 0, 1, or -1, nothing needs to be done. We simply move up the tree recursively. When the height difference is 2 or -2, this is when we need to rebalance:</p><div class="informalexample"><pre class="programlisting">    protected void rebalance(Node&lt;E&gt; node){
        if(node==null){
            return;
        }
        nullSafeComputeHeight(node);
        int leftHeight = nullSafeHeight((Node&lt;E&gt;) node.getLeft());
        int rightHeight = nullSafeHeight((Node&lt;E&gt;) node.getRight());
        switch (leftHeight-rightHeight){
            case -1:
            case 0:
            case 1:
                rebalance((Node&lt;E&gt;) node.getParent());
                break;
            case 2:
                int childLeftHeight = nullSafeHeight(
                        (Node&lt;E&gt;) node.getLeft().getLeft());
                int childRightHeight = nullSafeHeight(
                        (Node&lt;E&gt;) node.getLeft().getRight());
                if(childRightHeight &gt; childLeftHeight){
                    rotate(node.getLeft(), true);
                }
                Node&lt;E&gt; oldParent = (Node&lt;E&gt;) node.getParent();
                rotate(node, false);
                rebalance(oldParent);
                break;
            case -2:
                childLeftHeight = nullSafeHeight(
                        (Node&lt;E&gt;) node.getRight().getLeft());
                childRightHeight = nullSafeHeight(
                        (Node&lt;E&gt;) node.getRight().getRight());
                if(childLeftHeight &gt; childRightHeight){
                    rotate(node.getRight(), false);
                }
                oldParent = (Node&lt;E&gt;) node.getParent();
                rotate(node, true);
                rebalance(oldParent);
                break;
        }
    }</pre></div><p class="calibre8">Once the<a id="id389" class="calibre1"/> rotation is implemented, implementing the<a id="id390" class="calibre1"/> insert and delete operations is very simple. We first do a regular insertion or deletion, followed by rebalancing. A simple insertion operation is as follows:</p><div class="informalexample"><pre class="programlisting">  @Override
    public BinaryTree.Node&lt;E&gt; insertValue(E value) {
        Node&lt;E&gt; node = (Node&lt;E&gt;) super.insertValue(value);
        if(node!=null)
            rebalance(node);
            return node;
    }</pre></div><p class="calibre8">The delete operation is also very similar. It only requires an additional check confirming that the node is actually found and deleted:</p><div class="informalexample"><pre class="programlisting">@Override
    public BinaryTree.Node&lt;E&gt; deleteValue(E value) {
        Node&lt;E&gt; node = (Node&lt;E&gt;) super.deleteValue(value);
        if(node==null){
            return null;
        }
        Node&lt;E&gt; parentNode = (Node&lt;E&gt;) node.getParent();
        rebalance(parentNode);
        return node;
    }</pre></div><div class="book" title="Complexity of search, insert, and delete in an AVL tree"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec18" class="calibre1"/>Complexity of search, insert, and delete in an AVL tree</h3></div></div></div><p class="calibre8">The worst <a id="id391" class="calibre1"/>case of an AVL tree is when it has maximum imbalance. In <a id="id392" class="calibre1"/>other words, the tree is worst when it reaches its maximum height for a given number of nodes. To find out how much that is, we need to ask the<a id="id393" class="calibre1"/> question differently, given a height h: what is the<a id="id394" class="calibre1"/> minimum number of nodes (n) that can achieve this? Let the minimum number of nodes required to achieve this be <span class="strong"><em class="calibre12">f(h)</em></span>. A tree of height <span class="strong"><em class="calibre12">h</em></span> will have two subtrees, and without any loss of generality, we can assume that the left subtree is higher than the right subtree. We would like both these subtrees to also have a minimum number of nodes. So the height of the left subtree would be <span class="strong"><em class="calibre12">f(h-1)</em></span>. We want the height of the right subtree to be minimum, as this would not affect the height of the entire tree. However, in an AVL tree, the difference between the heights of two subtrees at the same level can differ by a maximum of one. The height of this subtree is <span class="strong"><em class="calibre12">h-2</em></span>. So the number of nodes in the right subtree is <span class="strong"><em class="calibre12">f(h-2)</em></span>. The entire tree must also have a root, hence the total number of nodes:</p><div class="informalexample"><pre class="programlisting">f(h) = f(h-1) + f(h-2) + 1</pre></div><p class="calibre8">It almost looks like the formula of the Fibonacci sequence, except for the <span class="strong"><em class="calibre12">+1</em></span> part. Our starting values are 1 and 2 because <span class="strong"><em class="calibre12">f(1) = 1</em></span> (only the root) and <span class="strong"><em class="calibre12">f(2) = 2</em></span> (just one child). This is greater than the starting values of the Fibonacci sequence, which are 1 and 1. One thing is of course clear that the number of nodes would be greater than the corresponding Fibonacci number. So, the following is the case:</p><div class="informalexample"><pre class="programlisting">f(h) ≥ F<sub class="calibre16">h</sub> where F<sub class="calibre16">h</sub> is the h<sup class="calibre14">th</sup> Fibonacci number.</pre></div><p class="calibre8">We know that for a large enough <span class="strong"><em class="calibre12">h</em></span>, <span class="strong"><em class="calibre12">F</em></span>
<sub class="calibre16">h</sub><span class="strong"><em class="calibre12"> ≈ φF</em></span>
<sub class="calibre16">h-1</sub> holds true; here <span class="strong"><em class="calibre12">φ</em></span> is the golden ratio <span class="strong"><em class="calibre12">(1 + √5)/2</em></span>. This means <span class="strong"><em class="calibre12">F</em></span>
<sub class="calibre16">h</sub><span class="strong"><em class="calibre12"> = C φ </em></span>
<sup class="calibre14">h</sup>, where C is some constant. So, we have the following:</p><div class="informalexample"><pre class="programlisting">f(h) ≥ C φ <sup class="calibre14">h</sup>
=&gt;n ≥ C  φ <sup class="calibre14">h</sup>
=&gt; log <sub class="calibre16">φ</sub>n ≥  h +  log <sub class="calibre16">φ</sub> C
=&gt; h = O(  log <sub class="calibre16">φ</sub>n) = O(lg n)</pre></div><p class="calibre8">This means even the worst height of an AVL tree is logarithmic, which is what we wanted. Since an insertion processes one node in each level until it reaches the insertion site, the complexity of an insertion is <span class="strong"><em class="calibre12">O(lg n)</em></span>; it is the same for performing search and delete operations, and it holds true for the same reason.</p></div></div></div>

<div class="book" title="Red-black tree"><div class="book" id="1FLS42-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec43" class="calibre1"/>Red-black tree</h1></div></div></div><p class="calibre8">An AVL tree guarantees logarithmic insertion, deletion, and search. But it makes a lot of rotations. In <a id="id395" class="calibre1"/>most applications, insertions are randomly ordered and so are deletions. So, the trees would sort of balance out eventually. However, since the AVL tree is too quick to rotate, it may make very frequent rotations in opposite directions even when it would be unnecessary, had it been waiting for the future values to be inserted. This can be avoided using a different approach: knowing when to rotate a subtree. This approach is called a red-black tree.</p><p class="calibre8">In a red-black tree, the nodes have a color, either black or red. The colors can be switched during the operations on the node, but they have to follow these conditions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The root has to be black</li><li class="listitem">A red node cannot have a black child</li><li class="listitem">The black height of any subtree rooted by any node is equal to the black height of the subtree rooted by the sibling node</li></ul></div><p class="calibre8">Now what is the black height of a subtree? It is the number of black nodes found from the root to the leaf. When we say <span class="strong"><em class="calibre12">leaf</em></span>, we really mean null children, which are considered black and allow a parent to be red without violating rule 2. This is the same no matter which path we take. This is because of the third condition. So the third condition can also be restated as this: the number of black nodes in the path from the root of any subtree to any of its leaves is the same, irrespective of which leave we choose.</p><p class="calibre8">For ease of manipulation, the null children of the leaves are also considered sort of half nodes; null children are always considered black and are the only ones really considered as leaves as well. So leaves don't contain any value. But they are different from the conventional leaves in other red-black trees. New nodes can be added to the leaves but not in a red-black tree; this is because the leaves here are null nodes. So we will not draw them out explicitly or put them in the code. They are only helpful to compute and match black heights:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Red-black tree" class="calibre9"/><div class="caption"><p class="calibre15">An example of a red-black tree</p></div></div><p class="calibre10"> </p><p class="calibre8">In our example <a id="id396" class="calibre1"/>of the red-black tree of height 4, the null nodes are black, which are not shown (in print copy, the light-colored or gray nodes are red nodes and dark-colored nodes are black nodes).</p><p class="calibre8">Both insertion and deletion are more complicated than the AVL tree, as there are more cases that we need to handle. We will discuss this in the following sections.</p></div>

<div class="book" title="Red-black tree">
<div class="book" title="Insertion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec55" class="calibre1"/>Insertion</h2></div></div></div><p class="calibre8">Insertion is <a id="id397" class="calibre1"/>done in the same way we do it with BST. After an insertion is complete, the new node is colored red. This preserves the black height, but it can result in a red node being a child of another red node, which would violate condition 2. So we do some manipulation to fix this. The following two figures show four cases of insertions:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Insertion" class="calibre9"/><div class="caption"><p class="calibre15">Case 1 and 2 of red-black tree insertion</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Insertion" class="calibre9"/><div class="caption"><p class="calibre15">Case 3 and 4 of red-black tree insertion</p></div></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">Let's discuss<a id="id398" class="calibre1"/> the insertions case by case. Notice that the trees in the diagram look black and unbalanced. But this is only because we have not drawn the entire tree; it's just a part of the tree we are interested in. The important point is that the black height of none of the nodes change because of whatever we do. If the black height must be increased to fit the new node, it must be at the top level; so we simply move it up to the parent. The four cases are as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The parent is black. In this case, nothing needs to be done as it does not violate any of the constraints.</li><li class="listitem" value="2">Both parent and uncle are red. In this case, we repaint parent, uncle, and grandparent and the black heights are still unchanged. Notice now that no constraints are violated. If, however, the grandparent is the root, keep it black. This way, the entire tree's black height is increased by 1.</li><li class="listitem" value="3">The parent is red and uncle is black. The newly added node is on the same side of the parent as the parent is of the grandparent. In this case, we make a rotation and repaint. We first repaint the parent and grandparent and then rotate the grandparent.</li><li class="listitem" value="4">This is the case that is similar to case 3, except the newly added node is on the opposite side of the parent as the parent is of the grandparent. Case 3 cannot be applied here because doing so will change the black height of the newly added node. In this case, we rotate the parent to make it the same as case 3.</li><li class="listitem" value="5">Note that all the cases can happen in the opposite direction, that is, in mirror image. We will handle both the cases the same way.</li></ol><div class="calibre13"/></div><p class="calibre8">Let's create<a id="id399" class="calibre1"/> our <code class="email">RedBlackTree</code> class extending the <code class="email">BinarySearchTree</code> class. We have to again extend the <code class="email">Node</code> class and include a flag to know whether the node is black:</p><div class="informalexample"><pre class="programlisting">public class RedBlackTree&lt;E extends Comparable&lt;E&gt;&gt; extends BinarySearchTree&lt;E&gt;{
    public static class Node&lt;E&gt; extends BinaryTree.Node&lt;E&gt;{
        protected int blackHeight = 0;
        protected boolean black = false;
        public Node(BinaryTree.Node parent,
                    BinaryTree containerTree, E value) {
            super(parent, containerTree, value);
        }
    }

    @Override
    protected  BinaryTree.Node&lt;E&gt; newNode(
      BinaryTree.Node&lt;E&gt; parent, BinaryTree&lt;E&gt; containerTree, E value) {
        return new Node(parent, containerTree, value);
    }
...
}</pre></div><p class="calibre8">We now add a utility method that returns whether a node is black. As explained earlier, a null node is considered black:</p><div class="informalexample"><pre class="programlisting">    protected boolean nullSafeBlack(Node&lt;E&gt; node){
        if(node == null){
            return true;
        }else{
            return node.black;
        }
    }</pre></div><p class="calibre8">Now we're ready to define the method of rebalancing after we do an insertion. This method works as described in the four cases earlier. We maintain a <code class="email">nodeLeftGrandChild</code> flag that stores whether the parent is the left child of the grand parent or its right <a id="id400" class="calibre1"/>child. This helps us find the uncle and also rotate in the correct direction:</p><div class="informalexample"><pre class="programlisting">    protected void rebalanceForInsert(Node&lt;E&gt; node){
        if(node.getParent() == null){
            node.black = true;
        }else{
            Node&lt;E&gt; parent = (Node&lt;E&gt;) node.getParent();
            if(parent.black){
                return;
            }else{
                Node&lt;E&gt; grandParent = (Node&lt;E&gt;) parent.getParent();
                boolean nodeLeftGrandChild = grandParent.getLeft()== parent;

                Node&lt;E&gt; uncle = nodeLeftGrandChild?
                  (Node&lt;E&gt;) grandParent.getRight()
                  : (Node&lt;E&gt;) grandParent.getLeft();
                if(!nullSafeBlack(uncle)){
                    if(grandParent!=root)
                        grandParent.black = false;
                        uncle.black = true;
                        parent.black = true;
                        rebalanceForInsert(grandParent);
                }else{
                    boolean middleChild = nodeLeftGrandChild?
                      parent.getRight() == node:parent.getLeft() == node;
                    if (middleChild){
                        rotate(parent, nodeLeftGrandChild);
                        node = parent;
                        parent = (Node&lt;E&gt;) node.getParent();
                    }
                    parent.black = true;
                    grandParent.black = false;
                    rotate(grandParent, !nodeLeftGrandChild);
                }
            }

        }
    }</pre></div><p class="calibre8">The insertion<a id="id401" class="calibre1"/> is now done as follows:</p><div class="informalexample"><pre class="programlisting">    @Override
    public BinaryTree.Node&lt;E&gt; insertValue(E value) {
        Node&lt;E&gt; node = (Node&lt;E&gt;) super.insertValue(value);
        if(node!=null)
            rebalanceForInsert(node);
        return node;
    }</pre></div></div></div>

<div class="book" title="Red-black tree">
<div class="book" title="Deletion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec56" class="calibre1"/>Deletion</h2></div></div></div><p class="calibre8">Deletion starts <a id="id402" class="calibre1"/>with a normal binary search tree deletion. If you remember, this always involves deletion of a node with at most one child. Deletion of an internal node is done by first copying the value of the leftmost node of the right subtree and deleting it. So we will consider only this case:</p><div class="mediaobject"><img src="../images/00058.jpeg" alt="Deletion" class="calibre9"/><div class="caption"><p class="calibre15">Case 1, 2, and 3 of deletion in a red-black tree</p></div></div><p class="calibre10"> </p><p class="calibre8">After the<a id="id403" class="calibre1"/> deletion is done, the parent of the deleted node either has no child or has one child, which was originally its grandchild. During the insertion, the problem we needed to solve was a red child of a red parent. In a deletion process, this cannot happen. But it can cause the black height to change.</p><p class="calibre8">One simple case is that if we delete a red node, the black height does not change anything, so we don't have to do anything. Another simple case is that if the deleted node were black and the child red, we can simply repaint the child black in order to restore the black height.</p><p class="calibre8">A black child <a id="id404" class="calibre1"/>cannot really happen because that would mean the original tree was black and unbalanced, as the deleted node had a single black child. But since recursion is involved, a black child can actually arise while moving up the path with recursive rebalancing. In the following discussion, we only look at cases where the deleted node was black and the child was also black (or null child, which is considered black). Deletion is done as per the following cases, as shown in the figures <span class="strong"><em class="calibre12">Case 1 and 2 and 3 of deletion in a red-black tree</em></span> and <span class="strong"><em class="calibre12">Case 4, 5 and 6 of deletion from a red-black tree</em></span>:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The first case we have is when the parent, sibling, and both the nephews are black. In this case, we can simply repaint the sibling to red, which will make the parent black and balanced. However, the black height of the whole subtree will reduce by one; hence, we must continue rebalancing from the parent.</li><li class="listitem" value="2">This is the case when the parent and sibling are black, but the away nephew is red. In this case, we cannot repaint the sibling as this would cause the red sibling to have a red child, violating constraint 2. So we first repaint the red nephew to black and then rotate to fix the black height of the nephew while fixing the black height of the child.</li><li class="listitem" value="3">When the near nephew is red instead of the away nephew, the rotation does not restore the black height of the near nephew that has been repainted. So, we repaint NN but do a double rotation instead.</li><li class="listitem" value="4">Now consider what happens when the sibling is red. We first repaint the parent and sibling using opposite colors and rotating P. But this does not change the black height of any node; it reduces the case to case 5 or 6, which we will discuss now. So we simply call the rebalancing code again recursively.</li><li class="listitem" value="5">We are now done with all the cases where the parent was black. This is a case where the parent is red. In this case, we consider the near nephew to be black. Simply rotating the parent fixes the black height.</li><li class="listitem" value="6">Our final case is when the parent is red and the near nephew is red. In this case, we recolor the parent and do a double rotation. Notice that the top node remains red. This is not a problem because the original top node, which is the parent node, was also red and hence its parent must be black.<div class="mediaobject"><img src="../images/00059.jpeg" alt="Deletion" class="calibre9"/><div class="caption"><p class="calibre15">Case 4, 5, and 6 of deletion from a red-black tree</p></div></div><p class="calibre26"> </p></li></ol><div class="calibre13"/></div><p class="calibre8">Now we can <a id="id405" class="calibre1"/>define the <code class="email">rebalanceForDelete</code> method coding all the preceding cases:</p><div class="informalexample"><pre class="programlisting">    protected void rebalanceForDelete(Node&lt;E&gt; parent, boolean nodeDirectionLeft){
        if(parent==null){
            return;
        }
        Node&lt;E&gt; node = (Node&lt;E&gt;) (nodeDirectionLeft? parent.getLeft(): parent.getRight());
        if(!nullSafeBlack(node)){
            node.black = true;
            return;
        }

        Node&lt;E&gt; sibling = (Node&lt;E&gt;) (nodeDirectionLeft? parent.getRight(): parent.getLeft());


        Node&lt;E&gt; nearNephew = (Node&lt;E&gt;) (nodeDirectionLeft?sibling.getLeft():sibling.getRight());

        Node&lt;E&gt; awayNephew = (Node&lt;E&gt;) (nodeDirectionLeft?sibling.getRight():sibling.getLeft());

        if(parent.black){
            if(sibling.black){
                if(nullSafeBlack(nearNephew) &amp;&amp; nullSafeBlack(awayNephew)){
                    sibling.black = false;
                    if(parent.getParent()!=null){
                        rebalanceForDelete (
                          (Node&lt;E&gt;) parent.getParent(),
                          parent.getParent().getLeft() == parent);
                    }
                }else if(!nullSafeBlack(awayNephew)){
                    awayNephew.black = true;
                    rotate(parent, nodeDirectionLeft);
                }else{
                    nearNephew.black = true;
                    rotate(sibling, !nodeDirectionLeft);
                    rotate(parent, nodeDirectionLeft);
                }

            }else{
                parent.black = false;
                sibling.black = true;
                rotate(parent, nodeDirectionLeft);
                rebalanceForDelete(parent, nodeDirectionLeft);
            }
        }else{

            if(nullSafeBlack(nearNephew)){
                rotate(parent, nodeDirectionLeft);
            }else{
                parent.black = true;
                rotate(sibling, !nodeDirectionLeft);
                rotate(parent, nodeDirectionLeft);
            }
        }

    }</pre></div><p class="calibre8">Now we override the <code class="email">deleteValue</code> method to invoke rebalancing after the deletion. We only need to rebalance if the deleted node was black. We first check that. Then, we need to figure out<a id="id406" class="calibre1"/> whether the deleted child was a left child of the parent or the right child. After that, we can invoke the <code class="email">rebalanceForDelete</code> method:</p><div class="informalexample"><pre class="programlisting">    @Override
    public BinaryTree.Node&lt;E&gt; deleteValue(E value) {
        Node&lt;E&gt; node = (Node&lt;E&gt;) super.deleteValue(value);

        if(node !=null &amp;&amp; node.black &amp;&amp; node.getParent()!=null){
            Node&lt;E&gt; parentsCurrentChild = (Node&lt;E&gt;) (node.getLeft() == null ? node.getRight(): node.getLeft());
            if(parentsCurrentChild!=null){
                boolean isLeftChild = parentsCurrentChild.getParent().getLeft() == parentsCurrentChild;
                rebalanceForDelete(                         (Node&lt;E&gt;) node.getParent(), isLeftChild);
            }else{
                boolean isLeftChild = node.getParent().getRight()!=null;
                rebalanceForDelete(
                        (Node&lt;E&gt;) node.getParent(), isLeftChild);
            }

        }
        return node;
    }</pre></div></div></div>

<div class="book" title="Red-black tree">
<div class="book" title="The worst case of a red-black tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec57" class="calibre1"/>The worst case of a red-black tree</h2></div></div></div><p class="calibre8">What is the worst possible red-black tree? We try to find out the same way we did in the case of the AVL tree. This one is a little more complicated, though. To understand the worst tree, we must<a id="id407" class="calibre1"/> take into account the black height. To fit the minimum number of nodes n into height h, we need to first choose a black height. Now it is desirable to have as few black nodes as possible so that we don't have to include black nodes for balancing the black height in the siblings of the nodes we are trying to stretch the height with. Since a red node cannot be the parent of another, we must have alternate black nodes. We consider height <span class="strong"><em class="calibre12">h</em></span> and an even number so that the black height is <span class="strong"><em class="calibre12">h/2 = l</em></span>. For simplicity, we don't count the black null nodes for either the height or the black height. The next figure shows some examples of the worst trees:</p><div class="mediaobject"><img src="../images/00060.jpeg" alt="The worst case of a red-black tree" class="calibre9"/><div class="caption"><p class="calibre15">Worst red-black trees</p></div></div><p class="calibre10"> </p><p class="calibre8">The general idea is, of course, to have one path with the maximum possible height. This path should be stuffed with the maximum number of red nodes and the other paths filled with the least number of nodes, that is, with only black nodes. The general idea is shown in the next figure.</p><p class="calibre8">The number<a id="id408" class="calibre1"/> of nodes in a full black tree of height <span class="strong"><em class="calibre12">l-1</em></span> is of course <span class="strong"><em class="calibre12">2</em></span>
<sup class="calibre14">l-1</sup><span class="strong"><em class="calibre12"> – 1</em></span>. So, if the number of nodes for height <span class="strong"><em class="calibre12">h = 2l</em></span> is <span class="strong"><em class="calibre12">f(l)</em></span>, then we have the recursive formula:</p><div class="informalexample"><pre class="programlisting">f(l) = f(l-1) + 2 ( 2l-1 – 1) + 2
=&gt; f(l) = f(l-1) + 2l</pre></div><p class="calibre8">Now, from the preceding figure, we can already see that <span class="strong"><em class="calibre12">f(1) = 2</em></span>, <span class="strong"><em class="calibre12">f(2) = 6</em></span>, and <span class="strong"><em class="calibre12">f(3) = 14</em></span>. It looks like the formula should be <span class="strong"><em class="calibre12">f(l) = 2</em></span>
<sup class="calibre14">l-1</sup><span class="strong"><em class="calibre12"> -2</em></span>. We already have the base cases. If we can prove that if the formula is true for l, then it is also true for <span class="strong"><em class="calibre12">l+1</em></span>, we would be able to prove the formula for all <span class="strong"><em class="calibre12">l</em></span> by induction. This is what we will try to do:</p><div class="mediaobject"><img src="../images/00061.jpeg" alt="The worst case of a red-black tree" class="calibre9"/><div class="caption"><p class="calibre15">General idea of the worst red-black tree</p></div></div><p class="calibre10"> </p><p class="calibre8">We already have <span class="strong"><em class="calibre12">f(l+1) = f(l) + 2l+1</em></span> and we also assume <span class="strong"><em class="calibre12">f(l) = 2l+1-2</em></span>. So this is the case: <span class="strong"><em class="calibre12">f(l+1) = 2l+1-2 +  2l+1 =  2l+2-2</em></span>. Hence, if the formula holds true for <span class="strong"><em class="calibre12">l</em></span>, it also holds true for <span class="strong"><em class="calibre12">l+1</em></span>; therefore, it is proved by induction.</p><p class="calibre8">So the minimum number of nodes is as follows:</p><div class="informalexample"><pre class="programlisting">n = f(l) =  2l+2-2. 
=&gt; lg n = lg ( 2l+2-2)   
=&gt; lg n &gt;  lg ( 2l+1)
=&gt; lg n &gt; l+1
=&gt; l + 1&lt; lg n
=&gt; l &lt; lg n
=&gt; l = O (lg n)</pre></div><p class="calibre8">Therefore, a red-black tree has a guaranteed logarithmic height; from this, it is not hard to derive that the<a id="id409" class="calibre1"/> search, insertion, and deletion operations are all logarithmic.</p></div></div>

<div class="book" title="Hash tables"><div class="book" id="1GKCM2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec44" class="calibre1"/>Hash tables</h1></div></div></div><p class="calibre8">A hash table is a<a id="id410" class="calibre1"/> completely different kind of searchable structure. The idea<a id="id411" class="calibre1"/> starts from what is called a hash function. It is a function that gives an integer for any value of the desired type. For example, the hash function for strings must return an integer for every string. Java requires every class to have a <code class="email">hashcode()</code> method. The object class has one method implemented by default, but we must override the default implementation whenever we override the <code class="email">equals</code> method. The <a id="id412" class="calibre1"/>hash function holds the following properties:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Same values must always return the same hash value. This is called consistency of the hash. In Java, this means if <code class="email">x</code> and <code class="email">y</code> are two objects and <code class="email">x.equals(y)</code> is <code class="email">true</code>, then <code class="email">x.hashcode() == y.hashcode()</code>.</li><li class="listitem">Different values may return the same hash, but it is preferred that they don't.</li><li class="listitem">The hash function is computable in constant time.</li></ul></div><p class="calibre8">A perfect hash function will always provide a different hash value for different values. However, such a hash function cannot be computed in constant time in general. So, we normally resort to generating hash values that look seemingly random but are really complicated functions of the value itself. For example, <code class="email">hashcode</code> of the <code class="email">String</code> class looks like this:</p><div class="informalexample"><pre class="programlisting">public int hashCode() {
    int h = hash;
     if (h == 0 &amp;&amp; value.length &gt; 0) {
        char val[] = value;

        for (int i = 0; i &lt; value.length; i++) {
            h = 31 * h + val[i];
        }
         hash = h;
    }
    return h;
}</pre></div><p class="calibre8">Notice that it is a <a id="id413" class="calibre1"/>complicated function that is computed from constituent characters.</p><p class="calibre8">A hash table keeps an array of buckets indexed by the hash code. The bucket can have many kinds of data structures, but here, we will use a linked list. This makes it possible to jump to a certain bucket in constant time and then the bucket is kept small enough so that the search within the bucket, even a linear search, will not cost that much.</p><p class="calibre8">Let's create a skeleton class for our hash table:</p><div class="informalexample"><pre class="programlisting">public class HashTable&lt;E&gt; {
    protected LinkedList&lt;E&gt; [] buckets;
    protected double maximumLoadFactor;
    protected int totalValues;
    public HashTable(int initialSize, double maximumLoadFactor){
        buckets = new LinkedList[initialSize];
        this.maximumLoadFactor = maximumLoadFactor;
    }
    …
}</pre></div><p class="calibre8">We accept two parameters. <code class="email">InitialSize</code> is the initial number of buckets we want to start with, and our second parameter is the maximum load factor.</p><p class="calibre8">What is load factor? Load factor is the average number of values per bucket. If the number of buckets is <span class="strong"><em class="calibre12">k</em></span> and the total number of values in it is <span class="strong"><em class="calibre12">n</em></span>, then load factor is <span class="strong"><em class="calibre12">n/k</em></span>.</p></div>

<div class="book" title="Hash tables">
<div class="book" title="Insertion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec58" class="calibre1"/>Insertion</h2></div></div></div><p class="calibre8">Insertion is<a id="id414" class="calibre1"/> done by first computing the hash and picking up the bucket in that index. Now firstly, the bucket is searched linearly for the value. If the value is found, insertion is not carried out; otherwise, the new value is added to the end of the bucket.</p><p class="calibre8">First we create a function for inserting in a given array of buckets and then using it to perform the <a id="id415" class="calibre1"/>insertion. This would be useful when you are dynamically growing your hash table:</p><div class="informalexample"><pre class="programlisting">    protected boolean insert(E value, int arrayLength,
                             LinkedList&lt;E&gt;[] array) {
        int hashCode = value.hashCode();
        int arrayIndex = hashCode % arrayLength;
        LinkedList&lt;E&gt; bucket = array[arrayIndex];
        if(bucket == null){
            bucket = new LinkedList&lt;&gt;();
            array[arrayIndex] = bucket;
        }
        for(E element: bucket){
            if(element.equals(value)){
                return false;
            }
        }
        bucket.appendLast(value);
        totalValues++;
        return true;
    }</pre></div><p class="calibre8">Note that effective hash code is computed by taking the remainder of the actual hash code divided by the number of buckets. This is done to limit the number of hash code.</p><p class="calibre8">There is one more thing to be done here and that is rehashing. Rehashing is the process of dynamically growing the hash table as soon as it exceeds a predefined load factor (or in some cases due to other conditions, but we will use load factor in this text). Rehashing is done by creating a second array of buckets of a bigger size and copying each element to the new set of buckets. Now the old array of buckets is discarded. We create this function as follows:</p><div class="informalexample"><pre class="programlisting">    protected void rehash(){
        double loadFactor = ((double)(totalValues))/buckets.length;
        if(loadFactor&gt;maximumLoadFactor){
            LinkedList&lt;E&gt; [] newBuckets = new LinkedList[buckets.length*2];
            totalValues = 0;
            for(LinkedList&lt;E&gt; bucket:buckets){
                if(bucket!=null) {
                    for (E element : bucket) {
                        insert(element, newBuckets.length, newBuckets);
                    }
                }
            }
            this.buckets = newBuckets;
        }
    }</pre></div><p class="calibre8">Now we can <a id="id416" class="calibre1"/>have our completed <code class="email">insert</code> function for a value:</p><div class="informalexample"><pre class="programlisting">    public boolean insert(E value){
        int arrayLength = buckets.length;
        LinkedList&lt;E&gt;[] array = buckets;
        boolean inserted = insert(value, arrayLength, array);
        if(inserted)
            rehash();
        return inserted;
    }</pre></div><div class="book" title="The complexity of insertion"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec19" class="calibre1"/>The complexity of insertion</h3></div></div></div><p class="calibre8">It is easy to <a id="id417" class="calibre1"/>see that the insert operation is almost constant time unless we have to rehash it; in this case, it is <span class="strong"><em class="calibre12">O(n)</em></span>. So how many times do we have to rehash it? Suppose the load factor is <span class="strong"><em class="calibre12">l</em></span> and the number of buckets is <span class="strong"><em class="calibre12">b</em></span>. Say we start from an <code class="email">initialSize</code> <span class="strong"><em class="calibre12">B</em></span>. Since we are doubling every time we rehash, the number of buckets will be <span class="strong"><em class="calibre12">b = B.2</em></span>
<sup class="calibre14">R</sup>; here <span class="strong"><em class="calibre12">R</em></span> is the number of times we rehashed. Hence, the total number of elements can be represented as this: <span class="strong"><em class="calibre12">n = bl = Bl. 2</em></span>
<span class="strong"><em class="calibre12">R</em></span>. Check this out:</p><div class="informalexample"><pre class="programlisting">lg n = R + lg(Bl) .
=&gt; R = ln n – lg (Bl) = O(lg n)</pre></div><p class="calibre8">There must be about <code class="email">lg n</code> number of rehashing operations, each with complexity of <code class="email">O(n)</code>. So the average complexity for inserting <code class="email">n</code> elements is <code class="email">O(n lg n)</code>. Hence, the average complexity for inserting each element is <code class="email">O(lg n)</code>. This, of course, would not work if the values are all clustered together in a single bucket that we are inserting into. Then, each insert would be <code class="email">O(n)</code>, which is the worst case complexity of an insertion.</p><p class="calibre8">Deletion is very similar to insertion; it involves deletion of elements from the buckets after they are searched.</p></div></div></div>

<div class="book" title="Hash tables">
<div class="book" title="Search"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec59" class="calibre1"/>Search</h2></div></div></div><p class="calibre8">Search is simple. We<a id="id418" class="calibre1"/> compute the hash code, go to the appropriate bucket, and do a linear search in the bucket:</p><div class="informalexample"><pre class="programlisting">public E search(E value){
    int hash = value.hashCode();
    int index = hash % buckets.length;
    LinkedList&lt;E&gt; bucket = buckets[index];
    if(bucket==null){
        return null;
    }else{
        for(E element: bucket){
            if(element.equals(value)){
                return element;
            }
        }
        return null;
    }
}</pre></div><div class="book" title="Complexity of the search"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec20" class="calibre1"/>Complexity of the search</h3></div></div></div><p class="calibre8">The complexity <a id="id419" class="calibre1"/>of the search operation is constant time if the values are evenly distributed. This is because in this case, the number of elements per bucket would be less than or equal to the load factor. However, if all the values are in the same bucket, search is reduced to a linear search and it is <span class="strong"><em class="calibre12">O(n)</em></span>. So the worst case is linear. The average case of search is constant time in most cases, which is better than that of binary search trees.</p></div></div></div>

<div class="book" title="Hash tables">
<div class="book" title="Choice of load factor"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec60" class="calibre1"/>Choice of load factor</h2></div></div></div><p class="calibre8">If the load factor is too big, each bucket would hold a lot of values that would output a bad linear search. But if the load factor is too small, there would be a huge number of unused buckets <a id="id420" class="calibre1"/>causing wastage of space. It is really a compromise between search time and space. It can be shown that for a uniformly distributed hash code, the fraction of buckets that are empty can be approximately expressed as e<sup class="calibre14">-l</sup>, where l is the load factor and e is the base of a natural logarithm. If we use a load factor of say 3, then the fraction of empty buckets would be approximately e<sup class="calibre14">-3</sup> = 0.0497 or 5 percent, which is not bad. In the case of a non-uniformly distributed hash code (that is, with unequal probabilities for different ranges of values of the same width), the fraction of empty buckets would always be greater. Empty buckets take up space in the array, but they do not improve the search time. Therefore, they are undesirable.</p></div></div>
<div class="book" title="Summary" id="1HIT81-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec45" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we saw a collection of searchable and modifiable data structures. All of these allowed you to insert new elements or delete elements while still remaining searchable and that too quite optimally. We saw binary search trees in which a search follows the paths of the tree from the root. Binary search trees can be modified optimally while still remaining searchable if they are of the self-balancing type. We studied two different kinds of self-balancing trees: AVL trees and red-black trees. Red-black trees are less balanced than AVL trees, but they involve a fewer number of rotations than AVL trees. In the end, we went through the hash table, which is a different kind of searchable structure. Although the worst case complexity of search or insertion is <span class="strong"><em class="calibre12">O(n)</em></span>, hash tables provide constant time search and average time insertion (<span class="strong"><em class="calibre12">O(lg n)</em></span>) in most cases. If a hash table does not keep growing, the average insertion and deletion operations will also be constant time.</p><p class="calibre8">In the next chapter, we will see some more important general purpose data structures.</p></div></body></html>