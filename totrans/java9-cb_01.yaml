- en: Installation and a Sneak Peek into Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和 Java 9 的预览
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Installing JDK 9 on Windows and setting up the PATH variable
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 JDK 9 并设置 PATH 变量
- en: Installing JDK 9 on Linux (Ubuntu, x64) and configuring the PATH variable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux（Ubuntu，x64）上安装 JDK 9 并配置 PATH 变量
- en: Compiling and running a Java application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和运行 Java 应用程序
- en: New features in Java 9
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9 的新特性
- en: Using new tools in JDK 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDK 9 中的新工具
- en: Comparing JDK 8 with JDK 9
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 JDK 8 与 JDK 9
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Every quest for learning a programming language begins with setting up the environment
    to experiment our learning. Keeping in sync with this philosophy, in this chapter,
    we will show you how to set up your development environment and then run a simple
    modular application to test our installation. After that, we'll give you an introduction
    to the new features and tools in JDK 9\. Then, we'll end the chapter with a comparison
    between the JDK 8 and JDK 9 installations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 学习任何编程语言的第一步是设置实验学习环境。与这一理念保持一致，在本章中，我们将向您展示如何设置您的开发环境，然后运行一个简单的模块化应用程序来测试我们的安装。之后，我们将向您介绍
    JDK 9 中的新特性和工具。然后，我们将以 JDK 8 和 JDK 9 安装的比较来结束本章。
- en: Installing JDK 9 on Windows and setting up the PATH variable
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 JDK 9 并设置 PATH 变量
- en: In this recipe, we will look at installing JDK on Windows and how to set up
    the `PATH` variable to be able to access the Java executables (such as `javac`,
    `java`, and `jar`, among others) from anywhere within the command shell.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨在 Windows 上安装 JDK 以及如何设置 `PATH` 变量，以便可以从命令行中的任何位置访问 Java 可执行文件（如
    `javac`、`java` 和 `jar` 等）。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Visit [https://jdk9.java.net/download/](http://jdk.java.net/9/) and accept
    the early adopter license agreement, which looks like this:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://jdk9.java.net/download/](http://jdk.java.net/9/) 并接受早期采用者许可协议，它看起来像这样：
- en: '![](img/364e286c-924b-4f24-96dd-67fc0f0fa569.png)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/364e286c-924b-4f24-96dd-67fc0f0fa569.png)'
- en: 'After accepting the license, you will get a grid of the available JDK bundles
    based on the OS and architecture (32/64 bit), as shown here:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受许可后，您将看到一个基于操作系统和架构（32/64 位）的可用 JDK 打包网格，如下所示：
- en: '![](img/0f718e54-83fe-4500-8dca-64cbee4714e7.png)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/0f718e54-83fe-4500-8dca-64cbee4714e7.png)'
- en: Click to download the relevant JDK executable (`.exe`) for your Windows platform.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载适用于您的 Windows 平台的相应 JDK 可执行文件（`.exe`）。
- en: Run the JDK executable (`.exe`) and follow the onscreen instructions to install
    JDK on your system.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 JDK 可执行文件（`.exe`）并遵循屏幕上的说明来安装 JDK 到您的系统上。
- en: If you have chosen all the defaults during the installation, you will find JDK
    installed in `C:/Program Files/Java` for 64 bit and `C:/Program Files (x86)/Java`
    for 32 bit.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在安装过程中选择了所有默认设置，您将发现在 64 位系统上 JDK 安装在 `C:/Program Files/Java`，在 32 位系统上安装在
    `C:/Program Files (x86)/Java`。
- en: Now that we have finished installing JDK, let's see how we can set the `PATH`
    variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 JDK 的安装，让我们看看如何设置 `PATH` 变量。
- en: 'The tools provided with JDK, namely `javac`, `java`, `jconsole`, and `jlink`,
    among others, are available in the bin directory of your JDK installation. There
    are two ways you could run these tools from the command prompt:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 提供的工具，包括 `javac`、`java`、`jconsole` 和 `jlink` 等，都位于 JDK 安装目录的 bin 目录中。您可以从命令提示符运行这些工具的两种方式：
- en: 'Navigate to the directory where the tools are installed and then run them,
    as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到工具安装的目录，然后按照以下方式运行它们：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Export the path to the directory so that the tools are available from any directory in
    the command prompt. To achieve this, we have to add the path to the JDK tools
    in the `PATH` environment variable. The command prompt will search for the relevant
    tool in all the locations declared in the `PATH` environment variable.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径导出到目录，以便工具可以从命令提示符中的任何目录访问。为了实现这一点，我们必须将 JDK 工具的路径添加到 `PATH` 环境变量中。命令提示符将在
    `PATH` 环境变量中声明的所有位置中搜索相关工具。
- en: 'Let''s see how you can add the JDK bin directory to the `PATH` variable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 JDK bin 目录添加到 `PATH` 变量中：
- en: 'Right click on My Computer and then click on Properties. You will see your
    system information. Search for Advanced system settings and click on it to get
    a window, as shown in the following screenshot:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“我的电脑”，然后单击“属性”。您将看到系统信息。搜索“高级系统设置”并单击它以获取以下截图所示的窗口：
- en: '![](img/efd8b32d-cb96-4eef-987e-639258678843.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efd8b32d-cb96-4eef-987e-639258678843.png)'
- en: Click on Environment Variables to view the variables defined in your system.
    You will see that there are quite a few environment variables already defined,
    as shown in the following screenshot (the variables will differ across systems;
    in the following screenshot, there are a few predefined variables and a few variables
    added by me):![](img/3575c25c-371d-486d-848a-fc4349eb22bd.png)The variables defined
    under System variables are available across all the users of the system, and those
    defined under User variables for sanaulla are available only to the user, `sanaulla`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“环境变量”以查看系统中定义的变量。您将看到已经定义了相当多的环境变量，如下面的截图所示（系统之间的变量会有所不同；在下面的截图中，有一些预定义的变量和几个我添加的变量）：![](img/3575c25c-371d-486d-848a-fc4349eb22bd.png)在系统变量下定义的变量对所有系统用户都可用，而在
    `sanaulla` 的用户变量下定义的变量仅对用户 `sanaulla` 可用。
- en: 'Click on New under User variables for <your username> to add a new variable,
    with the name `JAVA_HOME`, and its value as the location of the JDK 9 installation.
    For example, it would be `C:/Program Files/Java/jdk-9` (for 64 bit) or `C:/Program
    Files (x86)/Java/jdk-9` (for 32 bit):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<your username>` 的用户变量下点击“新建”，添加一个名为 `JAVA_HOME` 的新变量，其值为 JDK 9 安装的位置。例如，对于
    64 位系统将是 `C:/Program Files/Java/jdk-9`，对于 32 位系统将是 `C:/Program Files (x86)/Java/jdk-9`：
- en: '![](img/173219d2-184e-49f1-8835-41b2cffdebd8.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/173219d2-184e-49f1-8835-41b2cffdebd8.png)'
- en: The next step is to update the `PATH` environment variable with the location
    of the bin directory of your JDK installation (defined in the `JAVA_HOME` environment
    variable). If you already see the `PATH` variable defined in the list, then you
    need to select that variable and click on Edit. If the `PATH` variable is not
    seen, then click on New.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将 `PATH` 环境变量更新为 JDK 安装（在 `JAVA_HOME` 环境变量中定义）的 bin 目录位置。如果您已经在列表中看到了 `PATH`
    变量，则需要选择该变量并点击“编辑”。如果未看到 `PATH` 变量，则点击“新建”。
- en: 'Any of the actions in the previous step will give you a popup, as shown in
    the following screenshot (on Windows 10):'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步中的任何操作都会弹出一个窗口，如下面的截图所示（在 Windows 10 上）：
- en: '![](img/eb4dffc5-ffae-490b-8df7-1867a0afe983.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb4dffc5-ffae-490b-8df7-1867a0afe983.png)'
- en: 'The following image shows the other Windows versions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了其他 Windows 版本：
- en: '![](img/61f9e13f-1e2a-40d3-ba3b-6a32ba94a98d.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f9e13f-1e2a-40d3-ba3b-6a32ba94a98d.png)'
- en: You can either click on New in the first picture and insert the value, `%JAVA_HOME%/bin`,
    or you can append the value against the Variable value field by adding `; %JAVA_HOME%/bin`.
    The semicolon (`;`) in Windows is used to separate multiple values for a given
    variable name.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以点击第一张图中的“新建”并插入值，`%JAVA_HOME%/bin`，或者通过添加 `; %JAVA_HOME%/bin` 来追加变量值字段中的值。在
    Windows 中，分号 (`;`) 用于分隔给定变量名的多个值。
- en: After setting the values, open the command prompt and then run `javac -version`,
    and you should be able to see `javac 9-ea` as the output. If you don't see it,
    then it means that the bin directory of your JDK installation has not been correctly
    added to the `PATH` variable.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置值后，打开命令提示符，然后运行 `javac -version`，您应该能看到输出为 `javac 9-ea`。如果您看不到它，那么这意味着您的 JDK
    安装的 bin 目录尚未正确添加到 `PATH` 变量中。
- en: Installing JDK 9 on Linux (Ubuntu, x64) and configuring the PATH variable
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux (Ubuntu, x64) 上安装 JDK 9 并配置 PATH 变量
- en: In this recipe, we will look at installing JDK on Linux (Ubuntu, x64) and also
    how to configure the `PATH` variable to make the JDK tools (such as `javac`, `java`,
    `jar`, and others) available from any location within the terminal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探讨如何在 Linux (Ubuntu, x64) 上安装 JDK，以及如何配置 `PATH` 变量，以便在终端的任何位置使用 JDK
    工具（如 `javac`、`java`、`jar` 等）。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Follow the Steps 1 and 2 of the *Installing JDK 9 on Windows and setting up
    the PATH variable* recipe to reach the downloads page.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照教程 *在 Windows 上安装 JDK 9 并设置 PATH 变量* 的步骤 1 和 2，到达下载页面。
- en: Copy the download link (`tar.gz`) for the JDK for the Linux x64 platform from
    the downloads page.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载页面复制适用于 Linux x64 平台的 JDK 下载链接 (`tar.gz`)。
- en: Download the JDK by using `$> wget <copied link>`, for example, `$> wget http://download.java.net/java/jdk9/archive/180/binaries/jdk-9+180_linux-x64_bin.tar.gz`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `$> wget <copied link>` 下载 JDK，例如，`$> wget http://download.java.net/java/jdk9/archive/180/binaries/jdk-9+180_linux-x64_bin.tar.gz`。
- en: 'Once the download completes, you should have the relevant JDK available, for
    example, `jdk-9+180_linux-x64_bin.tar.gz`. You can list the contents by using
    `$> tar -tf jdk-9+180_linux-x64_bin.tar.gz`. You can even pipe it to `more` to
    paginate the output: `$> tar -tf jdk-9+180_linux-x64_bin.tar.gz | more`.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，您应该有相关的JDK可用，例如`jdk-9+180_linux-x64_bin.tar.gz`。您可以使用`$> tar -tf jdk-9+180_linux-x64_bin.tar.gz`列出内容。您甚至可以将它管道到`more`以分页显示输出：`$>
    tar -tf jdk-9+180_linux-x64_bin.tar.gz | more`。
- en: Extract the contents of the `tar.gz` file under `/usr/lib` by using `$> tar
    -xvzf jdk-9+180_linux-x64_bin.tar.gz -C /usr/lib`. This will extract the contents
    into a directory, `/usr/lib/jdk-9`. You can then list the contents of JDK 9 by
    using `$> ls /usr/lib/jdk-9`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$> tar -xvzf jdk-9+180_linux-x64_bin.tar.gz -C /usr/lib`通过在`/usr/lib`下提取`tar.gz`文件的内容。这将提取内容到一个目录，`/usr/lib/jdk-9`。然后，您可以使用`$>
    ls /usr/lib/jdk-9`列出JDK 9的内容。
- en: 'Update the `JAVA_HOME` and `PATH` variables by editing the `.bash_aliases`
    file in your Linux home directory:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑您Linux主目录下的`.bash_aliases`文件来更新`JAVA_HOME`和`PATH`变量：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Source the `.bashrc` file to apply the new aliases:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 源`.bashrc`文件以应用新别名：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the examples in this book are run against JDK installed on Linux (Ubuntu,
    x64), except for places where we have specifically mentioned that these are run
    on Windows. We have tried to provide run scripts for both platforms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都是在Linux（Ubuntu，x64）上针对安装的JDK运行的，除非我们特别指出这些是在Windows上运行的。我们已尝试为这两个平台提供运行脚本。
- en: The recipes on JavaFX are completely executed on Windows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX的菜谱在Windows上完全执行。
- en: Compiling and running a Java application
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行Java应用程序
- en: In this recipe, we will write a very simple modular `Hello world` program to
    test our JDK installation. This simple example prints `Hello world` in XML; after
    all it's the world of web services.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将编写一个非常简单的模块化`Hello world`程序来测试我们的JDK安装。这个简单的示例以XML格式打印`Hello world`；毕竟，这是网络服务的世界。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have JDK installed and the `PATH` variable updated to point to the
    JDK installation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经安装了JDK，并且将`PATH`变量更新为指向JDK安装位置。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s define the model object with the relevant properties and annotations
    that will be serialized into XML:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义具有相关属性和注释的模型对象，这些注释将被序列化为XML：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `@XmlRootElement` is used to define the root tag, `@XmlAccessorType` is
    used to define the type of source for the tag name and tag values, and `@XmlElement`
    is used to identify the sources that become the tag name and tag values in the
    XML.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@XmlRootElement`用于定义根标签，`@XmlAccessorType`用于定义标签名称和标签值的源类型，`@XmlElement`用于标识成为XML中标签名称和标签值的源：
- en: 'Now, let''s serialize an instance of the `Message` class into XML using JAXB:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用JAXB将`Message`类的实例序列化为XML：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will now create a module named `com.packt`. To create a module, we need
    to create a file named `module-info.java`, which contains the module definition. The
    module definition contains the dependencies of the module and the packages exported
    by the module to other modules:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`com.packt`的模块。要创建一个模块，我们需要创建一个名为`module-info.java`的文件，其中包含模块定义。模块定义包含模块的依赖项以及模块导出到其他模块的包：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will explain modules in detail in [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml),
    *Modular Programming*. But this example is just to give you a taste of modular
    programming and also to test your JDK installation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml)中详细解释模块，*模块化编程*。但这个例子只是为了给您一个模块化编程的尝鲜，同时也是为了测试您的JDK安装。
- en: 'The directory structure with the preceding files is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面文件的目录结构如下：
- en: '![](img/596281af-90c6-4cee-a81e-bb3a54cba9eb.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/596281af-90c6-4cee-a81e-bb3a54cba9eb.png)'
- en: 'Let''s now compile and run the code. From the directory, `hellowordxml`, create
    a new directory in which to place your compiled class files:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在编译并运行代码。从`hellowordxml`目录中，创建一个新的目录来放置您的编译后的类文件：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile the source, `HelloWorldXml.java` and `module-info.java`, into the `mods/com.packt` directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码`HelloWorldXml.java`和`module-info.java`编译到`mods/com.packt`目录中：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the compiled code by using `java --module-path mods -m com.packt/com.packt.HelloWorldXml`.
    You will see the following output:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java --module-path mods -m com.packt/com.packt.HelloWorldXml`运行编译后的代码。您将看到以下输出：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do not worry if you are not able to understand the options passed with the `java`
    or `javac` commands. You will learn about them in [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml),
    *Modular Programming*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法理解`java`或`javac`命令传递的选项，请不要担心。您将在[第3章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml)《模块化编程》中了解它们。
- en: New features in Java 9
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9的新特性
- en: 'The release of Java 9 is a milestone in the Java ecosystem. The much awaited
    modular framework developed under Project Jigsaw will be part of this Java SE
    release. Another major feature in this is the JShell tool, which is an REPL tool
    for Java. Apart from this, there are other important API changes and JVM-level
    changes to improve the performance and debuggability of the JVM. In a blog post
    ([https://blogs.oracle.com/java/jdk-9-categories](https://blogs.oracle.com/java/jdk-9-categories)),
    Yolande Poirier categorizes JDK 9 features into the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9的发布是Java生态系统中的一个里程碑。在Project Jigsaw下开发的备受期待的模块化框架将成为这个Java SE版本的一部分。另一个主要特性是JShell工具，这是一个Java的REPL工具。除此之外，还有其他重要的API更改和JVM级别的更改，以提高JVM的性能和调试性。在一篇博客文章([https://blogs.oracle.com/java/jdk-9-categories](https://blogs.oracle.com/java/jdk-9-categories))中，Yolande
    Poirier将JDK 9特性分类如下：
- en: Behind the scenes
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 背后
- en: New functionality
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新功能
- en: Specialized
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专用
- en: New standards
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新标准
- en: Housekeeping
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理工作
- en: Gone
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已消失
- en: 'The same blog post has summarized the preceding categorization into the following
    image:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同一篇博客文章将前面的分类总结成以下图像：
- en: '![](img/6de210f1-c649-46d9-9eed-ac2394a1dbe2.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6de210f1-c649-46d9-9eed-ac2394a1dbe2.png)'
- en: 'In this recipe, we will discuss a few important features of JDK 9 and, wherever
    possible, also show a small code snippet of that feature in action. Every new
    feature in JDK is introduced by means of **JDK Enhancement Proposals**, also called
    **JEPs**. More information about the different JEPs part of JDK 9 and the release
    schedule of JDK 9 can be found on the official project page:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论JDK 9的一些重要特性，并在可能的情况下，也会展示该特性的一个小代码片段。JDK中的每个新特性都是通过**JDK增强提案**（也称为**JEP**）引入的。有关JDK
    9中不同JEP的更多信息以及JDK 9的发布计划，可以在官方项目页面上找到：
- en: '[http://openjdk.java.net/projects/jdk9/](http://openjdk.java.net/projects/jdk9/).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://openjdk.java.net/projects/jdk9/](http://openjdk.java.net/projects/jdk9/)'
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We have picked a few features, which we feel are amazing and worth knowing about.
    In the following few sections, we'll briefly introduce you to those features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们挑选了一些我们认为很棒且值得了解的特性。在接下来的几个部分中，我们将简要介绍这些特性。
- en: JEP 102 -- Process API updates
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 102 -- Process API更新
- en: 'Java''s Process API has been quite primitive, with support only to launch new
    processes, redirect the processes'' output, and error streams. In this release,
    the updates to the Process API enable the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Java的Process API相当原始，仅支持启动新进程、重定向进程的输出和错误流。在这个版本中，Process API的更新使得以下功能成为可能：
- en: Get the PID of the current JVM process and any other processes spawned by the
    JVM
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前JVM进程的PID以及由JVM产生的任何其他进程的PID
- en: Enumerate the processes running in the system to get information such as PID,
    name, and resource usage
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出系统中运行的过程以获取诸如PID、名称和资源使用情况等信息
- en: Managing process trees
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理进程树
- en: Managing sub processes
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理子进程
- en: 'Let''s look at a sample code, which prints the current PID as well as the current
    process information:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例代码，该代码打印当前PID以及当前进程信息：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JEP 110 -- HTTP/2 client
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 110 -- HTTP/2客户端
- en: This feature is being included in the incubator module. This means that the
    feature is expected to change in the subsequent releases and may even be removed
    completely. So, we advise you to use this on an experimental basis.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性被包含在孵化器模块中。这意味着该特性预计在后续版本中会有所变化，甚至可能被完全删除。因此，我们建议您以实验性方式使用它。
- en: 'Java''s HTTP API has been the most primitive. Developers often resort to using
    third-party libraries, such as Apache HTTP, RESTlet, Jersey, and so on. In addition
    to this, Java''s HTTP API predates the HTTP/1.1 specification and is synchronous
    and hard to maintain. These limitations called for the need to add a new API.
    The new HTTP client API provides the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Java的HTTP API一直是最原始的。开发者经常求助于使用第三方库，例如Apache HTTP、RESTlet、Jersey等。除此之外，Java的HTTP
    API早于HTTP/1.1规范，并且是同步的，难以维护。这些限制要求添加一个新的API。新的HTTP客户端API提供了以下功能：
- en: A simple and concise API to deal with most HTTP requests
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单且简洁的API来处理大多数HTTP请求
- en: Support for HTTP/2 specification
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTP/2规范
- en: Better performance
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的性能
- en: Better security
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的安全性
- en: A few more enhancements
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些额外的增强
- en: 'Let''s see a sample code to make an HTTP GET request using the new APIs. Below
    is the module definition defined within the file `module-info.java`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例代码，使用新的 API 来进行 HTTP GET 请求。以下是在文件 `module-info.java` 中定义的模块定义：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code uses the HTTP Client API, which is part of `jdk.incubator.httpclient`
    module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 HTTP 客户端 API，它是 `jdk.incubator.httpclient` 模块的一部分：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: JEP 213 -- milling project coin
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 213 -- 磨削项目硬币
- en: 'In Java SE 7, `_` were introduced as part of the numbers, whereby a large number
    could be conveniently written by introducing `_` between the digits. This helped
    in increasing the readability of the number, for example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java SE 7 中，下划线 `_` 被引入作为数字的一部分，通过在数字之间引入 `_` 可以方便地写出大数字。这有助于提高数字的可读性，例如：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Java SE 8, the use of `_` in the variable names, as shown earlier, resulted
    in a warning, but in Java SE 9, this use results in an error, which means that
    the variables can no longer have `_` in their names.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java SE 8 中，变量名中使用 `_`，如前所述，会导致警告，但在 Java SE 9 中，这种使用会导致错误，这意味着变量名不能再包含 `_`。
- en: The other changed part of this JEP is to support private methods in interfaces.
    Java started with interfaces with absolutely no method implementations. Then,
    Java SE 8 introduced default methods that allowed interfaces to have methods with
    implementations, called default methods. So any class implementing this interface
    could choose not to override the default methods and use the implementation provided
    in the interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JEP 的另一个变化部分是支持接口中的私有方法。Java 从没有方法实现的接口开始。然后，Java SE 8 引入了默认方法，允许接口具有具有实现的方法，称为默认方法。因此，任何实现此接口的类都可以选择不覆盖默认方法，并使用接口中提供的方法实现。
- en: Java SE 9 is introducing private methods, wherein the default methods in the
    interfaces can share code between them by refactoring the common code into private
    methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 9 正在引入私有方法，其中接口中的默认方法可以通过将公共代码重构为私有方法来相互共享代码。
- en: 'Another useful feature is the allowing of effectively final variables to be
    used with try-with-resources. As of Java SE 8, we needed to declare a variable
    within the try-with-resources block, such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的特性是允许在 try-with-resources 中使用实际上是最终的变量。截至 Java SE 8，我们需要在 try-with-resources
    块内声明一个变量，如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, with Java SE 9, we can do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Java SE 9 中，我们可以做以下事情：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `conn` is effectively final; that is, it has been declared and defined
    before, and will never be reassigned during out the course of the program execution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`conn` 是实际上是最终的；也就是说，它已经在之前声明和定义，并且在程序执行过程中永远不会重新分配。
- en: 'JEP 222: jshell -- the Java shell (Read-Eval-Print Loop)'
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'JEP 222: jshell -- Java shell（读取-评估-打印循环）'
- en: You must have seen languages, such as Ruby, Scala, Groovy, Clojure, and others
    shipping with a tool, which is often called **REPL** (**Read-Eval-Print-Loop**).
    This REPL tool is extremely useful in trying out the language features. For example,
    in Scala, we can write a simple `Hello World` program as `scala> println("Hello
    World");`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定见过像 Ruby、Scala、Groovy、Clojure 等语言，它们都附带了一个工具，通常被称为 **REPL**（**读取-评估-打印-循环**）。这个
    REPL 工具在尝试语言特性时非常实用。例如，在 Scala 中，我们可以编写一个简单的 `Hello World` 程序，如下所示：`scala> println("Hello
    World");`
- en: 'Some of the advantages of the JShell REPL are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JShell REPL 的一些优点如下：
- en: Help language learners to quickly try out the language features
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助语言学习者快速尝试语言特性
- en: Help experienced developers to quickly prototype and experiment before adopting
    it in their main code base
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助经验丰富的开发者在使用主代码库之前快速原型设计和实验
- en: Java developers can now boast of an REPL
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 开发者现在可以吹嘘拥有一个 REPL
- en: 'Let''s quickly spawn our command prompts/terminals and run the JShell command,
    as shown in the following image:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速启动我们的命令提示符/终端，并运行 JShell 命令，如下面的图像所示：
- en: '![](img/93270775-b773-4add-bf2b-fe2ed3d61cef.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93270775-b773-4add-bf2b-fe2ed3d61cef.png)'
- en: There is a lot more we can do, but we will keep that for [Chapter 13](cb8070b8-52d8-4181-9644-05557d27b499.xhtml),
    *The Read-Evaluate-Print Loop (REPL) Using JShell*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做更多的事情，但我们将把那留到第 13 章，*使用 JShell 的读取-评估-打印循环（REPL）*。
- en: JEP 238 -- multi-release JAR files
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 238 -- 多版本 JAR 文件
- en: As of now, JAR files can contain classes that can only run on the Java version
    they were compiled for. To leverage the new features of the Java platform on newer
    versions, the library developers have to release a newer version of their library.
    Soon, there will be multiple versions of the library being maintained by the developers,
    which can be a nightmare. To overcome this limitation, the new feature of multirelease
    JAR files allows developers to build JAR files with different versions of class
    files for different Java versions. The following example makes it more clear.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，JAR 文件可以包含只能运行在它们编译的 Java 版本上的类。为了利用 Java 平台在较新版本上的新功能，库开发者必须发布他们库的新版本。很快，开发者将维护库的多个版本，这可能会成为一个噩梦。为了克服这一限制，多版本
    JAR 文件的新特性允许开发者构建包含不同 Java 版本类文件的不同版本的 JAR 文件。以下示例使这一点更加清晰。
- en: 'Here is an illustration of the current JAR files:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当前 JAR 文件的示例：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is how multirelease JAR files look:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是多版本 JAR 文件的外观：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding illustration, the JAR files support class files for two Java
    versions--9 and 10\. So, when the earlier JAR is executed on Java 9, the `A.class`
    under the `versions` `- 9` folder is picked for execution. On a platform that
    doesn't support multirelease JAR files, the classes under the versions directory
    are never used. So, if you run the multirelease JAR file on Java 8, it's as good
    as running a simple JAR file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，JAR 文件支持两个 Java 版本的类文件--9 和 10。因此，当较早的 JAR 文件在 Java 9 上执行时，`versions`
    `- 9` 文件夹下的 `A.class` 会被选中执行。在不支持多版本 JAR 文件的平台上，版本目录下的类永远不会被使用。所以，如果你在 Java 8
    上运行多版本 JAR 文件，它就像运行一个简单的 JAR 文件一样。
- en: JEP 266 -- more concurrency updates
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 266 -- 更多的并发更新
- en: 'In this update, a new class, `java.util.concurrent.Flow`, has been introduced,
    which has nested interfaces supporting the implementation of a publish-subscribe
    framework. The publish-subscribe framework enables developers to build components
    that can asynchronously consume a live stream of data by setting up publishers
    that produce the data and subscribers that consume the data via subscription,
    which manages them. The four new interfaces are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更新中，引入了一个新的类 `java.util.concurrent.Flow`，它包含嵌套接口，支持实现发布-订阅框架。发布-订阅框架允许开发者通过设置生产数据的发布者和通过订阅消费数据的订阅者来构建可以异步消费实时数据流组件，订阅管理这些订阅者。以下是新增加的四个接口：
- en: '`java.util.concurrent.Flow.Publisher`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Flow.Publisher`'
- en: '`java.util.concurrent.Flow.Subscriber`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Flow.Subscriber`'
- en: '`java.util.concurrent.Flow.Subscription`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Flow.Subscription`'
- en: '`java.util.concurrent.Flow.Processor` (which acts as both `Publisher` and `Subscriber`).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Flow.Processor`（它同时充当 `Publisher` 和 `Subscriber`）。'
- en: Project Jigsaw
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 Jigsaw
- en: 'The main aim of this project is to introduce the concept of modularity; support
    for creating modules in Java and then apply the same to the JDK; that is, modularize
    the JDK. Some of the benefits of modularity are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的主要目标是引入模块化的概念；在 Java 中支持创建模块，然后将这些应用到 JDK 中；也就是说，模块化 JDK。模块化的一些好处如下：
- en: 'Stronger encapsulation: The modules can access only those parts of the module
    that have been made available for use. So, the public classes in a package are
    not public unless the package is explicitly exported in the module info file.
    This encapsulation cannot be broken by using reflection (except in cases where
    the module is an open module or specific packages in the module have been made
    open).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更强的封装性：模块只能访问那些已公开供使用的模块部分。因此，除非包在模块信息文件中明确导出，否则包中的公共类不是公共的。这种封装性不能通过反射（除非模块是开放模块或模块中的特定包已被公开）来破坏。
- en: 'Clear dependencies: Modules must declare which other modules they would be
    using via the `requires` clause.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的依赖关系：模块必须通过 `requires` 子句声明它们将使用哪些其他模块。
- en: Combining modules to create a smaller runtime, which can be easily scaled to
    smaller computing devices.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块组合起来创建更小的运行时环境，这可以轻松地扩展到更小的计算设备。
- en: Make the applications more reliable by eliminating runtime errors. For example,
    you must have experienced your application failing during runtime due to missing
    classes, resulting in `ClassNotFoundException`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除运行时错误来提高应用程序的可靠性。例如，你可能经历过应用程序在运行时由于缺少类而失败，导致 `ClassNotFoundException`。
- en: 'There are various JEPs, which are part of this project, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种 JEP，它们是这个项目的一部分，如下所示：
- en: '**JEP 200 - modular JDK**: This applies the Java platform module system to
    modularize the JDK  into a set of modules that can be combined at compile time,
    build time, or runtime.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEP 200 - 模块化 JDK**：这将 Java 平台模块系统应用于模块化 JDK，使其成为一组可以在编译时、构建时或运行时组合的模块。'
- en: '**JEP 201 - modular source code**: This modularizes the JDK source code into
    modules and enhances the build tools to compile the modules.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEP 201 - 模块化源代码**：这将 JDK 源代码模块化，并增强构建工具以编译模块。'
- en: '**JEP 220 - modular runtime images**: This restructures the JDK and JRE runtime
    images to accommodate modules and to improve performance, security, and maintainability.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEP 220 - 模块化运行时图像**：这重构了 JDK 和 JRE 运行时图像以适应模块并提高性能、安全性和可维护性。'
- en: '**JEP 260 - encapsulate most internal APIs**: This allows a lot of internal
    APIs to be accessed directly or via reflection. Accessing internal APIs that are
    bound to change is quite risky. To prevent its use, they are being encapsulated
    into modules and only those internal APIs that are widely used are being made
    available until a proper API is in its place.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEP 260 - 封装大多数内部 API**：这允许许多内部 API 可以直接访问或通过反射访问。访问那些注定要改变的内部 API 风险很大。为了防止其使用，它们被封装到模块中，并且只有那些广泛使用的内部
    API 才被提供，直到合适的 API 取代它们。'
- en: '**JEP 261 - module system**: This implements the module system Java specification
    by changing the Java programming language, JVM, and other standard APIs ([http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html)).
    This includes the introduction of a new construct called module, `{ }`, with its
    supported keywords, such as `requires`, `exports`, `opens`, and `uses`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEP 261 - 模块系统**：这通过更改 Java 编程语言、JVM 和其他标准 API 来实现 Java 模块系统规范。这包括引入一个名为模块的新构造，`{
    }`，以及其支持的键词，如 `requires`、`exports`、`opens` 和 `uses`。'
- en: '**JEP 282: jlink, the Java linker**: This allows packaging modules and their
    dependencies into smaller run times.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEP 282: jlink，Java 链接器**：这允许将模块及其依赖项打包到更小的运行时中。'
- en: More details about Project Jigsaw can be found from the Project Jigsaw homepage
    ([http://openjdk.java.net/projects/jigsaw/](http://openjdk.java.net/projects/jigsaw/)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Project Jigsaw 的详细信息可以在 Project Jigsaw 主页上找到 ([http://openjdk.java.net/projects/jigsaw/](http://openjdk.java.net/projects/jigsaw/)).
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are quite a few features listed that are significant for developers,
    and we thought of grouping them together for your benefit:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了许多对开发者来说很重要的功能，我们考虑将它们分组在一起以供您参考：
- en: Enhance the Javadoc tool to generate HTML 5 output and the generated Javadoc
    should support the local search for classes and other elements.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强 Javadoc 工具以生成 HTML 5 输出，并且生成的 Javadoc 应该支持对类和其他元素的本地搜索。
- en: Make G1 as the default garbage collector and remove GC combinations that have
    been deprecated in Java 8\. G1 is the new garbage collector (which has been in
    existence since Java SE 7), which focuses on reducing the pause times of the garbage
    collection activity. These pause times are very critical to latency-critical applications
    and, hence, such applications are going towards adopting the new garbage collector.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 G1 作为默认的垃圾回收器，并移除 Java 8 中已弃用的 GC 组合。G1 是一个新的垃圾回收器（自 Java SE 7 以来一直存在），它专注于减少垃圾回收活动的暂停时间。这些暂停时间对于延迟敏感的应用程序至关重要，因此，这些应用程序正在转向采用新的垃圾回收器。
- en: Changing the internal representation of `String` to make use of a byte array
    rather than a character array. In a character array, each array element is 2 bytes,
    and it was observed that a majority of strings use 1 byte. This resulted in wasteful
    allocation. The new representation would also introduce a flag to indicate the
    type of encoding used.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `String` 的内部表示从使用字符数组改为使用字节数组。在字符数组中，每个数组元素是 2 个字节，观察到大多数字符串使用 1 个字节。这导致了浪费的分配。新的表示也将引入一个标志来指示使用的编码类型。
- en: The new stackwalking API to support navigating the stack trace, which will help
    to do much more than just print the stack trace.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的堆栈跟踪 API 支持导航堆栈跟踪，这将有助于做更多不仅仅是打印堆栈跟踪的事情。
- en: Allow the image I/O plugin to support the TIFF image format.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许图像 I/O 插件支持 TIFF 图像格式。
- en: Using new tools in JDK 9
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JDK 9 中使用新工具
- en: There are a few new command-line tools introduced in JDK 9 to support new features.
    We will give you a quick overview of these tools and the same will be explained
    with recipes of their own in the later chapters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9 中引入了一些新的命令行工具来支持新特性。我们将为您快速概述这些工具，并在后面的章节中用各自的配方进行解释。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have JDK 9 installed and the `PATH` environment variable updated
    to add the path to the `bin` directory of your JDK installation. Also, you need
    to have tried out `HelloWorldXml` explained in the recipe, *Compiling and running
    a Java application*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了 JDK 9，并且将 JDK 安装目录下的 `bin` 目录路径添加到 `PATH` 环境变量中。此外，你需要尝试过配方中解释的 `HelloWorldXml`，即
    *编译和运行 Java 应用程序*。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will look at a few interesting new command-line tools introduced.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些新引入的有趣命令行工具。
- en: jdeprscan
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jdeprscan
- en: 'This tool is used for scanning the usage of deprecated APIs in a given JAR
    file, classpath, or source directory. Suppose we have a simple class that makes
    use of the deprecated method, `addItem`, of the `java.awt.List` class, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具用于扫描给定 JAR 文件、类路径或源目录中弃用的 API 的使用情况。假设我们有一个简单的类，它使用了 `java.awt.List` 类中弃用的方法
    `addItem`，如下所示：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile the preceding class and then use `jdeprscan`, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编译前面的类，然后使用 `jdeprscan`，如下所示：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will notice that this tool prints out `class Test uses method java/awt/List
    addItem (Ljava/lang/String;)V deprecated`, which is exactly what we expected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个工具打印出 `class Test uses method java/awt/List addItem (Ljava/lang/String;)V
    deprecated`，这正是我们预期的。
- en: jdeps
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jdeps
- en: This tool analyses your code base specified by the path to the `.class` file,
    directory, or JAR, lists the package-wise dependency of your application, and
    also lists the JDK module in which the package exists. This helps in identifying
    the JDK modules that the application depends on and is the first step in migrating
    to modular applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具通过指定 `.class` 文件、目录或 JAR 的路径来分析你的代码库，列出应用程序的包依赖关系，并列出包含该包的 JDK 模块。这有助于识别应用程序所依赖的
    JDK 模块，并且是迁移到模块化应用程序的第一步。
- en: 'We can run the tool on our `HelloWorldXml` example written earlier and see
    what `jdeps` provides:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前编写的 `HelloWorldXml` 示例上运行此工具，看看 `jdeps` 提供了什么：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: jlink
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jlink
- en: 'This tool is used to select modules and create a smaller runtime image with
    the selected modules. For example, we can create a runtime image by adding the `com.packt`
    modules created in our `HelloWorldXml` example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具用于选择模块并创建包含所选模块的较小运行时镜像。例如，我们可以通过添加在 `HelloWorldXml` 示例中创建的 `com.packt` 模块来创建运行时镜像：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looking at the contents of the `img` folder, we should find that it has the `bin`,
    `conf`, `include`, and `lib` directories. We will learn more about `jlink` under
    [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml), *Modular Programming*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文件夹 `img` 的内容，我们应该发现它包含 `bin`、`conf`、`include` 和 `lib` 目录。我们将在第 3 章 *模块化编程*
    中学习更多关于 `jlink` 的内容。
- en: jmod
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jmod
- en: JMOD is a new format for packaging your modules. This format allows including
    native code, configuration files, and other data that do not fit into JAR files.
    The JDK modules have been packaged as JMOD files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: JMOD 是一种新的模块打包格式。这种格式允许包含原生代码、配置文件和其他不适合放入 JAR 文件中的数据。JDK 模块已被打包为 JMOD 文件。
- en: 'The `jmod` command-line tool allows `create`, `list`, `describe`, and `hash`
    JMOD files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmod` 命令行工具允许 `create`、`list`、`describe` 和 `hash` JMOD 文件：'
- en: '`create`: This is used to create a new `jmod` file'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：这个用于创建一个新的 `jmod` 文件'
- en: '`list`:  This is used to list the contents of a `jmod` file'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`：这个用于列出 `jmod` 文件的内容'
- en: '`describe`: This is used to describe module details'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`：这个用于描述模块详情'
- en: '`hash`: This is used to record hashes of tied modules'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`：这个用于记录绑定模块的哈希值'
- en: JShell
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JShell
- en: 'This tool has been briefly explained earlier, under the title, *JEP 222: jshell
    - the Java shell (Read-Eval-Print Loop)*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '此工具已在标题为 *JEP 222: jshell - Java shell（读取-评估-打印循环）* 的部分中简要介绍。'
- en: Comparing JDK 8 and JDK 9
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较 JDK 8 和 JDK 9
- en: Due to the application of a modular system to JDK under Project Jigsaw, there
    have been a few changes in the JDK directory structure installed in your systems.
    In addition to these, there were a few changes undertaken to fix the JDK installation
    structure, which dates back to the times of Java 1.2\. This has been deemed to
    be a golden opportunity by the JDK team to fix the issues with the JDK directory
    structure.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 Project Jigsaw 项目下对 JDK 应用了模块化系统，因此您的系统中安装的 JDK 目录结构发生了一些变化。除此之外，还进行了一些更改以修复
    JDK 安装结构，这些更改可以追溯到 Java 1.2 时代。JDK 团队认为这是一个修复 JDK 目录结构问题的绝佳机会。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To see the difference in the JDK 9 directory structure, you will need to install
    a pre-JDK 9 version. We have chosen to use JDK 8 to compare with JDK 9\. So, go
    ahead and install JDK 8 before you proceed further.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 JDK 9 目录结构中的差异，您需要安装一个 JDK 9 之前的版本。我们选择使用 JDK 8 与 JDK 9 进行比较。因此，在继续之前，请先安装
    JDK 8。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We did a side-by-side comparison of both the JDK installation directories as
    shown in the following:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对以下所示的两个 JDK 安装目录进行了并排比较：
- en: '![](img/b3a4d907-5b86-464f-88a5-0f0e83b5ce91.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3a4d907-5b86-464f-88a5-0f0e83b5ce91.png)'
- en: 'Following are our observations from the preceding comparison:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们从先前的比较中得出的观察结果：
- en: The `jre` directory has been completely removed and has been replaced by `jmods` and `conf`.
    The `jmods` directory contains the runtime images of the JDK modules, the `conf`
    directory contains configuration and property files, which were earlier under
    the `jre` directory.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jre` 目录已被完全删除，并已被 `jmods` 和 `conf` 替换。`jmods` 目录包含 JDK 模块的运行时镜像，`conf` 目录包含配置和属性文件，这些文件之前位于
    `jre` 目录下。'
- en: The contents of `jrebin` and `jrelib` have been moved to the lib and bin directories
    of JDK installation.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrebin` 和 `jrelib` 的内容已移动到 JDK 安装目录的 lib 和 bin 目录中。'
- en: See also
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Refer to the following recipe of this chapter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下配方：
- en: Using new tools in JDK 9
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JDK 9 中使用新工具
