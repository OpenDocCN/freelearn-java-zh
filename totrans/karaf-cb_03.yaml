- en: Chapter 3. Deploying a Message Broker with Apache ActiveMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apache ActiveMQ modules into Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ query command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ list command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ dstat command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ purge command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS connection factory command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS send command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS browse command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and deploying a master/slave broker with Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and deploying a Network of Brokers with Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ActiveMQ is a common framework used in enterprise software solutions to implement
    JMS messaging via TCP, SSL, HTTP(s), VM, and STOMP, which is one of the many ways
    to allow inter-bundle communications. ActiveMQ provides a lot of benefits, from
    handling data bursts to providing failover and scaling. In this chapter, we will
    cover the why and how of implementing the embedded ActiveMQ broker in a Karaf
    environment. We will also look at how to administer the broker under different
    deployment topologies.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, we should discuss when to use the embedded broker deployment
    strategy versus standalone. This is just as important as learning how, since an
    embedded broker can bring the system to its knees just as fast as bad architecture.
    In many cases, the initial thought is embedding ActiveMQ is easier to deploy and
    will make messaging faster. While there is some truth to this, in most cases,
    the benefit does not outweigh the cost. Allowing ActiveMQ to share the JVM resources
    will cause contention in higher load systems. Also, if there is an issue with
    ActiveMQ that causes it to fail, it will more than likely have a direct impact
    on the Karaf instance, which will in turn cause the application to fail, or vice
    versa. Embedded ActiveMQ brings a lot of value to enterprise applications; just
    make sure it is used for the right purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common embedded solution is for geographically separated client/server applications.
    One example is the client application resides in a Karaf instance across a WAN
    and intermittent outages can occur. Then, it might be a good idea to have a local
    embedded ActiveMQ to allow the client to continue functioning while the broker
    re-establishes communications with the server. The following diagram demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/Image_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Give a lot of thought as to whether or not an embedded broker is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apache ActiveMQ modules into Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing an ActiveMQ broker into a Karaf instance requires very little effort.
    This recipe will show you how easy it is to get ActiveMQ embedded and running.
    In order to install the ActiveMQ broker in Karaf, we first need to add the feature
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Out of the box, Karaf does not come with ActiveMQ installed. But do not fret,
    for Karaf makes it very easy to install it. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to install the XML features by adding the repo for the version
    we expect to use. This can be done using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows us how to start:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now that we have the features available, we can list them using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The screenshot should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'There are several options for installing only what we need. If your application
    is connecting to any ActiveMQ instance, then all you need in the OSGi environment
    is the client APIs for connecting. Simply install the `activemq-client` feature;
    this provides the necessary classes for instantiating a connection and sending
    or receiving messages. You can do this using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But, since we are embedding a broker in the Karaf instance, we need to run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the following screenshot that the `activemq-client`, `activemq`, `activemq-broker`,
    and `activemq-web-console` features have been installed. This is indicated by
    'X' in the third column.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we install the ActiveMQ broker, the instantiation is configured in the file
    `etc/org.apache.activemq.server-default.cfg`. This file is read at the time the
    embedded broker is started and will use the referenced `activemq.xml` file to
    define how the ActiveMQ broker will be initialized. Various other JVM parameters
    are also configured in this file. The default configuration file will look like
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A big benefit to having the configuration settings in the `.cfg` file is that
    any changes to the values in the configuration file will cause the broker to stop
    and restart, thereby incorporating the changes. Changes to the `activemq.xml`
    file require a manual stop and start of the broker. A good update to the configuration
    file is to add memory settings such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the properties in the `activemq.xml` file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The more configurations you can set as properties, the easier it is to administer
    the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ActiveMQ query command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A convenient feature of an embedded ActiveMQ is the ability to run commands
    against the broker for monitoring broker activity. The `query` command provides
    basic information about the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to get started, we need to get the `activemq-broker` feature installed
    as outlined in the previous recipe. Once that is installed, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After typing the command, press the *Tab* key. This will list out all the available
    ActiveMQ commands as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5081OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, just running the command is pretty boring; there is not much to see in
    an empty broker.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get some data loaded so that we can see what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s start sending some data through the broker in order to make this
    more entertaining and realistic. This recipe has some helper classes we can use
    to load the broker with data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `mvn clean install` command in the example code under the *Installing
    Apache ActiveMQ modules into Apache Karaf* recipe. Then, you can run the Publisher
    against the embedded ActiveMQ. If no defaults have been changed from the `activemq.xml`
    file, then the defaults in the publisher code will work. We can run the publisher
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will send 10001 messages to the broker including the shutdown message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we can see we have 10001 messages waiting in the test queue, let''s
    go ahead and consume them using our `Listener` as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a consumer on the queue and pull the messages off.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is nice to be able to see a queue at a glance, but what if we need to see
    more information about the queue? In many cases, we need to see how much memory
    a queue is consuming, or the consumer count, or any number of parameters. A good
    way is to use the query command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will list out the properties of a queue much like you might find in JConsole,
    which is a JMX monitoring tool provided by Java. This is a nice way to be able
    to monitor queue properties using scripts, or for continuous integration tests
    to monitor results. We can look at a few of the properties that are often looked
    at in JConsole when debugging. We can see that the depth of the queue is 10001\.
    This is found under the **QueueSize** parameter in JConsole. But if we want to
    see a parameter that tells us a little more about the health of the queue, let's
    look at the **MemoryPercentageUsage** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in JConsole that the value is currently **3**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An easier way to see these parameters is to use the Karaf console command `activemq:query`.
    This saves us from having to open JConsole and enter the long remote process URL:
    `service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can type in the username and password. Alternatively, we can simply
    use the `activemq:query –QQueue=<queue_name>` command to query the queue statistics
    using JMX. The following screenshot shows what will be displayed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we are command-line gurus, we can use the `|` command to grep for information
    we are interested in. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the statistics for **MemoryPercentUsage** (shown in the previous screenshot)
    are in there, along with all the other memory-based properties. Another useful
    filter is Count. This will show all the counts for `enqueue`, `dequeue`, `inflight`,
    `producer`, `consumer`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query command has many options. These can be seen by using the `--help`
    parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **QueueSize** column shows the number of messages that are currently in
    the queue waiting to be consumed. The **Dequeue** column is the total number of
    messages that have been consumed by a listener. If we were to run the publisher
    code again, we would see that the queue size increased again to 10001 but the
    **Dequeue** value has not moved, indicating we have 10001 messages in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the ActiveMQ commands are provided via MBeans or JMX. Many of the same
    functions are available through JConsole.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ list command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ dstat command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ list command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `list` command can be used to list out the brokers currently running inside
    the Karaf container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to get started, we need to get the `activemq-broker` feature installed.
    Reference the `activemq:query` command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5081OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To list out all brokers currently running embedded inside this instance of
    Karaf, we can simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list out the embedded broker names as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This `activemq` command will invoke the `JmxMBeansUtil.getAllBrokers` class
    on the JMX connection and retrieve the name of any broker currently running.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ query command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ dstat command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ dstat command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dstat` command is a convenient way to see queue message statistics at a
    glance. It will list out the queues with queue size, the number of producers and
    consumers, the number of messages enqueued and dequeued, and the percentage of
    memory used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get started, we need to get the `activemq-broker` feature installed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have run any previous recipes, a good way to get a clean environment
    is to stop Karaf, delete the data directory, and restart. This will clean up any
    data from the previous runs. Remember to reinstall the `activemq-broker` feature
    after restarting.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's run the `activemq:dstat` command, as shown in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5081OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not very impressive. Without data, these commands can be pretty boring. In the
    previous screenshot, we can see that we have one queue defined at this moment
    with no message, no producers, and no consumers. So, let's get some data loaded
    to see what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to start sending some data through the brokers in order to make this
    more entertaining and realistic. This recipe has some helper classes we can use
    to load the broker with data. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `mvn clean install` command in the example code under the *Installing
    Apache ActiveMQ modules into Apache Karaf* recipe. Then, you can run the publisher
    against the embedded ActiveMQ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If no defaults have been changed from the `activemq.xml` file, then the defaults
    in the publisher code will work. We can run the publisher using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will send 10001 messages to the broker. Now we can look at the `dstat`
    broker and see if there are any changes. The following screenshot shows the result
    from the `dstat` broker:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Using the `dstat` command, we can see that the publisher has put 10001 messages
    on the test queue and that several advisory messages have been enqueued too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Advisory messages are specific ActiveMQ messages that are meant to inform you
    of an event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we can see we have 10001 messages waiting in the test queue, let''s
    go ahead and consume them using our listener, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create a consumer on the queue and pull the messages off. We can
    see through the `dstat` command what is happening on our queue. This is displayed
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dstat` command uses the ServerInvocationHandler interface to create an
    instance of the QueueViewMBean interface or the TopicViewMBean interface using
    the JMX connection. These provide statistics on the queues or topics. The stats
    are simply listed out to the console in order to provide a high level snapshot
    of the queues/topics.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ purge command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ query command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ActiveMQ purge command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A useful command for clearing data is the `purge` command. This can be used
    in conjunction with wildcards to clear out large numbers of queues.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have the `activemq-broker` feature installed in a similar way as done in the
    *Using the ActiveMQ dstat command* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can purge the data, we first need to load some data. We can load
    data using the example code provided in the earlier recipes. The steps are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the publisher again using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `dstat` command from the earlier recipe, we can see in the following
    screenshot that we loaded 10001 messages into the test queue of our embedded broker:![How
    to do it…](img/5081OS_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `purge` command will remove data from any number of queues using wildcards
    and SQL92 syntax.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add messages to the queue using the publisher we saw in the *Installing
    Apache ActiveMQ modules into Apache Karaf* recipe. Run it a couple of times for
    fun. Now, query the queue using the following command to see how many messages
    we have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `*` character for the queue name will return the `EnqueueCount` value
    for all queues, but in this example, we only have the test queue anyway.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can see that after two runs we have **20002** as the **EnqueueCount** value,
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_03_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can see thousands of messages now in the queue after running the publisher
    a couple of times. Now run the following `purge` command against the test queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/5081OS_03_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `purge` command removes all messages in the given queue. Let''s rerun the
    following `query` command to see if the queues were cleared out:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PurgeCommand` class in the ActiveMQ code base is used to purge messages
    in the selected queue. If no queue is defined, as shown in the following command,
    it will purge all messages from all queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can use both an AMQ-specific language, which looks like `JMSPriority>2,MyHeader='Foo'`,
    or we can use the SQL-92 syntax `(JMSPriority>2) AND (MyHeader='Foo')` to select
    specific messages for deletion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ list command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the ActiveMQ query command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS connection factory commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an embedded broker and have looked at some of the commands
    for viewing the broker properties and statistics, let's look at how to interact
    with the broker using JMS commands. In this recipe, we will look at the command
    for creating and interacting with the broker by creating a connection factory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for us to control the connection factory and send messages to the
    embedded broker, first we need to install the required commands using the following
    JMS feature command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the *Tab* key, we will see a list of the JMS commands available for creating,
    sending, and browsing messages as well as creating connection factories. These
    commands are listed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5081OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, let's create a connection factory for our embedded broker. We do this
    using the `jms:create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to reference the `--help` command for required and optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a connection factory first so that we can mess around with sending
    messages. All that is needed to create a connection factory is the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for this example, a command like the following will work to make a connection
    of type `-t activemq` to the URL `-u tcp://localhost:61616`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will create a connection factory using the ActiveMQConnectionFactory as
    defined by the `–t` option (the other option is WebsphereMQ). We can verify that
    our factory was indeed set up by performing a `la` command from the command line.
    Your last entry should look something like the following command-line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the pattern for the XML file naming is `connectionfactory-<name>.xml`.
    In the case of our example, we used the name 'cookbook'. If this is not the last
    entry, or you do not see it, try using the `la | grep cookbook` command.
  prefs: []
  type: TYPE_NORMAL
- en: A file called `connectionfactory-cookbook.xml` was created in the `deploy` directory
    of the Karaf instance, which is shown in the following code. This file is a Blueprint
    XML file that will instantiate the connection factory, pooled connection factory,
    the resource manager, and the transaction manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The pooled connection factory is added to the services with a JNDI name of `jms/cookbook`.
    The important piece of information to note here is the `–u` option that is used
    to define the URL for the connection based on which the connection pool is also
    created. This is an important input from a system resource management perspective.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the JMS send command* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS send command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When debugging or testing code, it is very handy to be able to send messages
    to a specific queue. This can be done from the command console in Karaf using
    the JMS subshell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that the JMS feature is installed and available. In order to use most
    of the commands via JMS, we need to have a connection factory created (see the
    *Using the JMS connection factory commands* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s make sure the service is in place using the `info` command. The
    connection factory can be referenced either from the specified name `cookbook`
    or by the JNDI service name `jms/cookbook`, as we can see in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have verified the JMS connection factory, we can use it to send
    messages to the broker. This can be done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will send a message, `the recipes are sweet`, to `cookbookQueue` using
    the JNDI name for our connection factory `jms/cookbook`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `send` command will package up the string variable in the command line
    and put it in a JMS message, and then send the message to the specified queue.
    If you look at the command line, there are three parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The JNDI reference to the connection factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the queue we are sending the message to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out the `browse` command to see how to view the message you just sent
    to the broker. You can also see it at [http://karaf.apache.org/manual/latest/users-guide/jms.html](http://karaf.apache.org/manual/latest/users-guide/jms.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS browse command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an embedded broker and have looked at some of the commands
    for viewing the broker properties and statistics, let's look at how to interact
    with the broker using commands. In this recipe, we will look at the command for
    browsing messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for us to control the connection factory and send messages to the
    embedded broker, first we need to get the commands installed using the following
    JMS feature command, like we did in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, let's create a connection factory for our embedded broker. We do this
    using the `jms:create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to reference the `--help` command for required or optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The real meat and potatoes of this command is the ability to browse the messages
    in the queue. An example `browse` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to see the message content, persistence (delivery mode), expiration,
    ID, the replyTo value, destination, and so on. It is a quick way to monitor what
    is in the queue at any given time. The output of the preceding `browse` command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Browsing messages in the queue is simple. The parameters on the command line
    tell the `browse` command what connection factory to use and what queue to browse.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and deploying a master/slave broker with Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will set up and deploy two Karaf instances with embedded
    ActiveMQ in a master/slave configuration. This is used for high availability in
    messaging systems. This will allow systems to continue functioning in case of
    a failure of the active instance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we need to get two instances of Karaf started up with an embedded broker.
    If we are doing this on two different machines, it is actually easier since we
    will not have port conflicts when using the defaults on both machines. Keep in
    mind that if you decide to run this deployment on a single machine, one of the
    instances of Jetty and ActiveMQ embedded in Karaf needs to have its ports changed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we can only assume that we have one machine to work with, we will go
    over how to get two instances of Karaf running on a single machine. We can create
    a second instance by unzipping the Karaf `.zip` or `.tar` file to a new directory
    or just copy and paste the current instance to a new directory. Now, we have to
    change the port setting on one of the instances. This can be done using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `org.apache.karaf.management.cfg` file and locate the following lines
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alter the port to something not in use, say `1096`. Then, alter the RMI server
    connection port as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can change this to something like `44446`. Now, we can start up the second
    instance without port conflicts. But we are not done yet. We still have to configure
    the ActiveMQ instances for failover.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to instance 1 and instance 2 of Karaf:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `org.apache.activemq.server-default.cfg` file of the `<karaf-home>/etc/`
    folder and change the following code to a hardcoded location on the disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example might be something like the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `jetty.xml` file of the `<karaf-home>/etc/` folder and change the
    value of `jetty.port` to something like `8186`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `org.apache.karaf.shell.cfg` file of the `<karaf-home>/etc/` folder
    and change the value of `sshPort` to something like `8106`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are running both ActiveMQ instances on the same machine, it would
    be more complete to change the port on the second ActiveMQ instance to a different
    port, although this is not required since the port is not allocated until ActiveMQ
    gets a lock on the file location (this step is optional in this configuration;
    however, it is more important in a Network of Brokers configuration on a single
    machine as both instances are active). This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After changing the configuration files, save them and start both instances
    of Karaf. Install the `activemq-broker` feature on instance 1 as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will see that the embedded ActiveMQ instance starts up without issue. Now
    do the same on instance 2 and look at the log of instance 2 in the `karaf.log`
    file in the `data/log` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search the logfile of instance 2 for the phrase `could not be locked`. We will
    see the following output line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This indicates that the second embedded broker instance is in a wait state
    and not fully instantiated. To see instance 2 start up and initialize, press *Ctrl*
    + *D* on instance 1 (to shut down the instance). If you are tailing the logfile
    or you refresh the logfile in your viewer, you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indicates that the slave broker on instance 2 has started up and initialized
    the connections.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ActiveMQ gives us high availability via a couple of options. In the case of
    this recipe, we are using file-based persistence (`kahadb`). This allows us to
    point both instances at the same data file location to establish the master or
    the slave. The first instance to start up will get a lock on the file location
    and then finish initializing. The other instance will look at the same file location
    and see that a lock has already been established. Then, it will log the IOException
    and wait for the default 10 seconds before trying again.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous diagram shows that the master ActiveMQ instance has established
    a lock from the file location. It has instantiated all the connections configured
    in the `activemq.xml` file under the `etc` folder as defined by the transport
    connection elements. This allows clients to now connect to the master instance.
    Once an instance is shut down, those connections are killed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that the clients are configured with a failover protocol to the slave
    instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The client machines will automatically reconnect to the slave machine once
    the secondary broker finishes initializing. This is demonstrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we can restart the original master (instance 1) and that will
    now wait to get a lock on the file. This gives us the master/slave setup without
    having to restart instances or restore data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring and deploying a Network of Brokers with Apache Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and deploying a Network of Brokers with Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times, a single system may not be enough to handle the load of the applications.
    In this case, scaling is needed to balance load across multiple systems. We can
    scale applications using embedded ActiveMQ instances in a **Network of Brokers**
    (**NoB**) configuration.
  prefs: []
  type: TYPE_NORMAL
- en: This is different from a master/slave configuration because we will have two
    active instances rather than an active and passive pair.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By following the same initial setup in the previous recipe, we need to have
    two instances of Karaf running. We can prove this concept on a single machine
    or multiple machines. For this recipe, we will again be showing you how to set
    up two instances on the same machine, which requires different ports to be used
    for the different Karaf instances.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the defaults for the two instances are in place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please follow these steps to configure and deploy a Network of Brokers configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `org.apache.activemq.server-defaults.cfg` file of the `<karaf-home>/etc/`
    folder and make sure the following data value is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will tell the embedded ActiveMQ instance to use a local data folder defined
    by the parameters mentioned earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the instance 1 option for broker name to `recipe-3-broker-1` and change
    the instance 2 option for broker name to `recipe-3-broker-2`. So, the values in
    the file should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That way, it is easy to differentiate between brokers when looking at them using
    JMX. The `karaf.data` property is a system property that is set based on the Karaf
    location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For this recipe, let''s work with instance 2\. First, we have to alter the
    `etc/activemq.xml` file to have a network connector that links it with the instance.
    The following is the XML code that needs to be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the URI has the static protocol with a TCP connection to the instance 1
    port (in this case, the default port was left on instance 1 as `61616`). We turn
    on duplex to allow two-way communication through a single pipe and pass the username
    and password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to avoid port conflicts, we need to change the transport connector
    port on instance 2 to something other than `61616`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One more change and we are ready to test. We need to change the port in the
    `jetty.xml` file under the `etc` folder. By default, the port is `8181`, but since
    instance 1 is using that, we need to change instance 2 to something else. For
    this recipe, I have used `8182`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can start up both instances now. If we monitor the logs for instance 2,
    we will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The log entries indicate that instance 2 has found instance 1 and established
    a connection between the two.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Network of Brokers configuration can be used for two different topologies:
    vertical or horizontal. First, let''s look at horizontal, which is more for scaling
    purposes. This type of topology will often be used to provide great throughput
    for a system. The main idea is to NOT increase the number of brokers a message
    must pass through in order to be consumed by your application. Rather, it is designed
    to balance load across multiple servers. Notice in the following diagram that
    there are two client machines attached to each instance allowing each broker/Karaf
    pair to only have to process the messages for two clients.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each broker instance has its own message store and is not considered a highly
    available topology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though clients can failover from one client to the other, persisted data
    is not shared between the instances. This means that if one instance of the broker
    dies, then the pending messages in that store are not processed until the broker
    is restarted, even though the clients move over to the one active broker instance.
    Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The benefit to having a network of brokers is the ability to forward messages
    to idle clients. If a message is produced to the local **broker 1** but all the
    clients are busy, then ActiveMQ will forward the message to any idle clients on
    **broker 2**. This is considered horizontal scaling.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is also the notion of vertical scaling. But this has an entirely different
    use case. When using vertical scaling, the obstacle is usually not performance.
    In most cases, vertical scaling is used for communication problems over a WAN.
    A good example of this is outlined in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/5081OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous diagram, an embedded ActiveMQ is used locally to avoid application
    downtime if the connection between Los Angeles and Dallas is lost. So, the local
    application will communicate directly with the local instance without worrying
    if the WAN is up or down. Then, the local ActiveMQ will be in charge of establishing
    and maintaining the connection to the backend service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a performance cost to vertical scaling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vertical scaling is forcing a two-broker hop. So, you have to figure out which
    is more important from the requirements: performance or stability.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring* *and deploying a master/slave broker with Apache Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
