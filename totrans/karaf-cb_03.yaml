- en: Chapter 3. Deploying a Message Broker with Apache ActiveMQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用 Apache ActiveMQ 部署消息代理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Installing Apache ActiveMQ modules into Apache Karaf
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Apache ActiveMQ 模块安装到 Apache Karaf 中
- en: Using the ActiveMQ query command
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ActiveMQ 查询命令
- en: Using the ActiveMQ list command
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ActiveMQ 列表命令
- en: Using the ActiveMQ dstat command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ActiveMQ dstat 命令
- en: Using the ActiveMQ purge command
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ActiveMQ 清理命令
- en: Using the JMS connection factory command
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JMS 连接工厂命令
- en: Using the JMS send command
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JMS 发送命令
- en: Using the JMS browse command
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JMS 浏览命令
- en: Configuring and deploying a master/slave broker with Apache Karaf
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 配置和部署主/从代理
- en: Configuring and deploying a Network of Brokers with Apache Karaf
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 配置和部署代理网络
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: ActiveMQ is a common framework used in enterprise software solutions to implement
    JMS messaging via TCP, SSL, HTTP(s), VM, and STOMP, which is one of the many ways
    to allow inter-bundle communications. ActiveMQ provides a lot of benefits, from
    handling data bursts to providing failover and scaling. In this chapter, we will
    cover the why and how of implementing the embedded ActiveMQ broker in a Karaf
    environment. We will also look at how to administer the broker under different
    deployment topologies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveMQ 是在 TCP、SSL、HTTP(s)、VM 和 STOMP 等多种方式中实现 JMS 消息传递的常用框架之一，这是允许组件间通信的许多方法之一。ActiveMQ
    提供了许多好处，从处理数据突发到提供故障转移和扩展。在本章中，我们将介绍在 Karaf 环境中实现嵌入式 ActiveMQ 代理的原因和方法。我们还将探讨在不同部署拓扑下如何管理代理。
- en: Before we begin, we should discuss when to use the embedded broker deployment
    strategy versus standalone. This is just as important as learning how, since an
    embedded broker can bring the system to its knees just as fast as bad architecture.
    In many cases, the initial thought is embedding ActiveMQ is easier to deploy and
    will make messaging faster. While there is some truth to this, in most cases,
    the benefit does not outweigh the cost. Allowing ActiveMQ to share the JVM resources
    will cause contention in higher load systems. Also, if there is an issue with
    ActiveMQ that causes it to fail, it will more than likely have a direct impact
    on the Karaf instance, which will in turn cause the application to fail, or vice
    versa. Embedded ActiveMQ brings a lot of value to enterprise applications; just
    make sure it is used for the right purposes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们应该讨论何时使用嵌入式代理部署策略与独立部署。这和学会如何做一样重要，因为嵌入式代理可能会像糟糕的架构一样快速地将系统拖垮。在许多情况下，最初的考虑是嵌入式
    ActiveMQ 更容易部署，并且会使消息传递更快。虽然这一点有一定的真实性，但在大多数情况下，这种好处并不超过成本。允许 ActiveMQ 共享 JVM
    资源将在高负载系统中引起竞争。此外，如果 ActiveMQ 出现问题导致其失败，它很可能会对 Karaf 实例产生直接影响，进而导致应用程序失败，反之亦然。嵌入式
    ActiveMQ 为企业应用程序带来了很多价值；只是确保它被用于正确的目的。
- en: 'A common embedded solution is for geographically separated client/server applications.
    One example is the client application resides in a Karaf instance across a WAN
    and intermittent outages can occur. Then, it might be a good idea to have a local
    embedded ActiveMQ to allow the client to continue functioning while the broker
    re-establishes communications with the server. The following diagram demonstrates
    this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的嵌入式解决方案是用于地理位置分离的客户端/服务器应用程序。一个例子是客户端应用程序位于跨越 WAN 的 Karaf 实例中，可能会发生间歇性中断。那么，拥有一个本地的嵌入式
    ActiveMQ 以允许客户端在代理与服务器重新建立通信时继续运行可能是个好主意。以下图示展示了这一点：
- en: '![Introduction](img/Image_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/Image_01.jpg)'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Give a lot of thought as to whether or not an embedded broker is needed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑是否真的需要一个嵌入式代理。
- en: Installing Apache ActiveMQ modules into Apache Karaf
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Apache ActiveMQ 模块安装到 Apache Karaf 中
- en: Installing an ActiveMQ broker into a Karaf instance requires very little effort.
    This recipe will show you how easy it is to get ActiveMQ embedded and running.
    In order to install the ActiveMQ broker in Karaf, we first need to add the feature
    URL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ActiveMQ 代理安装到 Karaf 实例中几乎不需要任何努力。本食谱将向您展示如何轻松地集成并运行 ActiveMQ。为了在 Karaf 中安装
    ActiveMQ 代理，我们首先需要添加功能 URL。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Out of the box, Karaf does not come with ActiveMQ installed. But do not fret,
    for Karaf makes it very easy to install it. The steps are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开箱即用，Karaf 并未安装 ActiveMQ。但无需担心，Karaf 使得安装它变得非常简单。步骤如下：
- en: 'First we need to install the XML features by adding the repo for the version
    we expect to use. This can be done using the following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过添加我们期望使用的版本的仓库来安装XML功能。这可以通过以下命令完成：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot shows us how to start:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图展示了如何启动：
- en: '![How to do it…](img/5081OS_03_02.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_03_02.jpg)'
- en: 'Now that we have the features available, we can list them using the following
    command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这些功能可用，我们可以使用以下命令列出它们：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The screenshot should look like the following:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截图应该看起来像以下这样：
- en: '![How to do it…](img/5081OS_03_04.jpg)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_03_04.jpg)'
- en: 'There are several options for installing only what we need. If your application
    is connecting to any ActiveMQ instance, then all you need in the OSGi environment
    is the client APIs for connecting. Simply install the `activemq-client` feature;
    this provides the necessary classes for instantiating a connection and sending
    or receiving messages. You can do this using the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以只安装我们需要的部分。如果你的应用程序连接到任何ActiveMQ实例，那么在OSGi环境中你只需要连接客户端API。只需安装`activemq-client`功能；这提供了实例化连接和发送或接收消息所需的必要类。你可以使用以下命令完成此操作：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But, since we are embedding a broker in the Karaf instance, we need to run
    the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于我们在Karaf实例中嵌入代理，我们需要运行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice in the following screenshot that the `activemq-client`, `activemq`, `activemq-broker`,
    and `activemq-web-console` features have been installed. This is indicated by
    'X' in the third column.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下截图中的`activemq-client`、`activemq`、`activemq-broker`和`activemq-web-console`功能已被安装。这由第三列中的'X'表示。
- en: '![How to do it…](img/5081OS_03_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_03_03.jpg)'
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'If we install the ActiveMQ broker, the instantiation is configured in the file
    `etc/org.apache.activemq.server-default.cfg`. This file is read at the time the
    embedded broker is started and will use the referenced `activemq.xml` file to
    define how the ActiveMQ broker will be initialized. Various other JVM parameters
    are also configured in this file. The default configuration file will look like
    the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们安装ActiveMQ代理，其实例化配置在文件`etc/org.apache.activemq.server-default.cfg`中。该文件在启动嵌入式代理时被读取，并将使用引用的`activemq.xml`文件来定义ActiveMQ代理的初始化方式。该文件还配置了各种其他JVM参数。默认配置文件看起来像以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A big benefit to having the configuration settings in the `.cfg` file is that
    any changes to the values in the configuration file will cause the broker to stop
    and restart, thereby incorporating the changes. Changes to the `activemq.xml`
    file require a manual stop and start of the broker. A good update to the configuration
    file is to add memory settings such as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置设置放在`.cfg`文件中的一个大好处是，对配置文件中值的任何更改都会导致代理停止并重新启动，从而合并更改。对`activemq.xml`文件的更改需要手动停止和启动代理。一个很好的配置文件更新是添加如下内存设置：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, add the properties in the `activemq.xml` file using the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下代码在`activemq.xml`文件中添加属性：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The more configurations you can set as properties, the easier it is to administer
    the runtime.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你能设置的配置属性越多，管理运行时就越容易。
- en: Using the ActiveMQ query command
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ActiveMQ查询命令
- en: A convenient feature of an embedded ActiveMQ is the ability to run commands
    against the broker for monitoring broker activity. The `query` command provides
    basic information about the broker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式ActiveMQ的一个方便的特性是能够运行命令来监控代理活动。`query`命令提供了关于代理的基本信息。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In order to get started, we need to get the `activemq-broker` feature installed
    as outlined in the previous recipe. Once that is installed, we can use the following
    command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们需要按照前一个菜谱中概述的步骤安装`activemq-broker`功能。一旦安装完成，我们就可以使用以下命令：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After typing the command, press the *Tab* key. This will list out all the available
    ActiveMQ commands as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输入命令后，按*Tab*键。这将列出所有可用的ActiveMQ命令，如下面的截图所示：
- en: '![Getting ready](img/5081OS_03_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5081OS_03_05.jpg)'
- en: Now, just running the command is pretty boring; there is not much to see in
    an empty broker.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仅仅运行命令相当无聊；在一个空的代理中看不到太多东西。
- en: Let's get some data loaded so that we can see what is happening.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载数据，以便我们可以看到正在发生的事情。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Now, let''s start sending some data through the broker in order to make this
    more entertaining and realistic. This recipe has some helper classes we can use
    to load the broker with data:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始通过代理发送一些数据，以便使这个例子更有趣、更真实。这个菜谱有一些辅助类我们可以用来加载数据到代理中：
- en: 'Run the `mvn clean install` command in the example code under the *Installing
    Apache ActiveMQ modules into Apache Karaf* recipe. Then, you can run the Publisher
    against the embedded ActiveMQ. If no defaults have been changed from the `activemq.xml`
    file, then the defaults in the publisher code will work. We can run the publisher
    using the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“将Apache ActiveMQ模块安装到Apache Karaf”的示例代码中运行`mvn clean install`命令。然后，你可以运行发布者对嵌入的ActiveMQ。如果没有从`activemq.xml`文件更改默认设置，那么发布者代码中的默认设置将工作。我们可以使用以下命令运行发布者：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will send 10001 messages to the broker including the shutdown message.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将向代理发送10001条消息，包括关闭消息。
- en: 'Now that we can see we have 10001 messages waiting in the test queue, let''s
    go ahead and consume them using our `Listener` as shown in the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以看到测试队列中有10001条消息等待，让我们继续使用我们的`Listener`来消费它们，如下面的命令所示：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create a consumer on the queue and pull the messages off.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在队列上创建一个消费者并拉取消息。
- en: 'It is nice to be able to see a queue at a glance, but what if we need to see
    more information about the queue? In many cases, we need to see how much memory
    a queue is consuming, or the consumer count, or any number of parameters. A good
    way is to use the query command as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能够一眼看到队列是件好事，但如果我们需要看到更多关于队列的信息怎么办？在许多情况下，我们需要看到队列消耗了多少内存，或者消费者数量，或者任何数量的参数。一个好的方法是使用查询命令，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will list out the properties of a queue much like you might find in JConsole,
    which is a JMX monitoring tool provided by Java. This is a nice way to be able
    to monitor queue properties using scripts, or for continuous integration tests
    to monitor results. We can look at a few of the properties that are often looked
    at in JConsole when debugging. We can see that the depth of the queue is 10001\.
    This is found under the **QueueSize** parameter in JConsole. But if we want to
    see a parameter that tells us a little more about the health of the queue, let's
    look at the **MemoryPercentageUsage** parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出队列的属性，就像你可能在JConsole中找到的那样，JConsole是Java提供的一个JMX监控工具。这是一种使用脚本监控队列属性或用于持续集成测试监控结果的好方法。我们可以查看在调试时在JConsole中经常查看的一些属性。我们可以看到队列的深度是10001。这可以在JConsole的**QueueSize**参数下找到。但如果我们想看到一个告诉我们队列健康状况的参数，让我们看看**MemoryPercentageUsage**参数。
- en: 'We can see in JConsole that the value is currently **3**, as shown in the following
    screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在JConsole中看到当前值是**3**，如下面的屏幕截图所示：
- en: '![How to do it…](img/5081OS_03_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_03_06.jpg)'
- en: 'An easier way to see these parameters is to use the Karaf console command `activemq:query`.
    This saves us from having to open JConsole and enter the long remote process URL:
    `service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些参数的一个更简单的方法是使用Karaf控制台命令`activemq:query`。这使我们免去了打开JConsole并输入长远程进程URL的麻烦：`service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root`。
- en: 'Then, we can type in the username and password. Alternatively, we can simply
    use the `activemq:query –QQueue=<queue_name>` command to query the queue statistics
    using JMX. The following screenshot shows what will be displayed in the console:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以输入用户名和密码。或者，我们可以简单地使用`activemq:query –QQueue=<queue_name>`命令，通过JMX查询队列统计信息。下面的屏幕截图显示了控制台将显示的内容：
- en: '![How to do it…](img/5081OS_03_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_03_07.jpg)'
- en: 'Since we are command-line gurus, we can use the `|` command to grep for information
    we are interested in. This is shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是命令行高手，我们可以使用`|`命令来grep我们感兴趣的信息。这在上面的屏幕截图中有展示：
- en: '![How to do it…](img/5081OS_03_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_03_08.jpg)'
- en: Notice the statistics for **MemoryPercentUsage** (shown in the previous screenshot)
    are in there, along with all the other memory-based properties. Another useful
    filter is Count. This will show all the counts for `enqueue`, `dequeue`, `inflight`,
    `producer`, `consumer`, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到**MemoryPercentUsage**（如前一个屏幕截图所示）的统计数据包含在内，以及所有其他基于内存的属性。另一个有用的过滤器是计数。这将显示`enqueue`、`dequeue`、`inflight`、`producer`、`consumer`等的所有计数。
- en: 'The query command has many options. These can be seen by using the `--help`
    parameter as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查询命令有许多选项。这些可以通过使用`--help`参数查看，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **QueueSize** column shows the number of messages that are currently in
    the queue waiting to be consumed. The **Dequeue** column is the total number of
    messages that have been consumed by a listener. If we were to run the publisher
    code again, we would see that the queue size increased again to 10001 but the
    **Dequeue** value has not moved, indicating we have 10001 messages in the queue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列大小**列显示了当前在队列中等待被消费的消息数量。**出队**列是已被监听器消费的总消息数量。如果我们再次运行发布者代码，我们会看到队列大小再次增加到10001，但**出队**值没有变化，这表明队列中有10001条消息。'
- en: Most of the ActiveMQ commands are provided via MBeans or JMX. Many of the same
    functions are available through JConsole.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数ActiveMQ命令都是通过MBeans或JMX提供的。许多相同的功能也通过JConsole提供。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using the ActiveMQ list command* recipe
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用ActiveMQ list命令**的配方'
- en: The *Using the ActiveMQ dstat command* recipe
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用ActiveMQ dstat命令**的配方'
- en: Using the ActiveMQ list command
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ActiveMQ list命令
- en: The `list` command can be used to list out the brokers currently running inside
    the Karaf container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`命令可以用来列出在Karaf容器内当前运行的代理。'
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'In order to get started, we need to get the `activemq-broker` feature installed.
    Reference the `activemq:query` command, as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们需要安装`activemq-broker`功能。参考以下屏幕截图中的`activemq:query`命令：
- en: '![Getting ready](img/5081OS_03_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5081OS_03_09.jpg)'
- en: How to do it…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To list out all brokers currently running embedded inside this instance of
    Karaf, we can simply run the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出在这个Karaf实例内部当前运行的嵌入式所有代理，我们可以简单地运行以下命令：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will list out the embedded broker names as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出以下嵌入式代理名称：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This `activemq` command will invoke the `JmxMBeansUtil.getAllBrokers` class
    on the JMX connection and retrieve the name of any broker currently running.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`activemq`命令将在JMX连接上调用`JmxMBeansUtil.getAllBrokers`类，并检索任何当前正在运行的代理的名称。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using the ActiveMQ query command* recipe
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用ActiveMQ查询命令**的配方'
- en: The *Using the ActiveMQ dstat command* recipe
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用ActiveMQ dstat命令**的配方'
- en: Using the ActiveMQ dstat command
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ActiveMQ dstat命令
- en: The `dstat` command is a convenient way to see queue message statistics at a
    glance. It will list out the queues with queue size, the number of producers and
    consumers, the number of messages enqueued and dequeued, and the percentage of
    memory used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`dstat`命令是一种方便的方法，可以一眼看到队列消息统计信息。它将列出队列，包括队列大小、生产者和消费者数量、入队和出队消息数量以及内存使用百分比。'
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In order to get started, we need to get the `activemq-broker` feature installed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们需要安装`activemq-broker`功能。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have run any previous recipes, a good way to get a clean environment
    is to stop Karaf, delete the data directory, and restart. This will clean up any
    data from the previous runs. Remember to reinstall the `activemq-broker` feature
    after restarting.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行过任何之前的配方，一个好的方法是停止Karaf，删除数据目录，然后重新启动。这将清理之前运行的所有数据。记住在重新启动后重新安装`activemq-broker`功能。
- en: As an example, let's run the `activemq:dstat` command, as shown in the following
    screenshot.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们运行`activemq:dstat`命令，如下面的屏幕截图所示。
- en: '![Getting ready](img/5081OS_03_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5081OS_03_11.jpg)'
- en: Not very impressive. Without data, these commands can be pretty boring. In the
    previous screenshot, we can see that we have one queue defined at this moment
    with no message, no producers, and no consumers. So, let's get some data loaded
    to see what is happening.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并不太令人印象深刻。没有数据，这些命令可能会相当无聊。在之前的屏幕截图中，我们可以看到此刻我们定义了一个队列，没有消息，没有生产者，也没有消费者。所以，让我们加载数据来看看发生了什么。
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We need to start sending some data through the brokers in order to make this
    more entertaining and realistic. This recipe has some helper classes we can use
    to load the broker with data. This can be done as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始通过代理发送一些数据，以便使这个过程更加有趣和真实。这个配方有一些辅助类我们可以用来加载数据到代理。这可以按以下方式完成：
- en: Run the `mvn clean install` command in the example code under the *Installing
    Apache ActiveMQ modules into Apache Karaf* recipe. Then, you can run the publisher
    against the embedded ActiveMQ.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**将Apache ActiveMQ模块安装到Apache Karaf**配方下的示例代码中运行`mvn clean install`命令。然后，你可以对嵌入式ActiveMQ运行发布者。
- en: 'If no defaults have been changed from the `activemq.xml` file, then the defaults
    in the publisher code will work. We can run the publisher using the following
    command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有从 `activemq.xml` 文件更改默认值，则发布者代码中的默认值将工作。我们可以使用以下命令运行发布者：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will send 10001 messages to the broker. Now we can look at the `dstat`
    broker and see if there are any changes. The following screenshot shows the result
    from the `dstat` broker:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将向代理发送 10001 条消息。现在我们可以查看 `dstat` 代理，看看是否有任何变化。以下屏幕截图显示了 `dstat` 代理的结果：
- en: '![How to do it…](img/5081OS_03_12.jpg)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_03_12.jpg)'
- en: Using the `dstat` command, we can see that the publisher has put 10001 messages
    on the test queue and that several advisory messages have been enqueued too.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `dstat` 命令，我们可以看到发布者已经在测试队列上放置了 10001 条消息，并且还有几条通知消息已经入队。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Advisory messages are specific ActiveMQ messages that are meant to inform you
    of an event.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通知消息是特定于 ActiveMQ 的消息，旨在通知您事件。
- en: 'Now that we can see we have 10001 messages waiting in the test queue, let''s
    go ahead and consume them using our listener, using the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们可以看到我们有 10001 条消息在测试队列中等待，让我们继续使用我们的监听器使用以下命令消费它们：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will create a consumer on the queue and pull the messages off. We can
    see through the `dstat` command what is happening on our queue. This is displayed
    in the following screenshot:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在队列上创建一个消费者并拉取消息。我们可以通过 `dstat` 命令看到我们队列上发生的事情。这将在以下屏幕截图中显示：
- en: '![How to do it…](img/5081OS_03_13.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_03_13.jpg)'
- en: How it works…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `dstat` command uses the ServerInvocationHandler interface to create an
    instance of the QueueViewMBean interface or the TopicViewMBean interface using
    the JMX connection. These provide statistics on the queues or topics. The stats
    are simply listed out to the console in order to provide a high level snapshot
    of the queues/topics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`dstat` 命令使用 ServerInvocationHandler 接口通过 JMX 连接创建 QueueViewMBean 接口或 TopicViewMBean
    接口的实例。这些提供了关于队列或主题的统计信息。统计信息简单地列在控制台上，以提供队列/主题的高级快照。'
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the ActiveMQ purge command* recipe
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 ActiveMQ 清除命令* 菜谱'
- en: The *Using the ActiveMQ query command* recipe
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 ActiveMQ 查询命令* 菜谱'
- en: Using the ActiveMQ purge command
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ActiveMQ 清除命令
- en: A useful command for clearing data is the `purge` command. This can be used
    in conjunction with wildcards to clear out large numbers of queues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 清除数据的实用命令是 `purge` 命令。它可以与通配符结合使用，以清除大量队列。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have the `activemq-broker` feature installed in a similar way as done in the
    *Using the ActiveMQ dstat command* recipe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似 *使用 ActiveMQ dstat 命令* 菜谱中的方式安装 `activemq-broker` 功能。
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Before we can purge the data, we first need to load some data. We can load
    data using the example code provided in the earlier recipes. The steps are as
    follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够清除数据之前，我们首先需要加载数据。我们可以使用前面菜谱中提供的示例代码加载数据。步骤如下：
- en: 'We can run the publisher again using the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令再次运行发布者：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the `dstat` command from the earlier recipe, we can see in the following
    screenshot that we loaded 10001 messages into the test queue of our embedded broker:![How
    to do it…](img/5081OS_03_10.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面菜谱中的 `dstat` 命令，我们可以在以下屏幕截图中看到我们已将 10001 条消息加载到嵌入式代理的测试队列中：![如何做…](img/5081OS_03_10.jpg)
- en: The `purge` command will remove data from any number of queues using wildcards
    and SQL92 syntax.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`purge` 命令将使用通配符和 SQL92 语法从任意数量的队列中删除数据。'
- en: 'Now, add messages to the queue using the publisher we saw in the *Installing
    Apache ActiveMQ modules into Apache Karaf* recipe. Run it a couple of times for
    fun. Now, query the queue using the following command to see how many messages
    we have:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用我们在 *将 Apache ActiveMQ 模块安装到 Apache Karaf* 脚本中看到的发布者向队列中添加消息。为了乐趣，运行几次。现在，使用以下命令查询队列，看看我们有多少条消息：
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `*` character for the queue name will return the `EnqueueCount` value
    for all queues, but in this example, we only have the test queue anyway.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `*` 字符作为队列名称将返回所有队列的 `EnqueueCount` 值，但在这个例子中，我们只有测试队列。
- en: 'We can see that after two runs we have **20002** as the **EnqueueCount** value,
    as shown in the following screenshot:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，经过两次运行，我们的 `EnqueueCount` 值为 **20002**，如下面的屏幕截图所示：
- en: '![How to do it…](img/5081OS_03_14.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_03_14.jpg)'
- en: 'We can see thousands of messages now in the queue after running the publisher
    a couple of times. Now run the following `purge` command against the test queue:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行发布者几次之后，现在我们可以看到队列中有成千上万的消息。现在运行以下 `purge` 命令针对测试队列：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it…](img/5081OS_03_15.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_03_15.jpg)'
- en: 'The `purge` command removes all messages in the given queue. Let''s rerun the
    following `query` command to see if the queues were cleared out:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`purge` 命令会移除给定队列中的所有消息。让我们重新运行以下 `query` 命令，看看队列是否被清空：'
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `PurgeCommand` class in the ActiveMQ code base is used to purge messages
    in the selected queue. If no queue is defined, as shown in the following command,
    it will purge all messages from all queues:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveMQ代码库中的 `PurgeCommand` 类用于在所选队列中清除消息。如果没有定义队列，如以下命令所示，它将清除所有队列中的所有消息：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can use both an AMQ-specific language, which looks like `JMSPriority>2,MyHeader='Foo'`,
    or we can use the SQL-92 syntax `(JMSPriority>2) AND (MyHeader='Foo')` to select
    specific messages for deletion.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似于 `JMSPriority>2,MyHeader='Foo'` 的AMQ特定语言，或者我们可以使用SQL-92语法 `(JMSPriority>2)
    AND (MyHeader='Foo')` 来选择要删除的特定消息。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the ActiveMQ list command* recipe
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ActiveMQ列表命令* 的配方'
- en: The *Using the ActiveMQ query command* recipe
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ActiveMQ查询命令* 的配方'
- en: Using the JMS connection factory commands
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMS连接工厂命令
- en: Now that we have an embedded broker and have looked at some of the commands
    for viewing the broker properties and statistics, let's look at how to interact
    with the broker using JMS commands. In this recipe, we will look at the command
    for creating and interacting with the broker by creating a connection factory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个嵌入式代理，并且查看了一些用于查看代理属性和统计信息的命令，让我们看看如何使用JMS命令与代理交互。在这个配方中，我们将通过创建连接工厂来查看创建和与代理交互的命令。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In order for us to control the connection factory and send messages to the
    embedded broker, first we need to install the required commands using the following
    JMS feature command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们能够控制连接工厂并向嵌入式代理发送消息，我们首先需要使用以下JMS功能命令安装所需的命令：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the *Tab* key, we will see a list of the JMS commands available for creating,
    sending, and browsing messages as well as creating connection factories. These
    commands are listed in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Tab* 键，我们将看到可用于创建、发送、浏览消息以及创建连接工厂的JMS命令列表。这些命令在以下屏幕截图中列出：
- en: '![Getting ready](img/5081OS_03_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5081OS_03_16.jpg)'
- en: First, let's create a connection factory for our embedded broker. We do this
    using the `jms:create` command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的嵌入式代理创建一个连接工厂。我们使用 `jms:create` 命令来完成这项工作。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to reference the `--help` command for required and optional parameters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必参考 `--help` 命令以获取所需和可选参数。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s create a connection factory first so that we can mess around with sending
    messages. All that is needed to create a connection factory is the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个连接工厂，这样我们就可以发送消息了。创建连接工厂只需要以下命令：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, for this example, a command like the following will work to make a connection
    of type `-t activemq` to the URL `-u tcp://localhost:61616`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个例子，以下命令将用于将类型为 `-t activemq` 的连接到 URL `-u tcp://localhost:61616`：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This will create a connection factory using the ActiveMQConnectionFactory as
    defined by the `–t` option (the other option is WebsphereMQ). We can verify that
    our factory was indeed set up by performing a `la` command from the command line.
    Your last entry should look something like the following command-line output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用由 `–t` 选项定义的 ActiveMQConnectionFactory 创建连接工厂（另一个选项是 WebsphereMQ）。我们可以通过在命令行中执行
    `la` 命令来验证我们的工厂确实已设置。你的最后一条条目应该类似于以下命令行输出：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the pattern for the XML file naming is `connectionfactory-<name>.xml`.
    In the case of our example, we used the name 'cookbook'. If this is not the last
    entry, or you do not see it, try using the `la | grep cookbook` command.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，XML文件命名的模式是 `connectionfactory-<name>.xml`。在我们的例子中，我们使用了名称 'cookbook'。如果不是最后一个条目，或者你没有看到它，尝试使用
    `la | grep cookbook` 命令。
- en: A file called `connectionfactory-cookbook.xml` was created in the `deploy` directory
    of the Karaf instance, which is shown in the following code. This file is a Blueprint
    XML file that will instantiate the connection factory, pooled connection factory,
    the resource manager, and the transaction manager.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karaf实例的`deploy`目录中创建了一个名为`connectionfactory-cookbook.xml`的文件，如下面的代码所示。这是一个Blueprint
    XML文件，它将实例化连接工厂、池化连接工厂、资源管理器和事务管理器。
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The pooled connection factory is added to the services with a JNDI name of `jms/cookbook`.
    The important piece of information to note here is the `–u` option that is used
    to define the URL for the connection based on which the connection pool is also
    created. This is an important input from a system resource management perspective.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 池化连接工厂以JNDI名称`jms/cookbook`添加到服务中。这里需要注意的重要信息是用于定义基于该URL的连接的`-u`选项，这也基于该URL创建了连接池。这对于系统资源管理方面是一个重要的输入。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using the JMS send command* recipe
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用JMS发送命令*菜谱'
- en: Using the JMS send command
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMS发送命令
- en: When debugging or testing code, it is very handy to be able to send messages
    to a specific queue. This can be done from the command console in Karaf using
    the JMS subshell.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试或测试代码时，能够向特定队列发送消息是非常方便的。这可以通过在Karaf的命令控制台中使用JMS子shell来完成。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that the JMS feature is installed and available. In order to use most
    of the commands via JMS, we need to have a connection factory created (see the
    *Using the JMS connection factory commands* recipe).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 确保JMS功能已安装并可用。为了通过JMS使用大多数命令，我们需要创建一个连接工厂（参见*使用JMS连接工厂命令*菜谱）。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, let''s make sure the service is in place using the `info` command. The
    connection factory can be referenced either from the specified name `cookbook`
    or by the JNDI service name `jms/cookbook`, as we can see in the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`info`命令确保服务到位。连接工厂可以通过指定的名称`cookbook`或JNDI服务名称`jms/cookbook`来引用，如下面的命令所示：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have verified the JMS connection factory, we can use it to send
    messages to the broker. This can be done using the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了JMS连接工厂，我们可以使用它向代理发送消息。这可以通过以下命令完成：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will send a message, `the recipes are sweet`, to `cookbookQueue` using
    the JNDI name for our connection factory `jms/cookbook`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用我们连接工厂的JNDI名称`jms/cookbook`向`cookbookQueue`发送一条消息，`the recipes are sweet`。
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The `send` command will package up the string variable in the command line
    and put it in a JMS message, and then send the message to the specified queue.
    If you look at the command line, there are three parameters, which are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`命令将包装命令行中的字符串变量，并将其放入JMS消息中，然后将消息发送到指定的队列。如果您查看命令行，有三个参数，如下所示：'
- en: The JNDI reference to the connection factory
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到连接工厂的JNDI引用
- en: The name of the queue we are sending the message to
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要发送消息到的队列名称
- en: The message body
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息体
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Check out the `browse` command to see how to view the message you just sent
    to the broker. You can also see it at [http://karaf.apache.org/manual/latest/users-guide/jms.html](http://karaf.apache.org/manual/latest/users-guide/jms.html).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`browse`命令以了解如何查看您刚刚发送到代理的消息。您也可以在[http://karaf.apache.org/manual/latest/users-guide/jms.html](http://karaf.apache.org/manual/latest/users-guide/jms.html)中查看。
- en: Using the JMS browse command
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMS浏览命令
- en: Now that we have an embedded broker and have looked at some of the commands
    for viewing the broker properties and statistics, let's look at how to interact
    with the broker using commands. In this recipe, we will look at the command for
    browsing messages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个嵌入式代理并且查看了一些用于查看代理属性和统计信息的命令，让我们看看如何使用命令与代理交互。在这个菜谱中，我们将查看浏览消息的命令。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order for us to control the connection factory and send messages to the
    embedded broker, first we need to get the commands installed using the following
    JMS feature command, like we did in the previous recipe:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够控制连接工厂并向嵌入式代理发送消息，我们首先需要使用以下JMS功能命令安装命令，就像我们在前面的菜谱中所做的那样：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, let's create a connection factory for our embedded broker. We do this
    using the `jms:create` command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的嵌入式代理创建一个连接工厂。我们使用`jms:create`命令来完成此操作。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to reference the `--help` command for required or optional parameters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要参考`--help`命令以获取所需或可选参数。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The real meat and potatoes of this command is the ability to browse the messages
    in the queue. An example `browse` command is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的实际核心是浏览队列中消息的能力。以下是一个示例 `browse` 命令：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This allows you to see the message content, persistence (delivery mode), expiration,
    ID, the replyTo value, destination, and so on. It is a quick way to monitor what
    is in the queue at any given time. The output of the preceding `browse` command
    is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您查看消息内容、持久性（投递模式）、过期时间、ID、回复到值、目的地等。这是在任何给定时间监控队列中内容的快速方法。前面 `browse` 命令的输出如下：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Browsing messages in the queue is simple. The parameters on the command line
    tell the `browse` command what connection factory to use and what queue to browse.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中浏览消息很简单。命令行上的参数告诉 `browse` 命令使用哪个连接工厂以及要浏览哪个队列。
- en: Configuring and deploying a master/slave broker with Apache Karaf
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 配置和部署主/从代理
- en: In this recipe, we will set up and deploy two Karaf instances with embedded
    ActiveMQ in a master/slave configuration. This is used for high availability in
    messaging systems. This will allow systems to continue functioning in case of
    a failure of the active instance.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将设置和部署两个带有嵌入式 ActiveMQ 的 Karaf 实例，配置为主/从配置。这用于消息系统中的高可用性。这将允许系统在活动实例失败的情况下继续运行。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First we need to get two instances of Karaf started up with an embedded broker.
    If we are doing this on two different machines, it is actually easier since we
    will not have port conflicts when using the defaults on both machines. Keep in
    mind that if you decide to run this deployment on a single machine, one of the
    instances of Jetty and ActiveMQ embedded in Karaf needs to have its ports changed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启动两个带有嵌入式代理的 Karaf 实例。如果我们在这两台不同的机器上执行此操作，实际上会更简单，因为我们不会在两台机器上使用默认值时遇到端口冲突。记住，如果你决定在单台机器上运行此部署，Karaf
    中嵌入的 Jetty 和 ActiveMQ 中的一个实例需要更改其端口。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Since we can only assume that we have one machine to work with, we will go
    over how to get two instances of Karaf running on a single machine. We can create
    a second instance by unzipping the Karaf `.zip` or `.tar` file to a new directory
    or just copy and paste the current instance to a new directory. Now, we have to
    change the port setting on one of the instances. This can be done using the following
    steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只能假设我们有一台机器可以工作，我们将介绍如何在单台机器上运行两个 Karaf 实例。我们可以通过将 Karaf 的 `.zip` 或 `.tar`
    文件解压到新目录或直接复制粘贴当前实例到新目录来创建第二个实例。现在，我们必须更改其中一个实例的端口号设置。这可以通过以下步骤完成：
- en: 'Open the `org.apache.karaf.management.cfg` file and locate the following lines
    of code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `<karaf-home>/etc/` 文件夹中的 `org.apache.karaf.management.cfg` 文件，找到以下代码行：
- en: '[PRE31]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alter the port to something not in use, say `1096`. Then, alter the RMI server
    connection port as shown in the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将端口更改为未使用的端口，例如 `1096`。然后，如以下代码所示更改 RMI 服务器连接端口：
- en: '[PRE32]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can change this to something like `44446`. Now, we can start up the second
    instance without port conflicts. But we are not done yet. We still have to configure
    the ActiveMQ instances for failover.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将其更改为类似 `44446` 的值。现在，我们可以启动第二个实例而不会发生端口冲突。但我们的工作还没有完成。我们仍然需要配置 ActiveMQ
    实例以实现故障转移。
- en: 'Make the following changes to instance 1 and instance 2 of Karaf:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Karaf 的实例 1 和实例 2 进行以下更改：
- en: 'Open the `org.apache.activemq.server-default.cfg` file of the `<karaf-home>/etc/`
    folder and change the following code to a hardcoded location on the disk:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `<karaf-home>/etc/` 文件夹中的 `org.apache.activemq.server-default.cfg` 文件，将以下代码更改为磁盘上的硬编码位置：
- en: '[PRE33]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An example might be something like the following code:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个示例可能如下所示：
- en: '[PRE34]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open the `jetty.xml` file of the `<karaf-home>/etc/` folder and change the
    value of `jetty.port` to something like `8186`, as shown in the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `<karaf-home>/etc/` 文件夹中的 `jetty.xml` 文件，将 `jetty.port` 的值更改为类似 `8186` 的值，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open the `org.apache.karaf.shell.cfg` file of the `<karaf-home>/etc/` folder
    and change the value of `sshPort` to something like `8106`, as shown in the following
    code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `<karaf-home>/etc/` 文件夹中的 `org.apache.karaf.shell.cfg` 文件，将 `sshPort` 的值更改为类似
    `8106` 的值，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since we are running both ActiveMQ instances on the same machine, it would
    be more complete to change the port on the second ActiveMQ instance to a different
    port, although this is not required since the port is not allocated until ActiveMQ
    gets a lock on the file location (this step is optional in this configuration;
    however, it is more important in a Network of Brokers configuration on a single
    machine as both instances are active). This can be done as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在同一台机器上运行两个 ActiveMQ 实例，因此将第二个 ActiveMQ 实例的端口更改为不同的端口会更完整，尽管这不是必需的，因为端口只有在
    ActiveMQ 锁定文件位置后才会分配（在这个配置中，这一步是可选的；然而，在单台机器上的代理网络配置中更为重要，因为两个实例都是活动的）。可以按照以下方式完成：
- en: '[PRE37]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After changing the configuration files, save them and start both instances
    of Karaf. Install the `activemq-broker` feature on instance 1 as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改配置文件后，保存它们并启动 Karaf 的两个实例。在实例 1 上按照以下方式安装 `activemq-broker` 功能：
- en: '[PRE38]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will see that the embedded ActiveMQ instance starts up without issue. Now
    do the same on instance 2 and look at the log of instance 2 in the `karaf.log`
    file in the `data/log` folder.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到嵌入式 ActiveMQ 实例启动没有问题。现在在实例 2 上做同样的事情，并查看 `data/log` 文件夹中的 `karaf.log`
    文件中的实例 2 的日志。
- en: 'Search the logfile of instance 2 for the phrase `could not be locked`. We will
    see the following output line:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例 2 的日志文件中搜索短语 `could not be locked`。我们将看到以下输出行：
- en: '[PRE39]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This indicates that the second embedded broker instance is in a wait state
    and not fully instantiated. To see instance 2 start up and initialize, press *Ctrl*
    + *D* on instance 1 (to shut down the instance). If you are tailing the logfile
    or you refresh the logfile in your viewer, you will see the following output:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表明第二个嵌入式代理实例处于等待状态，并未完全实例化。要查看实例 2 的启动和初始化，请在实例 1 上按 *Ctrl* + *D*（以关闭实例）。如果您正在跟踪日志文件或刷新您的查看器中的日志文件，您将看到以下输出：
- en: '[PRE40]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This indicates that the slave broker on instance 2 has started up and initialized
    the connections.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明实例 2 上的从代理已启动并初始化了连接。
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: ActiveMQ gives us high availability via a couple of options. In the case of
    this recipe, we are using file-based persistence (`kahadb`). This allows us to
    point both instances at the same data file location to establish the master or
    the slave. The first instance to start up will get a lock on the file location
    and then finish initializing. The other instance will look at the same file location
    and see that a lock has already been established. Then, it will log the IOException
    and wait for the default 10 seconds before trying again.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveMQ 通过几个选项为我们提供了高可用性。在本食谱的情况下，我们使用基于文件的持久性（`kahadb`）。这允许我们将两个实例指向相同的数据文件位置以建立主实例或从实例。第一个启动的实例将锁定文件位置，然后完成初始化。另一个实例将查看相同的文件位置，并看到已经建立了锁定。然后，它将记录
    IOException 并在默认的 10 秒后再次尝试。
- en: '![How it works…](img/5081OS_03_17.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_03_17.jpg)'
- en: The previous diagram shows that the master ActiveMQ instance has established
    a lock from the file location. It has instantiated all the connections configured
    in the `activemq.xml` file under the `etc` folder as defined by the transport
    connection elements. This allows clients to now connect to the master instance.
    Once an instance is shut down, those connections are killed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示显示主 ActiveMQ 实例已从文件位置建立锁定。它已实例化了在 `etc` 文件夹下由传输连接元素定义的 `activemq.xml` 文件中配置的所有连接。这允许客户端现在连接到主实例。一旦实例关闭，这些连接将被终止。
- en: 'Consider that the clients are configured with a failover protocol to the slave
    instance as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户端已配置为使用以下故障转移协议连接到从实例：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The client machines will automatically reconnect to the slave machine once
    the secondary broker finishes initializing. This is demonstrated in the following
    diagram:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦辅助代理完成初始化，客户端机器将自动重新连接到从机器。这在下图中得到演示：
- en: '![How it works…](img/5081OS_03_18.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_03_18.jpg)'
- en: At this point, we can restart the original master (instance 1) and that will
    now wait to get a lock on the file. This gives us the master/slave setup without
    having to restart instances or restore data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以重新启动原始主实例（实例 1），它现在将等待获取文件锁定。这使我们能够在不重新启动实例或恢复数据的情况下获得主/从设置。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Configuring and deploying a Network of Brokers with Apache Karaf* recipe
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Apache Karaf 配置和部署代理网络* 食谱'
- en: Configuring and deploying a Network of Brokers with Apache Karaf
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 配置和部署代理网络
- en: Many times, a single system may not be enough to handle the load of the applications.
    In this case, scaling is needed to balance load across multiple systems. We can
    scale applications using embedded ActiveMQ instances in a **Network of Brokers**
    (**NoB**) configuration.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，单个系统可能不足以处理应用程序的负载。在这种情况下，需要扩展以在多个系统之间平衡负载。我们可以使用**代理网络**（**NoB**）配置中的嵌入式ActiveMQ实例来扩展应用程序。
- en: This is different from a master/slave configuration because we will have two
    active instances rather than an active and passive pair.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这与主/从配置不同，因为我们会有两个活动实例，而不是一个活动实例和一个被动实例。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By following the same initial setup in the previous recipe, we need to have
    two instances of Karaf running. We can prove this concept on a single machine
    or multiple machines. For this recipe, we will again be showing you how to set
    up two instances on the same machine, which requires different ports to be used
    for the different Karaf instances.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循上一个配方中的相同初始设置，我们需要运行两个Karaf实例。我们可以在单个机器或多个机器上证明这个概念。对于这个配方，我们再次将向您展示如何在同一台机器上设置两个实例，这需要为不同的Karaf实例使用不同的端口。
- en: Ensure that the defaults for the two instances are in place.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 确保两个实例的默认设置就绪。
- en: How to do it…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Please follow these steps to configure and deploy a Network of Brokers configuration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤配置和部署一个代理网络配置：
- en: 'Open the `org.apache.activemq.server-defaults.cfg` file of the `<karaf-home>/etc/`
    folder and make sure the following data value is set:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`<karaf-home>/etc/`文件夹下的`org.apache.activemq.server-defaults.cfg`文件，并确保以下数据值已设置：
- en: '[PRE42]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will tell the embedded ActiveMQ instance to use a local data folder defined
    by the parameters mentioned earlier.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将告诉嵌入式ActiveMQ实例使用前面提到的参数定义的本地数据文件夹。
- en: 'Change the instance 1 option for broker name to `recipe-3-broker-1` and change
    the instance 2 option for broker name to `recipe-3-broker-2`. So, the values in
    the file should look like the following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例1的代理名称选项更改为`recipe-3-broker-1`，并将实例2的代理名称选项更改为`recipe-3-broker-2`。因此，文件中的值应如下代码所示：
- en: '[PRE43]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That way, it is easy to differentiate between brokers when looking at them using
    JMX. The `karaf.data` property is a system property that is set based on the Karaf
    location.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，在通过JMX查看时，可以很容易地区分不同的代理。`karaf.data`属性是基于Karaf位置设置的系统属性。
- en: 'For this recipe, let''s work with instance 2\. First, we have to alter the
    `etc/activemq.xml` file to have a network connector that links it with the instance.
    The following is the XML code that needs to be added:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，让我们处理实例2。首先，我们必须修改`etc/activemq.xml`文件，以使其具有一个网络连接器，将其与实例连接起来。以下是需要添加的XML代码：
- en: '[PRE44]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note the URI has the static protocol with a TCP connection to the instance 1
    port (in this case, the default port was left on instance 1 as `61616`). We turn
    on duplex to allow two-way communication through a single pipe and pass the username
    and password.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意URI具有静态协议，通过TCP连接到实例1的端口（在这种情况下，实例1的默认端口被保留为`61616`）。我们打开双工，允许通过单个管道进行双向通信，并传递用户名和密码。
- en: 'In order to avoid port conflicts, we need to change the transport connector
    port on instance 2 to something other than `61616`, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免端口冲突，我们需要将实例2的传输连接器端口更改为除了`61616`之外的其他端口，如下所示：
- en: '[PRE45]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'One more change and we are ready to test. We need to change the port in the
    `jetty.xml` file under the `etc` folder. By default, the port is `8181`, but since
    instance 1 is using that, we need to change instance 2 to something else. For
    this recipe, I have used `8182`, as shown in the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再做一次更改，我们就可以开始测试了。我们需要更改位于`etc`文件夹下的`jetty.xml`文件中的端口。默认端口是`8181`，但由于实例1正在使用该端口，我们需要将实例2的端口更改为其他端口。对于这个配方，我使用了`8182`，如下代码所示：
- en: '[PRE46]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can start up both instances now. If we monitor the logs for instance 2,
    we will see the following output:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以启动这两个实例。如果我们监控实例2的日志，我们将看到以下输出：
- en: '[PRE47]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The log entries indicate that instance 2 has found instance 1 and established
    a connection between the two.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 日志条目表明实例2已找到实例1，并在两者之间建立了连接。
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Network of Brokers configuration can be used for two different topologies:
    vertical or horizontal. First, let''s look at horizontal, which is more for scaling
    purposes. This type of topology will often be used to provide great throughput
    for a system. The main idea is to NOT increase the number of brokers a message
    must pass through in order to be consumed by your application. Rather, it is designed
    to balance load across multiple servers. Notice in the following diagram that
    there are two client machines attached to each instance allowing each broker/Karaf
    pair to only have to process the messages for two clients.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 经纪人网络配置可用于两种不同的拓扑：垂直或水平。首先，让我们看看水平扩展，这更多的是为了扩展目的。这种拓扑通常用于为系统提供极高的吞吐量。主要思想是不要增加消息必须通过的数量，以便被您的应用程序消费。相反，它旨在平衡多个服务器之间的负载。注意在以下图中，每个实例都连接了两个客户端机器，使得每个经纪人/Karaf对只需处理两个客户端的消息。
- en: Tip
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Each broker instance has its own message store and is not considered a highly
    available topology.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每个经纪人实例都有自己的消息存储，并且不被认为是高可用拓扑。
- en: 'Even though clients can failover from one client to the other, persisted data
    is not shared between the instances. This means that if one instance of the broker
    dies, then the pending messages in that store are not processed until the broker
    is restarted, even though the clients move over to the one active broker instance.
    Have a look at the following diagram:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使客户端可以从一个客户端切换到另一个客户端，持久化数据在实例之间并不共享。这意味着如果经纪人实例中的一个实例死亡，那么在该存储中的挂起消息将不会处理，直到经纪人重新启动，尽管客户端已经切换到活动的经纪人实例。看看以下图示：
- en: '![How it works…](img/5081OS_03_19.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/5081OS_03_19.jpg)'
- en: The benefit to having a network of brokers is the ability to forward messages
    to idle clients. If a message is produced to the local **broker 1** but all the
    clients are busy, then ActiveMQ will forward the message to any idle clients on
    **broker 2**. This is considered horizontal scaling.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个经纪人网络的好处是能够将消息转发给空闲的客户。如果一个消息被发送到本地的**经纪人1**，但所有客户都在忙碌，那么ActiveMQ会将消息转发到**经纪人2**上的任何空闲客户。这被认为是水平扩展。
- en: There's more…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There is also the notion of vertical scaling. But this has an entirely different
    use case. When using vertical scaling, the obstacle is usually not performance.
    In most cases, vertical scaling is used for communication problems over a WAN.
    A good example of this is outlined in the following diagram:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 还有垂直扩展的概念。但这有一个完全不同的用例。当使用垂直扩展时，通常不是性能问题。在大多数情况下，垂直扩展用于WAN上的通信问题。以下图示中概述了一个很好的例子：
- en: '![There''s more…](img/5081OS_03_20.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/5081OS_03_20.jpg)'
- en: In the previous diagram, an embedded ActiveMQ is used locally to avoid application
    downtime if the connection between Los Angeles and Dallas is lost. So, the local
    application will communicate directly with the local instance without worrying
    if the WAN is up or down. Then, the local ActiveMQ will be in charge of establishing
    and maintaining the connection to the backend service.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，使用本地嵌入的ActiveMQ以避免在洛杉矶和达拉斯之间的连接丢失时导致应用程序停机。因此，本地应用程序将直接与本地实例通信，无需担心WAN是否在线。然后，本地ActiveMQ将负责建立和维护与后端服务的连接。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a performance cost to vertical scaling.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展会有性能成本。
- en: 'Vertical scaling is forcing a two-broker hop. So, you have to figure out which
    is more important from the requirements: performance or stability.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展会强制进行两个经纪人的跳转。因此，您必须确定从需求中哪个更重要：性能或稳定性。
- en: See also
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Configuring* *and deploying a master/slave broker with Apache Karaf* recipe
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置*和*部署*Apache Karaf的master/slave经纪人食谱'
