<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Reactive Design Patterns</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will explore one of the most important features of the Spring 5 Framework, which is reactive pattern programming. The Spring 5 Framework introduced this new feature with the Spring web reactive module. We will discuss this module in this chapter. Before that, let's have a look at reactive patterns. What is the reactive pattern, and why is it growing more popular nowadays? I will start my discussion on reactive pattern with the following statement made by <strong>Satya Nadella</strong>, CEO, Microsoft Corporation:</p>
<div class="packt_quote">Every business out there now is a software company, is a digital company.</div>
<p>The topics we will cover here are as follows:</p>
<ul>
<li>Why reactive pattern?</li>
<li>The reactive pattern principles</li>
<li>Blocking calls</li>
<li>Non-blocking calls</li>
<li>Back-pressure</li>
<li>Implementing the reactive pattern using the Spring Framework</li>
<li>The Spring web reactive module</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding application requirement over the years</h1>
                </header>
            
            <article>
                
<p>If you go back 10 to 15 years, there were very few internet users, and far less online portals for end users compared to what we have today. Nowadays, we cannot think of a life without a computer or without any online system. In short, we have become extremely dependent on computers and online computing for personal as well as business use. Every business model is moving towards digitalization. The Prime Minister of India, Mr. Narendra Damodardas Modi has launched a Digital India campaign to ensure that the Government's services are made available to citizens electronically by improved online infrastructure, increasing internet connectivity, and by making the country digitally empowered in the field of technology.</p>
<p>All this implies that the number of internet users is increasing dramatically. According to the Ericsson Mobility Report,</p>
<div class="packt_quote">The Internet of Things (IoT) is expected to surpass mobile phones as the largest category of connected devices in 2018.</div>
<p>There has been a tremendous growth of mobile internet users, and there is no sign of that slowing down anytime soon. In these sectors, by definition, the server side has to handle millions of connected devices concurrently. The following table compares the infrastructure and application requirements today with the requirement from 10 years back:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Requirements</strong></td>
<td><strong>Now</strong></td>
<td><strong>Ten years ago</strong></td>
</tr>
<tr>
<td><strong>Server nodes</strong></td>
<td>More than 1000 nodes required.</td>
<td>Ten nodes were enough.</td>
</tr>
<tr>
<td><strong>Response times</strong></td>
<td>Takes milliseconds to serve requests, and send back responses.</td>
<td>Took seconds to response.</td>
</tr>
<tr>
<td><strong>Maintenance downtimes</strong></td>
<td>Currently, there is no or zero maintenance downtime required.</td>
<td>Took hours of maintenance downtime.</td>
</tr>
<tr>
<td><strong>Data volume</strong></td>
<td>Data for the current application that increased to TBs from PBs.</td>
<td>Data was in GBs.</td>
</tr>
</tbody>
</table>
<p>You can see the differences in the requirement of resources in the preceding table. These requirements have increased, because we now expect responses immediately, within the second. At the same time, the complexity of tasks given to computers have also increased. These tasks are not just pure computation in a mathematical sense, but also in requesting the responses to be distilled from enormous amounts of data. So, now we have to focus the performance of such systems by designing a single computer in the form of multi-core CPUs, possibly, combined in multi-socket servers. The first thing on our minds is to make the system responsive. It is the first of the reactive traits-responsiveness. We will explore more of this in this chapter, along with the following topics:</p>
<ul>
<li>Why reactive pattern</li>
<li>Reactive pattern principles</li>
<li>Blocking calls</li>
<li>Non-blocking calls</li>
<li>Back-pressure</li>
<li>Implementing reactive pattern using the Spring Framework</li>
<li>Spring Web reactive module</li>
<li>Implementing reactive at server side</li>
<li>Implementing reactive at client side</li>
<li>Request and response body type conversion</li>
</ul>
<p>This chapter will teach you how to make a system responsive in the face of any variable load, partial outages, program failure, and more. Nowadays, systems are distributed across different nodes to efficiently serve requests.</p>
<p>Let's look at the aforementioned topics in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the reactive pattern</h1>
                </header>
            
            <article>
                
<p>Today, the modern applications must be more robust, more resilient, more flexible, and better positioned to meet the requirements of the organizations, because, in the recent couple of years, the requirements for applications have changed dramatically. As we have seen in the last table, 10 to 15 years ago, a large application had 10 server nodes, the response time taken to serve a request was in seconds, we required a couple of hours of downtime for maintenance and deployment, and the data was in gigabytes. But today, an application requires thousands of server nodes, because it is accessed by multiple channels such as mobile devices. The server responses are expected within milliseconds, and the downtime for deployment and maintenance is near to 0%. Data has been increased from terabytes to petabytes.</p>
<p>Ten-year old systems cannot fulfill the requirements of today's applications; we need a system that can fulfill all user's requirements either at the application level or the system level, which means we need a responsive system. Responsiveness is one of the properties of the reactive pattern. We want a system that must be responsive, resilient, elastic, and message-driven. We know these systems as reactive systems. These systems are more flexible, loosely-coupled, and scalable.</p>
<p>A system must react to failure and stay available, that is, it should be resilient, and the system must react to variable load conditions, and not be overloaded. The system should react to events--event-driven or message-driven. If all these properties are associated with a system, then it will be responsive, that is, if a system reacts to its users, it is responsive. To create a reactive system, we must focus on the system level and application level. Let's see first the all reactive traits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The reactive pattern traits</h1>
                </header>
            
            <article>
                
<p>The following are the principles of the Reactive pattern:</p>
<ul>
<li><strong>Responsive</strong>: This is the goal of each application today.</li>
<li><strong>Resilient</strong>: This is required to make an application responsive.</li>
<li><strong>Scalable</strong>: This is also required to make an application responsive; without resilience and scalability, it is impossible to achieve responsiveness.</li>
<li><strong>Message-driven</strong>: A message-driven architecture is the base of a scalable and resilient application, and ultimately, it makes a system responsive. Message-driven either based on the event-driven or actor-based programming model.</li>
</ul>
<p>The preceding points mentioned are core principles of the reactive pattern. Let's explore each principle of the reactive pattern in detail, and understand why all of them must be applied together in order to make a reactive system with quality software for a modern context application, which is able to handle millions of parallel requests in milliseconds without any failure. Let's first understand these principles with the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="131" width="218" src="assets/1b916152-d20b-4250-a1a2-b7ee0e54c418.png"/></div>
<p>As you can see in the preceding diagram, to make a system reactive, we need scalability and resilience. To make a system scalable and resilient, we need an event-driven or message-driven architecture of the application. Ultimately, these principles, scalability, resilience, and event-driven architecture make a system responsive to the client. Let's see these properties in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Responsiveness</h1>
                </header>
            
            <article>
                
<p>When we say that a system or an application is responsive, it means that the application or system responds quickly to all users in a given time in all conditions, and that is in good condition as well as bad. It ensures a consistent positive user experience.</p>
<p>Responsiveness is required for a system for usability and utility. A responsive system means that up on system failure, either because of an external system or a spike in traffic, the failures are detected quickly, and dealt with effectively in a short time without the users knowing of the failure. An end user must be able to interact with the system by providing rapid and consistent response times. A user must not face any failure during interaction with the system, and it must deliver a consistent quality of service to the user. That consistent behavior solves the failures and builds end-user confidence in the system. Quickness and a positive user experience under various conditions make a system responsive. It depends on the two other traits of a reactive application or system, that is, resilience and scalability. Another trait, that is, event-driven or message-driven architecture, provides the overall foundation for a responsive system. The following diagram illustrates a responsive system:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="216" width="289" src="assets/76c032b0-0a17-4b9f-ab4f-38870c843f2f.png"/></div>
<p>As you can see in the preceding diagram, a responsive system depends on resilient and scalability of the system, and these depend on its event-driven architecture. Let's look at the other traits of a reactive application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resilience</h1>
                </header>
            
            <article>
                
<p>When we design and develop a system, we have consider all conditions--good and bad. If we consider only the good conditions, then we tend to implement a system that may fail after just a few days. A major application failure results in downtime and data loss and damages your application's reputation in the market.</p>
<p>So, we have to focus on every condition to ensure the responsiveness of the application under all conditions. Such a system or application is known as a resilient system.</p>
<p>Every system must be resilient to ensure responsiveness. If a system is not resilient, it will be unresponsive after a failure. So, a system must be responsive in the face of failure as well. In the whole system, failure can exist in any component of the application or system. So, each component in the system must be isolated from each other so that at the time of failure of a component, we can recover it without compromising the system as a whole. Recovery of an individual component is achieved by replication. If a system is resilient, then it must have replication, containment, isolation, and delegation. Take a look at the following diagram, which illustrates the resilient traits of a reactive application or system:</p>
<div class="CDPAlignCenter CDPAlign"><img height="205" width="385" class=" image-border" src="assets/b591206b-d282-49de-a9e3-00e5a213624e.png"/></div>
<p>As you can see in the preceding diagram, resilience is achieved by replication, containment, isolation, and delegation. Let's discuss these points in detail:</p>
<ul>
<li><strong>Replication</strong>: This ensures high-availability, where necessary, at the time of component failure.</li>
<li><strong>Isolation</strong>: This means that the failure of each component must be isolated, which is achieved by decoupling the components as much as possible. Isolation is needed for a system to self-heal. If your system has isolation in place, then you can easily measure the performance of each component, and check the memory and CPU usage. Moreover, the failure of one component won't impact the responsiveness of the overall system or application.</li>
<li><strong>Containment</strong>: The result of decoupling is containment of the failure. It helps avoid failure in the system as a whole.</li>
<li><strong>Delegation</strong>: After failure, the recovery of each component is delegated to another component. It is possible only when our system is composable.</li>
</ul>
<p>Modern applications not only depend on the internal infrastructure but are also integrated with other web services via network protocols. So, our applications must be resilient at their core in order to stay responsive under a variety of real-world in the opposite conditions. Our applications must not only be resilient at the application level but also at the system level.</p>
<p>Let's see another principle of the reactive pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scalable</h1>
                </header>
            
            <article>
                
<p>Resiliency and scalability together make a system consistently responsive. A scalable system or an elastic system can easily be upgraded under a varying workload. A reactive system can be made scalable on demand by increasing and decreasing the resources allocated to service these inputs. It supports multiple scaling algorithms by providing relevant live performance for the scalability of the application. We can achieve scalability by using cost-effective software and cheap commodity hardware (for example, the Cloud).</p>
<p>An application is scalable if it can be extended according to its usage, in the following ways:</p>
<ul>
<li><strong>scale-up</strong>: It makes use of parallelism in multi-core systems.</li>
<li><strong>scale-out</strong>: It makes use of multi-server nodes. Location transparency and resilience are important for this.</li>
</ul>
<p>Minimizing the shared mutable state is very important for scalability.</p>
<div class="packt_infobox">Elasticity and Scalability are both the same! Scalability is all about the efficient use of resources already available, while elasticity is all about adding new resources to your application on demand when the needs of the system changed. So, eventually, the system can be made responsive anyway--by either using the existing resources of the system or by adding new resources to the system.</div>
<p>Let's see the final foundation of the resilient and scalability of the reactive pattern, that is, message-driven architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message-driven architecture</h1>
                </header>
            
            <article>
                
<p>A message-driven architecture is the base of a responsive application. A message-driven application can be an event-driven and actor-based application. It can also be a combination of both architectures--event-driven and actor-based architecture.</p>
<p>In event-driven architecture, events and event observers play the main role. Events happen, but are not directed to a specific address; event listeners listen to these events, and take actions. But in message-driven architecture, the messages have a proper direction to the destination. Let's look at the following diagram that illustrates message-driven and event-driven architectures:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="269" width="427" class=" image-border" src="assets/e69c809d-c56b-4a96-a15e-7904e66edfeb.png"/></div>
<p>As you can see in the preceding diagram, in event-driven architecture, if an event happens, then listeners listen to it. But in the message-driven one, one generated message communication has an addressable recipient and a single purpose.</p>
<p>Asynchronous message-driven architecture acts as the foundation for a reactive system by establishing limitations between the components. It ensures loose coupling, isolation, and location transparency. Isolation between components fully depends on the loose coupling between them. And isolations and loose coupling develop the base of resilience and elasticity.</p>
<p>A large system has multiple components. These components either have smaller applications, or they may have reactive properties. This means that the reactive design principles have to apply at all levels of the scale to make a large system composable.</p>
<p>Traditionally, large systems are composed of multiple threads which communicate with a shared synchronized state. It tends to have strong coupling and is hard to compose, and it also tends to block stage. But, for now, all large systems are composed of loosely coupled event handlers. And events can be handled asynchronously without blocking.</p>
<p>Let's look at the blocking and non-blocking programming models.</p>
<p>In very simple terms, reactive programming is all about non-blocking applications that are asynchronous and event-driven, and require a small number of threads to scale vertically rather than horizontally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocking calls</h1>
                </header>
            
            <article>
                
<p>In a system, a call may be holding the resources while other calls wait for the same resources. These resources are released when the other one finishes using them.</p>
<p>Let's come to the technical words--actually, blocking a call means some operations in the application or system that take a longer time to complete, such as file I/O operations and database access using blocking drives. The following is a diagram of blocking calls for the JDBC operation in a system:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="303" width="430" class=" image-border" src="assets/d4aa2b1f-c8de-47a7-b760-c385e8b9a639.png"/></div>
<p>As you can see in the preceding diagram, the blocking operations, shown here in red, are the ones where the user calls the servlet to fetch data, then that moves to the JDBC and DB connection with the DB server. Until that time, the current thread waits for the result set from the DB server. If the DB server has latency, then this wait time can increase. That means that thread execution depends on the DB server latency.</p>
<p>Let's look at how to make this a non-blocking execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Non-blocking calls</h1>
                </header>
            
            <article>
                
<p>Non-blocking execution of a program means that a thread competes for a resource without waiting for it. A non-blocking API for the resources allows calling the resources without waiting for the blocked call such as database access and network calls. If the resources are not available at the time of calling, then it moves to other work rather than waiting for the blocked resources. The system is notified when the blocked resources are available.</p>
<p>Take a look at the following diagram that shows the JDBC connection to access data without the blocking thread execution:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="312" width="441" class=" image-border" src="assets/1398578c-a083-4e21-add1-7a9c3ef15c01.png"/></div>
<p>As you can see in the preceding diagram, thread execution does not wait for the result set from the DB server. The thread makes the DB connection and SQL statement for the DB server. If the DB server has latency in the response, then the thread moves on to do other work rather than be blocked waiting for the resource to become available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Back-pressure</h1>
                </header>
            
            <article>
                
<p>A reactive application is never given up in overload conditions. Back-pressure is a key aspect of a reactive application. It is a mechanism to ensure that the reactive application doesn't overwhelm the consumers. It tests aspects for the reactive application. It tests the system response gracefully under any load.</p>
<p>The back-pressure mechanism ensures that the system is resilient under load. In a back-pressure condition, the system makes itself scalable by applying other resources to help distribute the load.</p>
<p>Until now, we have seen the reactive pattern principles; these are mandatory to make a system responsive in the blue sky or grey sky. Let's see, in the upcoming section how Spring 5 implements reactive programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing reactive with the Spring 5 Framework</h1>
                </header>
            
            <article>
                
<p>The most highlighted feature of the latest version of the Spring Framework is the new reactive stack web framework. Reactive is the update that takes us to the future. This area of technology is gaining popularity with every passing day, which is the reason why Spring Framework 5.0 has been launched with the capability of reactive programming. This addition makes the latest version of the Spring Framework convenient for event-loop style processing, which enables scaling with a small number of threads.</p>
<p>The Spring 5 Framework implements the reactive programming pattern by using the reactor internally for its own reactive support. A reactor is a Reactive Stream implementation that extends the basic Reactive Streams. Twitter has been implemented as a reactive passed by using Reactive Streams.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams</h1>
                </header>
            
            <article>
                
<p>Reactive Streams provide a protocol or rule for asynchronous stream processing with non-blocking back-pressure. This standard is also adopted by Java 9 in the form of <kbd>java.util.concurrent.Flow</kbd>. Reactive Streams is composed of four simple Java interfaces. These interfaces are <kbd>Publisher</kbd>, <kbd>Subscriber</kbd>, <kbd>Subscription</kbd>, and <kbd>Processor</kbd>. But the main goal of the Reactive Streams is handling the backpressure. As discussed earlier, backpressure is a process that allows a receiver to ask about a data quantity from the emitter.</p>
<p>You can use the following Maven dependency for adding Reactive Streams in your application development:</p>
<pre>    &lt;dependency&gt; 
      &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; 
      &lt;artifactId&gt;reactive-streams&lt;/artifactId&gt; 
      &lt;version&gt;1.0.1&lt;/version&gt; 
   &lt;/dependency&gt; 
   &lt;dependency&gt; 
      &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; 
      &lt;artifactId&gt;reactive-streams-tck&lt;/artifactId&gt; 
      &lt;version&gt;1.0.1&lt;/version&gt; 
   &lt;/dependency&gt; </pre>
<p>The preceding Maven dependency code adds the required libraries for the Reactive Streams in your application. In the upcoming section, we'll see how Spring implements Reactive Streams in the web module of Spring and the Spring MVC Framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Web reactive module</h1>
                </header>
            
            <article>
                
<p>As of Spring 5.0 Framework, Spring has introduced a new module for reactive programming--the spring-web-reactive module. It is based on Reactive Streams. Basically, this module uses the Spring MVC module with reactive programming, so, you can still use the Spring MVC module for your web application either separately or with the spring-web-reactive module.</p>
<p>This new module in the Spring 5.0 Framework contains support for the Reactive-web-functional- based programming model. It also supports the Annotation-based programming model. The Spring-web-reactive module contains support for reactive HTTP and WebSocket clients to call the reactive server application. It also enables the reactive web client to make a connection with a reactive HTTP connection with a reactive web application.</p>
<p>The following diagram shows a Spring-web-reactive module with its components that give reactive behavior to the Spring web application:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="178" width="352" class=" image-border" src="assets/2bde56a1-73df-42c1-af5a-374403e55064.png"/></div>
<p>As you can see in the preceding diagram, there are two parallel modules--one for the traditional Spring MVC framework, and the other for the Spring-reactive web modules. On the left side in the diagram are the Spring-MVC-related components such as the @MVC controllers, <strong>spring-web-mvc module</strong>, <strong>Servlet API module</strong>, and <strong>Servlet Container.</strong> On the right side in the diagram are the spring-web-reactive related components such as the Router Functions, spring-web-reactive module, HTTP/Reactive Streams, Reactive version of Tomcat, and so on. <strong>Spring-web-reactive</strong> related components such as the <strong>Router Functions</strong>, <strong>spring-web-reactive module</strong>, <strong>HTTP/Reactive Streams</strong>, Reactive version of Tomcat, and so on.</p>
<p>In the preceding diagram, you must focus on the placement of the modules. Each module on the same level has comparisons between the traditional Spring MVC and Spring-web-reactive modules. These comparisons are given as follows:</p>
<ul>
<li>In the Spring web reactive modules, the Router functions are similar to the @MVC controllers in the Spring MVC modules such as the <kbd>@Controller</kbd>, <kbd>@RestController</kbd>, and <kbd>@RequestMapping</kbd> annotations.</li>
<li>The Spring-web-reactive module is parallel to the Spring-web-MVC modules.</li>
<li>In the traditional Spring MVC Framework, we use the Servlet API for the <kbd>HttpServletRequest</kbd> and <kbd>HttpServletResponse</kbd> in the servlet container. But in the Spring-web-reactive framework, we use HTTP/Reactive Streams, which creates <kbd>HttpServerRequest</kbd> and <kbd>HttpServerResponse</kbd> under the reactive support of the tomcat server.</li>
<li>We can user Servlet Container for the traditional Spring MVC Framework, but a reactive-supported server is required for the Spring-web-reactive application. Spring provides support for Tomcat, Jetty, Netty, and Undertow.</li>
</ul>
<p>In <a href="ef5eac66-9b41-4959-8155-96f002137409.xhtml" target="_blank">Chapter 10</a>, <em>Implementing MVC Pattern in a Web Application using Spring</em>, you learned how to implement a web application using the Spring MVC module. Let's now see how to implement a reactive web application by using the Spring web reactive module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a reactive web application at the server side</h1>
                </header>
            
            <article>
                
<p>Spring reactive web modules support both programming models--Annotation-based or the Functional-based programming model. Let's see how these models work on the server side:</p>
<ul>
<li><strong>Annotations-based programming model</strong>: It is based on MVC annotations such as <kbd>@Controller</kbd>, <kbd>@RestController</kbd>, <kbd>@RequestMapping</kbd>, and many more. Annotations are supported by the Spring MVC framework for server-side programming for a web application.</li>
<li><strong>Functional programming model:</strong> It is a new paradigm of programming supported by the Spring 5 Framework. It is based on the Java 8 Lambda style routing and handling. Scala also provides the functional programming paradigm.</li>
</ul>
<p>The following are the Maven dependencies that we have to add for a reactive web application based on Spring Boot:</p>
<pre>    &lt;parent&gt; 
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 
       &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; 
       &lt;version&gt;2.0.0.M3&lt;/version&gt; 
       &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; 
    &lt;/parent&gt; 
 
    &lt;properties&gt; 
       &lt;project.build.sourceEncoding&gt;UTF-<br/>        8&lt;/project.build.sourceEncoding&gt; 
       &lt;project.reporting.outputEncoding&gt;UTF<br/>        -8&lt;/project.reporting.outputEncoding&gt; 
       &lt;java.version&gt;1.8&lt;/java.version&gt; 
    &lt;/properties&gt; 
 
    &lt;dependencies&gt; 
       &lt;dependency&gt; 
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 
          &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; 
       &lt;/dependency&gt; 
 
       &lt;dependency&gt; 
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 
          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; 
          &lt;scope&gt;test&lt;/scope&gt; 
       &lt;/dependency&gt; 
       &lt;dependency&gt; 
          &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; 
          &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; 
          &lt;scope&gt;test&lt;/scope&gt; 
       &lt;/dependency&gt; 
    &lt;/dependencies&gt; </pre>
<p>As you can see in the preceding Maven configuration file for dependencies, we have added the <kbd>spring-boot-starter-webflux</kbd> and <kbd>reactor-test</kbd> dependencies to the application.</p>
<p>Let's create a reactive web application based on the Annotation-based programming model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Annotation-based programming model</h1>
                </header>
            
            <article>
                
<p>You can use the same annotations that you have used in <a href="ef5eac66-9b41-4959-8155-96f002137409.xhtml">Chapter 10</a>, <em>Implementing MVC pattern in a Web Application with Spring</em>. Annotations such as <kbd>@Controller</kbd> and <kbd>@RestController</kbd> of Spring MVC are also supported on the reactive side. There is no difference till now between the traditional Spring MVC and Spring web with reactive module. The actual difference starts after the <kbd>@Controller</kbd> annotation configuration declaration, that is, when we go to the internal working of the Spring MVC, starting with <kbd>HandlerMapping</kbd> and <kbd>HandlerAdapter</kbd>.</p>
<p>The main difference between the traditional Spring MVC and Spring web reactive comes into play in the request-handling mechanism. Spring MVC without reactive handles the requests using the blocking <kbd>HttpServletRequest</kbd> and the <kbd>HttpServletResponse</kbd> interfaces of the Servlet API, but the Spring web reactive framework is non-blocking, and operates on the reactive <kbd>ServerHttpRequest</kbd> and <kbd>ServerHttpResponse</kbd> rather than on <kbd>HttpServletRequest</kbd> and <kbd>HttpServletResponse</kbd>.</p>
<p>Let's see the following example with a reactive controller:</p>
<pre>    package com.packt.patterninspring.chapter11.<br/>      reactivewebapp.controller; 
 
    import org.reactivestreams.Publisher; 
    import org.springframework.beans.factory.annotation.Autowired; 
    import org.springframework.web.bind.annotation.GetMapping; 
    import org.springframework.web.bind.annotation.PathVariable; 
    import org.springframework.web.bind.annotation.PostMapping; 
    import org.springframework.web.bind.annotation.RequestBody; 
    import org.springframework.web.bind.annotation.RestController; 
 
    import com.packt.patterninspring.chapter11.<br/>      reactivewebapp.model.Account; 
    import  com.packt.patterninspring.chapter11.<br/>      reactivewebapp.repository.AccountRepository; 
 
    import reactor.core.publisher.Flux; 
    import reactor.core.publisher.Mono; 
 
    @RestController 
    public class AccountController { 
    
      @Autowired 
      private AccountRepository repository; 
  
      @GetMapping(value = "/account") 
      public Flux&lt;Account&gt; findAll() { 
        return repository.findAll().map(a -&gt; new <br/>          Account(a.getId(), a.getName(),<br/>           a.getBalance(), a.getBranch())); 
      } 
  
      @GetMapping(value = "/account/{id}") 
      public Mono&lt;Account&gt; findById(@PathVariable("id") Long id) { 
        return repository.findById(id) 
         .map(a -&gt; new Account(a.getId(), a.getName(), a.getBalance(),<br/>            a.getBranch())); 
      } 
  
      @PostMapping("/account") 
      public Mono&lt;Account&gt; create(@RequestBody <br/>        Publisher&lt;Account&gt; accountStream) { 
        return repository 
          .save(Mono.from(accountStream) 
          .map(a -&gt; new Account(a.getId(), a.getName(), a.getBalance(),<br/>             a.getBranch()))) 
          .map(a -&gt; new Account(a.getId(), a.getName(), a.getBalance(),<br/>             a.getBranch())); 
      } 
    } 
 </pre>
<p>As you can see in the preceding Controller code of <kbd>AccountController.java</kbd>, I have used the same Spring MVC annotations such as <kbd>@RestController</kbd> to declare a controller class, and <kbd>@GetMapping</kbd> and <kbd>@PostMapping</kbd> are used to create the request handler methods for the <kbd>GET</kbd> and <kbd>POST</kbd> request methods respectively.</p>
<p>Let's focus on the return types of the handler methods. These methods return values as <strong>Mono</strong> and <strong>Flux</strong> types. These are types of the reactive steams provided by the reactor framework. Also, the handler method takes the request body using the Publisher type.</p>
<p>Reactor is a Java Framework from the Pivotal open-source team. It builds directly on Reactive Streams, so there is no need for a bridge. The Reactor IO project provides wrappers around low-level network runtimes like Netty and Aeron. Reactor is a "4th Generation" library according to David Karnok's Generations of Reactive classification.</p>
<p>Let's look at the same controller class using the functional programming model to handle requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The functional programming model</h1>
                </header>
            
            <article>
                
<p>The functional programming model uses the API that has functional interfaces such as <kbd>RouterFunction</kbd> and <kbd>HandlerFunction</kbd>. It uses Java 8 Lambda style programming with routing and request handling instead of the Spring MVC annotations. They are simple, but powerful, building blocks for creating web applications.</p>
<p>The following is an example of functional request handling:</p>
<pre>    package com.packt.patterninspring.chapter11.web.reactive.function; 
 
    import static org.springframework.http.MediaType.APPLICATION_JSON; 
    import static org.springframework.web.reactive.<br/>      function.BodyInserters.fromObject; 
 
    import org.springframework.web.reactive.<br/>      function.server.ServerRequest; 
    import org.springframework.web.reactive.<br/>      function.server.ServerResponse; 
 
    import com.packt.patterninspring.chapter11.<br/>      web.reactive.model.Account; 
    import com.packt.patterninspring.chapter11.<br/>      web.reactive.repository.AccountRepository; 
 
    import reactor.core.publisher.Flux; 
    import reactor.core.publisher.Mono; 
 
    public class AccountHandler { 
 
      private final AccountRepository repository; 
 
      public AccountHandler(AccountRepository repository) { 
         this.repository = repository; 
      } 
 
      public Mono&lt;ServerResponse&gt; findById(ServerRequest request) { 
        Long accountId = Long.valueOf(request.pathVariable("id")); 
        Mono&lt;ServerResponse&gt; notFound = <br/>          ServerResponse.notFound().build(); 
        Mono&lt;Account&gt; accountMono =<br/>         this.repository.findById(accountId); 
        return accountMono 
         .flatMap(account -&gt;    ServerResponse.ok().contentType<br/>         (APPLICATION_JSON).body(<br/>            fromObject(account))) 
         .switchIfEmpty(notFound); 
      }  
    
      public Mono&lt;ServerResponse&gt; findAll(ServerRequest request) { 
       Flux&lt;Account&gt; accounts = this.repository.findAll(); 
       return ServerResponse.ok().contentType<br/>       (APPLICATION_JSON).body(accounts, <br/>         Account.class); 
      } 
    
      public Mono&lt;ServerResponse&gt; create(ServerRequest request) { 
        Mono&lt;Account&gt; account = request.bodyToMono(Account.class); 
        return  ServerResponse.ok().build(this.<br/>        repository.save(account)); 
      } 
    } </pre>
<p>In the preceding code, the class file, <kbd>AccountHandler.java</kbd>, is based on the functional reactive programming model. Here, I have used the reactor framework to handle the request. Two functional interfaces, <kbd>ServerRequest</kbd> and <kbd>ServerResponse</kbd>, are used to handle requests and to generate responses.</p>
<p>Let's see the Repositories classes of this application. The following <kbd>AccountRepository</kbd> and <kbd>AccountRepositoryImpl</kbd> classes are the same for both type of applications-Annotation-based and the functional-based programming model.</p>
<p>Let's create an interface <kbd>AccountRepository.java</kbd> class as follows:</p>
<pre>    package com.packt.patterninspring.chapter11.<br/>      reactivewebapp.repository; 
  
    import com.packt.patterninspring.chapter11.<br/>      reactivewebapp.model.Account; 
 
    import reactor.core.publisher.Flux; 
    import reactor.core.publisher.Mono; 
 
    public interface AccountRepository { 
    
      Mono&lt;Account&gt; findById(Long id); 
     
      Flux&lt;Account&gt; findAll(); 
     
      Mono&lt;Void&gt; save(Mono&lt;Account&gt; account); 
    }</pre>
<p>The preceding code is an interface, let's implements this interface with the <kbd>AccountRepositoryImpl.java</kbd> class as following:</p>
<pre>    package com.packt.patterninspring.chapter11.<br/>      web.reactive.repository; 
 
    import java.util.Map; 
    import java.util.concurrent.ConcurrentHashMap; 
 
    import org.springframework.stereotype.Repository; 
 
    import com.packt.patterninspring.chapter11.web.<br/>      reactive.model.Account; 
 
    import reactor.core.publisher.Flux; 
    import reactor.core.publisher.Mono; 
 
    @Repository 
    public class AccountRepositoryImpl implements AccountRepository { 
     
      private final Map&lt;Long, Account&gt; accountMap = new <br/>      ConcurrentHashMap&lt;&gt;();  
     
      public AccountRepositoryImpl() { 
        this.accountMap.put(1000l, new Account(1000l,<br/>        "Dinesh Rajput", 50000l,<br/>          "Sector-1")); 
        this.accountMap.put(2000l, new Account(2000l, <br/>        "Anamika Rajput", 60000l,<br/>          "Sector-2")); 
        this.accountMap.put(3000l, new Account(3000l, <br/>        "Arnav Rajput", 70000l,<br/>           "Sector-3")); 
        this.accountMap.put(4000l, new Account(4000l,<br/>       "Adesh Rajput", 80000l,<br/>           "Sector-4")); 
      } 
    
      @Override 
      public Mono&lt;Account&gt; findById(Long id) { 
        return Mono.justOrEmpty(this.accountMap.get(id)); 
      } 
 
      @Override 
      public Flux&lt;Account&gt; findAll() { 
        return Flux.fromIterable(this.accountMap.values()); 
      } 
 
      @Override 
      public Mono&lt;Void&gt; save(Mono&lt;Account&gt; account) { 
        return account.doOnNext(a -&gt; { 
          accountMap.put(a.getId(), a); 
          System.out.format("Saved %s with id %d%n", a, a.getId()); 
        }).thenEmpty(Mono.empty()); 
         // return accountMono; 
      } 
    } </pre>
<p>As you can see in the preceding code, we created the <kbd>AccountRepository</kbd> class. This class has only three methods: <kbd>findById()</kbd>, <kbd>findAll()</kbd>, and <kbd>save()</kbd>. We implemented these methods according to the business requirements. In this repository class, I have, especially, used the Flux and Mono react types to make it a reactive-based application.</p>
<p>Let's create the server for the functional-based programming model. In Annotation-based programming, we use the simple tomcat container to deploy the web application. But for this functional-based programming, we have to create a Server class to start the Tomcat server or Reactor server, as follows:</p>
<pre>    package com.packt.patterninspring.chapter11.web.reactive.function; 
 
    //Imports here 
 
    public class Server { 
 
      public static final String HOST = "localhost"; 
  
      public static final int TOMCAT_PORT = 8080; 
      public static final int REACTOR_PORT = 8181; 
    
      //main method here, download code for GITHUB 
    
      public RouterFunction&lt;ServerResponse&gt; routingFunction() { 
         AccountRepository repository = new AccountRepositoryImpl(); 
         AccountHandler handler = new AccountHandler(repository); 
 
         return nest(path("/account"), nest(accept(APPLICATION_JSON), 
           route(GET("/{id}"), handler::findById) 
           .andRoute(method(HttpMethod.GET), handler::findAll) 
           ).andRoute(POST("/").and(contentType<br/>           (APPLICATION_JSON)), handler::create)); 
      } 
 
      public void startReactorServer() throws InterruptedException { 
         RouterFunction&lt;ServerResponse&gt; route = routingFunction(); 
         HttpHandler httpHandler = toHttpHandler(route); 
 
         ReactorHttpHandlerAdapter adapter = new<br/>            ReactorHttpHandlerAdapter(httpHandler); 
         HttpServer server = HttpServer.create(HOST, REACTOR_PORT); 
         server.newHandler(adapter).block(); 
      } 
 
      public void startTomcatServer() throws LifecycleException { 
         RouterFunction&lt;?&gt; route = routingFunction(); 
         HttpHandler httpHandler = toHttpHandler(route); 
 
         Tomcat tomcatServer = new Tomcat(); 
         tomcatServer.setHostname(HOST); 
         tomcatServer.setPort(TOMCAT_PORT); 
         Context rootContext = tomcatServer.addContext("",<br/>           System.getProperty("java.io.tmpdir")); 
         ServletHttpHandlerAdapter servlet = new<br/>           ServletHttpHandlerAdapter(httpHandler); 
         Tomcat.addServlet(rootContext, "httpHandlerServlet", servlet); 
         rootContext.addServletMapping("/", "httpHandlerServlet"); 
         tomcatServer.start(); 
      } 
    } </pre>
<p>As you can see in the preceding <kbd>Server.java</kbd> class file, I have added both, the Tomcat and Reactor servers. The Tomcat server uses port 8080, but the Reactor server uses the port <kbd>8181</kbd>.</p>
<p>This <kbd>Server.java</kbd> class has three methods. The first method, <kbd>routingFunction()</kbd>, is responsible for handling client requests by using the <kbd>AccountHandler</kbd> class. It depends on the <kbd>AccountRepository</kbd> class. The second method, <kbd>startReactorServer()</kbd>, is responsible for starting the Reactor server by using the <kbd>ReactorHttpHandlerAdapter</kbd> class of the reactor server. This class takes an object of the <kbd>HttpHandler</kbd> class as a constructor argument to create the request handler mapping. Similarly, the third method, <kbd>startTomcatServer()</kbd>, is responsible for starting the Tomcat server. And it is bound to the <kbd>HttpHandler</kbd> object through a reactor adapter class, <kbd>ServletHttpHandlerAdapter</kbd>.</p>
<p>You can run this server class file as a Java application, and see the output on the browser by typing the URL, <kbd>http://localhost:8080/account/</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="435" width="252" class=" image-border" src="assets/c22f603b-fde7-4b27-9c36-9dc25d66e213.png"/></div>
<p>You can also type the same URL with port <kbd>8181</kbd> for the Reactor server, as follows, and you will get the same output:</p>
<p><kbd>http://localhost:8181/account/</kbd></p>
<p>In this section, you learned how to create a reactive web application using the Spring-web-reactive module. We created the web application by using both the programming paradigms: Annotation-based and Functional-based.</p>
<p>In the next section, we'll discuss client-side code, and how a client accesses the reactive web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a Reactive Client-Side application</h1>
                </header>
            
            <article>
                
<p>The Spring 5 Framework introduces a functional and reactive WebClient. It is a fully non-blocking and reactive web client, and an alternative to <kbd>RestTemplate</kbd>. It creates the network input and output in the form of reactive <kbd>ClientHttpRequest</kbd> and <kbd>ClientHttpRespones</kbd>. It creates the body of the request and response in the form of <kbd>Flux&lt;DataBuffer&gt;</kbd> instead of <kbd>InputStream</kbd> and <kbd>OutputStream</kbd>.</p>
<p>Let's see the code for the web client, which creates a <kbd>Client.java</kbd> class:</p>
<pre>    package com.packt.patterninspring.chapter11.web.reactive.function; 
 
    //Imports here 
 
    public class Client { 
 
      private ExchangeFunction exchange = ExchangeFunctions.create(new<br/>        ReactorClientHttpConnector()); 
 
      public void findAllAccounts() { 
        URI uri = URI.create(String.format("http://%s:%d/account",<br/>        Server.HOST,<br/>          Server.TOMCAT_PORT)); 
        ClientRequest request = ClientRequest.method(HttpMethod.GET,  <br/>        uri).build(); 
 
        Flux&lt;Account&gt; account = exchange.exchange(request) 
        .flatMapMany(response -&gt; response.bodyToFlux(Account.class)); 
 
         Mono&lt;List&lt;Account&gt;&gt; accountList = account.collectList(); 
         System.out.println(accountList.block()); 
      } 
 
      public void createAccount() { 
        URI uri = URI.create(String.format("http://%s:%d/account",<br/>        Server.HOST,<br/>           Server.TOMCAT_PORT)); 
        Account jack = new Account(5000l, "Arnav Rajput", 500000l,<br/>        "Sector-5"); 
 
        ClientRequest request = ClientRequest.method(HttpMethod.POST,<br/>        uri) 
        .body(BodyInserters.fromObject(jack)).build(); 
 
        Mono&lt;ClientResponse&gt; response = exchange.exchange(request); 
 
        System.out.println(response.block().statusCode()); 
      } 
    }   </pre>
<p>The preceding class, <kbd>Client.java</kbd>, is a web client class for <kbd>Server.java</kbd>. It has two methods. The first method is <kbd>findAllAccounts()</kbd>. It fetches all accounts from the account repository. It uses the <kbd>org.springframework.web.reactive.function.client</kbd>. The <kbd>ClientRequest</kbd> interface to create a request to the <kbd>http://localhost:8080/account/</kbd> URI with the <kbd>GET</kbd> http method. By using the <kbd>org.springframework.web.reactive.function.client</kbd>. The <kbd>ExchangeFunction</kbd> interface, it calls the server, and fetches the result as the JSON format. Similarly, the other method, <kbd>createAccount()</kbd>, creates a new account in the server by using the URI with the <kbd>POST</kbd> method <kbd>http://localhost:8080/account/</kbd>.</p>
<p>Let's run the Client class as a Java application and see the output on the console, which is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><em><img class=" image-border" src="assets/39fecf73-9041-45a8-b8ba-1a881bacf7a7.png"/></em></div>
<p>It creates a new record and fetch all five record in the form of JSON list.</p>
<div class="packt_infobox">The <kbd>AsyncRestTemplate</kbd> also supports non-blocking interactions. The main difference is that it can't support non-blocking streaming, for example, Twitter one, because, fundamentally, it's still based and relies on <kbd>InputStream</kbd> and <kbd>OutputStream</kbd>.</div>
<p>In the next section, we'll talk about the request and response body parameters in a reactive web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request and response body conversion</h1>
                </header>
            
            <article>
                
<p>In <a href="ef5eac66-9b41-4959-8155-96f002137409.xhtml">Chapter 10</a>, <em>Implementing MVC Pattern in a Web Application with Spring</em>, we discussed message conversion for the request body and response body either from Java to JSON, or from JSON to Java object, and many more. Similarly, conversion is also required in the case of a Reactive web application, . The spring core module provides reactive Encoder and Decoder to enable the serialization of a Flux of bytes to and from the typed objects.</p>
<p>Let's see the following example for request body type conversions. Developers do not need to forcefully do type conversion--the Spring Framework automatically converts it for you in both types of approaches: Annotation-based programming, and functional-based programming.</p>
<ul>
<li><strong>Account account</strong>: This means that the account object is deserialized before the controller is called without blocking.</li>
<li><strong>Mono&lt;Account&gt; account</strong>: This means that <kbd>AccountController</kbd> can use the Mono to declare logic. The account object is first deserialized, and then this logic is executed.</li>
<li><strong>Flux&lt;Account&gt; accounts</strong>: This means that <kbd>AccountController</kbd> can use Flux in case of the input streaming scenario.</li>
<li><strong>Single&lt;Account&gt; account</strong>: This is very similar to the Mono, but here the Controller uses RxJava.</li>
<li><strong>Observable&lt;Account&gt; accounts</strong>: This is also very similar to Flux, but in this case, the Controller uses input streaming with RxJava.</li>
</ul>
<p>In the preceding list, you saw the Spring Framework for type conversion in the reactive programing model. Let's see the following return types in the example for the response body:</p>
<ul>
<li><strong>Account</strong>: This serializes without blocking the given Account; implies a synchronous, non-blocking controller method.</li>
<li><strong>void</strong>: This is specific to the annotation-based programming model. Request handling completes when the method returns; this implies a synchronous, non-blocking controller method.</li>
<li><strong>Mono&lt;Account&gt;</strong>: This serializes without blocking the given Account when the Mono completes.</li>
<li><strong>Mono&lt;Void&gt;</strong>: This implies that request handling completes when the Mono completes.</li>
<li><strong>Flux&lt;Account&gt;</strong>: This is used in the streaming scenario, possibly, the SSE depends on the requested content type.</li>
<li><strong>Flux&lt;ServerSentEvent&gt;</strong>: This enables SSE streaming.</li>
<li><strong>Single&lt;Account&gt;</strong>: The same, but uses RxJava.</li>
<li><strong>Observable&lt;Account&gt;</strong>: The same, but uses the RxJava Observable type.</li>
<li><strong>Flowable&lt;Account&gt;</strong>: The same, but uses the RxJava 2 Flowable type.</li>
</ul>
<p>In the preceding list, you have seen the return types of the handler methods. The Spring Framework does type conversions in the reactive programing model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about the Reactive pattern and its principles. It is not a new innovation in programming--it is a very old concept, but it very fits in very well with the demands of modern applications.</p>
<p>Reactive programming has four principles: responsiveness, resilience, elasticity, and message-driven architecture. Responsiveness means a system must be responsive in all conditions: odd conditions and even conditions.</p>
<p>The Spring 5 Framework provides support for the reactive programming model by using the Reactor framework and reactive stream. Spring has introduced new a reactive web module, that is, spring-web-reactive. It provides the reactive programming approach to a web application by either using Spring MVC's annotations, such as <kbd>@Controller</kbd>, <kbd>@RestController</kbd>, and <kbd>@RequestMapping</kbd>, or by using the functional programming approach using the Java 8 Lambda expression.</p>
<p>In this chapter, we created a web application by using the spring web reactive modules. The code for this application is available on GitHub. In the next chapter, you will learn about implementation of concurrency patterns.</p>


            </article>

            
        </section>
    </body></html>