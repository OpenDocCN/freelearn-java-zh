["```java\nfor (int i = 0; i < n - m + 1; i++) {\n  boolean hasMatch = true;\n  for (int j = 0; j < m; j++) {\n    if (P.charAt(j) != T.charAt(i + j)) {\n      hasMatch = false;\n      break;\n    }\n  }\n  if (hasMatch)\n  shifts.add(i);\n}  \n```", "```java\nfor (int j = m - 1; j >= 0; j--) {\n  if (P.charAt(j) != T.charAt(i + j)) {\n    hasMatch = false;\n    break;\n  }\n} \n```", "```java\nint skip;\nfor (int i = 0; i < n - m + 1; i += skip) {\n  skip = 0;\n  for (int j = m - 1; j >= 0; j--) {\n    if (P.charAt(j) != T.charAt(i + j)) {\n      skip = Math.max(1, j - left[j][T.charAt(i + j)]);\n     break;\n    }\n  }\n  if (skip == 0) {\n    shifts.add(i);\n    skip = 1;\n  }\n}  \n```", "```java\nint i = m, j = m + 1;\nint[] f = new int[m + 1];\nint[] s = new int[m + 1];\nf[i] = j;\nwhile (i > 0) {\n  while (j <= m && P.charAt(i - 1) != P.charAt(j - 1)) {\n    if (s[j] == 0)\n      s[j] = j - i;\n      j = f[j];\n  }\n  i--; j--;\n  f[i] = j;\n}\n```", "```java\nf, whose entries *f[i]* contain the starting position of the widest border of the suffix of the pattern that starts at position *i*. *f[m]* is equal to *m + 1*, as the empty string has no border. The idea behind the previously shown preprocessing algorithm is to compute each border by checking whether a shorter border that is already known can be extended to the left by the same symbol. The array *s* is used to store shift distances; we can save entries in array *s* whenever we can't extend a border to the left (when *P[i - 1] != P[j - 1]*), provided that *s[j]* is not already occupied.\n```", "```java\nj = f[0];\nfor (i = 0; i <= m; i++) {\n  if (s[i] == 0)\n  s[i] = j;\n  if (i == j)\n  j = f[j];\n} \n```", "```java\nfor (i = 0; i < n - m + 1; i += skip) {\n  boolean hasMatch = true;\n  skip = 0;\n  for (j = m - 1; j >= 0; j--) {\n    if (P.charAt(j) != T.charAt (i + j)) {\n      skip = s[j + 1];\n      hasMatch = false;\n      break;\n    }\n  }\n  if (hasMatch) {\n    shifts.add(i);\n    skip = s[0];\n  } \n}  \n```", "```java\nfor (i = 0; i < n - m + 1; i += skip) {\n  skip = 0;\n  boolean hasMatch = true;\n  for (j = m - 1; j >= 0; j--) {\n    if (P.charAt(j) != T.charAt(i + j)) {\n      hasMatch = false;\n      skip = Math.max(s[j + 1], j - left[j]\n      [T.charAt(i + j)]);\n      break;\n    }\n  }\n  if (hasMatch) {\n    shifts.add(i);\n    skip = s[0];\n  } \n}  \n```", "```java\nlong q = BigInteger.probablePrime(31, new  Random()).longValue();\n// Precompute d^(m-1) % q for use when removing leading digit\nlong dm = 1;\nfor (int i = 1; i <= m - 1; i++)\n  dm = (d * dm) % q;\n// Precompute p and t0\nlong ph = 0;\nlong th = 0;\nfor (int i = 0; i < m; i++) {\n  ph = (d * ph + P.charAt(i)) % q;\n  th = (d * th + T.charAt(i)) % q;\n} \n```"]