- en: '*Chapter 1*: Getting Started with Microservices Using the Micronaut Framework'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent times, there's been a good buzz about **microservices** and how the
    **microservices architecture** has been transformational in developing rapid,
    agile, and enterprise-grade web services to address the unique challenges and
    requirements of today's world. The microservices architecture has turned the page
    toward disciplining the standards on developing these web services. In this chapter,
    we will walk through the evolution of web services to microservices. We will quickly
    dive into some useful microservices design patterns. We will zero in on the key
    pitfalls in most of the traditional Java development frameworks and how their
    surface-level adoption to the microservices architecture has elevated performance
    and optimization issues. We will then explore how the Micronaut framework has
    addressed these performance and optimization issues in the microservices with
    an overhauled and ground-up approach to microservices development. Lastly, to
    get started with the Micronaut framework, we will set up the Micronaut CLI and
    work on a small hello world project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on these topics in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing microservices and their evolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding microservices design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Micronaut is the best choice for developing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with the Micronaut framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on the hello world project in the Micronaut framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have an understanding of how web services
    evolved in to microservices and why traditional Java frameworks are ineffective
    for developing microservices as compared to the Micronaut framework. Furthermore,
    we will also gain the practical knowledge to start using the Micronaut framework
    by working on a small project in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and mac OS X. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development IDE**: Based on your preferences, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing microservices and their evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we thoroughly jump into introducing and defining microservices, it will
    be helpful to know how microservices have evolved. In the late 1960s, Alan Kay
    coined the term **object-oriented programming**. Though it was a definitive idea,
    later it birthed the four pillars for building software solutions using object-oriented
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a short mnemonic, it's known as EIPA. Since the inception of these four pillars,
    the software industry has seen the rise and fall of many programming languages,
    frameworks, design patterns, and so on. With each such adaption and idea, thinkers
    and tinkerers have tried to come closer to EIPA by keeping a modular design and
    loosely coupled yet tightly encapsulated application components. Over the last
    few decades, software teams have moved away from the art of object-oriented programming
    toward the science of object-oriented programming by systematically adopting these
    key pillars. This iterative journey is the evolution of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 1980s and early 1990s, almost every enterprise application was exposed
    as either a command line or native desktop software. Applications were tightly
    connected to databases and it was almost as if the end user was directly interacting
    with the database with the application as a thin façade in between. It was the
    era of monolithic applications or client/server architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the proceeding diagram, we can see how users interacted with a monolith
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Monolithic client/server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Monolithic client/server architecture
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in *Figure 1.1*, in monolithic client/server architecture, the application
    is tightly coupled to the database and the user interacts through a terminal façade
    or desktop application. In this architecture, it was painful to maintain good
    **service-level agreements** (**SLAs**). Almost all the key non-functional factors
    such as scalability, high availability, fault tolerance, and flexibility underperformed
    or failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address some of these aspects **service-oriented architecture** (**SOA**)
    came into existence. In the 2000s, SOA was formalized in the industry with the
    definition of some standard protocols such as **Simple Object Access Protocol
    (SOAP**). **Web Services Description Language** (**WSDL**) was also created during
    this period. Web 2.0 applications were popular with **Asynchronous JavaScript
    And XML (AJAX**). Enterprise service bus and messaging systems were highly used
    in enterprise applications. Advancements in SOA catalyzed a new paradigm of delivering
    software solutions to end users: **Software as a Service** (**SaaS**). Instead
    of desktop applications and terminal clients, software solutions were delivered
    to end users over HTTP as hosted online services. In the proceeding diagram, we
    can see how users interacted with an SOA-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – SOA'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – SOA
  prefs: []
  type: TYPE_NORMAL
- en: As shown, SOA brought in some decoupling by separating the concerns between
    the web application, web server, and app server. App servers or **enterprise service
    buses** (**ESBs**) usually interact with the database and the user interacts with
    the application by accessing it on web browsers (SaaS solutions). Though SOA brought
    some relief, the adoption of SaaS left scalability and flexibility as key unhashed
    puzzles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Post-2010, the technology world started to move much faster than it did in
    the previous two decades. With the introduction of containers, the cloud, big
    data, and machine learning, everything started moving rapidly in architecture
    design. It is the era of Uber, Airbnb, Netflix, and freemium/premium applications.
    Applications are designed for distributed computing and scalability. With the
    microservices architecture, the application is decomposed to loosely coupled microservices
    where each microservice owns its database. In the proceeding diagram, we can see
    how users interact with a microservices-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Microservices architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Microservices architecture
  prefs: []
  type: TYPE_NORMAL
- en: In the previous diagram, we can see a fully realized microservices application
    where each microservice interacts with and owns its database. The user interacts
    with a single-page application through a modern browser. Any incoming requests
    from the web server are routed to the respective microservice. The full realization
    of microservices architecture is to address key factors of scalability, fault
    tolerance, high availability, and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it simply, microservices or microservices architecture componentize
    an application into a collection of interacting services. Each service could be
    developed, tested, deployed, and maintained independently. Thus, each smaller
    (micro) service has its own unique life cycle. Furthermore, since each service
    is loosely coupled (interacting with other services using HTTP/HTTPS), we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scale up or scale down (based on the service traffic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address any runtime faults (boot up the service backup).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make new changes (change impact is limited to the service).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, through the complete realization of decoupled architecture in the
    microservices, we address key issues of scalability, fault tolerance, high availability,
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about microservices and their evolution and how they
    have been transformational in addressing the unique, rapid, and agile needs of
    today's world. This understanding is a good preface to realizing the potential
    of microservices. In the next section, we will dive into the microservices design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding microservices design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully realize the benefits of any architecture (including the microservices
    architecture), an architectural approach is often backed with design patterns.
    Understanding these design patterns is crucial for an ideal adoption of the architecture.
    In the following sections, we will cover some practical and commonly used design
    patterns in microservices. Each pattern addresses a different aspect of the application
    development life cycle and our focus would be to see these design patterns from
    a practical usage standpoint. We will begin with decomposition design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposition design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decomposition design patterns dictate how we can componentize or decompose a
    big/monolithic application into smaller (micro) services. These patterns come
    in handy in designing a transformational architecture for any legacy monolithic
    application. The following are the most commonly used design patterns in decompositions.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing by business capability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any business capability is an instrument to make a profit. If we can enlist
    and categorize an application into a set of business capabilities such as inventory
    management, customer orders, or operations, then the application can be decomposed
    into microservices that are based on these business capabilities. This process
    to decompose is effective and recommended for small- to medium-sized applications.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing by domains/sub-domains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the application is an enterprise-grade and heavy application, then the previous
    approach may end up decomposing the application into smaller monoliths. These
    monoliths are smaller but monoliths nonetheless. In such cases, business modeling
    can help to categorize and map application functionalities into domains and sub-domains.
    Functionalities inside a domain/sub-domain are similar but very different from
    the functionalities of other domains/sub-domains. Microservices then can be designed
    and built around domains or sub-domains (if there are many functionalities mapped
    to a domain).
  prefs: []
  type: TYPE_NORMAL
- en: Integration design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the application is broken down into smaller (micro) services, we will need
    to establish cohesion among these services. Integration design patterns address
    such collaboration requirements. The following are the most commonly used design
    patterns in integrations.
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often upstream frontend consumers need to access microservices through a façade.
    This façade is called an API gateway. The API gateway design pattern serves an
    important purpose to keep things simple for frontend clients:'
  prefs: []
  type: TYPE_NORMAL
- en: The frontend client is not sending too many requests to microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend client is not processing/aggregating too many responses (from microservices).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the server end, the gateway routes a request to multiple microservices, and
    these microservices can run in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before sending the final response, we can aggregate individual responses from
    different microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aggregator pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern is very similar to the aforementioned API gateway pattern. However,
    composite microservice is the key differential. The mandate of a composite microservice
    is to offload an incoming request to multiple microservices and then collaborate
    to create a unified response. This pattern is used when a user request is atomic
    from business logic standpoints, but it is processed by multiple microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The chained microservices pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some scenarios, an incoming request is executed in a series of steps wherein
    each step could be spinning off a call to a microservice. For example, ordering
    an item in an online marketplace would require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for an item (inventory management service)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding an item to the cart (cart service)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking out the added item (payment service, mail service, inventory management
    service)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these service calls would be synchronous. Fulfilling a user request would
    be an amalgamation of all these chained microservice calls.
  prefs: []
  type: TYPE_NORMAL
- en: Data management patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrating with the persistence layer is an important aspect of any microservice-based
    application. Greenfield (net new) and brownfield (legacy transformation) applications
    may dictate their requirements in how to choose a data management pattern. The
    following are the most often used design patterns in data management in microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Database per service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In greenfield (net new) applications, it is ideal to have a database per service.
    Each service is the owner of an isolated database (relational or non-relational)
    and any data operation must be executed through the microservice only. Furthermore,
    even if any other microservice needs to perform a database operation, then it
    should be routed through the owner microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Shared database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In brownfield (transformational) applications, it may not be practical to decompose
    the database into one database per service. In such scenarios, the microservices
    architecture realization can be kickstarted with services sharing a common monolith
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Command query responsibility segregation (CQRS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In greenfield or fully transformed applications where each microservice is
    an independent database owner, there might be a requirement to query data from
    multiple databases. The CQRS pattern stipulates to decompose an application into
    a command and query:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: This part will manage any create, update, and delete requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query**: This part will manage query requests using database views where
    database views can unify data from multiple schemas or data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-cutting patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some concerns cut across all the different aspects/layers of microservices.
    In the following sub-sections, we will discuss some of these concerns and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The service discovery pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a microservices-based application, each microservice may have more than one
    instance at runtime. Furthermore, these service instances can be added or removed
    at runtime based on traffic. This runtime agility can be an issue for upstream
    consumers in how they connect with services.
  prefs: []
  type: TYPE_NORMAL
- en: The service discovery pattern addresses this by implementing a service registry
    database. The service registry is a metadata store containing information such
    as the service name, where the service is running, and the current status of the
    service. Any change to the service runtime information will be updated in the
    service registry, for example, when a service adds a new instance or a service
    is down. This eases the pain for upstream consumers to connect with different
    microservices in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a microservices-based application, often services interact with each other
    by invoking endpoints. There could be a scenario where a service is calling a
    downstream service but the downstream service is down. Without a circuit breaker,
    the upstream service will keep calling the downstream service while it's down
    and this will keep impacting the user interaction with the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the circuit breaker pattern, a downstream service call will be routed through
    a proxy. This proxy will timeout for a fixed interval if the downstream service
    is down. After the timeout expiry, the proxy will try to connect again. If successful,
    it will connect with the downstream service; otherwise, it will renew the timeout
    period. Therefore, the circuit breaker will not bombard the downstream service
    with unnecessary calls and it will not impact user interaction with the application.
  prefs: []
  type: TYPE_NORMAL
- en: The log aggregation pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the microservices landscape, often an incoming request will be processed
    by multiple services. Each service may create and log its entries. To trace any
    issues, it will be counter-intuitive to access these sporadic logs. By implementing
    a log aggregation pattern, logs could be indexed in a central place, thereby enabling
    easy access to all application logs. **Elasticsearch, Logstash, Kibana** (**ELK**)
    can be used to implement log aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered some often-used design patterns in different stages
    of the application life cycle. Understanding these design patterns is required
    to fully reap the benefits of microservices architecture. In the next section,
    we will dive into the Micronaut framework for developing microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Why Micronaut is the best choice for developing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned about the maturity on the architectural
    side of microservices. Unfortunately, on the implementation side, an overhaul
    shift to build/develop microservices is not as mature as microservices architecture.
    To address some of these implementation challenges, many traditional Java frameworks
    have added small, iterative changes, but much-sought-after disruptive and overhauled
    changes are missing. At the core, these traditional Java frameworks have stayed
    almost the same since the time of monolithic services. Reflections, runtime proxies,
    and bulky configuration management have plagued all traditional frameworks with
    slower boot time and bigger memory footprints, making them unsuitable for microservices
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Micronaut is developed from the bottom up, considering these important challenges,
    to organically support microservices development:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Inject` for dependency injection. It adds the *Java inject* module to the
    compiler and all the annotations are processed at compile time. The compiler generates
    the byte code for all the classes based on the annotations that are used in their
    source code. This is all done at compile time. At runtime, Micronaut can instantiate
    the beans and read their metadata from the generated byte code and does not need
    to use the slow reflection API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ahead-of-time compilation**: As discussed before, one of the key contrasts
    is that Micronaut performs dependency injection, configuration management, and
    aspect-oriented programming proxying at compile time. Micronaut relies on one
    or more annotation processors to process the annotation metadata into **ASM**-generated
    (**assembly**) byte code. Furthermore, this ahead-of-time-generated byte code
    is further optimized by Java''s **just-in-time** (**JIT**) compiler. Other frameworks
    use reflection and produce the annotation metadata at application boot-up. This
    metadata is loaded to runtime memory, therefore increasing the memory footprint.
    Instead of the Java Reflection API, Micronaut uses the Java annotation processor
    API, the Kotlin compiler plugin for annotation processors, and Groovy AST transformations
    for metaprogramming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster boot-up time and lower memory consumption**: Other frameworks use
    Java reflections and at application boot-up, all classpaths are scanned to generate
    reflection metadata for each field, method, and constructor. This metadata is
    then used to determine and inject the required object into the application runtime.
    This adds significantly to boot-up time as well as runtime memory. As discussed
    previously, Micronaut uses ahead-of-time compilation and the Java annotation processor
    API to offload such work from the runtime and reduce memory requirements by not
    pushing unnecessary reflection metadata onto runtime memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless applications support**: One of the key issues in serverless applications
    is boot-up time. With a huge memory footprint and slower boot-up time, traditional
    frameworks are not a prudent choice to develop serverless applications. Micronaut
    organically supports serverless application development by keeping the minimal
    runtime memory footprint and sub-second boot-up time. Furthermore, Micronaut natively
    supports commonly used cloud platforms for serverless function development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language-agnostic framework**: The Micronaut framework supports the Java,
    Kotlin, and Groovy programming languages. With varied support for major programming
    languages, developers can choose their preferred language option when considering
    cloud requirements. For example, for IoT requirements, Groovy could be a good
    option. This language-agnostic enablement makes it flexible and apt for varied
    requirements of mobile/web/cloud solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support to GraalVM**: Since Micronaut doesn''t use reflections, any Micronaut-based
    application can be ahead-of-time compiled into a GraalVM native image. GraalVM
    is a universal virtual machine offered by Oracle that can run a Java application
    down to machine code. This increases application performance significantly. Any
    Micronaut application compiled to a GraalVM native image can boot up in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In light of the preceding key points, Micronaut stands out as a preferred framework
    to develop cloud-native, ultra-light, and rapid microservices. In addition, we
    performed a quick benchmark experiment to compare the application startup times
    for Micronaut versus another popular traditional framework. In the following chart,
    startup times are shown for both Micronaut and a traditional framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Startup times for a traditional framework versus Micronaut'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Startup times for a traditional framework versus Micronaut
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding chart, the traditional framework took 6,156 milliseconds
    to boot up whereas Micronaut took only 3,750 milliseconds. This time difference
    in booting up the application is significant and sets Micronaut as a go-to framework
    for developing cloud-native and rapid microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will get started with using the Micronaut framework
    on both Windows as well as mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get started with the Micronaut framework, we will begin by installing
    the Micronaut CLI on Mac and Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Micronaut CLI on mac OS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On mac OS, we can install the Micronaut CLI in a couple of ways – using SDKMAN!,
    Homebrew, or MacPorts. In the following sections, we will cover step-by-step instructions
    to install the Micronaut CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Micronaut using SDKMAN!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please follow these steps to install the Micronaut CLI using SDKMAN!:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don''t have SDKMAN! installed, take the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Type or paste the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'b. Next, type or paste the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To install the Micronaut CLI, type or paste the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will observe the following interactions on Terminal while installing the
    Micronaut CLI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Installing Micronaut CLI on mac OS using SDKMAN!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.5 – Installing Micronaut CLI on mac OS using SDKMAN!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If all the preceding steps execute successfully, you can verify the Micronaut
    CLI installation by running the following command in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing Micronaut using Homebrew
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please follow these steps to install the Micronaut CLI using MacPorts:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don''t have Homebrew installed, then take the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Type or paste the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'b. Next, type or paste the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type or paste the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will observe the following interactions on Terminal while installing the
    Micronaut CLI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Installing the Micronaut CLI on mac OS using HomeBrew'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.6 – Installing the Micronaut CLI on mac OS using HomeBrew
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If all the preceding steps execute successfully, you can verify the Micronaut
    CLI installation by hitting the following command in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing Micronaut using MacPorts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please follow these steps to install the Micronaut CLI using Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have MacPorts installed, then follow the instructions at [https://www.macports.org/install.php](https://www.macports.org/install.php).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type or paste the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type or paste the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will observe the following interactions on Terminal while installing the
    Micronaut CLI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Installing the Micronaut CLI on macOS using MacPorts'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.7 – Installing the Micronaut CLI on macOS using MacPorts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If all the preceding steps execute successfully, you can verify the Micronaut
    CLI installation by hitting the followed command in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing the Micronaut CLI on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please follow these steps to install the Micronaut CLI on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the Micronaut CLI binary from the Micronaut download page: [https://micronaut.io/download.html](https://micronaut.io/download.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded binary file into a folder on your system. It is better
    to keep this in a separate folder under a root directory such as `C:\Program Files\Micronaut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new system variable called `MICRONAUT_HOME` with the preceding directory
    path. Please note to add this variable under system variables (not user variables).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, update your Windows `PATH` environment variable. You can add a path such
    as `%MICRONAUT_HOME%\bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Command Prompt or any terminal and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will boot up the CLI for the first time by resolving any dependencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test that the CLI is installed properly, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what the command outputs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Installing the Micronaut CLI on Windows OS'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B16585_Fixed.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 1.8 – Installing the Micronaut CLI on Windows OS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should see all the **CLI** options after hitting the preceding command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we explored different ways to install the Micronaut CLI in
    Windows and macOS. In order to get hands-on with the Micronaut framework, we will
    get started with working on a hello world project in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working on a hello world project in the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the practical aspects of using the Micronaut framework for developing
    a microservice, we will work with a hello world project. This will help you quickly
    get started with the Micronaut framework and also give you first-hand experience
    of how easy it is to do microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: Micronaut works seamlessly with the Maven and Gradle packaging managers. We
    will cover one example for each using the Micronaut CLI as well as Micronaut Launch
    (web interface) for generating barebones projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hello world project using the Micronaut CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please take the following steps to create a hello world application using the
    Micronaut CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal (or Command Prompt).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the directory to your desired directory where you want to create the
    hello world project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait for the Micronaut CLI to finish and it will create a `hello-world-maven`
    project. The `create-app` command will create a boilerplate project for you with
    a Maven build and your system-installed Java version. It will create `Application.java`
    as well as a sample test class called `ApplicationTest.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To explore your freshly created `hello-world-maven` project, open this project
    in your preferred IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run your project, run the following command in a Bash terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: mvn -N io.takari:maven:wrapper
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Maven wrapper will build and run your project on `http://localhost:8080`
    by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding HelloWorldController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a simple endpoint, let''s add a simple controller to the `hello-world-maven`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a web package to our `hello-world-maven` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `HelloWorldController` Java class. It will contain a simple `hello` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`HelloController` is accessible on the `…/hello` path. `helloMicronaut()` will
    generate a plain text `"Hello, Micronaut!"` message.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rerun your application and hit [http://localhost:8080/hello/](http://localhost:8080/hello/)
    in a browser window. The server will return the following response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Hello, Micronaut!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.9_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – Hello, Micronaut!
  prefs: []
  type: TYPE_NORMAL
- en: By default, the application will be accessible on port `8080`, and this port
    can be changed in the application properties.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have worked on a hello world project using the Micronaut CLI. Next,
    we will explore Micronaut Launch, which is a web interface, to generate a boilerplate
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hello world project using Micronaut Launch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Micronaut Launch** ([https://micronaut.io/launch/](https://micronaut.io/launch/))
    is an intuitive web interface that came into existence with Micronaut 2.0.1\.
    We can use this interface to quickly generate boilerplate for different kinds
    of Micronaut applications (such as server applications, the CLI, serverless functions,
    a messaging application, and so on). Let''s quickly use this to generate a hello
    world application for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please follow these instructions to generate the hello world project using
    the Micronaut Launch web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Micronaut Launch in a browser window: [https://micronaut.io/launch/](https://micronaut.io/launch/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Application Type**, choose **Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Micronaut Version**, choose **2.0.1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the Java version, choose **Java 14**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Language**, choose **Java**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a base package name such as `com.packtpub.micronaut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Gradle** as the build option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a name to the application, such as `hello-world-gradle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **JUnit** as the testing framework
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've finished choosing all the options, click on **GENERATE PROJECT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After choosing the preceding options and providing various inputs, the Micronaut
    Launch interface should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Using Micronaut Launch to generate a boilerplate project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.10_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – Using Micronaut Launch to generate a boilerplate project
  prefs: []
  type: TYPE_NORMAL
- en: Your project boilerplate source code will be generated into a zipped file. You
    can unarchive this zipped file into your desired directory and open it in your
    preferred IDE. Just like the previous example (`hello-world-maven`), we can add
    a basic `HelloWorldController` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your project, run the following command in a Bash terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the project is running, go to `http://localhost:8080/hello` and you should
    see the **Hello, Micronaut!** message in the browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored how to get started with the Micronaut framework
    by developing small hello world projects using the Micronaut CLI as well as the
    Micronaut Launch user interface. This small exercise will be a good preface for
    what we will cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began our journey into microservices by exploring their
    evolution and some useful design patterns. We covered the Micronaut framework
    in contrast to the traditional reflection-based Java frameworks. Essentially,
    Micronaut's approach to leverage ahead-of-time compilation (and not reflections)
    sets it apart as an ideal framework for developing microservices. To get our hands
    dirty, we went through setting up the Micronaut CLI on mac OS as well as Windows
    OS. Lastly, we worked on `hello-world-maven` and `hello-world-gradle` projects.
    In both projects, we added `hello` endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: With the fundamentals of microservices as well as practical hello world projects
    covered, this chapter enhanced your knowledge of the evolution of microservices,
    their design patterns, and why Micronaut should be preferred for developing microservices.
    This foundational understanding is the bedrock for starting the adventure of microservices
    development in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we kickstarted an exciting journey into microservices
    development using the Micronaut CLI and Micronaut Launch. In the next chapter,
    we will explore how we can integrate different kinds of persistent storage and
    databases in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How did web services evolve into microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a microservice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the microservice architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the microservices design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should Micronaut be preferred for developing microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which framework should be used to develop microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you install the Micronaut CLI on macOS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you install the Micronaut CLI on Windows OS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a project using the Micronaut CLI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a project using Micronaut Launch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
