- en: '*Chapter 3*: GraalVM Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：GraalVM 架构'
- en: In [*Chapter 1*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Evolution
    of Java Virtual Machine*, we took a detailed look at the JVM architecture. In
    [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*, we went into more detail on how JVM JIT compilers work. We also
    looked at how JVM has evolved into an optimum HotSpot VM, with C1 and C2 JIT compilers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014) *Java 虚拟机的发展* 中，我们详细探讨了
    JVM 架构。在 [*第 2 章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028) *JIT、HotSpot
    和 GraalJIT* 中，我们更详细地介绍了 JVM JIT 编译器的工作原理。我们还探讨了 JVM 如何发展成为最优的 HotSpot VM，拥有 C1
    和 C2 JIT 编译器。
- en: While the C2 compiler is very sophisticated, it has become a very complex piece
    of code. GraalVM provides a Graal compiler, which builds on top of all the best
    practices from the C2 compiler, but it is built entirely from the ground up in
    Java. Hence, Graal JIT is more object-oriented, and has modern and manageable
    code, with the support of all of the modern integrated development environments,
    tools, and utilities to monitor, tune, and manage the code. GraalVM is much more
    than just the Graal JIT compiler. GraalVM brings in a larger ecosystem of tools,
    runtimes, and APIs to support multiple languages (Polyglot) to run on VMs, leveraging
    the most mature and hardened JIT compilation provided by Graal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C2 编译器非常复杂，但它已经成为一段非常复杂的代码。GraalVM 提供了一个 Graal 编译器，它基于 C2 编译器的所有最佳实践，但它是完全从零开始用
    Java 编写的。因此，Graal JIT 更具有面向对象的特点，拥有现代且易于管理的代码，并支持所有现代集成开发环境、工具和实用程序来监控、调整和管理代码。GraalVM
    远不止是 Graal JIT 编译器。GraalVM 引入了一个更大的工具、运行时和 API 生态系统，以支持多种语言（多语言）在 VM 上运行，利用 Graal
    提供的最成熟和最坚固的 JIT 编译。
- en: In this chapter, we will focus on the GraalVM architecture and its various components
    to achieve the most advanced, fastest, polyglot runtime for the cloud. We will
    also explore the cloud-native architectural patterns, and how GraalVM is the best
    platform for the cloud.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将重点关注 GraalVM 架构及其各种组件，以实现最先进、最快的多语言云运行时。我们还将探讨云原生架构模式，以及 GraalVM 是云的最佳平台。
- en: Before we get into the details of the GraalVM architecture, we will begin by
    learning the requirements of a modern technical architecture. Later in the chapter,
    as we go through each of the GraalVM architectural components, we will address
    these requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 GraalVM 架构的细节之前，我们将首先学习现代技术架构的需求。在章节的后面，当我们逐一介绍 GraalVM 架构组件时，我们将解决这些需求。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reviewing modern architectural requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查现代架构需求
- en: Learning what the GraalVM architecture is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 GraalVM 架构是什么
- en: Reviewing the GraalVM editions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查 GraalVM 版本
- en: Understanding the GraalVM architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraalVM 架构
- en: An overview of the GraalVM microservices architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 微服务架构概述
- en: An overview of various microservices frameworks that can build code for GraalVM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述各种可以为 GraalVM 构建代码的微服务框架
- en: Understanding how GraalVM addresses various non-functional aspects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraalVM 如何解决各种非功能性方面
- en: By the end of this chapter, you will have a very clear understanding of the
    GraalVM architecture and how various components come together to provide a comprehensive
    VM runtime for polyglot applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对 GraalVM 架构以及各种组件如何协同工作以提供针对多语言应用的全面 VM 运行时有一个非常清晰的理解。
- en: Reviewing modern architectural requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查现代架构需求
- en: Before we dig deeper into the GraalVM architecture, let's first understand the
    shortcomings of JVM and why we need a new architecture and approach. The older
    versions of JVM were optimized for traditional architectures, which were built
    for long-running applications that run in a data center, providing high throughput
    and stability (for example, monolith web application servers and large client-side
    applications). Some microservices are long-running, and Graal JIT will also provide
    the optimum solution. As we move to cloud-native, the whole architecture paradigm
    has shifted to componentized, modularized, distributed, and asynchronous architecture
    tuned to run efficiently with high scalability and availability requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Let's break this down into more specific requirements for the modern cloud-native
    architectures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Smaller footprint
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The applications are composed of granular modular components (microservices)
    for high scalability. Hence, it is important to build the applications with a
    smaller footprint, so that they don't consume too much RAM and CPU. As we move
    to cloud-native deployments, it's even more important, as we have *p**ay-per-use*
    on the cloud. The smaller the footprint, the more we can run with fewer resources
    on the cloud. This has a direct impact on **Total Cost of Ownership** (**TCO**),
    one of the key business KPIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A smaller footprint also helps us to make changes and deploy them rapidly and
    continuously. This is very important in the agile world, where the systems are
    built to embrace change. As businesses change rapidly, applications are also required
    to embrace changes rapidly to support business decisions. In traditional monolith
    architectures, even a small change requires an overall build, test, and deployment.
    In modern architectures, we need flexibility to roll out changes in the functionality
    in a modular way, without bringing the production systems down.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We have new engineering practices such as A/B testing, where we perform the
    testing of these functional modules (microservices) in parallel with the older
    version, to decide whether the new version is good enough to roll out. We perform
    canary deployments (rolling updates), where the application components are updated,
    without stopping the production systems. We will cover these architectural requirements
    in more detail in the *DevOps – continuous integration and delivery* section later
    in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Quicker bootstrap
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scalability is one of the most important requirements. Modern applications are
    built to scale up and down rapidly based on the load. The load has increased exponentially
    and modern-day applications are required to handle any load gracefully. With a
    smaller footprint, it's also expected that these application components (microservices)
    boot up quickly to start handling the load. As we move toward more serverless
    architectures, the application components are expected to handle bootup and shutdown
    on request. This requires a very rapid bootup strategy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A quicker bootstrap and smaller footprint also pose the challenge of building
    application components with embeddable VM. The container-based approach requires
    these application components to be immutable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的引导和更小的占用空间也带来了挑战，即使用可嵌入的虚拟机构建应用程序组件。基于容器的方案要求这些应用程序组件是不可变的。
- en: Polyglot and interoperability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多语言和互操作性
- en: 'Polyglot is the reality: each language has its own strengths and will continue
    to have, so we need to embrace this fact. If you look at the core logic of the
    interpreter/compiler, they are all the same. They all try to achieve similar levels
    of optimization and generate the fastest running machine code with the smallest
    footprint. What we need is an optimum platform that can run these various applications,
    written in different languages, and also allow interoperability between them.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言是现实：每种语言都有其自身的优势，并将继续存在，因此我们需要接受这一事实。如果你看看解释器/编译器的核心逻辑，它们都是相同的。它们都试图达到类似的优化水平，并生成具有最小占用空间的运行最快的机器代码。我们需要的是一个最佳平台，可以运行用不同语言编写的各种应用程序，并允许它们之间进行互操作性。
- en: With these architecture requirement lists in mind, let's now understand how
    GraalVM works and how it addresses these requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了这些架构要求列表之后，现在让我们了解 GraalVM 的工作原理以及它是如何满足这些要求的。
- en: Learning what the GraalVM architecture is
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 GraalVM 架构是什么
- en: GraalVM provides a Graal JIT compiler, an implementation of JVMCI (which we
    covered in the previous chapter), which is completely built on Java and uses C2
    compiler optimization techniques as the baseline and builds on top of it. Graal
    JIT is much more sophisticated than a C2 compiler. GraalVM is a drop-in replacement
    for JDK, which means that all the applications that are currently running on JDK
    should run on GraalVM without any application code changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 提供了一个 Graal JIT 编译器，这是 JVMCI 的实现（我们在上一章中已经介绍过），它完全基于 Java，并以 C2 编译器优化技术为基础，在此基础上构建。Graal
    JIT 比一个 C2 编译器要复杂得多。GraalVM 是 JDK 的替代品，这意味着所有目前在 JDK 上运行的应用程序都应该在 GraalVM 上运行，而无需对应用程序代码进行任何更改。
- en: While GraalVM is built on Java, it not only supports Java, but also enables
    Polyglot development with JavaScript, Python, R, Ruby, C, and C++. It provides
    an extensible framework called **Truffle** that allows any language to be built
    and run on the platform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GraalVM 是基于 Java 构建的，但它不仅支持 Java，还支持使用 JavaScript、Python、R、Ruby、C 和 C++ 进行多语言开发。它提供了一个可扩展的框架，称为
    **Truffle**，允许任何语言在平台上构建和运行。
- en: GraalVM also provides AOT compilation to build native images with static linking.
    GraalVM comes with the following list of runtimes, libraries, and tools/utilities
    (this is for the GraalVM 20.3.0 version. The latest list of components can be
    found at [https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/).)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 还提供了 AOT 编译功能，以静态链接的方式构建原生镜像。GraalVM 包含以下运行时、库和工具/实用程序列表（这是针对 GraalVM
    20.3.0 版本的。最新组件列表可以在 [https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/)
    找到。）
- en: 'First, let''s have a look at the core components in the following table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下以下表格中的核心组件：
- en: '![](img/B16878_Table_3.1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16878_Table_3.1.jpg)'
- en: 'Next, let''s go through the list of additional tools and utilities in the following
    table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下以下表格中列出的额外工具和实用程序：
- en: '![](img/B16878_Table_3.2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16878_Table_3.2.jpg)'
- en: Now that we are aware of the components in GraalVM, we will go through the various
    editions of GraalVM that are available, and the differences between these editions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 GraalVM 的组件，我们将探讨 GraalVM 可用的各种版本，以及这些版本之间的差异。
- en: Reviewing the GraalVM editions (Community and Enterprise)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 GraalVM 版本（社区和企业）
- en: 'GraalVM is available as Community and Enterprise Editions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 可作为社区版和企业版提供：
- en: '**Community Edition**: GraalVM **Community Edition** (**CE**) is an open source
    edition built as an OpenJDK distribution. Most of the components of GraalVM are
    GPL 2, with a classpath exception licensed. For more details on licensing, please
    refer to [https://github.com/oracle/graal#license](https://github.com/oracle/graal#license).
    GraalVM CE is based on OpenJDK 1.8.272 and OpenJDK 11.0.9\. GraalVM CE is community
    supported. It can be deployed in production. However, it does not come with the
    required support services from Oracle. Oracle also provides a Docker image, which
    is readily downloadable, for testing and evaluation (refer to [https://www.graalvm.org/docs/getting-started/container-images/](https://www.graalvm.org/docs/getting-started/container-images/)
    for further details).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区版**：GraalVM **社区版**（**CE**）是一个开源版本，作为OpenJDK发行版构建。GraalVM的大多数组件是GPL 2，带有类路径例外许可。有关许可的更多详细信息，请参阅[https://github.com/oracle/graal#license](https://github.com/oracle/graal#license)。GraalVM
    CE基于OpenJDK 1.8.272和OpenJDK 11.0.9。GraalVM CE由社区支持。它可以部署在生产环境中。然而，它不包含Oracle提供的要求支持服务。Oracle还提供可下载的Docker镜像，用于测试和评估（有关更多详细信息，请参阅[https://www.graalvm.org/docs/getting-started/container-images/](https://www.graalvm.org/docs/getting-started/container-images/)）。'
- en: '**Enterprise Edition**: GraalVM **Enterprise Edition** (**EE**) is a licensed
    version under the GraalVM OTN license agreement. This is free for evaluation and
    building non-production applications. GraalVM EE provides additional performance
    (~20% faster than CE and dynamic languages such as JavaScript, Python, R, and
    Ruby are ~2x faster), a smaller footprint (~2x smaller than CE), security (native
    code memory protection), and scalability for running production enterprise applications.
    EE comes with additional debugging tools, such as Ideal Graph Visualizer, which
    helps in not only debugging performance issues, but also in fine-tuning the applications
    for best performance on GraalVM. GraalVM EE comes with support services. For Oracle
    cloud customers, GraalVM EE support is available as part of the subscription.
    GraalVM EE also has a managed mode, which does better heap management, avoiding
    page faults and crashes. GraalVM EE is available for clients who already have
    a Java SE subscription.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业版**：GraalVM **企业版**（**EE**）是在GraalVM OTN许可协议下的授权版本。此版本可用于评估和构建非生产应用程序。GraalVM
    EE提供了额外的性能（比CE快约20%），更小的占用空间（比CE小约2倍），安全性（原生代码内存保护），以及运行生产级企业应用程序的可伸缩性。EE版包含额外的调试工具，如Ideal
    Graph Visualizer，它不仅有助于调试性能问题，还有助于在GraalVM上优化应用程序以获得最佳性能。GraalVM EE还提供支持服务。对于Oracle云客户，GraalVM
    EE支持作为订阅的一部分提供。GraalVM EE还有一个托管模式，它更好地管理堆，避免页面错误和崩溃。GraalVM EE适用于已订阅Java SE的客户。'
- en: Now that we know the various available editions of GraalVM, and what runtimes,
    tools, and frameworks come with it, let's get into the details of the GraalVM
    architecture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GraalVM的各种可用版本以及它所包含的运行时、工具和框架，让我们深入了解GraalVM的架构。
- en: Understanding the GraalVM architecture
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GraalVM架构
- en: 'In this section, we will look at the various architectural components of GraalVM.
    We will look at how various runtimes, tools, and frameworks come together to provide
    the most advanced VM and runtime. The following diagram shows the high-level architecture
    of GraalVM:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨GraalVM的各种架构组件。我们将了解各种运行时、工具和框架是如何结合在一起以提供最先进的虚拟机和运行时的。以下图表显示了GraalVM的高级架构：
- en: '![Figure 3.1 – Graal VM architecture'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – Graal VM架构]'
- en: '](img/B16878_Figure_3.1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16878_Figure_3.1.jpg]'
- en: Figure 3.1 – Graal VM architecture
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Graal VM架构
- en: Let's go through each of these components in detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地逐一介绍这些组件。
- en: JVM (HotSpot)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM（HotSpot）
- en: JVM HotSpot is the regular Java HotSpot VM. The C2 compiler, which is part of
    the HotSpot VM, is replaced with the Graal JIT compiler implementation. The Graal
    JIT compiler is an implementation of **Java Virtual Machine Compiler Interface**
    (**JVMCI**) and plugs into the Java VM. We covered the architecture of JVM HotSpot
    in the previous chapters. Please refer to them for a more in-depth understanding
    of how JVM HotSpot works and the various architectural components of JVM.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JVM HotSpot是常规的Java HotSpot VM。HotSpot VM中的C2编译器被Graal JIT编译器实现所取代。Graal JIT编译器是Java虚拟机编译器接口（**JVMCI**）的一个实现，并插入到Java
    VM中。我们在前面的章节中介绍了JVM HotSpot的架构。请参考它们以深入了解JVM HotSpot的工作原理以及JVM的各种架构组件。
- en: Java Virtual Machine Compiler Interface (JVMCI)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java虚拟机编译器接口（JVMCI）
- en: JVMCI was introduced in Java 9\. This allowed compilers to be written as plugins
    that JVM can call for dynamic compilation. It provides an API and a protocol to
    build compilers with custom implementations and optimizations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The word *compiler* in this context means a just-in-time compiler. We went into
    a lot of detail on JIT compilers in the previous chapters. GraalVM uses JVMCI
    to get access to the JVM objects, interact with JVM, and install the machine code
    into the code cache.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Graal JIT implementation comes in two modes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '`libgraal`: `libgraal` is an AOT compiled binary that is loaded by HotSpot
    VM as a native binary. This is the default mode and the recommended way to run
    GraalVM with HotSpot VM. In this mode, `libgraal` uses its own memory space and
    does not use the HotSpot heap. This mode of Graal JIT has quick bootup and improved
    performance.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jargraal`: In this mode, Graal JIT is loaded like any other Java class, and
    hence it goes through a warm-up phase and runs with an interpreter until the hot
    methods are identified and optimized. This mode can be invoked by passing the
    `--XX:-UseJVMCINativeLibrary` flag from the command line.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In OpenJDK 9+, 10+, and 11+, we use the `-XX:+UnlockExperimentalVMOptions`,
    `-XX:+UseJVMCICompiler`, and `XX:+EnableJVMCI` flags to run the Graal compiler,
    instead of the C2 compiler. GraalVM, by default, uses the Graal JIT compiler.
    It is always advisable to use GraalVM distributions, as these have the latest
    changes. OpenJDK gets the changes merged at a slower rate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be going into detail on how Graal JIT is better
    than the C2 JIT, using a sample code. We will be using the debugging tools and
    utilities that come with Graal to demonstrate the optimizations that Graal JIT
    performs at runtime.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Graal compiler and tooling
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Graal compiler is built on JVMCI and provides a better JIT compiler (C2
    as we covered in both the previous chapters) implementation, with further optimizations.
    The Graal compiler also provides an AOT (Graal AOT) compilation option to build
    native images that can run standalone with embedded VMs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Graal JIT compiler
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We looked at the JVM architecture in [*Chapter 1*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Evolution of Java Virtual Machine*. For reference, here is the high-level architecture
    overview of JVM:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – JVM architecture with a C2 compiler'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – JVM architecture with a C2 compiler
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the C1 and C2 compilers implement the JIT compilation as part
    of the JVM execution engine. We went into a lot of detail on how C1 and C2 optimize/deoptimize
    the code based on the compilation threshold.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'GraalVM replaces the JIT compiler in JVM and incorporates further optimization.
    The following diagram shows the high-level architecture of GraalVM:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – VM architecture with Graal compiler'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.3.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – VM architecture with Graal compiler
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: One of the differences between the JVM JIT compiler and Graal JIT is that Graal
    JIT is built to optimize the intermediate code representation (**abstract syntax
    tree** (**AST**) and using Graal graphs, or Graal intermediate representation).
    Java represents the code as an AST, an intermediate representation, while compiling.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Any language expressions and instructions can be converted and represented as
    ASTs; this helps in abstracting the language-specific syntax and semantics from
    the logic of optimizing the code. This approach makes GraalVM capable of optimizing
    and running code written in any language, as long as the code can be converted
    into an AST. We will be doing a deep dive into Graal graphs and ASTs in [*Chapter
    4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077), *Graal Just-In-Time Compiler*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The four key components of the Graal JIT compiler are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiler**: As the name suggests, it profiles the running code and generates
    the information that is used by the code optimizer to take decisions or make assumptions
    regarding optimization.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intermediate Code Generator**: This generates the intermediate code representation,
    which is the input for the code optimizer.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code Optimizer**: This uses the data that is collected by profiles and optimizes
    the intermediate code.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target Code Generator**: The optimized code is then converted to the target
    machine code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how Graal JIT works at a very high level:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Graal JIT compilation – a high-level flowchart'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Graal JIT compilation – a high-level flowchart
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this flowchart better:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The JVM language (Java, Kotlin, Groovy, and so on) code runs on Graal JIT natively,
    and Graal JIT optimizes the code.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-JVM languages (such as JavaScript and Ruby) implement a language parser
    and interpreter using the Truffle API. The language interpreters convert the code
    into AST representation. Graal runs the JIT compilation on the intermediate representation.
    This helps in leveraging all the advanced optimization techniques implemented
    by Graal to non-JVM languages.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The native LLVM-based languages (such as C/C++, Swift, and Objective C) follow
    a slightly different route to convert to the intermediate representation. Graal
    Sulong is used to create the intermediate representation that is used by Graal.
    We will be talking about Truffle and Sulong later in this chapter.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graal JIT optimization strategies
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Graal JIT optimization strategies are built from the ground up, based on the
    best practices from the C2 JIT compiler optimization strategies. Graal JIT builds
    on top of the C2 optimization strategies and provides more advanced optimization
    strategies. Here are some of the optimization strategies that the Graal JIT compiler
    performs:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Partial escape analysis
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved inlining ([http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf](http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf))
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard optimization ([http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf))
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining lambdas
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-procedural optimization
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be covering these optimization strategies in detail, with the help of
    sample code and examples, in the next chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Truffle
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Truffle framework is an open source library for building the interpreters
    and the tools/utilities (such as integrated development environments, debuggers,
    and profilers). The Truffle API is used to build language interpreters that can
    run on GraalVM, leveraging the optimizations provided by GraalVM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The Graal and Truffle frameworks consist of the following APIs that enable
    Polyglot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Language Implementation Framework**: This framework is used by the language
    implementers. It also comes with a reference implementation of a language called
    **SimpleLanguage**. We will be going through this in detail in [*Chapter 9*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169),
    *Graal Polyglot – LLVM, Ruby, and WASM*.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyglot API**: This set of APIs aids interaction between code written in
    different languages (guest languages) with Java (the host language). For example,
    a Java (host) program can embed R (guest) language code to perform some machine
    learning/AI logic. The Polyglot API provides the framework that will help the
    language programmers to manage the objects between the guest and the host.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumentation**: The Truffle Instrumentation API provides the framework
    for utilities/tool builders to build integrated development/debugging environments,
    tools, and utilities. The tools and utilities that are built using the Truffle
    Instrumentation API can work with any language that is implemented with Truffle.
    This provides a consistent developer experience across various languages and leverages
    the sophisticated debugging/diagnostic capabilities of JVM.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3.5* shows the high-level architecture of how Truffle acts as an intermediate
    layer between GraalVM and other language interpreters. The individual language
    interpreters are implemented using the Truffle API. Truffle also provides an interoperability
    API, for calling methods and passing data between methods across various language
    implementations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Truffle architecture'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.5.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Truffle architecture
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: As represented in the previous diagram, Java applications run directly on the
    GraalVM, with Graal Compiler replacing the C2 JIT compiler. Other language programs
    run on top of the Truffle Language Implementation framework. The respective language
    interpreters use the Truffle to implement the interpreters. Truffle combines the
    code along with the interpreter to produce the machine code, using partial evaluation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'AST is the intermediate representation. AST provides the optimum way to represent
    the syntactic structure of the language, where typically, the parent node is the
    operator, and the children node represents the operands or operators (based on
    cardinality). The following diagram shows a rough representation of AST:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – AST for simple expression'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.6.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – AST for simple expression
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, **a**, **b**, and **c** can be any variables (for loosely typed
    languages). The interpreter starts assuming "generics" based on the profiling
    of various executions. It then starts assuming the specifics and will then optimize
    the code using partial evaluation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Truffle (language interpreters written with Truffle) runs as an interpreter
    and Graal JIT kicks in to start identifying optimizations in the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The optimizations are based on speculation, and eventually, if the speculation
    is proven to be incorrect at runtime, the JIT will re-optimize and recompile (as
    shown in the previous diagram). Re-optimization and recompiling is an expensive
    task.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial evaluation creates an intermediate representation of the language,
    from the code and the data, and as it learns, and identifies new data types, it
    deoptimizes to the AST interpreter, applies optimizations, and does the node rewriting
    and recompiles. After a certain point, it will have the optimum representation.
    The following diagram explains how Truffle and Graal optimize intermediate representation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – AST optimization by Graal JIT'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.7.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – AST optimization by Graal JIT
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this diagram better:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The expression is reduced to an AST. In the AST nodes, the leaf nodes are operands.
    In this example, we have taken a very simple expression to understand how partial
    evaluation works. In a language such as JavaScript, which is not a strongly typed
    language, a, b, and c can be any data type (sometimes referred to as generics).
    Evaluating a generic in an expression is a costly operation.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the profiling, Graal JIT speculates and assumes a specific data type
    (in this example, as an integer), optimizes the code to evaluate the expression
    for integers, and compiles the code.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, it is using an inlining optimization strategy. The Graal JIT
    compiler has various other optimization strategies that are applied based on the
    use case.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When, during runtime, the compiler identifies a control flow where one of the
    operands is not really an integer, it deoptimizes and rewrites the AST with the
    new data type and optimizes the code.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following a few iterations of running this optimization/deoptimization, the
    compiler will eventually generate the most optimum code.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key difference here is that Graal is working on the AST and generating optimized
    code, and it does not matter what language is used to write the source code as
    long as the code is represented as AST.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a high-level flow of how different languages run
    on GraalVM, with Truffle acting as an intermediate layer, to execute any programming
    language code on GraalVM:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Truffle and Graal compilation flowchart'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.8.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Truffle and Graal compilation flowchart
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This diagram illustrates a simpler representation of how Truffle acts as a layer
    between non-JVM languages and GraalVM. The code can also be built directly as
    a native image with Substrate VM.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Truffle API is used along with a custom annotations processor to generate interpreter
    source code, which is then compiled. Java code does not need the intermediate
    representation. It can be compiled directly to run on GraalVM. We will discuss
    Truffle interpreters and how to write a custom interpreter in [*Chapter 9*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169),
    *Graal Polyglot – LLVM, Ruby, and WASM*. We will cover the Truffle Polyglot API
    in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An
    Overview*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Truffle also provides a framework called the **Truffle Instrument API** for
    building tools. Instruments provide fine-grained VM-level runtime events, which
    can be used to build profiling, tracing analyzing, and debugging tools. The best
    part is that the language interpreters built with Truffle can use the ecosystem
    of Truffle instruments (for example, VisualVM, Chrome Debugger, and GraalVM Visual
    Studio Code Extension).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Truffle provides the **Polyglot Interoperability Protocol**. This protocol defines
    the message that each language needs to implement and supports the passing of
    data between the Polyglot applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Sulong – LLVM
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLVM is an open source project that is a collection of modular, reusable compilers
    and toolchains. There are a lot of language (C, C++, Fortran, Rust, Swift, and
    so on) compilers that are built on LLVM, where LLVM provides the intermediate
    representation (also known as LLVM-IR).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sulong pipeline looks different from what we looked at in other language
    compilers that are running on Truffle. The following diagram shows how C/C++ code
    gets compiled:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – LLVM compilation flowchart'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.9.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – LLVM compilation flowchart
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows how an application code written in C is compiled and run
    on GraalVM. The application code in native languages such as C/C++ is compiled
    in Clang, into an intermediate representation. This LLVM intermediate representation
    runs on the LLVM intermediate representation interpreter, which is built on the
    Truffle API. Graal JIT will further optimize the code at runtime.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: SubstrateVM (Graal AOT and native image)
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications on Graal can be deployed on GraalVM or SubstrateVM. SubstrateVM
    is embeddable VM code that gets packaged during AOT compilation in native images.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Graal AOT compilation is a very powerful way to create native binaries for a
    particular targeted OS/architecture. For cloud-native workloads and serverless,
    this is a very powerful option for achieving a smaller footprint, faster startups,
    and, more importantly, embeddable runtimes (providing immutability).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Rapid componentized modular deployment (containers) also poses management and
    versioning challenges. This is typically called **Configuration Drift**, which
    is one of the major issues that we face in managing a large number of containers
    in high-availability environments. Typically, container infrastructure is built
    by a team and, over time, it is managed by different teams. There are always situations
    where we are forced to change the configuration of the VMs/containers/OS in a
    particular environment that we may never trace. This causes a gap between production
    and the DR/HA environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Immutable infrastructure (images) helps us do better version control of the
    infrastructure. It also gives us more confidence in testing, as the underlying
    infrastructure on which our application containers are running is immutable, and
    we are certain about the test results. To build immutable components, we require
    an embeddable VM (with a small footprint). SubstrateVM provides that embeddable
    VM.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'In AOT compilation, the code is compiled directly to the machine code and executed.
    There is no runtime profiling or optimization/deoptimization. The Graal AOT compiler
    (also referred to as the "native image" compiler) performs static analysis and
    static initializations on the code and produces a VM-embedded executable code.
    The optimization performed by AOT is based on the reachability of the code. The
    following diagram shows the compilation process:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Graal AOT compilation'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Graal AOT compilation
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows how the Graal AOT compiles native images and embeds SubstrateVM
    as part of the native image. One of the disadvantages of AOT compilation is that
    the VM cannot optimize the code based on runtime profiling, as in JIT. To address
    this issue, we use a profile guided optimization strategy to capture the runtime
    metrics of the application and use that profiled data to optimize the native image
    by recompiling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Profile Guided Optimization (PGO)
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GraalVM uses **Profile Guided Optimization** (**PGO**) to optimize native images
    based on the runtime profiling data. This is one of the features that is available
    in Enterprise Edition only. The following diagram shows how a PGO pipeline works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Graal AOT compilation with PGO'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.11.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Graal AOT compilation with PGO
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this workflow better:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: When the code is compiled with `native-image`, we use the `--pgo-instrumented`
    flag. This will tell the compiler to inject instrumentation code into the compiled
    code.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we start running this instrumented native image, the profiler starts collecting
    the runtime data and then starts creating the profile files (`.ipof`).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have run the native image with various workloads (all possible workloads
    – to capture as much instrumentation as possible), we can then recompile the native
    image with the `--pgo` flag (`native-image --pgo=profile.iprof`), providing the
    profile files as input. The Graal native image compiler creates the optimum native
    image.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be building a native image with profile-guided optimization in the next
    chapter with the help of real examples and also understand how memory management
    works in native images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM is a great runtime for the modern microservices architecture. In the
    next section, we will go through the various features of GraalVM that help to
    build a microservices application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: An overview of GraalVM microservices architecture
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM is ideal for microservices architecture. One of the most important requirements
    for certain microservices architecture is a smaller footprint and faster startup.
    GraalVM is an ideal runtime for running Polyglot workloads in the cloud. Cloud-native
    frameworks are already available on the market that can build applications to
    run optimally on GraalVM, such as Quarkus, Micronut, Helidon, and Spring. These
    frameworks are found to perform almost 50x times faster when running as native
    images. We will go into detail about how GraalVM is the right runtime and platform
    for microservices in [*Chapter 10*](B16878_10_Final_SK_ePub.xhtml#_idTextAnchor187),
    *Microservices Architecture with GraalVM.*
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how GraalVM addresses various non-functional aspects
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through the typical non-functional requirements
    of a microservices cloud-native architecture, and how GraalVM addresses these
    requirements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Performance and scalability
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance and scalability are among the more important non-functional requirements
    of a microservices cloud-native architecture. The microservices are automatically
    scaled out and down by orchestrators such as Kubernetes. This requires the microservices
    to be built on a runtime that starts up quickly and runs fast, consuming minimal
    cloud resources. GraalVM AOT compilation helps to build native images that perform
    on a par with native languages such as C/C++.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how AOT compiled code (native image) is faster than JIT compiled
    code, let''s look at the steps that JIT and AOT follow at runtime:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Graal JIT versus the AOT flowchart'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.12.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Graal JIT versus the AOT flowchart
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows the high-level steps for JIT and AOT. JIT optimizes the code
    over a period of time by profiling the code at runtime. There are performance
    overheads, as there is additional profiling, optimizing, and deoptimizing that
    is done by the JVM at runtime.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: It is observed, based on the Apache Bench benchmark, that while GraalVM JIT
    throughput and performance is lower than AOT at the beginning, as the number of
    requests increases, Graal JIT optimizes and performs better than Graal AOT after
    around 14,000 requests per second.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: It is also observed that Graal AOT performs 50 times faster than Graal JIT and
    has a 5x smaller memory footprint than Graal JIT.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Graal AOT with PGO throughput is consistent and sometimes better than Graal
    JIT. However, for long-running tasks, Graal JIT might have better throughput.
    So, for the best throughput and consistent performance, Graal AOT with PGO is
    the best.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the benchmark study published at [https://www.infoq.com/presentations/graalvm-performance/](https://www.infoq.com/presentations/graalvm-performance/)
    and [https://www.graalvm.org/why-graalvm/](https://www.graalvm.org/why-graalvm/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: There are further benchmark studies that are published with academic collaborators
    at [https://renaissance.dev](https://renaissance.dev).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we can conclude:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM Native Image (AOT) is best for faster startups and applications that
    require a smaller footprint, such as serverless applications and container microservices.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM JIT is best for peak throughputs. Throughput is a very important aspect
    for long-running processes, where scalability is critical. This could be high-volume
    web application servers such as e-commerce servers and stock market applications.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of garbage collection configuration and JIT will help in achieving
    reduced latency. Latency is very important as regards the responsiveness of applications.
    When we are running high throughput, it's possible that on occasion, garbage collection
    slows down the response.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is not a hard and fast rule for using it. It depends on various combinations
    that we need to decide between JIT and AOT, and various other configurations that
    are possible. We will explore various compiler and native image configurations
    in the next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GraalVM security is built on JVM security, which is based on the sandbox model.
    Let''s have a very quick review of how the sandbox model works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – JVM security model'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – JVM security model
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In Java 2 security architecture, all the class files are verified by bytecode
    verifier (please refer to both the previous chapters for more details on class
    loaders). The bytecode verifier checks whether the class files are valid and look
    for any overflows, underflows, data type conversions, method calls, references
    to classes, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Once the bytecode is verified, the dependent classes are loaded by the class
    loader. Please refer to [*Chapter 1*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Evolution of Java Virtual Machine*, to understand how the class loader subsystem
    works. Class loaders work with Security Manager and access control to enforce
    security rules that are defined in the policy files. Java code that is downloaded
    over the network is checked for a signature (represented as `java.security.CodeSource`,
    including the public key).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Security Manager (`java.lang.SecurityManager`) is the most important component
    for handling authorizations. Security Manager has various checks in place to ensure
    that the authorization is done. The access controller (`java.security.AccessContoller`)
    class is another critical class that helps control access to system resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Keystore is a password-protected store that holds all the private keys and certificates.
    Each entry in the store can also be password-protected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Java Security is extendable, with custom security implementations called **Security
    Providers**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM builds on the Java security model and abstracts it to address enforcing
    security at intermediate representation level. GraalVM does not recommend running
    untrusted code on Security Manager.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraalVM security model uses the Truffle language implementation framework
    API for JVM host applications to create an execution context, which is passed
    to the guest application (application code written in different languages). The
    following diagram shows the high-level architecture of how GraalVM allows the
    guest and host applications to interoperate and determine how access is controlled:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Graal security model'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.14.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Graal security model
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The execution context (`org.graalvm.polyglot.Context`) defines the access control
    for the guest applications. Based on the access control that is defined in the
    execution context, the guest applications get access to the system's resources.
    GraalVM provides a Polyglot API to create these access controls, with an execution
    context, to set the access privileges to access various functions, such as File
    I/O, Threading, and Native Access. Based on what privileges are set by the host,
    the guest will have that access. A watchdog thread is used to timebound the context.
    The watchdog will close the context, in the given time, to free up the resources,
    and restrict access based on time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how the execution context can be set:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'GraalVM also offers an API to exchange objects between host and guest applications:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`@HostAccess.Export` Annotation, for example).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host to Guest Data Exchange**: The objects passed from the host to the guest
    need to be handled by guest languages. The data is passed through the context,
    for example:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Value `a` can be returned by the host application to the JavaScript guest application
    with a value of `42` (after evaluation).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering this in detail in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120),
    *Truffle – An Overview*, with the help of a real example.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM EE also provides a managed execution mode for LLVM intermediate representation
    code to handle any memory violations and faults. Please refer to [https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html](https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html)
    for more details.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: DevOps – continuous integration and delivery
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DevOps automation is one of the core requirements of any modern, cloud-native
    architecture. GraalVM integrates very well into the DevOps pipeline. The following
    diagram illustrates a typical GitOps pipeline with representative software (GraalVM
    integrates into any stack of the DevOps software stack):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – GitOps with GraalVM'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_3.15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – GitOps with GraalVM
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand this diagram better.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Continuous Integration** (**CI**) pipeline gets triggered by a typical
    pull request from the Git repository with changes in the application code and
    infrastructure code. CI tools such as GitHub actions, Argo CD, or CicleCI can
    be used to orchestrate a CI pipeline. A typical CI pipeline consists of the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: In the build phase, the release tagged code is pulled from the appropriate
    branch from the Git repository. The code is verified (any static code analysis)
    and built. For cloud-native, typically, the code is built as native images, using
    the Graal AOT compiler.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: The code is tested with unit testing scripts and further verified
    for any security vulnerabilities.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package**: Once the code passes all the tests, the code is typically packaged
    into the cloud-native target runtime (using a Docker image or VM or any other
    binary format). The target could be a serverless container or Docker container
    or a VM.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store**: The final binaries are stored on binary stores or repositories,
    such as Docker Hub or Red Hat Quay (if it''s a Docker image).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Continuous Deployment pipeline can either be triggered based on a release
    plan or can be manually triggered (depending on the release plan and strategy).
    Continuous Deployment typically has the following phases:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment for Validation**: The final binary ID deployed to an environment
    where the binary can now be tested end to end. Various strategies can be followed:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a. **Traditionally**: We have an Integration Test Environment and a User Acceptance
    Test Environment (or Pre-Production Environment) for various levels of validation
    and testing.'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. **Blue/Green Deployment**: There are two parallel environments (called Blue
    and Green). One of them will be in production, let''s assume Blue. The Green environment
    can be used to test and validate our code. Once we are sure that the new release
    is working fine, we use the router to switch to the Green environment and use
    the Blue environment for testing future releases. This provides a high availability
    way to deploy applications.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c. **Canary Deployments and Rolling Updates**: Canary deployment is more a
    recent approach of using the same environment for both production and validation.
    This is a great feature to test our code and compare the new release with the
    current release (A/B testing). Canary deployments provide an API management layer,
    which can be used to redirect the traffic to specific endpoints, based on various
    parameters (such as testing users or a user from a specific department can access
    the new version, while end users are still using the old version). The application
    can be deployed on a specific number of servers/nodes (by % or number). As we
    get more confident with the new release, we can perform rolling updates by increasing
    the number of nodes, where the new release should run, and open up to a wider
    circle of users. This also gives the flexibility to perform a phased rollout of
    new releases (by region or user demography or any parameter).'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Testing**: There are various levels of testing that are performed, both functional
    and non-functional. Most of this is performed with automation, and that is also
    choreographed by the Continuous Delivery pipeline.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production Deployment**: Once it''s all tested, the final application is
    deployed to the production environment. Once again, this deployment may use one
    of the Traditional or Blue/Green or Canary strategies.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM provides a very flexible way to deploy the application as a standalone,
    container, cloud, VM, and Oracle database. There are very sophisticated microservices
    frameworks, such as Quarkus, Micronaut, and Fn project, that provide native support
    for GraalVM and integrate very well with modern GitOps tools.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the GraalVM architecture. Graal JIT is the new
    implementation of the JIT compiler, which replaces the C2 compiler, and brings
    in a lot more optimizations. Graal JIT is implemented completely in Java. Truffle
    provides the interpreter implementation framework and Polyglot framework to get
    other non-JVM languages into GraalVM.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided a good understanding of the various runtimes, frameworks,
    tools, Graal updater, and utilities that are shipped with GraalVM. We also looked
    at the two available editions of GraalVM and what the key differences are between
    these two editions. We went through all the various components of the GraalVM
    architecture. We also explored some of the non-functional aspects of the architecture,
    including security model, performance, and DevOps. This is very important if you
    want to understand how GraalVM can be used to build cloud-native microservices
    and high-performing applications across various languages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deeper into how Graal JIT works, how we can
    use the various tools that come with Graal to understand the internal workings
    of Graal JIT, and how we can use these tools to debug and fine-tune our code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the various editions of GraalVM?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JVMCI?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Graal JIT?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Graal AOT? How does PGO help AOT compilation?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Truffle? How does it help to run multiple language codes on GraalVM?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SubstrateVM?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Guest Access Context?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is GraalVM the ideal runtime for cloud-native microservices?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lightweight Cloud-Native Java Applications ([https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673](https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673))
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java on Truffle — Going Fully Metacircular ([https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840](https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840))
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM Enterprise Edition ([https://docs.oracle.com/en/graalvm/enterprise/20/index.html](https://docs.oracle.com/en/graalvm/enterprise/20/index.html))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM Git ([https://github.com/oracle/graal](https://github.com/oracle/graal))
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
