- en: '*Chapter 3*: GraalVM Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：GraalVM 架构'
- en: In [*Chapter 1*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Evolution
    of Java Virtual Machine*, we took a detailed look at the JVM architecture. In
    [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*, we went into more detail on how JVM JIT compilers work. We also
    looked at how JVM has evolved into an optimum HotSpot VM, with C1 and C2 JIT compilers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014) *Java 虚拟机的发展* 中，我们详细探讨了
    JVM 架构。在 [*第 2 章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028) *JIT、HotSpot
    和 GraalJIT* 中，我们更详细地介绍了 JVM JIT 编译器的工作原理。我们还探讨了 JVM 如何发展成为最优的 HotSpot VM，拥有 C1
    和 C2 JIT 编译器。
- en: While the C2 compiler is very sophisticated, it has become a very complex piece
    of code. GraalVM provides a Graal compiler, which builds on top of all the best
    practices from the C2 compiler, but it is built entirely from the ground up in
    Java. Hence, Graal JIT is more object-oriented, and has modern and manageable
    code, with the support of all of the modern integrated development environments,
    tools, and utilities to monitor, tune, and manage the code. GraalVM is much more
    than just the Graal JIT compiler. GraalVM brings in a larger ecosystem of tools,
    runtimes, and APIs to support multiple languages (Polyglot) to run on VMs, leveraging
    the most mature and hardened JIT compilation provided by Graal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C2 编译器非常复杂，但它已经成为一段非常复杂的代码。GraalVM 提供了一个 Graal 编译器，它基于 C2 编译器的所有最佳实践，但它是完全从零开始用
    Java 编写的。因此，Graal JIT 更具有面向对象的特点，拥有现代且易于管理的代码，并支持所有现代集成开发环境、工具和实用程序来监控、调整和管理代码。GraalVM
    远不止是 Graal JIT 编译器。GraalVM 引入了一个更大的工具、运行时和 API 生态系统，以支持多种语言（多语言）在 VM 上运行，利用 Graal
    提供的最成熟和最坚固的 JIT 编译。
- en: In this chapter, we will focus on the GraalVM architecture and its various components
    to achieve the most advanced, fastest, polyglot runtime for the cloud. We will
    also explore the cloud-native architectural patterns, and how GraalVM is the best
    platform for the cloud.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将重点关注 GraalVM 架构及其各种组件，以实现最先进、最快的多语言云运行时。我们还将探讨云原生架构模式，以及 GraalVM 是云的最佳平台。
- en: Before we get into the details of the GraalVM architecture, we will begin by
    learning the requirements of a modern technical architecture. Later in the chapter,
    as we go through each of the GraalVM architectural components, we will address
    these requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 GraalVM 架构的细节之前，我们将首先学习现代技术架构的需求。在章节的后面，当我们逐一介绍 GraalVM 架构组件时，我们将解决这些需求。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reviewing modern architectural requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查现代架构需求
- en: Learning what the GraalVM architecture is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 GraalVM 架构是什么
- en: Reviewing the GraalVM editions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查 GraalVM 版本
- en: Understanding the GraalVM architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraalVM 架构
- en: An overview of the GraalVM microservices architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 微服务架构概述
- en: An overview of various microservices frameworks that can build code for GraalVM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述各种可以为 GraalVM 构建代码的微服务框架
- en: Understanding how GraalVM addresses various non-functional aspects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraalVM 如何解决各种非功能性方面
- en: By the end of this chapter, you will have a very clear understanding of the
    GraalVM architecture and how various components come together to provide a comprehensive
    VM runtime for polyglot applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对 GraalVM 架构以及各种组件如何协同工作以提供针对多语言应用的全面 VM 运行时有一个非常清晰的理解。
- en: Reviewing modern architectural requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查现代架构需求
- en: Before we dig deeper into the GraalVM architecture, let's first understand the
    shortcomings of JVM and why we need a new architecture and approach. The older
    versions of JVM were optimized for traditional architectures, which were built
    for long-running applications that run in a data center, providing high throughput
    and stability (for example, monolith web application servers and large client-side
    applications). Some microservices are long-running, and Graal JIT will also provide
    the optimum solution. As we move to cloud-native, the whole architecture paradigm
    has shifted to componentized, modularized, distributed, and asynchronous architecture
    tuned to run efficiently with high scalability and availability requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨GraalVM架构之前，让我们首先了解JVM的不足之处以及为什么我们需要新的架构和方法。JVM的旧版本是为传统架构优化的，这些架构是为在数据中心运行的长运行应用程序而构建的，提供高吞吐量和稳定性（例如，单体Web应用程序服务器和大型客户端应用程序）。一些微服务是长运行的，Graal
    JIT也将提供最佳解决方案。随着我们转向云原生，整个架构范式已经转变为组件化、模块化、分布式和异步架构，以高效运行并满足高可扩展性和可用性要求。
- en: Let's break this down into more specific requirements for the modern cloud-native
    architectures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些内容分解为现代云原生架构的更具体要求。
- en: Smaller footprint
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更小的占用空间
- en: The applications are composed of granular modular components (microservices)
    for high scalability. Hence, it is important to build the applications with a
    smaller footprint, so that they don't consume too much RAM and CPU. As we move
    to cloud-native deployments, it's even more important, as we have *p**ay-per-use*
    on the cloud. The smaller the footprint, the more we can run with fewer resources
    on the cloud. This has a direct impact on **Total Cost of Ownership** (**TCO**),
    one of the key business KPIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由细粒度的模块化组件（微服务）组成，以实现高可扩展性。因此，构建具有较小占用空间的应用程序非常重要，这样它们就不会消耗过多的RAM和CPU。随着我们转向云原生部署，这甚至更为重要，因为我们在云上实现的是*按使用付费*。占用空间越小，我们可以在云上使用更少的资源运行得越多。这对**总拥有成本**（**TCO**），作为关键业务KPI之一，有直接影响。
- en: A smaller footprint also helps us to make changes and deploy them rapidly and
    continuously. This is very important in the agile world, where the systems are
    built to embrace change. As businesses change rapidly, applications are also required
    to embrace changes rapidly to support business decisions. In traditional monolith
    architectures, even a small change requires an overall build, test, and deployment.
    In modern architectures, we need flexibility to roll out changes in the functionality
    in a modular way, without bringing the production systems down.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更小的占用空间也有助于我们快速连续地做出更改并部署它们。这在敏捷世界中非常重要，因为系统是构建来拥抱变化的。随着商业的快速变化，应用程序也需要快速拥抱变化以支持商业决策。在传统的单体架构中，即使是微小的更改也需要整体构建、测试和部署。在现代架构中，我们需要灵活性，以便以模块化的方式推出功能更改，而不会使生产系统崩溃。
- en: We have new engineering practices such as A/B testing, where we perform the
    testing of these functional modules (microservices) in parallel with the older
    version, to decide whether the new version is good enough to roll out. We perform
    canary deployments (rolling updates), where the application components are updated,
    without stopping the production systems. We will cover these architectural requirements
    in more detail in the *DevOps – continuous integration and delivery* section later
    in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有新的工程实践，例如A/B测试，在这种测试中，我们与旧版本并行测试这些功能模块（微服务），以决定新版本是否足够好，可以发布。我们执行金丝雀部署（滚动更新），其中应用程序组件得到更新，而不会停止生产系统。我们将在本章后面的*DevOps
    – 持续集成和交付*部分更详细地介绍这些架构要求。
- en: Quicker bootstrap
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快的启动
- en: Scalability is one of the most important requirements. Modern applications are
    built to scale up and down rapidly based on the load. The load has increased exponentially
    and modern-day applications are required to handle any load gracefully. With a
    smaller footprint, it's also expected that these application components (microservices)
    boot up quickly to start handling the load. As we move toward more serverless
    architectures, the application components are expected to handle bootup and shutdown
    on request. This requires a very rapid bootup strategy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是最重要的要求之一。现代应用程序是构建来根据负载快速扩展和缩减的。负载呈指数增长，现代应用程序需要优雅地处理任何负载。随着更小的占用空间，也期望这些应用程序组件（微服务）能够快速启动以开始处理负载。随着我们向更多无服务器架构迈进，应用程序组件预计将根据请求处理启动和关闭。这需要一个非常快速的启动策略。
- en: A quicker bootstrap and smaller footprint also pose the challenge of building
    application components with embeddable VM. The container-based approach requires
    these application components to be immutable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的引导和更小的占用空间也带来了挑战，即使用可嵌入的虚拟机构建应用程序组件。基于容器的方案要求这些应用程序组件是不可变的。
- en: Polyglot and interoperability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多语言和互操作性
- en: 'Polyglot is the reality: each language has its own strengths and will continue
    to have, so we need to embrace this fact. If you look at the core logic of the
    interpreter/compiler, they are all the same. They all try to achieve similar levels
    of optimization and generate the fastest running machine code with the smallest
    footprint. What we need is an optimum platform that can run these various applications,
    written in different languages, and also allow interoperability between them.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言是现实：每种语言都有其自身的优势，并将继续存在，因此我们需要接受这一事实。如果你看看解释器/编译器的核心逻辑，它们都是相同的。它们都试图达到类似的优化水平，并生成具有最小占用空间的运行最快的机器代码。我们需要的是一个最佳平台，可以运行用不同语言编写的各种应用程序，并允许它们之间进行互操作性。
- en: With these architecture requirement lists in mind, let's now understand how
    GraalVM works and how it addresses these requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了这些架构要求列表之后，现在让我们了解 GraalVM 的工作原理以及它是如何满足这些要求的。
- en: Learning what the GraalVM architecture is
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 GraalVM 架构是什么
- en: GraalVM provides a Graal JIT compiler, an implementation of JVMCI (which we
    covered in the previous chapter), which is completely built on Java and uses C2
    compiler optimization techniques as the baseline and builds on top of it. Graal
    JIT is much more sophisticated than a C2 compiler. GraalVM is a drop-in replacement
    for JDK, which means that all the applications that are currently running on JDK
    should run on GraalVM without any application code changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 提供了一个 Graal JIT 编译器，这是 JVMCI 的实现（我们在上一章中已经介绍过），它完全基于 Java，并以 C2 编译器优化技术为基础，在此基础上构建。Graal
    JIT 比一个 C2 编译器要复杂得多。GraalVM 是 JDK 的替代品，这意味着所有目前在 JDK 上运行的应用程序都应该在 GraalVM 上运行，而无需对应用程序代码进行任何更改。
- en: While GraalVM is built on Java, it not only supports Java, but also enables
    Polyglot development with JavaScript, Python, R, Ruby, C, and C++. It provides
    an extensible framework called **Truffle** that allows any language to be built
    and run on the platform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GraalVM 是基于 Java 构建的，但它不仅支持 Java，还支持使用 JavaScript、Python、R、Ruby、C 和 C++ 进行多语言开发。它提供了一个可扩展的框架，称为
    **Truffle**，允许任何语言在平台上构建和运行。
- en: GraalVM also provides AOT compilation to build native images with static linking.
    GraalVM comes with the following list of runtimes, libraries, and tools/utilities
    (this is for the GraalVM 20.3.0 version. The latest list of components can be
    found at [https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/).)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 还提供了 AOT 编译功能，以静态链接的方式构建原生镜像。GraalVM 包含以下运行时、库和工具/实用程序列表（这是针对 GraalVM
    20.3.0 版本的。最新组件列表可以在 [https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/)
    找到。）
- en: 'First, let''s have a look at the core components in the following table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下以下表格中的核心组件：
- en: '![](img/B16878_Table_3.1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16878_Table_3.1.jpg)'
- en: 'Next, let''s go through the list of additional tools and utilities in the following
    table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下以下表格中列出的额外工具和实用程序：
- en: '![](img/B16878_Table_3.2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16878_Table_3.2.jpg)'
- en: Now that we are aware of the components in GraalVM, we will go through the various
    editions of GraalVM that are available, and the differences between these editions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 GraalVM 的组件，我们将探讨 GraalVM 可用的各种版本，以及这些版本之间的差异。
- en: Reviewing the GraalVM editions (Community and Enterprise)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 GraalVM 版本（社区和企业）
- en: 'GraalVM is available as Community and Enterprise Editions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 可作为社区版和企业版提供：
- en: '**Community Edition**: GraalVM **Community Edition** (**CE**) is an open source
    edition built as an OpenJDK distribution. Most of the components of GraalVM are
    GPL 2, with a classpath exception licensed. For more details on licensing, please
    refer to [https://github.com/oracle/graal#license](https://github.com/oracle/graal#license).
    GraalVM CE is based on OpenJDK 1.8.272 and OpenJDK 11.0.9\. GraalVM CE is community
    supported. It can be deployed in production. However, it does not come with the
    required support services from Oracle. Oracle also provides a Docker image, which
    is readily downloadable, for testing and evaluation (refer to [https://www.graalvm.org/docs/getting-started/container-images/](https://www.graalvm.org/docs/getting-started/container-images/)
    for further details).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区版**：GraalVM **社区版**（**CE**）是一个开源版本，作为OpenJDK发行版构建。GraalVM的大多数组件是GPL 2，带有类路径例外许可。有关许可的更多详细信息，请参阅[https://github.com/oracle/graal#license](https://github.com/oracle/graal#license)。GraalVM
    CE基于OpenJDK 1.8.272和OpenJDK 11.0.9。GraalVM CE由社区支持。它可以部署在生产环境中。然而，它不包含Oracle提供的要求支持服务。Oracle还提供可下载的Docker镜像，用于测试和评估（有关更多详细信息，请参阅[https://www.graalvm.org/docs/getting-started/container-images/](https://www.graalvm.org/docs/getting-started/container-images/)）。'
- en: '**Enterprise Edition**: GraalVM **Enterprise Edition** (**EE**) is a licensed
    version under the GraalVM OTN license agreement. This is free for evaluation and
    building non-production applications. GraalVM EE provides additional performance
    (~20% faster than CE and dynamic languages such as JavaScript, Python, R, and
    Ruby are ~2x faster), a smaller footprint (~2x smaller than CE), security (native
    code memory protection), and scalability for running production enterprise applications.
    EE comes with additional debugging tools, such as Ideal Graph Visualizer, which
    helps in not only debugging performance issues, but also in fine-tuning the applications
    for best performance on GraalVM. GraalVM EE comes with support services. For Oracle
    cloud customers, GraalVM EE support is available as part of the subscription.
    GraalVM EE also has a managed mode, which does better heap management, avoiding
    page faults and crashes. GraalVM EE is available for clients who already have
    a Java SE subscription.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业版**：GraalVM **企业版**（**EE**）是在GraalVM OTN许可协议下的授权版本。此版本可用于评估和构建非生产应用程序。GraalVM
    EE提供了额外的性能（比CE快约20%），更小的占用空间（比CE小约2倍），安全性（原生代码内存保护），以及运行生产级企业应用程序的可伸缩性。EE版包含额外的调试工具，如Ideal
    Graph Visualizer，它不仅有助于调试性能问题，还有助于在GraalVM上优化应用程序以获得最佳性能。GraalVM EE还提供支持服务。对于Oracle云客户，GraalVM
    EE支持作为订阅的一部分提供。GraalVM EE还有一个托管模式，它更好地管理堆，避免页面错误和崩溃。GraalVM EE适用于已订阅Java SE的客户。'
- en: Now that we know the various available editions of GraalVM, and what runtimes,
    tools, and frameworks come with it, let's get into the details of the GraalVM
    architecture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GraalVM的各种可用版本以及它所包含的运行时、工具和框架，让我们深入了解GraalVM的架构。
- en: Understanding the GraalVM architecture
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GraalVM架构
- en: 'In this section, we will look at the various architectural components of GraalVM.
    We will look at how various runtimes, tools, and frameworks come together to provide
    the most advanced VM and runtime. The following diagram shows the high-level architecture
    of GraalVM:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨GraalVM的各种架构组件。我们将了解各种运行时、工具和框架是如何结合在一起以提供最先进的虚拟机和运行时的。以下图表显示了GraalVM的高级架构：
- en: '![Figure 3.1 – Graal VM architecture'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – Graal VM架构]'
- en: '](img/B16878_Figure_3.1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16878_Figure_3.1.jpg]'
- en: Figure 3.1 – Graal VM architecture
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Graal VM架构
- en: Let's go through each of these components in detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地逐一介绍这些组件。
- en: JVM (HotSpot)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM（HotSpot）
- en: JVM HotSpot is the regular Java HotSpot VM. The C2 compiler, which is part of
    the HotSpot VM, is replaced with the Graal JIT compiler implementation. The Graal
    JIT compiler is an implementation of **Java Virtual Machine Compiler Interface**
    (**JVMCI**) and plugs into the Java VM. We covered the architecture of JVM HotSpot
    in the previous chapters. Please refer to them for a more in-depth understanding
    of how JVM HotSpot works and the various architectural components of JVM.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JVM HotSpot是常规的Java HotSpot VM。HotSpot VM中的C2编译器被Graal JIT编译器实现所取代。Graal JIT编译器是Java虚拟机编译器接口（**JVMCI**）的一个实现，并插入到Java
    VM中。我们在前面的章节中介绍了JVM HotSpot的架构。请参考它们以深入了解JVM HotSpot的工作原理以及JVM的各种架构组件。
- en: Java Virtual Machine Compiler Interface (JVMCI)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java虚拟机编译器接口（JVMCI）
- en: JVMCI was introduced in Java 9\. This allowed compilers to be written as plugins
    that JVM can call for dynamic compilation. It provides an API and a protocol to
    build compilers with custom implementations and optimizations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JVMCI 在 Java 9 中引入。这允许编写作为插件使用的编译器，JVM 可以调用以进行动态编译。它提供了一个 API 和协议，用于构建具有自定义实现和优化的编译器。
- en: The word *compiler* in this context means a just-in-time compiler. We went into
    a lot of detail on JIT compilers in the previous chapters. GraalVM uses JVMCI
    to get access to the JVM objects, interact with JVM, and install the machine code
    into the code cache.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，“编译器”一词指的是即时编译器。我们在前几章中详细介绍了 JIT 编译器。GraalVM 使用 JVMCI 来访问 JVM 对象，与 JVM
    交互，并将机器代码安装到代码缓存中。
- en: 'Graal JIT implementation comes in two modes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Graal JIT 实现有两种模式：
- en: '`libgraal`: `libgraal` is an AOT compiled binary that is loaded by HotSpot
    VM as a native binary. This is the default mode and the recommended way to run
    GraalVM with HotSpot VM. In this mode, `libgraal` uses its own memory space and
    does not use the HotSpot heap. This mode of Graal JIT has quick bootup and improved
    performance.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libgraal`：`libgraal` 是一个 AOT 编译的二进制文件，由 HotSpot VM 作为本地二进制文件加载。这是默认模式，也是推荐使用
    HotSpot VM 运行 GraalVM 的方式。在此模式下，`libgraal` 使用自己的内存空间，不使用 HotSpot 堆。这种模式的 Graal
    JIT 具有快速的启动时间和改进的性能。'
- en: '`jargraal`: In this mode, Graal JIT is loaded like any other Java class, and
    hence it goes through a warm-up phase and runs with an interpreter until the hot
    methods are identified and optimized. This mode can be invoked by passing the
    `--XX:-UseJVMCINativeLibrary` flag from the command line.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jargraal`：在这种模式下，Graal JIT 被像任何其他 Java 类一样加载，因此它将经历一个预热阶段，并使用解释器运行，直到识别出热方法并进行优化。可以通过从命令行传递
    `--XX:-UseJVMCINativeLibrary` 标志来调用此模式。'
- en: In OpenJDK 9+, 10+, and 11+, we use the `-XX:+UnlockExperimentalVMOptions`,
    `-XX:+UseJVMCICompiler`, and `XX:+EnableJVMCI` flags to run the Graal compiler,
    instead of the C2 compiler. GraalVM, by default, uses the Graal JIT compiler.
    It is always advisable to use GraalVM distributions, as these have the latest
    changes. OpenJDK gets the changes merged at a slower rate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenJDK 9+、10+ 和 11+ 中，我们使用 `-XX:+UnlockExperimentalVMOptions`、`-XX:+UseJVMCICompiler`
    和 `XX:+EnableJVMCI` 标志来运行 Graal 编译器，而不是 C2 编译器。默认情况下，GraalVM 使用 Graal JIT 编译器。始终建议使用
    GraalVM 发行版，因为这些版本包含最新的更改。OpenJDK 以较慢的速度合并更改。
- en: In the next chapter, we will be going into detail on how Graal JIT is better
    than the C2 JIT, using a sample code. We will be using the debugging tools and
    utilities that come with Graal to demonstrate the optimizations that Graal JIT
    performs at runtime.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过示例代码详细说明 Graal JIT 如何比 C2 JIT 更好，我们将使用 Graal 伴随的调试工具和实用程序来演示 Graal
    JIT 在运行时执行的优化。
- en: Graal compiler and tooling
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Graal 编译器和工具
- en: The Graal compiler is built on JVMCI and provides a better JIT compiler (C2
    as we covered in both the previous chapters) implementation, with further optimizations.
    The Graal compiler also provides an AOT (Graal AOT) compilation option to build
    native images that can run standalone with embedded VMs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 编译器基于 JVMCI 构建，提供了一个更好的 JIT 编译器（C2，我们在前几章中讨论过）实现，并进行了进一步优化。Graal 编译器还提供了一个
    AOT（Graal AOT）编译选项，可以构建可以独立运行并嵌入虚拟机的原生镜像。
- en: Graal JIT compiler
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Graal JIT 编译器
- en: 'We looked at the JVM architecture in [*Chapter 1*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Evolution of Java Virtual Machine*. For reference, here is the high-level architecture
    overview of JVM:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014)，“Java 虚拟机的发展”中探讨了
    JVM 架构。为了参考，以下是 JVM 的高级架构概述：
- en: '![Figure 3.2 – JVM architecture with a C2 compiler'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 带有 C2 编译器的 JVM 架构'
- en: '](img/B16878_Figure_3.2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_3.2.jpg)'
- en: Figure 3.2 – JVM architecture with a C2 compiler
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 带有 C2 编译器的 JVM 架构
- en: As you can see, the C1 and C2 compilers implement the JIT compilation as part
    of the JVM execution engine. We went into a lot of detail on how C1 and C2 optimize/deoptimize
    the code based on the compilation threshold.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，C1 和 C2 编译器将 JIT 编译作为 JVM 执行引擎的一部分实现。我们详细介绍了 C1 和 C2 如何根据编译阈值优化/去优化代码。
- en: 'GraalVM replaces the JIT compiler in JVM and incorporates further optimization.
    The following diagram shows the high-level architecture of GraalVM:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 替换了 JVM 中的 JIT 编译器，并进一步优化。以下图表显示了 GraalVM 的高级架构：
- en: '![Figure 3.3 – VM architecture with Graal compiler'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 带有 Graal 编译器的 VM 架构'
- en: '](img/B16878_Figure_3.3.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_3.3.jpg)'
- en: Figure 3.3 – VM architecture with Graal compiler
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 带有 Graal 编译器的 VM 架构
- en: One of the differences between the JVM JIT compiler and Graal JIT is that Graal
    JIT is built to optimize the intermediate code representation (**abstract syntax
    tree** (**AST**) and using Graal graphs, or Graal intermediate representation).
    Java represents the code as an AST, an intermediate representation, while compiling.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JVM JIT 编译器和 Graal JIT 之间的一个区别是，Graal JIT 是构建来优化中间代码表示（**抽象语法树**（**AST**）和 Graal
    图，或 Graal 中间表示）。Java 在编译时将代码表示为 AST 和中间表示。
- en: Any language expressions and instructions can be converted and represented as
    ASTs; this helps in abstracting the language-specific syntax and semantics from
    the logic of optimizing the code. This approach makes GraalVM capable of optimizing
    and running code written in any language, as long as the code can be converted
    into an AST. We will be doing a deep dive into Graal graphs and ASTs in [*Chapter
    4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077), *Graal Just-In-Time Compiler*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语言的表达式和指令都可以被转换并表示为抽象语法树（AST）；这有助于从优化代码的逻辑中抽象出特定语言的语法和语义。这种方法使得 GraalVM 能够优化和运行任何语言的代码，只要代码可以被转换为
    AST。我们将在[*第 4 章*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077)“Graal Just-In-Time
    编译器”中深入探讨 Graal 图和 AST。
- en: 'The four key components of the Graal JIT compiler are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Graal JIT 编译器的四个关键组件如下：
- en: '**Profiler**: As the name suggests, it profiles the running code and generates
    the information that is used by the code optimizer to take decisions or make assumptions
    regarding optimization.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析器**：正如其名所示，它分析运行中的代码，并生成代码优化器用于做出决策或对优化做出假设的信息。'
- en: '**Intermediate Code Generator**: This generates the intermediate code representation,
    which is the input for the code optimizer.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间代码生成器**：这个生成中间代码表示，它是代码优化器的输入。'
- en: '**Code Optimizer**: This uses the data that is collected by profiles and optimizes
    the intermediate code.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码优化器**：这个使用由配置文件收集的数据来优化中间代码。'
- en: '**Target Code Generator**: The optimized code is then converted to the target
    machine code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标代码生成器**：然后，优化后的代码被转换为目标机器代码。'
- en: 'The following diagram shows how Graal JIT works at a very high level:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Graal JIT 在非常高级的层面上是如何工作的：
- en: '![Figure 3.4 – Graal JIT compilation – a high-level flowchart'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – Graal JIT 编译 – 高级流程图'
- en: '](img/B16878_Figure_3.4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_3.4.jpg)'
- en: Figure 3.4 – Graal JIT compilation – a high-level flowchart
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Graal JIT 编译 – 高级流程图
- en: 'Let''s understand this flowchart better:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解这个流程图：
- en: The JVM language (Java, Kotlin, Groovy, and so on) code runs on Graal JIT natively,
    and Graal JIT optimizes the code.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 语言（Java、Kotlin、Groovy 等）的代码在 Graal JIT 上以原生方式运行，并且 Graal JIT 优化代码。
- en: The non-JVM languages (such as JavaScript and Ruby) implement a language parser
    and interpreter using the Truffle API. The language interpreters convert the code
    into AST representation. Graal runs the JIT compilation on the intermediate representation.
    This helps in leveraging all the advanced optimization techniques implemented
    by Graal to non-JVM languages.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非JVM语言（如JavaScript和Ruby）使用 Truffle API 实现语言解析器和解释器。语言解释器将代码转换为 AST 表示形式。Graal
    在中间表示形式上运行 JIT 编译。这有助于利用 Graal 实现的所有高级优化技术来优化非JVM语言。
- en: The native LLVM-based languages (such as C/C++, Swift, and Objective C) follow
    a slightly different route to convert to the intermediate representation. Graal
    Sulong is used to create the intermediate representation that is used by Graal.
    We will be talking about Truffle and Sulong later in this chapter.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生基于 LLVM 的语言（如 C/C++、Swift 和 Objective C）遵循一条略微不同的路径来转换为中间表示。Graal Sulong 用于创建
    Graal 所使用的中间表示。我们将在本章后面讨论 Truffle 和 Sulong。
- en: Graal JIT optimization strategies
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Graal JIT 优化策略
- en: 'Graal JIT optimization strategies are built from the ground up, based on the
    best practices from the C2 JIT compiler optimization strategies. Graal JIT builds
    on top of the C2 optimization strategies and provides more advanced optimization
    strategies. Here are some of the optimization strategies that the Graal JIT compiler
    performs:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Graal JIT 优化策略是从头开始构建的，基于 C2 JIT 编译器优化策略的最佳实践。Graal JIT 在 C2 优化策略之上构建，并提供了更高级的优化策略。以下是
    Graal JIT 编译器执行的一些优化策略：
- en: Partial escape analysis
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分逃逸分析
- en: Improved inlining ([http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf](http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf))
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的内联（[http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf](http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf)）
- en: Guard optimization ([http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf))
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护优化 ([http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf](http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf))
- en: Chaining lambdas
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接式 lambda
- en: Inter-procedural optimization
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉过程优化
- en: We will be covering these optimization strategies in detail, with the help of
    sample code and examples, in the next chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中，通过示例代码和示例，详细介绍这些优化策略。
- en: Truffle
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Truffle
- en: The Truffle framework is an open source library for building the interpreters
    and the tools/utilities (such as integrated development environments, debuggers,
    and profilers). The Truffle API is used to build language interpreters that can
    run on GraalVM, leveraging the optimizations provided by GraalVM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 框架是一个用于构建解释器和工具/实用程序（如集成开发环境、调试器和性能分析器）的开源库。Truffle API 用于构建可以在 GraalVM
    上运行的、利用 GraalVM 提供的优化功能的语言解释器。
- en: 'The Graal and Truffle frameworks consist of the following APIs that enable
    Polyglot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 和 Truffle 框架由以下 API 组成，这些 API 使多语言（Polyglot）成为可能：
- en: '**Language Implementation Framework**: This framework is used by the language
    implementers. It also comes with a reference implementation of a language called
    **SimpleLanguage**. We will be going through this in detail in [*Chapter 9*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169),
    *Graal Polyglot – LLVM, Ruby, and WASM*.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言实现框架**：此框架由语言实现者使用。它还附带了一个名为 **SimpleLanguage** 的语言参考实现。我们将在 [*第 9 章*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169)，*Graal
    Polyglot – LLVM, Ruby, and WASM* 中详细介绍。'
- en: '**Polyglot API**: This set of APIs aids interaction between code written in
    different languages (guest languages) with Java (the host language). For example,
    a Java (host) program can embed R (guest) language code to perform some machine
    learning/AI logic. The Polyglot API provides the framework that will help the
    language programmers to manage the objects between the guest and the host.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polyglot API**：这组 API 帮助不同语言（客语言）编写的代码与 Java（宿主语言）之间进行交互。例如，一个 Java（宿主）程序可以嵌入
    R（客）语言代码以执行一些机器学习/AI 逻辑。Polyglot API 提供了框架，将帮助语言程序员管理客语言和宿主语言之间的对象。'
- en: '**Instrumentation**: The Truffle Instrumentation API provides the framework
    for utilities/tool builders to build integrated development/debugging environments,
    tools, and utilities. The tools and utilities that are built using the Truffle
    Instrumentation API can work with any language that is implemented with Truffle.
    This provides a consistent developer experience across various languages and leverages
    the sophisticated debugging/diagnostic capabilities of JVM.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化**：Truffle 仪器化 API 为工具/工具构建者提供了构建集成开发/调试环境、工具和实用程序的框架。使用 Truffle 仪器化 API
    构建的工具和实用程序可以与任何使用 Truffle 实现的语言一起工作。这为各种语言提供了一致的开发者体验，并利用了 JVM 的复杂调试/诊断功能。'
- en: '*Figure 3.5* shows the high-level architecture of how Truffle acts as an intermediate
    layer between GraalVM and other language interpreters. The individual language
    interpreters are implemented using the Truffle API. Truffle also provides an interoperability
    API, for calling methods and passing data between methods across various language
    implementations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.5* 展示了 Truffle 作为 GraalVM 和其他语言解释器之间中间层的高级架构。各个语言解释器使用 Truffle API 实现。Truffle
    还提供了一个互操作性 API，用于在跨各种语言实现的方法之间调用方法和传递数据：'
- en: '![Figure 3.5 – Truffle architecture'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – Truffle 架构'
- en: '](img/B16878_Figure_3.5.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_3.5.jpg)'
- en: Figure 3.5 – Truffle architecture
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – Truffle 架构
- en: As represented in the previous diagram, Java applications run directly on the
    GraalVM, with Graal Compiler replacing the C2 JIT compiler. Other language programs
    run on top of the Truffle Language Implementation framework. The respective language
    interpreters use the Truffle to implement the interpreters. Truffle combines the
    code along with the interpreter to produce the machine code, using partial evaluation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Java 应用程序直接在 GraalVM 上运行，由 Graal 编译器取代 C2 JIT 编译器。其他语言程序在 Truffle 语言实现框架之上运行。相应的语言解释器使用
    Truffle 实现解释器。Truffle 将代码与解释器结合，使用部分评估生成机器代码。
- en: 'AST is the intermediate representation. AST provides the optimum way to represent
    the syntactic structure of the language, where typically, the parent node is the
    operator, and the children node represents the operands or operators (based on
    cardinality). The following diagram shows a rough representation of AST:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: AST是中间表示形式。AST提供了表示语言语法结构的最佳方式，其中通常，父节点是操作符，子节点表示操作数或操作符（基于基数）。以下图表展示了AST的粗略表示：
- en: '![Figure 3.6 – AST for simple expression'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 简单表达式的AST'
- en: '](img/B16878_Figure_3.6.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – AST优化示例](img/B16878_Figure_3.6.jpg)'
- en: Figure 3.6 – AST for simple expression
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 简单表达式的AST
- en: In this diagram, **a**, **b**, and **c** can be any variables (for loosely typed
    languages). The interpreter starts assuming "generics" based on the profiling
    of various executions. It then starts assuming the specifics and will then optimize
    the code using partial evaluation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图表中，**a**、**b**和**c**可以是任何变量（对于弱类型语言）。解释器开始基于各种执行的配置文件假设“泛型”。然后它开始假设具体细节，并使用部分评估来优化代码。
- en: Truffle (language interpreters written with Truffle) runs as an interpreter
    and Graal JIT kicks in to start identifying optimizations in the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle（使用Truffle编写的语言解释器）作为解释器运行，而Graal JIT开始识别代码中的优化。
- en: The optimizations are based on speculation, and eventually, if the speculation
    is proven to be incorrect at runtime, the JIT will re-optimize and recompile (as
    shown in the previous diagram). Re-optimization and recompiling is an expensive
    task.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 优化基于推测，最终，如果在运行时证明推测是错误的，JIT将重新优化和重新编译（如前图所示）。重新优化和重新编译是一项昂贵的任务。
- en: 'Partial evaluation creates an intermediate representation of the language,
    from the code and the data, and as it learns, and identifies new data types, it
    deoptimizes to the AST interpreter, applies optimizations, and does the node rewriting
    and recompiles. After a certain point, it will have the optimum representation.
    The following diagram explains how Truffle and Graal optimize intermediate representation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 部分评估从代码和数据中创建语言的中间表示形式，随着它学习并识别新的数据类型，它将去优化到AST解释器，应用优化，并进行节点重写和重新编译。在某个点上，它将具有最优表示。以下图表解释了Truffle和Graal如何优化中间表示形式：
- en: '![Figure 3.7 – AST optimization by Graal JIT'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – Graal JIT的AST优化'
- en: '](img/B16878_Figure_3.7.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – AST优化示例](img/B16878_Figure_3.7.jpg)'
- en: Figure 3.7 – AST optimization by Graal JIT
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – Graal JIT的AST优化
- en: 'Let''s understand this diagram better:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解这个图表：
- en: The expression is reduced to an AST. In the AST nodes, the leaf nodes are operands.
    In this example, we have taken a very simple expression to understand how partial
    evaluation works. In a language such as JavaScript, which is not a strongly typed
    language, a, b, and c can be any data type (sometimes referred to as generics).
    Evaluating a generic in an expression is a costly operation.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式被简化为AST。在AST节点中，叶节点是操作数。在此示例中，我们选取了一个非常简单的表达式来理解部分评估是如何工作的。在JavaScript等非强类型语言中，a、b和c可以是任何数据类型（有时被称为泛型）。在表达式中评估泛型是一个昂贵的操作。
- en: Based on the profiling, Graal JIT speculates and assumes a specific data type
    (in this example, as an integer), optimizes the code to evaluate the expression
    for integers, and compiles the code.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据配置文件，Graal JIT推测并假设一个特定的数据类型（在此示例中，为整数），优化代码以评估整数表达式，并编译代码。
- en: In this example, it is using an inlining optimization strategy. The Graal JIT
    compiler has various other optimization strategies that are applied based on the
    use case.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此示例中，它使用内联优化策略。Graal JIT编译器根据用例应用了各种其他优化策略。
- en: When, during runtime, the compiler identifies a control flow where one of the
    operands is not really an integer, it deoptimizes and rewrites the AST with the
    new data type and optimizes the code.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在运行时，编译器识别到一个控制流，其中一个操作数实际上不是整数时，它将去优化，并使用新的数据类型重新编写AST，并优化代码。
- en: Following a few iterations of running this optimization/deoptimization, the
    compiler will eventually generate the most optimum code.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过几次运行此优化/去优化迭代后，编译器最终将生成最优化代码。
- en: The key difference here is that Graal is working on the AST and generating optimized
    code, and it does not matter what language is used to write the source code as
    long as the code is represented as AST.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别是Graal正在处理AST并生成优化代码，只要代码表示为AST，它就不关心源代码是用什么语言编写的。
- en: 'The following diagram shows a high-level flow of how different languages run
    on GraalVM, with Truffle acting as an intermediate layer, to execute any programming
    language code on GraalVM:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了不同语言在GraalVM上运行的高级流程，其中Truffle作为中间层，以在GraalVM上执行任何编程语言代码：
- en: '![Figure 3.8 – Truffle and Graal compilation flowchart'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – Truffle和Graal编译流程图'
- en: '](img/B16878_Figure_3.8.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_3.8.jpg)'
- en: Figure 3.8 – Truffle and Graal compilation flowchart
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – Truffle和Graal编译流程图
- en: This diagram illustrates a simpler representation of how Truffle acts as a layer
    between non-JVM languages and GraalVM. The code can also be built directly as
    a native image with Substrate VM.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了Truffle作为非JVM语言和GraalVM之间层的简化表示。代码也可以直接与Substrate VM构建为原生镜像。
- en: Truffle API is used along with a custom annotations processor to generate interpreter
    source code, which is then compiled. Java code does not need the intermediate
    representation. It can be compiled directly to run on GraalVM. We will discuss
    Truffle interpreters and how to write a custom interpreter in [*Chapter 9*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169),
    *Graal Polyglot – LLVM, Ruby, and WASM*. We will cover the Truffle Polyglot API
    in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An
    Overview*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle API与自定义注解处理器一起使用，以生成解释器源代码，然后进行编译。Java代码不需要中间表示形式。它可以直接编译在GraalVM上运行。我们将在[*第9章*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169)，“Graal多语言
    – LLVM、Ruby和WASM”中讨论Truffle解释器和如何编写自定义解释器。我们将在[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)，“Truffle
    – 概述”中介绍Truffle多语言API。
- en: Truffle also provides a framework called the **Truffle Instrument API** for
    building tools. Instruments provide fine-grained VM-level runtime events, which
    can be used to build profiling, tracing analyzing, and debugging tools. The best
    part is that the language interpreters built with Truffle can use the ecosystem
    of Truffle instruments (for example, VisualVM, Chrome Debugger, and GraalVM Visual
    Studio Code Extension).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle还提供了一个名为**Truffle Instrument API**的框架，用于构建工具。仪器提供细粒度的虚拟机级运行时事件，可用于构建分析、跟踪、分析和调试工具。最好的部分是，使用Truffle构建的语言解释器可以使用Truffle仪器的生态系统（例如，VisualVM、Chrome调试器和GraalVM
    Visual Studio Code扩展）。
- en: Truffle provides the **Polyglot Interoperability Protocol**. This protocol defines
    the message that each language needs to implement and supports the passing of
    data between the Polyglot applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle提供了**多语言互操作性协议**。此协议定义了每种语言需要实现的协议，并支持在多语言应用程序之间传递数据。
- en: Sulong – LLVM
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sulong – LLVM
- en: LLVM is an open source project that is a collection of modular, reusable compilers
    and toolchains. There are a lot of language (C, C++, Fortran, Rust, Swift, and
    so on) compilers that are built on LLVM, where LLVM provides the intermediate
    representation (also known as LLVM-IR).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM是一个开源项目，它是一组模块化、可重用的编译器和工具链。有很多语言（C、C++、Fortran、Rust、Swift等）编译器是基于LLVM构建的，其中LLVM提供中间表示形式（也称为LLVM-IR）。
- en: 'The Sulong pipeline looks different from what we looked at in other language
    compilers that are running on Truffle. The following diagram shows how C/C++ code
    gets compiled:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Sulong管道与其他在Truffle上运行的编程语言编译器所看到的有所不同。以下图示展示了C/C++代码的编译过程：
- en: '![Figure 3.9 – LLVM compilation flowchart'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – LLVM编译流程图'
- en: '](img/B16878_Figure_3.9.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_3.9.jpg)'
- en: Figure 3.9 – LLVM compilation flowchart
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – LLVM编译流程图
- en: This diagram shows how an application code written in C is compiled and run
    on GraalVM. The application code in native languages such as C/C++ is compiled
    in Clang, into an intermediate representation. This LLVM intermediate representation
    runs on the LLVM intermediate representation interpreter, which is built on the
    Truffle API. Graal JIT will further optimize the code at runtime.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了用C编写的应用程序代码如何在GraalVM上编译和运行。在C/C++等本地语言中编写的应用程序代码在Clang中编译成中间表示形式。此LLVM中间表示形式在基于Truffle
    API构建的LLVM中间表示形式解释器上运行。Graal JIT将在运行时进一步优化代码。
- en: SubstrateVM (Graal AOT and native image)
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SubstrateVM（Graal AOT和原生镜像）
- en: Applications on Graal can be deployed on GraalVM or SubstrateVM. SubstrateVM
    is embeddable VM code that gets packaged during AOT compilation in native images.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Graal上的应用可以在GraalVM或SubstrateVM上部署。SubstrateVM是一种可嵌入的虚拟机代码，在AOT编译过程中被打包成原生镜像。
- en: Graal AOT compilation is a very powerful way to create native binaries for a
    particular targeted OS/architecture. For cloud-native workloads and serverless,
    this is a very powerful option for achieving a smaller footprint, faster startups,
    and, more importantly, embeddable runtimes (providing immutability).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Graal AOT编译是创建特定目标操作系统/架构的原生二进制文件的一种非常强大的方式。对于云原生工作负载和无服务器架构，这是一个非常强大的选项，可以实现更小的体积、更快的启动速度，更重要的是，可嵌入的运行时（提供不可变性）。
- en: Rapid componentized modular deployment (containers) also poses management and
    versioning challenges. This is typically called **Configuration Drift**, which
    is one of the major issues that we face in managing a large number of containers
    in high-availability environments. Typically, container infrastructure is built
    by a team and, over time, it is managed by different teams. There are always situations
    where we are forced to change the configuration of the VMs/containers/OS in a
    particular environment that we may never trace. This causes a gap between production
    and the DR/HA environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 快速组件化模块化部署（容器）也带来了管理和版本控制挑战。这通常被称为**配置漂移**，这是我们面对高可用性环境中大量容器时遇到的主要问题之一。通常，容器基础设施由一个团队构建，随着时间的推移，它由不同的团队管理。总有这样的情况，我们被迫在某个环境中更改VM/容器/OS的配置，而我们可能永远无法追踪。这导致了生产环境和DR/HA环境之间的差距。
- en: Immutable infrastructure (images) helps us do better version control of the
    infrastructure. It also gives us more confidence in testing, as the underlying
    infrastructure on which our application containers are running is immutable, and
    we are certain about the test results. To build immutable components, we require
    an embeddable VM (with a small footprint). SubstrateVM provides that embeddable
    VM.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施（镜像）帮助我们更好地进行基础设施版本控制。它还增加了我们在测试中的信心，因为我们应用程序容器运行的基础设施是不可变的，我们对测试结果有信心。要构建不可变组件，我们需要一个具有小体积的嵌入式虚拟机（VM）。SubstrateVM提供了这个嵌入式VM。
- en: 'In AOT compilation, the code is compiled directly to the machine code and executed.
    There is no runtime profiling or optimization/deoptimization. The Graal AOT compiler
    (also referred to as the "native image" compiler) performs static analysis and
    static initializations on the code and produces a VM-embedded executable code.
    The optimization performed by AOT is based on the reachability of the code. The
    following diagram shows the compilation process:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在AOT编译中，代码直接编译成机器代码并执行。没有运行时分析或优化/去优化。Graal AOT编译器（也称为“原生镜像”编译器）对代码执行静态分析和静态初始化，并生成嵌入VM的可执行代码。AOT执行的优化基于代码的可达性。以下图显示了编译过程：
- en: '![Figure 3.10 – Graal AOT compilation'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – Graal AOT编译'
- en: '](img/B16878_Figure_3.10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_3.10.jpg)'
- en: Figure 3.10 – Graal AOT compilation
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – Graal AOT编译
- en: This diagram shows how the Graal AOT compiles native images and embeds SubstrateVM
    as part of the native image. One of the disadvantages of AOT compilation is that
    the VM cannot optimize the code based on runtime profiling, as in JIT. To address
    this issue, we use a profile guided optimization strategy to capture the runtime
    metrics of the application and use that profiled data to optimize the native image
    by recompiling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了Graal AOT如何编译原生镜像并将SubstrateVM作为原生镜像的一部分嵌入。AOT编译的一个缺点是VM不能像JIT那样根据运行时分析优化代码。为了解决这个问题，我们使用基于配置引导的优化策略来捕获应用程序的运行时指标，并使用这些配置数据通过重新编译来优化原生镜像。
- en: Profile Guided Optimization (PGO)
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置引导优化（PGO）
- en: 'GraalVM uses **Profile Guided Optimization** (**PGO**) to optimize native images
    based on the runtime profiling data. This is one of the features that is available
    in Enterprise Edition only. The following diagram shows how a PGO pipeline works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM使用**配置引导优化**（**PGO**）根据运行时分析数据优化原生镜像。这是仅在企业版中可用的功能之一。以下图显示了PGO管道的工作方式：
- en: '![Figure 3.11 – Graal AOT compilation with PGO'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 使用PGO的Graal AOT编译'
- en: '](img/B16878_Figure_3.11.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16878_Figure_3.11.jpg)'
- en: Figure 3.11 – Graal AOT compilation with PGO
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 使用PGO的Graal AOT编译
- en: 'Let''s understand this workflow better:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解这个工作流程：
- en: When the code is compiled with `native-image`, we use the `--pgo-instrumented`
    flag. This will tell the compiler to inject instrumentation code into the compiled
    code.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`native-image`编译代码时，我们使用`--pgo-instrumented`标志。这将告诉编译器向编译后的代码中注入检测代码。
- en: When we start running this instrumented native image, the profiler starts collecting
    the runtime data and then starts creating the profile files (`.ipof`).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们开始运行这个经过仪表化的原生镜像时，分析器开始收集运行时数据，然后开始创建配置文件（`.ipof`）。
- en: Once we have run the native image with various workloads (all possible workloads
    – to capture as much instrumentation as possible), we can then recompile the native
    image with the `--pgo` flag (`native-image --pgo=profile.iprof`), providing the
    profile files as input. The Graal native image compiler creates the optimum native
    image.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们用各种工作负载（所有可能的工作负载 – 以捕获尽可能多的仪表数据）运行了原生镜像，我们就可以使用 `--pgo` 标志（`native-image
    --pgo=profile.iprof`）重新编译原生镜像，提供配置文件作为输入。Graal 原生镜像编译器创建最佳原生镜像。
- en: We will be building a native image with profile-guided optimization in the next
    chapter with the help of real examples and also understand how memory management
    works in native images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章通过真实示例构建带有配置文件引导优化的原生镜像，并了解原生镜像中的内存管理是如何工作的。
- en: GraalVM is a great runtime for the modern microservices architecture. In the
    next section, we will go through the various features of GraalVM that help to
    build a microservices application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 是现代微服务架构的优秀运行时。在下一节中，我们将介绍 GraalVM 的各种功能，这些功能有助于构建微服务应用程序。
- en: An overview of GraalVM microservices architecture
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraalVM 微服务架构概述
- en: GraalVM is ideal for microservices architecture. One of the most important requirements
    for certain microservices architecture is a smaller footprint and faster startup.
    GraalVM is an ideal runtime for running Polyglot workloads in the cloud. Cloud-native
    frameworks are already available on the market that can build applications to
    run optimally on GraalVM, such as Quarkus, Micronut, Helidon, and Spring. These
    frameworks are found to perform almost 50x times faster when running as native
    images. We will go into detail about how GraalVM is the right runtime and platform
    for microservices in [*Chapter 10*](B16878_10_Final_SK_ePub.xhtml#_idTextAnchor187),
    *Microservices Architecture with GraalVM.*
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 是微服务架构的理想选择。对于某些微服务架构来说，最重要的要求之一是更小的占用空间和更快的启动速度。GraalVM 是在云中运行多语言工作负载的理想运行时。市场上已经有一些原生框架，可以构建在
    GraalVM 上运行最佳的应用程序，例如 Quarkus、Micronut、Helidon 和 Spring。这些框架在作为原生镜像运行时被发现几乎快了
    50 倍。我们将在 [*第 10 章*](B16878_10_Final_SK_ePub.xhtml#_idTextAnchor187) “使用 GraalVM
    的微服务架构”中详细介绍 GraalVM 是微服务的正确运行时和平台。
- en: Understanding how GraalVM addresses various non-functional aspects
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GraalVM 如何解决各种非功能性方面
- en: In this section, we will go through the typical non-functional requirements
    of a microservices cloud-native architecture, and how GraalVM addresses these
    requirements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍微服务云原生架构的典型非功能性要求，以及 GraalVM 如何解决这些要求。
- en: Performance and scalability
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能和可伸缩性
- en: Performance and scalability are among the more important non-functional requirements
    of a microservices cloud-native architecture. The microservices are automatically
    scaled out and down by orchestrators such as Kubernetes. This requires the microservices
    to be built on a runtime that starts up quickly and runs fast, consuming minimal
    cloud resources. GraalVM AOT compilation helps to build native images that perform
    on a par with native languages such as C/C++.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和可伸缩性是微服务云原生架构中更重要的非功能性要求之一。微服务由 Kubernetes 等编排器自动扩展和缩减。这要求微服务建立在启动速度快且运行快速的运行时上，消耗最少的云资源。GraalVM
    AOT 编译有助于构建与 C/C++ 等原生语言相当性能的原生镜像。
- en: 'To understand how AOT compiled code (native image) is faster than JIT compiled
    code, let''s look at the steps that JIT and AOT follow at runtime:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 AOT 编译的代码（原生镜像）为什么比 JIT 编译的代码更快，让我们看看 JIT 和 AOT 在运行时遵循的步骤：
- en: '![Figure 3.12 – Graal JIT versus the AOT flowchart'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – Graal JIT 与 AOT 流程图](img/B16878_Figure_3.12.jpg)'
- en: '](img/B16878_Figure_3.12.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – Graal JIT 与 AOT 流程图](img/B16878_Figure_3.12.jpg)'
- en: Figure 3.12 – Graal JIT versus the AOT flowchart
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – Graal JIT 与 AOT 流程图
- en: This diagram shows the high-level steps for JIT and AOT. JIT optimizes the code
    over a period of time by profiling the code at runtime. There are performance
    overheads, as there is additional profiling, optimizing, and deoptimizing that
    is done by the JVM at runtime.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了 JIT 和 AOT 的高级步骤。JIT 通过在运行时分析代码来优化代码一段时间。由于 JVM 在运行时执行了额外的分析、优化和去优化操作，因此存在性能开销。
- en: It is observed, based on the Apache Bench benchmark, that while GraalVM JIT
    throughput and performance is lower than AOT at the beginning, as the number of
    requests increases, Graal JIT optimizes and performs better than Graal AOT after
    around 14,000 requests per second.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Apache Bench基准测试，观察到虽然GraalVM JIT的吞吐量和性能在开始时低于AOT，但随着请求数量的增加，大约在每秒14,000个请求后，Graal
    JIT进行了优化，并比Graal AOT表现更好。
- en: It is also observed that Graal AOT performs 50 times faster than Graal JIT and
    has a 5x smaller memory footprint than Graal JIT.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到Graal AOT的性能比Graal JIT快50倍，并且内存占用比Graal JIT小5倍。
- en: Graal AOT with PGO throughput is consistent and sometimes better than Graal
    JIT. However, for long-running tasks, Graal JIT might have better throughput.
    So, for the best throughput and consistent performance, Graal AOT with PGO is
    the best.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Graal AOT与PGO的吞吐量一致，有时甚至优于Graal JIT。然而，对于长时间运行的任务，Graal JIT可能具有更好的吞吐量。因此，为了获得最佳吞吐量和一致的性能，使用带有PGO的Graal
    AOT是最佳选择。
- en: Please refer to the benchmark study published at [https://www.infoq.com/presentations/graalvm-performance/](https://www.infoq.com/presentations/graalvm-performance/)
    and [https://www.graalvm.org/why-graalvm/](https://www.graalvm.org/why-graalvm/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅在[https://www.infoq.com/presentations/graalvm-performance/](https://www.infoq.com/presentations/graalvm-performance/)和[https://www.graalvm.org/why-graalvm/](https://www.graalvm.org/why-graalvm/)发布的基准研究。
- en: There are further benchmark studies that are published with academic collaborators
    at [https://renaissance.dev](https://renaissance.dev).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与学术合作伙伴一起发布了更多的基准研究，请参阅[https://renaissance.dev](https://renaissance.dev)。
- en: 'Here''s what we can conclude:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: GraalVM Native Image (AOT) is best for faster startups and applications that
    require a smaller footprint, such as serverless applications and container microservices.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM本地图像（AOT）对于快速启动和需要更小内存占用的应用最佳，例如无服务器应用和容器微服务。
- en: GraalVM JIT is best for peak throughputs. Throughput is a very important aspect
    for long-running processes, where scalability is critical. This could be high-volume
    web application servers such as e-commerce servers and stock market applications.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM JIT 在峰值吞吐量方面表现最佳。吞吐量对于长时间运行的过程来说非常重要，在这些过程中，可扩展性是关键。这可能是高流量的Web应用服务器，例如电子商务服务器和股市应用。
- en: A combination of garbage collection configuration and JIT will help in achieving
    reduced latency. Latency is very important as regards the responsiveness of applications.
    When we are running high throughput, it's possible that on occasion, garbage collection
    slows down the response.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合垃圾收集配置和JIT，可以帮助降低延迟。延迟对于应用的响应性非常重要。当我们运行高吞吐量时，有时垃圾收集会减慢响应速度。
- en: There is not a hard and fast rule for using it. It depends on various combinations
    that we need to decide between JIT and AOT, and various other configurations that
    are possible. We will explore various compiler and native image configurations
    in the next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它并没有一条固定的规则。这取决于我们需要在JIT和AOT之间做出的各种组合决策，以及可能的各种其他配置。我们将在下一章探讨各种编译器和本地图像配置。
- en: Security
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: 'GraalVM security is built on JVM security, which is based on the sandbox model.
    Let''s have a very quick review of how the sandbox model works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM的安全性建立在JVM安全性的基础上，后者基于沙盒模型。让我们快速回顾一下沙盒模型是如何工作的：
- en: '![Figure 3.13 – JVM security model'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – JVM安全模型](img/B16878_Figure_3.13.jpg)'
- en: '](img/B16878_Figure_3.13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – JVM安全模型](img/B16878_Figure_3.13.jpg)'
- en: Figure 3.13 – JVM security model
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – JVM安全模型
- en: In Java 2 security architecture, all the class files are verified by bytecode
    verifier (please refer to both the previous chapters for more details on class
    loaders). The bytecode verifier checks whether the class files are valid and look
    for any overflows, underflows, data type conversions, method calls, references
    to classes, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 2安全架构中，所有类文件都由字节码验证器验证（请参阅前几章以获取有关类加载器的更多详细信息）。字节码验证器检查类文件是否有效，并寻找任何溢出、下溢、数据类型转换、方法调用、对类的引用等问题。
- en: Once the bytecode is verified, the dependent classes are loaded by the class
    loader. Please refer to [*Chapter 1*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Evolution of Java Virtual Machine*, to understand how the class loader subsystem
    works. Class loaders work with Security Manager and access control to enforce
    security rules that are defined in the policy files. Java code that is downloaded
    over the network is checked for a signature (represented as `java.security.CodeSource`,
    including the public key).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦字节码被验证，依赖的类将由类加载器加载。请参阅[*第1章*](B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014)，*Java虚拟机的发展*，以了解类加载器子系统的工作原理。类加载器与安全管理者及访问控制一起工作，强制执行在策略文件中定义的安全规则。通过网络下载的Java代码将检查签名（表示为`java.security.CodeSource`，包括公钥）。
- en: Security Manager (`java.lang.SecurityManager`) is the most important component
    for handling authorizations. Security Manager has various checks in place to ensure
    that the authorization is done. The access controller (`java.security.AccessContoller`)
    class is another critical class that helps control access to system resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安全管理者（`java.lang.SecurityManager`）是处理授权最重要的组件。安全管理者有各种检查以确保授权完成。访问控制器（`java.security.AccessController`）类是另一个关键类，它有助于控制对系统资源的访问。
- en: Keystore is a password-protected store that holds all the private keys and certificates.
    Each entry in the store can also be password-protected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥库是一个密码保护的存储库，其中包含所有私钥和证书。存储库中的每个条目也可以是密码保护的。
- en: Java Security is extendable, with custom security implementations called **Security
    Providers**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Java安全是可扩展的，有自定义安全实现称为**安全提供者**。
- en: GraalVM builds on the Java security model and abstracts it to address enforcing
    security at intermediate representation level. GraalVM does not recommend running
    untrusted code on Security Manager.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM建立在Java安全模型之上，并将其抽象化以在中间表示级别强制执行安全。GraalVM不建议在安全管理者上运行不受信任的代码。
- en: 'The GraalVM security model uses the Truffle language implementation framework
    API for JVM host applications to create an execution context, which is passed
    to the guest application (application code written in different languages). The
    following diagram shows the high-level architecture of how GraalVM allows the
    guest and host applications to interoperate and determine how access is controlled:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM安全模型使用Truffle语言实现框架API为JVM主机应用程序创建执行上下文，并将其传递给访客应用程序（用不同语言编写的应用程序代码）。以下图显示了GraalVM如何允许访客和主机应用程序交互操作以及如何控制访问的高级架构：
- en: '![Figure 3.14 – Graal security model'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – Graal安全模型'
- en: '](img/B16878_Figure_3.14.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_3.14.jpg)'
- en: Figure 3.14 – Graal security model
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – Graal安全模型
- en: The execution context (`org.graalvm.polyglot.Context`) defines the access control
    for the guest applications. Based on the access control that is defined in the
    execution context, the guest applications get access to the system's resources.
    GraalVM provides a Polyglot API to create these access controls, with an execution
    context, to set the access privileges to access various functions, such as File
    I/O, Threading, and Native Access. Based on what privileges are set by the host,
    the guest will have that access. A watchdog thread is used to timebound the context.
    The watchdog will close the context, in the given time, to free up the resources,
    and restrict access based on time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文（`org.graalvm.polyglot.Context`）定义了访客应用程序的访问控制。基于在执行上下文中定义的访问控制，访客应用程序可以访问系统的资源。GraalVM提供了一个Polyglot
    API来创建这些访问控制，通过执行上下文来设置访问各种函数的权限，例如文件I/O、线程和原生访问。根据主机设置的权限，访客将拥有相应的访问权限。使用看门狗线程来限制上下文的时间。看门狗将在指定的时间内关闭上下文，以释放资源，并基于时间限制访问。
- en: 'The following code demonstrates how the execution context can be set:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何设置执行上下文：
- en: '[PRE0]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'GraalVM also offers an API to exchange objects between host and guest applications:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM还提供了一个API，用于在主机和访客应用程序之间交换对象：
- en: '`@HostAccess.Export` Annotation, for example).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@HostAccess.Export` 注解，例如）。'
- en: '**Host to Guest Data Exchange**: The objects passed from the host to the guest
    need to be handled by guest languages. The data is passed through the context,
    for example:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机到访客数据交换**：从主机传递给访客的对象需要由访客语言处理。数据通过上下文传递，例如：'
- en: '[PRE1]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Value `a` can be returned by the host application to the JavaScript guest application
    with a value of `42` (after evaluation).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 主机应用程序可以将值`a`返回给JavaScript访客应用程序，其值为`42`（在评估后）。
- en: We will be covering this in detail in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120),
    *Truffle – An Overview*, with the help of a real example.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 6 章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)“Truffle – 概述”中详细讲解，通过一个真实示例来帮助理解。
- en: GraalVM EE also provides a managed execution mode for LLVM intermediate representation
    code to handle any memory violations and faults. Please refer to [https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html](https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html)
    for more details.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM EE 还为 LLVM 中间表示代码提供了一种管理执行模式，以处理任何内存违规和故障。请参阅[https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html](https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html)获取更多详细信息。
- en: DevOps – continuous integration and delivery
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevOps – 持续集成和交付
- en: 'DevOps automation is one of the core requirements of any modern, cloud-native
    architecture. GraalVM integrates very well into the DevOps pipeline. The following
    diagram illustrates a typical GitOps pipeline with representative software (GraalVM
    integrates into any stack of the DevOps software stack):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 自动化是任何现代云原生架构的核心要求之一。GraalVM 与 DevOps 管道集成得非常好。以下图表展示了典型的 GitOps 管道及其代表性软件（GraalVM
    集成到 DevOps 软件栈的任何堆栈中）：
- en: '![Figure 3.15 – GitOps with GraalVM'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.15 – 使用 GraalVM 的 GitOps'
- en: '](img/B16878_Figure_3.15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_3.15.jpg)'
- en: Figure 3.15 – GitOps with GraalVM
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 使用 GraalVM 的 GitOps
- en: Let's understand this diagram better.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解这个图表。
- en: 'The **Continuous Integration** (**CI**) pipeline gets triggered by a typical
    pull request from the Git repository with changes in the application code and
    infrastructure code. CI tools such as GitHub actions, Argo CD, or CicleCI can
    be used to orchestrate a CI pipeline. A typical CI pipeline consists of the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）管道由 Git 仓库中应用程序代码和基础设施代码更改的典型拉取请求触发。可以使用 GitHub actions、Argo
    CD 或 CicleCI 等CI工具来编排 CI 管道。典型的 CI 管道包括以下步骤：'
- en: '**Build**: In the build phase, the release tagged code is pulled from the appropriate
    branch from the Git repository. The code is verified (any static code analysis)
    and built. For cloud-native, typically, the code is built as native images, using
    the Graal AOT compiler.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：在构建阶段，从 Git 仓库的适当分支拉取标记为发布的代码。代码经过验证（任何静态代码分析）并构建。对于云原生，通常使用 Graal AOT
    编译器将代码构建为原生镜像。'
- en: '**Test**: The code is tested with unit testing scripts and further verified
    for any security vulnerabilities.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：使用单元测试脚本来测试代码，并进一步验证是否存在任何安全漏洞。'
- en: '**Package**: Once the code passes all the tests, the code is typically packaged
    into the cloud-native target runtime (using a Docker image or VM or any other
    binary format). The target could be a serverless container or Docker container
    or a VM.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**：一旦代码通过所有测试，通常将代码打包到云原生目标运行时（使用 Docker 镜像、VM 或任何其他二进制格式）。目标可以是无服务器容器、Docker
    容器或 VM。'
- en: '**Store**: The final binaries are stored on binary stores or repositories,
    such as Docker Hub or Red Hat Quay (if it''s a Docker image).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：最终二进制存储在二进制存储或仓库中，如 Docker Hub 或 Red Hat Quay（如果是 Docker 镜像）。'
- en: 'The Continuous Deployment pipeline can either be triggered based on a release
    plan or can be manually triggered (depending on the release plan and strategy).
    Continuous Deployment typically has the following phases:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署管道可以基于发布计划触发，或者可以手动触发（取决于发布计划和策略）。持续部署通常具有以下阶段：
- en: '**Deployment for Validation**: The final binary ID deployed to an environment
    where the binary can now be tested end to end. Various strategies can be followed:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署验证**：将最终二进制 ID 部署到可以现在进行端到端测试的环境。可以遵循以下各种策略：'
- en: 'a. **Traditionally**: We have an Integration Test Environment and a User Acceptance
    Test Environment (or Pre-Production Environment) for various levels of validation
    and testing.'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. **传统上**：我们有集成测试环境和用户验收测试环境（或预生产环境）用于不同级别的验证和测试。
- en: 'b. **Blue/Green Deployment**: There are two parallel environments (called Blue
    and Green). One of them will be in production, let''s assume Blue. The Green environment
    can be used to test and validate our code. Once we are sure that the new release
    is working fine, we use the router to switch to the Green environment and use
    the Blue environment for testing future releases. This provides a high availability
    way to deploy applications.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. **蓝/绿部署**：存在两个并行环境（称为蓝和绿）。其中一个将在生产环境中运行，让我们假设是蓝环境。绿环境可以用来测试和验证我们的代码。一旦我们确认新版本运行良好，我们使用路由器切换到绿环境，并使用蓝环境来测试未来的版本。这提供了一种高可用性的应用部署方式。
- en: 'c. **Canary Deployments and Rolling Updates**: Canary deployment is more a
    recent approach of using the same environment for both production and validation.
    This is a great feature to test our code and compare the new release with the
    current release (A/B testing). Canary deployments provide an API management layer,
    which can be used to redirect the traffic to specific endpoints, based on various
    parameters (such as testing users or a user from a specific department can access
    the new version, while end users are still using the old version). The application
    can be deployed on a specific number of servers/nodes (by % or number). As we
    get more confident with the new release, we can perform rolling updates by increasing
    the number of nodes, where the new release should run, and open up to a wider
    circle of users. This also gives the flexibility to perform a phased rollout of
    new releases (by region or user demography or any parameter).'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. **金丝雀部署和滚动更新**：金丝雀部署是一种更近期的使用相同环境进行生产和验证的方法。这是一个测试我们的代码并与当前版本（A/B测试）比较的出色功能。金丝雀部署提供了一个API管理层，可以根据各种参数（例如测试用户或来自特定部门的用户可以访问新版本，而最终用户仍在使用旧版本）将流量重定向到特定的端点。应用可以部署在特定数量的服务器/节点上（通过百分比或数量）。随着我们对新版本越来越有信心，我们可以通过增加运行新版本的节点数量来进行滚动更新，并向更广泛的用户群体开放。这也提供了按阶段推出新版本（按地区或用户人口统计或任何参数）的灵活性。
- en: '**Testing**: There are various levels of testing that are performed, both functional
    and non-functional. Most of this is performed with automation, and that is also
    choreographed by the Continuous Delivery pipeline.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：执行了各种级别的测试，包括功能性和非功能性测试。大部分测试都是通过自动化完成的，而且这也是由持续交付管道编排的。'
- en: '**Production Deployment**: Once it''s all tested, the final application is
    deployed to the production environment. Once again, this deployment may use one
    of the Traditional or Blue/Green or Canary strategies.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产部署**：一旦所有测试都完成，最终应用将被部署到生产环境。再次强调，这种部署可能使用传统的、蓝/绿或金丝雀策略之一。'
- en: GraalVM provides a very flexible way to deploy the application as a standalone,
    container, cloud, VM, and Oracle database. There are very sophisticated microservices
    frameworks, such as Quarkus, Micronaut, and Fn project, that provide native support
    for GraalVM and integrate very well with modern GitOps tools.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM提供了一种非常灵活的方式来部署应用，无论是作为独立应用、容器、云、虚拟机还是Oracle数据库。存在非常复杂的微服务框架，如Quarkus、Micronaut和Fn项目，它们为GraalVM提供原生支持，并与现代GitOps工具很好地集成。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the GraalVM architecture. Graal JIT is the new
    implementation of the JIT compiler, which replaces the C2 compiler, and brings
    in a lot more optimizations. Graal JIT is implemented completely in Java. Truffle
    provides the interpreter implementation framework and Polyglot framework to get
    other non-JVM languages into GraalVM.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了GraalVM架构。Graal JIT是JIT编译器的新实现，它取代了C2编译器，并带来了更多的优化。Graal JIT完全用Java实现。Truffle提供了解释器实现框架和多语言框架，以便将其他非JVM语言引入GraalVM。
- en: This chapter provided a good understanding of the various runtimes, frameworks,
    tools, Graal updater, and utilities that are shipped with GraalVM. We also looked
    at the two available editions of GraalVM and what the key differences are between
    these two editions. We went through all the various components of the GraalVM
    architecture. We also explored some of the non-functional aspects of the architecture,
    including security model, performance, and DevOps. This is very important if you
    want to understand how GraalVM can be used to build cloud-native microservices
    and high-performing applications across various languages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对 GraalVM 随附的各种运行时、框架、工具、Graal 更新器和实用工具的良好理解。我们还探讨了 GraalVM 的两个可用版本以及这两个版本之间的关键区别。我们详细介绍了
    GraalVM 架构的所有各种组件。我们还探索了架构的一些非功能性方面，包括安全模型、性能和 DevOps。如果你想要了解如何使用 GraalVM 来构建跨各种语言的云原生微服务和高性能应用程序，这一点非常重要。
- en: In the next chapter, we will dig deeper into how Graal JIT works, how we can
    use the various tools that come with Graal to understand the internal workings
    of Graal JIT, and how we can use these tools to debug and fine-tune our code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Graal JIT 的工作原理，如何使用 Graal 提供的各种工具来理解 Graal JIT 的内部工作方式，以及如何使用这些工具来调试和微调我们的代码。
- en: Questions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the various editions of GraalVM?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM 有哪些版本？
- en: What is JVMCI?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 JVMCI？
- en: What is Graal JIT?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Graal JIT？
- en: What is Graal AOT? How does PGO help AOT compilation?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Graal AOT？PGO 如何帮助 AOT 编译？
- en: What is Truffle? How does it help to run multiple language codes on GraalVM?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Truffle？它是如何帮助在 GraalVM 上运行多种语言代码的？
- en: What is SubstrateVM?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 SubstrateVM？
- en: What is Guest Access Context?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Guest Access Context？
- en: Why is GraalVM the ideal runtime for cloud-native microservices?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 GraalVM 是云原生微服务的理想运行时？
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Lightweight Cloud-Native Java Applications ([https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673](https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673))
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级云原生 Java 应用程序 ([https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673](https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673))
- en: Java on Truffle — Going Fully Metacircular ([https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840](https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840))
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java on Truffle — 实现完全元循环 ([https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840](https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840))
- en: GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))
- en: GraalVM Enterprise Edition ([https://docs.oracle.com/en/graalvm/enterprise/20/index.html](https://docs.oracle.com/en/graalvm/enterprise/20/index.html))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 企业版 ([https://docs.oracle.com/en/graalvm/enterprise/20/index.html](https://docs.oracle.com/en/graalvm/enterprise/20/index.html))
- en: GraalVM Git ([https://github.com/oracle/graal](https://github.com/oracle/graal))
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM Git ([https://github.com/oracle/graal](https://github.com/oracle/graal))
