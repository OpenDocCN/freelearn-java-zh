- en: Flowables and Backpressure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flowables 和 背压
- en: 'In the previous chapter, we learned about different operators that intercept
    rapidly firing emissions and either consolidate or omit them to decrease the emissions
    passed downstream. But for most cases where a source is producing emissions faster
    than the downstream can process them, it is better to proactively make the source
    slow down in the first place and emit at a pace that agrees with the downstream
    operations. This is known as backpressure or flow control, and it can be enabled
    by using a `Flowable` instead of an `Observable`. This will be the core type that
    we work with in this chapter, and we will learn about the right times to leverage
    it in our applications. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了不同的操作符，它们可以拦截快速发射的发射，并合并或省略它们以减少传递到下游的发射。但对于大多数情况下，如果源头产生的发射比下游处理得快，最好首先让源头减速，并以与下游操作一致的速度发射。这被称为背压或流控制，可以通过使用
    `Flowable` 而不是 `Observable` 来启用。这将是本章我们将与之工作的核心类型，我们将学习在应用程序中何时利用它。本章我们将涵盖以下主题：
- en: Understanding backpressure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解背压
- en: '`Flowable` and `Subscriber`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flowable` 和 `Subscriber`'
- en: Using `Flowable.create()`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Flowable.create()`
- en: Interoperating Observables and Flowables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables 和 Flowables 的互操作性
- en: Backpressure operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背压操作符
- en: Using `Flowable.generate()`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Flowable.generate()`
- en: Understanding backpressure
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解背压
- en: Throughout this book, I emphasized the "push-based" nature of Observables. Pushing
    items synchronously and one at a time from the source all the way to the `Observer`
    is indeed how `Observable` chains work by default without any concurrency.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我强调了 Observables 的“基于推送”的特性。从源头同步且逐个推送项目到 `Observer` 确实是 `Observable`
    链默认的工作方式，没有任何并发。
- en: 'For instance, the following is an `Observable` that will emit the numbers 1
    through 999,999,999\. It will map each integer to a `MyItem` instance, which simply
    holds it as a property. But let''s slow down the processing of each emission by
    50 milliseconds in the `Observer`. This shows that even if the downstream is slowly
    processing each emission, the upstream synchronously keeps pace with it. This
    is because one thread is doing all the work:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个将发出从1到999,999,999的数字的 `Observable`。它将每个整数映射到一个 `MyItem` 实例，该实例简单地将其作为属性持有。但让我们在
    `Observer` 中将每个发射的处理速度减慢50毫秒。这表明即使下游正在缓慢处理每个发射，上游也会同步地跟上它。这是因为只有一个线程在做所有的工作：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The outputted alternation between `Constructing MyItem` and `Received MyItem` shows
    that each emission is bring processed one at a time from the source all the way
    to the terminal `Observer`. This is because one thread is doing all the work for
    this entire operation, making everything synchronous. The consumers and producers
    are passing emissions in a serialized, consistent flow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的 `Constructing MyItem` 和 `Received MyItem` 之间的交替表明每个发射都是从源头逐个处理到终端 `Observer`
    的。这是因为只有一个线程为整个操作做所有的工作，使得一切同步。消费者和生产者以序列化、一致的方式传递发射。
- en: An example that needs backpressure
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要背压的示例
- en: When you add concurrency operations to an `Observable` chain (particularly `observeOn()`,
    parallelization, and operators such as `delay()`), the operation become *asynchronous*.
    This means hat multiple parts of the `Observable` chain can be processing emissions
    at a given time, and producers can outpace consumers as they are now operating
    on different threads. An emission is no longer strictly being handed downstream
    one at a time from the source all the way to the `Observer` before starting the
    next one. This is because once an emission hits a different `Scheduler` through `observeOn()`
    (or other concurrent operators), the source is no longer in charge of pushing
    that emission to the `Observer`. Therefore, the source will start pushing the
    next emission even though the previous emission may not have reached the Observer
    yet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向 `Observable` 链（尤其是 `observeOn()`、并行化以及如 `delay()` 这样的操作符）添加并发操作时，操作变为 **异步**。这意味着在给定时间内，`Observable`
    链的多个部分可以处理发射，生产者可以超过消费者，因为它们现在在不同的线程上操作。发射不再严格地从源头逐个传递到 `Observer`，然后再开始下一个。这是因为一旦发射通过
    `observeOn()`（或其他并发操作符）击中不同的 `Scheduler`，源头就不再负责将那个发射推送到 `Observer`。因此，源头将开始推送下一个发射，即使前一个发射可能还没有到达
    `Observer`。
- en: 'If we take our previous example and add `observeOn(Shedulers.io())` right before `subscribe()`
    (as shown in the following code), you will notice something very blatant:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前的例子添加 `observeOn(Shedulers.io())` 在 `subscribe()` 之前（如下面的代码所示），你会注意到一个非常明显的事实：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is just a section of my console output. Note that when `MyItem 1001902` is
    created, the `Observer` is still only processing `MyItem 38`. The emissions are
    being pushed much faster than the `Observer` can process them, and because backlogged
    emissions get queued by `observeOn()` in an unbounded manner, this could lead
    to many problems, including `OutOfMemoryError` exceptions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我控制台输出的一个部分。注意，当创建 `MyItem 1001902` 时，`Observer` 仍在处理 `MyItem 38`。排放被推送的速度比
    `Observer` 处理它们的速度快得多，并且由于排放积压在 `observeOn()` 中无限制地排队，这可能导致许多问题，包括 `OutOfMemoryError`
    异常。
- en: Introducing the Flowable
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 `Flowable`
- en: 'So how do we mitigate this? You could get hacky and try to use native Java
    concurrency tools such as semaphores. But thankfully, RxJava has a streamlined
    solution to this problem: the  `Flowable`. The `Flowable` is a backpressured variant
    of the `Observable` that tells the source to emit at a pace specified by the downstream
    operations.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们应该如何减轻这种情况呢？你可以尝试使用原生的 Java 并发工具，例如信号量。但幸运的是，RxJava 为此问题提供了一个简化的解决方案：`Flowable`。`Flowable`
    是 `Observable` 的背压变体，它告诉源以下游操作指定的速度发出。
- en: 'In the following code, replace `Observable.range()` with `Flowable.range()`,
    and this will make this entire chain work with Flowables instead of Observables.
    Run the code and you will see a very different behavior with the output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，将 `Observable.range()` 替换为 `Flowable.range()`，这将使整个链使用 `Flowable` 而不是
    `Observable` 来工作。运行代码，你将看到输出有非常大的不同：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that Flowables do not subscribe with Observers but rather Subscribers,
    which we will dive into later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Flowable` 不使用观察者（Observers）订阅，而是使用订阅者（Subscribers），我们将在稍后深入探讨。
- en: You will notice something very different with the output when using `Flowable`.
    I omitted parts of the preceding output using `...` to highlight some key events.
    128 emissions were immediately pushed from `Flowable.range()`, which constructed
    128 `MyItem` instances. After that, `observeOn()` pushed 96 of them downstream
    to `Subscriber`. After these 96 emissions were processed by `Subscriber`, another
    96 were pushed from the source. Then another 96 were passed to `Subscriber`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Flowable` 时，你会注意到输出有非常大的不同。我使用 `...` 省略了前面输出的一部分，以突出一些关键事件。`Flowable.range()`
    立即推送了 128 个排放，构建了 128 个 `MyItem` 实例。之后，`observeOn()` 将其中的 96 个推送到了 `Subscriber`。在这
    96 个排放被 `Subscriber` 处理之后，又有 96 个从源推送出来。然后又有 96 个传递给了 `Subscriber`。
- en: Do you see a pattern yet? The source started by pushing 128 emissions, and after
    that, a steady flow of 96 emissions at a time was processed by the `Flowable`
    chain. It is almost like the entire `Flowable` chain strives to have no more than
    96 emissions in its pipeline at any given time. Effectively, that is exactly what
    is happening! This is what we call **backpressure**, and it effectively introduces
    a pull dynamic to the push-based operation to limit how frequently the source
    emits.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到模式了吗？源开始时推送了 128 个排放，之后，`Flowable` 链以每次 96 个排放的稳定流进行处理。这几乎就像整个 `Flowable`
    链努力在任何给定时间不超过 96 个排放在其管道中。实际上，这正是正在发生的事情！这就是我们所说的 **背压**，它有效地引入了拉动态到基于推送的操作中，以限制源发出的频率。
- en: But why did `Flowable.range()` start with 128 emissions, and why did `observeOn()`
    only send 96 downstream before requesting another 96, leaving 32 unprocessed emissions?
    The initial batch of emissions is a bit larger so some extra work is queued if
    there is any idle time. If (in theory) our `Flowable` operation started by requesting
    96 emissions and continued to emit steadily at 96 emissions at a time, there would
    be moments where operations might wait idly for the next 96\. Therefore, an extra
    rolling cache of 32 emissions is maintained to provide work during these idle
    moments, which can provide greater throughput. This is much like a warehouse holding
    a little extra inventory to supply orders while it waits for more from the factory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么`Flowable.range()`从128个发射开始，为什么`observeOn()`在请求另一个96个之前只向下发送96个，留下了32个未处理发射？初始的发射批次稍微大一些，所以如果有任何空闲时间，会有一些额外的工作被排队。如果在理论上我们的`Flowable`操作从请求96个发射开始，并继续每次发射96个发射，那么可能会有一些时刻操作可能会空闲等待下一个96个。因此，维护一个额外的32个发射的滚动缓存，在空闲时刻提供工作，这可以提供更高的吞吐量。这就像一个仓库在等待从工厂得到更多库存的同时，持有少量额外的库存来供应订单。
- en: What is great about Flowables and their operators is that they usually do all
    the work for you. You do not have to specify any backpressure policies or parameters
    unless you need to create your own Flowables from scratch or deal with sources
    (such as Observables) that do not implement backpressure. We will cover these
    cases in the rest of the chapter, and hopefully, you will not run into them often.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable`及其操作符的伟大之处在于它们通常为你做所有工作。除非你需要从头创建自己的`Flowable`或处理（如`Observable`）不实现背压的源，否则你不需要指定任何背压策略或参数。我们将在本章的其余部分讨论这些情况，并希望你不会经常遇到。'
- en: Otherwise, Flowable is just like an `Observable` with nearly all the operators
    we learned so far. You can convert from an `Observable` into a `Flowable` and
    vice-versa, which we will cover later. But first, let's cover when we should use
    Flowables instead of Observables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`Flowable`就像我们迄今为止学到的几乎所有操作符的`Observable`。你可以从`Observable`转换为`Flowable`，反之亦然，我们将在后面讨论。但首先，让我们讨论我们应该在什么情况下使用`Flowable`而不是`Observable`。
- en: When to use Flowables and backpressure
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Flowables和背压
- en: It is critical to know when to use `Flowable` versus `Observable`. Overall,
    the benefits offered from the `Flowable` are leaner usage of memory (preventing
    `OutOfMemoryError` exceptions) as well as prevention of `MissingBackpressureException`.
    The latter can occur if operations backpressure against a source but the source
    has no backpressure protocol in its implementation. However, the disadvantage
    of Flowable is that it adds overhead and may not perform as quickly as an `Observable`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 知道何时使用`Flowable`而不是`Observable`是至关重要的。总的来说，`Flowable`提供的优势是更节省内存的使用（防止`OutOfMemoryError`异常）以及防止`MissingBackpressureException`。后者可能发生在操作对源进行背压，但源在其实现中没有背压协议的情况下。然而，`Flowable`的缺点是它增加了开销，可能不如`Observable`快速。
- en: Here are a few guidelines to help you choose between an `Observable` versus
    a `Flowable`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些指南可以帮助你选择使用`Observable`还是`Flowable`。
- en: Use an Observable If...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果使用一个可观察对象...
- en: You expect few emissions over the life of the `Observable` subscription (less
    than 1000) or the emissions are intermittent and far apart. If you expect only
    a trickle of emissions coming from a source, an `Observable` will do the job just
    fine and have less overhead. But when you are dealing with large amounts of data
    and performing complex operations on them, you will likely want to use a `Flowable`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你预计在`Observable`订阅的生命周期中发射的数量很少（少于1000）或者发射是间歇性的且间隔很远。如果你只期望从源处发出少量的发射，一个`Observable`就能很好地完成任务并且开销更小。但是当你处理大量数据并对它们执行复杂操作时，你可能会想使用`Flowable`。
- en: Your operation is strictly synchronous and has limited usage of concurrency.
    This includes simple usage of `subscribeOn()` at the start of an `Observable`
    chain because the process is still operating on a single thread and emitting items
    synchronously downstream. However, when you start zipping and combining different
    streams on different threads, parallelize, or use operators such as `observeOn()`,
    `interval()`, and `delay()`, your application is no longer synchronous and you
    might be better-off using a `Flowable`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的操作是严格同步的，并且并发使用有限。这包括在`Observable`链的开始简单使用`subscribeOn()`，因为该过程仍在单个线程上操作并同步向下发射项目。然而，当你开始在不同的线程上压缩和组合不同的流、并行化或使用如`observeOn()`、`interval()`和`delay()`这样的操作符时，你的应用程序就不再是同步的，你可能更倾向于使用`Flowable`。
- en: You want to emit user interface events such as button clicks, `ListView` selections,
    or other user inputs on Android, JavaFX, or Swing. Since users cannot programmatically
    be told to slow down, there is rarely any opportunity using a `Flowable`. To cope
    with rapid user inputs, you are likely better-off using the operators discussed
    in [Chapter 7](964f5943-b955-49f7-b53e-801754d06c3c.xhtml), *Switching, Throttling,
    Windowing, and Buffering*.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要在Android、JavaFX或Swing上发射用户界面事件，如按钮点击、`ListView`选择或其他用户输入。由于用户不能被编程告知减慢速度，所以很少有机会使用`Flowable`。为了应对快速的用户输入，你可能会更倾向于使用[第7章](964f5943-b955-49f7-b53e-801754d06c3c.xhtml)中讨论的操作符，*切换、节流、窗口化和缓冲*。
- en: Use a Flowable If...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在以下情况下使用Flowable...
- en: You are dealing with over 10,000 elements and there is opportunity for the source
    to generate emissions in a regulated manner. This is especially true when the
    source is asynchronous and pushes large amounts of data.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在处理超过10,000个元素，并且源有机会以有规律的方式生成排放。当源是异步的并且推送大量数据时，这一点尤其正确。
- en: You want to emit from IO operations that support blocking while returning results,
    which is how many IO sources work. Data sources that iterate records, such as
    lines from files or a `ResultSet` in JDBC, are especially easy to control because
    iteration can pause and resume as needed. Network and Streaming APIs that can
    request a certain amount of returned results can easily be backpressured as well.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要从支持阻塞并返回结果的IO操作中发射，这是许多IO源的工作方式。迭代记录的数据源，如文件中的行或JDBC中的`ResultSet`，特别容易控制，因为迭代可以根据需要暂停和恢复。可以请求一定量返回结果的网络和流式API也可以轻松地产生背压。
- en: Note in RxJava 1.0, the `Observable` was backpressured and was essentially what
    the `Flowable` is in RxJava 2.0\. The reason the `Flowable` and `Observable` became
    separate types is due to the merits of both for different situations, as described
    precedingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在RxJava 1.0中，`Observable`会受到背压，这本质上就是RxJava 2.0中的`Flowable`。`Flowable`和`Observable`成为不同类型的原因是它们在不同情况下的优点，如前所述。
- en: You will find that you can easily interoperate Observables and Flowables together.
    But you need to be careful and aware of the context they are being used in and
    where undesired bottlenecks can occur.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现你可以轻松地将Observables和Flowables一起使用。但你需要小心并意识到它们被使用的上下文以及可能出现的未期望的瓶颈。
- en: Understanding the Flowable and Subscriber
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Flowable和Subscriber
- en: Pretty much all the `Observable` factories and operators you learned up to this
    point also apply to Flowable. On the factory side, there is `Flowable.range()`,
    `Flowable.just()`, `Flowable.fromIterable()`, and `Flowable.interval()`. Most
    of these implement backpressure for you, and usage is generally the same as the
    `Observable` equivalent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有你到目前为止学到的`Observable`工厂和操作符也适用于Flowable。在工厂方面，有`Flowable.range()`、`Flowable.just()`、`Flowable.fromIterable()`和`Flowable.interval()`。其中大多数为你实现了背压，并且使用方式通常与`Observable`等价。
- en: 'However, consider `Flowable.interval()`, which pushes time-based emissions
    at fixed time intervals. Can this be backpressured logically? Contemplate the
    fact that each emission is sensitively tied to the time it emits. If we slowed
    down `Flowable.interval()`, our emissions would no longer reflect time intervals
    and become misleading. Therefore, `Flowable.interval()` is one of those few cases
    in the standard API that can throw `MissingBackpressureException` the moment downstream
    requests backpressure. Here, if we emit every millisecond against a slow `intenseCalculation()` that
    occurs after `observeOn()`, we will get this error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑一下`Flowable.interval()`，它在固定的时间间隔推动基于时间的排放。这能否在逻辑上产生背压？思考这样一个事实：每次排放都与它排放的时间紧密相关。如果我们减慢`Flowable.interval()`的速度，我们的排放将不再反映时间间隔，从而产生误导。因此，`Flowable.interval()`是标准API中少数几个在下游请求背压时可以抛出`MissingBackpressureException`的情况之一。在这里，如果我们每毫秒对`observeOn()`之后的慢速`intenseCalculation()`进行排放，我们将得到这个错误：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To overcome this issue, you can use operators such as `onBackpresureDrop()`
    or `onBackPressureBuffer()`, which we will learn about later in this chapter.
    `Flowable.interval()` is one of those factories that logically cannot be backpressured
    at the source, so you can use operators after it to handle backpressure for you.
    Otherwise, most of the other `Flowable` factories you work with support backpressure.
    Later, we need to call out how to create our own `Flowable` sources that conform
    to backpressure, and we will discuss this shortly. But first, we will explore
    the Subscriber a bit more.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，你可以使用`onBackpresureDrop()`或`onBackPressureBuffer()`等操作符，我们将在本章后面学习。`Flowable.interval()`是那些在源头上逻辑上不能进行背压的工厂之一，因此你可以使用它后面的操作符来为你处理背压。否则，你使用的其他大多数`Flowable`工厂都支持背压。稍后，我们需要指出如何创建符合背压的自己的`Flowable`源，我们将在稍后讨论这个问题。但首先，我们将更深入地探讨`Subscriber`。
- en: The Subscriber
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于`Subscriber`
- en: Instead of an `Observer`, the `Flowable` uses a `Subscriber` to consume emissions
    and events at the end of a `Flowable` chain. If you pass only lambda event arguments
    (and not an entire `Subscriber` object), `subscribe()` does not return a `Disposable` but
    rather a `Subscription`, which can be disposed of by calling `cancel()` instead
    of `dispose()`. The `Subscription` can also serve another purpose; it communicates
    upstream how many items are wanted using its `request()` method. `Subscription`
    can also be leveraged in the `onSubscribe()` method of `Subscriber` to `request()`
    elements the moment it is ready to receive emissions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Observer`不同，`Flowable`使用`Subscriber`在`Flowable`链的末尾消费排放量和事件。如果你只传递lambda事件参数（而不是整个`Subscriber`对象），`subscribe()`不会返回`Disposable`，而是返回`Subscription`，可以通过调用`cancel()`而不是`dispose()`来取消它。`Subscription`还可以通过其`request()`方法向上游传达想要多少项。`Subscription`还可以在`Subscriber`的`onSubscribe()`方法中利用，以便在准备好接收排放量时立即`request()`元素。
- en: 'Just like an `Observer`, the quickest way to create a `Subscriber` is to pass
    lambda arguments to `subscribe()`, as we have been doing earlier (and shown again
    in the following code). This default implementation of `Subscriber` will request
    an unbounded number of emissions upstream, but any operators preceding it will
    still automatically handle backpressure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Observer`一样，创建`Subscriber`最快的方法是将lambda参数传递给`subscribe()`，正如我们之前所做的那样（以下代码再次展示了这一点）。这个`Subscriber`的默认实现将请求无界的排放量，但任何在其前面的操作员仍然会自动处理背压：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, you can implement your own `Subscriber` as well, which, of course,
    has the `onNext()`, `onError()`, and `onComplete()` methods as well as `onSubscribe()`.
    This is not as straightforward as implementing an `Observer` because you need
    to call `request()` on `Subscription` to request emissions at the right moments.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以实现自己的`Subscriber`，它当然有`onNext()`、`onError()`、`onComplete()`方法以及`onSubscribe()`。这不像实现`Observer`那样直接，因为你需要在适当的时候在`Subscription`上调用`request()`来请求排放量。
- en: The quickest and easiest way to implement a `Subscriber` is to have the `onSubscribe()`
    method call `request(Long.MAX_VALUE)` on `Subscription`, which essentially tells
    the upstream "give me everything now". Even though the operators preceding `Subscriber`
    will request emissions at their own backpressured pace, no backpressure will exist
    between the last operator and the `Subscriber`. This is usually fine since the
    upstream operators will constrain the flow anyway.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`Subscriber`最快和最简单的方法是在`onSubscribe()`方法中调用`Subscription`上的`request(Long.MAX_VALUE)`，这本质上告诉上游“现在给我所有东西”。尽管前面的操作员将以自己的背压速度请求排放量，但最后操作员和`Subscriber`之间不会存在背压。这通常是正常的，因为上游操作员无论如何都会约束流量。
- en: 'Here, we reimplement our previous example but implement our own `Subscriber`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重新实现了我们之前的例子，但实现了我们自己的`Subscriber`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want your `Subscriber` to establish an explicit backpressured relationship
    with the operator preceding it, you will need to micromanage the `request()` calls.
    Say, for some extreme situation, you decide that you want `Subscriber` to request
    40 emissions initially and then 20 emissions at a time after that. This is what
    you would need to do:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的`Subscriber`与它前面的操作员建立显式的背压关系，你需要对`request()`调用进行微观管理。比如说，在某种极端情况下，你决定让`Subscriber`最初请求40个排放量，然后每次请求20个排放量。这是你需要做的：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the source is still emitting 128 emissions initially and then still
    pushes 96 emissions at a time. But our `Subscriber` received only 40 emissions,
    as specified, and then consistently calls for 20 more. The `request()` calls in
    our `Subscriber` only communicate to the immediate operator upstream to it, which
    is `map()`. The `map()` operator likely relays that request to `observeOn()`,
    which is caching items and only flushing out 40 and then 20, as requested by the
    `Subscriber`. When its cache gets low or clears out, it will request another 96
    from the upstream.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，源仍然最初排放128个排放量，然后仍然每次推送96个排放量。但是我们的`Subscriber`只接收了40个排放量，正如指定的那样，然后持续要求再增加20个。我们`Subscriber`中的`request()`调用只与它上游的即时操作员`map()`通信。`map()`操作员可能将那个请求转发到`observeOn()`，它正在缓存项目，并且只根据`Subscriber`的要求输出40个和20个。当其缓存变低或清空时，它将从上游请求另一个96个。
- en: 'This is a warning: you should not rely on these exact numbers of requested
    emissions, such as 128 and 96\. These are an internal implementation we happen
    to observe, and these numbers may be changed to aid further implementation optimizations
    in the future.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个警告：你不应该依赖于请求排放的确切数字，例如128和96。这些是我们偶然观察到的内部实现，这些数字可能会在未来为了进一步优化实现而改变。
- en: This custom implementation may actually be reducing our throughput, but it demonstrates
    how to manage custom backpressure with your own `Subscriber` implementation. Just
    keep in mind that the `request()` calls do not go all the way upstream. They only
    go to the preceding operator, which decides how to relay that request upstream.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自定义实现实际上可能正在降低我们的吞吐量，但它展示了如何通过自己的`Subscriber`实现来管理自定义背压。只需记住，`request()`调用并不一直向上游传递。它们只到达前面的操作员，该操作员决定如何将那个请求转发到上游。
- en: Creating a Flowable
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Flowable
- en: 'Earlier in this book, we used `Observable.create()` a handful of times to create
    our own `Observable` from scratch, which describes how to emit items when it is
    subscribed to, as shown in the following code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的早期，我们多次使用`Observable.create()`从头开始创建我们自己的`Observable`，这描述了在订阅时如何输出项目，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `Observable.create()`will emit the integers 0 to 1000 and then call `onComplete()`.
    It can be stopped abruptly if `dispose()` is called on the `Disposable` returned
    from `subscribe()`, and the for-loop will check for this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Observable.create()`将输出从0到1000的整数，然后调用`onComplete()`。如果对从`subscribe()`返回的`Disposable`调用`dispose()`，它可以被突然停止，for循环将检查这一点。
- en: However, think for a moment how something like this can be backpressured if
    we execute `Flowable.create()`, the `Flowable` equivalent of `Observable.create()`.
    Using a simple for-loop like the preceding one, there is no notion of emissions
    *stopping* and *resuming* based on the requests of a downstream `Subscriber`.
    Doing backpressure properly is going to add some complexity. There are simpler
    ways to support backpressure, but they often involve compromised strategies such
    as buffering and dropping, which we will cover first. There are also a few utilities
    to implement backpressure at the source, which we will cover afterward.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，思考一下，如果我们执行`Flowable.create()`，即`Observable.create()`的`Flowable`等效，如何实现类似这样的背压。使用像前面的简单for循环，没有基于下游`Subscriber`请求的排放*停止*和*恢复*的概念。正确实现背压将增加一些复杂性。有一些更简单的方法来支持背压，但它们通常涉及妥协策略，如缓冲和丢弃，我们将在首先介绍。还有一些工具可以在源处实现背压，我们将在之后介绍。
- en: Using Flowable.create() and BackpressureStrategy
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flowable.create()和BackpressureStrategy
- en: Leveraging `Flowable.create()` to create a `Flowable` feels much like `Observable.create()`,
    but there is one critical difference; you must specify a `BackpressureStrategy`
    as a second argument. This enumerable type does not by any means provide magic
    implementations of backpressure support. As a matter of fact, this simply supports
    backpressure by caching or dropping emissions or not implementing backpressure
    at all.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`Flowable.create()`创建一个`Flowable`感觉就像`Observable.create()`，但有一个关键的区别；你必须指定一个`BackpressureStrategy`作为第二个参数。这种可枚举类型并不提供任何形式的背压支持的魔法实现。事实上，这仅仅通过缓存或丢弃排放量或根本不实现背压来支持背压。
- en: 'Here, we use `Flowable.create()` to create a `Flowable`, but we provide a second
    `BackpressureStrategy.BUFFER` argument to buffer the emissions before they are
    backpressured:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Flowable.create()`来创建一个`Flowable`，但我们提供了一个第二个`BackpressureStrategy.BUFFER`参数来在背压之前缓存排放量：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is not optimal because the emissions will be held in an unbounded queue,
    and it is possible that when `Flowable.create()` pushes too many emissions, you
    will get an `OutOfMemoryError`. But at least it prevents `MissingBackpressureException`
    and can make your custom `Flowable` workable to a small degree. We will learn
    about a more robust way to implement backpressure later in this chapter using
    `Flowable.generate()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最佳方案，因为排放将被保留在一个无界队列中，当`Flowable.create()`推送过多的排放时，你可能会得到一个`OutOfMemoryError`。但至少它防止了`MissingBackpressureException`，并且可以在一定程度上使你的自定义`Flowable`可行。我们将在本章后面学习使用`Flowable.generate()`实现更健壮的反压方法。
- en: There are currently five `BackpressureStrategy` options you can choose from.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有五种`BackpressureStrategy`选项可供选择。
- en: '| **BackpressureStrategy** | **Description** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **反压策略** | **描述** |'
- en: '| MISSING | Essentially results in no backpressure implementation at all. The
    downstream must deal with backpressure overflow, which can be helpful when used
    with `onBackpressureXXX()` operators, which we will cover later in this chapter.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 缺失 | 实际上没有实现任何反压。下游必须处理反压溢出，当与我们在本章后面将要介绍的`onBackpressureXXX()`操作符一起使用时可能很有帮助。
    |'
- en: '| ERROR | Signals a `MissingBackpressureException` the moment the downstream
    cannot keep up with the source. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 当下游无法跟上源时，会立即触发`MissingBackpressureException`。 |'
- en: '| BUFFER | Queues up emissions in an unbounded queue until the downstream is
    able to consume them, but can cause an `OutOfMemoryError` if the queue gets too
    large. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| BUFFER | 在无界队列中排队排放，直到下游能够消费它们，但如果队列太大，可能会引起`OutOfMemoryError`。 |'
- en: '| DROP | If the downstream cannot keep up, this will ignore upstream emissions
    and not queue anything while the downstream is busy. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| DROP | 如果下游无法跟上，这将忽略上游排放，并在下游忙碌时不会排队任何内容。 |'
- en: '| LATEST | This will keep only the latest emission until the downstream is
    ready to receive it. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 最新 | 这将只保留最新的排放，直到下游准备好接收它。 |'
- en: Next, we will see some of these strategies used as operators, particularly converting
    Observables into Flowables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一些这些策略作为操作符的使用，特别是将Observables转换为Flowables。
- en: Turning an Observable into a Flowable (and vice-versa)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Observable转换为Flowable（反之亦然）
- en: 'There is another way that you can implement `BackpressureStrategy` against
    a source that has no notion of backpressure. You can turn an Observable into `Flowable`
    easily by calling its `toFlowable()` operator, which accepts a `BackpressureStrategy`
    as an argument. In the following code, we turn `Observable.range()` into `Flowable` using `BackpressureStrategy.BUFFER`.
    The Observable has no notion of backpressure, so it is going to push items as
    quickly as it can regardless if the downstream can keep up. But `toFlowable()`,
    with a buffering strategy, will act as a proxy to backlog the emissions when the
    downstream cannot keep up:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将`Observable`转换为`Flowable`来对没有反压概念的数据源实现`BackpressureStrategy`。你可以通过调用其`toFlowable()`操作符并传递一个`BackpressureStrategy`作为参数来轻松地将Observable转换为`Flowable`。在下面的代码中，我们使用`BackpressureStrategy.BUFFER`将`Observable.range()`转换为`Flowable`。Observable没有反压概念，所以它将尽可能快地推送项目，不管下游是否能跟上。但是，带有缓冲策略的`toFlowable()`将在下游无法跟上时作为代理来缓冲排放：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, note that `toFlowable()`, with a buffering strategy, is going to have
    an unbounded queue, which can cause an `OutOfMemoryError`. In the real world,
    it would be better to use `Flowable.range()` in the first place, but sometimes,
    you may only be provided with an `Observable`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，带有缓冲策略的`toFlowable()`将有一个无界队列，这可能会导致`OutOfMemoryError`。在现实世界中，最好首先使用`Flowable.range()`，但有时你可能只能得到一个`Observable`。
- en: 'The `Flowable` also has a `toObservable()` operator, which will turn a `Flowable<T>`
    into an `Observable<T>`. This can be helpful in making a `Flowable` usable in
    an `Observable` chain, especially with operators such as `flatMap()`, as shown
    in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable`还有一个`toObservable()`操作符，它将`Flowable<T>`转换为`Observable<T>`。这有助于使`Flowable`在`Observable`链中使用，特别是与`flatMap()`等操作符一起使用，如下面的代码所示：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `Observable<String>` had much more than five emissions (such as 1,000 or
    10,000), then it would probably be better to turn that into a `Flowable` instead
    of turning the flat-mapped `Flowable` into an `Observable`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Observable<String>`有超过五个排放（例如1,000或10,000），那么将其转换为`Flowable`可能更好，而不是将扁平映射的`Flowable`转换为`Observable`。
- en: Even if you call `toObservable()`, the `Flowable` will still leverage backpressure
    upstream. But at the point it becomes an `Observable`, the downstream will no
    longer be backpressured and will request a `Long.MAX_VALUE` number of emissions.
    This may be fine as long as no more intensive operations or concurrency changes
    happen downstream and the `Flowable` operations upstream constrains the number
    of emissions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你调用 `toObservable()`，`Flowable` 仍然会在上游利用背压。但到了它成为 `Observable` 的点，下游将不再受到背压，并请求
    `Long.MAX_VALUE` 数量的发射。只要下游没有发生更复杂的操作或并发变化，并且上游的 `Flowable` 操作限制了发射的数量，这可能就足够了。
- en: But typically, when you commit to using a `Flowable`, you should strive to make
    your operations remain `Flowable`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常情况下，当你承诺使用一个 `Flowable` 时，你应该努力使你的操作保持 `Flowable`。
- en: Using onBackpressureXXX() operators
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 onBackpressureXXX() 操作符
- en: If you are provided a `Flowable` that has no backpressure implementation (including
    ones derived from `Observable`), you can apply `BackpressureStrategy` using `onBackpressureXXX()`
    operators. These also provide a few additional configuration options. This can
    be helpful if, for example, you have a `Flowable.interval()` that emits faster
    than consumers can keep up. `Flowable.interval()` cannot be slowed down at the
    source because it is time-driven, but we can use an `onBackpressureXXX()` operator
    to proxy between it and the downstream. We will use `Flowable.interval()` for
    these examples, but this can apply to any `Flowable` that does not have backpressure
    implemented.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供了一个没有背压实现（包括从 `Observable` 派生的）的 `Flowable`，你可以使用 `onBackpressureXXX()`
    操作符应用 `BackpressureStrategy`。这些操作符还提供了一些额外的配置选项。如果，例如，你有一个 `Flowable.interval()`
    发射速度比消费者处理速度快，这可能会很有用。`Flowable.interval()` 由于是时间驱动的，不能在源处减慢速度，但我们可以使用 `onBackpressureXXX()`
    操作符在它和下游之间代理。我们将使用 `Flowable.interval()` 进行这些示例，但这可以应用于任何没有实现背压的 `Flowable`。
- en: Sometimes, `Flowable` may simply be configured with `BackpressureStrategy.MISSING`
    so these `onBackpressureXXX()` operators can specify the strategy later.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`Flowable` 可能只是配置了 `BackpressureStrategy.MISSING`，这样 `onBackpressureXXX()`
    操作符就可以稍后指定策略。
- en: onBackPressureBuffer()
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: onBackPressureBuffer()
- en: 'The `onBackPressureBuffer()`will take an existing `Flowable` that is assumed
    to not have backpressure implemented and then essentially apply `BackpressureStrategy.BUFFER`
    at that point to the downstream. Since `Flowable.interval()` cannot be backpressured
    at the source, putting `onBackPressureBuffer()` after it will proxy a backpressured
    queue to the downstream:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBackPressureBuffer()` 将接受一个假设未实现背压的现有 `Flowable`，并在该点向下游应用 `BackpressureStrategy.BUFFER`。由于
    `Flowable.interval()` 在源处不能进行背压，将其放在 `onBackPressureBuffer()` 之后将代理一个背压队列到下游：'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a number of overload arguments that you can provide as well. We will
    not get into all of them, and you can refer to the JavaDocs for more information,
    but we will highlight the common ones. The capacity argument will create a maximum
    threshold for the buffer rather than allowing it to be unbounded. An `onOverflow`
    `Action` lambda can be specified to fire an action when an overflow exceeds the
    capacity. You can also specify a `BackpressureOverflowStrategy` enum to instruct
    how to handle an overflow that exceeds the capacity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一些重载参数。我们不会详细介绍所有这些参数，你可以参考 JavaDocs 获取更多信息，但我们将突出显示常见的参数。容量参数将为缓冲区创建一个最大阈值，而不是允许其无界。你可以指定一个
    `onOverflow` `Action` lambda，当溢出超过容量时触发一个动作。你还可以指定一个 `BackpressureOverflowStrategy`
    枚举来指示如何处理超过容量的溢出。
- en: 'Here are the three `BackpressureOverflowStrategy` enum items that you can choose
    from:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可以选择的三个 `BackpressureOverflowStrategy` 枚举项：
- en: '| **BackpressureOverflowStrategy** | **Description** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **BackpressureOverflowStrategy** | **描述** |'
- en: '| ERROR | Simply throws an error the moment capacity is exceeded |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ERROR | 当容量超过时立即抛出错误 |'
- en: '| DROP_OLDEST | Drops the oldest value from the buffer to make way for a new
    one |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| DROP_OLDEST | 从缓冲区中丢弃最旧的值，为新值腾出空间 |'
- en: '| DROP_LATEST | Drops the latest value from the buffer to prioritize older,
    unconsumed values |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| DROP_LATEST | 从缓冲区中丢弃最新的值，以优先处理较旧的未消费值 |'
- en: 'In the following code, we hold a maximum capacity of 10 and specify to use
    `BackpressureOverflowStrategy.DROP_LATEST` in the event of an overflow. We also
    will print a notification in the event of an overflow:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们保持最大容量为 10，并在溢出时指定使用 `BackpressureOverflowStrategy.DROP_LATEST`。我们还会在溢出时打印一个通知：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that in this part of my noisy output, there was a large range of numbers
    skipped between `136` and `492`. This is because these emissions were dropped
    from the queue due to `BackpressureOverflowStrategy.DROP_LATEST`. The queue was
    already filled with emissions waiting to be consumed, so the new emissions were
    ignored.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我嘈杂的输出这部分，`136`和`492`之间跳过了很大一段数字范围。这是因为由于`BackpressureOverflowStrategy.DROP_LATEST`，这些排放被从队列中丢弃。队列已经充满了等待被消费的排放，所以新的排放被忽略了。
- en: onBackPressureLatest()
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onBackPressureLatest()`'
- en: 'A slight variant of `onBackpressureBuffer()` is `onBackPressureLatest()`. This
    will retain the latest value from the source while the downstream is busy, and
    once the downstream is free to process more, it will provide the latest value.
    Any previous values emitted during this busy period will be lost:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBackpressureBuffer()`的一个轻微变体是`onBackPressureLatest()`。当下游忙碌时，它将保留源的最新值，一旦下游空闲可以处理更多，它将提供最新值。在此忙碌期间发出的任何先前值都将丢失：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you study my output, you will notice that there is a jump between `127` and
    `494`. This is because all numbers in between were ultimately beaten by `494`
    being the latest value, and at that time, the downstream was ready to process
    more emissions. It started by consuming the cached `494` and the others before
    it was dropped.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究我的输出，你会注意到`127`和`494`之间有一个跳跃。这是因为所有介于它们之间的数字最终都被`494`这个最新值击败，当时，下游已经准备好处理更多的排放。它从消费缓存的`494`和其他之前被丢弃的排放开始。
- en: onBackPressureDrop()
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onBackPressureDrop()`'
- en: 'The `onBackpressureDrop()`will simply discard emissions if the downstream is
    too busy to process them. This is helpful when emissions are considered redundant
    if the downstream is already occupied (such as a "`RUN`" request being sent repeatedly,
    although the resulting process is already running). You can optionally provide
    an `onDrop` lambda argument specifying what to do with each dropped item, which
    we will simply print, as shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBackpressureDrop()`将简单地丢弃下游太忙无法处理的排放。当下游已经忙碌（例如，一个"`RUN`"请求被重复发送，尽管结果过程已经运行）时，这很有帮助。你可以选择性地提供一个`onDrop`
    lambda 参数，指定对每个丢弃项要做什么，我们将简单地按照以下代码打印出来：'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In my output, note that there is a large jump between `127` and `493`. The numbers
    between them were dropped because the downstream was already busy when they were
    ready to be processed, so they were discarded rather than queued.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的输出中，注意`127`和`493`之间有一个很大的跳跃。它们之间的数字被丢弃，因为当它们准备好被处理时，下游已经忙碌，所以它们被丢弃而不是排队。
- en: Using Flowable.generate()
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Flowable.generate()`
- en: A lot of the content we covered so far in this chapter did not show the optimal
    approaches to backpressure a source. Yes, using a `Flowable` and most of the standard
    factories and operators will automatically handle backpressure for you. However,
    if you are creating your own custom sources, `Flowable.create()` or the `onBackPressureXXX()`
    operators are somewhat compromised in how they handle backpressure requests. While
    quick and effective for some cases, caching emissions or simply dropping them
    is not always desirable. It would be better to make the source backpressured in
    the first place.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到目前为止我们讨论的很多内容都没有展示出对源进行背压的最优方法。是的，使用`Flowable`以及大多数标准工厂和操作符会自动为你处理背压。然而，如果你正在创建自己的自定义源，`Flowable.create()`或`onBackPressureXXX()`操作符在处理背压请求方面有些妥协。虽然对于某些情况来说既快又有效，但缓存排放或简单地丢弃它们并不总是可取的。最好是首先让源受到背压。
- en: Thankfully, `Flowable.generate()` exists to help create backpressure, respecting
    sources at a nicely abstracted level. It will accept a `Consumer<Emitter<T>>`
    much like `Flowable.create()`, but it will use a lambda to specify what `onNext()`,
    `onComplete()`, and `onError()` events to pass each time an item is requested
    from the upstream.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Flowable.generate()`存在，可以帮助创建背压，在很好地抽象级别上尊重源。它将接受一个`Consumer<Emitter<T>>`，就像`Flowable.create()`一样，但它将使用lambda来指定每次从上游请求项目时要传递的`onNext()`、`onComplete()`和`onError()`事件。
- en: Before you use `Flowable.generate()`, consider making your source `Iterable<T>`
    instead and passing it to `Flowable.fromIterable()`. The `Flowable.fromIterable()`will
    respect backpressure and might be easier to use for many cases. Otherwise, `Flowable.generate()`
    is your next best option if you need something more specific.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用 `Flowable.generate()` 之前，考虑将你的源 `Iterable<T>` 改为 `Iterable<T>` 并将其传递给 `Flowable.fromIterable()`。`Flowable.fromIterable()`
    会尊重背压，并且对于许多情况来说可能更容易使用。否则，如果你需要更具体的东西，`Flowable.generate()` 是你的下一个最佳选择。
- en: 'The simplest overload for `Flowable.generate()` accepts just `Consumer<Emitter<T>>` and
    assumes that there is no state maintained between emissions. This can be helpful
    in creating a backpressure-aware random integer generator, as displayed here.
    Note that 128 emissions are immediately emitted, but after that, 96 are pushed
    downstream before another 96 are sent from the source:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable.generate()` 的最简单重载只接受 `Consumer<Emitter<T>>` 并假设在发射之间没有维护状态。这有助于创建一个具有背压感知的随机整数生成器，如下所示。请注意，立即发出
    128 个发射，但之后，在从源发送另一个 96 个之前，会向下游推送 96 个：'
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With `Flowable.generate()`, invoking multiple `onNext()` operators within `Consumer<Emitter<T>>`
    will result in `IllegalStateException`. The downstream needs it only to invoke
    `onNext()` once, so it can make the repeated calls, as required, to maintain flow.
    It will also emit `onError()` for you in the event that an exception occurs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Flowable.generate()`，在 `Consumer<Emitter<T>>` 中调用多个 `onNext()` 操作符将导致 `IllegalStateException`。下游只需要调用一次
    `onNext()`，因此它可以按照需要重复调用，以保持流动。如果发生异常，它还会为您发出 `onError()`。
- en: 'You can also provide a state that can act somewhat like a "seed" similar to
    `reduce()` and maintain a state that is passed from one emission to the next.
    Suppose we want to create something similar to `Flowable.range()` but instead,
    we want to emit the integers in reverse between `upperBound` and `lowerBound`.
    Using `AtomicInteger` as our state, we can decrement it and pass its value to
    the emitter''s `onNext()` operator until `lowerBound` is encountered. This is
    demonstrated as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以提供一个类似于 `reduce()` 的“种子”状态，以维护从一次发射到下一次发射传递的状态。假设我们想要创建类似于 `Flowable.range()`
    的东西，但相反，我们想要在 `upperBound` 和 `lowerBound` 之间反向发出整数。使用 `AtomicInteger` 作为我们的状态，我们可以递减它并将它的值传递给发射器的
    `onNext()` 操作符，直到遇到 `lowerBound`。这如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Flowable.generator()` provides a nicely abstracted mechanism to create a source
    that respects backpressure. For this reason, you might want to prefer this over
    `Flowable.create()` if you do not want to mess with caching or dropping emissions.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable.generator()` 提供了一个很好地抽象化的机制来创建一个尊重背压的源。因此，如果你不希望与缓存或丢弃发射项打交道，你可能会更喜欢使用这个而不是
    `Flowable.create()`。'
- en: With `Flowable.generate()`, you can also provide a third `Consumer<? super S>
    disposeState` argument to do any disposal operations on termination, which can
    be helpful for IO sources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Flowable.generate()`，您还可以提供一个第三个 `Consumer<? super S> disposeState` 参数，在终止时执行任何清理操作，这对于
    IO 源可能很有帮助。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about `Flowable` and backpressure and which situations
    it should be preferred over an `Observable`. Flowables are especially preferable
    when concurrency enters your application and a lot of data can flow through it,
    as it regulates how much data comes from the source at a given time. Some Flowables,
    such as `Flowable.interval()` or those derived from an `Observable`, do not have
    backpressure implemented. In these situations, you can use `onBackpressureXXX()`
    operators to queue or drop emissions for the downstream. If you are creating your
    own `Flowable` source from scratch, prefer to use the existing `Flowable` factories,
    and if that fails, prefer `Flowable.generate()` instead of `Flowable.create()`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于 `Flowable` 和背压以及它应该在哪些情况下优先于 `Observable`。当并发进入你的应用程序并且大量数据可以通过它流动时，Flowables
    特别受欢迎，因为它调节了在给定时间内从源处来的数据量。一些 Flowables，如 `Flowable.interval()` 或从 `Observable`
    派生的那些，没有实现背压。在这些情况下，你可以使用 `onBackpressureXXX()` 操作符来排队或丢弃下游的发射。如果你是从头开始创建自己的 `Flowable`
    源，则更喜欢使用现有的 `Flowable` 工厂，如果那失败了，则更喜欢使用 `Flowable.generate()` 而不是 `Flowable.create()`。
- en: If you got to this point and understand most of the content in this book so
    far, congrats! You have all the core concepts of RxJava in your toolkit, and the
    rest of the book is all a walk in the park from here. The next chapter will cover
    how to create your own operators, which can be a somewhat advanced task. At a
    minimum, you should know how to compose existing operators to create new operators,
    which will be one of the next topics.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这个阶段并且理解了这本书到目前为止的大部分内容，恭喜你！你已经拥有了RxJava的核心概念，而本书的剩余部分对你来说将是一条轻松的道路。下一章将介绍如何创建自己的操作符，这可能会是一项相对复杂的工作。至少，你应该知道如何组合现有的操作符来创建新的操作符，这将是下一个话题之一。
