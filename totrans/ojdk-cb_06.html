<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Building IcedTea with Other VM Implementations"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building IcedTea with Other VM Implementations</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring cross-compilation between ARM and x86</li><li class="listitem" style="list-style-type: disc">Building IcedTea for ARM with integrated CACAO VM</li><li class="listitem" style="list-style-type: disc">Porting JamVM to use OpenJDK</li><li class="listitem" style="list-style-type: disc">Configuring Zero assembler with the Shark compiler to use OpenJDK</li><li class="listitem" style="list-style-type: disc">Building MIPS and other architectures using OpenEmbedded recipes</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Introduction</h1></div></div></div><p>Though various x86-compatible platforms are widespread and common to use, there are other architectures to think about. Java language itself is designed to be as cross-platform, as possible. In an x86-compatible world, it means that Java will work equally well and predictable for the vast majority of operating systems. Where more architectures are concerned, it should work on a great number of them.</p><p>The ARM architecture is the second architecture among the most popular ones. It gives a great balance between power saving and performance, and is used mostly in embedded and portable devices. There are several operating systems, supporting ARM, such as various Linux distributions, Android, Symbian, MeeGo, and many Windows releases.</p><p>In this chapter, we will speak about building IcedTea on ARM, using virtual Java machines, which are not official and aren't parts of the OpenJDK community. They are built for different purposes—academic, performance, and so on.</p><p>Unfortunately, these days, the only operating system that works with ARM and OpenJDK both, is Linux. Nuances of building IcedTea on Linux differ from distribution to distribution, though the main idea and philosophy is the same.</p><p>In this chapter, we will try to use as many different distribution-based examples and device nuances, as possible, though the most thoroughly tested ones will be the following pairs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Raspberry Pi and Raspbian</li><li class="listitem" style="list-style-type: disc">Nexus 7 and Ubuntu touch</li></ul></div><p>This chapter will also cover a topic of cross-compilation with an x86-based system, because one may probably need a faster compilation that ARM processors are capable of, especially in the case of small computers of the Raspberry Pi class.</p><p>We will have three VMs in this chapter: ZeroVM, CACAO VM, and Jam VM. However, only the Zero assembler is a member of an OpenJDK project. The Zero assembler is an effort to get rid of platform-specific assembler languages and to build an interpreter-only virtual machine. It will make porting any Java executable to any operating system a remarkably easy task, but with a significant performance impact because of the absence of JIT. However, there is Shark, a JIT-compiler for Zero, which uses LLVM to compile the Zero-assembler to the platform-specific code. It's obvious, though, that Shark works only for architectures that are supported by LLVM itself.</p><p>JamVM is also famous because of its really small size, which is, depending on architectures, between 200 and 250 kilobytes. In this space, it implements the full JVM specification, published by Oracle, known as <span class="strong"><strong>blue book</strong></span>.</p></div></div>
<div class="section" title="Configuring cross-compilation between ARM and x86"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Configuring cross-compilation between ARM and x86</h1></div></div></div><p>Though <a id="id206" class="indexterm"/>many of the recent ARM devices have great performance and the same core numbers, as their desktop fellows, there are always those whose performance is not sufficient enough to do complicated work in a reasonable amount of time. Don't want to be bored by endless hours of compilation? Use OpenEmbedded builds. <span class="strong"><strong>OpenEmbedded</strong></span><a id="id207" class="indexterm"/> is a build framework to create Linux distributions and can cross-compile for a large variety of architectures.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec155"/>Getting ready</h2></div></div></div><p>We will need a real or emulated ARM device with Linux installed on it. The following recipes are primarily for the deb-based distributions, but the general idea remains the same for any ARM-based device that runs Linux kernel with GNU-based tools.</p><p>Also, we will need another device with Linux, or Windows with Cygwin installed, to do the main compilation job.</p><p>This recipe also assumes that you will use the deb-based distributions. If you are using the ebuild-based distributions, use their own cross-compile tools. In the rpm-based distributions, the process is quite similar.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec156"/>How to do it...</h2></div></div></div><p>First, we need to<a id="id208" class="indexterm"/> make use of the OpenEmbedded project. OpenEmbedded<a id="id209" class="indexterm"/> is a project whose goal is to build a platform-specific environment and build various known packages. Take a look at the following <a id="id210" class="indexterm"/>procedure to build various packages using the OpenEmbedded project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In order to use it, we will install some packages:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install git g++ gawk zip diffstat texi2html texinfo subversion chrpath libgl1-mesa-dev libglu1-mesa-dev libsdl1.2-dev</strong></span>
</pre></div></li><li class="listitem">After that, we need to get an OpenEmbedded environment:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone git://git.openembedded.org/openembedded-core oe-core</strong></span>
</pre></div></li><li class="listitem">Then, we need to create three more projects in the <code class="literal">oe-core</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd oe-core</strong></span>
</pre></div></li><li class="listitem">Moving ahead, let's clone some layers into our root directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone git://git.openembedded.org/bitbake bitbake</strong></span>

<span class="strong"><strong>git clone git://git.openembedded.org/meta-openembedded</strong></span>

<span class="strong"><strong>git clone https://github.com/woglinde/meta-java.git</strong></span>
</pre></div></li><li class="listitem">Finally, initialize an OpenEmbedded environment:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>. ./oe-init-build-env</strong></span>
</pre></div></li></ol></div><p>Now we have a fully operational OpenEmbedded environment. All we have to do is to configure our build. There are two ways to do it: by editing the config files manually or through the Hob GUI.</p><div class="section" title="Configuring OpenEmbedded build manually"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec01"/>Configuring OpenEmbedded build manually</h3></div></div></div><p>You will <a id="id211" class="indexterm"/>need to edit two configuration files: the first configuration file is for Java layer and the second is generic and easy to include this layer in the build, as shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, edit the <code class="literal">conf/local.conf</code> file.</li><li class="listitem">We will set JamVM as a preferred virtual machine:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PREFERRED_PROVIDER_virtual/java-native = "jamvm-native"</strong></span>
</pre></div></li><li class="listitem">Set other versions as you wish (Version 1.8.11, for example):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PREFERRED_PROVIDER_virtual/javac-native = "ecj-bootstrap-native"</strong></span>
<span class="strong"><strong>PREFERRED_VERSION_cacaoh-native = "&lt;version_number&gt;"</strong></span>
<span class="strong"><strong>PREFERRED_VERSION_icedtea6-native = "&lt;version_number&gt;"</strong></span>
</pre></div></li><li class="listitem">We will need an ARM build, so we will select a qemu-arm machine as the target machine:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MACHINE ?= "qemuarm"</strong></span>
</pre></div></li><li class="listitem">We will<a id="id212" class="indexterm"/> also need to mention how many compilation processes can be in progress together:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PARALLEL_MAKE = "-j 2"</strong></span>
</pre></div></li><li class="listitem">Also, we can reconfigure a number of threads for one compiling package. For a Quad-core computer, it will be <code class="literal">2</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>BB_NUMBER_THREADS = "2"</strong></span>
</pre></div></li><li class="listitem">Then, we will edit the <code class="literal">conf/bblayers.conf</code> file.</li><li class="listitem">The following parameter is a version of the file format. It means that there was 3 incompatible formats before this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>LCONF_VERSION = "4"</strong></span>
</pre></div></li><li class="listitem">We will then set layers to command OpenEmbedded system on what exactly to build:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>BBFILES ?= ""</strong></span>
<span class="strong"><strong>BBLAYERS = " \</strong></span>
<span class="strong"><strong>  /home/user/oe-core/meta \</strong></span>
<span class="strong"><strong>  /home/user/oe-core/meta-openembedded/meta-oe \</strong></span>
<span class="strong"><strong>  /home/user/oe-core/meta-java \</strong></span>
<span class="strong"><strong>"</strong></span>
</pre></div></li></ol></div></div><div class="section" title="Using the Hob utility to configure the OpenEmbedded build"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec02"/>Using the Hob utility to configure the OpenEmbedded build</h3></div></div></div><p>Hob is<a id="id213" class="indexterm"/> a <a id="id214" class="indexterm"/>graphical UI for BitBake. Please take a look at the following procedures to use the Hob utility to<a id="id215" class="indexterm"/> configure the OpenEmbedded build:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's run a <code class="literal">hob</code> executable from a build directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>hob</strong></span>
</pre></div><p>This can be done only after an environment initialization. You will have a command not found message otherwise.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>No command 'hob' found, did you mean:</strong></span>
<span class="strong"><strong> Command 'bob' from package 'python-sponge' (universe)</strong></span>
<span class="strong"><strong> Command 'hoz' from package 'hoz' (universe)</strong></span>
<span class="strong"><strong> Command 'tob' from package 'tob' (universe)</strong></span>
<span class="strong"><strong> Command 'hnb' from package 'hnb' (universe)</strong></span>
<span class="strong"><strong>hob: command not found</strong></span>
</pre></div></li><li class="listitem">A starting screen will appear as shown:<div class="mediaobject"><img src="graphics/8405_06_01.jpg" alt="Using the Hob utility to configure the OpenEmbedded build"/></div></li><li class="listitem">First, we<a id="id216" class="indexterm"/> will select a <a id="id217" class="indexterm"/>virtual machine. For ARM processors, the most convenient is the qemu-arm machine.</li><li class="listitem">After that, we will need to select two additional layers. One is the <span class="strong"><strong>meta-oe</strong></span> layer and the second is <span class="strong"><strong>meta-java</strong></span>.<div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>While the <code class="literal">meta-java</code> folder is in the root folder of OpenEmbedded, the path to <code class="literal">meta-oe</code> is <code class="literal">meta-openembedded/meta-oe/</code>.</p></div></div></li><li class="listitem">When a machine is chosen, the tool will parse all recipes and compute all dependencies <a id="id218" class="indexterm"/>needed. Then, the window should look like this:<div class="mediaobject"><img src="graphics/8405_06_02.jpg" alt="Using the Hob utility to configure the OpenEmbedded build"/></div></li><li class="listitem">Then select a recipe. Here<a id="id219" class="indexterm"/> is one Java-related recipe: <span class="strong"><strong>java-test-image</strong></span>. Although, it would be better not to choose it and choose <span class="strong"><strong>core-image-basic</strong></span> instead.<div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>You can try to assemble your image from scratch. You can select the package you want and dependencies will be automatically calculated.</p></div></div></li></ol></div><p>You can choose in an advanced configuration section, exactly what the output will be. You can even get it in a <code class="literal">.deb</code> form, as shown:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You need to edit recipes and add <span class="strong"><strong>openjdk-7-jre</strong></span> to them as shown:<div class="mediaobject"><img src="graphics/8405_06_03.jpg" alt="Using the Hob utility to configure the OpenEmbedded build"/></div><p>Also, you <a id="id220" class="indexterm"/>can add<a id="id221" class="indexterm"/> some dependencies that are necessary for the build.</p></li><li class="listitem">When all is ready, press the <span class="strong"><strong>Build packages</strong></span> button and the following screen will appear:<div class="mediaobject"><img src="graphics/8405_06_04.jpg" alt="Using the Hob utility to configure the OpenEmbedded build"/></div></li></ol></div><p>If something<a id="id222" class="indexterm"/> goes<a id="id223" class="indexterm"/> wrong, the <span class="strong"><strong>Issues</strong></span> tab will not be empty.</p></div><div class="section" title="After the build"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec03"/>After the build</h3></div></div></div><p>You will need to copy the build output from the <span class="strong"><strong>tmp-eglibc</strong></span> folder to your ARM device.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec157"/>How it works…</h2></div></div></div><p>OpenEmbedded is<a id="id224" class="indexterm"/> a stack of cross-compile recipes for various tools that needs a lot of time for compilation. OpenEmbedded will create a root filesystem from scratch. Then it will build the packages that you want to be built. OpenEmbedded provides a bunch of abstraction layers, from the developer to the core layer. These layers include recipes and tools to build an environment and a target project.</p><p>So, after a performed configuration, the tool will build an environment and then some projects in it.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec158"/>There's more...</h2></div></div></div><p>Building OpenEmbedded recipes is not a trivial task. It often needs some problem solving skills. It's not unusual when your build, that literally takes hours to pass, is interrupted with some errors even when you are trying to build a stock Java-test image.</p><p>Though the basics of recipe-building and correcting will be given in the following recipes, we can provide a roadmap to deal with some problems right here, in this section.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Some cases, which were found and overcome by authors, will be found in <a class="link" href="ch08.html" title="Chapter 8. Hacking OpenJDK">Chapter 8</a>, <span class="emphasis"><em>Hacking OpenJDK</em></span>.</p></div></div><div class="section" title="Configure problems – when a header file is not found"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec04"/>Configure problems – when a header file is not found</h3></div></div></div><p>Though the<a id="id225" class="indexterm"/> building process is similar to creating a well-maintained Linux repository from scratch, it's not so simple. It's a task of building the whole thing from source, and some header movement in some minor package maybe a major problem that is fatal to your build, as shown:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">So, it's a dependency problem. At first, try to find out, do you need the package, which header is not found, at all.</li><li class="listitem">If so, find out whether you can disable it through the standard <code class="literal">./configure</code> properties (those which are specified before make).</li><li class="listitem">If you can, you're lucky. Just find a recipe for your package and edit the <code class="literal">.bb</code> or <code class="literal">.inc</code> file. For OpenJDK, it's <code class="literal">openjdk-7-common.inc</code>.</li><li class="listitem">Add (or remove) the desired <code class="literal">./configure</code> property to (or from) <code class="literal">EXTRA_OECONF</code>. Don't forget the screening <code class="literal">\</code>. If you need that dependency or cannot disable it, it's another matter.</li><li class="listitem">First, consider switching to an older/newer version of the <code class="literal">.bb</code> files. It may solve some problems, but can easily add to them as well.</li><li class="listitem">If this is impossible or will not help, try to find a patch to the source and apply it.</li></ol></div></div><div class="section" title="Fetch problems – where your package is not accessible through any mirror available"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec05"/>Fetch problems – where your package is not accessible through any mirror available</h3></div></div></div><p>First, try<a id="id226" class="indexterm"/> to check whether all the mirrors that are used are permanently offline. If not, just wait for a bit while one of those becomes accessible.</p></div><div class="section" title="Compile problems – where a compile error occurs"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec06"/>Compile problems – where a compile error occurs</h3></div></div></div><p>There is <a id="id227" class="indexterm"/>always a solution to this kind of problem, which is searchable through the Internet.</p><p>It may be a wrong dependency version or even a major compilation issue that slipped away from the maintainer's eye. The solution is to patch your build using some known patches or even your own patch, or change the source parameter of the package.</p></div><div class="section" title="Parsing problems – where your recipes cannot be parsed"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec07"/>Parsing problems – where your recipes cannot be parsed</h3></div></div></div><p>It is not a<a id="id228" class="indexterm"/> common problem but it was encountered, for example, in the <code class="literal">openjdk-7</code> branch of the <code class="literal">meta-java</code> repository. Often it doesn't mean that something is completely broken. Check the indicated lines of recipe files for missing \, partial comments, and other minor formatting issues. If the problem still appears, consider changing your current branch.</p></div></div></div>
<div class="section" title="Building IcedTea for ARM with integrated CACAO VM"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Building IcedTea for ARM with integrated CACAO VM</h1></div></div></div><p>This<a id="id229" class="indexterm"/> recipe promises to be quite simple, because the integration of CACAO VM is already a part of IcedTea itself. It will not require any patching or other complicated things.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec159"/>Getting ready</h2></div></div></div><p>We may need a real or emulated ARM device, which has Linux and any Java environment installed. We need Java to perform a <code class="literal">javac</code> compilation, which is a necessary part of the IcedTea building process.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec160"/>How to do it...</h2></div></div></div><p>We will download IcedTea, unpack it, and build it with the specified parameters, that's all.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's get the latest IcedTea source from the server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wget http://icedtea.wildebeest.org/download/source/icedtea-&lt;icedtea_version&gt;.tar.gz</strong></span>
</pre></div><p>It will download an archive.</p></li><li class="listitem">Perform a checksum check if required.</li><li class="listitem">Let's unpack an archive and copy it into the <code class="literal">icedtea</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tar -xzf icedtea-XXXX</strong></span>
<span class="strong"><strong>cd icedtea-XXXX</strong></span>
</pre></div></li><li class="listitem">Then, you might have to install some dependency packages needed to make your IcedTea.</li><li class="listitem">The given packages are those that were missing on the authors' machine during the first build:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install zip gawk xsltproc libjpeg8-dev libgif-dev libpng-dev liblcms2-dev libgtk2-dev cups libcups2-dev libc6-dev libattr1-dev alsa-ocaml-dev</strong></span>
</pre></div></li><li class="listitem">Then, we <a id="id230" class="indexterm"/>will make a link for build configuration to find the Java home directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo ln -s /usr/lib/jvm/java-7-openjdk-armhf/ /usr/lib/jvm/java-1.7.0-openjdk</strong></span>
</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>If you have a distribution-recommended way to change the default Java home directory, please follow it instead.</p></div></div></li><li class="listitem">Then we will enable the CACAO VM in our configuration. Also, we will configure the newly built IcedTea to use the CACAO VM not only as the build configuration, but as a default:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> ./configure --enable-cacao --with-icedtea —with-icedtea-home=&lt;your_openjdk_home&gt;</strong></span>
</pre></div></li><li class="listitem">When running <code class="literal">configure</code>, you probably will encounter errors with messages indicating that some program or library is missing. It's okay, you just need to install them using your package manager.</li><li class="listitem">After doing that, we will build IcedTea using just one simple command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make</strong></span>
</pre></div></li></ol></div><p>It is a long process, even using cross-compilation, so it's best to have a cup of tea or something.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec161"/>How it works…</h2></div></div></div><p>IcedTea is now supporting CACAO VM as a build configuration just out of the box. We will only need to enable this option to configure and add missing dependencies. Normally, IcedTea uses a ZeroVM on ARM, but without Shark JIT compilation. Under the hood, however, it literally applies hundreds of patches and uses an amount of memory that is not acceptable on embedded devices.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec162"/>There's more...</h2></div></div></div><p>Since you may experience some difficulties with building IcedTea on some devices, you may need to use cross-compiling the way we used it before.</p><p>You may need just to set a variable to the local configuration file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> PREFERRED_PROVIDER_virtual/java-native = "cacao-native"</strong></span>
</pre></div></div></div>
<div class="section" title="Porting JamVM to use OpenJDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Porting JamVM to use OpenJDK</h1></div></div></div><p>Another Zero HotSpot alternative for non-JIT supported platforms is <a id="id231" class="indexterm"/>JamVM—an extremely small VM, which is the smallest among those supporting the blue book <a id="id232" class="indexterm"/>specification (one that was published in the book form) for Java VMs.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec163"/>Getting ready</h2></div></div></div><p>We may need a real or emulated ARM device that has Linux and any Java environment installed. We need Java to perform a <code class="literal">javac</code> compilation, which is a necessary part of IcedTea building process.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec164"/>How to do it...</h2></div></div></div><p>Though JamVM patches may be applied manually, we will use the more simple way:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's clone the source from the repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone git://git.berlios.de/jamvm</strong></span>
</pre></div></li><li class="listitem">Then we configure it to use OpenJDK as Java runtime libraries:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./autogen.sh –with-java-runtime-library=openjdk</strong></span>
</pre></div></li><li class="listitem">Then we will actually build it from source using the <code class="literal">make</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make &amp;&amp; make install</strong></span>
</pre></div></li><li class="listitem">Next, we need to copy <code class="literal">libjvm</code> to <code class="literal">lib</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp libjvm.so  /usr/local/jamvm/lib.</strong></span>
</pre></div></li><li class="listitem">Then let's copy the OpenJDK contents:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /usr/lib/jvm</strong></span>
<span class="strong"><strong>cp -r java-7-openjdk jamvm-openjdk</strong></span>
<span class="strong"><strong>cp /usr/local/jamvm/lib/libjvm.so jamvm-openjdk/jre/lib/armv6/server</strong></span>
</pre></div></li><li class="listitem">Then, let's run our compiled Java:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/usr/lib/jvm/jamvm-openjdk/jre/bin/java -version</strong></span>
</pre></div></li><li class="listitem">We will see the output like this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java version "1.7.0_20"</strong></span>
<span class="strong"><strong>OpenJDK Runtime Environment (IcedTea7 1.9.5) (7b20-1.9.5-0ubuntu1)</strong></span>
<span class="strong"><strong>JamVM (build 1.7.0-devel, inline-threaded interpreter)</strong></span>
</pre></div></li></ol></div></div><div class="section" title="There's more"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec165"/>There's more</h2></div></div></div><p>Also, the Jam M support is a part of an OpenEmbedded Java layer. In order to add it, you will remove the ZeroVM support and add a JamVM support. It's a simple task, though you may experience errors during configuration and building.</p><p>Also, you can<a id="id233" class="indexterm"/> run whatever Java program you choose with JamVM, even if your IcedTea build is not configured to use it.</p><p>Just type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java  -jamvm &lt;other parameters and program name&gt;</strong></span>
</pre></div></div></div>
<div class="section" title="Configuring Zero-assembler with the Shark compiler to use OpenJDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Configuring Zero-assembler with the Shark compiler to use OpenJDK</h1></div></div></div><p>Zero-assembler HotSpot port<a id="id234" class="indexterm"/> is the default Java VM for all<a id="id235" class="indexterm"/> newly-built OpenJDK instances on ARM prior to Java 8. It is the default Java VM for quite a few JIT-unsupported platforms. However, there is an effort to bring JIT power to it, named Shark.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec166"/>Getting ready</h2></div></div></div><p>We may need a real or emulated ARM device, which has Linux and any Java environment installed. We need Java to perform a <code class="literal">javac</code> compilation, which is a necessary part of the IcedTea building process.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec167"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's download an IcedTea source.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wget http://icedtea.wildebeest.org/download/source/icedtea-&lt;icedtea_version&gt;.tar.gz</strong></span>
</pre></div><p>It will download an archive.</p></li><li class="listitem">Then, you can check a checksum.</li><li class="listitem">Let's unpack it and copy it into the <code class="literal">icedtea</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tar -xzf icedtea-XXXX</strong></span>
<span class="strong"><strong>cd icedtea-XXXX</strong></span>
</pre></div></li><li class="listitem">Then, you may need to install some dependency packages needed to make your IcedTea.<p>The following packages are those that were missing on my machine during my first build.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install zip gawk xsltproc libjpeg8-dev libgif-dev libpng-dev liblcms2-dev libgtk2-dev cups libcups2-dev libc6-dev libattr1-dev alsa-ocaml-dev</strong></span>
</pre></div></li><li class="listitem">Then, we <a id="id236" class="indexterm"/>will make a link for the build configuration to find the Java home directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo ln -s /usr/lib/jvm/java-7-openjdk-armhf/ /usr/lib/jvm/java-1.7.0-openjdk</strong></span>
</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>If you have a distribution-recommended way to change the default Java home directory, please follow it instead.</p></div></div></li><li class="listitem">Then we will enable Zero-Shark in our configuration. Also, we will configure the newly built IcedTea to use Shark VM not only as the build, but as the default:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> ./configure --enable-zero  --enable-shark --with-icedtea —with-icedtea-home=&lt;your_openjdk_home&gt;</strong></span>
</pre></div><p>When running <code class="literal">configure</code>, you probably will encounter errors with messages indicating that some program or library is missing. It's okay, you just need to install them using your package manager.</p></li><li class="listitem">After doing that, we will build IcedTea using just one simple command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec168"/>How it works…</h2></div></div></div><p>Normally, IcedTea uses a ZeroVM on ARM but without Shark JIT-compilation. All we need to do is to command it to use ZeroVM and Shark JIT compiler.</p><p>Shark<a id="id237" class="indexterm"/> is a project that uses a famous list of LLVM-supported platforms to enable JIT support on all of them, which is quite impressive. It may not be as fast as native JIT but something is better than nothing.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>On ARM, there is a workable OpenJDK that uses JIT-compilation in HotSpot out of the box. However, it's only in the early-access mode and since it's JDK 8, this support will not be ported any prior to it.</p></div></div><p>The LLVM project's goal is to achieve the cross-platform compilation across as many languages and platforms as possible. It uses frontend and backend transforms to provide a flexibility of their tools as shown in the following figure:</p><div class="mediaobject"><img src="graphics/8405OT_06_05.jpg" alt="How it works…"/></div><p>Because of this<a id="id238" class="indexterm"/> structure, LLVM can be used to compile the Java class methods' code to an intermediate language and then to a native code. It leaves the simplest features as reflection and so on to the VM.</p></div><div class="section" title="There's more"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec169"/>There's more</h2></div></div></div><p>Also, you could always cross-compile IcedTea with Zero-Shark support. In order to do so, refer to the last recipe in this chapter.</p></div></div>
<div class="section" title="Building for MIPS and other architectures using OpenEmbedded recipes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Building for MIPS and other architectures using OpenEmbedded recipes</h1></div></div></div><p>When ARM-based <a id="id239" class="indexterm"/>devices are widespread and popular, there are always other architectures. The great power of Java is its cross-platformness, so let's try to have builds for some other architecture.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec170"/>Getting ready</h2></div></div></div><p>You will need an<a id="id240" class="indexterm"/> Internet connection and Linux or Windows with Cygwin installed on your computer. Also, from the author's experience, you will need at least 4GB RAM.</p><p>For a comfortable build, it's recommended to have a powerful hardware and a fast HDD.</p><p>Also, you may experience some lags or even OOM-kills during build, so make sure that all your data is saved.</p><p>Also, you will need an OpenEmbedded project configured, as described in the first recipe of this chapter.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec171"/>How to do it...</h2></div></div></div><p>First, we will see how to add architectures<a id="id241" class="indexterm"/> and software to <a id="id242" class="indexterm"/>OpenEmbedded:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open your browser, and go to <a class="ulink" href="http://layers.openembedded.org/layerindex/branch/master/layers/">http://layers.openembedded.org/layerindex/branch/master/layers/</a>.<p>You will find a list of architectures supported and a list of software that you can install.</p></li><li class="listitem">Do a Git clone of the repositories containing the code that you need (such as <code class="literal">meta-asus</code> or <code class="literal">meta-htc</code>).</li><li class="listitem">Then prepare your build environment and open the Hob GUI as shown:<div class="mediaobject"><img src="graphics/8405_06_06.jpg" alt="How to do it..."/></div></li><li class="listitem">Select the machine from the drop-down list.</li><li class="listitem">Then, you will probably need to set some architecture-specific <code class="literal">./configure</code> options. In order to do that, you will need to change a <code class="literal">bitbake</code> file, adding or correcting the <code class="literal">EXTRA_OECONF </code>variable. Don't forget to add trailing \s.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec172"/>How it works…</h2></div></div></div><p>The main goal <a id="id243" class="indexterm"/>of this project is to create the repository and distribution from scratch, with precompiled images and dependencies. It consists of metadata, called the <code class="literal">.bb</code> files, and many dependencies between them.</p><p>If this project is not running very smoothly, and you may need to make some changes in order to make your way through. A <code class="literal">.bb</code> file is a file of the following structure:</p><div class="informalexample"><pre class="programlisting">#A description of this recipe.
 DESCRIPTION = ""
#A homepage, if any
 HOMEPAGE = ""
#A license
 LICENSE = ""
#Dependecies
 DEPENDS = ""
#URI of the sources
 SRC_URI = " \
 "
 # SRC_URI could also point to a git repository, eg:
 # SRC_URI = "git://host:port/path/to/repo.git;branch=win;protocol=ssh;user=username"
 
 # any .patch files included here will be auto-magically applied, increasing the -p level until it sticks.
 # SRC_URI = "file://some.patch"
 
#package revision. This is a really important thing, you will change it each time when you update the recipe.
 PR = "r0"
 
#checksums for tarball packages
 SRC_URI[md5sum] = ""
 SRC_URI[sha256sum] = ""
 S = "${WORKDIR}/CHANGEME-${PV}"

#Action which will be performed on oe_configure stage
 do_configure () {
   ./configure --prefix=${prefix}
 }

#Action which will be performed on oe_make stage
 do_compile () {
   make
 }


 #Action which will be performed on install stage
do_install () {
   DESTDIR=${D} oe_runmake install
 }</pre></div><p>This is a plain <a id="id244" class="indexterm"/>recipe template and you can add whatever dependency you want through it. Also, you can add patches into the recipe directory or even add sources to it.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec173"/>There's more...</h2></div></div></div><p>You always can build OpenJDK on other architectures using a standard HotSpot Zero port. It is fully interpretable and it can make your programs run very slowly, but it's better than nothing. Just follow the standard procedure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./configure</strong></span>
<span class="strong"><strong>make</strong></span>
</pre></div><p>This approach has its downsides, because most of the architectures aside from Intel and ARM are embedded, so you will not be able to make something fast, or even make it at all. For example, on Raspberry Pi with a newly-built Raspbian and 512 Mb RAM, building IcedTea will randomly crash because of lack of memory, even with large swapfiles.</p></div></div></body></html>