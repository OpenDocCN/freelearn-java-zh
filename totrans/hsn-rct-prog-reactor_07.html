<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Flow Control and Backpressure</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we have discussed how Reactor offers effective controls to check the production rate. This mechanism is often called backpressure. However, there are instances where backpressure is not an efficient strategy. In such cases, Reactor offers a number of flow control optimizations that can be used without backpressure.</p>
<p>In this chapter, we will cover the following topics regarding flow control and backpressure:</p>
<ul>
<li>GroupBy</li>
<li>Buffer</li>
<li>Window</li>
<li>Sample</li>
<li>Backpressure</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>Java Standard Edition, JDK 8 or above</li>
<li><span>IntelliJ IDEA IDE 2018.1 or above</span></li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter07">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter07</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flow control</h1>
                </header>
            
            <article>
                
<p>Flow control is all about managing the rate of events so that a producer <span>does not overwhe</span><span>lm its subscribers when</span> <span>raising a large number of events. A fast producer will push many events to its subscribers. Each of the subscribers will process these events as it receives them, one at a time. This sequential process can be quite inefficient, as each event is delivered over a wire.</span></p>
<p><span>In order to improve the efficiency, there are operators in Reactor that allow the producer to raise events in chunks. Each chunk of events is delivered to the subscriber, allowing them to work on many events simultaneously.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The groupBy operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>groupBy()</kbd> operator converts the <kbd>Flux&lt;T&gt;</kbd> into batches. The operator associates a key with each element of the <kbd>Flux&lt;T&gt;</kbd>. It then groups elements that have the same key. These groups are then emitted by the operator. This is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77b226df-de1b-4a9f-9634-4fcfb7001657.png" style=""/></div>
<p>It is important to note that elements may lose their original sequence order once they are grouped. The order is enforced by the logic of the key generation. Since each element is only associated with one key, the generated groups are not empty. All the generated groups are disjointed by nature. Let's try to generate some groups for our Fibonacci series:</p>
<pre>    @Test<br/>    public  void testGrouping(){<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator.take(20)<br/>                .groupBy(i -&gt; {<br/>                    List&lt;Integer&gt; divisors= Arrays.asList(2,3,5,7);<br/>                    Optional&lt;Integer&gt; divisor = divisors.stream().filter(d -&gt; i % d == 0).findFirst();<br/>                    return divisor.map(x -&gt; "Divisible by "+x).orElse("Others");<br/><br/>                })<br/>                 .concatMap(x -&gt; {<br/>                     System.out.println("\n"+x.key());<br/>                     return x;<br/>                 })<br/>                .subscribe(x -&gt; System.out.print(" "+x));<br/>    }</pre>
<p>In the preceding code, we have carried out the following steps:</p>
<ol>
<li>We partitioned the original dataset into groups of <kbd>Divisible by 2</kbd>, <kbd>Divisible by 3</kbd>, <kbd>Divisible by 5</kbd>, <kbd>Divisible by 7</kbd>, and so on.</li>
<li><kbd>groupBy</kbd> is emitted these partitioned datasets as a key-value pair. The key is a string and the value is <kbd>List&lt;Long&gt;</kbd>.</li>
<li>The datasets were combined using the <kbd>concatMap</kbd> operator. We also printed the key using the operator.</li>
<li>Finally, we printed the <kbd>List</kbd> in the <kbd>Subscribe</kbd> function.</li>
</ol>
<p>Let's run our test case to confirm the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/81d4fbc3-974f-430a-bc7a-f09efef88a45.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The buffer operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>buffer()</kbd> operator gathers all <kbd>Flux&lt;T&gt;</kbd> elements and emits them as a <kbd>List&lt;T&gt;</kbd>. Unlike groups generated by the <kbd>groupBy()</kbd> operator, all the elements in the <kbd>List&lt;T&gt;</kbd> <span>buffer</span><span> </span><span>are in their original order. Alternatively, we could provide a</span> <kbd>batchSize</kbd> <span>to the operator. The operator will then generate</span> <em>N</em><span> lists, each of which will have a specified number of elements. Let's try to use the buffer operator on our Fibonacci series:</span></p>
<pre>    @Test<br/>    public  void testBufferWithDefinateSize(){<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator.take(100)<br/>                .buffer(10)<br/>                .subscribe(x -&gt; System.out.println(x));<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We partitioned the original dataset into buffer lists of 10 elements each</li>
<li>We then printed the list using the <kbd>subscribe</kbd> function</li>
</ol>
<p>Let's run our test case to confirm the output. We can see that the Fibonacci elements are emitted in a single <kbd>List&lt;Long&gt;</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a10c997e-0377-45cf-8c58-7c139903bc8d.png"/></div>
<p>There are many variants of the <kbd>buffer()</kbd> operator. Let's look at a few of them. Each of these generates multiple list buffers.</p>
<p>The <kbd>buffer(maxSize, skipSize)</kbd> operator takes two arguments. The first argument is the max size of each buffer. The second argument is the number of elements that must be skipped before starting a new buffer. The buffer lists generated by the operator have the following characteristics:</p>
<ul>
<li>If the <kbd>maxSize</kbd> is larger than the <kbd>skipSize</kbd>, the buffers are overlapping in nature. The next buffer starts from the element at the position specified by the <kbd>skipSize</kbd> of the previous buffer. This means that elements are duplicated across all buffers.</li>
</ul>
<ul>
<li>If the <kbd>maxSize</kbd> is smaller than the <kbd>skipSize</kbd>, the buffers are disjointed in nature. The generated lists miss elements from the original <kbd>Flux&lt;T&gt;</kbd>.</li>
<li>If the <kbd>skipSize</kbd> is <kbd>0</kbd>, then all lists are disjointed in nature. They do not miss any elements from the original <kbd>Flux&lt;T&gt;</kbd>. Consider the following code:</li>
</ul>
<pre>    @Test<br/>    public  void testBufferSizes(){<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator.take(100)<br/>                .buffer(2,5)<br/>                .subscribe(x -&gt; System.out.println(x));<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We partitioned the original dataset into buffers of two elements each</li>
<li>Each of the buffer lists started at the fifth element, therefore dropping three elements</li>
<li>We printed the list in the <kbd>subscribe</kbd> function</li>
</ol>
<p>Let's run the code to confirm the output. We can see that the Fibonacci elements are emitted in a single <kbd>List&lt;Long&gt;</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0129c0fb-4fde-4600-91ea-b886d147ff03.png"/></div>
<p>The <kbd>bufferUntil</kbd><span><span> </span></span>and <kbd>bufferWhile</kbd> variants take a predicate condition and aggregate elements until the condition is true. The <kbd>bufferWhile</kbd> operator generates a single buffer that contains all elements that match the condition. On the other hand, the <kbd>bufferUntil</kbd>  operator buffers non-matching elements to a list. When it finds a matching element, it adds it to the current buffer. It then starts a new buffer to add the next incoming element. This process is shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0fa957a0-164d-4277-984e-d1536c2fcbf4.png" style=""/></div>
<p>Another overloaded <kbd>buffer()</kbd> method enables us to generate buffer lists based on the time period. The operator accepts a duration and aggregates all elements during that period. It can therefore collect all events that happened during the first <kbd>Duration</kbd>, the second <kbd>Duration</kbd>, and so on, as follows:</p>
<pre>    @Test<br/>    public  void testBufferTimePerid(){<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator<br/>                .buffer(Duration.ofNanos(10))<br/>                .subscribe(x -&gt; System.out.println(x));<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We partitioned the original data based on a 10-nanosecond time slice</li>
<li>Each of the buffer lists contained elements emitted during the time period</li>
<li>Finally, we printed the lists using the <kbd>subscribe</kbd> function</li>
</ol>
<p>Let's run this code to confirm the output. We can see that Fibonacci elements are emitted as multiple <kbd>List&lt;Long&gt;</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f58603a7-ea36-435b-a1b3-4fb4b9c3eb7c.png"/></div>
<p>The <kbd>buffer</kbd> operator offers a number of variants of the <span>methods </span>discussed <span>here</span>. All <kbd>buffer</kbd> methods provide a list, but only one of the overloaded methods allow us to convert a buffer into a collection dataset<span>. We need to provide a supplier function to the overloaded <kbd>buffer</kbd> operator. This function is responsible for creating a collection instance. Let's look at the following code:</span></p>
<pre>    @Test<br/>    public  void testBufferSupplier(){<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator.take(100)<br/>                .buffer(5,HashSet::new)<br/>                .subscribe(x -&gt; System.out.println(x));<br/>    }</pre>
<p>Here, we have done the following:</p>
<ul>
<li>We partitioned the original dataset into buffers of a maximum of five elements</li>
<li>Each of the buffers was emitted as a <kbd>HashSet</kbd>, which means that it contains only distinct elements</li>
<li>Finally, we printed the lists using the <kbd>subscribe</kbd> function</li>
</ul>
<p>Since we used a <kbd>HashSet</kbd>, we can see that it does not contain duplicate elements of the Fibonacci series:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b95bb99a-69b9-4ac9-9fb7-01220a758f3d.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The window operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>window()</kbd> operator is similar to the <kbd>buffer()</kbd> operator. It also slices the original dataset, but emits each dataset as a processor, rather than as a new collection. Each processor serve<span>s</span><span> as a publisher</span> and emits items after subscribing to them<span>. </span>The <kbd>window</kbd> operator<span> allows us to have a fixed window size, a time-based window, or a predicate-based window. Unlike the <kbd>buffer</kbd> operator, which allows us to build a single buffer for all published elements, the <kbd>window</kbd> operator does not allow you to publish elements in a single window.</span></p>
<p>The <kbd>window()</kbd> operator offers better memory utilization, as the items are emitted immediately rather than first <span>being</span><span> </span><span>cached to a collection and then emitted once the correct collection</span> size <span>is achieved. </span>The <kbd>window</kbd> operator also offers better memory usage than the buffer operator. <span>This is depicted with the following code:</span></p>
<pre>    @Test<br/>     public  void testWindowsFixedSize(){<br/>         Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                 Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>             if (state.getT1() &lt; 0)<br/>                 sink.complete();<br/>             else<br/>                 sink.next(state.getT1());<br/>             return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>         });<br/>         fibonacciGenerator<br/>                 .window(10)<br/>                 .concatMap(x -&gt; x)<br/>                 .subscribe(x -&gt; System.out.print(x+" "));<br/>     }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We partitioned the original data into windows with a maximum of 10 elements each</li>
<li>Each window is a type of <kbd>UnicastProcesser</kbd>, so it needed to be combined with the other generated windows using either <kbd>ConcatMap</kbd> or <kbd>flatMap</kbd></li>
<li>Finally, we printed the lists using the subscribe function</li>
</ol>
<p>Let's run this code to confirm the output. We can see that the Fibonacci elements are emitted as multiple batches and then combined as one:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a893f73a-7e23-4e4d-b0f2-3f68924f49e3.png"/></div>
<p>The <kbd>WindowUntil</kbd><span><span> and the </span></span><kbd>WindowWhile</kbd> variants take a predicate condition and build a window batch until the condition is true. The <kbd>WindowWhile</kbd> operator generates a single window containing all the elements that match the condition. The <kbd>WindowUntil</kbd> operator, on the other hand, aggregates non-matching elements to a window. When it finds a matching element, it adds it to the current window. It then starts a new window to add the next incoming element. Consider the following code:</p>
<pre>   @Test<br/>    public  void testWindowsPredicate(){<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        fibonacciGenerator<br/>                .windowWhile(x -&gt; x &lt; 500)<br/>                .concatMap(x -&gt; x)<br/>                .subscribe(x -&gt; System.out.println(x));<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We partitioned the original data based on the condition that <kbd>x &lt; 500</kbd>.</li>
<li>All elements that matched the criteria were published in a single window.</li>
<li>The window elements were emitted as <kbd>WindowFlux</kbd>. They were combined using <kbd>concatMap</kbd> or <kbd>flatMap</kbd>.</li>
<li>Finally, we printed the elements with the subscribe function.</li>
</ol>
<p>Let's run our code to confirm the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d1932e7e-bbd3-4cd0-9094-ffe58371f4d6.png"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The sample operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>groupBy()</kbd>, <kbd>buffer()</kbd>, and <kbd>window()</kbd> operators aggregate inputs and consolidate them into chunks, based on their size, time period, or condition. They are not aimed at skipping events. At times, you may be required to skip events and listen to a particular event during a given time interval. This is often required for fast, non-changing events, such as user clicks. In such a situation, we need to throttle the flow and pick data <span>selectively</span><span>.</span></p>
<p>The <kbd>sample()</kbd> operator allows us to accomplish this throttling. It takes a time period and listens to events published during that time period. It then publishes the last event that happened during the time period. This is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b170198e-5194-4446-84f1-d1bb2c4a3437.png" style=""/></div>
<p>Let's try to add a delay to our Fibonacci series and then throttle it:</p>
<pre>    @Test<br/>    public  void testSample() throws Exception{<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        CountDownLatch latch = new CountDownLatch(1);<br/>        fibonacciGenerator<br/>                .delayElements(Duration.ofMillis(100L))<br/>                .sample(Duration.ofSeconds(1))<br/>                .subscribe(x -&gt; System.out.println(x), e -&gt; latch.countDown() , () -&gt; latch.countDown());<br/>        latch.await();<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We added the <kbd>delayElements()</kbd> operator. This operator is responsible for delaying each event by the supplied time period. In this case, we have delayed each element by 100 milliseconds.</li>
<li>Next, we added the <kbd>sample()</kbd> operator with a time interval of one second.</li>
<li>We then printed the elements using the <kbd>Subscribe</kbd> function.</li>
<li>We also added a <kbd>CountDownLatch</kbd> to wait for the test execution for completion/error events.</li>
</ol>
<p> Let's run the code to confirm the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a043362b-520e-48ef-ab4b-c6b8a1843a5f.png"/></div>
<p>The <kbd>samplefirst()</kbd> operator is similar to the <kbd>sample()</kbd>operator. This operator publishes the first element that was received during the specified time period, rather than selecting the last element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backpressure</h1>
                </header>
            
            <article>
                
<p>Backpressure is an integral part of Reactor. We have discussed it multiple times in previous chapters, but we will have a detailed look at the topic here. Let's recap the <span>out-of-the-box support for </span><span>backpressure that is available with Reactor. Each of the subscribers requests the number of events that it can process using the subscription object. The publisher must respect this limit and publish events that are less than or equal to the requested limit. This is depicted in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/252589c2-c331-4308-8982-084df0f7bb90.png" style=""/></div>
<div class="packt_tip">Invoking a request with <kbd>Long.MAX_VALUE</kbd> means requesting an unbounded number of events. The publisher can push as many events as it can. It is no longer bound by the subscriber limit.</div>
<p>As each subscriber is processing the received events, it can request additional events using the subscription handle. If the publisher is raising events rapidly, it must come up with a strategy to handle the non-requested events. Take a look at the following test code:</p>
<pre>    @Test<br/>    public void testBackPressure() throws  Exception{<br/>        Flux&lt;Integer&gt; numberGenerator = Flux.create(x -&gt; {<br/>            System.out.println("Requested Events :"+x.requestedFromDownstream());<br/>            int number = 1;<br/>            while(number &lt; 100) {<br/>                x.next(number);<br/>                number++;<br/>            }<br/>            x.complete();<br/>        });<br/><br/>        CountDownLatch latch = new CountDownLatch(1);<br/>        numberGenerator.subscribe(new BaseSubscriber&lt;Integer&gt;() {<br/>            @Override<br/>            protected void hookOnSubscribe(Subscription subscription) {<br/>                request(1);<br/>            }<br/><br/>            @Override<br/>            protected void hookOnNext(Integer value) {<br/>                System.out.println(value);<br/>            }<br/><br/>            @Override<br/>            protected void hookOnError(Throwable throwable) {<br/>                throwable.printStackTrace();<br/>                latch.countDown();<br/>            }<br/><br/>            @Override<br/>            protected void hookOnComplete() {<br/>                latch.countDown();<br/>            }<br/>        });<br/>        assertTrue(latch.await(1L, TimeUnit.SECONDS));<br/>    }</pre>
<p>In the preceding code, the following occurred:</p>
<ol>
<li>We created a publisher using the <kbd>Flux.create</kbd> API</li>
<li>The publisher printed the requested number to the console and emitted 100 events</li>
<li>The subscriber requested a single event in the subscribe hook</li>
<li>The subscriber printed the received event to the console</li>
<li>There is a <kbd>CountDownLatch</kbd> to pause the code for 1 second</li>
</ol>
<p>To sum up, the subscriber requested one event, but the publisher emitted 100. Let's run the test to see the result on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae5b1ad5-8591-4955-a36d-7143921a313e.png"/></div>
<p>The preceding test failed to complete successfully. Our subscriber asked for one event and it received only one. The publisher, however, pushed 100 data events followed by the complete event. Reactor did some work behind the scenes to hold the events in a queue. It offers a few overflow strategies to handle events produced by a fast publisher: </p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 27.9502px">
<td class="CDPAlignCenter CDPAlign" style="height: 27.9502px;width: 21.663%"><strong>Strategy</strong></td>
<td class="CDPAlignCenter CDPAlign" style="height: 27.9502px;width: 77.455%"><strong>Description</strong></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignCenter CDPAlign" style="height: 32px;width: 21.663%"><kbd>IGNORE</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px;width: 77.455%">This strategy ignores the limits of the subscriber for backpressure and keeps delivering the next event to the subscriber.</td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignCenter CDPAlign" style="height: 32px;width: 21.663%"><kbd>BUFFER</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px;width: 77.455%"><span>This strategy combines the undelivered events in a buffer. Events from the buffer are delivered when the subscriber requests the next events.</span></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignCenter CDPAlign" style="height: 32px;width: 21.663%"><kbd>DROP</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px;width: 77.455%">This strategy silently drops undelivered events that are produced. The subscriber will only get a newly produced event when the next request is raised.</td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignCenter CDPAlign" style="height: 32px;width: 21.663%"><kbd>LATEST</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px;width: 77.455%"><span>This strategy keeps the latest event raised in the buffer. The subscriber will only get the latest produced event when the next request is raised.</span></td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignCenter CDPAlign" style="height: 32px;width: 21.663%"><kbd>ERROR</kbd></td>
<td class="CDPAlignLeft CDPAlign" style="height: 32px;width: 77.455%">This strategy raises an <kbd>OverFlowException</kbd> if the producer raises more than the events requested by the subscriber.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The API created by default uses the <kbd>Overflow.Buffer</kbd> strategy. We could override this by passing the one we want in the overloaded <kbd>create</kbd> method. Let's test the preceding code with the <kbd>Overflow.Error</kbd> strategy:</p>
<pre>@Test<br/>    public  void testBackPressure() throws  Exception{<br/>        Flux&lt;Integer&gt; numberGenerator = Flux.create(x -&gt; {<br/>            System.out.println("Requested Events :"+x.requestedFromDownstream());<br/>            int number = 1;<br/>            while(number &lt; 100) {<br/>                x.next(number);<br/>                number++;<br/>            }<br/>            x.complete();<br/>        }, OverflowStrategy.ERROR);<br/><br/>      // Removed for Brevity<br/>    }</pre>
<p>The test case now fails with the following error:</p>
<pre>reactor.core.Exceptions$OverflowException: The receiver is overrun by more signals than expected (bounded queue...)<br/>    at reactor.core.Exceptions.failWithOverflow(Exceptions.java:202)<br/>    at reactor.core.publisher.FluxCreate$ErrorAsyncSink.onOverflow(FluxCreate.java:632)<br/>    at reactor.core.publisher.FluxCreate$NoOverflowBaseAsyncSink.next(FluxCreate.java:603)<br/>    at reactor.core.publisher.FluxCreate$SerializedSink.next(FluxCreate.java:151)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OnBackpressure</h1>
                </header>
            
            <article>
                
<p>Reactor also provides operators to alter the overflow strategy configured with the publisher. There are various <kbd>OnBackpressureXXX()</kbd> operators that cater to each of the strategies available with Reactor. These are quite useful in scenarios in which none of the preceding strategies can be applied to the publisher.</p>
<div class="packt_tip">A publisher is sometimes configured with an <kbd>IGNORE</kbd> strategy. In such cases, backpressure is configured using operators while subscribing to the publisher.</div>
<p>Let's work with our test case and apply backpressure operators to it:</p>
<pre>@Test<br/>    public  void testBackPressureOps() throws  Exception{<br/>        Flux&lt;Integer&gt; numberGenerator = Flux.create(x -&gt; {<br/>            System.out.println("Requested Events :"+x.requestedFromDownstream());<br/>            int number = 1;<br/>            while(number &lt; 100) {<br/>                x.next(number);<br/>                number++;<br/>            }<br/>            x.complete();<br/>        });<br/><br/>        CountDownLatch latch = new CountDownLatch(1);<br/>        numberGenerator<br/>                .onBackpressureDrop(x -&gt; System.out.println("Dropped :"+x))<br/>                .subscribe(new BaseSubscriber&lt;Integer&gt;() {<br/>            // Removed for Brevity<br/>        });<br/>        assertTrue(latch.await(1L, TimeUnit.SECONDS));<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We configured <kbd>Flux&lt;Integer&gt;</kbd> with <kbd>OverflowStrategy.BUFFER</kbd>, the default configuration</li>
<li>While subscribing to <kbd>Flux&lt;Integer&gt;</kbd>, we altered the strategy to use <kbd>OverflowStrategy.DROP</kbd></li>
<li>Additionally, we passed a lambda to the operator to print the dropped value</li>
</ol>
<p>Let's run the code and validate the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d1e9929-30cb-47a9-a4ea-2912ce8ddf29.png"/></div>
<p>Additionally, there are the <kbd>onBackpressureLatest()</kbd>, <kbd>onBackpressureError()</kbd>, and <kbd>onBackpressureBuffer()</kbd> operators, which are similar to the <kbd>onBackpressureDrop()</kbd> operator. The <kbd>onBackpressureBuffer()</kbd> operator has a couple of overloaded variants. As a basic configuration, it allows us to specify the buffer size. We could also specify one of the following strategies to handle the overflow beyond the specified buffer:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 25.6773%"><strong> Buffer overflow</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 71.3227%"><strong> Description</strong></td>
</tr>
<tr>
<td style="width: 25.6773%"><kbd>DROP_LATEST</kbd></td>
<td style="width: 71.3227%">All generated events are buffered first and then the new events are dropped. This would keep the oldest events in the buffer.</td>
</tr>
<tr>
<td style="width: 25.6773%"><kbd>DROP_OLDEST</kbd></td>
<td style="width: 71.3227%"><span>All generated events are buffered. Events that are currently in the buffer are then replaced with new events. This would keep the latest events in the buffer.</span></td>
</tr>
<tr>
<td style="width: 25.6773%"><kbd>ERROR</kbd></td>
<td style="width: 71.3227%">This raises an <kbd>OverFlowException</kbd> for events that are beyond the buffer.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's look at how this works with an example. We can also pass a consumer lambda to be invoked for the overflow events:</p>
<pre>    @Test<br/>    public  void testBackPressureOps() throws  Exception{<br/>        Flux&lt;Integer&gt; numberGenerator = Flux.create(x -&gt; {<br/>            System.out.println("Requested Events :"+x.requestedFromDownstream());<br/>            int number = 1;<br/>            while(number &lt; 100) {<br/>                x.next(number);<br/>                number++;<br/>            }<br/>            x.complete();<br/>        });<br/><br/>        CountDownLatch latch = new CountDownLatch(1);<br/>        numberGenerator<br/>                .onBackpressureBuffer(2,x -&gt; System.out.println("Dropped :"+x),BufferOverflowStrategy.DROP_LATEST)<br/>                .subscribe(new BaseSubscriber&lt;Integer&gt;() {<br/>        // Removed for brevity<br/>        });<br/>        assertTrue(latch.await(1L, TimeUnit.SECONDS));<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>We configured <kbd>Flux&lt;Integer&gt;</kbd> with <kbd>OverflowStrategy.BUFFER</kbd>, the default configuration</li>
<li>While subscribing to <kbd>Flux&lt;Integer&gt;</kbd>, we altered the buffer size to two elements</li>
<li>We configured the <kbd>DROP_LATEST</kbd> strategy for events beyond the buffer</li>
<li>We also passed a lambda to the operator to print the dropped value</li>
</ol>
<p>Let's run the code and validate the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e35094bb-b847-4a8e-8c50-4372e6e3d4e8.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed <span>the flow control operators that are available in Reactor </span><span>in detail. We looked at the different overload options that are available in the</span> <kbd>groupBy</kbd><span>,</span> <kbd>buffer</kbd>, and <kbd>window</kbd> operators<span>. We then considered how we can throttle events using the sample operator, which allows only a single event to be delivered in the specified time interval. After that, we recapped the support for backpressure that is available in Reactor and studied the different overflow strategies that it provides. We also learned that Reactor uses the</span> <kbd>Overflow.Buffer</kbd> <span>strategy by default, which </span><span>can be provided as part of the</span> <kbd>Flux.create</kbd> <span>API. Finally, we discussed the backpressure operators that can be used to alter the strategy of the producer</span><span>. To sum up, we discussed the complete list of operators available for flow control and backpressure. In the next chapter we will look at handling and recovering errors.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why do we need the <kbd>groupBy</kbd> operator?</li>
<li>What is the difference between the <kbd>groupBy</kbd> and <kbd>buffer</kbd> operators?</li>
<li>How can we throttle an event in Reactor?</li>
<li>What is the difference between the <kbd>Overflow.Ignore</kbd> and <kbd>OverFlow.Latest</kbd> strategies?</li>
<li>Which operators are available to change the backpressure strategy of a producer?</li>
</ol>


            </article>

            
        </section>
    </body></html>