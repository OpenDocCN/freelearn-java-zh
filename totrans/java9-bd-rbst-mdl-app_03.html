<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Discovering Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java 9 represents a major release and consists of a large number of internal changes to the Java platform. Collectively, these internal changes represent a tremendous set of new possibilities for Java developers, some stemming from developer requests, others from Oracle-inspired enhancements. In this chapter, we will review 26 of the most important changes. Each change is related to a <strong class="calibre8">JDK Enhancement Proposal</strong> (<strong class="calibre8">JEP</strong>). JEPs are indexed and housed at <a href="http://openjdk.java.net/jeps/0" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">openjdk.java.net/jeps/0</a>. You can visit this site for additional information on each JEP.</p>
<div class="packt_infobox">The JEP program is part of Oracle's support for open source, open innovation, and open standards. While other open source Java projects can be found, OpenJDK is the only one supported by Oracle.</div>
<p class="mce-root">In this chapter, we will cover changes to the Java platform. These changes have several impressive implications, including:</p>
<ul class="calibre13">
<li class="calibre14">Heap space efficiencies</li>
<li class="calibre14">Memory allocation</li>
<li class="calibre14">Compilation process improvements</li>
<li class="calibre14">Type testing</li>
<li class="calibre14">Annotations</li>
<li class="calibre14">Automated runtime compiler tests</li>
<li class="calibre14">Improved garbage collection</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Playing around with the Java Shell</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For a long time, there has been no standard shell shipped with the Java programming language to experiment with new language features or libraries or for rapid prototyping. If you wanted to do this, you could write a test application with a main method, compile it with <kbd class="calibre16">javac</kbd>, and run it. This could be done either at the command line or using a Java IDE; however, in both cases, this is not as convenient as having an interactive shell for the purpose.</p>
<p class="mce-root">Starting an interactive shell in JDK 9 is as simple as running the following command (assuming the <kbd class="calibre16">bin</kbd> directory of your JDK 9 installation is in the current path):</p>
<pre class="calibre21"><strong class="calibre3">jshell</strong></pre>
<p class="mce-root">You may find it somewhat puzzling that an interactive shell has not been introduced earlier in the Java platform as many programming languages, such as Python, Ruby, and a number of others, already come with an interactive shell in their earliest versions; However, this had still not made it on the priority features list for the earlier Java releases, until now, and it is out there and ready for use. The Java shell makes use of a JShell API that provides capabilities to enable autocompletion or evaluation of expressions and code snippets, among other features. A full chapter is dedicated to discussing the details of the Java shell so that developers can make the best use out of it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Taking control of external processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Up to JDK 9, if you wanted to create a Java process and handle process input/output, you had to use either the <kbd class="calibre16">Runtime.getRuntime.exec()</kbd> method, which allows us to execute a command in a separate OS process and get a <kbd class="calibre16">java.lang.Process</kbd> instance over which to provide certain operations in order to manage the external process, or use the new <kbd class="calibre16">java.lang.ProcessBuilder</kbd> class with some more enhancements in regard to interacting with the external process and also create a <kbd class="calibre16">java.lang.Process</kbd> instance to represent the external process. Both mechanisms were inflexible and also non-portable as the set of commands executed by the external processes were highly dependent on the operating system (additional effort had to be exerted in order to make the particular process operations portable across multiple operating systems). A chapter is dedicated to the new process API, providing developers with the knowledge of creating and managing external processes in a much easier way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Boosting performance with G1</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The G1 garbage collector was already introduced in JDK 7 and is now enabled by default in JDK 9. It is targeted for systems with multiple processing cores and a lot of available memory. What are the benefits of the G1 compared to previous types of garbage collectors? How does it achieve these improvements? Is there a need to manually tune it, and in what scenarios? These, and several more questions regarding G1, will be discussed in a separate chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Measuring performance with JMH</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">On many occasions, Java applications may suffer from performance degradation. Exacerbating the issue is a lack of performance tests that can provide at least a minimal set of guarantees that performance requirements are met and, moreover, the performance of certain features will not degrade over time. Measuring performance of Java applications is not trivial, especially due to the fact that there is a number of compiler and runtime optimizations that may affect performance statistics. For that reason, additional measures such as warm-up phases and other tricks must be used in order to provide more accurate performance measurements. The Java Microbenchmark Harness is a framework that incorporates a number of techniques along with a convenient API that can be used for this purpose. It is not a new tool, but is included with the distribution of Java 9. If you have not added JMH to your toolbox yet, read the detailed chapter on the usage of JMH in the context of Java 9 application development.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started with HTTP 2.0</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">HTTP 2.0 is the successor of the HTTP 1.1 protocol, and this new version of the protocol addresses some limitations and drawbacks of the previous one. HTTP 2.0 improves performance in several ways and provides capabilities such as request/response multiplexing in a single TCP connection, sending of responses in a server-push, flow control, and request prioritization, among others.</p>
<p class="mce-root">Java provides the <kbd class="calibre16">java.net.HttpURLConnection</kbd> utility that can be used to establish a non-secure HTTP 1.1 connection. However, the API was considered difficult to maintain and further extended with the support for HTTP 2.0 and, so, an entirely new client API was introduced in order to establish a connection via the HTTP 2.0 or the web socket protocols. The new HTTP 2.0 client, along with the capabilities it provides, will be covered in a dedicated chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Encompassing reactive programming</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Reactive programming is a paradigm used to describe a certain pattern for propagation of changes in a system. Reactiveness is not built in Java itself, but reactive data flows can be established using third-party libraries such as RxJava or project Reactor (part of the Spring Framework). JDK 9 also addresses the need for an API that aids the development of highly-responsive applications built around the idea of reactive streams by providing the <kbd class="calibre16">java.util.concurrent.Flow</kbd> class for the purpose. The <kbd class="calibre16">Flow</kbd> class, along with other related changes introduced in JDK 9, will be covered in a separate chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Expanding the wish list</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Apart from all of the new stuff in JDK 9, a whole new set of features is expected in future releases of the platform. Among these are the following:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Generics over primitive types</strong>: This is one of the features planned for JDK 10 as part of project Valhalla. Other language enhancements, such as value handles, are already part of Java 9 and will be introduced later in this book.</li>
<li class="calibre14"><strong class="calibre3">Reified generics</strong>: This is another featured part of project Valhalla that aims to provide the ability to preserve generic types at runtime. The related goals are listed as follows:
<ul class="calibre13">
<li class="calibre14">The foreign functional interface aims to introduce a new API to call and manage native functions. The API addresses some of the drawbacks of JNI and especially a lack of simplicity for use by application developers. The foreign functional interface is developed as part of project Panama in the JDK ecosystem.</li>
<li class="calibre14">New money and currency API <span class="calibre5">(developed under JSR 354) was</span> initially planned for Java 9, but was postponed.</li>
<li class="calibre14">New lightweight JSON API (developed under JSR 353) was also planned for Java 9, but postponed to Java 10.</li>
</ul>
</li>
</ul>
<p class="mce-root">These are just some of the new things one may expect in subsequent releases of the JDK. Project Penrose aims to bridge the gap between the module system in Java and the OSGi module system, and to provide different methodologies for interoperability between the two systems.</p>
<p class="mce-root">The Graal VM is another interesting research project that is a potential candidate for subsequent releases of the Java platform. It aims to bring the runtime performance of Java to dynamic languages such as JavaScript or Ruby.</p>
<p class="mce-root">A chapter dedicated to the future of JDK discusses all of these points in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this brief introductory chapter, we revealed the small universe of capabilities provided by JDK 9. The module system introduced in this release of the platform is indisputably a cornerstone in the development of Java applications. We also discovered that a number of other major features and changes are introduced in JDK 9 that deserve special attention and will be discussed in great detail in subsequent chapters.</p>
<p class="mce-root">In the next chapter, we will take a look at 26 internal changes to the Java platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improved Contended Locking [JEP 143]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The JVM uses Heap space for classes and objects. The JVM allocates memory on the heap whenever we create an object. This helps facilitate Java's garbage collection which releases memory previously used to hold objects that no longer have a reference to it. Java Stack memory is a bit different and is usually much smaller than heap memory.</p>
<p class="mce-root">The JVM does a good job of managing data areas that are shared by multiple threads. It associates a monitor with every object and class; these monitors have locks that are controlled by a single thread at any one time. These locks, controlled by the JVM, are, in essence, giving the controlling thread the object's monitor.</p>
<p class="mce-root">So, what is contended locking? When a thread is in a queue for a currently locked object, it is said to be in contention for that lock. The following diagram shows a high-level view of this contention:</p>
<div class="mce-root1"><img src="Images/0f195fbd-f2f1-4152-8fcd-c5a02b2fe215.png" width="1284" height="798" class="calibre23"/></div>
<p class="mce-root2">As you can see in the preceding illustration, any threads in waiting cannot use a locked object until it is released.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improvement goals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The general goal of JEP 143 was to increase the overall performance of how the JVM manages contention over locked Java object monitors. The improvements to contended locking were all internal to the JVM and do not require any developer actions to benefit from them. The overall improvement goals were related to faster operations. These include:</p>
<ul class="calibre13">
<li class="calibre14">Faster monitor enter</li>
<li class="calibre14">Faster monitor exit</li>
<li class="calibre14">Faster notifications</li>
</ul>
<p class="mce-root">The notifications are the <kbd class="calibre16">notify()</kbd> and <kbd class="calibre16">notifyAll()</kbd> operations that are called when the locked status of an object is changed. Testing this improvement is not something you can easily accomplish. Greater efficiency, at any level, is welcome, so this improvement is one we can be thankful for even without any easily observable testing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Segmented code cache [JEP 197]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The segmented code cache JEP (197) upgrade was completed and results in faster, more efficient execution time. At the core of this change was the segmentation of the code cache into three distinct segments--non-method, profiled, and non-profiled code.</p>
<div class="packt_infobox">A code cache is the area of memory where the Java Virtual Machine stores generated native code.</div>
<p class="mce-root">Each of the aforementioned code cache segments will hold a specific type of compiled code. As you can see in the following diagram, the code heap areas are segmented by type of compiled code:</p>
<div class="mce-root1"><img src="Images/d2b14b35-4bed-4a9e-8b9f-bcb5832112c9.png" width="929" height="491" class="calibre24"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Memory allocation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The code heap containing non-method code is for JVM internal code and consists of a 3 MB fixed memory block. The rest of the code cache memory is equally allocated for the profiled code and non-profiled code segments. You have control of this via command-line commands.<br class="calibre9"/>
The following command can be used to define the code heap size for the non-method compiled code:</p>
<pre class="calibre21"><strong class="calibre3">-XX:NonMethodCodeCodeHeapSize</strong></pre>
<p class="mce-root">The following command can be used to define the code heap size for the profiled compiled methods:</p>
<pre class="calibre21"><strong class="calibre3">-XX:ProfiledCodeHeapSize</strong></pre>
<p class="mce-root">The following command can be used to define the code heap size for the non-profiled compiled methods:</p>
<pre class="calibre21"><strong class="calibre3">-XX:NonProfiledCodeHeapSize</strong></pre>
<p class="mce-root">This Java 9 feature certainly stands to improve Java application efficiency. It also impacts other processes that employ the code cache.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Smart Java compilation, phase two [JEP 199]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The <span class="calibre7">JDK Enhancement Proposal 199 is aimed at improving the code compilation process. All Java developers will be familiar with the</span></span> <strong class="calibre8">javac</strong> tool for compiling source code to bytecode, which is used by the JVM to run Java programs. <strong class="calibre8">Smart Java Compilation</strong>, also referred to as Smart Javac and <strong class="calibre8">sjavac</strong>, adds a <em class="calibre20">smart</em> wrapper around the javac process. Perhaps the core improvement sjavac adds is that only the necessary code is recompiled. Necessary code, in this context, is code that has changed since the last compile cycle.</p>
<p class="mce-root">This enhancement might not get developers excited if they only work on small projects. Consider, however, the tremendous gains in efficiency when you continuously have to recompile your code for medium and large projects. The time developers stand to save is enough reason to embrace JEP 199.</p>
<p class="mce-root">How will this change how you compile your code? It probably will not, at least not yet. Javac will remain the default compiler. While sjavac offers efficiencies regarding incremental builds, Oracle has deemed it to not have sufficient stability to become part of the standard compilation workflow.</p>
<div class="packt_infobox">You can read more information about the smart javac wrapper tool here: <a href="http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Resolving Lint and Doclint warnings [JEP 212]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Do not worry if you are not familiar with Lint or Doclint in Java. As you can determine from the section title, they are sources that report warnings to javac. Let's take a look at each one:</span></p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Lint</strong> analyzes byte code and source code for javac. The goal of Lint is to identify security vulnerabilities in the code being analyzed. Lint can also provide insights into scalability and thread locking concerns. There is more to Lint, and the overall purpose is to save developers time.</li>
</ul>
<div class="packt_infobox"><span class="calibre5">You can read more about Lint here:</span> <a href="https://en.wikipedia.org/wiki/Lint_(software)" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1"><span class="calibre5">https://en.wikipedia.org/wiki/Lint_(software)</span></a><span class="calibre5">.</span></div>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Doclint</strong> is similar to Lint and is specific to javadoc. Both Lint and Doclint report errors and warnings during the compile process. Resolution of these warnings was the focus of JEP 212. When using core libraries, there should not be any warnings. This mindset led to JEP 212, which has been resolved and implemented in Java 9.</li>
</ul>
<div class="packt_infobox">A comprehensive list of the Lint and Doclint warnings can be reviewed in the <a href="https://bugs.openjdk.java.net" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://bugs.openjdk.java.net</a> JDK Bug System.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Tiered attribution for javac [JEP 215]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">JEP 215 represents an impressive undertaking to streamline javac's type checking schema. Let's first review how type checking works in Java 8; then we will explore the changes in Java 9.</span></p>
<p class="mce-root">In Java 8, type checking of poly expressions is handled by a <strong class="calibre8">speculative attribution</strong> tool.</p>
<div class="packt_infobox">Speculative attribution is a method of type checking as part of javac's compilation process. It has a significant processing overhead.</div>
<p class="mce-root">Using the speculative attribution approach to type checking is accurate, but lacks efficiency. These checks include argument position, and are exponentially slower when testing in the midst of recursion, polymorphism, nested loops, and lambda expressions. So the goal with JEP 215 was to change the type checking schema to create faster results. The results themselves were not inaccurate with speculative attribution; they were just not generated rapidly.</p>
<p class="mce-root">The new approach, released with Java 9, uses a tiered attribution tool. This tool implements a tiered approach for type checking argument expressions for all method calls. Permissions are also made for method overriding. In order for this new schema to work, new structural types are created for each of the following listed types of method arguments:</p>
<ul class="calibre13">
<li class="calibre14">Lambda expressions</li>
<li class="calibre14">Poly expressions</li>
<li class="calibre14">Regular method calls</li>
<li class="calibre14">Method references</li>
<li class="calibre14">Diamond instance creation expressions</li>
</ul>
<p class="mce-root">The changes to javac from JEP 215 are more complex than what has been highlighted in this section. There is no immediate impact to developers other than a more efficient javac and time saved.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Annotations pipeline 2.0 [JEP 217]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java annotations refer to a special kind of metadata that resides inside your Java source code files. They are not stripped by javac, so that they can remain available to the JVM at runtime.</span></p>
<p class="mce-root">Annotations look similar to JavaDocs references because they start with the <kbd class="calibre16">@</kbd> symbol. There are three types of annotations. Let's examine each:</p>
<ul class="calibre13">
<li class="calibre14">The most basic form of annotation is a <strong class="calibre3">marker</strong> annotation. These are standalone annotations with the only component being the name of the animation. Here is an example:</li>
</ul>
<pre class="calibre21">        @thisIsAMarkerAnnotation<br class="calibre2"/>        public double computeSometing(double x, double y) <br class="calibre2"/>        {<br class="calibre2"/>          // do something and return a double<br class="calibre2"/>        }</pre>
<ul class="calibre13">
<li class="calibre14">The second type of annotation is one that contains a <em class="calibre22">single value</em>, or piece of data. As you can see in the following code, the annotation, which starts with the <kbd class="calibre16">@</kbd> symbol, is followed by parentheses containing data:</li>
</ul>
<pre class="calibre21">        @thisIsAMarkerAnnotation (data="compute x and y <br class="calibre2"/>         coordinates")<br class="calibre2"/>        public double computeSometing(double x, double y) <br class="calibre2"/>        {<br class="calibre2"/>          // do something and return a double<br class="calibre2"/>        }</pre>
<p class="calibre26">An alternative way of coding the single value annotation type is to omit the <kbd class="calibre16">data=</kbd> component, as illustrated in the following code:</p>
<pre class="calibre21"><span class="calibre5">        @thisIsAMarkerAnnotation ("compute x and y coordinates")</span><br class="calibre2"/><span class="calibre5">        public double computeSometing(double x, double y) </span><br class="calibre2"/><span class="calibre5">        {</span><br class="calibre2"/><span class="calibre5">          // do something and return a double</span><br class="calibre2"/><span class="calibre5">        }</span></pre>
<ul class="calibre13">
<li class="calibre14">The third type of annotation is when there is <em class="calibre22">more than one data component</em>. With this type of annotation, the <kbd class="calibre16">data=</kbd> component cannot be omitted. Here is an example:</li>
</ul>
<pre class="calibre21"><span class="calibre5">        @thisIsAMarkerAnnotation (data="compute x and y <br class="calibre2"/>         coordinates", purpose="determine intersecting point")</span><br class="calibre2"/><span class="calibre5">         public double computeSometing(double x, double y) </span><br class="calibre2"/><span class="calibre5">         {</span><br class="calibre2"/><span class="calibre5">           // do something and return a double</span><br class="calibre2"/><span class="calibre5">         }</span></pre>
<p class="mce-root">So, what has changed in Java 9? To answer this question, we need to recall a couple of changes introduced with Java 8 that impacted Java annotations:</p>
<ul class="calibre13">
<li class="calibre14">Lambda expressions</li>
<li class="calibre14">Repeated annotations</li>
<li class="calibre14">Java type annotations</li>
</ul>
<p class="mce-root">These Java 8 related changes impacted Java annotations, but did not usher in a change to how javac processed them. There were some hardcoded solutions that allowed javac to handle the new annotations, but they were not efficient. Moreover, this type of coding (hardcoding workarounds) is difficult to maintain.</p>
<p class="mce-root">So, JEP 217 focused on refactoring the javac annotation pipeline. This refactoring was all internal to javac, so it should not be evident to developers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New version-string scheme [JEP 223]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Prior to Java 9, the release numbers did not follow industry standard versioning--<strong class="calibre8">semantic versioning</strong>. For example, at the time of writing, the last four JDK releases were:</span></p>
<ul class="calibre13">
<li class="calibre14">JDK 8 update 131</li>
<li class="calibre14">JDK 8 update 121</li>
<li class="calibre14">JDK 8 update 112</li>
</ul>
<div class="packt_infobox"><strong class="calibre3">Semantic versioning</strong> uses a major, minor, patch (0.0.0) schema:<br class="calibre2"/>
<strong class="calibre3">Major</strong> equates to new API changes that are not backwards compatible.<br class="calibre2"/>
<strong class="calibre3">Minor</strong> is when functionality is added that is backwards compatible.<br class="calibre2"/>
<strong class="calibre3">Patch</strong> refers to bug fixes or minor changes that are backwards compatible.</div>
<p class="mce-root">Oracle has embraced semantic versioning for Java 9 and beyond. For Java, a <strong class="calibre8">major-minor-security</strong> schema will be used for the first three elements of Java version numbers:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Major</strong>: A major release consisting of a significant new set of features</li>
<li class="calibre14"><strong class="calibre3">Minor</strong>: Revisions and bug fixes that are backwards compatible</li>
<li class="calibre14"><strong class="calibre3">Security</strong>: Fixes deemed critical to improve security</li>
</ul>
<p class="mce-root">This description of JEP 223 might make the versioning schema seem basic. To the contrary, a very detailed set of rules and practices have been developed to manage the future version numbers. To demonstrate the complexity, see the following example:</p>
<pre class="calibre21">    1.9.0._32.b19</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Generating run-time compiler tests automatically [JEP 233]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java is arguably the most used programming language and resides on an increasingly diverse number of platforms. This exacerbates the problem of running targeted compiler tests in an efficient manner. The purpose of JEP 233 was to create a tool that could automate the runtime compiler tests.</span></p>
<p class="mce-root">The tool that was created starts by generating a random set of Java source code and/or byte code. The generated code will have three key characteristics:</p>
<ul class="calibre13">
<li class="calibre14">Be syntactically correct</li>
<li class="calibre14">Be semantically correct</li>
<li class="calibre14">Use a random seed that permits reusing the same randomly-generated code</li>
</ul>
<p class="mce-root">The source code that is randomly generated will be saved in the following directory:</p>
<pre class="calibre21">    hotspot/test/testlibrary/jit-tester</pre>
<p class="mce-root">These test cases will be stored for later re-use. They can be run from the <kbd class="calibre16">j-treg</kbd> directory or from the tool's makefile. One of the benefits of re-running saved tests is to test the stability of your system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Testing class-file attributes generated by Javac [JEP 235]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The lack of, or insufficient, capability to create tests for class-file attributes was the impetus behind JEP 235. The goal is to ensure javac creates a class-file's attributes completely and correctly. This suggests that even if some attributes are not used by the class-file, all class-files should be generated with a complete set of attributes. There also needs to be a way of testing that the class-files were created correctly, in regards to the file's attributes.</span></p>
<p class="mce-root">Prior to Java 9, there was no method of testing a class-file's attributes. Running a class and testing the code for anticipated or expected results was the most commonly used method of testing javac generated class-files. This technique falls short of testing to validate the file's attributes.</p>
<p class="mce-root">There are three categories of class-file attributes--attributes used by the JVM, optional attributes, and attributes not used by the JVM.</p>
<p class="mce-root">Attributes used by the JVM include:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">BootstrapMethods</kbd></li>
<li class="calibre14"><kbd class="calibre16">Code</kbd></li>
<li class="calibre14"><kbd class="calibre16">ConstantValue</kbd></li>
<li class="calibre14"><kbd class="calibre16">Exceptions</kbd></li>
<li class="calibre14"><kbd class="calibre16">StackMapTable</kbd></li>
</ul>
<p class="mce-root">Optional attributes include:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">Deprecated</kbd></li>
<li class="calibre14"><kbd class="calibre16">LineNumberTable</kbd></li>
<li class="calibre14"><kbd class="calibre16">LocalVariableTable</kbd></li>
<li class="calibre14"><kbd class="calibre16">LocalVariableTypeTable</kbd></li>
<li class="calibre14"><kbd class="calibre16">SourceDebugExtension</kbd></li>
<li class="calibre14"><kbd class="calibre16">SourceFile</kbd></li>
</ul>
<p class="mce-root">Attributes not used by the JVM include:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">AnnotationDefault</kbd></li>
<li class="calibre14"><kbd class="calibre16">EnclosingMethod</kbd></li>
<li class="calibre14"><kbd class="calibre16">InnerClasses</kbd></li>
<li class="calibre14"><kbd class="calibre16">MethodParameters</kbd></li>
<li class="calibre14"><kbd class="calibre16">RuntimeInvisibleAnnotations</kbd></li>
<li class="calibre14"><kbd class="calibre16">RuntimeInvisibleParameterAnnotations</kbd></li>
<li class="calibre14"><kbd class="calibre16">RuntimeInvisibleTypeAnnotations</kbd></li>
<li class="calibre14"><kbd class="calibre16">RuntimeVisibleAnnotations</kbd></li>
<li class="calibre14"><kbd class="calibre16">RuntimeVisibleParameterAnnotations</kbd></li>
<li class="calibre14"><kbd class="calibre16">RuntimeVisibleTypeAnnotations</kbd></li>
<li class="calibre14"><kbd class="calibre16">Signature</kbd></li>
<li class="calibre14"><kbd class="calibre16">Synthetic</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Storing interned strings in CDS archives [JEP 250]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The method in which strings are stored and accessed to and from <strong class="calibre8">Class Data Sharing</strong> (<strong class="calibre8">CDS</strong>) archives is inefficient, excessively time consuming, and wastes memory. The following diagram illustrates the method in which Java stores interned strings in a CDS archive:</span></p>
<div class="mce-root1"><img src="Images/326abe1b-f83d-421b-b919-49ff22f1cb89.png" width="1058" height="289" class="calibre27"/></div>
<p class="mce-root">The inefficiency stems from the current storage schema. Especially when the <strong class="calibre8">Class Data Sharing</strong> tool dumps the classes into the shared archive file, the constant pools containing <kbd class="calibre16">CONSTANT_String</kbd> items have a UTF-8 string representation.</p>
<div class="packt_infobox">UTF-8 is an 8-bit variable-length character encoding standard.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With the current use of UTF-8, the strings must be converted to string objects, instances of the <kbd class="calibre16">java.lang.String</kbd> class. This conversion takes place on-demand which can result in slower systems and unnecessary memory usage. The processing time is extremely short, but the memory usage cannot be overlooked. Every character in an interned string requires at least 3 bytes of memory and potentially more.</p>
<p class="mce-root">A related problem is that the stored strings are not accessible to all JVM processes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The solution</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">CDS archives now allocate specific space on the heap for strings:</p>
<div class="mce-root1"><img src="Images/91cce5a8-f4ef-419d-881f-a809d4f600f2.png" width="1058" height="285" class="calibre28"/></div>
<p class="mce-root">The string space is mapped using a shared-string table, hash tables, and deduplication.</p>
<div class="packt_infobox">Deduplication is a data compression technique that eliminates duplicative information in an archive.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Preparing JavaFX UI controls and CSS APIs for modularization [JEP 253]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">JavaFX is a set of packages that permits the design and development of media-rich graphical user interfaces. JavaFX applications provide developers with a great API for creating a consistent interface for applications. <strong class="calibre8">Cascading Style Sheets</strong> (<strong class="calibre8">CSS</strong>) can be used to customize the interfaces. One of the great things about JavaFX is that the tasks of programming and interface design can easily be separated.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JavaFX overview</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There is a wonderful visual scripting tool called Scene Builder that allows you to create graphical user interfaces by using drag and drop and property settings. Scene Builder generates the necessary FXML files that are used by your <strong class="calibre8">Integrated Development Environment</strong> (<strong class="calibre8">IDE</strong>) such as NetBeans.</p>
<p class="mce-root">Here is a sample UI created with Scene Builder:</p>
<div class="mce-root1"><img src="Images/c0c58de4-e328-41dd-9ea0-821385a82099.png" class="calibre29"/></div>
<p class="mce-root">And, here is the FXML file created by Scene Builder:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;?import java.lang.*?&gt;<br class="calibre2"/>    &lt;?import java.util.*?&gt;<br class="calibre2"/>    &lt;?import javafx.scene.control.*?&gt;<br class="calibre2"/>    &lt;?import javafx.scene.layout.*?&gt;<br class="calibre2"/>    &lt;?import javafx.scene.paint.*?&gt;<br class="calibre2"/>    &lt;?import javafx.scene.text.*?&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;AnchorPane id="AnchorPane" maxHeight="-Infinity"<br class="calibre2"/>     maxWidth="-Infinity" minHeight="-Infinity"<br class="calibre2"/>     minWidth="-Infinity" prefHeight="400.0" prefWidth="600.0"<br class="calibre2"/>      <br class="calibre2"/>     &gt;<br class="calibre2"/>     &lt;children&gt;<br class="calibre2"/>       &lt;TitledPane animated="false" collapsible="false"<br class="calibre2"/>        layoutX="108.0" layoutY="49.0" text="Sample"&gt;<br class="calibre2"/>       &lt;content&gt;<br class="calibre2"/>         &lt;AnchorPane id="Content" minHeight="0.0" minWidth="0.0"<br class="calibre2"/>          prefHeight="180.0" prefWidth="200.0"&gt;<br class="calibre2"/>         &lt;children&gt;<br class="calibre2"/>           &lt;CheckBox layoutX="26.0" layoutY="33.0" <br class="calibre2"/>            mnemonicParsing="false" prefWidth="94.0" <br class="calibre2"/>            text="CheckBox" /&gt;<br class="calibre2"/>           &lt;ColorPicker layoutX="26.0" layoutY="65.0" /&gt;<br class="calibre2"/>           &lt;Hyperlink layoutX="26.0" layoutY="103.0"<br class="calibre2"/>            text="Hyperlink" /&gt;<br class="calibre2"/>           &lt;Label alignment="CENTER" layoutX="14.0" layoutY="5.0" <br class="calibre2"/>            prefWidth="172.0" text="This is a Label"<br class="calibre2"/>            textAlignment="CENTER"&gt;<br class="calibre2"/>            &lt;font&gt;<br class="calibre2"/>              &lt;Font size="14.0" /&gt;<br class="calibre2"/>            &lt;/font&gt;<br class="calibre2"/>           &lt;/Label&gt;<br class="calibre2"/>           &lt;Button layoutX="81.0" layoutY="146.0" <br class="calibre2"/>            mnemonicParsing="false" text="Button" /&gt;<br class="calibre2"/>         &lt;/children&gt;<br class="calibre2"/>         &lt;/AnchorPane&gt;<br class="calibre2"/>       &lt;/content&gt;<br class="calibre2"/>       &lt;/TitledPane&gt;<br class="calibre2"/>     &lt;/children&gt;<br class="calibre2"/>    &lt;/AnchorPane&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implications for Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 9, JavaFX controls as well as CSS functionality were only available to developers by interfacing with internal APIs. Java 9's modularization has made the internal APIs inaccessible. Therefore, JEP 253 was created to define public, instead of internal, APIs.</p>
<p class="mce-root">This was a larger undertaking than it might seem. Here are a few actions that were taken as part of this JEP:</p>
<ul class="calibre13">
<li class="calibre14">Moving javaFX control skins from the internal to public API (<kbd class="calibre16">javafx.scene.skin</kbd>)</li>
<li class="calibre14">Ensuring API consistencies</li>
<li class="calibre14">Generation of a thorough javadoc</li>
</ul>
<p class="mce-root">The following classes were moved from internal packages to a public <kbd class="calibre16">javafx.scene.control.skin</kbd> package:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">AccordionSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ButtonBarSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ButtonSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">CellSkinBase</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">CheckBoxSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ChoiceBoxSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ColorPickerSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ComboBoxBaseSkin</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">ComboBoxListViewSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ComboBoxPopupControl</kbd></td>
<td class="calibre33"><kbd class="calibre16">ContextMenuSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">DateCellSkin</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">DatePickerSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">HyperLinkSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">LabelSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">LabeledSkinBase</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">ListCellSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ListViewSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">MenuBarSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">MenuButtonSkin</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">MenuButtonSkinbase</kbd></td>
<td class="calibre33"><kbd class="calibre16">NestedTableColumHeader</kbd></td>
<td class="calibre33"><kbd class="calibre16">PaginationSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ProgressBarSkin</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">ProgressIndicatorSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">RadioButtonSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ScrollBarSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ScrollPaneSkin</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">SeparatorSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">SliderSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">SpinnerSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">SplitMenuButtonSkin</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">SplitPaneSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TabPaneSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TableCellSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TableCellSkinBase</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">TableColumnHeader</kbd></td>
<td class="calibre33"><kbd class="calibre16">TableHeaderRow</kbd></td>
<td class="calibre33"><kbd class="calibre16">TableHeaderSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TableRowSkinBase</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">TableViewSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TableViewSkinBase</kbd></td>
<td class="calibre33"><kbd class="calibre16">TextAreaSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TextFieldSkin</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">TextInputControlSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TitledPaneSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">ToggleButtonSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TooBarSkin</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">TooltipSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TreeCellSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TreeTableCellSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TreeTableRowSkin</kbd></td>
</tr>
<tr class="calibre35">
<td class="calibre33"><kbd class="calibre16">TreeTableViewSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">TreeViewSkin</kbd></td>
<td class="calibre33"><kbd class="calibre16">VirtualContainerBase</kbd></td>
<td class="calibre33"><kbd class="calibre16">VirtualFlow</kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root">The public <kbd class="calibre16">javafx.css</kbd> package now has the additional classes:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">CascadingStyle.java:public class CascadingStyle implements Comparable&lt;CascadingStyle&gt;</kbd></li>
<li class="calibre14"><kbd class="calibre16">CompoundSelector.java:final public class CompoundSelector extends Selector</kbd></li>
<li class="calibre14"><kbd class="calibre16">CssError.java:public class CssError</kbd></li>
<li class="calibre14"><kbd class="calibre16">Declaration.java:final public class Declaration</kbd></li>
<li class="calibre14"><kbd class="calibre16">Rule.java:final public class Rule</kbd></li>
<li class="calibre14"><kbd class="calibre16">Selector.java:abstract public class Selector</kbd></li>
<li class="calibre14"><kbd class="calibre16">SimpleSelector.java:final public class SimpleSelector extends Selector</kbd></li>
<li class="calibre14"><kbd class="calibre16">Size.java:final public class Size</kbd></li>
<li class="calibre14"><kbd class="calibre16">Style.java:final public class Style</kbd></li>
<li class="calibre14"><kbd class="calibre16">Stylesheet.java:public class Stylesheet</kbd></li>
<li class="calibre14"><kbd class="calibre16">CssParser.java:final public class CssParser</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Compact strings [JEP 254]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The string data type is an important part of nearly every Java app. While JEP 254's aim was to make strings more space-efficient, it was approached with caution so that existing performance and compatibilities would not be negatively impacted.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Pre-Java 9 status</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 9, string data was stored as an array of chars. This required 16 bits for each char. It was determined that the majority of String objects could be stored with only 8 bits, or 1 byte of storage. This is due to the fact that most strings consist of Latin-1 characters.</p>
<div class="packt_infobox">The ISO Latin-1 Character Set is a single-byte set of character's encodings.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New with Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Starting with Java 9, strings are now internally represented using a byte array along with a flag field for encoding references.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Merging selected Xerces 2.11.0 updates into JAXP [JEP 255]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Xerces is a library used for parsing XML in Java. It was updated to 2.11.0 in late 2010, so JEP 255's aim was to update JAXP to incorporate changes in Xerces 2.11.0.</span></p>
<div class="packt_infobox">JAXP is Java's API for XML processing.</div>
<p class="mce-root">Prior to Java 9, the JDK's latest update regarding XML processing was based on Xerces 2.7.1. There were some additional changes to JDK 7 based on Xerces, 2.10.0. JEP 255 is a further refinement of the JAXP based on Xerces 2.11.0.</p>
<p class="mce-root">Xerces 2.11.0 supports the following standards:</p>
<ul class="calibre13">
<li class="calibre14">XML 1.0, Fourth Edition</li>
<li class="calibre14">Namespaces in XML 1.0, Second Edition</li>
<li class="calibre14">XML 1.1, Second Edition</li>
<li class="calibre14">Namespaces in XML 1.1, Second Edition</li>
<li class="calibre14">XML Inclusions 1.0, Second Edition</li>
<li class="calibre14"><strong class="calibre3">Document Object Model</strong> (<strong class="calibre3">DOM</strong>)
<ul class="calibre13">
<li class="calibre14">Level 3
<ul class="calibre13">
<li class="calibre14">Core</li>
<li class="calibre14">Load &amp; save</li>
</ul>
</li>
<li class="calibre14">Level 2
<ul class="calibre13">
<li class="calibre14">Core</li>
<li class="calibre14">Events</li>
</ul>
</li>
</ul>
</li>
<li class="calibre14">Traversal &amp; Range</li>
<li class="calibre14">Element Traversal, First Edition</li>
<li class="calibre14">Simple API for XML 2.0.2</li>
<li class="calibre14"><strong class="calibre3">Java APIs for XML Processing</strong> (<strong class="calibre3">JAXP</strong>) 1.4</li>
<li class="calibre14">Streaming API for XML 1.0</li>
<li class="calibre14">XML Schema 1.0</li>
<li class="calibre14">XML Schema 1.1</li>
<li class="calibre14">XML Schema Definition Language</li>
</ul>
<p class="mce-root">The JDK was updated to include the following Xerces 2.11.0 categories:</p>
<ul class="calibre13">
<li class="calibre14">Catalog resolver</li>
<li class="calibre14">Datatypes</li>
<li class="calibre14">Document Object Model Level 3</li>
<li class="calibre14">XML Schema Validation</li>
<li class="calibre14">XPointer</li>
</ul>
<p class="mce-root">The public API for JAXP was not changed in Java 9.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Updating JavaFX/Media to newer version of GStreamer [JEP 257]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">JavaFX is used for creating desktop and web applications. JavaFX was created to replace Swing as Java's standard GUI library. The <kbd class="calibre16">Media</kbd> class, <kbd class="calibre16">javafx.scene.media.Media</kbd>, is used to instantiate an object representing a media resource. JavaFX/Media refers to the following class:</span></p>
<pre class="calibre21">    public final class Media extends java.lang.Object</pre>
<p class="mce-root">This class provides referential data to a media resource. The <kbd class="calibre16">javafx.scene.media</kbd> package provides developers with the ability to incorporate media into their JavaFX applications. JavaFX/Media utilizes a GStreamer pipeline.</p>
<div class="packt_infobox">GStreamer is a multimedia processing framework that can be used to build systems that take in media from several different formats and, after processing, export them in selected formats.</div>
<p class="mce-root">The purpose of JEP 257 was to ensure JavaFX/Media was updated to include the latest release of GStreamer for stability, performance, and security assurances.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">HarfBuzz Font-Layout Engine [JEP 258]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Prior to Java 9, the layout engine used to handle font complexities; specifically fonts that have rendering behaviors beyond what the common Latin fonts have. Java used the uniform client interface, also referred to as ICU, as the defacto text rendering tool. The ICU layout engine has been depreciated and, in Java 9, has been replaced with the HarfBuzz font layout engine.</span></p>
<p class="mce-root">HarfBuzz is an <strong class="calibre8">OpenType</strong> text rendering engine. This type of layout engine has the characteristic of providing script-aware code to help ensure text is laid out as desired.</p>
<div class="packt_infobox">OpenType is an HTML formatted font format specification.</div>
<p class="mce-root">The impetus for the change from the ICU Layout Engine to the HarfBuzz Font Layout Engine was IBM's decision to cease supporting the ICU Layout Engine. Therefore, the JDK was updated to contain the HarfBuzz Font Layout Engine.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">HiDPI graphics on Windows and Linux [JEP 263]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">JEP 263 was focused on ensuring the crispness of on-screen components, relative to the pixel density of the display. The following terms are relevant to this JEP and are provided along with the below listed descriptive information:</span></p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">DPI-aware application</strong>: An application that is able to detect and scale images for the display's specific pixel density</li>
<li class="calibre14"><strong class="calibre3">DPI-unaware application</strong>: An application that makes no attempt to detect and scale images for the display's specific pixel density</li>
<li class="calibre14"><strong class="calibre3">HiDPI graphics</strong>: High dots-per-inch graphics</li>
<li class="calibre14"><strong class="calibre3">Retina display</strong>: This term was created by Apple to refer to displays with a pixel density of at least 300 pixels per inch</li>
</ul>
<p class="mce-root">Displaying graphics, both images and graphical user interface components, to the user is typically of paramount performance. Displaying this imagery in high quality can be somewhat problematic. There is large variability in computer monitor DPIs. There are three basic approaches to developing for displays:</p>
<ul class="calibre13">
<li class="calibre14">Develop apps without regard for the potential different display dimensions. In other words, create a DPI-unaware application.</li>
<li class="calibre14">Develop a DPI-aware application that selectively uses pre-rendered image sizes for a given display.</li>
<li class="calibre14">Develop a DPI-aware application that properly scales images up/down to account for the specific display the application is run on.</li>
</ul>
<p class="mce-root">Clearly, the first two approaches are problematic, and for different reasons. With the first approach, the user experience is not considered. Of course, if the application was being developed for a very specific display with no expected pixel density variability, then this approach could be viable.</p>
<p class="mce-root">The second approach requires a lot of work on the design and development end to ensure images for each expected display density are created and implemented programmatically. In addition to the tremendous amount of work, the app size will unnecessarily increase, and new and different pixel densities will not have been accounted for.</p>
<p class="mce-root">The third approach is to create a DPI-aware application with efficient and effective scaling capabilities. This approach works well and has been proven with the Mac retina displays.</p>
<p class="mce-root">Prior to Java 9, automatic scaling and sizing was already implemented in Java for the Mac OS X operating system. This capability was added in Java 9 for Windows and Linux operating systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Marlin graphics renderer [JEP 265]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">JEP 265 replaced the Pisces graphics rasterizer with the Marlin graphics renderer in the Java 2D API. This API is used to draw 2D graphics and animations.</span></p>
<p class="mce-root">The goal was to replace Pisces with a rasterizer/renderer that was much more efficient and without any quality loss. This goal was realized in Java 9. An intended collateral benefit was to include a developer-accessible API. Previously, the means of interfacing with the AWT and Java 2D was internal.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Unicode 8.0.0 [JEP 267]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Unicode 8.0.0 was released on June 17, 2015. JEP 267 focused on updating the relevant APIs to support Unicode 8.0.0.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New in Unicode 8.0.0</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Unicode 8.0.0 added nearly 8,000 characters. Here are the highlights of the release:</p>
<ul class="calibre13">
<li class="calibre14">Ahom script for the Tai Ahom language (India)</li>
<li class="calibre14">Arwi, Tamil language (Arabic)</li>
<li class="calibre14">Cherokee symbols</li>
<li class="calibre14">CJK unified ideographs</li>
<li class="calibre14">Emoji symbols along with flesh-tone symbol modifiers</li>
<li class="calibre14">Georgian lari currency symbol</li>
<li class="calibre14">lk language (Uganda)</li>
<li class="calibre14">Kulango languge (<span class="calibre5">CÃ´te dâIvoire</span>)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Updated Classes in Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In order to fully comply with the new Unicode standard, several Java classes were updated. The following listed classes were updated for Java 9 to comply with the new Unicode standard:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">java.awt.font.NumericShaper</kbd></li>
<li class="calibre14"><kbd class="calibre16">java.lang.Character</kbd></li>
<li class="calibre14"><kbd class="calibre16">java.lang.String</kbd></li>
<li class="calibre14"><kbd class="calibre16">java.text.Bidi</kbd></li>
<li class="calibre14"><kbd class="calibre16">java.text.BreakIterator</kbd></li>
<li class="calibre14"><kbd class="calibre16">java.text.Normalizer</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reserved stack areas for critical sections [JEP 270]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The goal of JEP 270 was to mitigate problems stemming from stack overflows during the execution of critical sections. This mitigation took the form of reserving additional thread stack space.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The pre-Java 9 situation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The JVM throws a <kbd class="calibre16">StackOverflowError</kbd> when it is asked to perform data computation in a thread that has insufficient stack space and does not have permission to allocate additional space. This is an asynchronous exception. The JVM can also throw the <kbd class="calibre16">StackOverflowError</kbd> exception synchronously when a method is invoked.</p>
<p class="mce-root">When a method is invoked, an internal process is used to report the Stack Overflow. While the current schema works sufficiently for reporting the error, there is no room for the calling application to easily recover from the error. This can result in being more than a nuisance for developers and users. If the <kbd class="calibre16">StackOverflowError</kbd> was thrown during a critical computational operation, the data might be corrupted, causing additional problems.</p>
<p class="mce-root">While not the sole cause of these problems, the effected status of locks from the <kbd class="calibre16">ReentrantLock</kbd> class were a common cause of undesirable outcomes. This issue was evident in Java 7 because the <kbd class="calibre16">ConcurrentHasMap</kbd> code implemented the <kbd class="calibre16">ReentrantLock</kbd> class. The <kbd class="calibre16">ConcurrentHasMap</kbd> code was modified for Java 8, but problems still persisted for any implementation of the <kbd class="calibre16">ReentrantLock</kbd> class. Similar problems existed beyond just <kbd class="calibre16">ReentrantLock</kbd> class usage.</p>
<p class="mce-root">The following diagram provides a broad overview of the <kbd class="calibre16">StackOverflowError</kbd> problem:</p>
<div class="mce-root1"><img src="Images/49c4c434-1548-47f8-84e9-c74bce5c3901.png" width="865" height="307" class="calibre36"/></div>
<p class="mce-root">In the next section, we will look at how this issue was resolved for Java 9.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New in Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With the JEP 270 changes for Java 9, a critical section will automatically be given additional space so that it can complete its execution and not suffer from the <kbd class="calibre16">StackOverflowError</kbd>. This is predicated on the additional space allocation needs being small. The necessary changes have been made to the JVM to permit this functionality.</p>
<p class="mce-root">The JVM actually delays the <kbd class="calibre16">StackOverflowError</kbd>, or at least attempts to, while critical sections are executing. In order to capitalize on this new schema, methods must be annotated with the following:</p>
<pre class="calibre21">    jdk.internal.vm.annotation.ReservedStackAccess</pre>
<p class="mce-root">When a method has this annotation and a <kbd class="calibre16">StackOverflowError</kbd> condition exists, temporary access to the reserved memory space is granted. The new process is, at a high level of abstraction, presented as follows:</p>
<div class="mce-root1"><img src="Images/f576b05c-8b60-454e-bb51-3972d50dd8d9.png" width="891" height="488" class="calibre37"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dynamic linking of language-defined object models [JEP 276]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java interoperability was enhanced with JEP 276. The necessary JDK changes were made to permit runtime linkers from multiple languages to coexist in a single JVM instance. This change applies to high-level operations, as you would expect. An example of a relevant high-level operation is the reading or writing of a property with elements such as accessors and mutators.</span></p>
<p class="mce-root">The high-level operations apply to objects of unknown types. They can be invoked with <kbd class="calibre16">INVOKEDYNAMIC</kbd> instructions. Here is an example of calling an object's property when the object's type is unknown at compile time:</p>
<pre class="calibre21">    INVOKEDYNAMIC "dyn:getProp:age"</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Proof of concept</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Nashorn is a lightweight, high-performance, JavaScript runtime that permits embedding JavaScript in Java applications. This was created for Java 8 and replaced the previous JavaScript scripting engine that was based on Mozilla Rhino. Nashorn already has this functionality. It provides linkage between high-level operations on any object of unknown type, such as <kbd class="calibre16">obj.something</kbd>, where it produces the following:</p>
<pre class="calibre21">    INVOKEDYNAMIC "dyn.getProp.something"</pre>
<p class="mce-root">The dynamic linker springs into action and provides, when possible, the appropriate implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Additional tests for humongous objects in G1 [JEP 278]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">One of the long-favored features of the Java platform is the behind the scenes garbage collection. JEP 278's focus was to create additional WhiteBox tests for humongous objects as a feature of the G1 garbage collector.</span></p>
<div class="packt_infobox">WhiteBox testing is an API used to query JVM internals. The WhiteBox testing API was introduced in Java 7 and upgraded in Java 8 and Java 9.</div>
<p class="mce-root">The G1 garbage collector works extremely well, but there was room for some improved efficiency. The way the G1 garbage collector worked is based on first dividing the heap into regions of equal size, illustrated as follows:</p>
<div class="mce-root1"><img src="Images/1e81f892-f803-458c-ae5b-7f080daa6710.png" width="547" height="544" class="calibre38"/></div>
<p class="mce-root">The problem with the G1 garbage collector was how humongous objects were handled.</p>
<div class="packt_infobox">A humongous object in the context of garbage collection, is any object that takes up more than one region on the heap.</div>
<p class="mce-root">The problem with humongous objects was that if they took up any part of a region on the heap, the remaining space was not able to be allocated for other objects. In Java 9, the WhiteBox API was extended with four types of new methods:</p>
<ul class="calibre13">
<li class="calibre14">Methods with the purpose of blocking full garbage collection and to initiate concurrent marking.</li>
<li class="calibre14">Methods that can access individual G1 garbage collection heap regions. Access to these regions consist of attribute reading, such as with the current state of the region.</li>
<li class="calibre14">Methods with direct access to the G1 garbage collection internal variables.</li>
<li class="calibre14">Methods that can determine if humongous objects reside on the heap and, if so, in what regions.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improving test-failure troubleshooting [JEP 279]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">For developers that do a lot of testing, JEP 279 is worth reading about. Additional functionality has been added in Java 9 to automatically collect information to support troubleshooting test failures as well as timeouts. Collecting readily available diagnostic information during tests stands to provide developers and engineers with greater fidelity in their logs and other output.</span></p>
<p class="mce-root">There are two basic types of information in the context of testing--environmental and process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Environmental information</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When running tests, the testing environment information can be important for troubleshooting efforts. This information includes the following:</p>
<ul class="calibre13">
<li class="calibre14">CPU loads</li>
<li class="calibre14">Disk space</li>
<li class="calibre14">I/O loads</li>
<li class="calibre14">Memory space</li>
<li class="calibre14">Open files</li>
<li class="calibre14">Open sockets</li>
<li class="calibre14">Processes running</li>
<li class="calibre14">System events</li>
<li class="calibre14">System messages</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java process information</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There is also information available during the testing process directly related to Java processes. These include:</p>
<ul class="calibre13">
<li class="calibre14">C stacks</li>
<li class="calibre14">Core dumps</li>
<li class="calibre14">Mini dumps</li>
<li class="calibre14">Heap statistics</li>
<li class="calibre14">Java stacks</li>
</ul>
<div class="packt_tip">For additional information on this concept, read about the JDK's regression test harness (jtreg).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Optimizing string concatenation [JEP 280]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">JEP 280 is an interesting enhancement for the Java platform. Prior to Java 9, string concatenation was translated by javac into</span> <kbd class="calibre16">StringBuilder : : append</kbd> <span class="calibre7">chains. This was a sub-optimal translation methodology often requiring <kbd class="calibre16">StringBuilder</kbd> presizing.</span></p>
<p class="mce-root">The enhancement changed the string concatenation bytecode sequence, generated by javac, so that it uses <kbd class="calibre16">INVOKEDYNAMIC</kbd> calls. The purpose of the enhancement was to increase optimization and to support future optimizations without the need to reformat the javac's bytecode.</p>
<div class="packt_tip">See JEP 276 for more information on <kbd class="calibre39">INVOKEDYNAMIC</kbd>.</div>
<p class="mce-root">The use of <kbd class="calibre16">INVOKEDYAMIC</kbd> calls to <kbd class="calibre16">java.lang.invoke.StringConcatFactory</kbd> allows us to use a methodology similar to lambda expressions instead of using StringBuilder's step-wise process. This results in more efficient processing of string concatenation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">HotSpot C++ unit-test framework [JEP 281]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">HotSpot is the name of the JVM. This Java enhancement was intended to support the development of C++ unit tests for the JVM. Here is a partial, non-prioritized, list of goals for this enhancement:</span></p>
<ul class="calibre13">
<li class="calibre14">Command-line testing</li>
<li class="calibre14">Create appropriate documentation</li>
<li class="calibre14">Debug compile targets</li>
<li class="calibre14">Framework elasticity</li>
<li class="calibre14">IDE support</li>
<li class="calibre14">Individual and isolated unit testing</li>
<li class="calibre14">Individualized test results</li>
<li class="calibre14">Integrate with existing infrastructure</li>
<li class="calibre14">Internal test support</li>
<li class="calibre14">Positive and negative testing</li>
<li class="calibre14">Short execution time testing</li>
<li class="calibre14">Support all JDK 9 build platforms</li>
<li class="calibre14">Test compile targets</li>
<li class="calibre14">Test exclusion</li>
<li class="calibre14">Test grouping</li>
<li class="calibre14">Testing that requires the JVM to be initialized</li>
<li class="calibre14">Tests co-located with source code</li>
<li class="calibre14">Tests for platform-dependent code</li>
<li class="calibre14">Write and execute unit testing (for classes and methods)</li>
</ul>
<p class="mce-root">This enhancement is evidence of the increasing extensibility.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enabling GTK 3 on Linux [JEP 283]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">GTK+, formally known as the GIMP toolbox, is a cross-platform tool used for creating <strong class="calibre8">Graphical User Interfaces</strong> (<strong class="calibre8">GUI</strong>). The tool consists of widgets accessible through its API. JEP 283's focus was to ensure GTK 2 and GTK 3 were supported on Linux when developing Java applications with graphical components. The implementation supports Java apps that employ JavaFX, AWT, and Swing.</span></p>
<p class="mce-root">We can create Java graphical applications with JavaFX, AWT, and Swing. Here is a table to summarize those three approaches as they relate to GTK, prior to Java 9:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Approach</strong></td>
<td class="calibre33"><strong class="calibre3">Remarks</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">JavaFX</td>
<td class="calibre33">
<ul class="calibre13">
<li class="calibre14">Uses a dynamic GTK function lookup</li>
<li class="calibre14">Interacts with AWT and Swing via JFXPanel</li>
<li class="calibre14">Uses AWT printing functionality</li>
</ul>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">AWT</td>
<td class="calibre33">
<ul class="calibre13">
<li class="calibre14">Uses a dynamic GTK function lookup</li>
</ul>
</td>
</tr>
<tr class="calibre35">
<td class="calibre33">Swing</td>
<td class="calibre33">
<ul class="calibre13">
<li class="calibre14">Uses a dynamic GTK function lookup</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root">So, what changes were necessary to implement this JEP? For JavaFX, three specific things were changed:</p>
<ul class="calibre13">
<li class="calibre14">Automated testing was added for both GTK 2 and GTK 3</li>
<li class="calibre14">Functionality was added to dynamically load GTK 2</li>
<li class="calibre14">Support was added for GTK 3</li>
</ul>
<p class="mce-root">For AWT and Swing, the following changes were implemented:</p>
<ul class="calibre13">
<li class="calibre14">Automated testing was added for both GTK 2 and GTK 3</li>
<li class="calibre14"><kbd class="calibre16">AwtRobot</kbd> was migrated to GTK 3</li>
<li class="calibre14"><kbd class="calibre16">FileChooserDilaog</kbd> was updated for GTK 3</li>
<li class="calibre14">Functionality was added to dynamically load GTK 3</li>
<li class="calibre14">The Swing GTK LnF was modified to support GTK 3</li>
</ul>
<div class="packt_infobox">Swing GTK LnF is short for Swing GTK look and feel.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New HotSpot build system [JEP 284]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The Java platform used, prior to Java 9, was a build system riddled with duplicate code, redundancies, and other inefficiencies. The build system has been reworked for Java 9 based on the build-infra framework. In this context, infra is short for infrastructure. The overarching goal for JEP 284 was to upgrade the build system to one that was simplified. Specific goals included:</span></p>
<div class="calibre40">
<ul class="calibre13">
<li class="calibre14">Leverage existing build system</li>
<li class="calibre14">Maintainable code</li>
<li class="calibre14">Minimize duplicate code</li>
<li class="calibre14">Simplification</li>
<li class="calibre14">Support future enhancements</li>
</ul>
</div>
<p class="mce-root">You can learn more about Oracle's infrastructure framework at this site: <a href="http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html</a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we covered some impressive new features of the Java platform, with specific focus on javac, JDK libraries, and various test suites. Memory management improvements, including heap space efficiencies, memory allocation, and improved garbage collection represent a powerful new set of Java platform enhancements. Changes regarding the compilation process resulting in greater efficiencies were part of our chapter. We also covered important improvements, such as with the compilation process, type testing, annotations, and automated runtime compiler tests.</p>
<p class="mce-root">In the next chapter, we will look at several minor language enhancements introduced in Java 9.</p>


            </article>

            
        </section>
    </div>



  </body></html>