<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Code Integration"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Code Integration</h1></div></div></div><p>Being able to make Java and Scala cooperate on the same code base is a prerequisite to guarantee a smooth transition between the two languages.</p><p>In this chapter, we are going to quickly create a small Java web application in which we will show you how to add Scala code to it. Then, we will cover some of the most common integration points between Java and Scala and how programming styles differ so that programmers who want to refactor and extend their Java application can do it according to some guidelines.</p><p>To avoid spending too much time on creating, understanding, and documenting a sample Java project, we are going to use a small database that is already available as part of the Oracle's NetBeans IDE distribution and create a JPA persistence layer as well as a REST API from it using the code generation features of the IDE.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Download the sample Java project</strong></span>
</p><p>If you are impatient to directly jump into the Scala code integration features of this chapter, you may skip the following section and download the ready-to-use maven Java project instead from Packt's website at <a class="ulink" href="http://www.packtpub.com">www.packtpub.com</a>.</p></div></div><div class="section" title="Creating a REST API from an existing database"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Creating a REST API from an existing database</h1></div></div></div><p>The sample database <a id="id68" class="indexterm"/>bundled with the NetBeans IDE can be downloaded from the <a class="ulink" href="http://www.netbeans.org">www.netbeans.org</a> website. Just click on the <span class="strong"><strong>Download</strong></span> button on this website and pick the JavaEE version of the IDE.</p><p>Once you have run the <a id="id69" class="indexterm"/>installation wizard, seen the <span class="strong"><strong>The installation was successful!</strong></span> message, and started the IDE (Version 8.0 in our case), we are ready to create a fully functional web app in five minutes. The first time you use it, just click on the upper-left corner of the NetBeans IDE to close the startup screen and you should see the three tabs: <span class="strong"><strong>Projects</strong></span>, <span class="strong"><strong>Files</strong></span>, and <span class="strong"><strong>Services</strong></span> on the left-hand side of the IDE.</p><div class="section" title="The sample database"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>The sample database</h2></div></div></div><p>Our reference database can be <a id="id70" class="indexterm"/>seen from the IDE by clicking on the <span class="strong"><strong>Services</strong></span> panel. Under the <span class="strong"><strong>Databases</strong></span> menu that is part of the <span class="strong"><strong>Services</strong></span> tab, double-click on the <code class="literal">jdbc:derby://localhost:1527/sample [app on APP] Database Connection</code> link to connect to the sample database on port 1527 (the default port for Derby databases) with the <code class="literal">app</code> <a id="id71" class="indexterm"/>user on the <code class="literal">APP</code> schema. Under the <code class="literal">APP</code> schema, you should find seven tables including <code class="literal">CUSTOMER</code> and <code class="literal">PRODUCT</code>. By right-clicking on the <code class="literal">CUSTOMER</code> table and choosing <span class="strong"><strong>View Data…</strong></span>, you should be able to browse the content of the table.</p><p>The following diagram depicts the whole database schema so that you can visualize the dependencies or foreign keys between the different tables:</p><div class="mediaobject"><img src="graphics/3637_02_01.jpg" alt="The sample database"/></div></div><div class="section" title="Setting up a Maven project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Setting up a Maven project</h2></div></div></div><p>To quickly set up our sample Java <a id="id72" class="indexterm"/>project, you may either import it directly in your favorite IDE from the downloaded code (and skip creating JPA entities and the REST <a id="id73" class="indexterm"/>web service) or perform the following simple steps on the NetBeans IDE:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click anywhere within the <span class="strong"><strong>Projects</strong></span> tab in the IDE, select <span class="strong"><strong>New Project…</strong></span>, and then choose the <span class="strong"><strong>Maven</strong></span> category and the <span class="strong"><strong>Web Application</strong></span> project type.</li><li class="listitem">Enter <code class="literal">Sample</code> as <span class="strong"><strong>Project Name </strong></span>and <code class="literal">com.demo </code>as <span class="strong"><strong>Group Id</strong></span>, and then click on the <span class="strong"><strong>Next &gt;</strong></span> button.</li><li class="listitem">Make sure a <span class="strong"><strong>Server</strong></span> container is selected for deployment (we use the default GlassFish 4.0 as part of the NetBeans distribution) as well as <span class="strong"><strong>Java EE 7 Web</strong></span> as the Java EE version.</li><li class="listitem">Click on the <span class="strong"><strong>Finish</strong></span> button and you should see the structure of the created project under the <span class="strong"><strong>Projects</strong></span> tab.</li></ol></div></div><div class="section" title="Creating JPA entities and REST web services"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Creating JPA entities and REST web services</h2></div></div></div><p>Right-click on the <span class="strong"><strong>Sample</strong></span> <a id="id74" class="indexterm"/>project root we just created and navigate to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>RESTful Web Services from Databases…</strong></span>. Selecting the <code class="literal">derby sample</code> database connection from the drop-down list in the newly opened window should bring up the <a id="id75" class="indexterm"/>database tables into the <span class="strong"><strong>Available Tables</strong></span> section. <a id="id76" class="indexterm"/>Mark only the <code class="literal">CUSTOMER</code> table and select <span class="strong"><strong>Add&gt;</strong></span>, both <code class="literal">CUSTOMER</code> and <code class="literal">DISCOUNT_CODE</code> (which are dependent on <code class="literal">CUSTOMER</code>) should be <a id="id77" class="indexterm"/>listed as <span class="strong"><strong>Selected Tables</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_02_02.jpg" alt="Creating JPA entities and REST web services"/></div><p>Clicking on the <span class="strong"><strong>Next </strong></span>button and again on <span class="strong"><strong>Next</strong></span> on the next page, and finally clicking on <span class="strong"><strong>Finish </strong></span>will generate both the persistence <a id="id78" class="indexterm"/>JPA entities for <code class="literal">Customer</code> and <code class="literal">DiscountCode</code> and the service facade classes, <code class="literal">CustomerFacadeREST</code> and <code class="literal">DiscountCodeFacadeREST</code>. Note that since Java EE6, the <code class="literal">EntityManager</code> class is instantiated in each service class, which <a id="id79" class="indexterm"/>avoids the need for JPA controller <a id="id80" class="indexterm"/>classes that were generated in the <a id="id81" class="indexterm"/>previous versions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>A more detailed version of how to generate a RESTful web service from a database is available under the NetBeans tutorial at <a class="ulink" href="http://www.netbeans.org">www.netbeans.org</a>.</p></div></div></div><div class="section" title="Running and testing the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Running and testing the project</h2></div></div></div><p>Before we start introducing Scala <a id="id82" class="indexterm"/>code into our Java project, we may launch our application and test REST invocations in a browser. Right-click on the <span class="strong"><strong>Sample</strong></span> root node of the <a id="id83" class="indexterm"/>project and select <span class="strong"><strong>Run</strong></span> to deploy the application. Once the console displays that the GlassFish server is running, and that the message <span class="strong"><strong>Hello World!</strong></span> appears in your browser to show that everything is deployed correctly, right-click on the <code class="literal">RESTful Web Services</code> folder under the project root, and select <span class="strong"><strong>Test RESTful Web Services</strong></span>. The opening dialog lets you choose between generating a test client as part of the same project or externally, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_02_04.jpg" alt="Running and testing the project"/></div><p>Select <span class="strong"><strong>Locally Generated Test Client (suitable for Internet Explorer)</strong></span> and click on <span class="strong"><strong>OK</strong></span>.</p><p>Once deployment completes, the browser will display a test page where we can invoke REST methods on our <code class="literal">customer</code> and <code class="literal">discountcode</code> entities. If we expand the <code class="literal">com.demo.sample.customer</code> folder, additional <a id="id84" class="indexterm"/>parameters will be shown. Clicking on the <code class="literal">{id}</code> parameter, we will get an input field on the right pane where we can enter a particular customer <code class="literal">id</code> value. For instance, we can enter <code class="literal">409</code>. In the drop-down list that shows <span class="strong"><strong>MIME</strong></span> types, select <span class="strong"><strong>application/json</strong></span> and <code class="literal">GET</code> as the method to test, and then click on <span class="strong"><strong>Test</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637_02_03.jpg" alt="Running and testing the project"/></div><p>The bottom part of the page will now display the response to the REST query. It consists of a <span class="strong"><strong>Status: 200 (OK) </strong></span>message and a <span class="strong"><strong>Response</strong></span> content where the  <span class="strong"><strong>Raw View</strong></span> tab will display the body of the response as <a id="id85" class="indexterm"/>JSON, as shown in the previous screenshot.</p><div class="section" title="Adding a unit test in Java"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl1sec1333"/>Adding a unit test in Java</h3></div></div></div><p>Finally, we can generate a very <a id="id86" class="indexterm"/>simple unit test for the <code class="literal">Customer</code> class by selecting the <code class="literal">Customer.java</code> source file from the <span class="strong"><strong>Projects </strong></span>pane, and then right-clicking on it and navigating to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Create Tests</strong></span>. Simply click on the <span class="strong"><strong>OK</strong></span> button in the dialog and eventually allow the installation of the <span class="strong"><strong>JUnit 4.xx</strong></span> if required. The resulting generated file <a id="id87" class="indexterm"/>appears within <span class="strong"><strong>Test Packages</strong></span> under the same Java package structure as the original class under test, in our case <code class="literal">com.demo.sample.CustomerTest.java</code>, which is a common convention when dealing with unit testing in Java. Right-clicking on the <code class="literal">CustomerTest</code> class and choosing <span class="strong"><strong>Test File</strong></span> will make all the test methods run with <span class="strong"><strong>JUnit</strong></span><a id="id88" class="indexterm"/> and fail as a <code class="literal">fail</code> clause is present by default at the end of each tested method. For now, just comment out the <code class="literal">fail</code> statement of <code class="literal">testGetCustomerId</code> and remove all the other test methods. Then, rerun the test to see it in green in the IDE. Alternatively, if you have set up the Maven project with another IDE or a plain text editor, from the root of the project in the filesystem (where the <code class="literal">pom.xml</code> file is located), you may enter <a id="id89" class="indexterm"/>the following Maven command, <a id="id90" class="indexterm"/>which you probably are familiar with, in a terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mvn test</strong></span>
<span class="strong"><strong>-------------------------------------------------------</strong></span>
<span class="strong"><strong> T E S T S</strong></span>
<span class="strong"><strong>-------------------------------------------------------</strong></span>
<span class="strong"><strong>Running com.demo.sample.CustomerTest</strong></span>
<span class="strong"><strong>getCustomerId</strong></span>
<span class="strong"><strong>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.034 sec</strong></span>
<span class="strong"><strong>Results :</strong></span>
<span class="strong"><strong>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong></span>
</pre></div></div></div></div></div>
<div class="section" title="Adding a test in Scala"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Adding a test in Scala</h1></div></div></div><p>For now, we have only Java code in the <a id="id91" class="indexterm"/>small sample Maven project. We are ready to introduce a few lines of Scala to the same codebase in order to show how both languages seamlessly interoperate. Let's create a <code class="literal">src/test/scala</code> directory, next to the existing <code class="literal">java/</code> directory, where we <a id="id92" class="indexterm"/>will put our following new <code class="literal">CustomerScalaTest.scala</code> class, which is a similar test to the one we already have under <code class="literal">src/test/java</code>:</p><div class="informalexample"><pre class="programlisting">package com.demo.sample

import org.junit._
import Assert._

class CustomerScalaTest {

  @Before
  def setUp: Unit = {
  }

  @After
  def tearDown: Unit = {
  }

  @Test
  def testGetCustomerId = {
    System.out.println("getCustomerId")
    val instance = new Customer()
    val expResult: Integer = null
    val result: Integer = instance.getCustomerId()
    assertEquals(expResult, result)
  }
}</pre></div><p>If we run the tests again, <a id="id93" class="indexterm"/>that is, type <code class="literal">&gt;mvn clean test</code> again, the class will just be ignored as it is <a id="id94" class="indexterm"/>not a <code class="literal">.java</code> source file.</p></div>
<div class="section" title="Setting up Scala within a Java Maven project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Setting up Scala within a Java Maven project</h1></div></div></div><p>In order to be able to start <a id="id95" class="indexterm"/>writing a Scala unit test and compile Scala <a id="id96" class="indexterm"/>code into our Java project, we need to add a few dependencies and the scala-maven-plugin to the <code class="literal">pom.xml</code> file. The dependencies are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dependency for the core scala-library:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;
  &lt;artifactId&gt;scala-library&lt;/artifactId&gt;
  &lt;version&gt;2.10.0&lt;/version&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Dependency for scalatest (a framework for testing in Scala that supports JUnit and other styles; we will cover it in detail in <a class="link" href="ch04.html" title="Chapter 4. Testing Tools">Chapter 4</a>, <span class="emphasis"><em>Testing Tools)</em></span>:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.scalatest&lt;/groupId&gt;
  &lt;artifactId&gt;scalatest_2.10&lt;/artifactId&gt;
  &lt;version&gt;2.0/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Dependency for JUnit to use Java <code class="literal">Assert</code> statements in our test case:<div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.11&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li></ul></div><p>Concerning the <code class="literal">scala-maven-plugin</code>, just add something similar to the following XML block to the <code class="literal">&lt;plugins&gt;</code> section of your <code class="literal">pom.xml</code> build file:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;
  &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;scala-compile-first&lt;/id&gt;
      &lt;phase&gt;process-resources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;add-source&lt;/goal&gt;
        &lt;goal&gt;compile&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
    &lt;execution&gt;
      &lt;id&gt;scala-test-compile&lt;/id&gt;
      &lt;phase&gt;process-test-resources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;testCompile&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</pre></div><p>If we try to rerun the tests, this time our newly created Scala test will be picked up and executed, as shown in the <a id="id97" class="indexterm"/>following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mvn clean test</strong></span>
<span class="strong"><strong>-------------------------------------------------------</strong></span>
<span class="strong"><strong> T E S T S</strong></span>
<span class="strong"><strong>-------------------------------------------------------</strong></span>
<span class="strong"><strong>Running com.demo.sample.CustomerScalaTest</strong></span>
<span class="strong"><strong>getCustomerId</strong></span>
<span class="strong"><strong>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.035 sec</strong></span>
<span class="strong"><strong>Running com.demo.sample.CustomerTest</strong></span>
<span class="strong"><strong>getCustomerId</strong></span>
<span class="strong"><strong>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.004 sec</strong></span>

<span class="strong"><strong>Results :</strong></span>

<span class="strong"><strong>Tests run: 2, Failures: 0, Errors: 0, Skipped: 0</strong></span>
</pre></div><p>A couple of observations are worth mentioning about the <code class="literal">CustomerScalaTest.scala</code> class. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The package declaration at the top of the file is similar to package declarations in Java. However, having a package declaration in Scala mirroring the path of directories in the filesystem is not a requirement unlike Java, but is still recommended.</li><li class="listitem" style="list-style-type: disc">Import statements in <a id="id98" class="indexterm"/>Scala are similar to Java except that the <code class="literal">*</code> wildcard is replaced by the underscore, <code class="literal">_</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>You probably noticed that we suddenly have the enormous power to use any Java library in our Scala code, which means that we will never be stuck and can always invoke methods in the existing Java classes if we need a piece of functionality that is not directly available in Scala.</p></div></div></li></ul></div><p>With very few additions to the <code class="literal">pom.xml</code> build file, we now have made a regular Java project Scala aware, which means that we can freely add Scala classes and invoke any Java library within them. This also means that as Java developers, we are now able to migrate or refactor only small parts of a project if it makes sense and progressively improve our codebase as we get more <a id="id99" class="indexterm"/>acquainted with the Scala constructs.</p><p>This approach of dealing with an existing Maven project is only one way of proceeding. In the next chapter, we will see some other approaches with a more radical change that involves the Scala's <span class="strong"><strong>Simple Build </strong></span><a id="id100" class="indexterm"/>
<span class="strong"><strong>Tool</strong></span> (<span class="strong"><strong>SBT</strong></span>), an alternative to Maven builds.</p></div>
<div class="section" title="Scala and Java collaboration"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Scala and Java collaboration</h1></div></div></div><p>Going back to the REPL, we are going to experiment further with mixing Scala and Java to explore some common integration <a id="id101" class="indexterm"/>needs, and in particular, testing and manipulating the Java REST API that we have built at the beginning of the chapter.</p><p>As a reminder on how to restart the REPL from the <span class="emphasis"><em>hello-scala</em></span> project introduced in <a class="link" href="ch01.html" title="Chapter 1. Programming Interactively within Your Project">Chapter 1</a>, <span class="emphasis"><em>Programming Interactively within Your Project</em></span>, if you closed it in the meantime, just start a new terminal window, navigate to the root of the <span class="emphasis"><em>hello-scala</em></span> project, and enter the following command in the command prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator console</strong></span>
</pre></div><div class="section" title="Converting between collection types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Converting between collection types</h2></div></div></div><p>Let's start by comparing <a id="id102" class="indexterm"/>Java and Scala collection classes and see how we can go from one to the other. For instance, a Scala <code class="literal">List</code> (from the <code class="literal">scala.collection.immutable</code> package) is different from <code class="literal">java.util.List</code>, and sometimes, it <a id="id103" class="indexterm"/>can be useful to convert from one to the other. A convenient way in Java to create <code class="literal">java.util.List</code> is to use the <code class="literal">java.util.Arrays</code> utility method, <code class="literal">asList</code>, whose exact signature is <code class="literal">public static&lt;T&gt; List&lt;T&gt; asList(T... a)</code>, where <code class="literal">T</code> refers to a generic type. Let's import it in the REPL as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import java.util.Arrays</strong></span>
<span class="strong"><strong>import java.util.Arrays</strong></span>
</pre></div><p>As the JDK classes are in the class path, they can be directly accessed into the REPL as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val javaList = Arrays.asList(1,2,3,4)</strong></span>
<span class="strong"><strong>javaList: java.util.List[Int] = [1, 2, 3, 4]</strong></span>
</pre></div><p>Now that we have instantiated a Java list of integers, we want to convert it to its Scala equivalent and need to import the <code class="literal">JavaConverters</code> classes for that using the following lines of command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import scala.collection.JavaConverters._</strong></span>
<span class="strong"><strong>import scala.collection.JavaConverters._</strong></span>
</pre></div><p>Looking at the documentation of <code class="literal">JavaConverters</code> in Scaladoc (which is similar to Javadoc, used to document Scala APIs, and available online at <a class="ulink" href="http://www.scala-lang.org/api/current/index.html">www.scala-lang.org/api/current/index.html</a>), we can see, for example, that the equivalent of <code class="literal">java.util.List</code> is <code class="literal">scala.collection.mutable.Buffer</code>. So, if we invoke the <code class="literal">asScala</code> method on <code class="literal">java.util.List</code>, we will get exactly that:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val scalaList = javaList.asScala</strong></span>
<span class="strong"><strong>scalaList: scala.collection.mutable.Buffer[Int] = Buffer(1, 2, 3, 4)</strong></span>
</pre></div><p>Now, by invoking the <code class="literal">asJava</code> method on <code class="literal">scalaList</code>, we will get back our original <code class="literal">java.util.List</code> collection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val javaListAgain = scalaList.asJava</strong></span>
<span class="strong"><strong>javaListAgain: java.util.List[Int] = [1, 2, 3, 4]</strong></span>
</pre></div><p>A good test to verify that we get back the original object after converting it to a target type and back again is to use an <code class="literal">assert</code> <a id="id104" class="indexterm"/>statement, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; assert( javaList eq javaListAgain)</strong></span>
<span class="strong"><strong>[no output]</strong></span>
</pre></div><p>Having no output from <code class="literal">assert</code> means that it evaluated to <code class="literal">True</code>; otherwise, we would get a stack trace that shows why they are not equal. You might wonder where this <code class="literal">assert</code> method comes from; <code class="literal">assert</code> is a <a id="id105" class="indexterm"/>method of the <code class="literal">Predef</code> class, a Scala class imported by default containing useful aliases for <a id="id106" class="indexterm"/>commonly used types, assertions like the one we have used, and simple functions for console's I/O and implicit conversions.</p></div><div class="section" title="JavaBean-style properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>JavaBean-style properties</h2></div></div></div><p>To ensure compatibility <a id="id107" class="indexterm"/>with Java frameworks such as Hibernate or JMX, you may sometimes need Java-style getters and setters on the fields of <a id="id108" class="indexterm"/>your class. For example, if we declare a <code class="literal">Company</code> class in the REPL as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Company(var name:String)</strong></span>
<span class="strong"><strong>defined class Company</strong></span>
</pre></div><p>We have seen in <a class="link" href="ch01.html" title="Chapter 1. Programming Interactively within Your Project">Chapter 1</a>, <span class="emphasis"><em>Programming Interactively within Your Project</em></span>, that Scala accessor methods to read and mutate the <code class="literal">name</code> field are <code class="literal">name</code> and <code class="literal">name_=</code>, respectively, as shown in the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sun = new Company("Sun Microsystems")</strong></span>
<span class="strong"><strong>sun: Company = Company@55385db5</strong></span>
<span class="strong"><strong>scala&gt; sun.name</strong></span>
<span class="strong"><strong>res33: String = Sun Microsystems</strong></span>
<span class="strong"><strong>scala&gt; sun.name_=("Oracle")</strong></span>
<span class="strong"><strong>[no output is returned]</strong></span>
<span class="strong"><strong>scala&gt; sun.name</strong></span>
<span class="strong"><strong>res35: String = Oracle</strong></span>
</pre></div><p>A straightforward way to have Java-style getters and setters is to annotate the field with <code class="literal">scala.beans.BeanProperty</code> as shown in the following lines of command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import scala.beans.BeanProperty</strong></span>
<span class="strong"><strong>import scala.beans.BeanProperty</strong></span>
<span class="strong"><strong>scala&gt; class Company(@BeanProperty var name:String)</strong></span>
<span class="strong"><strong>defined class Company</strong></span>
<span class="strong"><strong>scala&gt; val sun = new Company("Sun Microsystems")</strong></span>
<span class="strong"><strong>sun: Company = Company@42540cca</strong></span>
<span class="strong"><strong>scala&gt; sun.getName()</strong></span>
<span class="strong"><strong>res36: String = Sun Microsystems</strong></span>
<span class="strong"><strong>scala&gt; sun.setName("Oracle")</strong></span>
<span class="strong"><strong>[no output is returned]</strong></span>
<span class="strong"><strong>scala&gt; sun.name  (alternatively sun.getName)</strong></span>
<span class="strong"><strong>res38: String = Oracle</strong></span>
</pre></div></div><div class="section" title="Scala and Java object orientation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Scala and Java object orientation</h2></div></div></div><p>The interoperability between <a id="id109" class="indexterm"/>Scala and Java classes makes it very straightforward to replace or extend an existing Java class with a Scala class. Compiling a Scala class produces bytecode that is pretty similar to what Java produces. For example, let's take a shorter version of the <code class="literal">Customer</code> Java class we generated earlier:</p><div class="informalexample"><pre class="programlisting">public class Customer {

    private Integer customerId;
    private String zip;

    public Customer(Integer customerId) {
        this.customerId = customerId;
    }

    public Customer(Integer customerId, String zip) {
        this.customerId = customerId;
        this.zip = zip;
    }
    public Integer getCustomerId() {
        return customerId;
    }

    public void setCustomerId(Integer customerId) {
        this.customerId = customerId;
    }

    public String getZip() {
        return zip;
    }

    public void setZip(String zip) {
        this.zip = zip;
    }
}</pre></div><p>If we refactor it into a Scala class with class parameters and create an instance, we get the following in the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Customer ( var customerId: Int, var zip: String) {</strong></span>
<span class="strong"><strong>         def getCustomerId() = customerId</strong></span>
<span class="strong"><strong>         def setCustomerId(cust: Int): Unit = {</strong></span>
<span class="strong"><strong>           customerId = cust</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>defined class Customer</strong></span>
<span class="strong"><strong>scala&gt; val customer = new Customer(1, "123 45")</strong></span>
<span class="strong"><strong>customer: Customer = Customer@13425838</strong></span>
<span class="strong"><strong>scala&gt; customer.zip</strong></span>
<span class="strong"><strong>res5: String = 123 45</strong></span>
</pre></div><p>However, a constructor that takes only a <a id="id110" class="indexterm"/>single <code class="literal">zip</code> parameter does not exist in this definition:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val otherCustomer = new Customer("543 21")</strong></span>
<span class="strong"><strong>&lt;console&gt;:8: error: not enough arguments for constructor Customer: (customerId: Int, zip: String)Customer.</strong></span>
<span class="strong"><strong>Unspecified value parameter zip.</strong></span>
<span class="strong"><strong>       val otherCustomer = new Customer("543 21")</strong></span>
<span class="strong"><strong>                           ^</strong></span>
</pre></div><p>To complete our refactoring of the Java class, we need an extra constructor as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Customer ( var customerId: Int, var zip: String) {</strong></span>
<span class="strong"><strong>     |   def this( zip: String) = this(0,zip)</strong></span>
<span class="strong"><strong>     |   def getCustomerId() = customerId</strong></span>
<span class="strong"><strong>     |   def setCustomerId(cust: Int): Unit = {</strong></span>
<span class="strong"><strong>     |     customerId = cust</strong></span>
<span class="strong"><strong>     |   }</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class Customer</strong></span>
<span class="strong"><strong>scala&gt; val customer = new Customer("123 45")</strong></span>
<span class="strong"><strong>customer: Customer = Customer@7944cdbd</strong></span>
</pre></div><p>This time, we were able to create an <a id="id111" class="indexterm"/>instance with the auxiliary constructor, which obeys to a couple of rules. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any auxiliary constructor must immediately call another <code class="literal">this(…)</code> constructor</li><li class="listitem" style="list-style-type: disc">The primary constructor has to be called in the end to make sure all the parameters are initialized</li></ul></div></div><div class="section" title="Scala traits as enhanced Java interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Scala traits as enhanced Java interfaces</h2></div></div></div><p>Software interfaces are <a id="id112" class="indexterm"/>useful mechanisms to make a piece of code interact via a contract to other external software systems, isolating the specification of what it does from its implementation. Although Java classes on the JVM have the limitation to only extend one single class, they can have multiple types by implementing several interfaces. However, Java interfaces are purely abstract, that is, they contain only constants, method signatures, and nested types, but no method bodies; for example, see the following code snippet:</p><div class="informalexample"><pre class="programlisting">interface VIPCustomer {
  Integer discounts();
}</pre></div><p>In contrast, Scala traits are more powerful by allowing partial implementation of method bodies and therefore, more reusable. One can use a trait to mix in behavior into a class. Let's take an example in the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Customer(val name:String, val discountCode:String="N" ){</strong></span>
<span class="strong"><strong>     |   def discounts() : List[Int] = List(5)</strong></span>
<span class="strong"><strong>     |   override def toString() = "Applied discounts: " +</strong></span>
<span class="strong"><strong>     |     discounts.mkString(" ","%, ","% ") </strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class Customer</strong></span>
</pre></div><p>This class declares two fields, <code class="literal">name</code> and <code class="literal">discountCode</code> (initialized to <code class="literal">"N"</code> for normal), as well as two methods, <code class="literal">discounts()</code> and <code class="literal">toString()</code>, where <code class="literal">discounts()</code> accumulates discounts for a customer into <code class="literal">List</code> of integers (initialized to a <code class="literal">5</code> percent discount) and <code class="literal">toString()</code> displays it.</p><p>We can define a couple of traits that extends the class we just created:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; trait VIPCustomer extends Customer {</strong></span>
<span class="strong"><strong>     |   override def discounts = super.discounts ::: List(10)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined trait VIPCustomer</strong></span>
</pre></div><p>A <code class="literal">VIPCustomer</code> class is a customer who <a id="id113" class="indexterm"/>gets an extra <code class="literal">10</code> percent discount concatenated to the list of all of the already available discounts he/she has. The second trait is given as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; trait GoldCustomer extends Customer {</strong></span>
<span class="strong"><strong>     |   override def discounts =</strong></span>
<span class="strong"><strong>     |     if (discountCode.equals("H"))</strong></span>
<span class="strong"><strong>     |       super.discounts ::: List(20)</strong></span>
<span class="strong"><strong>     |     else super.discounts ::: List(15)</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>defined trait GoldCustomer</strong></span>
</pre></div><p>A <code class="literal">GoldCustomer</code> class is a customer <a id="id114" class="indexterm"/>who gets an additional <code class="literal">15</code> percent discount or even <code class="literal">20</code> percent if her rating, that is, <code class="literal">discountCode</code> is <code class="literal">"H"</code> (high).</p><p>Let's now write a <code class="literal">Main</code> class to show the addition of stackable traits when instantiating the <code class="literal">Customer</code> class. We use the <code class="literal">with</code> <a id="id115" class="indexterm"/>keyword to mix in these additional behaviors into the class as shown in the following lines of command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; object Main {</strong></span>
<span class="strong"><strong>     |   def main(args: Array[String]) {</strong></span>
<span class="strong"><strong>     |     val myDiscounts = new Customer("Thomas","H") with</strong></span>
<span class="strong"><strong>     |       VIPCustomer with GoldCustomer</strong></span>
<span class="strong"><strong>     |     println(myDiscounts)</strong></span>
<span class="strong"><strong>     |   }</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined module Main</strong></span>
</pre></div><p>We can now simply execute the main method and get the expected result as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; Main.main(Array.empty)</strong></span>
<span class="strong"><strong>Applied discounts:  5%, 10%, 20%</strong></span>
</pre></div><p>Note that the order in which traits are <a id="id116" class="indexterm"/>stacked is important. They are calling each other from right to left. <code class="literal">GoldCustomer</code> is, therefore, the first one to be called.</p><p>Traits lie between interfaces and abstract classes. However, you can only extend one abstract class whereas you can extend several traits.</p></div><div class="section" title="Declaring objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Declaring objects</h2></div></div></div><p>Java code often refers to the <code class="literal">static</code> <a id="id117" class="indexterm"/>keyword to refer to singleton methods and constants. Scala does not <a id="id118" class="indexterm"/>support the <code class="literal">static</code> identifier, but instead provides the notion of <code class="literal">object</code> in place of the <code class="literal">class</code> declaration. If you need to refactor Java code into Scala, by simply using the <code class="literal">object</code> declaration instead of <code class="literal">class</code>, you get singleton instances and you're done, having the extra advantage that such Scala objects can also extend interfaces and traits. A simple example of <code class="literal">object</code> is the declaration of the <code class="literal">Main</code> program we exhibited earlier in the usage of stackable traits, or the following simple <code class="literal">hello world</code> application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; object Main {</strong></span>
<span class="strong"><strong>     |   def main(args: Array[String]) {</strong></span>
<span class="strong"><strong>     |     println("Hello Scala World !")</strong></span>
<span class="strong"><strong>     |   }</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined module Main</strong></span>
</pre></div><p>In addition to the notion of object, Scala provides the notion of companion object, which consists of an object that cohabits with a <a id="id119" class="indexterm"/>class of the same name in the same package and file. This is why it is called <span class="strong"><strong>companion</strong></span>.</p></div><div class="section" title="Introducing companion objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Introducing companion objects</h2></div></div></div><p>The companion object <a id="id120" class="indexterm"/>enables storing of static methods and from this, you have full access to the classes' members, including private ones. It is, for <a id="id121" class="indexterm"/>example, a good place to declare static factory methods, and <span class="strong"><strong>case classes</strong></span> overload the <code class="literal">apply</code> factory method so that you are not required to use the <code class="literal">new</code> keyword when creating case class instances:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Customer(val name:String)</strong></span>
<span class="strong"><strong>defined class Customer</strong></span>
<span class="strong"><strong>scala&gt; val thomas = Customer("Thomas")</strong></span>
<span class="strong"><strong>thomas: Customer = Customer(Thomas)</strong></span>
</pre></div><p>However, you can still use the <code class="literal">new</code> keyword if you want to, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val thomas = new Customer("Thomas")</strong></span>
<span class="strong"><strong>thomas: Customer = Customer(Thomas)</strong></span>
</pre></div><p>Under the hood, the case class is constructed as a regular class that has, among other things, a companion object similar to the following (although simplified) code snippet:</p><div class="informalexample"><pre class="programlisting">object Customer {
  def apply()= new Customer("default name")
}
class Customer(name:String) {
…
}</pre></div></div><div class="section" title="Handling exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Handling exceptions</h2></div></div></div><p>We conclude this section <a id="id122" class="indexterm"/>about how to migrate code from Java to Scala with exceptions, a notion that appears everywhere in Java. In a quite similar <a id="id123" class="indexterm"/>way to Java, you can write the <code class="literal">try { } catch { }</code> blocks to capture method invocations that might fail. In Java, you would write something similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">package com.demo.sample;

public class ConversionSample {

  static Integer parse(String numberAsString) {
    Integer number = null;
    try {    
      number = Integer.parseInt(numberAsString);
    } catch (NumberFormatExceptionnfe) {
      System.err.println("Wrong format for "+numberAsString);
    } catch (Exception ex) {
      System.err.println("An unknown Error has occurred");
    }
    System.out.println("Parsed Number: "+number);
    return number;
  }
  public static void main(String[] args) {
    parse("2345");
    parse("23ab");
  }
}</pre></div><p>The preceding code produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>run:</strong></span>
<span class="strong"><strong>Parsed Number: 2345</strong></span>
<span class="strong"><strong>Wrong format for number 23ab</strong></span>
<span class="strong"><strong>Parsed Number: null</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL (total time: 0 seconds)</strong></span>
</pre></div><p>In Scala, you could translate it directly to the equivalent code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def parse(numberAsString: String) = </strong></span>
<span class="strong"><strong>         try {</strong></span>
<span class="strong"><strong>           Integer.parseInt(numberAsString)</strong></span>
<span class="strong"><strong>         } catch {</strong></span>
<span class="strong"><strong>           case nfe: NumberFormatException =&gt;</strong></span>
<span class="strong"><strong>             println("Wrong format for number "+numberAsString)</strong></span>
<span class="strong"><strong>           case e: Exception =&gt; println("Error when parsing number"+</strong></span>
<span class="strong"><strong>             numberAsString)</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>parse: (numberAsString:String)AnyVal</strong></span>
<span class="strong"><strong>scala&gt; parse("2345")</strong></span>
<span class="strong"><strong>res10: AnyVal = "2345"</strong></span>
<span class="strong"><strong>scala&gt; parse("23ab")</strong></span>
<span class="strong"><strong>Wrong format for number 23ab</strong></span>
<span class="strong"><strong>res11: AnyVal = ()</strong></span>
</pre></div><p>However, in this case, the return value inferred by the compiler is not only empty but also of the wrong type, <code class="literal">AnyVal</code>, which is the <a id="id124" class="indexterm"/>common type found between an <code class="literal">Int</code> value and whatever is returned by the exception. To make sure we get an <a id="id125" class="indexterm"/>integer as the output, we need to return an <code class="literal">Int</code> value from all the possible cases found in the <code class="literal">catch</code> block:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def parse(numberAsString: String) = </strong></span>
<span class="strong"><strong>         try {</strong></span>
<span class="strong"><strong>           Integer.parseInt(numberAsString)</strong></span>
<span class="strong"><strong>         } catch {</strong></span>
<span class="strong"><strong>           case nfe: NumberFormatException =&gt;</strong></span>
<span class="strong"><strong>             println("Wrong format for number "+numberAsString); -1</strong></span>
<span class="strong"><strong>           case _: Throwable =&gt;</strong></span>
<span class="strong"><strong>             println("Error when parsing number "+numberAsString)</strong></span>
<span class="strong"><strong>            -1</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>parse: (numberAsString:String)Int</strong></span>
</pre></div><p>This time we can capture the correct return type from the parsing invocation as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val number = parse("23ab")</strong></span>
<span class="strong"><strong>Wrong format for number 23ab</strong></span>
<span class="strong"><strong>number: Int= -1</strong></span>
</pre></div><p>In all cases, we return an <code class="literal">Int</code> value, <code class="literal">-1</code> in case of failure. This solution is still only partly satisfying as the caller does not really know the reason of failure unless we display/log it. A better way is to use, for example, an <code class="literal">Either</code> class that represents a value of one of the two possible types, where its instances are either of the <code class="literal">scala.util.Left</code> or <code class="literal">scala.util.Right</code> type. In this case, we can use the <code class="literal">Left</code> part to handle the failure and the <code class="literal">Right</code> part to handle a successful <a id="id126" class="indexterm"/>result as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Failure(val reason: String)</strong></span>
<span class="strong"><strong>defined class Failure</strong></span>
<span class="strong"><strong>scala&gt; def parse(numberAsString: String) : Either[Failure,Int] = </strong></span>
<span class="strong"><strong>         try {</strong></span>
<span class="strong"><strong>           val result = Integer.parseInt(numberAsString)</strong></span>
<span class="strong"><strong>           Right(result)</strong></span>
<span class="strong"><strong>         } catch {</strong></span>
<span class="strong"><strong>           case _ : Throwable =&gt; Left(Failure("Error when parsing number"))</strong></span>
<span class="strong"><strong>         }</strong></span>
<span class="strong"><strong>parse: (numberAsString:String)Either[Failure,Int]</strong></span>
<span class="strong"><strong>scala&gt; val number = parse("23ab")</strong></span>
<span class="strong"><strong>number: Either[Failure,Int] = Left(Failure(Error when parsing number))</strong></span>
<span class="strong"><strong>scala&gt; val number = parse("2345")</strong></span>
<span class="strong"><strong>number: Either[Failure,Int] = Right(2345)</strong></span>
</pre></div><p>Writing explicitly the return type will cause a compilation error on these types of errors, and therefore, is highly recommended.</p><p>Finally, without going into too much detail, there is an even more appropriate way of handling the <code class="literal">try</code> and <code class="literal">catch</code> blocks that are derived from <code class="literal">Either</code> using the <code class="literal">scala.util.Try</code> class. Instead of <a id="id127" class="indexterm"/>handling the exception as <code class="literal">Left</code> and <code class="literal">Right</code>, it returns <code class="literal">Failure[Throwable]</code> or <code class="literal">Success[T]</code>, <code class="literal">T</code> being a generic type. The advantage of this approach is that it can be used in for comprehensions (but we have not covered them yet, examples will come in <a class="link" href="ch05.html" title="Chapter 5. Getting Started with the Play Framework">Chapter 5</a>, <span class="emphasis"><em>Getting Started with the Play Framework</em></span>). Moreover, the semantics of <code class="literal">Try</code> for error handling is better than <code class="literal">Either</code> as it describes <code class="literal">Success</code> or <code class="literal">Failure</code> rather than the less meaningful and more generic terms <code class="literal">Left</code> and <code class="literal">Right</code>.</p></div></div>
<div class="section" title="Differences in style between Java and Scala code"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Differences in style between Java and Scala code</h1></div></div></div><p>If you are going to refactor <a id="id128" class="indexterm"/>or rewrite Java code into Scala code, there are a number of style differences that are useful to be aware of. Obviously, programming style is largely a matter of taste; however, a few guidelines generally acknowledged by the Scala community can help someone new to Scala to write easier-to-read and more maintainable code. This section is dedicated to showing some of the most common differences.</p><p>Writing an algorithm in Java follows an imperative style, that is, a sequence of statements that change a program state. Scala, focusing primarily on functional programming, adopts a more declarative approach, where everything is an expression rather than a statement. Let's illustrate this in an example.</p><p>In Java, you would commonly find the <a id="id129" class="indexterm"/>following code snippet:</p><div class="informalexample"><pre class="programlisting">...
String customerLevel = null;
if(amountBought &gt; 3000) {
    customerLevel = "Gold"; 
} else {
    customerLevel = "Silver";
}
...</pre></div><p>The Scala equivalent consists of the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amountBought = 5000</strong></span>
<span class="strong"><strong>amountBought: Int = 5000</strong></span>
<span class="strong"><strong>scala&gt; val customerLevel =</strong></span>
<span class="strong"><strong>         if (amountBought&gt; 3000) "Gold" else "Silver"</strong></span>
<span class="strong"><strong>customerLevel: String = Gold</strong></span>
</pre></div><p>Note that unlike the Java statements, <code class="literal">if</code> is now embedded as part of the resulting evaluated expression.</p><p>In general, working where everything is evaluated as an expression (and here an immutable expression) will make it much easier for reuse as well as composition.</p><p>Being able to chain the result of one expression to the next will give you a concise way of expressing fairly complicated transformations that would require much more code in Java.</p><div class="section" title="Adjusting the code layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Adjusting the code layout</h2></div></div></div><p>As the intent of functional <a id="id130" class="indexterm"/>programming is to minimize state behavior, it often consists of short lambda expressions so that you can visualize a fairly complicated transformation in an elegant and concise way, in many cases even as one-liners. For this reason, general formatting in Scala recommends that you use only two-space indentations instead of the four-space indentation that is generally admitted in Java code, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Customer(</strong></span>
<span class="strong"><strong>         val firstName: String, </strong></span>
<span class="strong"><strong>         val lastName: String,</strong></span>
<span class="strong"><strong>         val age: Int,</strong></span>
<span class="strong"><strong>         val address: String,</strong></span>
<span class="strong"><strong>         val country: String,</strong></span>
<span class="strong"><strong>         valhasAGoodRating: Boolean</strong></span>
<span class="strong"><strong>         ) {</strong></span>

<span class="strong"><strong>         override def toString() =</strong></span>
<span class="strong"><strong>           s" $firstName $lastName"</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>defined class Customer</strong></span>
</pre></div><p>If you have many constructor/method parameters, having them aligned as previously illustrated makes it easier to change them without the need to reformat the whole indentation. It is also the case if you want to refactor the class with a longer name, for example, <code class="literal">VeryImportantCustomer</code> instead of <code class="literal">Customer</code>; it will make smaller and more precise differences against your version <a id="id131" class="indexterm"/>control management system (Git, subversion, and so on).</p></div><div class="section" title="Naming conventions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Naming conventions</h2></div></div></div><p>Conventions for naming packages, <a id="id132" class="indexterm"/>classes, fields, and methods in the camel case generally follow the Java conventions. Note that you should avoid the underscore (<code class="literal">_</code>) in variable names (such as <code class="literal">first_name</code> or <code class="literal">_first_name</code>) as the underscore has a special meaning in <a id="id133" class="indexterm"/>Scala (<code class="literal">self</code> or <code class="literal">this</code> in anonymous functions).</p><p>However, constants, most likely declared as <code class="literal">private static final myConstant</code> in Java, are normally declared in Scala in the upper camel case, such as in the following enclosing object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; object Constants {</strong></span>
<span class="strong"><strong>     |   val MyNeverChangingAge = 20</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined module Constants</strong></span>
</pre></div><p>Choosing a meaningful name for variables and methods should always be a priority in Java, and it is often recommended to use rather long variable names to precisely describe what a variable or method represents. In Scala, things are a little bit different; meaningful names are, of course, a good way to make code more readable. However, as we are at the same time aiming at making behavior transformations concise through the use of functions and lambda expressions, short variable names can be an advantage if you can capture a whole piece of functionality in a short block of code. For example, incrementing a list of integers in Scala can simply be expressed as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amounts = List(3,6,7,10) map ( x =&gt; x +1 )</strong></span>
<span class="strong"><strong>amounts: List[Int] = List(4, 7, 8, 11)</strong></span>
</pre></div><p>Although using <code class="literal">x</code> as a variable name <a id="id134" class="indexterm"/>is often discouraged in Java, here it does not matter that much as the variable is not reused and we can capture the transformation it does at <a id="id135" class="indexterm"/>once. There are many short or long alternatives to the previous lambda syntax that will produce the same result. So, which one to choose? Some of the alternatives are as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amounts = List(3,6,7,10) map ( myCurrentAmount =&gt;</strong></span>
<span class="strong"><strong>         myCurrentAmount +1 )</strong></span>
<span class="strong"><strong>amounts: List[Int] = List(4, 7, 8, 11)</strong></span>
</pre></div><p>In this case, a long variable name breaks a clear and concise one-liner into two lines of code, thereby, making it difficult to understand. Meaningful names make more sense here if we start expressing logic on several lines as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amounts = List(3,6,7,10) map { myCurrentAmount  =&gt;</strong></span>
<span class="strong"><strong>         val result = myCurrentAmount + 1</strong></span>
<span class="strong"><strong>         println("Result: " + result)</strong></span>
<span class="strong"><strong>         result</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>Result: 4</strong></span>
<span class="strong"><strong>Result: 7</strong></span>
<span class="strong"><strong>Result: 8</strong></span>
<span class="strong"><strong>Result: 11</strong></span>
<span class="strong"><strong>amounts: List[Int] = List(4, 7, 8, 11)</strong></span>
</pre></div><p>A shorter but still expressive name is sometimes a good compromise to indicate to the reader that this is an amount we are currently manipulating in our lambda expression, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amounts = List(3,6,7,10) map( amt =&gt; amt + 1 )</strong></span>
<span class="strong"><strong>amounts: List[Int] = List(4, 7, 8, 11)</strong></span>
</pre></div><p>Finally, the shortest syntax of all that is well accepted by fluent Scala programmers for such a simple increment function is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amounts = List(3,6,7,10) map( _ + 1 )</strong></span>
<span class="strong"><strong>amounts: List[Int] = List(4, 7, 8, 11)</strong></span>
</pre></div><p>Underscores are also encountered in Scala for expressing more complicated operations in an elegant but more awkward way, as is the following <span class="emphasis"><em>sum</em></span> operation using the <code class="literal">foldLeft</code> method that accumulates the state from one element to the other (and is covered in the previous chapter):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sumOfAmounts = List(3,6,7,10).foldLeft(0)( _ + _ ) </strong></span>
<span class="strong"><strong>sumOfAmounts: Int = 26</strong></span>
</pre></div><p>Instead of explicitly having <code class="literal">0</code> as the initial value for the sum, we can write this summation a bit more elegantly by using the <a id="id136" class="indexterm"/>
<code class="literal">reduce</code> method that is similar to <code class="literal">foldLeft</code>. However, we take the first element of the <a id="id137" class="indexterm"/>collection as the initial value (here, <code class="literal">3</code> will be the initial value), as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sumOfAmounts = List(3,6,7,10) reduce ( _ + _ ) </strong></span>
<span class="strong"><strong>sumOfAmounts: Int = 26</strong></span>
</pre></div><p>As far as style is concerned, fluent <a id="id138" class="indexterm"/>Scala programmers will not have any problem reading this code. However, if the state accumulation operation is more complicated than just a simple <code class="literal">+</code> operation, it might be wise to write it more explicitly as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sumOfAmounts = </strong></span>
<span class="strong"><strong>         List(3,6,7,10) reduce ( (total,element) =&gt; total + element ) </strong></span>
<span class="strong"><strong>sumOfAmounts: Int = 26</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we have covered how to start integrating Scala code into a Java codebase as well as how to refactor some of the most common Java constructs into Scala by following some style guidelines. A much more exhaustive list of style recommendations is available at <a class="ulink" href="http://docs.scala-lang.org/style/">http://docs.scala-lang.org/style/</a> if you are interested in learning more.</p><p>So far we have been mostly addressing the Scala language and syntax. In the next chapter, we are going to introduce the tools that complement it and that are necessary to make our Scala programming both productive and enjoyable.</p></div></body></html>