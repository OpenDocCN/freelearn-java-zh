<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Enterprise JavaBeans"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Enterprise JavaBeans</h1></div></div></div><p>Enterprise JavaBeans are server side components that encapsulate business logic of an application. Enterprise JavaBeans<a id="id365" class="indexterm"/> simplify application development by automatically managing transaction management and security. There are two types of Enterprise JavaBeans: Session beans, which execute business logic, and message-driven beans, which act as a message listener.</p><p>Readers familiar with J2EE may notice that Entity Beans haven't been mentioned in the previous paragraph. In Java EE 5, Entity Beans were deprecated in favor of the <span class="strong"><strong>Java Persistence API</strong></span> (<span class="strong"><strong>JPA</strong></span>). Entity Beans are still supported for backwards compatibility, however, the preferred way of performing Object-relational mapping is through JPA.</p><p>The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Session beans<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A simple session bean</li><li class="listitem" style="list-style-type: disc">A more realistic example</li><li class="listitem" style="list-style-type: disc">Using a session bean to implement the DAO design pattern</li><li class="listitem" style="list-style-type: disc">Singleton session beans</li></ul></div></li><li class="listitem" style="list-style-type: disc">Message-driven beans</li><li class="listitem" style="list-style-type: disc">Transactions in Enterprise JavaBeans<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Container-managed transactions</li><li class="listitem" style="list-style-type: disc">Bean-managed transactions</li></ul></div></li><li class="listitem" style="list-style-type: disc">Enterprise JavaBeans life cycles<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A stateful session bean life cycle</li><li class="listitem" style="list-style-type: disc">A stateless session bean life cycle</li><li class="listitem" style="list-style-type: disc">Message-driven bean life cycle</li><li class="listitem" style="list-style-type: disc">The EJB Timer Service</li><li class="listitem" style="list-style-type: disc">EJB Security</li></ul></div></li></ul></div><div class="section" title="Introduction to session beans"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Introduction to session beans</h1></div></div></div><p>As we've previously mentioned, session beans typically encapsulate business logic. In Java EE, only one or two artifacts need to be created in order to create a session bean, namely, the bean itself and an optional <a id="id366" class="indexterm"/>business interface. These artifacts need to be decorated with the proper annotations to let the EJB container know they are session beans.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>J2EE required application developers to create several artifacts in order to create a session bean. These artifacts included the bean itself, a local or remote interface (or both), a local home or a remote home interface (or both), and an XML deployment descriptor. As we shall see in this chapter, EJB development was greatly simplified in Java EE.</p></div></div><div class="section" title="Developing a simple session bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Developing a simple session bean</h2></div></div></div><p>The following example<a id="id367" class="indexterm"/> illustrates a very simple session bean:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.Stateless;

@Stateless
public class SimpleSessionBean implements SimpleSession
{  
  private String message = 
      "If you don't see this, it didn't work!";
  
  public String getMessage()
  {
    return message;
  }
}</pre></div><p>The <code class="literal">@Stateless</code> annotation lets the EJB container know that this class is a stateless session bean. There are three types of session beans: stateless, stateful, and singleton. Before we explain the difference between these types of session beans, we need to clarify how an instance of an EJB is provided to an EJB client application.</p><p>When a stateless or stateful session bean is deployed, the EJB container creates a series of instances of each session bean. This is what is typically referred to as an EJB pool. When an EJB client application obtains an instance of EJB, the application server (GlassFish, in our case) provides one of the instances in the pool to the client application.</p><p>The difference between stateful and stateless session beans is that stateful session beans maintain a conversational state with the client, whereas stateless session beans do not. In simple terms, what this means is that when an EJB client application obtains an instance of a stateful session bean,<a id="id368" class="indexterm"/> we are guaranteed that the values of any instance variables in the bean will be consistent across method calls. It is safe to modify any instance variables on a stateful session bean, since they will retain their values for the next method call. The EJB container saves the conversational state by passivating stateful session beans, and retrieves that state when the bean is activated. Conversational state is the reason why the life cycle of stateful session beans is a bit more complex than that of stateless session beans and message driven beans (EJB life cycle is discussed later in this chapter).</p><p>The EJB container may provide any instance of EJB from the pool when an EJB client application requests an instance of a stateless session bean. Since we are not guaranteed the same instance for every method call, values set to any instance variables in a stateless session bean may be "lost" (they are not really lost; the modification is in another instance of the EJB in the pool).</p><p>Other than being decorated with the <code class="literal">@Stateless</code> annotation, there is nothing special about the previous class. Notice that it implements an interface called <code class="literal">SimpleSession</code>. This interface is the bean's business interface. The <code class="literal">SimpleSession</code> interface is shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.Remote;

<span class="strong"><strong>@Remote</strong></span>
public interface SimpleSession
{
  public String getMessage();
}</pre></div><p>The only peculiar thing about this interface is that it is decorated with the <code class="literal">@Remote</code> annotation. This annotation indicates that this is a remote business interface. What this means is that the interface may be in a different JVM than the client application invoking it. Remote business interfaces may even be invoked across the network.</p><p>Business interfaces may also be decorated with the <code class="literal">@Local</code> interface. This annotation indicates that the business interface is a local business interface. Local business interface implementations must be in the same JVM as the client application invoking its methods.</p><p>Since remote business interfaces can be invoked either from the same JVM or a different one than the client application, at first glance, we might be tempted to make all of our business interfaces remote. Before doing so, we must remind ourselves of the fact that the flexibility provided by remote business interfaces comes with a performance penalty, since method invocations are made under the assumption that they will be made across the network. As a matter of fact, most typical Java EE applications consist of web applications acting as client<a id="id369" class="indexterm"/> applications for EJBs; in such cases, the client application and the EJB are running on the same JVM, therefore local interfaces are used a lot more frequently than remote business interfaces.</p><p>Once we have compiled the session bean and its corresponding business interface, we need to place them in a JAR file and deploy them. Just like with WAR files, the easiest way to deploy an EJB JAR file is by copying it to <code class="literal">[glassfish installation directory]/glassfish/domains/domain1/autodeploy</code>.</p><p>Now that we have seen the session bean and its corresponding business interface, let's take a look at a client sample application:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.EJB;

public class SessionBeanClient
{
<span class="strong"><strong>  @EJB</strong></span>
  private static SimpleSession simpleSession;

  private void invokeSessionBeanMethods()
  {
    System.out.println(simpleSession.getMessage());

    System.out.println("\nSimpleSession is of type: "
        + simpleSession.getClass().getName());
  }

  public static void main(String[] args)
  {
    new SessionBeanClient().invokeSessionBeanMethods();
  }

}</pre></div><p>The previous code simply declares an instance variable of the type <code class="literal">net.ensode.SimpleSession</code>, which is the business interface for our session bean. The instance variable is decorated with the <code class="literal">@EJB</code> annotation. The <code class="literal">@EJB</code> annotation lets the EJB container know that this variable is a business interface for a session bean. The EJB container then injects an implementation of the business interface for the client code to use.</p><p>Since our client is a standalone application (as opposed to being a Java EE artifact, such as a WAR file or another EJB JAR file), in order for it to be able to access the code deployed in the server, it must<a id="id370" class="indexterm"/> be placed in a JAR file and executed through the appclient utility. The appclient utility is a GlassFish-specific tool that allows standalone Java applications to access resources deployed to the application server. This utility can be found at <code class="literal">[glassfish installation directory]/glassfish/bin/</code>. Assuming that this directory is in the <code class="literal">PATH</code> environment variable and that we've placed our client code in a JAR file called <code class="literal">simplesessionbeanclient.jar</code>, we will execute the previous client code by typing the following command in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appclient -client simplesessionbeanclient.jar</strong></span>
</pre></div><p>Executing the previous command results in the following console output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>If you don't see this, it didn't work!</strong></span>

<span class="strong"><strong>SimpleSession is of type: net.ensode.glassfishbook._SimpleSession_Wrapper</strong></span>
</pre></div><p>That is the output of the <code class="literal">SessionBeanClient</code> class<a id="id371" class="indexterm"/>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>We are using Maven to build our code. For this example, we used the Maven Assembly plugin (<a class="ulink" href="http://maven.apache.org/plugins/maven-assembly-plugin/">http://maven.apache.org/plugins/maven-assembly-plugin/</a>) to build a client JAR file that includes all dependencies; this frees us from having to specify all the dependent JAR files in the <code class="literal">-classpath</code> command-line option of the <code class="literal">appclient</code> utility. To build this JAR file, simply invoke <code class="literal">mvn assembly:assembly</code> from the command line.</p></div></div><p>The first line of the output is simply the return value of the <code class="literal">getMessage()</code> method we implemented in the session bean. The second line of output displays the fully qualified class name of the class implementing the business interface. Notice that the class name is not the fully qualified name of the session bean we wrote; instead, what is actually provided is an implementation of the business interface created behind the scenes by the EJB container.</p></div><div class="section" title="A more realistic example"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>A more realistic example</h2></div></div></div><p>In the previous section,<a id="id372" class="indexterm"/> we saw a very simple, "Hello world" type of example. In this section, we will show a more realistic example. Session beans are frequently used as <span class="strong"><strong>Data Access Objects</strong></span> (<span class="strong"><strong>DAOs</strong></span>).<a id="id373" class="indexterm"/> Sometimes, they are used as wrappers for JDBC calls and other times, they are used to wrap calls to obtain or modify JPA entities. In this section, we will take the latter approach.</p><p>The following example illustrates how to implement the DAO design pattern in a session bean. Before looking <a id="id374" class="indexterm"/>at the bean implementation, let's look at the business interface it corresponds to:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.Remote;

@Remote
public interface CustomerDao
{
  public void saveCustomer(Customer customer);

  public Customer getCustomer(Long customerId);

  public void deleteCustomer(Customer customer);
}</pre></div><p>As we can see, the previous code is a remote interface implementing three methods: <code class="literal">the saveCustomer()</code> method<a id="id375" class="indexterm"/> saves customer data to the database, the <code class="literal">getCustomer()</code> method<a id="id376" class="indexterm"/> obtains data for a customer from the database, and the <code class="literal">deleteCustomer()</code> method deletes customer data from the database. Two of these methods take an instance of the <code class="literal">Customer</code> entity we developed in <a class="link" href="ch03.html" title="Chapter 3. Object Relational Mapping with JPA">Chapter 3</a>, <span class="emphasis"><em>Object Relational Mapping with JPA</em></span>, as their parameters. The third method, <code class="literal">getCustomer()</code>, takes a <code class="literal">Long</code> value representing the ID of the <code class="literal">Customer</code> object we wish to retrieve from the database.</p><p>Let's now take a look at the session bean implementing the previous business interface. As we are about to see in the following code, there are some differences between the way the JPA code is implemented in a session bean and the way it is implemented in a plain old Java object:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.Stateful;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

@Stateful
public class CustomerDaoBean implements CustomerDao {

    @PersistenceContext
    private EntityManager entityManager;    

    public void saveCustomer(Customer customer) {
        if (customer.getCustomerId() == null) {
            saveNewCustomer(customer);
        } else {
            updateCustomer(customer);
        }
    }

    private void saveNewCustomer(Customer customer) {
        entityManager.persist(customer);
    }

    private void updateCustomer(Customer customer) {
        entityManager.merge(customer);
    }

    public Customer getCustomer(Long customerId) {
        Customer customer;

        customer = entityManager.find(Customer.class, customerId);

        return customer;
    }

    public void deleteCustomer(Customer customer) {
        entityManager.remove(customer);
    }
}</pre></div><p>The main difference between our session bean and previous JPA examples is that JPA calls were wrapped between calls to <code class="literal">UserTransaction.begin()</code> and <code class="literal">UserTransaction.commit()</code>. The reason we had to do this is because JPA calls are required to be wrapped in a <a id="id377" class="indexterm"/>transaction; if they are not wrapped in a transaction, most JPA calls will throw <code class="literal">TransactionRequiredException</code>. In this case we don't have to explicitly wrap JPA calls in a transaction as in previous examples, since session bean methods are implicitly transactional; there is nothing we need to do to make them that way. This default behavior is what is known as <span class="strong"><strong>Container-Managed Transactions</strong></span>. Container-managed transactions are discussed in detail later in this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>As mentioned in <a class="link" href="ch03.html" title="Chapter 3. Object Relational Mapping with JPA">Chapter 3</a>, <span class="emphasis"><em>Object Relational Mapping with JPA</em></span>, when a JPA entity is retrieved from one transaction and updated to a different transaction, the <code class="literal">EntityManager.merge()</code> method needs to be invoked to update the data in the database. Invoking <code class="literal">EntityManager.persist()</code> in this case will result in a <code class="literal">Cannot persist detached object</code> exception.</p></div></div></div><div class="section" title="Invoking session beans from web applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Invoking session beans from web applications</h2></div></div></div><p>Frequently, Java EE applications consist of web applications acting as clients for EJBs. Before Java EE 6, the most common way of deploying a Java EE application that consists of both a web application and <a id="id378" class="indexterm"/>one or more session beans was by packaging both the WAR file for the web application and the EJB JAR files into an EAR (Enterprise Archive) file.</p><p>Java EE 6 simplified the packaging <a id="id379" class="indexterm"/>and deployment of applications consisting of both EJB's and web components.</p><p>In this section, we will develop a JSF application with a CDI named bean acting as a client to the DAO session bean we just discussed in the previous section.</p><p>In order to make this application act as an EJB client, we will develop a <code class="literal">CustomerController</code> named bean so that it delegates the logic to save a new customer to the database to the <code class="literal">CustomerDaoBean</code> session bean we developed in the previous section. We will develop a <code class="literal">CustomerController</code> named bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jsfjpa;

//imports omitted for brevity

@Named
@RequestScoped
public class CustomerController implements Serializable {
    
<span class="strong"><strong>    @EJB</strong></span>
<span class="strong"><strong>    private CustomerDaoBean customerDaoBean;</strong></span>
    
    private Customer customer;
    
    private String firstName;
    private String lastName;
    private String email;
    
    public CustomerController() {
        customer = new Customer();
    }
    
    public String saveCustomer() {
        String returnValue = "customer_saved";
        
        try {
            populateCustomer();
            customerDaoBean.saveCustomer(customer);
        } catch (Exception e) {
            e.printStackTrace();
            returnValue = "error_saving_customer";
        }
        
        return returnValue;
    }
    
    private void populateCustomer() {
        if (customer == null) {
            customer = new Customer();
        }
        customer.setFirstName(getFirstName());
        customer.setLastName(getLastName());
        customer.setEmail(getEmail());
    }
    
//setters and getters omitted for brevity
    
}</pre></div><p>As we can see, all we <a id="id380" class="indexterm"/>had to do was declare an instance of the <code class="literal">CustomerDaoBean</code> session bean and decorate it with the <code class="literal">@EJB</code> annotation so that an instance of the corresponding EJB is injected, and then invoke the EJB <code class="literal">saveCustomer()</code> method.</p><p>Notice that we injected an instance<a id="id381" class="indexterm"/> of the session bean directly into our client code. The reason we can do this is because of a feature introduced in Java EE 6. When using Java EE 6 or newer, we can do away with local interfaces and use session bean instances directly in our client code.</p><p>Now that we have modified our web application to be a client for our session bean, we need to package it in a WAR (web archive) file and deploy it in order to use it.</p></div><div class="section" title="Introduction to singleton session beans"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Introduction to singleton session beans</h2></div></div></div><p>A new type of session bean<a id="id382" class="indexterm"/> that was introduced in <a id="id383" class="indexterm"/>Java EE 6 is the singleton session bean. A single instance of each singleton session bean exists per application.</p><p>Singleton session beans are useful to cache database data. Caching frequently used data in a singleton session bean increases performance, since it greatly minimizes trips to the database. The common pattern is to have a method in our bean decorated with the <code class="literal">@PostConstruct</code> annotation; in <a id="id384" class="indexterm"/>this method, we retrieve <a id="id385" class="indexterm"/>the data we want to cache. Then we provide a setter method for the bean's clients to call. The following example illustrates this technique:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.singletonsession;

import java.util.List;
import javax.annotation.PostConstruct;
import javax.ejb.Singleton;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import net.ensode.glassfishbook.entity.UsStates;

@Singleton
public class SingletonSessionBean implements
    SingletonSessionBeanRemote {

  @PersistenceContext
  private EntityManager entityManager;
  private List&lt;UsStates&gt; stateList;

  @PostConstruct
  public void init() {
    Query query = entityManager.createQuery(
        "Select us from UsStates us");
    stateList = query.getResultList();
  }

  @Override
  public List&lt;UsStates&gt; getStateList() {
    return stateList;
  }
}</pre></div><p>Since our bean is a singleton, all of its clients would access the same instance, avoiding multiple queries to the database. Additionally, since it is a singleton, it is safe to specify an instance variable, as all clients access the same instance of the bean.</p></div><div class="section" title="Asynchronous method calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Asynchronous method calls</h2></div></div></div><p>Sometimes it is useful to <a id="id386" class="indexterm"/>do some processing asynchronously, that is, invoke a method call and return control to the client immediately, without making the client wait for the method to finish.</p><p>In earlier versions of Java EE, the only way to invoke EJB methods asynchronously was using message-driven beans (which is discussed in the next section). Although message-driven beans are fairly easy to write, they do require some configuration before they can be used, such as setting up<a id="id387" class="indexterm"/> JMS message queues or topics.</p><p>EJB 3.1 introduced the <code class="literal">@Asynchronous</code> annotation, <a id="id388" class="indexterm"/>which can be used to mark a method in a session bean as asynchronous. When an EJB client invokes an asynchronous method, control immediately goes back to the client, without waiting for the method to finish.</p><p>Asynchronous methods can only return void or an implementation of the <code class="literal">java.util.concurrent.Future</code> interface. The <code class="literal">Future</code> interface was introduced in Java 5 and represents the result of an asynchronous computation. The following example illustrates both scenarios:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.asynchronousmethods;

import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.ejb.AsyncResult;
import javax.ejb.Asynchronous;
import javax.ejb.Stateless;

@Stateless
public class AsynchronousSessionBean implements
    AsynchronousSessionBeanRemote {

  private static Logger logger = Logger.getLogger(
      AsynchronousSessionBean.class.getName());

<span class="strong"><strong>  @Asynchronous</strong></span>
  @Override
<span class="strong"><strong>  public void slowMethod() {</strong></span>
    long startTime = System.currentTimeMillis();
    logger.info("entering " + this.getClass().getCanonicalName()
        + ".slowMethod()");
    try {
      Thread.sleep(10000); //simulate processing for 10 seconds
    } catch (InterruptedException ex) {
      Logger.getLogger(AsynchronousSessionBean.class.getName()).
          log(Level.SEVERE, null, ex);
    }
    logger.info("leaving " + this.getClass().getCanonicalName()
        + ".slowMethod()");
    long endTime = System.currentTimeMillis();
    logger.info("execution took " + (endTime - startTime)
        + " milliseconds");
  }

<span class="strong"><strong>  @Asynchronous</strong></span>
  @Override
<span class="strong"><strong>  public Future&lt;Long&gt; slowMethodWithReturnValue() {</strong></span>
    try {
      Thread.sleep(15000); //simulate processing for 15 seconds
    } catch (InterruptedException ex) {
      Logger.getLogger(AsynchronousSessionBean.class.getName()).
          log(Level.SEVERE, null, ex);
    }

    return new AsyncResult&lt;Long&gt;(42L);
  }
}</pre></div><p>When our asynchronous method returns void, the only thing we need to do is decorate the method with the <code class="literal">@Asynchronous</code> annotation<a id="id389" class="indexterm"/>, then call it as usual from the client code.</p><p>If we need a return value, this <a id="id390" class="indexterm"/>value needs to be wrapped in<a id="id391" class="indexterm"/> an implementation of the <code class="literal">jav.util.concurrent.Future</code> interface. The Java EE API provides a convenience implementation in the form of the <code class="literal">javax.ejb.AsyncResult</code> class. Both the <code class="literal">Future</code> interface and the <code class="literal">AsyncResult</code> class use generics, so we need to specify our return type as the type parameter of these artifacts.</p><p>The <code class="literal">Future</code> interface has several methods we can use to cancel the execution of an asynchronous method, check to see whether or not the method is finished, get the return value of the method, and check to see whether or not the method is canceled. The following table lists these methods:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cancel(boolean mayInterruptIfRunning)</code><a id="id392" class="indexterm"/>
<code class="literal"> </code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method cancels method execution. If the boolean parameter is <code class="literal">true</code>, this method will attempt to cancel the method execution even if it is already running.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">get()</code><a id="id393" class="indexterm"/>
<code class="literal"> </code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method will return the "unwrapped" return value of the method; it will be of the type parameter of the <code class="literal">Future</code> interface implementation returned by the method.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">get(long timeout, TimeUnit unit)</code><a id="id394" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This method will attempt to get the <code class="literal">unwrapped</code> return value of the method; the return value will be of the type parameter of the <code class="literal">Future</code> interface implementation returned by the method. This method will block for the amount of time specified by the first parameter. The unit of time to wait is determined by the second parameter, the <code class="literal">TimeUnit</code> enum has constants for NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, and so on. Refer to its Javadoc documentation for the complete list.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">isCancelled() </code><a id="id395" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This method returns <code class="literal">true</code> if the method has been cancelled; otherwise, it returns <code class="literal">false</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">isDone() </code><a id="id396" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This method returns <code class="literal">true</code> if the method has finished executing; otherwise, it returns <code class="literal">false</code>.</p>
</td></tr></tbody></table></div><p>As we can see, the <code class="literal">@Asynchronous</code> annotation makes it very easy to make asynchronous calls without suffering<a id="id397" class="indexterm"/> the overhead of having to set up message queues or topics. It is certainly a welcome addition to the EJB specification.</p></div></div></div>
<div class="section" title="Message-driven beans"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Message-driven beans</h1></div></div></div><p>The <span class="strong"><strong>Java Message Service</strong></span> (<span class="strong"><strong>JMS</strong></span>) is a Java EE API used for asynchronous communication between different applications. JMS messages are stored in either message queues <a id="id398" class="indexterm"/>or message topics.</p><p>The purpose of a message-driven bean is to consume messages from a JMS queue or a JMS topic, depending on the messaging domain used (refer to <a class="link" href="ch08.html" title="Chapter 8. The Java Message Service">Chapter 8</a>, <span class="emphasis"><em>The Java Message Service</em></span>). A message-driven bean must be decorated with the <code class="literal">@MessageDriven</code> annotation. The <code class="literal">mappedName</code> attribute<a id="id399" class="indexterm"/> of this annotation must contain the JNDI name of the JMS message queue or JMS message topic that the bean will be consuming messages from. The following example illustrates a simple message driven bean:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.MessageDriven;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

<span class="strong"><strong>@MessageDriven(mappedName = "jms/GlassFishBookQueue")</strong></span>
public class ExampleMessageDrivenBean implements MessageListener
{
  public void onMessage(Message message)
  {
    TextMessage textMessage = (TextMessage) message;
    try
    {
      System.out.print("Received the following message: ");
      System.out.println(textMessage.getText());
      System.out.println();
    }
    catch (JMSException e)
    {
      e.printStackTrace();
    }
  }
}</pre></div><p>It is recommended, but not required, for message-driven beans to implement the <code class="literal">javax.jms.MessageListener</code> interface. <a id="id400" class="indexterm"/>However, message-driven beans must have a method called <code class="literal">onMessage()</code> whose signature is identical to that in the previous example.</p><p>Client applications never invoke a message-driven bean's methods directly. Instead, they put messages in a message queue or topic, then the bean consumes those messages and acts appropriately. The previous example simply prints the message to standard output, since message-driven beans execute within an EJB container; standard output gets redirected to a log. To see the messages in the GlassFish's server log, open the <code class="literal">[GlassFish installation directory]/glassfish/domains/domain1/logs/server.log</code> file.</p></div>
<div class="section" title="Transactions in Enterprise JavaBeans"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Transactions in Enterprise JavaBeans</h1></div></div></div><p>As we mentioned <a id="id401" class="indexterm"/>earlier in this chapter, by default, all EJB methods are automatically wrapped in a transaction. This default behavior is known as <span class="strong"><strong>Container-managed transactions</strong></span>, <a id="id402" class="indexterm"/>since transactions are managed<a id="id403" class="indexterm"/> by the EJB container. Application developers may also choose to manage transactions themselves; this can be accomplished using bean-managed transactions. Both of these approaches are discussed in the following sections.</p><div class="section" title="Container-managed transactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Container-managed transactions</h2></div></div></div><p>Because EJB methods are transactional by default, we run into an interesting dilemma when an EJB method is invoked from client code that is already in a transaction. How should the EJB container behave? Should it suspend the client transaction, execute its method in a new transaction, then resume the client transaction? Should it not create a new transaction and execute its method <a id="id404" class="indexterm"/>as part of the client transaction? Should it throw an exception?</p><p>By default, if an EJB method is invoked by a client code that is already in a transaction, the EJB container will simply execute the session bean method as part of the client transaction. If this is not the behavior we need, <a id="id405" class="indexterm"/>we can change it by decorating the method with the <code class="literal">@TransactionAttribute</code> annotation. This annotation has a <code class="literal">value</code> attribute that determines how the EJB container will behave when the session bean method is invoked within an existing transaction and also when it is invoked outside any transactions. The value of the <code class="literal">value</code> attribute is typically a constant defined in the <code class="literal">javax.ejb.TransactionAttributeType</code> enum. </p><p>The following table lists the possible values for the<a id="id406" class="indexterm"/> <code class="literal">@TransactionAttribute</code> annotation:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>@TransactionAttribute value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransactionAttributeType.MANDATORY</code><a id="id407" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Forces <a id="id408" class="indexterm"/>the method to be invoked as part of a client transaction. If this method is called outside any transactions, it will throw a <code class="literal">TransactionRequiredException</code> exceptiom</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransactionAttributeType.NEVER</code><a id="id409" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The method<a id="id410" class="indexterm"/> is never executed in a transaction. If it is invoked as part of a client transaction, it will throw a <code class="literal">RemoteException</code> exception No transaction is created if the method is not invoked within a client transaction.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransactionAttributeType.NOT_SUPPORTED</code><a id="id411" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The method is invoked as part of a client transaction,<a id="id412" class="indexterm"/> the client transaction is suspended and the method is executed outside any transaction. After the method is executed, the client transaction is resumed. No transaction is created if the method is not invoked within the client transaction.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransactionAttributeType.REQUIRED</code><a id="id413" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The method is<a id="id414" class="indexterm"/> invoked as part of a client transaction, it is executed as part of that transaction. If the method is invoked outside a transaction, a new transaction is created for the method. This is the default behavior.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransactionAttributeType.REQUIRES_NEW</code><a id="id415" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The method<a id="id416" class="indexterm"/> is invoked as part of a client transaction, that transaction is suspended, and a new transaction is created for the method. Once the method executes, the client transaction is resumed. If the method is called outside a transaction, a new transaction is created for the method.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransactionAttributeType.SUPPORTS</code><a id="id417" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The method is<a id="id418" class="indexterm"/> invoked as part of a client transaction, it is executed as part of that transaction. If the method is invoked outside a transaction, no new transaction is created for the method.</p>
</td></tr></tbody></table></div><p>Although the default transaction attribute is reasonable in most cases, it is good to be able to override this default<a id="id419" class="indexterm"/> if necessary. For example, transactions have a performance impact. Therefore, being able to turn off transactions for a method that does not need them is beneficial. For a case like this, we<a id="id420" class="indexterm"/> would decorate our method, as illustrated in the following code snippet:</p><div class="informalexample"><pre class="programlisting">@TransactionAttribute(value=TransactionAttributeType.NEVER)
public void doitAsFastAsPossible()
{
  //performance critical code goes here.
}</pre></div><p>Other transaction attribute types can be declared by annotating the methods with the corresponding constant in the <code class="literal">TransactionAttributeType</code> enum.</p><p>If we wish to override the default transaction attribute consistently across all methods in a session bean, we can decorate the session bean class with the <code class="literal">@TransactionAttribute</code> annotation; the value of its <code class="literal">value</code> attribute will be applied to every method in the session bean.</p><p>Container-managed transactions are automatically rolled back whenever an exception is thrown within an EJB method. Additionally, we can programmatically roll back a container-managed transaction <a id="id421" class="indexterm"/>by invoking the <code class="literal">setRollbackOnly()</code> method on an instance of <code class="literal">javax.ejb.EJBContext</code> corresponding<a id="id422" class="indexterm"/> to the session bean in question. The following example is a new version of the session bean we saw earlier in this chapter, modified to roll back transactions if necessary:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

//imports omitted

@Stateless
public class CustomerDaoRollbackBean implements CustomerDaoRollback
{
<span class="strong"><strong>  @Resource</strong></span>
<span class="strong"><strong>  private EJBContext ejbContext;</strong></span>

  @PersistenceContext
  private EntityManager entityManager;

  @Resource(name = "jdbc/__CustomerDBPool")
  private DataSource dataSource;

  public void saveNewCustomer(Customer customer)
  {
<span class="strong"><strong>    if (customer == null || customer.getCustomerId() != null)</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      ejbContext.setRollbackOnly();</strong></span>
<span class="strong"><strong>    }</strong></span>
    else
    {
      customer.setCustomerId(getNewCustomerId());
      entityManager.persist(customer);
    }
  }

  public void updateCustomer(Customer customer)
  {
<span class="strong"><strong>    if (customer == null || customer.getCustomerId() == null)</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      ejbContext.setRollbackOnly();</strong></span>
<span class="strong"><strong>    }</strong></span>
    else
    {
      entityManager.merge(customer);
    }
  }
//Additional methods omitted for brevity.
  
}</pre></div><p>In this version of the DAO session bean, we deleted the <code class="literal">saveCustomer()</code> method<a id="id423" class="indexterm"/> and made the <code class="literal">saveNewCustomer()</code><a id="id424" class="indexterm"/> and <code class="literal">updateCustomer()</code> methods<a id="id425" class="indexterm"/> public. Each of these methods now checks to see whether or not the <code class="literal">customerId</code> field is set correctly for the operation we are trying to perform (<code class="literal">null</code> for inserts and not <code class="literal">null</code> for updates). It also checks to make <a id="id426" class="indexterm"/>sure the object to be persisted is not <code class="literal">null</code>. If any of the checks result in invalid data, the method <a id="id427" class="indexterm"/>simply rolls back the transaction by invoking the <code class="literal">setRollBackOnly()</code> method<a id="id428" class="indexterm"/> on the injected instance of <code class="literal">EJBContext</code> and does not update the database.</p></div><div class="section" title="Bean-managed transactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Bean-managed transactions</h2></div></div></div><p>As we have seen, container-managed transactions make it ridiculously easy to write code that is wrapped in a transaction. After <a id="id429" class="indexterm"/>all, there is nothing special that we need to do to make them that way; as a matter of fact, some developers are sometimes not even aware that they are writing code that will be transactional in nature when they develop session beans. Container-managed transactions cover most of the typical cases that we will encounter. However, they do have a limitation: <a id="id430" class="indexterm"/>each method can be wrapped in at most a single transaction. With container-managed transactions, it is not possible to implement a method that generates more than one transaction, this can be accomplished using bean-managed transactions, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import javax.annotation.Resource;
import javax.ejb.Stateless;
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.persistence.EntityManager;

//imports omitted 

@Stateless
<span class="strong"><strong>@TransactionManagement(value = TransactionManagementType.BEAN)</strong></span>
public class CustomerDaoBmtBean implements CustomerDaoBmt
{
<span class="strong"><strong>  @Resource</strong></span>
<span class="strong"><strong>  private UserTransaction userTransaction;</strong></span>

  @PersistenceContext
  private EntityManager entityManager;

  @Resource(name = "jdbc/__CustomerDBPool")
  private DataSource dataSource;

  public void saveMultipleNewCustomers(
      List&lt;Customer&gt; customerList)
  {
    for (Customer customer : customerList)
    {
      try
      {
<span class="strong"><strong>        userTransaction.begin();</strong></span>
        customer.setCustomerId(getNewCustomerId());
        entityManager.persist(customer);
<span class="strong"><strong>        userTransaction.commit();</strong></span>
      }
      catch (Exception e)
      {
        e.printStackTrace();
      }
    }
  }

  private Long getNewCustomerId()
  {
    Connection connection;
    Long newCustomerId = null;
    try
    {
      connection = dataSource.getConnection();
      PreparedStatement preparedStatement = 
          connection.prepareStatement("select " +
          "max(customer_id)+1 as new_customer_id " + 
          "from customers");

      ResultSet resultSet = preparedStatement.executeQuery();

      if (resultSet != null &amp;&amp; resultSet.next())
      {
        newCustomerId = resultSet.getLong("new_customer_id");
      }

      connection.close();
    }
    catch (SQLException e)
    {
      e.printStackTrace();
    }

    return newCustomerId;
  }
}</pre></div><p>In this example, we implemented a method named <code class="literal">saveMultipleNewCustomers()</code>.<a id="id431" class="indexterm"/> This method takes a <code class="literal">List</code> of customers as its sole parameter. The intention of this method is to save as many elements in <code class="literal">ArrayList</code> as possible. An exception saving one of the entities should not stop the method from attempting to save the remaining elements. This behavior is<a id="id432" class="indexterm"/> not possible using container-managed transactions, since if an exception is thrown when saving one of the entities it would roll back the whole transaction. The only way to achieve this behavior<a id="id433" class="indexterm"/> is through bean-managed transactions.</p><p>As shown in the previous example, we declare that the session bean uses bean-managed transactions by decorating the class with the <code class="literal">@TransactionManagement</code> annotation<a id="id434" class="indexterm"/>, and using <code class="literal">TransactionManagementType.BEAN</code> as the value for its <code class="literal">value</code> attribute (the only other valid value for this attribute is <code class="literal">TransactionManagementType.CONTAINER</code>, but since this is the default value, it is not necessary to specify it).</p><p>To be able to programmatically control transactions, we inject an instance of <code class="literal">javax.transaction.UserTransaction</code>, which is then used in the <code class="literal">for</code> loop within the <code class="literal">saveMultipleNewCustomers()</code> method<a id="id435" class="indexterm"/> to begin and commit transactions in each iteration of the loop.</p><p>If we need to roll back a bean-managed transaction, we can do so by simply calling the <code class="literal">rollback()</code> method<a id="id436" class="indexterm"/> on the appropriate instance of <code class="literal">javax.transaction.UserTransaction</code>.</p><p>Before moving on, it is worth noting that even though all the examples in this section were implemented as session beans, the <a id="id437" class="indexterm"/>concepts apply to message-driven beans as well.</p></div></div>
<div class="section" title="Enterprise JavaBean life cycles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Enterprise JavaBean life cycles</h1></div></div></div><p>Enterprise JavaBeans go through different states in their life cycle. Each type of EJB has different states. States specific <a id="id438" class="indexterm"/>to each type of EJB are discussed in the next sections.</p><div class="section" title="The stateful session bean life cycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>The stateful session bean life cycle</h2></div></div></div><p>Readers with experience in previous versions of J2EE may remember that in previous versions of the specification, <a id="id439" class="indexterm"/>session beans were required to implement the <code class="literal">javax.ejb.SessionBean</code> interface. This interface provided methods to be executed at certain points in the session bean's life cycle. Methods provided by the <code class="literal">SessionBean</code> interface include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ejbActivate()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ejbPassivate()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ejbRemove()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setSessionContext(SessionContext ctx)</code></li></ul></div><p>The first three methods were <a id="id440" class="indexterm"/>meant to be executed at certain points in the bean's life cycle. In most cases, there was nothing to do in the implementation of these methods. This fact resulted in the vast majority of session beans implementing empty versions of these methods. Thankfully, starting with Java EE 5, it is no longer necessary to implement the <code class="literal">SessionBean</code> interface, however, if necessary, we can still write methods that will get executed at certain points in the bean's<a id="id441" class="indexterm"/> life cycle. We can achieve this by decorating methods with specific annotations.</p><p>Before explaining the annotations available to implement life cycle methods, a brief explanation of the session bean life cycle is in order. The life cycle of a stateful session bean is different from that of a stateless session bean.</p><p>A stateful session bean's life cycle contains three states: <a id="id442" class="indexterm"/>
<span class="strong"><strong>Does Not Exist</strong></span>, <span class="strong"><strong>Ready</strong></span>, and <a id="id443" class="indexterm"/>
<span class="strong"><strong>Passive</strong></span>, <a id="id444" class="indexterm"/>as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/6886_04_01.jpg" alt="The stateful session bean life cycle"/></div><p>Before a stateful session bean is deployed, it is in the Does Not Exist state. Upon successful deployment, the EJB container does any required dependency injections for the bean and the bean goes <a id="id445" class="indexterm"/>into the Ready state. At this point, the bean is ready to have its methods called by a client application.</p><p>When a stateful session bean is in Ready state, the EJB container may decide to passivate it, that is, to move it from main memory to secondary storage. When this happens, the bean goes into<a id="id446" class="indexterm"/> <span class="strong"><strong>Passive</strong></span> state<a id="id447" class="indexterm"/>. If an instance of a stateful session bean hasn't been accessed for a period of time, the EJB container will set the bean to the Does Not Exist state. By default, GlassFish will send a stateful session bean to the Does Not Exist state after 90 minutes of inactivity. This default<a id="id448" class="indexterm"/> can be changed by going through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Log in to the GlassFish administration console.</li><li class="listitem">Expand the <span class="strong"><strong>Configuration</strong></span> node in the tree to the left-hand side.</li><li class="listitem">Expand the <span class="strong"><strong>server-config</strong></span> node.</li><li class="listitem">Click on the <span class="strong"><strong>EJB Container</strong></span> node.</li><li class="listitem">Scroll down towards the bottom of the page and modify the value of the <span class="strong"><strong>Removal Timeout</strong></span> text field.</li><li class="listitem">Click on the <span class="strong"><strong>Save</strong></span> button, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="graphics/6886_04_02.jpg" alt="The stateful session bean life cycle"/></div><p>This technique sets the timeout value for all stateful session beans. If we need to modify the timeout value for a <a id="id449" class="indexterm"/>specific session bean, we need to include a <code class="literal">glassfish-ejb-jar.xml</code> deployment descriptor in the JAR file containing the session bean. In this deployment descriptor, we can set the timeout <a id="id450" class="indexterm"/>value as the value of the <code class="literal">&lt;removal-timeout-in-seconds&gt;</code> element, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt;
&lt;glassfish-ejb-jar&gt;
  &lt;enterprise-beans&gt;
    &lt;ejb&gt;
<span class="strong"><strong>      &lt;ejb-name&gt;MyStatefulSessionBean&lt;/ejb-name&gt;</strong></span>
      &lt;bean-cache&gt;
<span class="strong"><strong>          &lt;removal-timeout-in-seconds&gt;</strong></span>
<span class="strong"><strong>              600</strong></span>
<span class="strong"><strong>          &lt;/removal-timeout-in-seconds&gt;</strong></span>
      &lt;/bean-cache&gt;
    &lt;/ejb&gt;
  &lt;/enterprise-beans&gt;
&lt;/glassfish-ejb-jar&gt;</pre></div><p>Even though we are not required to create an <code class="literal">ejb-jar.xml</code> file for our session beans anymore (which used to be the case in previous versions of the J2EE specification), we can still write one if we wish to. The <code class="literal">&lt;ejb-name&gt;</code> element in the <code class="literal">glassfish-ejb-jar.xml</code> deployment descriptor must match the value of the element of the same name in <code class="literal">ejb-jar.xml</code>. If we choose not to create an <code class="literal">ejb-jar.xml</code> file, this value must match the name of the EJB class. The timeout value for the stateful session bean must be the value of the <code class="literal">&lt;removal-timeout-in-seconds&gt;</code> element; as the name of the element suggests, the unit of time to use is seconds. In the previous example, we set the timeout value to 600 seconds, or 10 minutes.</p><p>Any methods in a stateful session bean decorated with the <code class="literal">@PostActivate</code> annotation will be invoked just after the stateful session bean has been activated. This is equivalent to implementing the <code class="literal">ejbActivate()</code> method<a id="id451" class="indexterm"/> in previous versions of J2EE. Similarly, any method decorated with the <code class="literal">@PrePassivate</code> annotation will be invoked just before the stateful session bean <a id="id452" class="indexterm"/>is passivated; this is equivalent to implementing the <code class="literal">ejbPassivate()</code> method in previous versions of J2EE.</p><p>When a stateful session bean in the Ready state times out and is sent to the Does not Exist state, any <a id="id453" class="indexterm"/>method decorated with the <code class="literal">@PreDestroy</code> annotation is executed. If the session bean times out in the Passive state, methods decorated with the <code class="literal">@PreDestroy</code> annotation are not executed. Additionally, if a client of the stateful session bean executes a method decorated with the <code class="literal">@Remove</code> annotation, all methods decorated with the <code class="literal">@PreDestroy</code> annotation are executed and the bean is marked for garbage collection. Decorating a method with the <code class="literal">@Remove</code> annotation is equivalent to implementing the <code class="literal">ejbRemove()</code> method<a id="id454" class="indexterm"/> in previous versions of the J2EE specification.</p><p>The <code class="literal">@PostActivate</code>,<a id="id455" class="indexterm"/> <code class="literal">@PrePassivate</code>,<a id="id456" class="indexterm"/> and <code class="literal">@Remove</code> annotations<a id="id457" class="indexterm"/> are valid only for stateful session beans, whereas the <code class="literal">@PreDestroy</code> and <code class="literal">@PostConstruct</code> annotations are valid for stateful session beans, stateless session beans, and message-driven beans.</p></div><div class="section" title="The stateless session bean life cycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>The stateless session bean life cycle</h2></div></div></div><p>A stateless session <a id="id458" class="indexterm"/>bean life cycle contains only the <a id="id459" class="indexterm"/>
<span class="strong"><strong>Does Not Exist</strong></span><a id="id460" class="indexterm"/> and <a id="id461" class="indexterm"/>
<span class="strong"><strong>Ready</strong></span> <a id="id462" class="indexterm"/>states, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/6886_04_03.jpg" alt="The stateless session bean life cycle"/></div><p>Stateless session beans are never passivated. A stateless session bean's methods can be decorated with the <code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> annotations. Just like with stateful session beans, any <a id="id463" class="indexterm"/>methods decorated with the <code class="literal">@PostConstruct</code> annotation will be executed when the stateless session bean goes from the Does Not Exist to the Ready State, and any methods decorated with the <code class="literal">@PreDestroy</code> annotation will be executed when a stateless session<a id="id464" class="indexterm"/> bean goes from the Ready state to the Does Not Exist state. Stateless session beans are never passivated, any <code class="literal">@PrePassivate</code> and <code class="literal">@PostActivate</code> annotations in a stateless session bean are simply ignored by the EJB container.</p><p>Just like with stateful session beans, we can control how GlassFish manages the life cycle of stateless session beans (and message-driven beans) via<a id="id465" class="indexterm"/> the administration web console, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886_04_04.jpg" alt="The stateless session bean life cycle"/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Initial and Minimum Pool Size</strong></span> refers to the minimum number of beans in the pool</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Maximum Pool Size</strong></span> refers to the maximum number of beans in the pool</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pool Resize Quantity</strong></span> refers to how many beans will be removed from the pool when the <span class="strong"><strong>Pool Idle Timeout</strong></span> value expires</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pool Idle Timeout</strong></span> refers to the number of seconds of inactivity to let pass before removing beans from the pool</li></ul></div><p>The previous settings affect all <code class="literal">poolable</code> EJBs, such as stateless session beans and message-driven beans. Just as with stateful session beans, these settings can be overridden on a case-by-case basis by adding a GlassFish specific <code class="literal">glassfish-ejb-jar.xml</code> deployment descriptor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt;
&lt;glassfish-ejb-jar&gt;
    &lt;enterprise-beans&gt;
        &lt;ejb&gt;
            &lt;ejb-name&gt;MyStatelessSessionBean&lt;/ejb-name&gt;
            &lt;bean-pool&gt;
                &lt;steady-pool-size&gt;10&lt;/steady-pool-size&gt;
                &lt;max-pool-size&gt;60&lt;/max-pool-size&gt;
                &lt;resize-quantity&gt;5&lt;/resize-quantity&gt;
                &lt;pool-idle-timeout-in-seconds&gt;
                    900
                &lt;/pool-idle-timeout-in-seconds&gt;
            &lt;/bean-pool&gt;
        &lt;/ejb&gt;
    &lt;/enterprise-beans&gt;
&lt;/glassfish-ejb-jar&gt;</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;steady-pool-size&gt;</code> line corresponds to <span class="strong"><strong>Initial and Minimum Pool Size</strong></span> in the GlassFish web console</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;max-pool-size&gt;</code> line corresponds to <span class="strong"><strong>Maximum Pool Size</strong></span> in the GlassFish web console</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;resize-quantity&gt;</code> line <a id="id466" class="indexterm"/>corresponds to <span class="strong"><strong>Pool Resize Quantity</strong></span> in the GlassFish web console</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;pool-idle-timeout-in-seconds&gt;</code> line corresponds to <span class="strong"><strong>Pool Idle Timeout</strong></span> in the GlassFish web <a id="id467" class="indexterm"/>console</li></ul></div></div><div class="section" title="Message-driven bean life cycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Message-driven bean life cycle</h2></div></div></div><p>Just like stateless session <a id="id468" class="indexterm"/>beans, <a id="id469" class="indexterm"/>message-driven beans exist only in the Does Not Exist and Ready states, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/6886_04_03.jpg" alt="Message-driven bean life cycle"/></div><p>The above image is exactly<a id="id470" class="indexterm"/> the same as the previous one. Message-driven beans have the same life cycle as stateless session beans. Therefore, the image to illustrate the life cycle was re-used.</p><p>A message-driven bean can <a id="id471" class="indexterm"/>have methods decorated with the <code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> methods. Methods decorated with the <code class="literal">@PostConstruct</code> method<a id="id472" class="indexterm"/> are executed just before the bean goes into the Ready state. Methods decorated with the <code class="literal">@PreDestroy</code> annotation<a id="id473" class="indexterm"/> are executed just before the bean goes to the Does Not Exist state.</p></div></div>
<div class="section" title="Introduction to the EJB Timer Service"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Introduction to the EJB Timer Service</h1></div></div></div><p>Stateless session beans and message-driven beans can have a method that is executed periodically at regular intervals of time. This can be accomplished using the <span class="strong"><strong>EJB Timer Service</strong></span>. The following example <a id="id474" class="indexterm"/>illustrates how to take advantage of this feature:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

//imports omitted

@Stateless
public class EjbTimerExampleBean implements EjbTimerExample
{
  private static Logger logger = Logger.getLogger(EjbTimerExampleBean.class
      .getName());
  @Resource
  TimerService timerService;

  public void startTimer(Serializable info)
  {
    Timer timer = timerService.createTimer
      (new Date(), 5000, info);
  }

  public void stopTimer(Serializable info)
  {
    Timer timer;
    Collection timers = timerService.getTimers();

    for (Object object : timers)
    {
      timer = ((Timer) object);

      if (timer.getInfo().equals(info))
      {
        timer.cancel();
        break;
      }
    }
  }

  @Timeout
  public void logMessage(Timer timer)
  {
    logger.info("This message was triggered by :" +
        timer.getInfo() + " at "
        + System.currentTimeMillis());
  }
}</pre></div><p>In our example, we injected an implementation of the <code class="literal">javax.ejb.TimerService</code> interface by decorating an instance variable of this type with the <code class="literal">@Resource</code> annotation. We then created a<a id="id475" class="indexterm"/> timer by invoking the <code class="literal">createTimer()</code> method of the <code class="literal">TimerService</code> instance.</p><p>There are several overloaded versions of the <code class="literal">createTimer()</code> method. The one we chose to use takes an instance of <code class="literal">java.util.Date</code> as its first parameter; this parameter is used to indicate the first time the timer should expire (go off). In the example, we chose to use a brand new instance of the <code class="literal">Date</code> class, which, in effect, makes the timer expire immediately. The second parameter of the <code class="literal">createTimer()</code> method<a id="id476" class="indexterm"/> is the amount of time to wait, in milliseconds, before the timer expires again. In our example, the timer is set to expire every five seconds. The third parameter of the <code class="literal">createTimer()</code> method can be an instance of any class implementing the <code class="literal">java.io.Serializable</code> interface. Since a single EJB can have several timers executing concurrently, this third parameter is used to uniquely identify each of the timers. If we don't need to identify the timers, <code class="literal">null</code> can be passed as a value<a id="id477" class="indexterm"/> for this parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>The EJB method invoking <code class="literal">TimerService.createTimer()</code> must be called from an EJB client. Placing this call in an EJB method decorated with the <code class="literal">@PostConstruct</code> annotation to start the timer automatically when the bean is placed in the Ready state w<a id="id478" class="indexterm"/>ill result in an <code class="literal">IllegalStateException</code> exception to be thrown.</p></div></div><p>We can stop a timer by invoking its <code class="literal">cancel()</code> method<a id="id479" class="indexterm"/>. There is no way to directly obtain a single timer associated with an EJB. What we need to do is invoke the <code class="literal">getTimers()</code> method<a id="id480" class="indexterm"/> on the instance of <code class="literal">TimerService</code> that is linked to the EJB; this method will return a Collection containing all the timers associated with the EJB. We can then iterate through the collection and cancel the correct one by invoking its <code class="literal">getInfo()</code> method<a id="id481" class="indexterm"/>. This method will return the <code class="literal">Serializable</code> object we passed as a parameter to the <code class="literal">createTimer()</code> method<a id="id482" class="indexterm"/>.</p><p>Finally, any EJB method decorated with the <code class="literal">@Timeout</code> annotation will be executed when a timer expires. Methods decorated with this annotation must return void and take a single parameter of type <code class="literal">javax.ejb.Timer</code>. In our example, the method simply writes a message to the server log.</p><p>The following class is a standalone client for the previous EJB:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.EJB;

public class Client
{
  @EJB
  private static EjbTimerExample ejbTimerExample;

  public static void main(String[] args)
  {
    try
    {
      System.out.println("Starting timer 1...");
<span class="strong"><strong>      ejbTimerExample.startTimer("Timer 1");</strong></span>
      System.out.println("Sleeping for 2 seconds...");
      Thread.sleep(2000);
      System.out.println("Starting timer 2...");
<span class="strong"><strong>      ejbTimerExample.startTimer("Timer 2");</strong></span>
      System.out.println("Sleeping for 30 seconds...");
      Thread.sleep(30000);
      System.out.println("Stopping timer 1...");
<span class="strong"><strong>      ejbTimerExample.stopTimer("Timer 1");</strong></span>
      System.out.println("Stopping timer 2...");
<span class="strong"><strong>      ejbTimerExample.stopTimer("Timer 2");</strong></span>
      System.out.println("Done.");
    }
    catch (InterruptedException e)
    {
      e.printStackTrace();
    }
  }
}</pre></div><p>The previous example simply <a id="id483" class="indexterm"/>starts a timer, waits for a couple of seconds, and then starts a second timer. It then sleeps for 30 seconds and then stops both timers. After deploying the EJB and executing the client, we should see some entries like the following in the server log:</p><div class="informalexample"><pre class="programlisting">[2013-08-26T20:44:55.180-0400] [glassfish 4.0] [INFO] [] [net.ensode.glassfishbook.EjbTimerExampleBean] [tid: _ThreadID=147 _ThreadName=__ejb-thread-pool1] [timeMillis: 1377564295180] [levelValue: 800] [[

  This message was triggered by :Timer 1 at 1377564295180]]


[2013-08-26T20:44:57.203-0400] [glassfish 4.0] [INFO] [] [net.ensode.glassfishbook.EjbTimerExampleBean] [tid: _ThreadID=148 _ThreadName=__ejb-thread-pool2] [timeMillis: 1377564297203] [levelValue: 800] [[

  This message was triggered by :Timer 2 at 1377564297203]]


[2013-08-26T20:44:58.888-0400] [glassfish 4.0] [INFO] [] [net.ensode.glassfishbook.EjbTimerExampleBean] [tid: _ThreadID=149 _ThreadName=__ejb-thread-pool3] [timeMillis: 1377564298888] [levelValue: 800] [[

  This message was triggered by :Timer 1 at 1377564298888]]


[2013-08-26T20:45:01.156-0400] [glassfish 4.0] [INFO] [] [net.ensode.glassfishbook.EjbTimerExampleBean] [tid: _ThreadID=150 _ThreadName=__ejb-thread-pool4] [timeMillis: 1377564301156] [levelValue: 800] [[

  This message was triggered by :Timer 2 at 1377564301156]]</pre></div><p>These entries are <a id="id484" class="indexterm"/>created each time one of the timers expires.</p><div class="section" title="Calendar-based EJB timer expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Calendar-based EJB timer expressions</h2></div></div></div><p>The example in the previous section has one disadvantage: the <code class="literal">startTimer()</code> method in the session bean must be invoked<a id="id485" class="indexterm"/> from a client in order to start the timer. This restriction makes it difficult to have the timer start as soon as the bean is deployed.</p><p>Java EE 6 introduced<a id="id486" class="indexterm"/> calendar-based EJB timer expressions. Calendar-based expressions allow one or more methods in our session beans to be executed at a certain date and time. For example, we could configure one of our methods to be executed every night at 8:10 p.m., which is exactly what the following example does:</p><div class="informalexample"><pre class="programlisting">package com.ensode.glassfishbook.calendarbasedtimer;

import java.util.logging.Logger;
import javax.ejb.Stateless;
import javax.ejb.LocalBean;
import javax.ejb.Schedule;

@Stateless
@LocalBean
public class CalendarBasedTimerEjbExampleBean {

  private static Logger logger = Logger.getLogger(
      CalendarBasedTimerEjbExampleBean.class.getName());

<span class="strong"><strong>  @Schedule(hour = "20", minute = "10")</strong></span>
  public void logMessage() {
    logger.info("This message was triggered at:"
        + System.currentTimeMillis());
  }
}</pre></div><p>As you can see in this example, we set up the time when the method will be executed via the <code class="literal">javax.ejb.Schedule</code> annotation. In this particular example, we set up our method to be executed at 8:10 p.m. by setting the <code class="literal">hour</code> attribute of the <code class="literal">@Schedule</code> annotation to <code class="literal">"20"</code>, and its minute attribute to <code class="literal">"10"</code>. The value of the <code class="literal">hour</code> attribute is 24 hour based; hour 20 is equivalent to 8:00 p.m.</p><p>The <code class="literal">@Schedule</code> annotation<a id="id487" class="indexterm"/> has several other attributes that allows a lot of flexibility in specifying when the method should be executed; we could, for instance, have a method being executed on the third Friday <a id="id488" class="indexterm"/>of every month, or the last day of the month, and so on and so forth.</p><p>The following table lists all the attributes in the <code class="literal">@Schedule</code> annotation that allow us to control when the annotated method will be executed:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Example values</p>
</th><th style="text-align: left" valign="bottom">
<p>Default value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dayOfMonth</code><a id="id489" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The day of the month.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"3"</code>: the third day of the month</p>
<p>
<code class="literal">"Last"</code>: the last day of the month</p>
<p>
<code class="literal">"-2"</code>: two days before the end of the month</p>
<p>
<code class="literal">"1st Tue"</code>: the first Tuesday of the month</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"*"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dayOfWeek</code><a id="id490" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The day of the week</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"3"</code>: every Wednesday</p>
<p>
<code class="literal">"Thu"</code>: every Thursday</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"*"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">hour</code><a id="id491" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The hour of the day (24 hour based)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"14"</code>: 2:00 p.m.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"0"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">minute</code><a id="id492" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The minute of the hour</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"10"</code>: ten minutes after the hour</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"0"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">month</code><a id="id493" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The month of the year</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"2"</code>: February</p>
<p>
<code class="literal">"March"</code>: March</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"*"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">second</code><a id="id494" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The second of the minute</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"5"</code>: five seconds after the minute</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"0"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">timezone</code><a id="id495" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The timezone ID</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"America/New York"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">year</code><a id="id496" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The four-digit year</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"2010"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"*"</code>
</p>
</td></tr></tbody></table></div><p>In addition to single values, most attributes accept the asterisk (<code class="literal">"*"</code>) as a wildcard, meaning that the annotated method will be executed regularly (every day, hour, and so on).</p><p>Additionally, we can specify<a id="id497" class="indexterm"/> more than one value by separating the values with commas, for example, if we need a method to be executed every Tuesday and Thursday, we could annotate the method as <code class="literal">@Schedule(dayOfWeek="Tue, Thu")</code>.</p><p>We can also specify a range of values; the first and last values are separated by a hyphen (<span class="emphasis"><em>-</em></span>). To execute a method from Monday through Friday, we could use <code class="literal">@Schedule(dayOfWeek="Mon-Fri")</code>. </p><p>Additionally, we could specify that we need the method to be executed every n units of time (for example, every day, every 2 hours, every 10 minutes, and so on). To do something like this, we could use <code class="literal">@Schedule(hour="*/12")</code>, which would execute the method every 12 hours.</p><p>As we can see, the <code class="literal">@Schedule</code> annotation provides a lot of flexibility in terms of how to specify when we need our methods executed. In addition, it provides us the advantage of not needing a client call to activate the scheduling. It also has the advantage of using cron-like syntax; therefore, developers familiar with this Unix tool will feel right at home using this annotation.</p></div></div>
<div class="section" title="EJB Security"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>EJB Security</h1></div></div></div><p>Enterprise JavaBeans allow us to declaratively decide which users can access their methods. For example, some methods might only be available to users in certain roles. A typical scenario is that only users with<a id="id498" class="indexterm"/> the role of administrator can add, delete, or modify other users in the system.</p><p>The following example is a slightly modified version of the DAO session bean we saw earlier in this chapter. In this version, some methods that were previously private are made public. Additionally, the session bean was modified to allow only users in certain roles to access its methods.</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

// imports omitted

@Stateless
<span class="strong"><strong>@RolesAllowed("appadmin")</strong></span>
public class CustomerDaoBean implements CustomerDao
{
  @PersistenceContext
  private EntityManager entityManager;

  @Resource(name = "jdbc/__CustomerDBPool")
  private DataSource dataSource;

  public void saveCustomer(Customer customer)
  {
    if (customer.getCustomerId() == null)
    {
      saveNewCustomer(customer);
    }
    else
    {
      updateCustomer(customer);
    }
  }

  public Long saveNewCustomer(Customer customer)
  {    
    entityManager.persist(customer);
    
    return customer.getCustomerId();
  }

  public void updateCustomer(Customer customer)
  {
    entityManager.merge(customer);
  }

<span class="strong"><strong>  @RolesAllowed(</strong></span>
<span class="strong"><strong>  { "appuser", "appadmin" })</strong></span>
  public Customer getCustomer(Long customerId)
  {
    Customer customer;

    customer = entityManager.find(Customer.class, customerId);

    return customer;
  }

  public void deleteCustomer(Customer customer)
  {
    entityManager.remove(customer);
  }
}</pre></div><p>As we can see, we declare what roles have access to the methods using the <code class="literal">@RolesAllowed</code> annotation. This annotation can take either a single string or an array of strings as its parameter. When a single string is used as a parameter for this annotation, only users with the role specified by the parameter can access the method. If an array of Strings is used<a id="id499" class="indexterm"/> as the parameter, users with any of the roles specified by the array's elements can access the method.</p><p>The <code class="literal">@RolesAllowed</code> annotation can be used to decorate an EJB class, in which case, its values apply to either all the methods in the EJB, or to one or more methods. In the second case, its values apply only to the method the annotation is decorating. If, like in our previous example, both the EJB class and one or more of its methods are decorated with the <code class="literal">@RolesAllowed</code> annotation, the method level annotation takes precedence.</p><p>Application roles need to be mapped to a security realm's group name (refer to <a class="link" href="ch09.html" title="Chapter 9. Securing Java EE Applications">Chapter 9</a>, <span class="emphasis"><em>Securing Java EE Applications</em></span>, for details). This mapping, along with what realm to use, is set in the <code class="literal">glassfish-ejb-jar.xml</code> deployment descriptor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt;
&lt;glassfish-ejb-jar&gt;
<span class="strong"><strong>    &lt;security-role-mapping&gt;</strong></span>
<span class="strong"><strong>        &lt;role-name&gt;appuser&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>        &lt;group-name&gt;appuser&lt;/group-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/security-role-mapping&gt;</strong></span>
<span class="strong"><strong>    &lt;security-role-mapping&gt;</strong></span>
<span class="strong"><strong>        &lt;role-name&gt;appadmin&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>        &lt;group-name&gt;appadmin&lt;/group-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/security-role-mapping&gt;</strong></span>
    &lt;enterprise-beans&gt;
        &lt;ejb&gt;
            &lt;ejb-name&gt;CustomerDaoBean&lt;/ejb-name&gt;
            &lt;ior-security-config&gt;
<span class="strong"><strong>                &lt;as-context&gt;</strong></span>
<span class="strong"><strong>                    &lt;auth-method&gt;username_password&lt;/auth-method&gt;</strong></span>
<span class="strong"><strong>                    &lt;realm&gt;file&lt;/realm&gt;</strong></span>
<span class="strong"><strong>                    &lt;required&gt;true&lt;/required&gt;</strong></span>
<span class="strong"><strong>                &lt;/as-context&gt;</strong></span>
            &lt;/ior-security-config&gt;
        &lt;/ejb&gt;
    &lt;/enterprise-beans&gt;
&lt;/glassfish-ejb-jar&gt;</pre></div><p>The <code class="literal">&lt;security-role-mapping&gt;</code> element of <code class="literal">glassfish-ejb-jar.xml</code> performs the mapping between application roles and the security realm's group. The value of the <code class="literal">&lt;role-name&gt;</code> subelement must contain the application role; this value must match the value used in the <code class="literal">@RolesAllowed</code> annotation<a id="id500" class="indexterm"/>. The value of the <code class="literal">&lt;group-name&gt;</code> subelement must contain the name of the security group in the security realm used by the EJB. In our example, <a id="id501" class="indexterm"/>we map two application roles to their corresponding groups in the security realm. Although in this particular example the name of the application role and the security group match, this does not need to be the case.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>
<span class="strong"><strong>Automatically matching roles to security groups</strong></span>
</p><p>It is possible to automatically match any application roles to identically named security groups in the security realm. This can be accomplished by logging in to the GlassFish web console, clicking on the <span class="strong"><strong>Configuration</strong></span> node, clicking on <span class="strong"><strong>Security</strong></span>, then clicking on the checkbox labeled <span class="strong"><strong>Default Principal To Role Mapping</strong></span>, and saving this configuration change.</p></div></div><p>As shown in our example, the security realm to use for authentication is defined in the <code class="literal">&lt;realm&gt;</code> subelement of the <code class="literal">&lt;as-context&gt;</code> element. The value of this subelement must match the name of a valid security realm in the application server. Other sub elements of the <code class="literal">&lt;as-context&gt;</code> element include <code class="literal">&lt;auth-method&gt;</code>, the only valid value for this element is <code class="literal">username_password</code>, and <code class="literal">&lt;required&gt;</code>, the only valid values of which are <code class="literal">true</code> and <code class="literal">false</code>.</p><div class="section" title="Client authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Client authentication</h2></div></div></div><p>If the client code accessing a secured EJB is part of a web application the user of which has already been authenticated (the user logged in through the web interface), then the user's credentials will be used to determine whether <a id="id502" class="indexterm"/>or not the user should be allowed to access the method they are trying to execute.</p><p>Standalone clients must be executed through the <code class="literal">appclient</code> utility. The following code illustrates a typical client for the previous, secured session bean:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.EJB;

public class Client
{
  @EJB
  private static CustomerDao customerDao;

  public static void main(String[] args)
  {
    Long newCustomerId;

    Customer customer = new Customer();
    customer.setFirstName("Mark");
    customer.setLastName("Butcher");
    customer.setEmail("butcher@phony.org");

    System.out.println("Saving New Customer...");
    newCustomerId = customerDao.saveNewCustomer(customer);

    System.out.println("Retrieving customer...");
    customer = customerDao.getCustomer(newCustomerId);
    System.out.println(customer);
  }
}</pre></div><p>As we can see, there is nothing the code is doing in order to authenticate the user. The session bean is simply injected into the code via the <code class="literal">@EJB</code> annotation<a id="id503" class="indexterm"/> and used as usual. The reason this works is because the <code class="literal">appclient</code> utility takes care of authenticating the user after invoking the client code via the <code class="literal">appclient</code> utility as follows:</p><div class="informalexample"><pre class="programlisting">appclient -client ejbsecurityclient.jar</pre></div><p>The <code class="literal">appclient</code> utility<a id="id504" class="indexterm"/> will present the user with a log in window when it attempts to invoke a secure method on EJB, a<a id="id505" class="indexterm"/>s shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886_04_05.jpg" alt="Client authentication"/></div><p>Assuming that the credentials are correct and the user has the appropriate permissions, the EJB code will execute, and we should see the expected output from the <code class="literal">Client</code> class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Saving New Customer...</strong></span>
<span class="strong"><strong>Retrieving customer...</strong></span>
<span class="strong"><strong>customerId = 29</strong></span>
<span class="strong"><strong>firstName = Mark</strong></span>
<span class="strong"><strong>lastName = Butcher</strong></span>
<span class="strong"><strong>email = butcher@phony.org</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we covered how to implement business logic via stateless and stateful session beans. Additionally, we covered how to implement message-driven beans to consume JMS messages.</p><p>We also explained how to take advantage of the transactional nature of EJBs to simplify implementing the Data Access Object (DAO) pattern.</p><p>Additionally, we explained the concept of container-managed transactions and how to control them using the appropriate annotations. We also explained how to implement Bean Managed Transactions for cases in which container-managed transactions are not enough to satisfy our requirements.</p><p>Life cycles for the different types of Enterprise JavaBeans were covered, including an explanation on how to have EJB methods automatically invoked by the EJB container at certain points in the life cycle.</p><p>We also covered how to have EJB methods invoked periodically by the EJB container by taking advantage of the EJB timer service.</p><p>Finally, we explained how to make sure EJB methods are only invoked by authorized users by annotating the EJB classes and/or methods and by adding the appropriate entries to the<code class="literal"> glassfish-ejb-jar.xml</code> deployment descriptor.</p><p>In the next chapter, we will cover Contexts and Dependency Injection.</p></div></body></html>