- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Testing React Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 React 应用
- en: This chapter explains the basics of testing React apps. It will give us an overview
    of using Jest, which is a JavaScript testing framework. We will look at how you
    can create and run new test suites and tests. To test our React Vite project,
    we will also learn how to use the React Testing Library together with Vitest.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了测试 React 应用的基础知识。它将为我们提供一个使用 Jest 的概述，Jest 是一个 JavaScript 测试框架。我们将探讨如何创建和运行新的测试套件和测试。为了测试我们的
    React Vite 项目，我们还将学习如何结合使用 React Testing Library 和 Vitest。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest
- en: Using the React Testing Library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 测试库
- en: Using Vitest
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vitest
- en: Firing events in tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中触发事件
- en: End-to-end testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Spring Boot application that we created in *Chapter 5*, *Securing Your Backend*,
    is required, as is the React app that we used in *Chapter 14*, *Styling the Frontend
    with React MUI*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第 5 章*，*保护后端安全* 中创建的 Spring Boot 应用程序，以及我们在 *第 14 章*，*使用 React MUI 设计前端样式*
    中使用的 React 应用程序都是必需的。
- en: 'The code samples available at the following GitHub link will also be required
    to follow along with this chapter: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter15).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 GitHub 链接中可用的代码示例也将需要跟随本章：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter15)。
- en: Using Jest
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest
- en: '**Jest** is a testing framework for JavaScript, developed by Meta Inc. ([https://jestjs.io/](https://jestjs.io/)).
    It is widely used with React and provides lots of useful features for testing.
    For example, you can create a **snapshot** test, whereby you can take snapshots
    from React trees and investigate how states are changing. Jest has mocking functionalities
    that you can use to test, for example, your asynchronous REST API calls. It also
    provides functions that are required for assertions in your test cases.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest** 是由 Meta Inc. 开发的 JavaScript 测试框架，[https://jestjs.io/](https://jestjs.io/)。它广泛用于
    React，并为测试提供了许多有用的功能。例如，您可以创建一个 **快照** 测试，从中可以获取 React 树的快照，并调查状态是如何变化的。Jest 具有模拟功能，您可以使用它来测试，例如，您的异步
    REST API 调用。它还提供了在测试用例中进行断言所需的函数。'
- en: 'To demonstrate the syntax, we will see how to create a test case for a basic
    TypeScript function that performs some simple calculations. The following function
    takes two numbers as arguments and returns the product of the numbers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示语法，我们将看到如何为一个基本的 TypeScript 函数创建一个测试用例，该函数执行一些简单的计算。以下函数接受两个数字作为参数，并返回这两个数字的乘积：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code snippet shows a Jest test for the preceding function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了针对前面函数的 Jest 测试：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The test case starts with a `test()` method that runs the test case. The `test()`
    method takes two required arguments: the test name (a descriptive string) and
    the anonymous function that contains the test code. The `expect()` function is
    used when you want to test values, and it gives you access to multiple **matchers**.
    The `toBe()` function is one matcher that checks whether the result from the function
    equals the value in the matcher.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例以一个 `test()` 方法开始，该方法运行测试用例。`test()` 方法需要两个必需的参数：测试名称（一个描述性字符串）和包含测试代码的匿名函数。当您想要测试值时，将使用
    `expect()` 函数，它为您提供了访问多个 **匹配器** 的权限。`toBe()` 函数是一个匹配器，它检查函数的结果是否等于匹配器中的值。
- en: 'There are many different matchers available in Jest, and you can find them
    in the documentation: [https://jestjs.io/docs/using-matchers](https://jestjs.io/docs/using-matchers).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 中有许多不同的匹配器可用，您可以在文档中找到它们：[https://jestjs.io/docs/using-matchers](https://jestjs.io/docs/using-matchers)。
- en: '`describe()` is a function that’s used in test suites to group related test
    cases together. It helps you to organize tests based on their functionality, or
    in React, based on the component being tested. In the following example, we have
    a test suite that contains two test cases for the `App` component:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 是一个在测试套件中用来将相关的测试用例组合在一起的功能。它帮助您根据功能组织测试，或者在 React 中，根据被测试的组件来组织。在下面的示例中，我们有一个包含
    `App` 组件两个测试用例的测试套件：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the React Testing Library
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 测试库
- en: The **React Testing Library** ([https://testing-library.com/](https://testing-library.com/))
    is a set of tools and APIs for testing React components. It can be used for DOM
    testing and queries. The React Testing Library provides a set of query functions
    that help you search elements based on their text content, label, and so on. It
    also provides tools to simulate user actions such as clicking a button and typing
    into input fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Testing Library** ([https://testing-library.com/](https://testing-library.com/))是一套用于测试React组件的工具和API。它可以用于DOM测试和查询。React
    Testing Library提供了一套查询函数，帮助您根据文本内容、标签等搜索元素。它还提供了模拟用户操作的工具，例如点击按钮和输入字段。'
- en: 'Let’s go through some important concepts in the React Testing Library. The
    Testing Library provides a `render()` method that renders a React element into
    the DOM and makes it available for testing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些React Testing Library中的重要概念来学习。Testing Library提供了一个`render()`方法，它将React元素渲染到DOM中，使其可用于测试：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Queries** can be used to find elements on the page. The `screen` object is
    a utility for querying the rendered components. It provides a set of query methods
    that can be used to find elements on the page. There are different types of queries
    that start with various keywords: `getBy`, `findBy`, or `queryBy`. The `getBy`
    and `findBy` queries throw an error if no element is found. The `queryBy` queries
    return `null` if no element is found.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**可以用来在页面上查找元素。`screen`对象是一个用于查询渲染组件的实用工具。它提供了一套查询方法，可以用来在页面上查找元素。有不同类型的查询，以不同的关键词开头：`getBy`、`findBy`或`queryBy`。`getBy`和`findBy`查询如果没有找到元素会抛出错误。`queryBy`查询如果没有找到元素则返回`null`。'
- en: The right query to use depends on the situation, and you can read more about
    the differences at [https://testing-library.com/docs/dom-testing-library/cheatsheet/](https://testing-library.com/docs/dom-testing-library/cheatsheet/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用哪种查询取决于具体情况，你可以在[https://testing-library.com/docs/dom-testing-library/cheatsheet/](https://testing-library.com/docs/dom-testing-library/cheatsheet/)了解更多关于不同查询之间的差异。
- en: 'For example, the `getByText()` method queries the document for an element that
    contains the specified text:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`getByText()`方法会在文档中查询包含指定文本的元素：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The forward slash (`/`) in `/Hello World/i` is used to define a regular expression
    pattern, and the `i`-flag at the end stands for case-insensitive. This means it
    is looking for rendered content that contains the “Hello World” text in a case-insensitive
    matter. You can also use a full string match that is case-sensitive by passing
    a string as an argument:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`/Hello World/i`中的正斜杠(`/`)用于定义正则表达式模式，而末尾的`i`标志代表不区分大小写。这意味着它正在寻找包含“Hello World”文本的内容，且不区分大小写。你也可以通过传递一个字符串作为参数来使用一个完全匹配的字符串，该字符串是区分大小写的：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we can use `expect` to make an assertion. `jest-dom` is a companion library
    for the React Testing Library, and it provides custom matchers that are useful
    when testing React components. For example, its `toBeInTheDocument()` matcher
    checks if the element is present in the document. If the following assertion passes,
    the test case will pass; otherwise, it will fail:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`expect`来进行断言。`jest-dom`是React Testing Library的配套库，它提供了一些在测试React组件时非常有用的自定义匹配器。例如，它的`toBeInTheDocument()`匹配器检查元素是否存在于文档中。如果以下断言通过，则测试用例将通过；否则，它将失败：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can find all the matchers in the `jest-dom` documentation: [https://github.com/testing-library/jest-dom](https://github.com/testing-library/jest-dom).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`jest-dom`文档中找到所有匹配器：[https://github.com/testing-library/jest-dom](https://github.com/testing-library/jest-dom)。
- en: We have now learned the basics of Jest and the React Testing Library. Both libraries
    are needed to test React applications. Jest is a testing framework that provides
    a testing environment and assertion library. The React Testing Library is a utility
    library designed for testing React components. Next, we will learn how to start
    testing in a Vite project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了Jest和React Testing Library的基础知识。这两个库都是测试React应用所必需的。Jest是一个提供测试环境和断言库的测试框架。React
    Testing Library是一个专为测试React组件设计的实用库。接下来，我们将学习如何在Vite项目中开始测试。
- en: Using Vitest
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vitest
- en: '**Vitest** ([https://vitest.dev/](https://vitest.dev/)) is the testing framework
    for Vite projects. It is also possible to use Jest in Vite projects, and there
    are libraries that provide Vite integration for Jest (for example, [https://github.com/sodatea/vite-jest](https://github.com/sodatea/vite-jest)).
    In this book, we will use Vitest because it is easier to start using it with Vite.
    Vitest is similar to Jest, and it provides `test`, `describe`, and `expect`, which
    we learned about in the Jest section.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vitest** ([https://vitest.dev/](https://vitest.dev/)) 是 Vite 项目的测试框架。在 Vite
    项目中也可以使用 Jest，并且有一些库提供了 Jest 的 Vite 集成（例如，[https://github.com/sodatea/vite-jest](https://github.com/sodatea/vite-jest)）。在这本书中，我们将使用
    Vitest，因为它更容易与 Vite 一起使用。Vitest 与 Jest 类似，它提供了`test`、`describe`和`expect`，这些我们在
    Jest 部分已经了解过。'
- en: In this section, we will create tests with Vitest and the React Testing Library
    for the frontend project that we used in *Chapter 14*, *Styling the Frontend with
    MUI*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为我们在第14章中使用的用于*使用 MUI 设计前端*的前端项目创建使用 Vitest 和 React 测试库的测试。
- en: Installing and configuring
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置
- en: 'The first step is installing Vitest and the React Testing Library to our project:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将 Vitest 和 React 测试库安装到我们的项目中：
- en: 'Open the project in Visual Studio Code. Move to your project folder in the
    terminal and execute the following `npm` command inside your project folder:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。在终端中移动到你的项目文件夹，并在你的项目文件夹内执行以下`npm`命令：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-D` flag in the `npm` command means that a package should be saved as a
    development dependency in the `devDependencies` section of the `package.json`
    file. These packages are necessary for development and testing but are not required
    for the production runtime of the application.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm`命令中的`-D`标志表示应该将包保存为`package.json`文件`devDependencies`部分的开发依赖项。这些包对于开发和测试是必要的，但不是应用程序生产运行时所需的。'
- en: 'Next, we have to configure Vitest by using a Vite configuration file, `vite.config.ts`.
    Open the file and add a new `test` property with the following changes:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须通过使用 Vite 配置文件`vite.config.ts`来配置 Vitest。打开文件，并添加一个新的`test`属性，进行以下更改：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, Vitest does not provide a global API. The `globals: true` setting
    allows us to reference APIs globally (`test` , `expect`, and so on), like Jest.
    The `environment: ''jsdom ''` setting defines that we are using the browser environment
    instead of Node.js.'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '默认情况下，Vitest 不提供全局 API。`globals: true`设置允许我们全局引用 API（如`test`、`expect`等），就像
    Jest 一样。`environment: ''jsdom ''`设置定义了我们正在使用浏览器环境而不是 Node.js。'
- en: 'Now, you can see a TypeScript type error in the `test` property because the
    `test` type doesn’t exist in Vite’s configuration. You can import extended Vite
    configuration from Vitest to get rid of the error. Modify the `defineConfig` import
    as shown in the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在`test`属性中看到一个 TypeScript 类型错误，因为`test`类型在 Vite 的配置中不存在。你可以从 Vitest 导入扩展的
    Vite 配置来消除错误。按照以下代码修改`defineConfig`导入：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will add the `test` script to our `package.json` file:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向`package.json`文件添加`test`脚本：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now run our tests using the following `npm` command. In this phase,
    you will get an error because we don’t have any tests yet:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下`npm`命令运行我们的测试。在这个阶段，你会得到一个错误，因为我们还没有任何测试：
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also find a Visual Studio Code extension for Vitest if you want to
    run your tests from the VS Code IDE: [https://marketplace.visualstudio.com/items?itemName=ZixuanChen.vitest-explorer](https://marketplace.visualstudio.com/items?itemName=ZixuanChen.vitest-explorer).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从 VS Code IDE 运行测试，也可以找到一个 Vitest 的 Visual Studio Code 扩展：[https://marketplace.visualstudio.com/items?itemName=ZixuanChen.vitest-explorer](https://marketplace.visualstudio.com/items?itemName=ZixuanChen.vitest-explorer)。
- en: 'By default, files to include in the test run are defined using the following
    glob pattern ([https://vitest.dev/config/#include](https://vitest.dev/config/#include)):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，测试运行中要包含的文件是通过以下全局模式定义的（[https://vitest.dev/config/#include](https://vitest.dev/config/#include)）：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will name our test files using the `component.test.tsx` naming convention.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`component.test.tsx`命名约定来命名我们的测试文件。
- en: Running our first test
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的第一个测试
- en: 'Now, we will create our first test case to verify that our `App` component
    is rendered and that the app header text can be found:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的第一个测试用例，以验证我们的`App`组件是否渲染，并且可以找到应用头部文本：
- en: 'Create a new file called `App.test.tsx` in the `src` folder of your React app
    and create a new test case. We are using Vitest, so we import `describe` and `test`
    from `vitest`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 React 应用程序的`src`文件夹中创建一个名为`App.test.tsx`的新文件，并创建一个新的测试用例。因为我们使用 Vitest，所以从`vitest`导入`describe`和`test`：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can use the `render` method from the React Testing Library to render
    our `App` component:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用React Testing Library的`render`方法来渲染我们的`App`组件：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we use the `screen` object and its query API to verify that the app header
    text has been rendered:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`screen`对象及其查询API来验证应用头部文本已被渲染：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to use `jest-dom` library matchers such as `toBeInTheDocument()`,
    which we used earlier, you should import the `jest-dom/vitest` package, which
    extends matchers:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要使用`jest-dom`库的匹配器，例如我们之前使用的`toBeInTheDocument()`，你应该导入`jest-dom/vitest`包，它扩展了匹配器：
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can run our test by typing the following command in the terminal:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在终端中输入以下命令来运行我们的测试：
- en: '[PRE17]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should see that the test passes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到测试通过了：
- en: '![](img/B19818_15_01.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_15_01.png)'
- en: 'Figure 15.1: Test run'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：测试运行
- en: Tests are run in **watch mode**, meaning each time you make changes to your
    source code, the tests that are related to the code changes are rerun. You can
    quit watch mode by pressing *q*, as shown in the figure. You can also invoke test
    reruns manually by pressing *r*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是在**监视模式**下运行的，这意味着每次你修改源代码时，与代码更改相关的测试都会重新运行。你可以通过按*q*键退出监视模式，如图所示。你也可以通过按*r*键手动触发测试重新运行。
- en: If you need, you can create a test setup file that can be used to set up the
    environment and configuration required for running tests. The setup file will
    be run before each test file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以创建一个测试设置文件，该文件可以用于设置运行测试所需的环境和配置。设置文件将在每个测试文件之前运行。
- en: 'You have to specify the path to the test setup file in the `vite.config.ts`
    file, inside the `test` node:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在`vite.config.ts`文件中的`test`节点中指定测试设置文件的路径：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also perform tasks that are required before or after test cases. Vitest
    provides the `beforeEach` and `afterEach` functions that you can use to invoke
    code before or after your test cases. For example, you can run the React Testing
    Library’s `cleanup` function after each test case to unmount React components
    that were mounted. If you only want to invoke some code once before or after *all*
    test cases, you can use the `beforeAll` or `afterAll` functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以执行在测试用例前后所需的任务。Vitest提供了`beforeEach`和`afterEach`函数，你可以使用这些函数在测试用例前后调用代码。例如，你可以在每个测试用例之后运行React
    Testing Library的`cleanup`函数来卸载已挂载的React组件。如果你只想在所有测试用例之前或之后调用一次代码，你可以使用`beforeAll`或`afterAll`函数。
- en: Testing our Carlist component
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的Carlist组件
- en: Let’s now make a test for our `Carlist` component. We will use our backend REST
    API, and in this section, you should run the backend that we used in the previous
    chapter. Using a real API in your tests is closer to a real-world scenario and
    allows end-to-end integration testing. However, real APIs always have some latency
    and make your tests slower to run.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来为我们的`Carlist`组件编写一个测试。我们将使用我们的后端REST API，在这一节中，你应该运行我们在上一章中使用过的后端。在测试中使用真实API更接近真实世界场景，并允许进行端到端集成测试。然而，真实API总是有一些延迟，使得测试运行速度变慢。
- en: You can alternatively use a **mock API**. This is common if the developer doesn’t
    have access to the real API. Using a mock API requires creating and maintaining
    the mock API implementation. There are several libraries that you can use for
    this with React, such as **msw** (**Mock Service Worker**) and **nock**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用**模拟API**。如果开发者没有访问真实API的权限，这很常见。使用模拟API需要创建和维护模拟API的实现。对于React，有几个库可以用来实现这一点，例如**msw**（模拟服务工作者）和**nock**。
- en: 'Let’s begin:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Create a new file called `Carlist.test.tsx` in your `src` folder. We will import
    the `Carlist` component and render it. The component renders the `''Loading...''`
    text when data from the backend is not available yet. The starter code looks like
    the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`src`文件夹中创建一个名为`Carlist.test.tsx`的新文件。我们将导入`Carlist`组件并将其渲染。当后端数据尚未可用时，组件会渲染`'Loading...'`文本。起始代码如下所示：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if you run your test cases, you will get the following error: **No QueryClient
    set, use QueryClientProvider to set one**. We used React Query for networking
    in our `Carlist` component; therefore, we need `QueryClientProvider` in our component.
    The source code below shows how we can do that. We have to create a new `QueryClient`
    and set retries to `false`. By default, React Query retries queries three times,
    which might cause timeouts in your test case if you want to test error cases:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你运行你的测试用例，你将得到以下错误：**未设置QueryClient，使用QueryClientProvider设置一个**。我们在`Carlist`组件中使用React
    Query进行网络操作；因此，我们需要在组件中使用`QueryClientProvider`。下面的源代码显示了我们可以如何做到这一点。我们必须创建一个新的`QueryClient`并将重试设置为`false`。默认情况下，React
    Query会重试查询三次，这可能会在你想测试错误情况时导致测试用例超时：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We also created a wrapper that returns a `QueryClientProvider` component. Then,
    we used the `render` function’s second argument and passed our `wrapper`, which
    is a React component, so that the `wrapper` wraps the `Carlist` component. This
    is useful functionality when you want to wrap your component with additional wrappers.
    The final result is that the `Carlist` component is wrapped inside the `QueryClientProvider`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还创建了一个返回`QueryClientProvider`组件的包装器。然后，我们使用`render`函数的第二个参数并传递我们的`wrapper`，这是一个React组件，这样`wrapper`就可以包裹`Carlist`组件。当你想要用额外的包装器包裹你的组件时，这是一个有用的功能。最终结果是`Carlist`组件被包裹在`QueryClientProvider`内部。
- en: 'Now, if you rerun your tests, you won’t get an error and your new test case
    will pass. The test run now includes two test files and two tests:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你重新运行你的测试，你将不会得到错误，并且你的新测试用例将通过。测试运行现在包括两个测试文件和两个测试：
- en: '![](img/B19818_15_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_15_02.png)'
- en: 'Figure 15.2: Test run'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：测试运行
- en: Next, we will test that our `getCars` fetch is invoked and the cars are rendered
    in the data grid. The network calls are asynchronous, and we don’t know when the
    response will arrive. We will use the React Testing Library’s `waitFor` function
    to wait until the **NEW CAR** button is rendered because then we know that the
    network request has succeeded. The test will proceed after the condition is met.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将测试我们的`getCars`获取是否被调用，并且汽车在数据网格中渲染。网络调用是异步的，我们不知道响应何时到达。我们将使用React Testing
    Library的`waitFor`函数等待直到**新汽车**按钮被渲染，因为那时我们知道网络请求已经成功。测试将在条件满足后继续进行。
- en: 'Finally, we will use a matcher to check that the `Ford` text can be found in
    the document. Add the following highlighted import to the `Carlist.test.tsx` file:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们将使用匹配器来检查文档中是否可以找到`Ford`文本。将以下高亮的导入添加到`Carlist.test.tsx`文件中：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The test looks like the following:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试看起来如下：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you rerun the tests, you can see that three tests pass now:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你重新运行测试，你现在可以看到三个测试通过了：
- en: '![](img/B19818_15_03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_15_03.png)'
- en: 'Figure 15.3: Test run'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：测试运行
- en: We have now learned the basics of Vitest and how to create and run test cases
    in a Vite React app. Next, we will learn how to simulate user actions in our test
    cases.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了Vitest的基础知识以及如何在Vite React应用中创建和运行测试用例。接下来，我们将学习如何在测试用例中模拟用户操作。
- en: Firing events in tests
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试中触发事件
- en: 'The React Testing Library provides a `fireEvent()` method that can be used
    to fire DOM events in your test cases. The `fireEvent()` method is used in the
    following way. First, we have to import it from the React Testing Library:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: React Testing Library提供了一个`fireEvent()`方法，可以在测试用例中触发DOM事件。`fireEvent()`方法的使用方式如下。首先，我们必须从React
    Testing Library中导入它：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we have to find the element and trigger its event. The following example
    shows how to trigger an input element’s change event and a button’s click event:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须找到元素并触发其事件。以下示例显示了如何触发输入元素的更改事件和按钮的点击事件：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the events are triggered, we can assert the expected behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件触发后，我们可以断言预期的行为。
- en: There is also a companion library for the Testing Library that is called `user-event`.
    The `fireEvent` function triggers element events, but browsers do more than only
    triggering one event. For example, if a user types some text into an input element,
    it is first focused, and then keyboard and input events are fired. `user-event`
    simulates the full user interaction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Testing Library还有一个配套库，称为`user-event`。`fireEvent`函数触发元素事件，但浏览器做的不仅仅是触发一个事件。例如，如果用户在输入元素中输入一些文本，它首先会被聚焦，然后触发键盘和输入事件。`user-event`模拟完整的用户交互。
- en: 'To use the `user-event` library, we have to install it in our project with
    the following `npm` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`user-event`库，我们必须使用以下`npm`命令在我们的项目中安装它：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we have to import `userEvent` in the test file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在测试文件中导入`userEvent`：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can create an instance of `userEvent` using the `userEvent.setup()`
    function. We can also call the API directly, which will call `userEvent.setup()`
    internally, and this is how we will use it in the following examples. The `userEvent`
    provides multiple functions to interact with the UI, such as `click()` and `type()`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `userEvent.setup()` 函数创建一个 `userEvent` 实例。我们也可以直接调用 API，这将在内部调用 `userEvent.setup()`，这就是我们将在以下示例中使用的做法。`userEvent`
    提供了多个与 UI 交互的函数，例如 `click()` 和 `type()`：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As an example, we will create a new test case that simulates a **NEW CAR**
    button press in our `Carlist` component and then checks that the modal form is
    opened:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将创建一个新的测试用例，模拟在 `Carlist` 组件中按下 **新汽车** 按钮，然后检查模态表单是否已打开：
- en: 'Open the `Carlist.test.tsx` file and import `userEvent`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Carlist.test.tsx` 文件并导入 `userEvent`：
- en: '[PRE28]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new test inside the `describe()` function where we have our `Carlist`
    component tests. In the test, we will render the `Carlist` component and wait
    until the **NEW CAR** button is rendered:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `describe()` 函数中创建一个新的测试，其中包含我们的 `Carlist` 组件测试。在测试中，我们将渲染 `Carlist` 组件并等待
    **新汽车** 按钮被渲染：
- en: '[PRE29]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, find the button using the `getByText` query and use the `userEvent.click()`
    function to press the button. Use a matcher to verify that the **SAVE** button
    can be found in the document:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `getByText` 查询找到按钮，并使用 `userEvent.click()` 函数来点击按钮。使用匹配器来验证文档中是否可以找到 **保存**
    按钮：
- en: '[PRE30]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, rerun your tests and see that four test cases pass:![](img/B19818_15_04.png)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新运行你的测试，你会看到有四个测试用例通过了：![](img/B19818_15_04.png)
- en: 'Figure 15.4: Test run'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.4：测试运行
- en: 'We can use the `getByRole` query to find elements based on their roles, such
    as buttons, links, and so on. Below is an example of how to find a button that
    contains the text `Save` by using the `getByRole` query. The first argument defines
    the role, and the second argument’s `name` option defines the button text:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 `getByRole` 查询根据元素的角色找到元素，例如按钮、链接等。以下是如何使用 `getByRole` 查询找到包含文本 `保存`
    的按钮的示例。第一个参数定义了角色，第二个参数的 `name` 选项定义了按钮文本：
- en: '[PRE31]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also test how a failed test looks by changing the text in the test matcher,
    for example:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过更改测试匹配器中的文本来测试失败的测试看起来如何，例如：
- en: '[PRE32]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, if we rerun the tests, we can see that one test fails, along with the
    reason for the failure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新运行测试，我们可以看到有一个测试失败了，以及失败的原因：
- en: '![](img/B19818_15_05.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_15_05.png)'
- en: 'Figure 15.5: Failed test'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：失败的测试
- en: Now, you know the basics of testing user interactions in your React components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了在 React 组件中测试用户交互的基础知识。
- en: End-to-end testing
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: '**End-to-end** (**E2E**) **testing** is a methodology that focuses on testing
    an entire application’s workflow. We will not cover it in detail in this book,
    but we will give you an idea about it and cover some tools that we can use.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端**（**E2E**）**测试**是一种专注于测试整个应用程序工作流程的方法。我们不会在本书中详细讨论它，但我们会给你一个大致的了解，并介绍一些我们可以使用的工具。'
- en: The goal is to simulate user scenarios and interactions with the application
    to make sure that all components work together correctly. E2E testing covers frontend,
    backend, and all interfaces or external dependencies of the software that is being
    tested. The E2E testing scope can also be *cross-browser* or *cross-platform*,
    where an application is tested using multiple different web browsers or mobile
    devices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是模拟用户场景和与应用程序的交互，以确保所有组件都能正确协同工作。端到端测试覆盖前端、后端以及正在测试的软件的所有接口或外部依赖。端到端测试的范围也可以是
    *跨浏览器* 或 *跨平台*，即使用多个不同的网络浏览器或移动设备来测试应用程序。
- en: 'There are several tools available for end-to-end testing, such as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可用于端到端测试，例如：
- en: '**Cypress** ([https://www.cypress.io/](https://www.cypress.io/)): This is a
    tool that can be used to create E2E tests for web applications. Cypress tests
    are simple to write and read. You can see your application’s behavior during the
    test execution in the browser and it also helps you to debug if there are any
    failures. You can use Cypress for free, with some limitations.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cypress** ([https://www.cypress.io/](https://www.cypress.io/))：这是一个可以用来创建
    Web 应用程序端到端测试的工具。Cypress 测试易于编写和阅读。你可以在浏览器中看到测试执行期间应用程序的行为，并且它还有助于你在出现失败时进行调试。你可以免费使用
    Cypress，但有一些限制。'
- en: '**Playwright** ([https://playwright.dev/](https://playwright.dev/)): This is
    a test automation framework designed for E2E testing, and it is developed by Microsoft.
    You can get a Visual Studio Code extension for Playwright and start to use it
    in your project. The default language for writing tests with Playwright is TypeScript,
    but you can also use JavaScript.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Playwright** ([https://playwright.dev/](https://playwright.dev/))：这是一个为 E2E
    测试设计的测试自动化框架，由微软开发。您可以为 Playwright 获取一个 Visual Studio Code 扩展，并在您的项目中开始使用它。使用
    Playwright 编写测试的默认语言是 TypeScript，但您也可以使用 JavaScript。'
- en: E2E testing helps to verify that your application meets its functional requirements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: E2E 测试有助于验证您的应用程序是否满足其功能需求。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided a basic overview of how to test React apps. We
    introduced Jest, a JavaScript testing framework, and the React Testing Library,
    which can be used to test React components. We also learned how to create and
    run tests in our Vite React app using Vitest, and finished off with a brief discussion
    on E2E testing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了如何测试 React 应用程序的基本概述。我们介绍了 Jest，一个 JavaScript 测试框架，以及 React Testing
    Library，它可以用来测试 React 组件。我们还学习了如何使用 Vitest 在我们的 Vite React 应用程序中创建和运行测试，并以对 E2E
    测试的简要讨论结束。
- en: In the next chapter, we will secure our application and add the login functionality
    to the frontend.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将确保我们的应用程序的安全，并将登录功能添加到前端。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Jest?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest 是什么？
- en: What is the React Testing Library?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 React Testing Library？
- en: What is Vitest?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vitest 是什么？
- en: How can you fire events in test cases?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何在测试用例中触发事件？
- en: What is the purpose of E2E testing?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: E2E 测试的目的是什么？
- en: Further reading
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some other resources for learning about React and testing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他关于学习 React 和测试的资源：
- en: '*Simplify Testing with React Testing Library*, by Scottie Crump ([https://www.packtpub.com/product/simplify-testing-with-react-testing-library/9781800564459](https://www.packtpub.com/product/simplify-testing-with-react-testing-library/9781800564459))'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 React Testing Library 简化测试*，由 Scottie Crump 编著 ([https://www.packtpub.com/product/simplify-testing-with-react-testing-library/9781800564459](https://www.packtpub.com/product/simplify-testing-with-react-testing-library/9781800564459))'
- en: '*React Testing Library Tutorial*, by Robin Wieruch ([https://www.robinwieruch.de/react-testing-library/](https://www.robinwieruch.de/react-testing-library/))'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React Testing Library 教程*，由 Robin Wieruch 编著 ([https://www.robinwieruch.de/react-testing-library/](https://www.robinwieruch.de/react-testing-library/))'
- en: Learn more on Discord
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code10796108009382640.png)'
