- en: Property-Based Testing in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a daily activity of many programmers. It is performed in order
    to verify the behavior of the software under development. Property-based testing
    is an alternative and supplementary approach to unit testing. It allows for the
    description of the expected properties of software and for their verification,
    if these properties hold using automatically generated data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss the situations in which property-based testing
    can be especially useful, and look at how the expected properties can be formulated
    and the test data can be produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of property-based testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shrinkers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties as laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to property-based testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of unit testing should be well-known by any professional developer.
    A unit test usually contains a number of test cases. Each test case describes
    the expected behavior of a part of the program. The description is usually formulated
    in the form: *for this unit of code in that specific state we expect given input
    to produce the following output*. The developer then replicates such test cases
    with some deviations in the initial state and/or input data and expectations of
    the result in order to cover different code paths.
  prefs: []
  type: TYPE_NORMAL
- en: The specification of the test case is represented in the form of a test code
    relying on a testing framework. As at the moment of this writing, there are two
    popular testing frameworks for Scala projects, `ScalaTest` and `Specs2`. It is
    arguable that at least one of them should be familiar to any Scala developer,
    so we won't cover them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we'll take a look at alternative ways to formulate expectations about
    the behavior of the program.
  prefs: []
  type: TYPE_NORMAL
- en: From unit tests to properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that testing scenarios (sometimes also called example-based tests)
    are just one of the many ways to define how the system is expected to work. Examples
    just describe some properties of the software having a specific state. The state
    usually affects the output in response to a provided input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, in addition to properties described via examples, there
    are other types of properties which characterize software, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Universally quantified properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With them we can tell something about the system which should hold for any valid
    input and possibly for all possible states.  This form of testing is called **property-based
    testing** (**PBT**). In contrast to the concrete scenario in a unit-testing case,
    the property is an abstract specification.
  prefs: []
  type: TYPE_NORMAL
- en: The same way that unit-testing frameworks provide functionality to structure
    tests and to formulate the expectations in the forms of unit tests, there is a
    Scala framework for PBT.
  prefs: []
  type: TYPE_NORMAL
- en: ScalaCheck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ScalaCheck ([http://www.scalacheck.org](http://www.scalacheck.org)) is a framework
    for automated PBT in Scala. It works great with SBT or IntelliJ IDEA and also
    has a built-in test runner and can be used standalone because of this. It also
    integrates well with `ScalaTest` and `specs2`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ScalaCheck` is an external dependency, so we need to add it to the `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In order to be able to play with the code in REPL, we'll need to add it to the
    default scope (by removing the `% Test` part (this is already done in the chapter's
    code) and start the REPL with SBT dependencies. If you don't know how to do this,
    please refer to the [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml),
    *Preparing the Environment and Running Code Samples*, where we explain it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can define and verify our first property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We just defined and verified that all `Strings` have non-negative lengths! Confused
    a bit? Let's take a closer look how it was done.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we imported a `forAll` property factory. In essence, its
    purpose is to convert functions into properties.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, in the second line the function is of a type `String => Boolean`.
    Naturally, there is some implicit magic in play. Among other things, there is
    an implicit conversion `Boolean => Property` and an `Arbitrary[String]` which
    provides a test data, in our case, random strings.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line we call a `check` method available on the `Prop` (`ScalaCheck`
    uses this name as an abbreviation for `"property"`) among other combination and
    execution methods to execute our test using the default configuration. Hence,
    it runs with 100 random strings as an input data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got a feeling for how the PBT looks in general, we'll rigorously
    approach each aspect of it, starting with properties.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining properties is the most important aspect of PBT. It is impossible to
    test a system properly without having good properties definition. The transition
    from testing scenarios to properties is usually the hardest part for developers
    starting to adopt PBT.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is useful to have some kind of system which would help to approach
    the task of defining a property in a systematic manner. Often, the first step
    in systematizing something is classification.
  prefs: []
  type: TYPE_NORMAL
- en: Types of properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already said that there are universally quantified and conditional properties,
    depending upon if some property holds always or just for some subset of all possible
    inputs. Now, we want to break down properties in different dimensions—by how they
    are defined. Let's see how we could describe some operations in general terms.
  prefs: []
  type: TYPE_NORMAL
- en: Commutativity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If order operands do not matter, we say that the operation is commutative.
    The most trivial examples would be addition and multiplication. The property should
    be universal for both of these operations. In the following code, we''re creating
    two properties, one for addition and one for multiplication, and checking that
    our assumption is correct by comparing results of computations with the changed
    order of operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For strings, the addition is defined as a concatenation but is not commutative
    in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can also see how `ScalaCheck` generates random inputs and
    finds some minimal failing case. If at least one of the strings is empty, the
    property becomes commutative which can be demonstrated with the following modification
    of the previous test where `b` is assigned an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of a conditional test for string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The associativity is the same for operators as commutativity is for operands—if
    there are multiple operations, then the order in which operations are performed
    does not matter as long as the order of operands does not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The associativity properties for multiplication and addition again look very
    similar, as in the following example where we have three properties, each comparing
    results of two computations with a different order of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The last line demonstrates that string concatenation is associative as well.
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The identity property of some operation states that if one of the operands
    is the identity value, then the result of the operation will be equal to another
    operand. For multiplication, the identity value is one; for addition, it is zero.
    Because of the commutativity of both multiplication and addition, the identity
    value can appear in any position. For example, in the next snippet the identity
    element appears as the first and as the second operand for all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For string concatenation, the identity is an empty string. It turns out our
    conditional commutativity property for strings was just a manifestation of the
    universal identity property!
  prefs: []
  type: TYPE_NORMAL
- en: Invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Invariant properties are those which should never change in the context of
    the operation. For example, sorting the contents of the string or changing the
    case of it should never change its length. The next property demonstrates that
    it holds for normal as well as for uppercase strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or well, for `toUpperCase` at least it should work if the locale matches the
    contents of the string or the string only contains ASCII symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we went a bit ahead of ourselves and used `Gen.asciiStr` to generate strings
    which only contain ASCII chars.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Idempotent operations only change their operand once. After the initial change,
    any follow-up application should leave the operand unchanged. Sorting and uppercasing
    the contents of the string are good examples of idempotent operations. Please
    note that the same operations had the length property invariant in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate that operations `toUpperCase` and sorted are idempotent
    by applying them a different number of times and expecting that the result is
    the same as after the first application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For multiplications, the natural idempotent element is by definition the identity
    element. But it is also a zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The logical `AND` and `OR` are idempotent for the Boolean values `false` and
    `true`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Induction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inductive properties reflect those of their operand(s). They are usually formulated
    for the inductive case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the factorial function for any argument should obey the factorial
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Which is, of course, a conditional property for `n > 2`, which we specify using
    the implication operator `==>` (more about this operator later).
  prefs: []
  type: TYPE_NORMAL
- en: Symmetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symmetry is a type of invariance. It states that the operand will have its original
    form after the application of some ordered set of operations . Often this set
    is limited to a pair of operations or even to a single symmetric operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our usual experimental string, there is a symmetric operation `reverse`;
    for numbers, we could define a pair of addition and subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to define another pair with multiplication and division as operands
    (with respect to division by zero, overflow, and precision).
  prefs: []
  type: TYPE_NORMAL
- en: The symmetry property is often called a **round-trip** property. For a single
    operation it must hold for any inversible function.
  prefs: []
  type: TYPE_NORMAL
- en: Test Oracle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strictly speaking, the test oracle does not belong to this list because it does
    not specify an intrinsic quality of the operation. Still, it is a useful and convenient
    way to pinpoint an expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle is simple and especially useful during a refactoring or rewriting
    of the existing system. It uses given trusted implementation to verify the behavior
    of the new code. Back to our string examples, we might use Java''s Array as a
    test oracle for the sorting of the contents of the string, by expecting that the
    results of sorting the string and an array, which consists of its elements, would
    be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But, of course, in the real refactoring scenario on the place of an array, the
    existing implementation would be used.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've defined all different type's properties in the same way, using the most
    concise version of the `forAll` constructor and a `check` method. There are some
    ways to customize them.
  prefs: []
  type: TYPE_NORMAL
- en: Checking property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `check()` method accepts `Test.Parameters`, which allow for the configuration
    of a few aspects of how the check is executed. The most useful describe a minimum
    number of successful tests, the number of workers to run in parallel, a test callback
    to execute after each test, the maximum discard ratio between passed and discarded
    tests for conditional tests, and an initial seed which can help to make the property
    evaluation deterministic. It is also possible to limit the time the test is allowed
    to execute. Here is an example, which uses both test parameters and a time limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we used the `Test.check` method, which executes a property with given parameters
    and returns test statistics back. We can see that our test has failed because
    of the timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `within`, there are other wrapper methods defined on `Prop`. For instance,
    it is possible to convert exceptions thrown by the property into test failures,
    to evaluate properties lazily, or to collect data for the test report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `==` and `?=` used in the previous code is subtle—the
    `==` compares two values and returns a Boolean, which is then implicitly converted
    to the `Prop`; the `?=` creates a `Prop` directly and sometimes it can be useful
    in the situations where properties are combined, as we'll see further.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property can also be labelled, which makes it easier to spot in the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we also used the `protect` method to convert the exception into the test
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: Combining properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we were talking about single, isolated properties. Sometimes, it
    is useful, or even required, to make sure that some combination of properties
    holds. For instance, we might want to define a property which holds if and only
    if all other properties hold. Or we might want to have a property which is true
    if at least one property from a set of properties is true. There are combination
    methods defined on `Prop` exactly for such use cases. The result is just another
    property which can be checked the same way we already did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a nested combination of properties. The topmost one holds if both `multiplicationLaws`
    and `stringProps` hold. The `stringProps` verifies that any `String` is either
    empty or non-empty; only one of these properties can be true at the same time.
    For `multiplicationLaws`, all nested properties must hold.
  prefs: []
  type: TYPE_NORMAL
- en: There are also more specific combinators, for example `someFailing` and `noneFailing`
    which hold in the case if some underlying properties are failing or none are failing
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have had a detailed discussion of properties, but haven't mentioned yet where
    the input data for these properties comes from. Let's correct this omission and
    give generators the care they deserve.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the generator comes from the general concept of types. In a sense, a
    type is a specification of possible values complying to that type. In other words, types
    describe the rules that values must comply to. These rules give us the possibility
    to generate ranges of data values for given types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some types there are more values; for others, there are less. As we already
    know, there are literal types which contain a single value. The same applies for
    `Unit` type with its `()` value. For `Boolean`, there are two values that exist:
    `true` and `false`. Two values would also exist for an imaginary equality relation
    type—equal and non-equal. With the same principle, we can say that full ordering
    takes one of three values: less than, equal, or greater than.'
  prefs: []
  type: TYPE_NORMAL
- en: Properties defined in terms of types with such limited sets of possible values
    are called *provable*. This is because it is possible to try out all values of
    a given type (or combinations, if there are multiple parameters) and prove that
    the program is correct for all possible inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The other type of properties are *falsifiable* properties. It is not possible
    (or does not make sense) to try out all possible values of input parameters, hence
    it is only possible to tell that the functionality under test works for some subset
    of all inputs.
  prefs: []
  type: TYPE_NORMAL
- en: To make falsifiable properties more trustworthy, existing `ScalaCheck` generators
    for `Byte`, `Short`, `Int`, and `Long` place additional weight on `zero`, `+1`,
    `-1`, and both `minValue` and `maxValue` for the type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at which generators are included in the `ScalaCheck` and how
    we can use them to create new generators for the data types specific for our code.
    We'll also briefly touch the topic of gradually reducing the test data for failing
    cases known as shrinking.
  prefs: []
  type: TYPE_NORMAL
- en: Existing generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking about existing generators, ScalaCheck provides a lot of them out of
    the box, such as all subtypes of `AnyVal`, `Unit`, `Function0`, chars and strings
    with different contents (`alphaChar`, `alphaLowerChar`, `alphaNumChar`, `alphaStr`,
    `alphaUpperChar`, `numChar`, `numStr`), containers, lists and maps (`containerOf`,
    `containerOf1`, `containerOfN`, `nonEmptyContainerOf`, `listOf`, `listOf1`, `listOfN`, `nonEmptyListOf`, `mapOf`,
    `mapOfN`, `nonEmptyMap`), numbers (`chooseNum`, `negNum`, `posNum`), duration,
    `Calendar`, `BitSet`, and even `Test.Parameters`!
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no generator  suitable for the testing purposes available, it is
    possible to create a custom generator by implementing a `Gen` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is an abstract class, which is basically just a function taking test parameters
    and returning an optional value of the required type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is partially implemented, but still, it''s a bit mundane to extend it manually.
    Hence new generators are usually implemented by reusing already existing ones. As
    an exercise, let''s implement a generator for literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we're creating a generator factory for literal types by delegating
    the value generation to the `Gen.const`. This is safe to do because, by definition,
    literal types contain just a single value. The second line creates an `implicit
    Arbitrary[42]`, which is expected to be in scope by the `forAll` property.
  prefs: []
  type: TYPE_NORMAL
- en: Combining generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it is not very hard to create a custom one, the absolute majority of
    generators is built by combining existing implementations. `Gen` offers a couple
    of methods that are very useful in such scenarios. The classic example is to use
    the `map` and `flatMap` methods to create a generator for a case class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this with an example of playing cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need some generators for suits and ranks which we can create by reusing
    existing `oneOf` and `choose` constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can combine our generators into the card generator using `for` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We also use `Gen.frequency` in order to have a proper distribution of numbers
    and symbols produced by our combined generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to change this generator to only make cards for a pique pack by
    using the `suchThat` combinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that our generators produce trustworthy values by using the `Prop.collect`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it is also possible to generate a handfull of cards from the deck
    using one of the container generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh, we have duplicate cards in our hand. It turns out that we need to use a
    more general form of the container generator, which takes both the type of the
    container and the type of the element as type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That is better, but now it seems that the duplicate elements have just disappeared
    so that we still don't have an expected behavior. Moreover, another issue is obvious—a
    lot of tests are discarded. This happens because our `piquet` generator is defined
    in terms of filtering the output of the more general `full` generator. `ScalaCheck`
    notices that there are too many tests which do not qualify as a valid input and
    gives up earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix our `piquet` generator and an issue with missing cards. For the
    first one, we will use the same approach as we''ve used for the `full` generator.
    We''ll just change the number used for the rank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Please note how the frequency changed in respect to the changed set of possible
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the second issue, we will repeatedly generate the set of cards until
    it has an expected size using `retryUntil` combinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, our hands are generated as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are even more useful combinator methods, which can be used
    to create other sophisticated generators. Please refer to the documentation ([https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md](https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md))
    or the source code for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Shrinkers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at two cornerstones of PBT—properties and generators. There is
    still one aspect we should take a look at before considering ourselves done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PBT, the test data comes from generators and it is kind of random. Given
    this fact, we could expect that it might be hard to find out why a test is failing.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that our property was falsified by the number `2008612603`,
    which is arguably not very useful. It is more or less obvious for an `Int`, but
    consider a case with a list of many elements and a property formulated for these
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, it is near to impossible to find out which of 1,000 strings had a
    wrong length in this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this moment, the new component comes into play: the `Shrink`. The job of
    the shrinker is to find a minimal test data with which the property does not hold.
    In two previous examples, we used a `forAllNoShrink` property constructor and
    thus had no shrinker active. This is how the result will look like if we change
    the definition to the normal `forAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the minimal list, which falsifies our property, is the
    list with one empty string. The original failing input is shown as `ARG_0_ORIGINAL`
    and it is of a similar length and complexity as we've seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Shrink` instances are passed as implicit parameters, so we can summon
    one to see how they work. We''ll do this with our failing value for `Int` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `shrink` method generates a stream of values and we evaluate it by converting
    it to the list. It is easy to see the pattern—the values produced by the `Shrink`
    lie symmetrically to the **central** value of `0` (zero), starting from the initial
    failing value, and then are each time divided by two until they converge to the
    zero. This is pretty much how it is implemented for numbers, including hardcoded
    values of `+-two`, `+-one`, and `zero`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to see that numbers produced by the `Shrink` will depend on the
    initial failing argument. This is why for the first property the returned value
    will differ each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the resulting failing value depends on the original failing value
    and is never `43`, but sometimes it lies quite close.
  prefs: []
  type: TYPE_NORMAL
- en: Shrinkers are essential at the time there are some properties which do not hold,
    especially if the input data is of significant size.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property-based testing is a supplementary technique to the traditional unit
    testing and behavior-driven development. It allows one to describe program properties
    in the form of an abstract specification, and the test data in the form of rules
    to apply for its generation.
  prefs: []
  type: TYPE_NORMAL
- en: Properly generated data includes edge cases, which are often ignored during
    example-based testing, and allows for higher code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScalaCheck` is a framework for property-based testing with Scala. It has
    three main components—properties, generators, and shrinkers.
  prefs: []
  type: TYPE_NORMAL
- en: Universally quantified properties must hold for any test data in any state of
    the program. Conditional properties are defined for some subset of the data or
    specific states of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '`ScalaCheck` provides a lots of generators for standard types out of the box.
    The best way to create generators for custom types is by combining existing generators
    using suitable methods defined on them.'
  prefs: []
  type: TYPE_NORMAL
- en: The role of an optional shrink is to reduce a test data set for a failing property,
    helping to identify a minimal failing test case.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few extension libraries available which allow one to generate arbitrary
    case classes and ADTs ([scalacheck-shapeless](https://github.com/alexarchambault/scalacheck-shapeless)),
    cats type class instances ([cats-check](https://github.com/non/cats-check)), and
    other common cases ([scalacheck-toolbox](https://github.com/47deg/scalacheck-toolbox)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are properly equipped to start our journey into the land of functional
    programming concepts, which we will cover in the next part of the book. We will
    start by examining some types present in the standard library, which are known
    as effects, such as `Option`, `Try`, `Either`, and `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define an invariant property for sorting a list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an idempotent property for sorting a list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an inductive property for sorting a list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a generator for a `List[Lists[Int]]`, such that elements of the nested
    list are positive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a generator for a `Map[UUID, () => String]`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
