["```java\ntrait Plugin {\n\n  //Called when the application starts.\n  def onStart() {}\n\n  // Called when the application stops.\n  def onStop() {}\n\n  // Is the plugin enabled?\n  def enabled: Boolean = true\n}\n```", "```java\nclass NotifierPlugin(app:Application) extends Plugin{ \n\n  private def notify(adminId:String,status:String):Unit = { \n\n    val time = new Date() \n\n    val msg = s\"The app has been $status at $time\" \n\n    //send email to admin with the msg\n\n    log.info(msg)\n\n  } \n\n  override def onStart() { \n\n    val emailId = app.configuration.getString(\"notify.admin.id\").get \n\n    notify(emailId,\"started\") \n\n  } \n\n  override def onStop() {     \n\n    val emailId = app.configuration.getString(\"notify.admin.id\").get \n\n    notify(emailId,\"stopped\") \n\n  } \n\n  override def enabled: Boolean = true \n\n}\n```", "```java\nclass CassandraPlugin(app: Application) extends Plugin {\n\n  private var _helper: Option[CassandraConnection] = None\n\n  def helper = _helper.getOrElse(throw new RuntimeException(\"CassandraPlugin error: CassandraHelper initialization failed\"))\n\n  override def onStart() = {\n\n    val appConfig = app.configuration.getConfig(\"cassandraPlugin\").get\n    val appName: String = appConfig.getString(\"appName\").getOrElse(\"appWithCassandraPlugin\")\n\n    val hosts: Array[java.lang.String] = appConfig.getString(\"host\").getOrElse(\"localhost\").split(\",\").map(_.trim)\n    val port: Int = appConfig.getInt(\"port\").getOrElse(9042)\n\n    val cluster = Cluster.builder()\n      .addContactPoints(hosts: _*)\n      .withPort(port).build()\n\n    _helper = try {\n      val session = cluster.connect()\n      Some(CassandraConnection(hosts, port, cluster, session))\n    } catch {\n      case e: NoHostAvailableException =>\n        val msg =\n          s\"\"\"Failed to initialize CassandraPlugin.\n             |Please check if Cassandra is accessible at\n             | ${hosts.head}:$port or update configuration\"\"\".stripMargin\n        throw app.configuration.globalError(msg)\n    }\n  }\n\n  override def onStop() = {\n    helper.session.close()\n    helper.cluster.close()\n  }\n\n  override def enabled = true\n}\n```", "```java\nprivate[plugin] case class CassandraConnection(hosts: Array[java.lang.String],\n  port: Int,\n  cluster: Cluster,\nsession: Session)\n```", "```java\nlibraryDependencies ++= Seq(\n \"com.datastax.cassandra\" % \"cassandra-driver-core\" % \"2.0.4\",\n \"com.typesafe.play\" %% \"play\" % \"2.3.0\" % \"provided\" )\n\n```", "```java\nclass DefaultApplication(\n  override val path: File,\n  override val classloader: ClassLoader,\n  override val sources: Option[SourceMapper],\n  override val mode: Mode.Mode) extends Application with WithDefaultConfiguration with WithDefaultGlobal with WithDefaultPlugins\n```", "```java\ntrait WithDefaultPlugins {\n  self: Application =>\n  private[api] def pluginClasses: Seq[String] = {\n    import scala.collection.JavaConverters._\n    val PluginDeclaration = \"\"\"([0-9_]+):(.*)\"\"\".r\n val pluginFiles = self.classloader.getResources(\"play.plugins\").asScala.toList ++ self.classloader.getResources(\"conf/play.plugins\").asScala.toList\n\n    pluginFiles.distinct.map { plugins =>\n      PlayIO.readUrlAsString(plugins).split(\"\\n\").map(_.replaceAll(\"#.*$\", \"\").trim).filterNot(_.isEmpty).map {\n        case PluginDeclaration(priority, className) => (priority.toInt, className)\n      }\n    }.flatten.sortBy(_._1).map(_._2)\n\n  }\n...\n}\n```", "```java\n1:play.core.system.MigrationHelper\n100:play.api.i18n.DefaultMessagesPlugin\n1000:play.api.libs.concurrent.AkkaPlugin\n10000:play.api.GlobalPlugin\n```", "```java\n200:play.api.db.BoneCPPlugin\n500:play.api.db.evolutions.EvolutionsPlugin\n600:play.api.cache.EhCachePlugin\n700:play.api.libs.ws.ning.NingWSPlugin\n```", "```java\nobject CassandraHelper {\n private val casPlugin = Play.application.plugin[CassandraPlugin].get\n\n  //complete DB transactions with the connection pool started through the plugin\n  def executeStmt(stmt:String) = {\n    casPlugin.session.execute(stmt)\n  }\n\n}\n```", "```java\nobject Cassandra {\n  private val casPlugin = Play.application.plugin[CassandraPlugin].get\n\n  private val cassandraHelper = casPlugin.helper\n\n  /**\n   * gets the Cassandra hosts provided in the configuration\n   */\n  def hosts: Array[java.lang.String] = cassandraHelper.hosts\n\n  /**\n    * gets the port number on which Cassandra is running from the configuration\n   */\n  def port: Int = cassandraHelper.port\n\n  /**\n    * gets a reference of the started Cassandra cluster\n    * The cluster is built with the configured set of initial contact points\n   * and policies at startup\n   */\n  def cluster: Cluster = cassandraHelper.cluster\n\n  /**\n    * gets a reference of the started Cassandra session\n    * A new session is created on the cluster at startup\n    */\n  def session: Session = cassandraHelper.session\n\n  /**\n    * executes CQL statements available in given file.\n    * Empty lines or lines starting with `#` are ignored.\n    * Each statement can extend over multiple lines and must end with a semi-colon.\n   * @param fileName - name of the file\n   */\n  def loadCQLFile(fileName: String): Unit = {\n    Util.loadScript(fileName, cassandraHelper.session)\n  }\n\n}\n```"]