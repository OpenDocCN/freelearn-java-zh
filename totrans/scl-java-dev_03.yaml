- en: Chapter 3. Understanding the Scala Ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning a new language also means getting acquainted with a new ecosystem of
    frameworks and tools. The good news is, in Scala, we can largely inherit the very
    rich and mature set of available tools and libraries from Java. In this chapter,
    we are going to cover the major novelties and additions to the existing ecosystem
    that we, as Java developers, are already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Code editing environments—also known as IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT—a tool specific to Scala to build, test, and execute code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities as plugins to SBT to integrate with the Java ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala Worksheets—a novel approach to interactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with HTTP and interacting with external web-based services, including
    the introduction of "for comprehensions"—a useful Scala construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typesafe Activator—a convenient tool to bootstrap projects quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Scala for scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting Java Integrated Development Environments (IDEs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala is supported on all the three major Java IDEs: Eclipse-based (including
    all the different versions of Eclipse, Typesafe''s own bundled version known as
    Scala IDE as well as more commercial IDEs such as SpringSourceSTS), IntelliJ IDEA,
    and NetBeans. This means that you can just keep working as you used to with Java,
    for instance, running Scala JUnit tests inside the IDE, directly debugging or
    remote debugging. The extended Scala support on all of these platforms will provide
    you with the very useful autocompletion feature and instant feedback on the various
    types that are inferred by the compiler. In [Chapter 2](ch02.html "Chapter 2. Code
    Integration"), *Code Integration*, we used NetBeans mostly because it had a convenient,
    small, and ready-to-use database and embedded tools to reverse engineer this database
    into a RESTful API in Java. As the usage of Eclipse targets a larger audience
    and is also the reference IDE that Typesafe provides support to, we are going
    to use it for the following chapters as our main development environment.'
  prefs: []
  type: TYPE_NORMAL
- en: From the [scala-ide.org](http://scala-ide.org) website, you can download and
    install the Scala IDE for Eclipse either as the bundled version that supports
    Scala or the Scala plugin through the use of update sites (as you would do in
    Java for installing any other Eclipse plugin into an existing environment). All
    instructions to install either the bundled or the plugin versions are very well
    explained on this site, so we won't spend much time here repeating this process.
    Instructions to install IDEA and NetBeans are available from [http://www.jetbrains.com/](http://www.jetbrains.com/)
    and [http://www.netbeans.org/](http://www.netbeans.org/), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Simple Build Tool (SBT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major addition to the Java ecosystem when dealing with Scala is **Simple Build
    Tool** (**SBT**), a flexible build system written in Scala that also powers both
    Typesafe Activator, which we used in the previous chapters, and the Play framework
    that we will cover later on in this book. In contrast to the existing XML formats
    used by Ant and Maven in Java environments, SBT build definitions are written
    in Scala in the form of a **Domain Specific Language** (**DSL**), having the benefit
    of compile-time checking. As we will see in this section, SBT provides a number
    of additional convenient features. In addition to its dependency management ability
    based on Ivy and supporting Maven-format repositories, SBT offers both incremental
    compilation and an interactive shell (that is, the REPL we were using earlier).
    It also supports continuous testing and deployment, and integrates with many Scala
    test frameworks, making it the de facto build tool for the Scala community.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with SBT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SBT consists of a single `.jar` archive as well as a very small start script.
    Therefore, it can be installed and run on any platform that supports JVM. Installation
    instructions are available at [http://www.scala-sbt.org/](http://www.scala-sbt.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once SBT is in your path (we used Version 0.13.0 at the time of writing this
    book), create a directory called `SampleProject` anywhere in your filesystem by
    entering the following commands in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To end the SBT session, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `build.sbt` file under the project root. This file gathers
    information about the project, that is, the equivalent of the Maven's `.pom` file
    in the Java world except that `build.sbt` compiles to Scala rather than being
    XML. The whole file structure of the project is illustrated in a diagram later
    on, once we have added some library dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open and edit `build.sbt` to fill out the basic information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the extra line between each statement is important. The `.sbt` files
    are not Scala programs; they are a list of Scala expressions, where a blank line
    is the delimiter between these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to import our empty project into our IDE before we start writing
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the project in Eclipse, IntelliJ IDEA, and NetBeans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sbteclipse` plugin is available to adapt a pure SBT project to an Eclipse
    project. You just need to create a `plugins.sbt` file under the `project/` directory
    and type the following line into it to import the `sbteclipse` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding given string is a way in SBT to express a dependency to a Maven
    library; it is the equivalent to what you would normally write into a `pom` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You see, downloading libraries and their dependencies in SBT is pretty much
    the same as working with Maven; they will be fetched from Maven repositories (Maven
    central and some other common repositories are already referenced by default in
    SBT; this is why you do not have to write them explicitly).
  prefs: []
  type: TYPE_NORMAL
- en: Note that eventually you should use a different version number as this plugin
    evolves from time to time. The current version is available together with the
    plugin documentation at [https://github.com/typesafehub/sbteclipse](https://github.com/typesafehub/sbteclipse).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `SampleProject/project/plugins.sbt` is present in your project, you can
    simply execute the following command to generate an Eclipse compliant project
    (still from the root of the project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now just start your Eclipse IDE if you haven't already done so, then select
    **File** |**Import...**. Navigate to **General** | **Existing Projects into Workspace**.
    Browse to the root directory of your project as you would do in Java and click
    on **OK**. Then, click on **Finish** to complete the import of the project, which
    will appear in the **Project Explorer** window.
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ** also has its plugin, which is available at [https://github.com/mpeltonen/sbt-idea](https://github.com/mpeltonen/sbt-idea).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that for the various IDEs, there are two plugin concepts: **SBT plugins**
    for particular IDEs and **IDE plugins** for SBT.'
  prefs: []
  type: TYPE_NORMAL
- en: The sbteclipse, sbt-idea, and nbsbt ([https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans](https://github.com/dcaoyuan/nbscala/wiki/SbtIntegrationInNetBeans))
    plugins are all SBT plugins that require modifications to your `plugins.sbt` file.
    When you run the appropriate SBT command, they generate project files to be used
    by Eclipse, IntelliJ, or NetBeans. When you update your SBT files, you may need
    to rerun the plugin in order to update your IDE configuration.
  prefs: []
  type: TYPE_NORMAL
- en: However, if an IntelliJ user browses the available IntelliJ plugins, then they
    will see a different Scala plugin there ([http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA](http://confluence.jetbrains.com/display/SCA/Scala+Plugin+for+IntelliJ+IDEA)).
    This is an add-on for IntelliJ, rather than an add-on for SBT. It helps IntelliJ
    to configure itself around an SBT project automatically, without the need for
    any modification to your SBT files or extra commands. This approach is arguably
    more popular in the IntelliJ community.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Maven and Eclipse in the Java world, then this is pretty much the
    same story as the m2eclipse Eclipse plugin versus the eclipse: eclipse Maven plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to Eclipse, you should edit a `plugins.sbt` file under `project/` and
    place the dependency to the `sbt-idea` plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The command to create an IntelliJ-compliant project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that as of IntelliJ IDEA 13, the IDEA Scala plugin natively
    supports SBT and doesn't require the external plugin to work. Refer to the IntelliJ
    documentation on how to import an SBT project into the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes newer versions of the plugin that are not present (yet) in the default
    Maven repositories exist. In this case, you have to add such a repository for
    SBT to be able to upload the plugin/library. You can do this by having an extra
    line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Scala Version 2.10+, NetBeans also has its plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin itself can be downloaded and built from a GitHub repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `publish-local` command will deploy it locally on your filesystem. Then,
    creating the files for your project is done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are going to continue the chapter adopting Eclipse as our IDE, but most of
    the tools should also work under the other IDEs. Moreover, if you need additional
    integration with other editors such as ENSIME and Sublime Text, browse the documentation
    at [http://www.scala-sbt.org](http://www.scala-sbt.org).
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is imported into Eclipse, you will notice that the file structure
    is the same as for Maven projects; source files have the default directories `src/main/scala`
    and `src/test/scala`, and this is the same structure for Java too.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web application that runs on a servlet container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Among the growing list of available SBT plugins is the xsbt-web-plugin (available
    at [https://github.com/JamesEarlDouglas/xsbt-web-plugin](https://github.com/JamesEarlDouglas/xsbt-web-plugin)),
    a useful plugin to create traditional web apps that runs on a servlet container
    (such as Jetty). As for the plugins we''ve previously seen, installation consists
    of adding single line to the `plugins.sbt` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following line to the `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to include Jetty in the container classpath as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole minimal `build.sbt` file is given as a summary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have updated our build file with new dependencies, we need to rerun `sbteclipse`
    to update the Eclipse files for our project. This operation can be achieved by
    re-entering from the SBT command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now write a tiny servlet in Scala in the IDE to exhibit our small sample
    logic, which mimics the Java syntax. Right-click on the root of the project in
    the **Package Explorer** window, and select **Refresh** to make sure the new dependencies
    are picked up. The whole structure of the project is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a web application that runs on a servlet container](img/3637_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now start editing a new Scala file under `src/main/scala` (in a new
    `com.samples` package) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a `web.xml` file as we would normally do in Java to
    configure the servlet deployment (to be put under the `src/main/webapp/WEB-INF`
    directory) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'From the root of the project, in our command prompt, we are now ready to deploy
    and execute our little example in the Jetty container by invoking `sbt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By default, the container will listen on localhost at port 8080.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now open `http://localhost:8080/` on a web browser and verify whether
    we get the Hello, world! message as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a web application that runs on a servlet container](img/3637_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may also run the `package` command from SBT that will assemble a `.war`
    archive and put it under `target/scala-2.10/sampleproject_2.10-1.0.war` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using sbt-assembly to build a single .jar archive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sbt-assembly plugin can gather all your project code and its dependencies
    into a single `.jar` file that can be published into a repository or deployed
    on other environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the plugin consists of adding sbt-assembly as a dependency in `project/assembly.sbt`
    (from SBT 0.13), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to run the assembly command within SBT, you just need to create
    an `assembly.sbt` file in the project root directory as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Assembly settings are documented at [https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly).
    They enable you to modify, for example, the `jarName` or the `outputPath`, variables
    as well as skipping tests during the assembly phase or setting a main class explicitly
    if you wish to create a runnable `.jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting code with Scalariform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automatic code formatting is a useful feature not only for its ability to apply
    the same formatting rules to code written by various individuals but also to make
    the differences appear more consistently in a source management tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala IDE for Eclipse uses Scalariform as its code formatter, which is
    also available as an sbt-plugin that can be added to the `plugins.sbt` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once you have it in place, Scalariform will format your source code automatically
    whenever you run `compile` or `test:compile` in SBT.
  prefs: []
  type: TYPE_NORMAL
- en: In Eclipse, formatting code is performed the same way as with Java, that is,
    right-clicking in the editor and then navigating to **Source** | **Format** (or
    *Ctrl* + *Shift* + *F*).
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with Scala Worksheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we had run the REPL as an interactive environment
    to experiment and get immediate feedback when entering the Scala syntax. This
    allowed us to very quickly write some small algorithms and get the right syntax
    to make things work. Although the SBT console provides programmers with a `:replay`
    command to rerun what has already been written in the session, wouldn't it be
    nice to be able to save our experiments for later use, as part of our project
    ? This is exactly what **Scala Worksheets** are all about.
  prefs: []
  type: TYPE_NORMAL
- en: Scala Worksheet is an innovative feature of the Scala support for Eclipse that
    brings an interactive environment, that is, a REPL in the context of a project.
    This feature is also now available on the Scala support for IntelliJ.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go to our small servlet sample in Eclipse to try it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a worksheet, right-click on any package or source file and navigate
    to **New** | **Scala Worksheet** (or if not present in the drop-down list, navigate
    to **Other...** | **Scala Wizards** | **Scala Worksheet**), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Experimenting with Scala Worksheets](img/3637_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will choose, for example, the current `com.samples` package. Click on **Next**
    and enter a name for your worksheet: `experiment`.'
  prefs: []
  type: TYPE_NORMAL
- en: This will create a file named `experiment.sc` that is saved within the source
    code but as it is not a `.scala` file, it will not be in conflict with the rest
    of our current code base nor be present in the deployed `.jar` archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default page looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything after the `>` sign on each statement is the result of the evaluation
    that gets (re)evaluated as soon as you save the Worksheet file. You may try out
    a few statements, for instance, by replacing the `println` statement with a few
    lines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you save it (*Ctrl* + *S*), the style sheet will display statement
    evaluations on the right-hand side as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Experimenting with Scala Worksheets](img/3637OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Scala can import and invoke Java classes as well as extend them, many of
    the Scala libraries available as part of the Scala ecosystem are only a thin layer
    on top of robust and mature Java libraries, to either provide additional features
    or simplify their usage by adding some syntactic sugar.
  prefs: []
  type: TYPE_NORMAL
- en: One such example is the Scala dispatch library (available at [http://dispatch.databinder.net/Dispatch.html](http://dispatch.databinder.net/Dispatch.html)),
    a useful library to achieve HTTP interaction based on Apache's robust HttpClient.
    Let's run a little dispatch session in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'As dispatch is an external library; we first need to import it into our SBT
    project to be able to use it from the REPL console. Add the dispatch dependency
    to the `build.sbt` file of the `SampleProject` so that it looks like the following
    code snippet (make sure to have a blank line between statements in `build.sbt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the REPL to make the libraries available, and import them into the
    session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a basic request to an online geolocation service, where the REST
    API is a simple `GET` request to the `freegeoip.net/{format}/{ip_or_hostname}`
    URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will send the `GET` request through HTTP and take the response as a
    string (wrapping XML as this is what we ask as response format from the service):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice the result type of `dispatch.Future[String]` returned by the interpreter.
    The previous versions of dispatch were synchronous (and still available under
    the library name, `dispatch-classic`) but the latest versions such as the one
    we are using cope with modern development practices, namely asynchrony. We will
    study the asynchronous Scala code later in [Chapter 8](ch08.html "Chapter 8. Essential
    Properties of Modern Applications – Asynchrony and Concurrency"), *Essential Properties
    of Modern Applications – Asynchrony and Concurrency*, but similar to Java, `Future`
    acts as a placeholder for a computation that does not block. This means that we
    can continue the flow of the program without waiting for the variable to be populated,
    which is convenient when invoking potentially long-running method calls (such
    as a REST service). Note, however, that here `dispatch.Future` is a different
    implementation than `java.util.concurrent.Future`, which is found in the standard
    Java library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read and display the result of our HTTP request, we can just type the following
    command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Calling `result()` here is the syntactic sugar for actually calling the `result.apply()`
    method, a convenient way to make code look elegant in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch provides a lot of ways to handle both the request, such as adding headers
    and parameters, and the processing of the response such as handling the response
    as XML or JSON, splitting into two different handlers or dealing with streams.
    To exhibit these behaviors, we are going to call another online service as an
    example, the **Groupon** service. Groupon is a service that offers discount coupons
    when you buy a product or service such as holidays, beauty products, and so on
    in a variety of categories. The Groupon API can be queried to gather offerings
    within a geographic location determined by either city or coordinates (latitude
    and longitude).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to experiment with the API, upon registration to the [http://www.groupon.com/pages/api](http://www.groupon.com/pages/api)
    URL, you should obtain a unique `client_id` key that authenticates you and that
    you have to pass along whenever you call the API. Let''s illustrate this in the
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL limits the amount of output for better readability. Instead of getting
    the response as a string, let''s handle it as XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This time our result is more structured as it is represented as an XML tree.
    We can print it in a better format by applying a `PrettyPrinter` object that will
    make the output fit within a width of 90 characters with an indentation of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting partial information from our XML structure can be achieved by applying
    the `map` transformations including XPath expressions. XPath expressions are useful
    to navigate through XML elements to retain only the relevant parts. We can progressively
    extract pieces of XML and return them as collections such as `Lists` or `Seqs`
    (sequences), as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we got back a sequence of city names for which there are coupons available.
  prefs: []
  type: TYPE_NORMAL
- en: Scala's for comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of applying successive `map` transformations to extract XML, in Scala,
    we can use a powerful construct that represents the silver bullet of iterations
    called `for comprehension` or `for expression`. Unlike the `for` loops found in
    Java and used for iterating, `for comprehension` returns a result. They are specified
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `sequence` can contain the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generators**: They drive the iteration and are written in the following form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As for Java loops, `element` represents a local variable bound to the current
    element of the iteration whereas `collection` represents the data to be iterated.
    Moreover, the first generator (there needs to be at least one) determines the
    type of the result. For example, if the input collection is a `List` or a `Vector`,
    the `for comprehension` will yield a `List` or a `Vector`, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Filters**: They control the iteration and are written in the following form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding expression must evaluate to a Boolean value. Filters can be defined
    either on the same line as generators or separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Definitions**: They are local variable definitions and are written in the
    following form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: They are intermediate values that can contribute to compute the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A `for comprehension` construct is much easier to visualize with a few concrete
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have transformed `List[Int]` into `List[String]` using only one generator.
    Using two generators is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a filter on any generator. For instance, if we want to retain only
    the uppercase characters of every word, we can write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we illustrate how to add a local variable definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to our HTTP Groupon service, we can now extract names of cities
    using `for comprehension` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to query the second part of the API to retrieve special discount
    deals for a specific area, we also need the latitude and longitude information
    from the queried cities. Let''s do that by returning a tuple including three elements,
    the first one being the name, the second being the latitude, and the third being
    the longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of the list of returned cities, we might be interested in just one for
    now. Let''s retrieve only the location for Honolulu using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `find` method in the preceding code takes a predicate as a parameter. As
    its return type is an `Option` value, we can retrieve its content by invoking
    `getOrElse` where we can write a default value in case the `find` method does
    not return any match.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative representation could be done using pattern matching, briefly
    described in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within
    Your Project"), *Programming Interactively within Your Project*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The regular syntax of pattern matching normally uses the `match` keyword before
    all the `case` alternatives, so here it is a simplified notation where the `match`
    keyword is implicit. The underscore (`_`) as well as the `city` variable given
    in `case` are wildcards in the pattern matching. We could have given these underscores
    variable names but it is not necessary as we are not using them in the predicate
    (that is, `city == "Honolulu"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a request to query for all the deals that match a particular
    geographic area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative to handle data as tuples is to define case classes to encapsulate
    elements in a convenient and reusable way. We can, therefore, define a `Deal`
    class and rewrite our previous `for comprehension` statement returning the `Deal`
    instances instead of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did previously for retrieving cities, we can now retrieve deals via HTTP
    GET and parse XML this time for the particular city of Honolulu, knowing its latitude
    and longitude, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<<?` operator means that we attach input parameters of a `GET` method
    to the `dealsByGeoArea` request. The `Map` object contains the parameters. It
    is equivalent to the normal representation of HTTP GET where we put the input
    parameters as key/value pairs in the URL (that is, `request_url?param1=value1;param2=value2`).
    This is in contrast with the `<<` operator, which would have specified a `POST`
    request. Creating a structured sequence of `Deal` instances out of the raw XML
    produced by the `dealsInHonolulu()` service call can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorting the list of deals by their category is only a matter of applying a
    `groupBy` method on the collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the `groupBy` method is a very convenient way of applying the `Map`
    part of a **MapReduce** job operating on a collection, in our case creating a
    `Map` object where keys are the tags or categories of the Groupon deals and values
    are a list of the deals that belong to the specific category. A possible tiny
    `Reduce` operation on the `Map` object can, for example, consist of counting the
    number of deals for each category, using the `mapValues` method that transforms
    the values of this (key,value) store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The example we went through only explores the surface of what we can do with
    HTTP tools such as dispatch and much more is described in their documentation.
    The direct interaction with the REPL greatly enhances the learning curve of such
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: There are several excellent alternatives of lightweight frameworks for dealing
    with HTTP interaction, and in the case of dispatch, we have only looked at the
    client side of things. Lightweight REST APIs can, therefore, be constructed by
    frameworks such as Unfiltered, Finagle, Scalatra, or Spray to name a few. Spray
    is currently being architected again to become the HTTP layer of the Play framework
    (on top of Akka); technologies we are going to cover later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of Typesafe Activator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to run an interactive programming session in the previous chapters,
    we have downloaded and installed a tool named **Typesafe Activator**. Running
    either as a command-line tool or through a web browser, the activator lets us
    create and execute a sample project out of a template, in this case, a minimal
    `hello-scala` project. From it, we have accessed the SBT console, which acts as
    a REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Typesafe Activator can be seen as a lightweight IDE powered by SBT. It provides
    many project templates that programmers can reuse as a starting point in their
    new development project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application based on activator templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a command terminal window and go to the directory where you extracted
    the activator, then enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to enter a name for your new project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Version 1.0.13 that we are using already contains 76 templates combining diverse
    technologies and frameworks together to make some interesting demo projects, but
    this list is increasing quickly (from 38 to 76 between Version 1.0.0 and 1.0.13,
    which are only a few months apart).
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s take a look at the `play-java-spring` template, a project sample
    in Java, so that we can feel comfortable with the code it contains. Therefore,
    enter its name when prompted for the name of the template to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The activator creates a SBT project, meaning you can edit `build.sbt` or `plugins.sbt`
    to add dependencies, repositories (that is, resolvers) as well as SBT plugins.
    We can, for example, reuse the `addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin"
    % "2.4.0")` line in `plugins.sbt` that we stated earlier to be able to create
    Eclipse project files and import the project into our Scala IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s execute the program to see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As the sample is based on the Play framework (that we will cover in later chapters),
    the following is displayed to indicate that the web application is deployed on
    localhost at port 9000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a browser at localhost:9000 to visualize the very basic web form of the
    sample and submit a couple of entries to be stored in the tiny database, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application based on activator templates](img/3637_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This web application takes an input from a simple HTML form and saves `Bar`
    objects into a small database through JPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a look at the code that is part of this template; we can run it through
    the activator by first pressing *Ctrl* + *D* in the command window to interrupt
    the current execution, and then, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, a browser page should open at `http://localhost:8888/app/javasample/`
    displaying the activator user interface specifically targeted to this application.
    Click on the **Code view & Open in IDE** item and navigate to the `app/models/Bar.java`
    file by double-clicking on the items on the left-hand side panel, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application based on activator templates](img/3637_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The browser displays a JPA-annotated entity as we are used to working with typically
    in the Eclipse IDE with colored and formatted syntax. The panel on the right-hand
    side leaves room for a tutorial, a precious feature to quickly understand the
    code and start modifying it. The top menu enables you to compile, run, or test
    the application from within the browser. You can open some of the other source
    files to identify the structure of the code, although we will cover play web applications
    in detail later on.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Typesafe Activator is a way to get you started in just minutes and
    is very flexible as you can run activator projects directly as SBT projects, therefore,
    having the possibility to generate IDE-specific files to continue working in Eclipse,
    IDEA, or NetBeans if you wish to.
  prefs: []
  type: TYPE_NORMAL
- en: The REPL as a scripting engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deal with interoperability with programs written in scripting languages,
    the Java community process has defined *JSR-223*, *Scripting for the JavaTM Platform*,
    a Java specification request that makes it possible to execute scripts written
    in other languages (such as Groovy, JavaScript, Ruby, or Jython to name of few)
    from within a Java program. For instance, we can write a Java program embedding
    a basic JavaScript snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output from the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from Scala''s upcoming Version 2.11, this very convenient functionality
    will let you interpret scripts written in Scala as well. The following is an example
    that we can just run directly in the REPL (taken from the [scala-lang.org](http://scala-lang.org)
    documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The engine context can bind the `n` variable to the integer value `5`, which
    can be invoked in the one-liner script which consists of a `foreach` lambda expression.
    The script, in this case, is only a side effect and does not return any interesting
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered some of the major differences between the Java
    and Scala ecosystems, and it is noticed that apart from SBT and REPL, which are
    not found in the Java world, we are able to reuse all the Java libraries, tools,
    and frameworks. We have seen that this `group % artifact % version` format used
    to load dependencies in SBT is the same as that of Java's Maven, and in fact,
    SBT, by default, is similar to most of the Maven repositories (for example, Maven
    Central). We can, therefore, feel confident that the vast majority of our Java
    skills are reusable, and they make the transition easier at least as long as the
    ecosystem is concerned. We voluntarily omitted talking about the testing ecosystem
    as this is the main topic of our next chapter.
  prefs: []
  type: TYPE_NORMAL
