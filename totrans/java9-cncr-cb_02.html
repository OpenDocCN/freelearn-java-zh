<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Basic Thread Synchronization</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Synchronizing a method</li>
<li class="calibre18">Using conditions in synchronized code</li>
<li class="calibre18">Synchronizing a block of code with a lock</li>
<li class="calibre18">Synchronizing data access with read/write locks</li>
<li class="calibre18">Using multiple conditions in a <span>lock</span></li>
<li class="calibre18">Advanced locking with the StampedLock class</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">One of the most common situations in concurrent programming occurs when more than one execution thread shares a resource. In a concurrent application, it is normal for multiple threads to read or write the same data structure or have access to the same file or database connection. These shared resources can provoke error situations or data inconsistency, and we have to implement mechanisms to avoid these errors. These situations are called <strong class="calibre1">race conditions</strong> and they occur when different threads have access to the same shared resource at the same time. Therefore, the final result depends on the order of the execution of threads, and most of the time, it is incorrect. You can also have problems with change visibility. So if a thread changes the value of a shared variable, the changes would only be written in the local cache of that thread; other threads will not have access to the change (they will only be able to see the old value).</p>
<p class="calibre4">The solution for these problems lies in the concept of <strong class="calibre1">critical section</strong>. A critical section is a block of code that accesses a shared resource and can't be executed by more than one thread at the same time.</p>
<p class="calibre4">To help programmers implement critical sections, Java (and almost all programming languages) offers synchronization mechanisms. When a thread wants access to a critical section, it uses one of these synchronization mechanisms to find out whether there is any other thread executing the critical section. If not, the thread enters the critical section. If yes, the thread is suspended by the synchronization mechanism until the thread that is currently executing the critical section ends it. When more than one thread is waiting for a thread to finish the execution of a critical section, JVM chooses one of them and the rest wait for their turn. This chapter presents a number of recipes that will teach you how to use the two basic synchronization mechanisms offered by the Java language:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">synchronized</kbd> keyword</li>
<li class="calibre18">The <kbd class="calibre15">Lock</kbd> interface and its implementations</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Synchronizing a method</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you will learn how to use one of the most basic methods of synchronization in Java, that is, the use of the <kbd class="calibre15">synchronized</kbd> keyword to control concurrent access to a method or a block of code. All the <kbd class="calibre15">synchronized</kbd> sentences (used on methods or blocks of code) use an object reference. Only one thread can execute a method or block of code protected by the same object reference.</p>
<p class="calibre4">When you use the <kbd class="calibre15">synchronized</kbd> keyword with a method, the object reference is implicit. When you use the <kbd class="calibre15">synchronized</kbd> keyword in one or more methods of an object, only one execution thread will have access to all these methods. If another thread tries to access any method declared with the <kbd class="calibre15">synchronized</kbd> keyword of the same object, it will be suspended until the first thread finishes the execution of the method. In other words, every method declared with the <kbd class="calibre15">synchronized</kbd> keyword is a critical section, and Java only allows the execution of one of the critical sections of an object at a time. In this case, the object reference used is the <kbd class="calibre15">own</kbd> object, represented by the <kbd class="calibre15">this</kbd> keyword. Static methods have a different behavior. Only one execution thread will have access to one of the static methods declared with the <kbd class="calibre15">synchronized</kbd> keyword, but a different thread can access other non-static methods of an object of that class. You have to be very careful with this point because two threads can access two different <kbd class="calibre15">synchronized</kbd> methods if one is static and the other is not. If both methods change the same data, you can have data inconsistency errors. In this case, the object reference used is the class object.</p>
<p class="calibre4">When you use the <kbd class="calibre15">synchronized</kbd> keyword to protect a block of code, you must pass an object reference as a parameter. Normally, you will use the <kbd class="calibre15">this</kbd> keyword to reference the object that executes the method, but you can use other object references as well. Normally, these objects will be created exclusively for this purpose. You should keep the objects used for synchronization private. For example, if you have two independent attributes in a class shared by multiple threads, you must synchronize access to each variable; however, it wouldn't be a problem if one thread is accessing one of the attributes and the other accessing a different attribute at the same time. Take into account that if you use the <kbd class="calibre15">own</kbd> object (represented by the <kbd class="calibre15">this</kbd> keyword), you might interfere with other synchronized code (as mentioned before, the <kbd class="calibre15">this</kbd> object is used to synchronize the methods marked with the <kbd class="calibre15">synchronized</kbd> keyword).</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">synchronized</kbd> keyword to implement an application simulating a parking area, with sensors that detect the following: when a car or a motorcycle enters or goes out of the parking area, an object to store the statistics of the vehicles being parked, and a mechanism to control cash flow. We will implement two versions: one without any synchronization mechanisms, where we will see how we obtain incorrect results, and one that works correctly as it uses the two variants of the <kbd class="calibre15">synchronized</kbd> keyword.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, create the application without using any synchronization mechanism. Create a class named <kbd class="calibre15">ParkingCash</kbd> with an internal constant and an attribute to store the total amount of money earned by providing this parking service:</li>
</ol>
<pre class="calibre23">
          public class ParkingCash { <br class="title-page-name"/>          private static final int cost=2; <br class="title-page-name"/>          private long cash; <br class="title-page-name"/><br class="title-page-name"/>          public ParkingCash() { <br class="title-page-name"/>            cash=0; <br class="title-page-name"/>          }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement a method named <kbd class="calibre15">vehiclePay()</kbd> that will be called when a vehicle (a car or motorcycle) leaves the parking area. It will increase the cash attribute:</li>
</ol>
<pre class="calibre23">
        public void vehiclePay() { <br class="title-page-name"/>          cash+=cost; <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Finally, implement a method named <kbd class="calibre15">close()</kbd> that will write the value of the cash attribute in the console and reinitialize it to zero:</li>
</ol>
<pre class="calibre23">
          public void close() { <br class="title-page-name"/>            System.out.printf("Closing accounting"); <br class="title-page-name"/>            long totalAmmount; <br class="title-page-name"/>            totalAmmount=cash; <br class="title-page-name"/>            cash=0; <br class="title-page-name"/>            System.out.printf("The total amount is : %d",<br class="title-page-name"/>                              totalAmmount); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a class named <kbd class="calibre15">ParkingStats</kbd> with three private attributes and the constructor that will initialize them:</li>
</ol>
<pre class="calibre23">
          public class ParkingStats { <br class="title-page-name"/>          private long numberCars; <br class="title-page-name"/>          private long numberMotorcycles; <br class="title-page-name"/>          private ParkingCash cash; <br class="title-page-name"/><br class="title-page-name"/>          public ParkingStats(ParkingCash cash) { <br class="title-page-name"/>            numberCars = 0; <br class="title-page-name"/>            numberMotorcycles = 0; <br class="title-page-name"/>              this.cash = cash; <br class="title-page-name"/>          }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, implement the methods that will be executed when a car or motorcycle enters or leaves the parking area. When a vehicle leaves the parking area, cash should be incremented:</li>
</ol>
<pre class="calibre23">
        public void carComeIn() { <br class="title-page-name"/>          numberCars++; <br class="title-page-name"/>        } <br class="title-page-name"/><br class="title-page-name"/>        public void carGoOut() { <br class="title-page-name"/>          numberCars--; <br class="title-page-name"/>          cash.vehiclePay(); <br class="title-page-name"/>        }
</pre>
<pre class="calibre23">
        public void motoComeIn() { <br class="title-page-name"/>          numberMotorcycles++; <br class="title-page-name"/>        } <br class="title-page-name"/><br class="title-page-name"/>        public void motoGoOut() { <br class="title-page-name"/>          numberMotorcycles--; <br class="title-page-name"/>          cash.vehiclePay(); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Finally, implement two methods to obtain the number of cars and motorcycles in the parking area, respectively.</li>
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">Sensor</kbd> that will simulate the movement of vehicles in the parking area. It implements the <kbd class="calibre15">Runnable</kbd> interface and has a <kbd class="calibre15">ParkingStats</kbd> attribute, which will be initialized in the constructor:</li>
</ol>
<pre class="calibre23">
        public class Sensor implements Runnable { <br class="title-page-name"/><br class="title-page-name"/>          private ParkingStats stats; <br class="title-page-name"/><br class="title-page-name"/>          public Sensor(ParkingStats stats) { <br class="title-page-name"/>            this.stats = stats; <br class="title-page-name"/>          }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. In this method, simulate that two cars and a motorcycle arrive in and then leave the parking area. Every sensor will perform this action 10 times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i = 0; i&lt; 10; i++) { <br class="title-page-name"/>            stats.carComeIn(); <br class="title-page-name"/>            stats.carComeIn(); <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(50); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>            stats.motoComeIn(); <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(50); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            }
</pre>
<pre class="calibre23">
 <br class="title-page-name"/>            stats.motoGoOut(); <br class="title-page-name"/>            stats.carGoOut(); <br class="title-page-name"/>            stats.carGoOut(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Finally, implement the main method. Create a class named <kbd class="calibre15">Main</kbd> with the <kbd class="calibre15">main()</kbd> method. It needs <kbd class="calibre15">ParkingCash</kbd> and <kbd class="calibre15">ParkingStats</kbd> objects to manage parking:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/><br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/><br class="title-page-name"/>            ParkingCash cash = new ParkingCash(); <br class="title-page-name"/>            ParkingStats stats = new ParkingStats(cash); <br class="title-page-name"/><br class="title-page-name"/>            System.out.printf("Parking Simulator\n");
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, create the <kbd class="calibre15">Sensor</kbd> tasks. Use the <kbd class="calibre15">availableProcessors()</kbd> method (that returns the number of available processors to the JVM, which normally is equal to the number of cores in the processor) to calculate the number of sensors our parking area will have. Create the corresponding <kbd class="calibre15">Thread</kbd> objects and store them in an array:</li>
</ol>
<pre class="calibre23">
        intnumberSensors=2 * Runtime.getRuntime()<br class="title-page-name"/>                                           .availableProcessors(); <br class="title-page-name"/>        Thread threads[]=new Thread[numberSensors]; <br class="title-page-name"/>        for (int i = 0; i&lt;numberSensors; i++) { <br class="title-page-name"/>          Sensor sensor=new Sensor(stats); <br class="title-page-name"/>          Thread thread=new Thread(sensor); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>          threads[i]=thread; <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Then wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;numberSensors; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Finally, write the statistics of <kbd class="calibre15">Parking</kbd>:</li>
</ol>
<pre class="calibre23">
            System.out.printf("Number of cars: %d\n",<br class="title-page-name"/>                              stats.getNumberCars()); <br class="title-page-name"/>            System.out.printf("Number of motorcycles: %d\n",<br class="title-page-name"/>                               stats.getNumberMotorcycles()); <br class="title-page-name"/>            cash.close(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<p class="calibre4">In our case, we executed the example in a four-core processor, so we will have eight <kbd class="calibre15">Sensor</kbd> tasks. Each task performs 10 iterations, and in each iteration, three vehicles enter the parking area and the same three vehicles go out. Therefore, each <kbd class="calibre15">Sensor</kbd> task will simulate 30 vehicles.</p>
<p class="calibre4">If everything goes well, the final stats will show the following:</p>
<ul class="calibre17">
<li class="calibre18">There are no cars in the parking area, which means that all the vehicles that came into the parking area have moved out</li>
<li class="calibre18">Eight <kbd class="calibre15">Sensor</kbd> tasks were executed, where each task simulated 30 vehicles and each vehicle was charged 2 dollars each; therefore, the total amount of cash earned was 480 dollars</li>
</ul>
<p class="calibre4">When you execute this example, each time you will obtain different results, and most of them will be incorrect. The following screenshot shows an example:</p>
<div class="cdpaligncenter"><img class="image-border" src="../images/00014.jpeg"/></div>
<p class="calibre4">We had race conditions, and the different shared variables accessed by all the threads gave incorrect results. Let's modify the previous code using the synchronized keyword to solve these problems:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, add the synchronized keyword to the <kbd class="calibre15">vehiclePay()</kbd> method of the <kbd class="calibre15">ParkingCash</kbd> class:</li>
</ol>
<pre class="calibre23">
        public synchronized void vehiclePay() { <br class="title-page-name"/>          cash+=cost; <br class="title-page-name"/>        }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Then, add a <kbd class="calibre15">synchronized</kbd> block of code using the <kbd class="calibre15">this</kbd> keyword to the <kbd class="calibre15">close()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public void close() { <br class="title-page-name"/>          System.out.printf("Closing accounting"); <br class="title-page-name"/>          long totalAmmount; <br class="title-page-name"/>          synchronized (this) { <br class="title-page-name"/>            totalAmmount=cash; <br class="title-page-name"/>            cash=0; <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("The total amount is : %d",totalAmmount); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Now add two new attributes to the <kbd class="calibre15">ParkingStats</kbd> class and initialize them in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        private final Object controlCars, controlMotorcycles; <br class="title-page-name"/>        public ParkingStats (ParkingCash cash) { <br class="title-page-name"/>          numberCars=0; <br class="title-page-name"/>          numberMotorcycles=0; <br class="title-page-name"/>          controlCars=new Object(); <br class="title-page-name"/>          controlMotorcycles=new Object(); <br class="title-page-name"/>          this.cash=cash; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Finally, modify the methods that increment and decrement the number of cars and motorcycles, including the <kbd class="calibre15">synchronized</kbd> keyword. The <kbd class="calibre15">numberCars</kbd> attribute will be protected by the <kbd class="calibre15">controlCars</kbd> object, and the <kbd class="calibre15">numberMotorcycles</kbd> attribute will be protected by the <kbd class="calibre15">controlMotorcycles</kbd> object. You must also synchronize the <kbd class="calibre15">getNumberCars()</kbd> and <kbd class="calibre15">getNumberMotorcycles()</kbd> methods with the associated reference object:</li>
</ol>
<pre class="calibre23">
        public void carComeIn() { <br class="title-page-name"/>          synchronized (controlCars) { <br class="title-page-name"/>            numberCars++; <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/><br class="title-page-name"/>        public void carGoOut() { <br class="title-page-name"/>          synchronized (controlCars) { <br class="title-page-name"/>            numberCars--; <br class="title-page-name"/>          } <br class="title-page-name"/>          cash.vehiclePay(); <br class="title-page-name"/>        } 
</pre>
<pre class="calibre23">
 <br class="title-page-name"/>        public void motoComeIn() { <br class="title-page-name"/>          synchronized (controlMotorcycles) { <br class="title-page-name"/>            numberMotorcycles++; <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/><br class="title-page-name"/>        public void motoGoOut() { <br class="title-page-name"/>          synchronized (controlMotorcycles) { <br class="title-page-name"/>            numberMotorcycles--; <br class="title-page-name"/>          } <br class="title-page-name"/>          cash.vehiclePay(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Execute the example now and see the difference when compared to the previous version.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the output of the new version of the example. No matter how many times you execute it, you will always obtain the correct result:</p>
<div class="cdpaligncenter"><img class="image-border1" src="../images/00015.jpeg"/></div>
<p class="calibre4">Let's see the different uses of the <kbd class="calibre15">synchronized</kbd> keyword in the example:</p>
<ul class="calibre17">
<li class="calibre18">First, we protected the <kbd class="calibre15">vehiclePay()</kbd> method. If two or more <kbd class="calibre15">Sensor</kbd> tasks call this method at the same time, only one will execute it and the rest will wait for their turn; therefore, the final amount will always be correct.</li>
<li class="calibre18">We used two different objects to control access to the car and motorcycle counters. This way, one <kbd class="calibre15">Sensor</kbd> task can modify the <kbd class="calibre15">numberCars</kbd> attribute and another <kbd class="calibre15">Sensor</kbd> task can modify the <kbd class="calibre15">numberMotorcycles</kbd> attribute at the same time; however, no two <kbd class="calibre15">Sensor</kbd> tasks will be able to modify the same attribute at the same time, so the final value of the counters will always be correct.</li>
</ul>
<p class="calibre4">Finally, we also synchronized the <kbd class="calibre15">getNumberCars()</kbd> and <kbd class="calibre15">getNumberMotorcycles()</kbd> methods. Using the <kbd class="calibre15">synchronized</kbd> keyword, we can guarantee correct access to shared data in concurrent applications.</p>
<p class="calibre4">As mentioned at the introduction of this recipe, only one thread can access the methods of an object that uses the <kbd class="calibre15">synchronized</kbd> keyword in their declaration. If thread (A) is executing a <kbd class="calibre15">synchronized</kbd> method and thread (B) wants to execute another <kbd class="calibre15">synchronized</kbd> method of the same object, it will be blocked until thread (A) is finished. But if thread (B) has access to different objects of the same class, none of them will be blocked.</p>
<p class="calibre4">When you use the <kbd class="calibre15">synchronized</kbd> keyword to protect a block of code, you use an object as a parameter. JVM guarantees that only one thread can have access to all the blocks of code protected with this object (note that we always talk about objects, not classes).</p>
<p class="calibre4">We used the <kbd class="calibre15">TimeUnit</kbd> class as well. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>. These indicate the units of time we pass to the sleep method. In our case, we let the thread sleep for 50 milliseconds.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">synchronized</kbd> keyword penalizes the performance of the application, so you must only use it on methods that modify shared data in a concurrent environment. If you have multiple threads calling a <kbd class="calibre15">synchronized</kbd> method, only one will execute them at a time while the others will remain waiting. If the operation doesn't use the <kbd class="calibre15">synchronized</kbd> keyword, all the threads can execute the operation at the same time, reducing the total execution time. If you know that a method will not be called by more than one thread, don't use the <kbd class="calibre15">synchronized</kbd> keyword. Anyway, if the class is designed for multithreading access, it should always be correct. You must promote correctness over performance. Also, you should include documentation in methods and classes in relation to their thread safety.</p>
<p class="calibre4">You can use recursive calls with <kbd class="calibre15">synchronized</kbd> methods. As the thread has access to the <kbd class="calibre15">synchronized</kbd> methods of an object, you can call other <kbd class="calibre15">synchronized</kbd> methods of that object, including the method that is being executed. It won't have to get access to the <kbd class="calibre15">synchronized</kbd> methods again.</p>
<p class="calibre4">We can use the <kbd class="calibre15">synchronized</kbd> keyword to protect access to a block of code instead of an entire method. We should use the <kbd class="calibre15">synchronized</kbd> keyword in this way to protect access to shared data, leaving the rest of the operations out of this block and obtaining better performance of the application. The objective is to have the critical section (the block of code that can be accessed only by one thread at a time) as short as possible. Also, avoid calling blocking operations (for example, I/O operations) inside a critical section. We have used the <kbd class="calibre15">synchronized</kbd> keyword to protect access to the instruction that updates the number of persons in the building, leaving out the long operations of the block that don't use shared data. When you use the <kbd class="calibre15">synchronized</kbd> keyword in this way, you must pass an object reference as a parameter. Only one thread can access the <kbd class="calibre15">synchronized</kbd> code (blocks or methods) of this object. Normally, we will use the <kbd class="calibre15">this</kbd> keyword to reference the object that is executing the method:</p>
<pre class="calibre23">
    synchronized (this) { <br class="title-page-name"/>      // Java code <br class="title-page-name"/>    }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using conditions in synchronized code</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using conditions in synchronized code</h1>
            

            <article>
                
<p class="calibre4">A classic problem in concurrent programming is the producer-consumer problem. We have a data buffer, one or more producers of data that save it in the buffer, and one or more consumers of data that take it from the buffer.</p>
<p class="calibre4">As the buffer is a shared data structure, we have to control access to it using a synchronization mechanism, such as the <kbd class="calibre15">synchronized</kbd> keyword, but here we have more limitations. A producer can't save data in the buffer if it's full, and a consumer can't take data from the buffer if it's empty.</p>
<p class="calibre4">For these types of situations, Java provides the <kbd class="calibre15">wait()</kbd>, <kbd class="calibre15">notify()</kbd>, and <kbd class="calibre15">notifyAll()</kbd> methods implemented in the <kbd class="calibre15">Object</kbd> class. A thread can call the <kbd class="calibre15">wait()</kbd> method inside a <kbd class="calibre15">synchronized</kbd> block of code. If it calls the <kbd class="calibre15">wait()</kbd> method outside a <kbd class="calibre15">synchronized</kbd> block of code, JVM throws an <kbd class="calibre15">IllegalMonitorStateException</kbd> exception. When the thread calls the <kbd class="calibre15">wait()</kbd> method, JVM puts the thread to sleep and releases the object that controls the <kbd class="calibre15">synchronized</kbd> block of code that it's executing and allows other threads to execute other blocks of <kbd class="calibre15">synchronized</kbd> code protected by this object. To wake up the thread, you must call the <kbd class="calibre15">notify()</kbd> or <kbd class="calibre15">notifyAll()</kbd> methods inside a block of code protected by the same object.</p>
<p class="calibre4">In this recipe, you will learn how to implement the producer-consumer problem using the <kbd class="calibre15">synchronized</kbd> keyword and the <kbd class="calibre15">wait()</kbd>, <kbd class="calibre15">notify()</kbd>, and <kbd class="calibre15">notifyAll()</kbd> methods.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">EventStorage</kbd>. It has two attributes, namely an <kbd class="calibre15">int</kbd> attribute called <kbd class="calibre15">maxSize</kbd> and a <kbd class="calibre15">List&lt;Date&gt;</kbd> attribute called <kbd class="calibre15">storage</kbd>:</li>
</ol>
<pre class="calibre23">
         public class EventStorage { <br class="title-page-name"/><br class="title-page-name"/>          private int maxSize; <br class="title-page-name"/>          private Queue&lt;Date&gt; storage;
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the constructor of the class that initializes the attributes of the class:</li>
</ol>
<pre class="calibre23">
        public EventStorage(){ <br class="title-page-name"/>          maxSize=10; <br class="title-page-name"/>          storage=new LinkedList&lt;&gt;(); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">synchronized</kbd> method <kbd class="calibre15">set()</kbd> to store an event in <kbd class="calibre15">storage</kbd>. First, check whether storage is full or not. If it's full, it calls the <kbd class="calibre15">wait()</kbd> method until it has empty space. At the end of the method, we call the <kbd class="calibre15">notify()</kbd> method to wake up all the threads that are sleeping in the <kbd class="calibre15">wait()</kbd> method. In this case, we will ignore <kbd class="calibre15">InterruptedException</kbd>. In a real implementation, you must think what treatment you must give to them. You can rethrow or transform them into a different type of exception of the application:</li>
</ol>
<pre class="calibre23">
        public synchronized void set(){ <br class="title-page-name"/>          while (storage.size()==maxSize){ <br class="title-page-name"/>            try { <br class="title-page-name"/>              wait(); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          storage.offer(new Date()); <br class="title-page-name"/>          System.out.printf("Set: %d",storage.size()); <br class="title-page-name"/>          notify(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">synchronized</kbd> method <kbd class="calibre15">get()</kbd> to get an event for storage purposes. First, check whether storage has events or not. If it has no events, it calls the <kbd class="calibre15">wait()</kbd> method until it is given some events. At the end of the method, we call the <kbd class="calibre15">notifyAll()</kbd> method to wake up all the threads that are sleeping in the <kbd class="calibre15">wait()</kbd> method. In this case, we will ignore <kbd class="calibre15">InterruptedException</kbd>. In a real implementation, you must think what treatment you must give to them. You can rethrow or transform them into a different type of exception of the application:</li>
</ol>
<pre class="calibre23">
        public synchronized void get(){ <br class="title-page-name"/>          while (storage.size()==0){ <br class="title-page-name"/>            try { <br class="title-page-name"/>              wait(); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          String element=storage.poll().toString(); <br class="title-page-name"/>          System.out.printf("Get: %d: %s\n",storage.size(),element); <br class="title-page-name"/>          notify(); <br class="title-page-name"/><br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">Producer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. It will implement the producer of the example:</li>
</ol>
<pre class="calibre23">
        public class Producer implements Runnable {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare an <kbd class="calibre15">EventStore</kbd> object and implement the constructor of the class that initializes this object:</li>
</ol>
<pre class="calibre23">
        private EventStorage storage; <br class="title-page-name"/><br class="title-page-name"/>        public Producer(EventStorage storage){ <br class="title-page-name"/>          this.storage=storage; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method that calls the <kbd class="calibre15">set()</kbd> method of the <kbd class="calibre15">EventStorage</kbd> object 100 times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;100; i++){ <br class="title-page-name"/>            storage.set(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">Consumer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. It will implement the consumer of the example:</li>
</ol>
<pre class="calibre23">
        public class Consumer implements Runnable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare an <kbd class="calibre15">EventStorage</kbd> object and implement the constructor of the class that initializes this object:</li>
</ol>
<pre class="calibre23">
        private EventStorage storage; <br class="title-page-name"/><br class="title-page-name"/>        public Consumer(EventStorage storage){ <br class="title-page-name"/>          this.storage=storage; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It calls the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">EventStorage</kbd> object 100 times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;100; i++){ <br class="title-page-name"/>            storage.get(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create the main class of the example by implementing a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/><br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create an <kbd class="calibre15">EventStorage</kbd> object:</li>
</ol>
<pre class="calibre23">
        EventStorage storage=new EventStorage();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create a <kbd class="calibre15">Producer</kbd> object and <kbd class="calibre15">Thread</kbd> to run it:</li>
</ol>
<pre class="calibre23">
        Producer producer=new Producer(storage); <br class="title-page-name"/>        Thread thread1=new Thread(producer);
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a <kbd class="calibre15">Consumer</kbd> object and <kbd class="calibre15">Thread</kbd> to run it:</li>
</ol>
<pre class="calibre23">
        Consumer consumer=new Consumer(storage); <br class="title-page-name"/>        Thread thread2=new Thread(consumer);
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Start both the threads:</li>
</ol>
<pre class="calibre23">
        thread2.start(); <br class="title-page-name"/>        thread1.start();
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key to this example is the <kbd class="calibre15">set()</kbd> and <kbd class="calibre15">get()</kbd> methods of the <kbd class="calibre15">EventStorage</kbd> class. First of all, the <kbd class="calibre15">set()</kbd> method checks whether there is free space in the storage attribute. If it's full, it calls the <kbd class="calibre15">wait()</kbd> method to wait for free space. When the other thread calls the <kbd class="calibre15">notify()</kbd> method, this thread wakes up and checks the condition again. The <kbd class="calibre15">notify()</kbd> method doesn't guarantee that the condition is met. This process is repeated until there is free space in storage and it can generate a new event and store it.</p>
<p class="calibre4">The behavior of the <kbd class="calibre15">get()</kbd> method is similar. First, it checks whether there are events on the storage attribute. If the <kbd class="calibre15">EventStorage</kbd> class is empty, it calls the <kbd class="calibre15">wait()</kbd> method to wait for events. When the other thread calls the <kbd class="calibre15">notify()</kbd> method, this thread wakes up and checks the condition again until there are some events in storage.</p>
<div class="packt_infobox">You have to keep checking the conditions and calling the <kbd class="calibre25">wait()</kbd> method in a <kbd class="calibre25">while</kbd> loop. You will not be able to continue until the condition is <kbd class="calibre25">true</kbd>.</div>
<p class="calibre4">If you run this example, you will find that although the producer and consumer are setting and getting events, storage never has the capacity to include more than 10 events.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">There are other important uses of the <kbd class="calibre15">synchronized</kbd> keyword. See the <em class="calibre14">See also</em> section of this recipes that explain the use of this keyword.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a method</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Synchronizing a block of code with a lock</h1>
            

            <article>
                
<p class="calibre4">Java provides another mechanism for synchronizing blocks of code. It's a more powerful and flexible mechanism than the <kbd class="calibre15">synchronized</kbd> keyword. It's based on the <kbd class="calibre15">Lock</kbd> (of the <kbd class="calibre15">java.util.concurrent.locks</kbd> package) interface and classes that implement it (as <kbd class="calibre15">ReentrantLock</kbd>). This mechanism presents some advantages, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">It allows you to structure synchronized blocks in a more flexible way. With the <kbd class="calibre15">synchronized</kbd> keyword, you only have control over a synchronized block of code in a structured way. However, the <kbd class="calibre15">Lock</kbd> interface allows you to get more complex structures to implement your critical section.</li>
<li class="calibre18">The <kbd class="calibre15">Lock</kbd> interface provides additional functionalities over the <kbd class="calibre15">synchronized</kbd> keyword. One of the new functionalities is implemented by the <kbd class="calibre15">tryLock()</kbd> method. This method tries to get control of the lock, and if it can't, because it's used by another thread, it returns <kbd class="calibre15">false</kbd>. With the <kbd class="calibre15">synchronized</kbd> keyword, if thread (A) tries to execute a synchronized block of code when thread (B) is executing it, thread (A) is suspended until thread (B) finishes the execution of the synchronized block. With lock, you can execute the <kbd class="calibre15">tryLock()</kbd> method. This method returns a <kbd class="calibre15">Boolean</kbd> value indicating whether there is another thread running the code protected by this lock.</li>
<li class="calibre18">The <kbd class="calibre15">ReadWriteLock</kbd> interface allows a separation of read and write operations with multiple readers and only one modifier.</li>
<li class="calibre18">The <kbd class="calibre15">Lock</kbd> interface offers better performance than the <kbd class="calibre15">synchronized</kbd> keyword.</li>
</ul>
<p class="calibre4">The constructor of the <kbd class="calibre15">ReentrantLock</kbd> class admits a <kbd class="calibre15">boolean</kbd> parameter named <kbd class="calibre15">fair</kbd>; this parameter allows you to control its behavior. The <kbd class="calibre15">false</kbd> value is the default value and it's called the <strong class="calibre1">non-fair mode</strong>. In this mode, if some threads are waiting for a lock and the lock has to select one of these threads to get access to the critical section, it randomly selects anyone of them. The <kbd class="calibre15">true</kbd> value is called the <strong class="calibre1">fair mode</strong>. In this mode, if some threads are waiting for a lock and the lock has to select one to get access to a critical section, it selects the thread that has been waiting for the longest period of time. Take into account that the behavior explained previously is only used in the <kbd class="calibre15">lock()</kbd> and <kbd class="calibre15">unlock()</kbd> methods. As the <kbd class="calibre15">tryLock()</kbd> method doesn't put the thread to sleep if the <kbd class="calibre15">Lock</kbd> interface is used, the fair attribute doesn't affect its functionality.</p>
<p class="calibre4">In this recipe, you will learn how to use locks to synchronize a block of code and create a critical section using the <kbd class="calibre15">Lock</kbd> interface and the <kbd class="calibre15">ReentrantLock</kbd> class that implements it, implementing a program that simulates a print queue. You will also learn how the fair parameter affects the behavior of <kbd class="calibre15">Lock</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example in this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">PrintQueue</kbd> that will implement the print queue:</li>
</ol>
<pre class="calibre23">
         public class PrintQueue {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a <kbd class="calibre15">Lock</kbd> object and initialize it with a new object of the <kbd class="calibre15">ReentrantLock</kbd> class in the constructor. The constructor will receive a <kbd class="calibre15">Boolean</kbd> parameter we will use to specify the fair mode of the <kbd class="calibre15">Lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private Lock queueLock; <br class="title-page-name"/>        public PrintQueue(booleanfairMode) { <br class="title-page-name"/>          queueLock = new ReentrantLock(fairMode); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">printJob()</kbd> method. It will receive <kbd class="calibre15">Object</kbd> as a parameter and it will not return any value:</li>
</ol>
<pre class="calibre23">
        public void printJob(Object document){
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Inside the <kbd class="calibre15">printJob()</kbd> method, get control of the <kbd class="calibre15">Lock</kbd> object by calling the <kbd class="calibre15">lock()</kbd> method:</li>
</ol>
<pre class="calibre23">
        queueLock.lock();
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, include the following code to simulate the process of printing a document:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          Long duration=(long)(Math.random()*10000); <br class="title-page-name"/>          System.out.println(Thread.currentThread().getName()+ ":<br class="title-page-name"/>                             PrintQueue: Printing a Job during "+<br class="title-page-name"/>                             (duration/1000)+" seconds"); <br class="title-page-name"/>          Thread.sleep(duration); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Finally, free the control of the <kbd class="calibre15">Lock</kbd> object with the <kbd class="calibre15">unlock()</kbd> method:</li>
</ol>
<pre class="calibre23">
        finally { <br class="title-page-name"/>          queueLock.unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Then, repeat the same process again. The <kbd class="calibre15">printJob()</kbd> method will help you get access to the lock and then free it twice. This strange behavior will allow us to see the difference between fair and non-fair mode in a better way. We include this piece of code in the <kbd class="calibre15">printJob()</kbd> method:</li>
</ol>
<pre class="calibre23">
          queueLock.lock(); <br class="title-page-name"/>          try { <br class="title-page-name"/>            Long duration = (long) (Math.random() * 10000); <br class="title-page-name"/>            System.out.printf("%s: PrintQueue: Printing a Job during<br class="title-page-name"/>                               %d seconds\n", Thread.currentThread()<br class="title-page-name"/>                              .getName(),(duration / 1000)); <br class="title-page-name"/>            Thread.sleep(duration); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } finally { <br class="title-page-name"/>          queueLock.unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">Job</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Job implements Runnable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare an object of the <kbd class="calibre15">PrintQueue</kbd> class and implement the constructor of the class that initializes this object:</li>
</ol>
<pre class="calibre23">
        private PrintQueue printQueue; <br class="title-page-name"/><br class="title-page-name"/>        public Job(PrintQueue printQueue){ <br class="title-page-name"/>          this.printQueue=printQueue; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It uses the <kbd class="calibre15">PrintQueue</kbd> object to send a job to print:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("%s: Going to print a document\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          printQueue.printJob(new Object()); <br class="title-page-name"/>        System.out.printf("%s: The document has been printed\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create the main class of the application by implementing a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/><br class="title-page-name"/>          public static void main (String args[]){
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">We are going to test the <kbd class="calibre15">PrintQueue</kbd> class using a lock with the fair mode returning both <kbd class="calibre15">true</kbd> and <kbd class="calibre15">false</kbd>. We will use an auxiliary method to implement both the tests so the code of the <kbd class="calibre15">main()</kbd> method is simple:</li>
</ol>
<pre class="calibre23">
          System.out.printf("Running example with fair-mode =<br class="title-page-name"/>                             false\n"); <br class="title-page-name"/>          testPrintQueue(false); <br class="title-page-name"/>          System.out.printf("Running example with fair-mode = true\n"); <br class="title-page-name"/>          testPrintQueue(true); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create the <kbd class="calibre15">testPrintQueue()</kbd> method and create a shared <kbd class="calibre15">PrintQueue</kbd> object inside it:</li>
</ol>
<pre class="calibre23">
        private static void testPrintQueue(Boolean fairMode) { <br class="title-page-name"/>          PrintQueue printQueue=new PrintQueue(fairMode);
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create 10 <kbd class="calibre15">Job</kbd> objects and 10 threads to run them:</li>
</ol>
<pre class="calibre23">
        Thread thread[]=new Thread[10]; <br class="title-page-name"/>        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          thread[i]=new Thread(new Job(printQueue),"Thread "+ i); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Start the 10 threads:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          thread[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Lastly, wait for the finalization of the 10 threads:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            thread[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the following screenshot, you can see a part of the output of one execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border2" src="../images/00016.jpeg"/></div>
<p class="calibre4">The key to the example is in the <kbd class="calibre15">printJob()</kbd> method of the <kbd class="calibre15">PrintQueue</kbd> class. When we want to implement a critical section using locks and guarantee that only one execution thread will run a block of code, we have to create a <kbd class="calibre15">ReentrantLock</kbd> object. At the beginning of the critical section, we have to get control of the lock using the <kbd class="calibre15">lock()</kbd> method. When thread (A) calls this method, if no other thread has control of the lock, it gives thread (A) control of the lock and returns immediately to allow the thread to execute the critical section. Otherwise, if there is another, say thread (B), executing the critical section controlled by this lock, the <kbd class="calibre15">lock()</kbd> method puts thread (A) to sleep until thread (B) finishes the execution of the critical section.</p>
<p class="calibre4">At the end of the critical section, we have to use the <kbd class="calibre15">unlock()</kbd> method to free the control of the lock and allow other threads to run the critical section. If you don't call the <kbd class="calibre15">unlock()</kbd> method at the end of the critical section, other threads that are waiting for the block will wait forever, causing a deadlock situation. If you use try-catch blocks in your critical section, don't forget to put the sentence containing the <kbd class="calibre15">unlock()</kbd> method inside the <kbd class="calibre15">finally</kbd> section.</p>
<p class="calibre4">The other topic we tested in this example was fair mode. We had two critical sections in every job. In the previous screenshot, you saw how all the jobs execute the second part immediately after the first one. This is the usual case, but there are exceptions. This occurs when we have non-fair mode, that is to say, we pass a false value to the constructor of the <kbd class="calibre15">ReentrantLock</kbd> class.</p>
<p class="calibre4">On the contrary, when we establish fair mode by passing the true value to the constructor of the <kbd class="calibre15">Lock</kbd> class, the behavior is different. The first thread that requests control of the lock is <kbd class="calibre15">Thread 0</kbd>, then <kbd class="calibre15">Thread 1</kbd>, and so on. While <kbd class="calibre15">Thread 0</kbd> is running the first block of code protected by the lock, we have nine threads waiting to execute the same block of code. When <kbd class="calibre15">Thread 0</kbd> releases the lock, it immediately requests the lock again, so we have 10 threads trying to get the lock. As the fair mode is enabled, the <kbd class="calibre15">Lock</kbd> interface will choose <kbd class="calibre15">Thread 1</kbd>, as it's the thread that has been waiting for more time for the lock. Then, it chooses <kbd class="calibre15">Thread 2</kbd>, then <kbd class="calibre15">Thread 3</kbd>, and so on. Until all the threads have passed the first block protected by the lock, none of them will execute the second block protected by the lock. Once all the threads have executed the first block of code protected by the lock, then it will be the turn of <kbd class="calibre15">Thread 0</kbd> again, then <kbd class="calibre15">Thread 1</kbd>, and so on. The following screenshot shows the difference:</p>
<div class="cdpaligncenter"><img class="image-border3" src="../images/00017.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Lock</kbd> interface (and the <kbd class="calibre15">ReentrantLock</kbd> class) includes another method to get control of the lock. It's the <kbd class="calibre15">tryLock()</kbd> method. The biggest difference with the <kbd class="calibre15">lock()</kbd> method is that this method, if the thread that uses it can't get control of the Lock interface, returns immediately and doesn't put the thread to sleep. It returns the <kbd class="calibre15">boolean</kbd> value <kbd class="calibre15">true</kbd> if the thread gets control of the lock and <kbd class="calibre15">false</kbd> if not. You can also pass a time value and a <kbd class="calibre15">TimeUnit</kbd> object to indicate the maximum amount of time the thread will wait to get the lock. If the time elapses and the thread doesn't get the lock, the method will return the false value. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>; these indicate the units of time we pass to a method.</p>
<div class="packt_infobox">Take into consideration that it is the responsibility of the programmer to take into account the result of this method and act accordingly. If the method returns <kbd class="calibre25">false</kbd>, it's apparent that your program is unable to execute the critical section. If it does, you probably will have wrong results in your application.</div>
<p class="calibre4">The <kbd class="calibre15">ReentrantLock</kbd> class also allows the use of recursive calls. When a thread has control of a lock and makes a recursive call, it continues with the control of the lock, so the calling to the <kbd class="calibre15">lock()</kbd> method will return immediately and the thread will continue with the execution of the recursive call. Moreover, we can also call other methods. You should call the <kbd class="calibre15">unlock()</kbd> method as many times as you called the <kbd class="calibre15">lock()</kbd> method in your code.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Avoiding deadlocks</h1>
            

            <article>
                
<p class="calibre4">You have to be very careful with the use of locks to avoid <strong class="calibre1">deadlocks</strong>. This situation occurs when two or more threads are blocked while waiting for locks that will never be unlocked. For example, thread (A) locks Lock (X) and thread (B) locks Lock (Y). Now, if thread (A) tries to lock Lock (Y) and thread (B) simultaneously tries to lock Lock (X), both the threads will be blocked indefinitely because they are waiting for locks that will never be liberated. Note that the problem occurs because both threads try to get the locks in the opposite order. The <span>Appendix</span>, <em class="calibre14">Concurrent Programming Design</em>, provides some good tips to design concurrent applications adequately and avoid these deadlock problems.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a method</em> and <em class="calibre14">Using multiple conditions in a lock</em> recipes in this chapter</li>
<li class="calibre18">The <em class="calibre14">Monitoring a Lock interface</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Synchronizing data access with read/write locks</h1>
            

            <article>
                
<p class="calibre4">One of the most significant improvements offered by locks is the <kbd class="calibre15">ReadWriteLock</kbd> interface and the <kbd class="calibre15">ReentrantReadWriteLock</kbd> class, the unique <span>class</span> that implements that interface. This class has two locks: one for read operations and one for write operations. There can be more than one thread using read operations simultaneously, but only one thread can use write operations. If a thread is doing a write operation, other threads can't write or read.</p>
<p class="calibre4">In this recipe, you will learn how to use a <kbd class="calibre15">ReadWriteLock</kbd> interface by implementing a program that uses it to control access to an object that stores the prices of two products.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready...</h1>
            

            <article>
                
<p class="calibre4">You should read the <em class="calibre14">Synchronizing a block of code with a lock</em> recipe to better understand this recipe.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">PricesInfo</kbd> that stores information about the prices of two products:</li>
</ol>
<pre class="calibre23">
        public class PricesInfo {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two <kbd class="calibre15">double</kbd> attributes named <kbd class="calibre15">price1</kbd> and <kbd class="calibre15">price2</kbd>:</li>
</ol>
<pre class="calibre23">
        private double price1; <br class="title-page-name"/>        private double price2;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a <kbd class="calibre15">ReadWriteLock</kbd> object called <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private ReadWriteLock lock;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class that initializes the three attributes. For the <kbd class="calibre15">lock</kbd> attribute, create a new <kbd class="calibre15">ReentrantReadWriteLock</kbd> object:</li>
</ol>
<pre class="calibre23">
        public PricesInfo(){ <br class="title-page-name"/>          price1=1.0; <br class="title-page-name"/>          price2=2.0; <br class="title-page-name"/>          lock=new ReentrantReadWriteLock(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">getPrice1()</kbd> method that returns the value of the <kbd class="calibre15">price1</kbd> attribute. It uses the read lock to control access to the value of this attribute:</li>
</ol>
<pre class="calibre23">
        public double getPrice1() { <br class="title-page-name"/>          lock.readLock().lock(); <br class="title-page-name"/>          double value=price1; <br class="title-page-name"/>          lock.readLock().unlock(); <br class="title-page-name"/>          return value; <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">getPrice2()</kbd> method that returns the value of the <kbd class="calibre15">price2</kbd> attribute. It uses the read lock to control access to the value of this attribute:</li>
</ol>
<pre class="calibre23">
        public double getPrice2() { <br class="title-page-name"/>          lock.readLock().lock(); <br class="title-page-name"/>          double value=price2; <br class="title-page-name"/>          lock.readLock().unlock(); <br class="title-page-name"/>          return value; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">setPrices()</kbd> method that establishes the values of two attributes. It uses the write lock to control access to them. We are going to make the thread sleep for 5 seconds. This shows that even though it has the write lock, there are no other threads getting the read lock:</li>
</ol>
<pre class="calibre23">
        public void setPrices(double price1, double price2) { <br class="title-page-name"/>          lock.writeLock().lock(); <br class="title-page-name"/>          System.out.printf("%s: PricesInfo: Write Lock Adquired.\n",<br class="title-page-name"/>                            new Date()); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(10); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          this.price1=price1; <br class="title-page-name"/>          this.price2=price2; <br class="title-page-name"/>          System.out.printf("%s: PricesInfo: Write Lock Released.\n",<br class="title-page-name"/>                            new Date()); <br class="title-page-name"/>          lock.writeLock().unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">Reader</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class implements a reader of the values of the <kbd class="calibre15">PricesInfo</kbd> class attribute:</li>
</ol>
<pre class="calibre23">
        public class Reader implements Runnable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare a <kbd class="calibre15">PricesInfo</kbd> object and implement the constructor of the class that could initialize this object:</li>
</ol>
<pre class="calibre23">
        private PricesInfo pricesInfo; <br class="title-page-name"/><br class="title-page-name"/>        public Reader (PricesInfo pricesInfo){ <br class="title-page-name"/>          this.pricesInfo=pricesInfo; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method for this class. It reads the value of the two prices 10 times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;20; i++){ <br class="title-page-name"/>            System.out.printf("%s: %s: Price 1: %f\n",new Date(),<br class="title-page-name"/>                              Thread.currentThread().getName(),<br class="title-page-name"/>                              pricesInfo.getPrice1()); <br class="title-page-name"/>            System.out.printf("%s: %s: Price 2: %f\n",new Date(),<br class="title-page-name"/>                              Thread.currentThread().getName(),<br class="title-page-name"/>                              pricesInfo.getPrice2()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a class named <kbd class="calibre15">Writer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class implements a modifier of the values of the <kbd class="calibre15">PricesInfo</kbd> class attribute:</li>
</ol>
<pre class="calibre23">
        public class Writer implements Runnable {
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Declare a <kbd class="calibre15">PricesInfo</kbd> object and implement the constructor of the class that could initialize this object:</li>
</ol>
<pre class="calibre23">
        private PricesInfo pricesInfo; <br class="title-page-name"/><br class="title-page-name"/>        public Writer(PricesInfo pricesInfo){ <br class="title-page-name"/>          this.pricesInfo=pricesInfo; <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It modifies the value of the two prices that are sleeping for 2 seconds between modifications three times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;3; i++) { <br class="title-page-name"/>            System.out.printf("%s: Writer: Attempt to modify the<br class="title-page-name"/>                              prices.\n", new Date()); <br class="title-page-name"/>            pricesInfo.setPrices(Math.random()*10, Math.random()*8); <br class="title-page-name"/>            System.out.printf("%s: Writer: Prices have been<br class="title-page-name"/>                              modified.\n", new Date()); <br class="title-page-name"/>            try { <br class="title-page-name"/>              Thread.sleep(2); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create a <kbd class="calibre15">PricesInfo</kbd> object:</li>
</ol>
<pre class="calibre23">
        PricesInfo pricesInfo=new PricesInfo();
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create five <kbd class="calibre15">Reader</kbd> objects and five <kbd class="calibre15">Thread</kbd> objects to execute them:</li>
</ol>
<pre class="calibre23">
        Reader readers[]=new Reader[5]; <br class="title-page-name"/>        Thread threadsReader[]=new Thread[5]; <br class="title-page-name"/><br class="title-page-name"/>        for (int i=0; i&lt;5; i++){ <br class="title-page-name"/>          readers[i]=new Reader(pricesInfo); <br class="title-page-name"/>          threadsReader[i]=new Thread(readers[i]); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a <kbd class="calibre15">Writer</kbd> object and <kbd class="calibre15">Thread</kbd> to execute it:</li>
</ol>
<pre class="calibre23">
        Writer writer=new Writer(pricesInfo); <br class="title-page-name"/>        Thread  threadWriter=new Thread(writer);
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Start the threads:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5; i++){ <br class="title-page-name"/>          threadsReader[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/>        threadWriter.start();
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the following screenshot, you can see a part of the output of one execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border4" src="../images/00018.jpeg"/></div>
<p class="calibre4">While the writer has acquired the write lock, none of the reader tasks can read the data. You can see some messages of the reader tasks after the <kbd class="calibre15">Write Lock Acquired</kbd> message, but they are instructions that were executed before and not shown yet in the console. Once the writer task has released the lock, reader tasks gain access to the prices information again and show the new prices.</p>
<p class="calibre4">As mentioned previously, the <kbd class="calibre15">ReentrantReadWriteLock</kbd> class has two locks: one for read operations and one for write operations. The lock used in read operations is obtained with the <kbd class="calibre15">readLock()</kbd> method declared in the <kbd class="calibre15">ReadWriteLock</kbd> interface. This lock is an object that implements the <kbd class="calibre15">Lock</kbd> interface, so we can use the <kbd class="calibre15">lock()</kbd>, <kbd class="calibre15">unlock()</kbd>, and <kbd class="calibre15">tryLock()</kbd> methods. The lock used in write operations is obtained with the <kbd class="calibre15">writeLock()</kbd> method declared in the <kbd class="calibre15">ReadWriteLock</kbd> interface. This lock is also an object that implements the <kbd class="calibre15">Lock</kbd> interface, so we can use the <kbd class="calibre15">lock()</kbd>, <kbd class="calibre15">unlock()</kbd>, and <kbd class="calibre15">tryLock()</kbd> methods. It is the responsibility of the programmer to ensure correct use of these locks, using them for the same purposes for which they were designed. When you get the read lock of a <kbd class="calibre15">Lock</kbd> interface, you can't modify the value of the variable. Otherwise, you probably will have data errors related to inconsistency.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a block of code with a lock</em> recipe in this chapter</li>
<li class="calibre18">The <em class="calibre14">Monitoring a Lock interface</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using multiple conditions in a lock</h1>
            

            <article>
                
<p class="calibre4">A lock may be associated with one or more conditions. These conditions are declared in the <kbd class="calibre15">Condition</kbd> interface. The purpose of these conditions is to allow threads to have control of a lock and check whether a condition is <kbd class="calibre15">true</kbd> or not. If it's <kbd class="calibre15">false</kbd>, the thread will be suspended until another thread wakes it up. The <kbd class="calibre15">Condition</kbd> interface provides the mechanisms to suspend a thread and wake up a suspended thread.</p>
<p class="calibre4">A classic problem in concurrent programming is the producer-consumer problem. We have a data buffer, one or more producers of data that save it in the buffer, and one or more consumers of data that take it from the buffer, as explained earlier in this chapter.</p>
<p class="calibre4">In this recipe, you will learn how to implement the producer-consumer problem using locks and conditions.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">You should read the <em class="calibre14">Synchronizing a block of code with a lock</em> recipe to better understand this recipe.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, implement a class that will simulate a text file. Create a class named <kbd class="calibre15">FileMock</kbd> with two attributes: a <kbd class="calibre15">String</kbd> array named content and <kbd class="calibre15">int</kbd> named <kbd class="calibre15">index</kbd>. They will store the content of the file and the line of the simulated file that will be retrieved:</li>
</ol>
<pre class="calibre23">
        public class FileMock { <br class="title-page-name"/><br class="title-page-name"/>          private String[] content; <br class="title-page-name"/>          private int index;
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the constructor of the class that initializes the content of the file with random characters:</li>
</ol>
<pre class="calibre23">
        public FileMock(int size, int length){ <br class="title-page-name"/>          content = new String[size]; <br class="title-page-name"/>          for (int i = 0; i&lt; size; i++){ <br class="title-page-name"/>            StringBuilder buffer = new StringBuilder(length); <br class="title-page-name"/>            for (int j = 0; j &lt; length; j++){ <br class="title-page-name"/>              int randomCharacter= (int)Math.random()*255; <br class="title-page-name"/>              buffer.append((char)randomCharacter); <br class="title-page-name"/>            } <br class="title-page-name"/>            content[i] = buffer.toString(); <br class="title-page-name"/>          } <br class="title-page-name"/>          index=0; <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">hasMoreLines()</kbd> method that returns <kbd class="calibre15">true</kbd> if the file has more lines to process or <kbd class="calibre15">false</kbd> if you have reached the end of the simulated file:</li>
</ol>
<pre class="calibre23">
        public boolean hasMoreLines(){ <br class="title-page-name"/>          return index &lt;content.length; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">getLine()</kbd> method that returns the line determined by the index attribute and increases its value:</li>
</ol>
<pre class="calibre23">
        public String getLine(){ <br class="title-page-name"/>          if (this.hasMoreLines()) { <br class="title-page-name"/>            System.out.println("Mock: " + (content.length-index)); <br class="title-page-name"/>            return content[index++]; <br class="title-page-name"/>          } <br class="title-page-name"/>          return null; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Now implement a class named <kbd class="calibre15">Buffer</kbd> that will implement the buffer shared by both the producers and consumers:</li>
</ol>
<pre class="calibre23">
        public class Buffer {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">This class has six attributes:</li>
</ol>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18">A <kbd class="calibre15">LinkedList&lt;String&gt;</kbd> attribute named <kbd class="calibre15">buffer</kbd> that will store the shared data. For example:</li>
</ul>
</div>
<pre class="calibre23">
                  private final LinkedList&lt;String&gt; buffer;
</pre>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18">An <kbd class="calibre15">int</kbd> type named <kbd class="calibre15">maxSize</kbd> that will store the length of the buffer<span>. For example:</span></li>
</ul>
</div>
<pre class="calibre23">
                    private final int maxSize;
</pre>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18">A <kbd class="calibre15">ReentrantLock</kbd> object called <kbd class="calibre15">lock</kbd> that will control access to the blocks of code that modify the buffer<span>. For example:</span></li>
</ul>
</div>
<pre class="calibre23">
                    private final ReentrantLock lock;
</pre>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18">Two <kbd class="calibre15">Condition</kbd> attributes named <kbd class="calibre15">lines</kbd> and <kbd class="calibre15">space</kbd>. For example:</li>
</ul>
</div>
<pre class="calibre23">
                  private final Condition lines;<br class="title-page-name"/><br class="title-page-name"/>                  private final Condition space;
</pre>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18">A <kbd class="calibre15">boolean</kbd> type called <kbd class="calibre15">pendingLines</kbd> that will indicate whether there are lines in the buffer<span>. For example:</span></li>
</ul>
</div>
<pre class="calibre23">
                  private boolean pendingLines;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the constructor of the class. It initializes all the attributes described previously:</li>
</ol>
<pre class="calibre23">
        public Buffer(int maxSize) { <br class="title-page-name"/>          this.maxSize = maxSize; <br class="title-page-name"/>          buffer = new LinkedList&lt;&gt;(); <br class="title-page-name"/>          lock = new ReentrantLock(); <br class="title-page-name"/>          lines = lock.newCondition(); <br class="title-page-name"/>          space = lock.newCondition(); <br class="title-page-name"/>          pendingLines =true; <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">insert()</kbd> method. It receives <kbd class="calibre15">String</kbd> as a parameter and tries to store it in the buffer. First, it gets control of the lock. When it has this, it checks whether there is empty space in the buffer. If the buffer is full, it calls the <kbd class="calibre15">await()</kbd> method in the <kbd class="calibre15">space</kbd> condition to wait for free space. The thread will be woken up when another thread calls the <kbd class="calibre15">signal()</kbd> or <kbd class="calibre15">signalAll()</kbd> method in the <kbd class="calibre15">space</kbd> condition. When this happens, the thread stores the line in the buffer and calls the <kbd class="calibre15">signallAll()</kbd> method over the <kbd class="calibre15">lines</kbd> condition. As we'll see in a moment, this condition will wake up all the threads that are waiting for lines in the buffer. To make the code easier, we ignore the <kbd class="calibre15">InterruptedException</kbd> exception. In real cases, you will probably have to process it:</li>
</ol>
<pre class="calibre23">
        public void insert(String line) { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          try { <br class="title-page-name"/>            while (buffer.size() == maxSize) { <br class="title-page-name"/>              space.await(); <br class="title-page-name"/>            } <br class="title-page-name"/>            buffer.offer(line); <br class="title-page-name"/>            System.out.printf("%s: Inserted Line: %d\n",<br class="title-page-name"/>                              Thread.currentThread().getName(),<br class="title-page-name"/>                              buffer.size()); <br class="title-page-name"/>            lines.signalAll(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } finally { <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">get()</kbd> method. It returns the first string stored in the buffer. First, it gets control of the lock. When this is done, it checks whether there are lines in the buffer. If the buffer is empty, it calls the <kbd class="calibre15">await()</kbd> method in the <kbd class="calibre15">lines</kbd> condition to wait for lines in the buffer. This thread will be woken up when another thread calls the <kbd class="calibre15">signal()</kbd> or <kbd class="calibre15">signalAll()</kbd> method in the lines condition. When this happens, the method gets the first line in the buffer, calls the <kbd class="calibre15">signalAll()</kbd> method over the <kbd class="calibre15">space</kbd> condition, and returns <kbd class="calibre15">String</kbd>:</li>
</ol>
<pre class="calibre23">
        public String get() { <br class="title-page-name"/>          String line = null; <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          try { <br class="title-page-name"/>            while ((buffer.size() == 0) &amp;&amp;(hasPendingLines())) { <br class="title-page-name"/>              lines.await(); <br class="title-page-name"/>            } <br class="title-page-name"/><br class="title-page-name"/>            if (hasPendingLines()) { <br class="title-page-name"/>              line = buffer.poll(); <br class="title-page-name"/>              System.out.printf("%s: Line Readed: %d\n",<br class="title-page-name"/>                                Thread.currentThread().getName(),<br class="title-page-name"/>                                buffer.size()); <br class="title-page-name"/>              space.signalAll(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } finally { <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/>          return line; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">setPendingLines()</kbd> method that establishes the value of the <kbd class="calibre15">pendingLines</kbd> attribute. It will be called by the producer when it has no more lines to produce:</li>
</ol>
<pre class="calibre23">
        public synchronized void setPendingLines(boolean pendingLines) { <br class="title-page-name"/>          this.pendingLines = pendingLines; <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">hasPendingLines()</kbd> method. It returns <kbd class="calibre15">true</kbd> if there are more lines to be processed or <kbd class="calibre15">false</kbd> otherwise:</li>
</ol>
<pre class="calibre23">
        public synchronized boolean hasPendingLines() { <br class="title-page-name"/>          return pendingLines || buffer.size()&gt;0; <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Now it's the turn of the producer. Implement a class named <kbd class="calibre15">Producer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Producer implements Runnable {
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Declare two attributes, namely an object of the <kbd class="calibre15">FileMock</kbd> class and an object of the <kbd class="calibre15">Buffer</kbd> class:</li>
</ol>
<pre class="calibre23">
        private FileMock mock; <br class="title-page-name"/><br class="title-page-name"/>        private Buffer buffer;
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the constructor of the class that initializes both the attributes:</li>
</ol>
<pre class="calibre23">
        public Producer (FileMock mock, Buffer buffer){ <br class="title-page-name"/>          this.mock = mock; <br class="title-page-name"/>          this.buffer = buffer; <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method that reads all the lines created in the <kbd class="calibre15">FileMock</kbd> object and use the <kbd class="calibre15">insert()</kbd> method to store them in the buffer. Once this is done, use the <kbd class="calibre15">setPendingLines()</kbd> method to alert the buffer that it will not generate more lines:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          buffer.setPendingLines(true); <br class="title-page-name"/>          while (mock.hasMoreLines()){ <br class="title-page-name"/>            String line = mock.getLine(); <br class="title-page-name"/>            buffer.insert(line); <br class="title-page-name"/>          } <br class="title-page-name"/>          buffer.setPendingLines(false); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Next is the consumer's turn. Implement a class named <kbd class="calibre15">Consumer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Consumer implements Runnable {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Declare a <kbd class="calibre15">Buffer</kbd> object and implement the constructor of the class that initializes it:</li>
</ol>
<pre class="calibre23">
        private Buffer buffer; <br class="title-page-name"/><br class="title-page-name"/>        public Consumer (Buffer buffer) { <br class="title-page-name"/>          this.buffer = buffer; <br class="title-page-name"/>        }
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. While the buffer has pending lines, it tries to get one line and process it:</li>
</ol>
<pre class="calibre23">
        @Override   <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          while (buffer.hasPendingLines()) { <br class="title-page-name"/>            String line = buffer.get(); <br class="title-page-name"/>            processLine(line); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Implement the auxiliary method <kbd class="calibre15">processLine()</kbd>. It only sleeps for 10 milliseconds to simulate some kind of processing with the line:</li>
</ol>
<pre class="calibre23">
        private void processLine(String line) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            Random random = new Random(); <br class="title-page-name"/>            Thread.sleep(random.nextInt(100)); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it.</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/><br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Create a <kbd class="calibre15">FileMock</kbd> object:</li>
</ol>
<pre class="calibre23">
        FileMock mock = new FileMock(100, 10);
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Create a <kbd class="calibre15">Buffer</kbd> object:</li>
</ol>
<pre class="calibre23">
        Buffer buffer = new Buffer(20);
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Create a <kbd class="calibre15">Producer</kbd> object and <kbd class="calibre15">Thread</kbd> to run it:</li>
</ol>
<pre class="calibre23">
        Producer producer = new Producer(mock, buffer); <br class="title-page-name"/>        Thread producerThread = new Thread(producer,"Producer");
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Create three <kbd class="calibre15">Consumer</kbd> objects and three threads to run them:</li>
</ol>
<pre class="calibre23">
        Consumer consumers[] = new Consumer[3]; <br class="title-page-name"/>        Thread consumersThreads[] = new Thread[3]; <br class="title-page-name"/><br class="title-page-name"/>        for (int i=0; i&lt;3; i++){ <br class="title-page-name"/>          consumers[i] = new Consumer(buffer); <br class="title-page-name"/>          consumersThreads[i] = new Thread(consumers[i],"Consumer "+i); <br class="title-page-name"/>        }
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Start the producer and the three consumers:</li>
</ol>
<pre class="calibre23">
        producerThread.start(); <br class="title-page-name"/>        for (int i = 0; i&lt; 3; i++){ <br class="title-page-name"/>          consumersThreads[i].start(); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">All the <kbd class="calibre15">Condition</kbd> objects are associated with a lock and are created using the <kbd class="calibre15">newCondition()</kbd> method declared in the <kbd class="calibre15">Lock</kbd> interface. Before we can do any operation with a condition, you have to have control of the lock associated with the condition. So operations with conditions must be done in a thread that holds the lock with a call to a <kbd class="calibre15">lock()</kbd> method of a <kbd class="calibre15">Lock</kbd> object and then frees it with an <kbd class="calibre15">unlock()</kbd> method of the same <kbd class="calibre15">Lock</kbd> object.</p>
<p class="calibre4">When a thread calls the <kbd class="calibre15">await()</kbd> method of a condition, it automatically frees the control of the lock so that another thread can get it and either begin the execution or another critical section protected by that lock.</p>
<div class="packt_infobox">When a thread calls the <kbd class="calibre25">signal()</kbd> or <kbd class="calibre25">signallAll()</kbd> methods of a condition, one or all of the threads that were waiting for that condition are woken up, but this doesn't guarantee that the condition that made them sleep is now <kbd class="calibre25">true</kbd>. So you must put the <kbd class="calibre25">await()</kbd> calls inside a while loop. You can't leave this loop until the condition is <kbd class="calibre25">true</kbd>. When the condition is <kbd class="calibre25">false</kbd>, you must call <kbd class="calibre25">await()</kbd> again.</div>
<p class="calibre4">You must be careful with the use of <kbd class="calibre15">await()</kbd> and <kbd class="calibre15">signal()</kbd>. If you call the <kbd class="calibre15">await()</kbd> method in a condition and never call the <kbd class="calibre15">signal()</kbd> method in the same condition, the thread will sleep forever.</p>
<p class="calibre4">A thread can be interrupted while it is sleeping, after a call to the <kbd class="calibre15">await()</kbd> method, so you have to process the <kbd class="calibre15">InterruptedException</kbd> exception.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Condition</kbd> interface has other versions of the <kbd class="calibre15">await()</kbd> method, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">await(long time, TimeUnit unit)</kbd>: Here, the thread will sleep until:
<ul class="calibre24">
<li class="calibre18">It's interrupted</li>
<li class="calibre18">Another thread calls the <kbd class="calibre15">signal()</kbd> or <kbd class="calibre15">signalAll()</kbd> methods in the condition</li>
<li class="calibre18">The specified time passes</li>
<li class="calibre18">The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd></li>
</ul>
</li>
</ul>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">awaitUninterruptibly()</kbd>: The thread will sleep until another thread calls the <kbd class="calibre15">signal()</kbd> or <kbd class="calibre15">signalAll()</kbd> methods, which can't be interrupted</li>
<li class="calibre18"><kbd class="calibre15">awaitUntil(Date date)</kbd>: The thread will sleep until:
<ul class="calibre24">
<li class="calibre18">It's interrupted</li>
<li class="calibre18">Another thread calls the <kbd class="calibre15">signal()</kbd> or <kbd class="calibre15">signalAll()</kbd> methods in the condition</li>
<li class="calibre18">The specified date arrives</li>
</ul>
</li>
</ul>
<p class="calibre4">You can use conditions with the <kbd class="calibre15">ReadLock</kbd> and <kbd class="calibre15">WriteLock</kbd> locks of a read/write lock.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a block of code with a lock</em> and <em class="calibre14">Synchronizing data access with read/write locks</em> recipes in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Advanced locking with the StampedLock class</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">StampedLock</kbd> class provides a special kind of lock that is different from the ones provided by the Lock or <kbd class="calibre15">ReadWriteLock</kbd> interfaces. In fact, this class doesn't implement these interfaces, but the functionality it provides is very similar.</p>
<p class="calibre4">The first point to note about this kind of lock is that its main purpose is to be a helper class to implement thread-safe components, so its use will not be very common in normal applications.</p>
<p class="calibre4">The most important features of <kbd class="calibre15">StampedLock</kbd> locks are as follows:</p>
<ul class="calibre17">
<li class="calibre18">You can obtain control of the lock in three different modes:
<ul class="calibre24">
<li class="calibre18"><strong class="calibre1">Write</strong>: In this mode, you get exclusive access to the lock. No other thread can have control of the lock in this mode.</li>
<li class="calibre18"><strong class="calibre1">Read</strong>: In this mode, you have non-exclusive access to the lock. There can be other threads that have access to the lock in this mode or the Optimistic Read mode.</li>
<li class="calibre18"><strong class="calibre1">Optimistic Read</strong>: Here, the thread doesn't have control over the block. Other threads can get control of the lock in write mode. When you get a lock in the Optimistic Read mode and you want to access the shared data protected by it, you will have to check whether you can access them or not using the <kbd class="calibre15">validate()</kbd> method.</li>
</ul>
</li>
<li class="calibre18">The <kbd class="calibre15">StampedLock</kbd> class provides methods to:
<ul class="calibre24">
<li class="calibre18">Acquire control over the lock in one of the previous modes. If the methods (<kbd class="calibre15">readLock()</kbd>, <kbd class="calibre15">writeLock()</kbd>, <kbd class="calibre15">readLockInterruptibly()</kbd>) are unable to get control of the lock, the current thread is suspended until it gets the lock.</li>
<li class="calibre18">Acquire control over the lock in one of the previous modes. If the methods (<kbd class="calibre15">tryOptimisticRead()</kbd>, <kbd class="calibre15">tryReadLock()</kbd>, <kbd class="calibre15">tryWriteLock()</kbd>) are unable to get control of the lock, they return a special value to indicate this circumstance.</li>
<li class="calibre18">Convert one mode into another, if possible. If not, the methods (<kbd class="calibre15">asReadLock()</kbd>, <kbd class="calibre15">asWriteLock()</kbd>, <kbd class="calibre15">asReadWriteLock()</kbd>) return a special value.</li>
<li class="calibre18">Release the lock.</li>
</ul>
</li>
<li class="calibre18">All these methods return a long value called stamp that we need to use to work with the lock. If a method returns zero, it means it tried to get a lock but it couldn't.</li>
<li class="calibre18">A <kbd class="calibre15">StampedLock</kbd> lock is not a reentrant lock, such as the <kbd class="calibre15">Lock</kbd> and <kbd class="calibre15">ReadWriteLock</kbd> interfaces. If you call a method that tries to get the lock again, it may be blocked and you'll get a deadlock.</li>
<li class="calibre18">It does not have the notion of ownership. They can be acquired by one thread and released by another.</li>
<li class="calibre18">Finally, it doesn't have any policy about the next thread that will get control of the lock.</li>
</ul>
<p class="calibre4">In this recipe, we will learn how to use the different modes of the <kbd class="calibre15">StampedLock</kbd> class to protect access to a shared data object. We will use a shared object between three concurrent tasks to test the three access modes with <kbd class="calibre15">StampedLock</kbd> (write, read, and Optimistic Read).</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, implement the shared data object. Create a class named <kbd class="calibre15">Position</kbd> with two integer attributes, namely <kbd class="calibre15">x</kbd> and <kbd class="calibre15">y</kbd>. You have to include the methods to get and set the values of the attributes. Its code is very simple so it is not included here.</li>
<li value="2" class="calibre18">Now let's implement the <kbd class="calibre15">Writer</kbd> task. It implements the <kbd class="calibre15">Runnable</kbd> interface and it will have two attributes: a <kbd class="calibre15">Position</kbd> object named <kbd class="calibre15">position</kbd> and <kbd class="calibre15">StampedLock</kbd> named <kbd class="calibre15">lock</kbd>. They will be initialized in the constructor:</li>
</ol>
<pre class="calibre23">
         public class Writer implements Runnable { <br class="title-page-name"/><br class="title-page-name"/>          private final Position position; <br class="title-page-name"/>          private final StampedLock lock; <br class="title-page-name"/><br class="title-page-name"/>          public Writer (Position position, StampedLock lock) { <br class="title-page-name"/>            this.position=position; <br class="title-page-name"/>            this.lock=lock; <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. In a loop that we will repeat 10 times, get the lock in write mode, change the value of the two attributes of the position object, suspend the execution of the thread for a second, release the lock (in the <kbd class="calibre15">finally</kbd> section of a <kbd class="calibre15">try...catch...finally</kbd> structure to release the lock in any circumstance), and suspend the thread for a second:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/><br class="title-page-name"/>          for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>            long stamp = lock.writeLock(); <br class="title-page-name"/><br class="title-page-name"/>            try { <br class="title-page-name"/>              System.out.printf("Writer: Lock acquired %d\n",stamp); <br class="title-page-name"/>              position.setX(position.getX()+1); <br class="title-page-name"/>              position.setY(position.getY()+1); <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock.unlockWrite(stamp); <br class="title-page-name"/>              System.out.printf("Writer: Lock released %d\n",stamp); <br class="title-page-name"/>            } <br class="title-page-name"/><br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/><br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Then, implement the <kbd class="calibre15">Reader</kbd> task to read the values of the shared object. Create a class named <kbd class="calibre15">Reader</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface. It will have two attributes: a <kbd class="calibre15">Position</kbd> object named <kbd class="calibre15">position</kbd> and a <kbd class="calibre15">StampedLock</kbd> object named <kbd class="calibre15">lock</kbd>. They will be initialized in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        public class Reader implements Runnable { <br class="title-page-name"/><br class="title-page-name"/>          private final Position position; <br class="title-page-name"/>          private final StampedLock lock; <br class="title-page-name"/><br class="title-page-name"/>          public Reader (Position position, StampedLock lock) { <br class="title-page-name"/>            this.position=position; <br class="title-page-name"/>            this.lock=lock; <br class="title-page-name"/>          }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Now implement the <kbd class="calibre15">run()</kbd> method. In a loop that we will repeat <kbd class="calibre15">50</kbd> times, get control of the lock in read mode, write the values of the position object in the console, and suspend the thread for <kbd class="calibre15">200</kbd> milliseconds. Finally, release the lock using the <kbd class="calibre15">finally</kbd> block of a <kbd class="calibre15">try...catch...finally</kbd> structure:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;50; i++) { <br class="title-page-name"/>            long stamp=lock.readLock(); <br class="title-page-name"/>            try { <br class="title-page-name"/>              System.out.printf("Reader: %d - (%d,%d)\n", stamp,<br class="title-page-name"/>                                position.getX(), position.getY()); <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(200); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock.unlockRead(stamp); <br class="title-page-name"/>              System.out.printf("Reader: %d - Lock released\n", stamp); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, implement the <kbd class="calibre15">OptimisticReader</kbd> task. The class <kbd class="calibre15">OptimisticReader</kbd> class implements the <kbd class="calibre15">Runnable</kbd> interface. It will have two attributes: a <kbd class="calibre15">Position</kbd> object named <kbd class="calibre15">position</kbd> and a <kbd class="calibre15">StampledLock</kbd> object named <kbd class="calibre15">lock</kbd>. They will be initialized in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        public class OptimisticReader implements Runnable { <br class="title-page-name"/><br class="title-page-name"/>          private final Position position; <br class="title-page-name"/>          private final StampedLock lock; <br class="title-page-name"/><br class="title-page-name"/>          public OptimisticReader (Position position, StampedLock lock) { <br class="title-page-name"/>            this.position=position; <br class="title-page-name"/>            this.lock=lock; <br class="title-page-name"/>          }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Now implement the <kbd class="calibre15">run()</kbd> method. First obtain the stamp of the lock in the optimistic read mode using the <kbd class="calibre15">tryOptimisticRead()</kbd> method. Then, repeat the loop <kbd class="calibre15">100</kbd> times. In the loop, validate whether you can access data using the <kbd class="calibre15">validate()</kbd> method. If this method returns true, write the values of the position object in the console. Otherwise, write a message in the console and get another stamp using the <kbd class="calibre15">tryOptimisticRead()</kbd> method again. Then, suspend the thread for <kbd class="calibre15">200</kbd> milliseconds:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          long stamp; <br class="title-page-name"/>          for (int i=0; i&lt;100; i++) { <br class="title-page-name"/>            try { <br class="title-page-name"/>              stamp=lock.tryOptimisticRead(); <br class="title-page-name"/>              int x = position.getX(); <br class="title-page-name"/>              int y = position.getY(); <br class="title-page-name"/>              if (lock.validate(stamp)) { <br class="title-page-name"/>                System.out.printf("OptmisticReader: %d - (%d,%d)\n",<br class="title-page-name"/>                                  stamp,x, y); <br class="title-page-name"/>              } else { <br class="title-page-name"/>                System.out.printf("OptmisticReader: %d - Not Free\n",<br class="title-page-name"/>                                  stamp); <br class="title-page-name"/>              } <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(200); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Finally, implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. Create a <kbd class="calibre15">Position</kbd> and <kbd class="calibre15">StampedLock</kbd> object, create three threads--one for each task--start the threads, and wait for their finalization:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/><br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/><br class="title-page-name"/>            Position position=new Position(); <br class="title-page-name"/>            StampedLock lock=new StampedLock(); <br class="title-page-name"/><br class="title-page-name"/>            Thread threadWriter=new Thread(new Writer(position,lock)); <br class="title-page-name"/>            Thread threadReader=new Thread(new Reader(position, lock)); <br class="title-page-name"/>            Thread threadOptReader=new Thread(new OptimisticReader<br class="title-page-name"/>                                               (position, lock)); <br class="title-page-name"/><br class="title-page-name"/>            threadWriter.start(); <br class="title-page-name"/>            threadReader.start(); <br class="title-page-name"/>            threadOptReader.start(); <br class="title-page-name"/><br class="title-page-name"/>            try { <br class="title-page-name"/>              threadWriter.join(); <br class="title-page-name"/>              threadReader.join(); <br class="title-page-name"/>              threadOptReader.join(); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, we tested the three modes you can use with a stamped lock. In the <kbd class="calibre15">Writer</kbd> task, we get the lock with the <kbd class="calibre15">writeLock()</kbd> method (that acquires the lock in write mode). In the <kbd class="calibre15">Reader</kbd> task, we get the lock with the <kbd class="calibre15">readLock()</kbd> method (that acquires the lock in read mode). Finally, in the <kbd class="calibre15">OptimisticRead</kbd> task, first we use <kbd class="calibre15">tryOptimisticRead()</kbd> and then we use the <kbd class="calibre15">validate()</kbd> method to check whether we can access data or not.</p>
<p class="calibre4">The first two methods, if they can get control of the lock, wait until they get the lock. The <kbd class="calibre15">tryOptimisticRead()</kbd> method always returns a value. It will be <kbd class="calibre15">0</kbd> if we are unable to use the lock and a value different from <kbd class="calibre15">0</kbd> if we can use it. Remember that in this case, we always need to use the <kbd class="calibre15">validate()</kbd> method to check whether we can really access the data.</p>
<p class="calibre4">The following screenshot shows part of the output of an execution of the program:</p>
<div class="cdpaligncenter"><img class="image-border5" src="../images/00019.jpeg"/></div>
<p class="calibre4">While the <kbd class="calibre15">Writer</kbd> task has control of the lock, neither <kbd class="calibre15">Reader</kbd> nor <kbd class="calibre15">OptimisticReader</kbd> can access the values. The <kbd class="calibre15">Reader</kbd> task is suspended in the <kbd class="calibre15">readLock()</kbd> method, while in <kbd class="calibre15">OptimisticReader</kbd>, the call to the <kbd class="calibre15">validate()</kbd> method returns <kbd class="calibre15">false</kbd> and the call to the <kbd class="calibre15">tryOptimisticRead()</kbd> method returns <kbd class="calibre15">0</kbd> to indicate that the lock is controlled in write mode by another thread. When the <kbd class="calibre15">Writertask</kbd> releases the lock, both <kbd class="calibre15">Reader</kbd> and <kbd class="calibre15">OptimisticReader</kbd> tasks will be able to access the values of the shared object.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">StampedLock</kbd> class has other methods that you should know:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">tryReadLock()</kbd> and <kbd class="calibre15">tryReadLock(long time, TimeUnit unit)</kbd>: These methods try to acquire the lock in read mode. If they can't, the first version is returned immediately and the second one waits for the amount of time specified in the parameter. These methods also return a stamp that must be checked (<kbd class="calibre15">stamp != 0</kbd>).</li>
<li class="calibre18"><kbd class="calibre15">tryWriteLock()</kbd> and <kbd class="calibre15">tryWriteLock(long time, TimeUnit unit)</kbd>: These methods try to acquire the lock in write mode. If they can't, the first version is returned immediately and the second one waits for the amount of time specified in the parameter. These methods also return a stamp that must be checked (<kbd class="calibre15">stamp != 0</kbd>).</li>
<li class="calibre18"><kbd class="calibre15">isReadLocked()</kbd> and <kbd class="calibre15">isWriteLocked()</kbd>: These methods are returned if the lock is currently held in read or write mode, respectively.</li>
<li class="calibre18"><kbd class="calibre15">tryConvertToReadLock(long stamp)</kbd>, <kbd class="calibre15">tryConvertToWriteLock(long stamp)</kbd>, and <kbd class="calibre15">tryConvertToOptimisticRead(long stamp)</kbd>: These methods try to convert the stamp passed as a parameter to the mode indicated in the name of the method. If they can, they return a new stamp. If not, they return <kbd class="calibre15">0</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">unlock(long stamp)</kbd>: This releases the corresponding mode of the lock.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a block of code with a lock</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>