<html><head></head><body>
		<div id="_idContainer217">
			<h1 id="_idParaDest-355" class="chapter-number"><a id="_idTextAnchor355"/>14</h1>
			<h1 id="_idParaDest-356"><a id="_idTextAnchor356"/>Lambda Expressions</h1>
			<p>In this chapter, we will cover lambda expressions, which is one of my favorite features. Introduced in Java 8, lambda expressions (<em class="italic">lambdas</em>) brought functional programming to Java. First, we will define a <em class="italic">functional interface</em> and its relationship with lambdas. We will demonstrate both custom and API-based lambda expressions. We will also explain the concept of “final or effectively final” concerning local variables used inside a <span class="No-Break">lambda expression.</span></p>
			<p>After that, we will cover method references. We will discuss and present example code showing bound, unbound, static, and constructor method references. Lastly, we will explain the critical nature of context in understanding <span class="No-Break">method references.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">lambda expressions</span></li>
				<li>Exploring functional interfaces from <span class="No-Break">the API</span></li>
				<li>Mastering <span class="No-Break">method references</span></li>
			</ul>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor357"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch14</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor358"/>Understanding lambda expressions</h1>
			<p>Lambda expressions <a id="_idIndexMarker1097"/>save on keystrokes and therefore make your code more concise and hence, more readable and maintainable. For this to work, the compiler has to be able to generate the code that you no longer type in. This brings us to our first topic: functional interfaces. To understand lambdas, we must first understand <span class="No-Break">functional interfaces.</span></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor359"/>Functional Interfaces</h2>
			<p>Recall that <a id="_idIndexMarker1098"/>an interface <a id="_idIndexMarker1099"/>has <strong class="source-inline">default</strong>, <strong class="source-inline">static</strong>, <strong class="source-inline">private</strong>, and <strong class="source-inline">abstract</strong> methods. A concrete (non-abstract) class that implements an interface must provide code for all of the <strong class="source-inline">abstract</strong> methods. <em class="italic">A functional interface is an interface with just one abstract method</em> – <strong class="source-inline">default</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">private</strong> methods do not count. Neither do any methods inherited from <strong class="source-inline">Object</strong>. This one <strong class="source-inline">abstract</strong> method is known as the <span class="No-Break"><em class="italic">functional method</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor360"/>Lambda expressions</h2>
			<p><em class="italic">A lambda expression is an instance of a class that implements a functional interface.</em> The <a id="_idIndexMarker1100"/>lambda is boiled down to its bare essentials. Lambdas look a lot like methods (and indeed in some quarters are called “anonymous methods”). However, a lambda is an instance with everything, but the method <span class="No-Break">stripped away.</span></p>
			<p>Let’s start with a sample functional interface and how a regular class would <span class="No-Break">implement it:</span></p>
			<pre class="source-code">
interface SampleFI{    void m();
}
class SampleClass implements SampleFI{
   @Override
   public void m(){System.out.println("m()");}
}</pre>
			<p>Now, let us examine the lambda version which does the <span class="No-Break">same thing:</span></p>
			<pre class="source-code">
      SampleFI lambda = () -&gt; System.out.println("m()");      lambda.m();</pre>
			<p>The preceding two lines of code can appear in any method. The first line declares/defines the lambda and the second line executes it. Note that, when defining the lambda, there is no mention of a class implementing the functional interface <strong class="source-inline">SampleFI</strong> and also, there is no mention of the functional method <strong class="source-inline">m()</strong>. In fact, in the lambda declaration, the <strong class="source-inline">()</strong> is the parameter list for <strong class="source-inline">m()</strong>, which takes in nothing; the <strong class="source-inline">-&gt;</strong> token separates the method header from the method body and the <strong class="source-inline">System.out.println("m()")</strong> is the code for the method <strong class="source-inline">m()</strong>. Don’t worry, we will explain lambda syntax in detail very shortly with further <span class="No-Break">code examples.</span></p>
			<p>Bear in mind that <a id="_idIndexMarker1101"/>lambdas save us from typing unnecessary code. For this to happen, the compiler must generate the (missing) code for us in the background. That is why lambdas are only applicable to functional interfaces – the compiler can infer a lot from the interface definition, due to the presence of only one <strong class="source-inline">abstract</strong> method. The compiler sees the one <strong class="source-inline">abstract</strong> method and knows immediately the signature required in the lambda. So, <span class="No-Break">to recap:</span></p>
			<ul>
				<li>Lambdas make your code <span class="No-Break">more concise</span></li>
				<li>Lambdas only work with <span class="No-Break">functional interfaces</span></li>
				<li>A lambda expression is an instance of a class that implements a <span class="No-Break">functional interface</span></li>
			</ul>
			<p>Now let us look at <span class="No-Break">some examples.</span></p>
			<h3>Lambda expressions – example 1</h3>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.1</em> presents a<a id="_idIndexMarker1102"/> custom lambda with an associated <span class="No-Break">functional interface:</span></p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B19793_14_01.jpg" alt=" Figure 14.1 – A functional interface with a lambda expression"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 14.1 – A functional interface with a lambda expression</p>
			<p>In this figure, we <a id="_idIndexMarker1103"/>define a functional <span class="No-Break">interface </span><span class="No-Break"><strong class="source-inline">SomeFunctionalInterface</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
interface SomeFunctionalInterface {    void m();
}</pre>
			<p>It has one <strong class="source-inline">abstract</strong> method, named <strong class="source-inline">m()</strong>. <a id="_idIndexMarker1104"/>As coded, this functional interface, <strong class="source-inline">SomeFunctionalInterface</strong>, can now be used in <span class="No-Break">lambda expressions.</span></p>
			<p>Lines 11-13 define the first lambda expression, <span class="No-Break">namely </span><span class="No-Break"><strong class="source-inline">lambda1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
SomeFunctionalInterface lambda1 = () -&gt; {   System.out.println("First lambda!");
};</pre>
			<p>The reference type is of the <strong class="source-inline">SomeFunctionalInterface</strong> type, our functional interface type. The <strong class="source-inline">lambda1</strong> reference is assigned (to refer to) the instance of the class that <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">SomeFunctionalInterface</strong></span><span class="No-Break">.</span></p>
			<p>On the right-hand side of the assignment are round brackets, <strong class="source-inline">()</strong>. These are for the <strong class="source-inline">m()</strong> method in the interface, <strong class="source-inline">SomeFunctionalInterface</strong>. No parameters have been defined in the method declaration in the interface, so there are no parameters being passed in. As <a id="_idIndexMarker1105"/>there are no parameters, <strong class="source-inline">()</strong> is required. Note that there is no need to mention the method name – this is because, as <strong class="source-inline">SomeFunctionalInterface</strong> is a functional interface, the compiler knows the only <strong class="source-inline">abstract</strong> method is <strong class="source-inline">m()</strong>. And as <strong class="source-inline">m()</strong> defines no parameters, the lambda header is <span class="No-Break">simply </span><span class="No-Break"><strong class="source-inline">()</strong></span><span class="No-Break">.</span></p>
			<p>The arrow token, <strong class="source-inline">-&gt;</strong>, separates the method header (the parameters coming in, if any) from the method body. In this instance, the method body is a block of code; in other words, there are curly braces <strong class="source-inline">{}</strong>, as there would be in a normal method. Once you specify a block of code, the usual rules with a block are followed – meaning, the compiler backs off and does nothing for you. For example, if you wanted to <strong class="source-inline">return</strong> something from the block, you must do this yourself. In the next example, we will see that the compiler will do the <strong class="source-inline">return</strong> for you, provided you do not use a <span class="No-Break">code block.</span></p>
			<p>The lambda in this example is simply outputting <strong class="source-inline">"First lambda!"</strong> to the screen. The semi-colon on line 13 is the normal end of statement token. Lines 11-13 simply <em class="italic">define</em> the lambda. No code has been executed at <span class="No-Break">this point.</span></p>
			<p>Line 15, <strong class="source-inline">lambda1.m()</strong> executes the lambda referred to by <strong class="source-inline">lambda1</strong>, resulting in <strong class="source-inline">"First lambda!"</strong> being output to <span class="No-Break">the screen.</span></p>
			<p>Line 17 defines a similar lambda except that it is even <span class="No-Break">more concise:</span></p>
			<pre class="source-code">
SomeFunctionalInterface lambda2 = () -&gt;    System.out.println("Second lambda!");</pre>
			<p>This lambda, <strong class="source-inline">lambda2</strong>, takes advantage of the fact that the compiler can do even more work for us. If you have only one statement to execute, then, as with other constructs such as loops, a set of curly braces is not necessary. As we are only executing <strong class="source-inline">System.out.println()</strong>, we do not need the curly braces, <strong class="source-inline">{}</strong>. The semi-colon at the end of line 17 is actually for the end of the assignment statement and not the end of <strong class="source-inline">System.out.println()</strong>. In other words, the semi-colon at the end of line 17 is the same semi-colon at the end of line 13 (and not the semi-colon at the end of <span class="No-Break">line 12).</span></p>
			<p>Again, line 17 only defines the lambda and no code has been executed. Line 18, <strong class="source-inline">lambda2.m()</strong> executes the lambda, resulting in <strong class="source-inline">"Second lambda!"</strong> being output to <span class="No-Break">the screen.</span></p>
			<p>Note, the <strong class="source-inline">@FunctionalInterface</strong> annotation (line 3 in <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.1</em>). This annotation ensures that the interface defines only one <strong class="source-inline">abstract</strong> method. Although optional, it is good <a id="_idIndexMarker1106"/>practice to use it, as it highlights to other developers our intention with this interface. In addition, use of this annotation enables the compiler to step in if we fail to provide exactly one <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> method.</span></p>
			<p>Let’s look at another example. This time, the functional method will accept a parameter and return <span class="No-Break">a value.</span></p>
			<h3>Lambda expressions – example 2</h3>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.2</em> presents an example that will enable us to discuss <span class="No-Break">further nuances:</span></p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B19793_14_02.jpg" alt="Figure 14.2 - A more complex functional interface with a lambda expression"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 - A more complex functional interface with a lambda expression</p>
			<p>In this figure, the <strong class="source-inline">Evaluate</strong> function interface is generically typed for <strong class="source-inline">&lt;T&gt;</strong>. This means that we can use it for various types, such as <strong class="source-inline">Integer</strong> (line 12) and <strong class="source-inline">String</strong> (line 16). The <strong class="source-inline">check</strong> functional method (line 8) takes in a parameter of type <strong class="source-inline">T</strong>, namely <strong class="source-inline">t</strong>, and returns a <strong class="source-inline">boolean</strong> value. This particular functional interface is very similar to one we will look at later from the Java API, namely <strong class="source-inline">Predicate</strong>. By way of contrast, the first lambda (line 12) is coded quite differently from the second lambda (<span class="No-Break">line 16).</span></p>
			<p>On line 12, we declare an <strong class="source-inline">Evaluate</strong> reference, namely <strong class="source-inline">isItPositive</strong>, that is typed for integers only. With lambdas, context is key. As we have typed <strong class="source-inline">isItPositive</strong> for <strong class="source-inline">Integer</strong>, this means that the identifier, <strong class="source-inline">n</strong>, in round brackets is of the <strong class="source-inline">Integer</strong> type! We have explicitly specified the type for <strong class="source-inline">n</strong> in this example, but this is not necessary since the compiler can figure it out from the context. In other words, we could have just used <strong class="source-inline">(n)</strong> or simply <strong class="source-inline">n</strong> in the lambda and it would have worked. We just left it as <strong class="source-inline">(Integer n)</strong> so that the relationship between the lambda (line 12) and the <strong class="source-inline">check(T t)</strong> functional method (line 8) <span class="No-Break">is clearer.</span></p>
			<p>The<a id="_idIndexMarker1107"/> right-hand side of <strong class="source-inline">=</strong> on line 12 we have <strong class="source-inline">(Integer n) -&gt; {return n&gt;0;}</strong>. This is the code for the <strong class="source-inline">check(T t)</strong> method in the class implementing <strong class="source-inline">Evaluate</strong>. Therefore, one parameter is required, typed for <strong class="source-inline">Integer</strong> due to the <strong class="source-inline">Evaluate&lt;</strong><em class="italic">Integer</em><strong class="source-inline">&gt;</strong> declaration, and a <strong class="source-inline">boolean</strong> value must <span class="No-Break">be returned.</span></p>
			<p>We have the <strong class="source-inline">-&gt;</strong> token again to separate the method header from the <span class="No-Break">method body.</span></p>
			<p>On line 12, as with all lambdas, the right-hand side of the <strong class="source-inline">-&gt;</strong> token is the method body. In this case, we have <strong class="source-inline">{return n&gt;0;}</strong>. As we have used curly braces, we must follow regular syntax rules when inside a code block. Given that the <strong class="source-inline">check(T t)</strong> method has a <strong class="source-inline">boolean</strong> return type, we must return a <strong class="source-inline">boolean</strong> value from the code block. Also, the <strong class="source-inline">return</strong> statement requires a closing semi-colon as usual. The overall assignment statement requires a closing semi-colon also. This is why there are two semi-colons near the end (line 12). What we are saying in this lambda is that if the <strong class="source-inline">Integer</strong> type passed in is greater than 0, we return <strong class="source-inline">true</strong>; otherwise, we <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p>Line 13, <strong class="source-inline">isItPositive.check(-1)</strong> executes the lambda, passing in <strong class="source-inline">-1</strong>, which returns <strong class="source-inline">false</strong>. Line 14, <strong class="source-inline">isItPositive.check(+1)</strong> also executes the lambda, this time passing in <strong class="source-inline">+1</strong>, which <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Line 16 is: <strong class="source-inline">Evaluate&lt;String&gt; isMale = s -&gt; s.startsWith("Mr.");</strong>. This defines an <strong class="source-inline">Evaluate</strong> lambda, typed for <strong class="source-inline">String</strong>, referred to by the <strong class="source-inline">isMale</strong> reference. As we typed the lambda for <strong class="source-inline">String</strong>, the parameter this time coming in, namely <strong class="source-inline">s</strong>, is of type <strong class="source-inline">String</strong>. Remember, what we are defining on line 16 is effectively the code for the <strong class="source-inline">check(T t)</strong> method. Notice that this time, we have not specified the type for <strong class="source-inline">s</strong> as the compiler figures it out from the context (<strong class="source-inline">Evaluate&lt;String&gt;</strong>). Also, as there is just one parameter and we have not specified the type, we can leave out the round brackets, <strong class="source-inline">()</strong>. However, as we have seen already, if you have no parameters at all, you must <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">()</strong></span><span class="No-Break">.</span></p>
			<p>Also, on line 16, note that as we have not used a code block, we do not need an explicit <strong class="source-inline">return</strong> statement as the compiler will do that for us. As <strong class="source-inline">s</strong> is a <strong class="source-inline">String</strong>, we can call <strong class="source-inline">String</strong> methods; which is why we have no issue calling <strong class="source-inline">startsWith("Mr.")</strong>. The semi-colon at the end of the line is for the overall assignment statement and not for the lambda (as none is required). In this lambda, we just evaluate the string passed in to see if it begins with “Mr.” and if it does, <strong class="source-inline">true</strong> is returned; otherwise, <strong class="source-inline">false</strong> <span class="No-Break">is returned.</span></p>
			<p>With the lambda <a id="_idIndexMarker1108"/>now defined, we can execute it. Line 17, <strong class="source-inline">isMale.check("Mr. Sean Kennedy")</strong> returns <strong class="source-inline">true</strong> and line 18, <strong class="source-inline">isMale.check("Ms. Maaike van Putten")</strong> <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p>As you can see, the compiler infers a lot, saving us a lot of typing. It takes a while to get used to lambdas but once you do, you will love them. <em class="italic">Table 14.1</em> summarizes <span class="No-Break">the syntax:</span></p>
			<table id="table001-3" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Functional Interface</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">Sample </strong><span class="No-Break"><strong class="bold">Lambda Expressions</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">interface FI{</strong></span></p>
							<p><strong class="source-inline">     </strong><span class="No-Break"><strong class="source-inline">void m();</strong></span></p>
							<p><strong class="source-inline">}</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">FI fi1 = () -&gt; </strong><span class="No-Break"><strong class="source-inline">System.out.println("lambda");</strong></span></p>
							<p><strong class="source-inline">fi1.m(); // </strong><span class="No-Break"><strong class="source-inline">outputs "lambda"</strong></span></p>
							<p><strong class="source-inline">FI fi2 = () -&gt; { System.out.println("lambda"); } ;</strong></p>
							<p><strong class="source-inline">fi2.m(); // </strong><span class="No-Break"><strong class="source-inline">outputs "lambda"</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">interface FI{</strong></span></p>
							<p><strong class="source-inline">     int </strong><span class="No-Break"><strong class="source-inline">m(int x);</strong></span></p>
							<p><strong class="source-inline">}</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">FI fi3 = (int x) -&gt; { return x * </strong><span class="No-Break"><strong class="source-inline">x;};</strong></span></p>
							<p><strong class="source-inline">System.out.println(fi3.m(5)); // </strong><span class="No-Break"><strong class="source-inline">25</strong></span></p>
							<p><strong class="source-inline">FI fi4 = x -&gt; x * </strong><span class="No-Break"><strong class="source-inline">x;</strong></span></p>
							<p><strong class="source-inline">System.out.println(fi4.m(6)); // </strong><span class="No-Break"><strong class="source-inline">36</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">interface FI{</strong></span></p>
							<p><strong class="source-inline">     String m(String a, </strong><span class="No-Break"><strong class="source-inline">String b);</strong></span></p>
							<p><strong class="source-inline">}</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">FI fi5 = (s1, s2) -&gt; s1 + </strong><span class="No-Break"><strong class="source-inline">s2;</strong></span></p>
							<p><strong class="source-inline">// next line returns '</strong><span class="No-Break"><strong class="source-inline">Sean Kennedy'</strong></span></p>
							<p><strong class="source-inline">System.out.println(fi5.m("Sean", " </strong><span class="No-Break"><strong class="source-inline">Kennedy"));</strong></span></p>
							<p><strong class="source-inline">FI fi6 = (String s1 , String s2) -&gt; {return s1 + </strong><span class="No-Break"><strong class="source-inline">s2; };</strong></span></p>
							<p><strong class="source-inline">// next line returns '</strong><span class="No-Break"><strong class="source-inline">Sean Kennedy'</strong></span></p>
							<p><strong class="source-inline">System.out.println(fi6.m("Sean", " </strong><span class="No-Break"><strong class="source-inline">Kennedy"));</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Table 14.1 – Examples of functional interfaces and associated lambda expressions</p>
			<p>The longer syntax, with<a id="_idIndexMarker1109"/> the parameter types, code blocks, and <strong class="source-inline">return</strong> statements, is syntactically similar to regular methods (except the method name is omitted). The shorter, more concise syntax, demonstrates just how much the compiler can infer from the surrounding context. This is possible as there is only one <strong class="source-inline">abstract</strong> method in a functional interface. Lambdas cannot and do not work with interfaces that have more than one <strong class="source-inline">abstract</strong> method. As interfaces can inherit from each other, be wary of inheriting an <strong class="source-inline">abstract</strong> method and then trying to define your own – that will not work <span class="No-Break">for lambdas.</span></p>
			<p>Now that we understand functional interfaces and how to implement them using lambda expressions, let’s examine why local variables must be <strong class="source-inline">final</strong> or “<span class="No-Break">effectively final.”</span></p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor361"/>final or effectively final</h2>
			<p>Recall that by declaring a <a id="_idIndexMarker1110"/>variable <strong class="source-inline">final</strong>, you are making it a constant, which means that the value of the variable, once assigned, cannot be changed. “Effectively final” means that even though the <strong class="source-inline">final</strong> keyword is not used in the variable declaration, the compiler makes it <em class="italic">effectively final</em> by ensuring that if you try to change its value, you get a compiler error. Note that this rule of <strong class="source-inline">final</strong> or “effectively final” relates only to local variables and does not apply to instance or <span class="No-Break">class variables.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.3</em> presents code demonstrating the use of <strong class="source-inline">final</strong> or “effectively final”. We will first explain the code and then explain why the local variable is “<span class="No-Break">effectively final.”</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B19793_14_03.jpg" alt="Figure 14.3 – “final” or “effectively final” code example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – “final” or “effectively final” code example</p>
			<p>In this figure, the<a id="_idIndexMarker1111"/> algorithm removes any names from the list that begin with <strong class="source-inline">"Mr."</strong>. Lines 9-11 declare and populate an <span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break"> list.</span></p>
			<p>Line 13 declares a local <strong class="source-inline">String</strong> variable named <strong class="source-inline">title</strong>. This variable is used in the lambda (line 21) and therefore, as it is not explicitly declared <strong class="source-inline">final</strong>, it is “<span class="No-Break">effectively final.”</span></p>
			<p>Lines 14-15 declare and change a local <strong class="source-inline">int</strong> variable, <strong class="source-inline">y</strong>. As <strong class="source-inline">y</strong> is not used in the lambda expression, this <span class="No-Break">is fine.</span></p>
			<p>Lines 19-22 present the <span class="No-Break">lambda expression:</span></p>
			<pre class="source-code">
Predicate&lt;String&gt; lambda = str -&gt; {     return str.startsWith(title);
};</pre>
			<p>The lambda is a <strong class="source-inline">Predicate</strong>, typed for <strong class="source-inline">String</strong>. <strong class="source-inline">Predicate</strong> is an API functional interface, which we will discuss in detail in the next section. The functional method for <strong class="source-inline">Predicate</strong> is <strong class="source-inline">boolean test(T t)</strong>. As we have typed the <strong class="source-inline">Predicate</strong> for <strong class="source-inline">String</strong>, both <strong class="source-inline">T</strong> and consequently <strong class="source-inline">str</strong> are <strong class="source-inline">String</strong>’s. The lambda returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> depending on whether <strong class="source-inline">str</strong> begins with <strong class="source-inline">"Mr."</strong>, thereby matching the return type of the <strong class="source-inline">test</strong> functional method. This is an important point – the lambda has taken a snapshot of the value in the local variable <strong class="source-inline">title</strong>; which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">"Mr."</strong></span><span class="No-Break">.</span></p>
			<p>Both lines 27 and 30 invoke <strong class="source-inline">filterData(people, lambda)</strong>. This is one of the real advantages of lambdas – they can be passed around! But remember, the value of <strong class="source-inline">title</strong> in the lambda <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">"Mr."</strong></span><span class="No-Break">.</span></p>
			<p>Lines 32-34 show the <span class="No-Break"><strong class="source-inline">filterData()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
public static void filterData(List&lt;String&gt; list,                              Predicate&lt;String&gt; lambda) {
     list.removeIf(lambda);
};</pre>
			<p>The<a id="_idIndexMarker1112"/> lambda is passed to the <strong class="source-inline">default</strong> method, <strong class="source-inline">removeIf(Predicate)</strong>, which is inherited from <strong class="source-inline">Collection</strong>. <strong class="source-inline">Collection</strong> is a parent interface of <strong class="source-inline">List</strong>. <strong class="source-inline">removeIf(Predicate)</strong> removes all elements from the list that satisfy the predicate (lambda) passed in. In this example, any names that begin with <strong class="source-inline">"Mr."</strong> <span class="No-Break">are removed.</span></p>
			<p>Now, you can see why the value of <strong class="source-inline">title</strong> (line 13) must never be allowed to change – the lambda uses <strong class="source-inline">"Mr."</strong> (line 21). If we were allowed to change <strong class="source-inline">title</strong>, either in the lambda (line 20) or in the method (lines 26 or 29), then the value of <strong class="source-inline">title</strong> in the method and the value of <strong class="source-inline">title</strong> in the lambda would not match! This must not happen. Therefore, any changes to <strong class="source-inline">title</strong>, either in the method or in the lambda, are prohibited. This is why lines 20, 26, and 29 are all commented out. Uncommenting any of them results in a <span class="No-Break">compiler error.</span></p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor362"/>Exploring functional interfaces from the API</h1>
			<p>Now, let’s examine some popular functional interfaces defined in the API. Interestingly, the <a id="_idIndexMarker1113"/>two<a id="_idIndexMarker1114"/> sorting interfaces from <a href="B19793_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, namely <strong class="source-inline">Comparator</strong> and <strong class="source-inline">Comparable</strong>, are both functional interfaces. <strong class="source-inline">Comparable</strong> defines one <strong class="source-inline">abstract</strong> method, namely <strong class="source-inline">int compareTo(T o)</strong>, and <strong class="source-inline">Comparator</strong> defines two <strong class="source-inline">abstract</strong> methods, namely <strong class="source-inline">int compare(T o1, T o2)</strong> and <strong class="source-inline">boolean equals(Object o)</strong>. Remember, however, that methods inherited from <strong class="source-inline">Object</strong> do not count when you’re deciding if an interface is a functional interface or not. As <strong class="source-inline">boolean equals(Object o)</strong> is inherited from <strong class="source-inline">Object</strong>, this means that <strong class="source-inline">Comparator</strong> is a <span class="No-Break">functional interface.</span></p>
			<p>In this section, we will concentrate on the functional interfaces defined in the <strong class="source-inline">java.util.function</strong> package (<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html</a>). This package has a large number of general-purpose functional interfaces that are used by the JDK and are available to us also. <em class="italic">Table 14.2</em> presents the most commonly used ones. Please refer to the API for further details. We will examine these functional interfaces and their lambda expressions in <span class="No-Break">code shortly:</span></p>
			<table id="table002-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Interface</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Method</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Predicate&lt;T&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">boolean </strong><span class="No-Break"><strong class="source-inline">test(T t)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Useful <span class="No-Break">for testing</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">BiPredicate&lt;T, U&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">boolean test(T t, </strong><span class="No-Break"><strong class="source-inline">U u)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>This is a two-arity (two parameters) specialization <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Predicate</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Supplier&lt;T&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">T get()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Useful for when you want values without <span class="No-Break">providing input</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Consumer&lt;T&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">void </strong><span class="No-Break"><strong class="source-inline">accept(T t)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Useful for when you pass in input but do not care about a <span class="No-Break">return value</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">BiConsumer&lt;T, U&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">void accept(T t, </strong><span class="No-Break"><strong class="source-inline">U u)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>This is a two-arity specialization <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Consumer</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Function&lt;T, R&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">R </strong><span class="No-Break"><strong class="source-inline">apply(T t)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Transforms the input into an output (types can <span class="No-Break">be different)</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">BiFunction&lt;T, </strong><span class="No-Break"><strong class="source-inline">U, R&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline" lang="de-DE" xml:lang="de-DE">R apply(T t, </strong><span class="No-Break"><strong class="source-inline" lang="de-DE" xml:lang="de-DE">U u)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>This is a two-arity specialization <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Function</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">UnaryOperator&lt;T&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">T </strong><span class="No-Break"><strong class="source-inline">apply(T t)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>The same as <strong class="source-inline">Function</strong> except the types are <span class="No-Break">the same</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">BinaryOperator&lt;T&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline" lang="de-DE" xml:lang="de-DE">T apply(T t1, </strong><span class="No-Break"><strong class="source-inline" lang="de-DE" xml:lang="de-DE">T t2</strong></span><span class="No-Break" lang="de-DE" xml:lang="de-DE">)</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>The same as <strong class="source-inline">BiFunction</strong> except the types are all <span class="No-Break">the same</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.2 – Popular functional interfaces in the API</p>
			<p>Now, let’s examine<a id="_idIndexMarker1115"/> each <a id="_idIndexMarker1116"/>of the preceding functional interfaces and their associated lambdas in code. Let’s start with <strong class="source-inline">Predicate</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">BiPredicate</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor363"/>Predicate and BiPredicate</h2>
			<p>A <a id="_idIndexMarker1117"/>predicate is <a id="_idIndexMarker1118"/>a <a id="_idIndexMarker1119"/>boolean-valued function (a function that will return <strong class="source-inline">boolean</strong>). <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.4</em> presents <strong class="source-inline">Predicate</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">BiPredicate</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B19793_14_04.jpg" alt="Figure 14.4 – Predicate and BiPredicate in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Predicate and BiPredicate in code</p>
			<p>In this figure, we would first like to discuss the relationship in the API between the generic types of functional interfaces and their functional methods. Understanding this relationship is key to understanding the examples and creating the context used by the compiler. This context will be very important when we discuss method <span class="No-Break">references later.</span></p>
			<p>As the comments on lines 32-33 indicate, there is a direct relationship between the generic types and both the parameter and return types used by the functional method. In this case, <strong class="source-inline">Predicate</strong> is generically typed for <strong class="source-inline">T</strong> (line 32), and the functional methods input parameter is also typed for <strong class="source-inline">T</strong> (line 33). Therefore, if we type our <strong class="source-inline">Predicate</strong> for <strong class="source-inline">Integer</strong>, then the parameter in the functional method will be <strong class="source-inline">Integer</strong>. We cannot pass <strong class="source-inline">Cat</strong>, <strong class="source-inline">Dog</strong>, <strong class="source-inline">String</strong>, or any other type as an argument. Now, let’s look at <span class="No-Break">the example.</span></p>
			<p>Line 34 defines a <strong class="source-inline">Predicate</strong>, generically typed for <strong class="source-inline">String</strong>, namely <strong class="source-inline">isCityInName</strong>. <strong class="source-inline">cityName -&gt; cityName.contains("City")</strong> is the code for the <strong class="source-inline">boolean test(T t)</strong> functional method. As the generic type is <strong class="source-inline">String</strong>, <strong class="source-inline">T</strong> is now <strong class="source-inline">String</strong> for this functional method, meaning that the parameter type is <strong class="source-inline">String</strong>. Thus, the <strong class="source-inline">cityName</strong> variable on line 34 represents a <strong class="source-inline">String</strong> variable. This is why the compiler has no issue with <strong class="source-inline">cityName.contains("City")</strong> in the lambda expression. As <strong class="source-inline">cityName.contains("City")</strong> is a simple expression, we do not need <strong class="source-inline">{}</strong> or a <strong class="source-inline">return</strong> statement – the compiler will fill all that in for us. Bear in mind that the expression we use must return a <strong class="source-inline">boolean</strong> value as the <strong class="source-inline">boolean test(T t)</strong> functional method returns <strong class="source-inline">boolean</strong>. The <strong class="source-inline">String</strong> method, <strong class="source-inline">boolean contains(CharSequnce)</strong>, does exactly that, so we are fine. So, with our lambda expression defined, let’s <span class="No-Break">execute it.</span></p>
			<p>Line 35 executes the <strong class="source-inline">isCityInName</strong> lambda defined on line 34. Note that the method that’s invoked using the <strong class="source-inline">isCityInName</strong> reference is the <strong class="source-inline">boolean test(T t)</strong> functional method. As we have generically typed <strong class="source-inline">isCityInName</strong> to <strong class="source-inline">String</strong>, the argument we pass must be a <strong class="source-inline">String</strong> argument. This<a id="_idIndexMarker1120"/> is <a id="_idIndexMarker1121"/>what we do, passing in <strong class="source-inline">"Vatican City"</strong>. This means that the <strong class="source-inline">cityName</strong> parameter in our lambda (line 34) becomes <strong class="source-inline">"Vatican City"</strong> and thus the code in the <strong class="source-inline">boolean test(T t)</strong> method becomes <strong class="source-inline">"Vatican City".contains("City")</strong>. Consequently, line 35 <span class="No-Break">outputs </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Line 39 defines a <strong class="source-inline">BiPredicate</strong>, generically typed for <strong class="source-inline">String, Integer</strong>; namely <strong class="source-inline">checkStringLength</strong> Again, the comments (lines 37-38), demonstrate the close relationship between the functional interface’s generic types and the parameters for the functional method. <strong class="source-inline">BiPredicate</strong> is simply an extension of <strong class="source-inline">Predicate</strong> except that there are now two (input) parameters for the functional method, instead of one. The functional method name is still <strong class="source-inline">test</strong> and the return type is <span class="No-Break">again </span><span class="No-Break"><strong class="source-inline">boolean</strong></span><span class="No-Break">.</span></p>
			<p>As <strong class="source-inline">checkStringLength</strong> is defined as <strong class="source-inline">BiPredicate&lt;String, Integer&gt;</strong>, the signature for the functional method is now <strong class="source-inline">boolean test(String str, Integer len)</strong>. The lambda then checks if the length of the string passed in as the first parameter, is equal to the number passed in as the <span class="No-Break">second parameter.</span></p>
			<p>On line 40, we test <strong class="source-inline">BiPredicate</strong>, passing in <strong class="source-inline">"Vatican City"</strong> and <strong class="source-inline">8</strong> in that order. The lambda returns <strong class="source-inline">false</strong> as the length of the <strong class="source-inline">"Vatican City"</strong> string is <strong class="source-inline">12</strong> (and <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">).</span></p>
			<p>As discussed earlier, both <strong class="source-inline">Predicate</strong> and <strong class="source-inline">BiPredicate</strong> are generically typed for <strong class="source-inline">T</strong>. This means that their functional method consumes a type, <strong class="source-inline">T</strong>, such as <strong class="source-inline">String</strong>, <strong class="source-inline">Integer</strong>, and so forth. This is in contrast to predicates that consume primitives. The following table, <em class="italic">Table 14.3</em>, presents the functional interfaces defined in the API for predicates that wish to <span class="No-Break">consume primitives:</span></p>
			<table id="table003-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Interface</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Method</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">DoublePredicate</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">boolean </strong><span class="No-Break"><strong class="source-inline">test(double value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">DoublePredicate p1 = d -&gt; d &gt; </strong><span class="No-Break"><strong class="source-inline">0;</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">IntPredicate</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">boolean </strong><span class="No-Break"><strong class="source-inline">test(int value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">IntPredicate p2 = i -&gt; i &gt; </strong><span class="No-Break"><strong class="source-inline">0;</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">LongPredicate</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">boolean </strong><span class="No-Break"><strong class="source-inline">test(long value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">LongPredicate p3 = lg -&gt; lg &gt; </strong><span class="No-Break"><strong class="source-inline">0;</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.3 – Primitive testing specializations of Predicate in the API</p>
			<p>As can be seen from the table, there are no generic types, such as <strong class="source-inline">&lt;T&gt;</strong> in the names of the functional interfaces. The <a id="_idIndexMarker1122"/>functional methods have primitive<a id="_idIndexMarker1123"/> parameters (instead of generic types). As we are dealing with primitives, the lambdas cannot invoke methods on the arguments (as primitives are just simple types and have <span class="No-Break">no methods).</span></p>
			<p>Now, let’s discuss the <strong class="source-inline">Supplier</strong> <span class="No-Break">functional interface.</span></p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor364"/>Supplier</h2>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.5</em> presents<a id="_idIndexMarker1124"/> code<a id="_idIndexMarker1125"/> that <span class="No-Break">demonstrates </span><span class="No-Break"><strong class="source-inline">Supplier</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B19793_14_05.jpg" alt="Figure 14.5 – Supplier in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Supplier in code</p>
			<p>The <strong class="source-inline">Supplier</strong> functional interface is very useful when you want a new object. The generic type determines the result supplied. In other words, line 47 types <strong class="source-inline">supSB</strong> for <strong class="source-inline">StringBuilder</strong>, where the functional method, <strong class="source-inline">get()</strong>, returns <strong class="source-inline">StringBuilder</strong>. Line 47 also demonstrates that if you have no parameters at all, you must specify the round <span class="No-Break">brackets, </span><span class="No-Break"><strong class="source-inline">()</strong></span><span class="No-Break">.</span></p>
			<p>Line 48 executes the lambda expression defined on line 47. Note that we chain <strong class="source-inline">append("SK")</strong> onto the return of the <strong class="source-inline">get()</strong> method. This will only work if the <strong class="source-inline">get()</strong> method returns a <strong class="source-inline">StringBuilder</strong> object, which <span class="No-Break">it does.</span></p>
			<p>Line 50 defines a <strong class="source-inline">Supplier</strong> functional interface, typed for <strong class="source-inline">LocalTime</strong>, called <strong class="source-inline">supTime</strong>. The lambda returns the local time. Line 51 executes it by invoking the functional method for <strong class="source-inline">Supplier</strong>, namely <strong class="source-inline">T get()</strong>. The output from a sample run is included in a comment on the <span class="No-Break">right-hand side.</span></p>
			<p>Line 53 defines a <strong class="source-inline">Supplier</strong> functional interface typed for <strong class="source-inline">Double</strong> called <strong class="source-inline">sRandom</strong>, which returns a random number. <strong class="source-inline">Math.random()</strong> returns a <strong class="source-inline">double</strong> value greater than or equal to 0.0 and less than 1.0. Line 54 executes it with sample output in a comment on <span class="No-Break">the right.</span></p>
			<p>The generically typed <strong class="source-inline">Supplier</strong> functional interface also has variants to cater to primitives. <em class="italic">Table 14.4</em> <span class="No-Break">shows these:</span></p>
			<table id="table004-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Interface</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Method</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">BooleanSupplier</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">boolean getAsBoolean()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">BooleanSupplier bS = () -&gt; </strong><span class="No-Break"><strong class="source-inline">LocalDate.now().isLeapYear();</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">System.out.println(bS.getAsBoolean());</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">DoubleSupplier</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">double getAsDouble()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">DoubleSupplier dS = () -&gt; </strong><span class="No-Break"><strong class="source-inline">Math.random();</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">System.out.println(dS.getAsDouble());</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">IntSupplier</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">int getAsInt()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">IntSupplier iS = () -&gt; (</strong><span class="No-Break"><strong class="source-inline">int)(Math.random()*20);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline" lang="de-DE" xml:lang="de-DE">System.out.println(iS.getAsInt());</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">LongSupplier</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">long getAsLong()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">LongSupplier lgS = () -&gt; (</strong><span class="No-Break"><strong class="source-inline">long)(Math.random()*100);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">System.out.println(lgS.getAsLong());</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.4 – Primitive-producing specializations of Supplier in the API</p>
			<p>In this table, the functional interface name identifies the primitive type being generated. For example, <strong class="source-inline">BooleanSupplier</strong> produces a <strong class="source-inline">boolean</strong> primitive type. The functional method<a id="_idIndexMarker1126"/> follows <a id="_idIndexMarker1127"/>accordingly; for example, <strong class="source-inline">BooleanSupplier</strong> has a <strong class="source-inline">boolean getAsBoolean()</strong> method. The other functional interfaces follow a <span class="No-Break">similar pattern.</span></p>
			<p>Now, let’s discuss the <strong class="source-inline">Consumer</strong> and <strong class="source-inline">BiConsumer</strong> <span class="No-Break">functional interfaces.</span></p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor365"/>Consumer and BiConsumer</h2>
			<p>We will <a id="_idIndexMarker1128"/>start <a id="_idIndexMarker1129"/>with <strong class="source-inline">Consumer</strong>, which, as<a id="_idIndexMarker1130"/> per <a id="_idIndexMarker1131"/>the API, “<em class="italic">represents an operation that takes in a single input and returns no result.</em>” <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.6</em> presents code demonstrating the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Consumer</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B19793_14_06.jpg" alt="Figure 14.6 – Consumer in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Consumer in code</p>
			<p>In this figure, line 67 (a comment) outlines that the <strong class="source-inline">void accept(T t)</strong> functional method does exactly as per the API: it takes in a single input and returns nothing (<strong class="source-inline">void</strong>). Consumers are very useful for outputting collections. In this example, <strong class="source-inline">Consumer</strong> (line 68) takes in a <strong class="source-inline">String</strong>, <strong class="source-inline">s</strong>, and echoes it to the standard output (the screen). We execute the lambda (line 69), passing in the string we want displayed. So, the <strong class="source-inline">"To be or not to be, that is the question"</strong> string is the argument to the <strong class="source-inline">void accept(T t)</strong> functional method. Here, the <strong class="source-inline">s</strong> parameter (line 68) takes on the string value, which is <span class="No-Break">then output.</span></p>
			<p class="callout-heading">The Iterable interface</p>
			<p class="callout">The <strong class="source-inline">Iterable</strong> interface is inherited<a id="_idIndexMarker1132"/> by many other popular interfaces, such as <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong>, and consequently, implemented by a large number of classes. Before Java 8, interfaces only had <strong class="source-inline">abstract</strong> methods – there were no <strong class="source-inline">default</strong>, <strong class="source-inline">static</strong>, or <strong class="source-inline">private</strong> methods (they all came in later releases of Java). This meant that if you changed an interface (method signature or added a new method), the existing code base would break. One of the main reasons for introducing <strong class="source-inline">default</strong> methods was for the Java designers to introduce the <strong class="source-inline">default</strong> method, <strong class="source-inline">forEach(Consumer&lt;? super T&gt; action)</strong>, into <strong class="source-inline">Iterable</strong> without breaking the existing code base. The default implementation is to execute the <strong class="source-inline">Consumer</strong> lambda on each element in <span class="No-Break">the collection.</span></p>
			<p>Now, let’s examine <a id="_idIndexMarker1133"/>how the Java API utilizes consumers. Line 71 declares an <strong class="source-inline">ArrayList</strong> of strings, namely <strong class="source-inline">names</strong>. Line 72 adds <strong class="source-inline">"Maaike"</strong> and <strong class="source-inline">"Sean"</strong> to <span class="No-Break">the list.</span></p>
			<p>Line 73 is <a id="_idIndexMarker1134"/>very interesting. We execute the <strong class="source-inline">forEach()</strong> method <a id="_idIndexMarker1135"/>on the list, passing in the consumer <a id="_idIndexMarker1136"/>lambda, <strong class="source-inline">printC</strong>, that was created on line 68. The <strong class="source-inline">forEach()</strong> method<a id="_idIndexMarker1137"/> loops through each <strong class="source-inline">String</strong> in the list and invokes the <strong class="source-inline">Consumer</strong> lambda, <strong class="source-inline">printC</strong>, on each <strong class="source-inline">String</strong>. In effect, the following happens in <span class="No-Break">the background:</span></p>
			<pre class="source-code">
printC.accept("Maaike");printC.accept("Sean");</pre>
			<p>Now, let’s look at an example of a <strong class="source-inline">BiConsumer</strong> interface in action. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.7</em> presents <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B19793_14_07.jpg" alt="Figure 14.7 – BiConsumer in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – BiConsumer in code</p>
			<p>In this figure, on line 75, we declare a <strong class="source-inline">Map&lt;String, String&gt;</strong>, namely <strong class="source-inline">mapCapitalCities</strong>, implemented by a <strong class="source-inline">HashMap</strong>. Both the key and the value in the map are strings. The <strong class="source-inline">BiConsumer</strong> <strong class="source-inline">biCon</strong> is declared on lines 80-81. The functional method, <strong class="source-inline">void accept(T t, U u)</strong>, requires two parameters – we have called them <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong>. Both are strings due to the context (the declaration of <strong class="source-inline">biCon</strong>). The lambda on line 81, is simply inserting the <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong> into the map. This is known as a “side effect” (see the callout). Lines 82-83 populate the map using the lambda and line 84 outputs <span class="No-Break">the map.</span></p>
			<p class="callout-heading">Side effects</p>
			<p class="callout">In Java, lambda expressions are considered a functional style of programming. While functional programming is outside the scope of this book, functions adhering to the functional programming style should not generate side effects. A side effect is a change to the program state not reflected in the function’s output. <strong class="source-inline">Consumer</strong>s, unlike most other functional interfaces in Java, are expected to operate via side effects (as the return type for the functional methods is <strong class="source-inline">void</strong>). For further detail please <span class="No-Break">see: </span><a href="https://en.wikipedia.org/wiki/Functional_programming"><span class="No-Break">https://en.wikipedia.org/wiki/Functional_programming</span></a></p>
			<p>Is there a <strong class="source-inline">forEach()</strong> method for <strong class="source-inline">Map</strong>? Thankfully, there is. It is a <strong class="source-inline">default</strong> method defined in the <strong class="source-inline">Map</strong> interface and its signature is <strong class="source-inline">default void forEach(BiConsumer&lt;? super K, ? super V) action)</strong>. Lines 86-88 set up the lambda expression to output the decorated string, stating that <strong class="source-inline">key</strong> is the capital of <strong class="source-inline">value</strong> (depending on the key/value pairs). Line 89 executes <strong class="source-inline">forEach()</strong>, passing in our <strong class="source-inline">BiConsumer</strong>. The <strong class="source-inline">forEach()</strong> method loops through each entry in the map and invokes the <strong class="source-inline">BiConsumer</strong> lambda, <strong class="source-inline">mapPrint</strong>, on each entry. In effect, the following<a id="_idIndexMarker1138"/> happens<a id="_idIndexMarker1139"/> in <a id="_idIndexMarker1140"/><span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker1141"/></span><span class="No-Break">background:</span></p>
			<pre class="source-code">
mapPrint.accept("Dublin", "Ireland");mapPrint.accept("The Hague", "Holland");</pre>
			<p>The generically typed <strong class="source-inline">Consumer</strong> functional interface also has variants to cater for primitives. <em class="italic">Table 14.5</em> <span class="No-Break">shows these:</span></p>
			<table id="table005-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Functional Interface</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Functional Method</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">DoubleConsumer</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><strong class="source-inline">void </strong><span class="No-Break"><strong class="source-inline">accept(double value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">DoubleConsumer dc = d -&gt; </strong><span class="No-Break"><strong class="source-inline">System.out.println(d);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">dc.accept(2.4);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">IntConsumer</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><strong class="source-inline">void </strong><span class="No-Break"><strong class="source-inline">accept(int value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">IntConsumer ic = i -&gt; </strong><span class="No-Break"><strong class="source-inline">System.out.println(i);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ic.accept(2);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">LongConsumer</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><strong class="source-inline">void </strong><span class="No-Break"><strong class="source-inline">accept(long value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">LongConsumer lc = lg -&gt; </strong><span class="No-Break"><strong class="source-inline">System.out.println(lg);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">lc.accept(8L);</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.5 – Primitive-accepting specializations of Consumer in the API</p>
			<p>Again, the <a id="_idIndexMarker1142"/>primitive name is embedded into the functional interface name. Note <a id="_idIndexMarker1143"/>that the parameter type<a id="_idIndexMarker1144"/> passed into <a id="_idIndexMarker1145"/>the <strong class="source-inline">accept()</strong> functional method is a primitive <span class="No-Break">each time</span></p>
			<p>Now, let’s discuss the <strong class="source-inline">Function</strong> and <strong class="source-inline">BiFunction</strong> <span class="No-Break">functional interfaces.</span></p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor366"/>Function and BiFunction</h2>
			<p>A function <a id="_idIndexMarker1146"/>accepts<a id="_idIndexMarker1147"/> one <a id="_idIndexMarker1148"/>argument and produces <a id="_idIndexMarker1149"/>a result. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.8</em> presents some code demonstrating the use of both <strong class="source-inline">Function</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">BiFunction</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/B19793_14_08.jpg" alt="Figure 14.8 – Function and BiFunction in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – Function and BiFunction in code</p>
			<p>In this figure, the comments on lines 101-102 show how the <strong class="source-inline">Function</strong> functional interface and its functional method appear in the API. <strong class="source-inline">Function</strong> is generically typed, with the first type, <strong class="source-inline">T</strong>, representing the input type and the second type, <strong class="source-inline">R</strong>, representing the output type. What this means is that, when, on line 103, we declare <strong class="source-inline">Function&lt;String, Integer&gt;</strong>, the functional method is <strong class="source-inline">Integer apply(String s)</strong>. This is reflected in the lambda expression on line 103, where we accept a string, <strong class="source-inline">s</strong>, and return its length. Note that the string’s <strong class="source-inline">length()</strong> method returns an <strong class="source-inline">int</strong> type but Java will auto-box this to an <strong class="source-inline">Integer</strong> type <span class="No-Break">for us.</span></p>
			<p>Line 104 executes the lambda, passing in <strong class="source-inline">"London"</strong>, which <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">BiFunction</strong> functional interface<a id="_idIndexMarker1150"/> represents a function <a id="_idIndexMarker1151"/>that accepts two arguments and<a id="_idIndexMarker1152"/> produces<a id="_idIndexMarker1153"/> a result. The comments on lines 106-107 shows its signature in the API, namely <strong class="source-inline">BiFunction&lt;T, U, R&gt;</strong>, and that of its functional method, which is <strong class="source-inline">R apply(T t, U u)</strong>. Therefore, the first two types are inputs and the last type is the <span class="No-Break">output type.</span></p>
			<p>Lines 108-109 define a <strong class="source-inline">BiFunction</strong> interface where we are accepting in two <strong class="source-inline">String</strong>s and returning an <strong class="source-inline">Integer</strong> type. The lambda implementing it takes in two <strong class="source-inline">String</strong> parameters, namely <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>, and returns the sum of <span class="No-Break">their lengths.</span></p>
			<p>Line 111 invokes the lambda while passing in the <strong class="source-inline">"William"</strong> and <strong class="source-inline">"Shakespeare"</strong> strings. Their lengths are <strong class="source-inline">7</strong> and <strong class="source-inline">11</strong>, respectively, resulting in <strong class="source-inline">18</strong> being returned by <span class="No-Break">the lambda.</span></p>
			<p>Lines 113-114 define a <strong class="source-inline">BiFunction</strong> interface <a id="_idIndexMarker1154"/>where we are accepting in two <strong class="source-inline">String</strong>s again, but <a id="_idIndexMarker1155"/>this time, we return a <strong class="source-inline">String</strong>. The<a id="_idIndexMarker1156"/> lambda (line 114) simply concatenates<a id="_idIndexMarker1157"/> the second <strong class="source-inline">String</strong> onto the first <strong class="source-inline">String</strong> and returns the result. Line 116 executes the lambda while passing in the same two strings, <strong class="source-inline">"William"</strong> and <strong class="source-inline">"Shakespeare"</strong>. This time, the result is the concatenation of the two, which is <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">William Shakespeare"</strong></span><span class="No-Break">.</span></p>
			<p>The generically typed <strong class="source-inline">Function</strong> functional interface also has variants to cater to primitives. <em class="italic">Table 14.6</em> presents a subset <span class="No-Break">of them:</span></p>
			<table id="table006-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Interface</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Functional Method</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">DoubleFunction&lt;R&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><strong class="source-inline">R </strong><span class="No-Break"><strong class="source-inline">apply(double value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">DoubleFunction&lt;String&gt; df = (double dbl) -&gt; "" + </strong><span class="No-Break"><strong class="source-inline">Math.pow(dbl, 2);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">df.apply(2.0); // "</strong><span class="No-Break"><strong class="source-inline">4.0"</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">DoubleToIntFunction</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><strong class="source-inline">int </strong><span class="No-Break"><strong class="source-inline">applyAsInt(double value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">DoubleToIntFunction dtoif = dbl -&gt; (</strong><span class="No-Break"><strong class="source-inline">int)Math.round(dbl);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">dtoif.applyAsInt(4.2);// 4</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><span class="No-Break"><strong class="source-inline">DoubleToLongFunction</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body" rowspan="2">
							<p><strong class="source-inline">long </strong><span class="No-Break"><strong class="source-inline">applyAsLong(double value)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">DoubleToLongFunction dtolf = (dbl) -&gt; </strong><span class="No-Break"><strong class="source-inline">Math.round(dbl);</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">dtolf.applyAsLong(4.0);// 4</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.6 – Double (primitive) specializations of Function in the API</p>
			<p>There are many more functional interfaces than those presented in <em class="italic">Table 14.6</em>. Please refer to the API for further details. They can be daunting but remember that there is a pattern in the functional interface names and their associated functional method names. This helps in understanding what <span class="No-Break">they do.</span></p>
			<p>For example, in <em class="italic">Table 14.6</em>, the <strong class="source-inline">double</strong> primitive type is catered for with <strong class="source-inline">DoubleFunction&lt;R&gt;</strong>, <strong class="source-inline">DoubleToIntFunction</strong>, and <strong class="source-inline">DoubleToLongFunction</strong>. There are corresponding functional interfaces for <strong class="source-inline">int</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">long</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">int</strong> functional interfaces are <strong class="source-inline">IntFunction&lt;R&gt;</strong>, <strong class="source-inline">IntToDoubleFunction</strong>, and <strong class="source-inline">IntToLongFunction</strong>. These <strong class="source-inline">int</strong>-related functional interfaces do the same thing as their <strong class="source-inline">double</strong> counterparts (as outlined in <em class="italic">Table 14.6</em>), except the input is <strong class="source-inline">int</strong> and not <strong class="source-inline">double</strong>. The relevant functional method names will depend on the result type. For example, the functional method for <strong class="source-inline">IntToDoubleFunction</strong> will be <strong class="source-inline">double </strong><span class="No-Break"><strong class="source-inline">applyAsDouble(int value)</strong></span><span class="No-Break">.</span></p>
			<p>The same is true for the <strong class="source-inline">long</strong> primitive. The <strong class="source-inline">long</strong> functional interfaces are <strong class="source-inline">LongFunction&lt;R&gt;</strong>, <strong class="source-inline">LongToDoubleFunction</strong>, and <strong class="source-inline">LongToIntFunction</strong>. Their functional method names follow the same pattern as <strong class="source-inline">int</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
			<p>Let’s finish <a id="_idIndexMarker1158"/>our<a id="_idIndexMarker1159"/> discussion <a id="_idIndexMarker1160"/>on <a id="_idIndexMarker1161"/>functional interfaces by examining <strong class="source-inline">UnaryOperator</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">BinaryOperator</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor367"/>UnaryOperator and BinaryOperator</h2>
			<p>Both of these functional interfaces are specializations of other interfaces. Let’s discuss <span class="No-Break"><strong class="source-inline">UnaryOperator</strong></span><span class="No-Break"> first.</span></p>
			<h3>UnaryOperator</h3>
			<p>In the API, the <strong class="source-inline">Function</strong> functional<a id="_idIndexMarker1162"/> interface<a id="_idIndexMarker1163"/> is defined as <strong class="source-inline">Function&lt;T, R&gt;</strong>. <strong class="source-inline">T</strong> represents the input to the function and <strong class="source-inline">R</strong> represents the output from the function. The fact that the letters are different is important. This means that, while the types can of course be the same, they can also, and often <span class="No-Break">are, different.</span></p>
			<p><strong class="source-inline">UnaryOperator</strong> is a specialization of <strong class="source-inline">Function</strong> where both the input and output types are the same. In the API, <strong class="source-inline">UnaryOperator</strong> is defined as <strong class="source-inline">UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt;</strong> and its functional method is <strong class="source-inline">T </strong><span class="No-Break"><strong class="source-inline">apply(T t)</strong></span><span class="No-Break">.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.9</em> presents an example <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B19793_14_09.jpg" alt="Figure 14.9 – UnaryOperator in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – UnaryOperator in code</p>
			<p>In this figure, line 128 defines a <strong class="source-inline">UnaryOperator</strong> typed for <strong class="source-inline">String</strong>. This means that both the input and output are now strings. The <strong class="source-inline">name</strong> identifier is a <strong class="source-inline">String</strong> and we are just pre-pending <strong class="source-inline">"My name is "</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">.</span></p>
			<p>Line 130 executes the lambda by passing in <strong class="source-inline">"Sean"</strong>. The return <strong class="source-inline">String</strong> of <strong class="source-inline">"My name is Sean"</strong> is output to <span class="No-Break">the screen.</span></p>
			<p>Now, let’s <span class="No-Break">examine </span><span class="No-Break"><strong class="source-inline">BinaryOperator</strong></span><span class="No-Break">.</span></p>
			<h3>BinaryOperator</h3>
			<p>The <strong class="source-inline">BinaryOperator</strong> functional<a id="_idIndexMarker1164"/> interface<a id="_idIndexMarker1165"/> is to <strong class="source-inline">BiFunction</strong> what <strong class="source-inline">UnaryOperator</strong> is to <strong class="source-inline">Function</strong>. In other words, <strong class="source-inline">BiFunction</strong> allows us to specify two input parameters and an output result, all of which could be different types. <strong class="source-inline">BinaryOperator</strong>, which <strong class="source-inline">extends</strong> <strong class="source-inline">BiFunction</strong>, mandates that the two input types and the output type must be <span class="No-Break">the same.</span></p>
			<p>In the API, <strong class="source-inline">BinaryOperator</strong> is defined as <strong class="source-inline">BinaryOperator&lt;T&gt; extends BiFunction&lt;T, T, T&gt;</strong>, and its functional method is <strong class="source-inline">T apply(T t1, </strong><span class="No-Break"><strong class="source-inline">T t2)</strong></span><span class="No-Break">.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.10</em> presents an example <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B19793_14_10.jpg" alt="Figure 14.10 – BinaryOperator in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – BinaryOperator in code</p>
			<p>In this <a id="_idIndexMarker1166"/>figure, line 134 defines a <strong class="source-inline">BinaryOperator</strong> typed for <strong class="source-inline">String</strong>. This means that both the input parameters and the result are now<a id="_idIndexMarker1167"/> strings. The <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong> identifiers are strings and we are just returning the result of concatenating <strong class="source-inline">s2</strong> <span class="No-Break">onto </span><span class="No-Break"><strong class="source-inline">s1</strong></span><span class="No-Break">.</span></p>
			<p>Line 136 executes the lambda by passing in <strong class="source-inline">"William"</strong> and <strong class="source-inline">"Shakespeare"</strong>. The return <strong class="source-inline">String</strong> of <strong class="source-inline">"William Shakespeare"</strong> is output to <span class="No-Break">the screen.</span></p>
			<h1 id="_idParaDest-368"><a id="_idTextAnchor368"/>Mastering method references</h1>
			<p>Now, let’s move on to another important topic concerning lambda expressions, and that is method references. As concise as<a id="_idIndexMarker1168"/> lambdas are, in certain situations, they <a id="_idIndexMarker1169"/>can be even more concise! This is where method references apply. If all your lambda does is call one method, then this is an opportunity for a method reference. In addition, if a lambda parameter is simply passed to a method, then the redundancy of specifying the variable twice can also <span class="No-Break">be removed.</span></p>
			<p>Let’s look at <span class="No-Break">an example:</span></p>
			<pre class="source-code">
List&lt;String&gt; names = Arrays.asList("Maaike", "Sean");names.forEach(name -&gt; System.out.println(name); // lambda
names.forEach(System.out::println); // method reference</pre>
			<p>In this code, we declare a list of strings by invoking the <strong class="source-inline">Arrays.asList()</strong> method. The first <strong class="source-inline">forEach(Consumer)</strong> shows how to output the list using a lambda expression. Recall that the functional method of <strong class="source-inline">Consumer</strong> is <strong class="source-inline">void </strong><span class="No-Break"><strong class="source-inline">accept(T t)</strong></span><span class="No-Break">.</span></p>
			<p>The second <strong class="source-inline">forEach(Consumer)</strong> shows the method reference syntax. Note the double-colon operator, <strong class="source-inline">::</strong> (or method reference operator), and the fact that there are no round brackets, <strong class="source-inline">()</strong>, after the method name, as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">println</strong></span><span class="No-Break">.</span></p>
			<p>Keep in mind at all times that the code has to be generated at some point. If we have all the code specified, then the compiler has nothing to do. However, if we have availed of lambdas and/or method references, the compiler must step in and generate the omitted code. The compiler can only do so when it understands the <em class="italic">context</em>. This is crucial to making sense of method references given that there is so much code omitted. Moreover, the functional interface, with its functional method, is critical for <span class="No-Break">providing context.</span></p>
			<p>There are four different types of <span class="No-Break">method references:</span></p>
			<ul>
				<li><span class="No-Break">Bound</span></li>
				<li><span class="No-Break">Unbound</span></li>
				<li><span class="No-Break">Static</span></li>
				<li><span class="No-Break">Constructor</span></li>
			</ul>
			<p>These are best explained with examples in code. Regarding the examples, to make them easier to understand, we have coded both the lambda and method reference versions for each example. The lambda variables use the <strong class="source-inline">"L"</strong> suffix and the method reference variables use the <strong class="source-inline">"MR"</strong> suffix. In<a id="_idIndexMarker1170"/> addition, in <a id="_idIndexMarker1171"/>the comments, just before each example, are the signatures of the functional interfaces and their associated <span class="No-Break">functional methods.</span></p>
			<p>Now, let’s start with the first method reference type: bound <span class="No-Break">method references.</span></p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor369"/>Bound method references</h2>
			<p>Bound references <a id="_idIndexMarker1172"/>get their<a id="_idIndexMarker1173"/> name from the fact that the reference is bound to an instance of a particular object. A bound method reference is sometimes referred to as a “reference to an instance of a particular object.” Let’s use an example to explain this further. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.11</em> presents a bound method <span class="No-Break">reference example:</span></p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B19793_14_11.jpg" alt="Figure 14.11 – Bound method reference example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – Bound method reference example</p>
			<p>In this figure, line 21 declares a <strong class="source-inline">String</strong> variable called <strong class="source-inline">name</strong>, initialized to <strong class="source-inline">"Mr. Joe Bloggs"</strong>. Lines 22-23 outline the <strong class="source-inline">Supplier</strong> functional interface and the signature of its <a id="_idIndexMarker1174"/>functional method, <strong class="source-inline">T get()</strong>, in the<a id="_idIndexMarker1175"/> API. Line 24 declares a <strong class="source-inline">Supplier</strong> lambda that converts <strong class="source-inline">name</strong> into lowercase. This is the same <strong class="source-inline">name</strong> variable declared on line 21. Hence, this lambda is <em class="italic">bound</em> to the <strong class="source-inline">name</strong> variable at compile time. As the lambda is simply calling one method, this is an opportunity to introduce a <span class="No-Break">method reference.</span></p>
			<p>Given the lambda on line 24, line 25 outlines the equivalent method reference. Note the use of the <strong class="source-inline">name</strong> variable; the method reference operator <strong class="source-inline">::</strong> and the omission of the round brackets <strong class="source-inline">()</strong> after the method name. Also, note that <strong class="source-inline">name</strong> is a <strong class="source-inline">String</strong> and that the <strong class="source-inline">toLowerCase()</strong> method is a method in the <span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break"> class.</span></p>
			<p>Lines 28 and 29 execute the lambda and method reference versions, respectively, returning <strong class="source-inline">"mr. joe bloggs"</strong> on <span class="No-Break">both occasions.</span></p>
			<p>The first example in <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.11</em> is using the <strong class="source-inline">Supplier</strong> functional interface, which did not require an input parameter. What if we wanted to pass in a value? A <strong class="source-inline">Supplier</strong> functional interface will not work as its functional method is <strong class="source-inline">T get()</strong>, which does not accept parameters. However, a <strong class="source-inline">Predicate</strong> will work as its functional method, <strong class="source-inline">boolean test(T t)</strong>, does accept an input parameter. The second example in <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.11</em> shows this <span class="No-Break">in action.</span></p>
			<p>Line 37 is the lambda version. As <strong class="source-inline">Predicate</strong> is typed for <strong class="source-inline">String</strong>, <strong class="source-inline">title</strong> is a <strong class="source-inline">String</strong>. Again, we bind to <strong class="source-inline">name</strong> and execute the <strong class="source-inline">String</strong> method, <strong class="source-inline">startsWith()</strong>, passing in the input parameter. We can see the redundancy in the lambda given that <strong class="source-inline">title</strong> is mentioned twice. Couple this with the fact that the lambda is simply calling one method, we have another opportunity to introduce a <span class="No-Break">method reference.</span></p>
			<p>Line 38 is the method reference version of the lambda on line 37. This method reference requires a bit more explanation however because, in the <strong class="source-inline">String</strong> class, the <strong class="source-inline">startsWith()</strong> method is overloaded. The overloaded versions are <strong class="source-inline">boolean startsWith(String, int)</strong> and <strong class="source-inline">boolean startsWith(String)</strong>. How does the compiler decide which version of <strong class="source-inline">startsWith()</strong> to use? This is where context is important! We are defining a <strong class="source-inline">Predicate</strong> and the functional method for <strong class="source-inline">Predicate</strong> is <strong class="source-inline">boolean test(T t)  </strong>- given that this method accepts just one parameter, the compiler selects the <strong class="source-inline">startsWith()</strong> method with one parameter, namely <span class="No-Break"><strong class="source-inline">boolean startsWith(String)</strong></span><span class="No-Break">.</span></p>
			<p>Line 40 executes the lambda version, passing in <strong class="source-inline">"Mr."</strong> This results in the lambda executing <strong class="source-inline">"Mr. Joe Bloggs".startsWith("Mr.")</strong>, which <span class="No-Break">is true.</span></p>
			<p>Line 41 executes the method reference version, passing in <strong class="source-inline">"Ms."</strong>. As the compiler translates the<a id="_idIndexMarker1176"/> method <a id="_idIndexMarker1177"/>reference into a lambda in the background, this results in the lambda executing <strong class="source-inline">"Mr. Joe Bloggs".startsWith("Ms.")</strong>, which <span class="No-Break">is false.</span></p>
			<p>Now, we will examine unbound <span class="No-Break">method references.</span></p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor370"/>Unbound method references</h2>
			<p>Unbound <a id="_idIndexMarker1178"/>method references<a id="_idIndexMarker1179"/> do not bind to a variable. Instead, the instance to use is provided at runtime. An unbound method reference is sometimes referred to as a “reference to an instance of an arbitrary object of a particular type.” <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.12</em> present an example <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B19793_14_12.jpg" alt="Figure 14.12 – Unbound method reference example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – Unbound method reference example</p>
			<p>In this figure, we<a id="_idIndexMarker1180"/> define a<a id="_idIndexMarker1181"/> lambda on line 48. This lambda is of the <strong class="source-inline">Function&lt;String, String&gt;</strong> type, meaning that the functional method is <strong class="source-inline">String apply(String)</strong>. Thus, <strong class="source-inline">s</strong> is a <strong class="source-inline">String</strong> and we can invoke the <strong class="source-inline">String</strong> method, <strong class="source-inline">toUpperCase()</strong>. Note that <strong class="source-inline">s</strong> is not a variable from the method’s scope. In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.11</em>, we were bound to the <strong class="source-inline">name</strong> variable declared in the method. Now, however, <strong class="source-inline">s</strong> has the scope of the lambda expression only. This means that the method reference is <em class="italic">unbound</em>. The lambda parameter, <strong class="source-inline">s</strong>, will be bound to at runtime (when the <strong class="source-inline">apply()</strong> method is called), as on <span class="No-Break">line 51.</span></p>
			<p>As the lambda has just one method call and there is redundancy with <strong class="source-inline">s</strong> on both sides of the <strong class="source-inline">-&gt;</strong> token, we can use a method reference. Line 49 represents the method reference version of the lambda on line 48. Note the use of the method reference operator <strong class="source-inline">::</strong> and the absence of <strong class="source-inline">()</strong> after the method name, <strong class="source-inline">toLowerCase</strong>. As <strong class="source-inline">toLowerCase</strong> is a <strong class="source-inline">String</strong> method, <strong class="source-inline">String</strong> precedes the <strong class="source-inline">::</strong> operator in the method reference. The method reference on line 49 is semantically equivalent to the lambda on <span class="No-Break">line 48.</span></p>
			<p>Line 57 declares a <strong class="source-inline">BiFunction</strong> lambda. Recall that <strong class="source-inline">BiFunction</strong> takes in two inputs and returns a result. In this case, all are <strong class="source-inline">String</strong> types. The parameters that are passed in are concatenated and returned. Again, we have only one method call in the lambda and redundancy of variables, so we can code a <span class="No-Break">method reference.</span></p>
			<p>Line 58 represents the method reference version of the lambda on line 57. Again, context is going to be key in figuring out the method reference. <strong class="source-inline">BiFunction&lt;String, String, String&gt;</strong> and <strong class="source-inline">String::concat</strong> inform the compiler that this is an unbound method reference that will take in two <strong class="source-inline">String</strong> arguments and <span class="No-Break">concatenate them.</span></p>
			<p>There is one other bit of information implied here – the first argument provided in the <strong class="source-inline">apply()</strong> method call is the instance to be used for the <strong class="source-inline">concat()</strong> method; the second argument is to be passed into the <strong class="source-inline">concat()</strong> method as an argument. What this means is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
concatMR.apply("Orange", " Juice");</pre>			<p>This translates into <span class="No-Break">the following:</span></p>
			<pre class="source-code">
"Orange ".concat("Juice");</pre>			<p>This can <a id="_idIndexMarker1182"/>be seen<a id="_idIndexMarker1183"/> on lines 62 and 63. The execution of the method reference on line 63 translates into the code in comments on line 62. Both the lambda and method reference invocations (lines 59 and 63, respectively) result in <strong class="source-inline">"Sean Kennedy"</strong> <span class="No-Break">being returned.</span></p>
			<p>Now, let’s explore static <span class="No-Break">method references.</span></p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor371"/>Static method references</h2>
			<p>A <strong class="source-inline">static</strong> method <a id="_idIndexMarker1184"/>reference is <a id="_idIndexMarker1185"/>also considered unbound as we do not bind to a variable from the outer scope. The method being invoked is <strong class="source-inline">static</strong>, hence the name. Let’s examine a <strong class="source-inline">static</strong> method reference in code. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.13</em> shows such <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B19793_14_13.jpg" alt="Figure 14.13 – Static method reference example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – Static method reference example</p>
			<p>In this figure, we define a <strong class="source-inline">Consumer</strong> lambda (line 110) that takes in a <strong class="source-inline">List&lt;Integer&gt;</strong> list. As we know, <strong class="source-inline">Consumer</strong>s take in one argument and do not return anything. The side effect is to call the <strong class="source-inline">static</strong> <strong class="source-inline">Collections</strong> method, <strong class="source-inline">sort</strong>, passing in the list to be sorted. As our lambda has just one method call and we have redundancy (<strong class="source-inline">list</strong> on both sides of the <strong class="source-inline">-&gt;</strong> token), we can <a id="_idIndexMarker1186"/>re-write <a id="_idIndexMarker1187"/>the lambda even more concisely as a <span class="No-Break">method reference.</span></p>
			<p>Line 111 is the method reference version of the lambda that was coded on line 110. The <strong class="source-inline">Collections.sort()</strong> method is overloaded – one version is <strong class="source-inline">sort(List)</strong> and the other is <strong class="source-inline">sort(List, Comparator)</strong>. Context decides which one the compiler selects. As the <strong class="source-inline">Consumer</strong> lambda’s functional method is <strong class="source-inline">void accept(T t)</strong>, which takes just one parameter, the <strong class="source-inline">sort()</strong> with one parameter, namely <strong class="source-inline">sort(List)</strong>, <span class="No-Break">is used.</span></p>
			<p>Line 113 generates a <strong class="source-inline">List&lt;Integer&gt;</strong> using the <strong class="source-inline">Arrays.asList()</strong> method. Lines 114 and 115 execute and output the <span class="No-Break">lambda version.</span></p>
			<p>Line 117 re-generates a <strong class="source-inline">List&lt;Integer&gt;</strong>, again using the <strong class="source-inline">Arrays.asList()</strong> method. Lines 118 and 119 execute and output the method <span class="No-Break">reference version.</span></p>
			<p>Our last method reference type is constructor method references. Let’s discuss <span class="No-Break">them now.</span></p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor372"/>Constructor method references</h2>
			<p>Constructor method <a id="_idIndexMarker1188"/>references are a special type of method<a id="_idIndexMarker1189"/> reference in that, rather than calling a (regular) method, the <strong class="source-inline">new</strong> keyword is used and an object is instantiated. Suppliers are a natural fit for constructor method references. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.14</em> presents an example <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B19793_14_14.jpg" alt="Figure 14.14 – Constructor method reference example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.14 – Constructor method reference example</p>
			<p>In this figure, line 75 defines a <strong class="source-inline">Supplier&lt;StringBuilder&gt;</strong> lambda. The <strong class="source-inline">Supplier</strong> lambda’s functional method is <strong class="source-inline">T get()</strong>, so we do not pass anything in. As we typed <strong class="source-inline">sbL</strong> for <strong class="source-inline">StringBuilder</strong>, the lambda code is <strong class="source-inline">new StringBuilder()</strong>. As we have only one method invocation in the lambda, a method reference version can <span class="No-Break">be coded.</span></p>
			<p>The method reference on line 76 is the constructor method reference equivalent of the lambda defined on line 75. Note the use of the <strong class="source-inline">new</strong> keyword after the <strong class="source-inline">::</strong> operator in <span class="No-Break">the syntax.</span></p>
			<p>Lines 77 and 78 invoke the lambda and method references, respectively. In addition, the <strong class="source-inline">StringBuilder</strong> objects that were created are populated <span class="No-Break">and output.</span></p>
			<p>As stated already, <strong class="source-inline">Supplier</strong> is a perfect fit for constructor method references. But what if you wanted to pass an argument in? Suppliers do not accept parameters (<strong class="source-inline">T get()</strong>). We need a functional interface that will accept a parameter and return a result. <strong class="source-inline">Function</strong> will do nicely for this <span class="No-Break">use case.</span></p>
			<p>The second example in <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.14</em> presents a <strong class="source-inline">Function</strong>-based constructor method reference. The <strong class="source-inline">ArrayList</strong> constructor is overloaded – one of the versions accepts an <strong class="source-inline">int</strong> type, which is used to specify the <span class="No-Break">initial capacity.</span></p>
			<p>Line 84 defines a <strong class="source-inline">Function</strong>-based lambda, which accepts an <strong class="source-inline">Integer</strong> type and returns a <strong class="source-inline">List&lt;String&gt;</strong> list. The lambda takes an <strong class="source-inline">Integer</strong> type, <strong class="source-inline">x</strong>, and constructs an <strong class="source-inline">ArrayList</strong> with an initial capacity of <strong class="source-inline">x</strong>. The value of <strong class="source-inline">x</strong> will be obtained from the lambda invocation (for example, 100 on <span class="No-Break">line 86).</span></p>
			<p>As we have only one method call in the lambda and as <strong class="source-inline">x</strong> is replicated on both sides of the <strong class="source-inline">-&gt;</strong> token (redundancy), we can write an equivalent <span class="No-Break">method reference.</span></p>
			<p>Line 85 is the method reference equivalent of the lambda that was coded on line 84. <strong class="source-inline">ArrayList</strong> is specified to indicate which implementation of <strong class="source-inline">List</strong> we want to return. The <strong class="source-inline">::new</strong> syntax is unique to constructor method references. Line 89 shows how the method reference is executed – invoke the <strong class="source-inline">apply()</strong> method while passing in 200 in <span class="No-Break">this example.</span></p>
			<p>That concludes <a id="_idIndexMarker1190"/>our discussion<a id="_idIndexMarker1191"/> on the four different types of method references. However, before we leave method references, we would like to discuss an example outlining just how important context is when trying to understand <span class="No-Break">method references.</span></p>
			<h2 id="_idParaDest-373"><a id="_idTextAnchor373"/>Method references and context</h2>
			<p>This <a id="_idIndexMarker1192"/>example will present three lambdas with their corresponding method references. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.15</em> shows the <span class="No-Break">code example:</span></p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B19793_14_15.jpg" alt="Figure 14.15 – Method references and context"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.15 – Method references and context</p>
			<p>In this figure, lines 7-11 define a class called <strong class="source-inline">Person</strong>. Line 8 defines a <strong class="source-inline">static</strong> <strong class="source-inline">howMany()</strong> method<a id="_idIndexMarker1193"/> that returns the number of objects in the <strong class="source-inline">Person</strong> array. Recall that <strong class="source-inline">varargs</strong> is represented by <strong class="source-inline">…</strong> and within the method, it is treated as an array (hence the <strong class="source-inline">length</strong> property). Given that the <strong class="source-inline">people</strong> parameter is a <strong class="source-inline">varargs</strong> parameter, we can invoke <strong class="source-inline">howMany()</strong> with 0 or <span class="No-Break">more arguments.</span></p>
			<p>The first scenario is calling <strong class="source-inline">howMany()</strong> with no <strong class="source-inline">Person</strong> object at all and getting back the count of objects passed, which will be 0. <strong class="source-inline">Supplier</strong> fits nicely as we will not be passing anything into the lambda, but will be getting back an <strong class="source-inline">Integer</strong> result. Line 15 is the lambda for this scenario. We accept in nothing and return an <strong class="source-inline">Integer</strong> count, which is the count of the number of <strong class="source-inline">Person</strong> objects passed to <strong class="source-inline">howMany()</strong>. This is, of <span class="No-Break">course, </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<p>Line 16 is the method reference equivalent for the lambda on line 15. We will return to discuss <span class="No-Break">this shortly.</span></p>
			<p>The second <a id="_idIndexMarker1194"/>scenario is calling <strong class="source-inline">howMany()</strong> with one <strong class="source-inline">Person</strong> object and getting back the count of objects passed, which will be <strong class="source-inline">1</strong>. <strong class="source-inline">Function</strong> fits nicely as we will be passing in one <strong class="source-inline">Person</strong> object to the lambda and receiving the <strong class="source-inline">Integer</strong> count. Line 21 is the lambda for this scenario. We accept one <strong class="source-inline">Person</strong> and return an <strong class="source-inline">Integer</strong>, representing the number of <strong class="source-inline">Person</strong> objects passed to <strong class="source-inline">howMany()</strong>. This <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<p>Line 22 is the method reference equivalent for the lambda on line 21. Again, we will return to discuss <span class="No-Break">this shortly.</span></p>
			<p>The third scenario is calling <strong class="source-inline">howMany()</strong> with two <strong class="source-inline">Person</strong> objects and getting back the count of objects passed, which will be <strong class="source-inline">2</strong>. <strong class="source-inline">BiFunction</strong> fits nicely as we will be passing in two <strong class="source-inline">Person</strong> objects to the lambda and receiving the <strong class="source-inline">Integer</strong> count. Line 27 is the lambda for this scenario. We accept two <strong class="source-inline">Person</strong> objects and return an <strong class="source-inline">Integer</strong> representing the number of <strong class="source-inline">Person</strong> objects passed to <strong class="source-inline">howMany()</strong>. This <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p>Line 28 is the method reference equivalent for the lambda on <span class="No-Break">line 27.</span></p>
			<p>Now, let’s discuss the method references (lines 16, 22, and 28). Notice how they are all the same! Again, this is where context is key. The compiler can generate the relevant lambdas based on the functional interfaces and the generic types specified. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
Supplier&lt;Integer&gt; mr1 = Person::howMany;</pre>			<p>Firstly, as <strong class="source-inline">howMany()</strong> is a <strong class="source-inline">static</strong> method in <strong class="source-inline">Person</strong>, the compiler knows that the lambda will be <strong class="source-inline">Person.howMany()</strong>. But how many objects should be passed? As it is a <strong class="source-inline">Supplier</strong> interface, whose functional method is <strong class="source-inline">T get()</strong>, the compiler knows there will be no parameter input, so it knows to pass nothing to <strong class="source-inline">howMany()</strong>. Concerning what to return, <strong class="source-inline">Supplier</strong> is typed for <strong class="source-inline">Integer</strong>, which matches the return type <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">howMany()</strong></span><span class="No-Break">.</span></p>
			<p>What if we want to pass one object to <strong class="source-inline">howMany()</strong>? Let’s examine the second <span class="No-Break">method reference:</span></p>
			<pre class="source-code">
Function&lt;Person, Integer&gt; mr2     = Person::howMany;</pre>			<p>The<a id="_idIndexMarker1195"/> one difference here is that we are declaring a <strong class="source-inline">Function</strong> as opposed to the previous <strong class="source-inline">Supplier</strong>. <strong class="source-inline">Function</strong>s take in one parameter and return a result. We know <strong class="source-inline">Integer</strong> must be the return type, as that is the return type of <strong class="source-inline">howMany()</strong>. So, what the compiler does here is take the input and pass it to the <strong class="source-inline">howMany()</strong> method. The equivalent lambda (line 21) shows what is happening in <span class="No-Break">the background.</span></p>
			<p>Lastly, what if we want to pass in two objects to <strong class="source-inline">howMany()</strong>? The last method reference demonstrates how to <span class="No-Break">do this:</span></p>
			<pre class="source-code">
BiFunction&lt;Person, Person, Integer&gt; mr3     =  Person::howMany;</pre>
			<p>The compiler sees <strong class="source-inline">BiFunction</strong> and realizes that <strong class="source-inline">BiFunction</strong> requires two inputs, so it will pass the two inputs to <strong class="source-inline">howMany()</strong>. And of course, this particular <strong class="source-inline">BiFunction</strong> return type of <strong class="source-inline">Integer</strong> matches the return type of the <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">howMany()</strong></span><span class="No-Break">.</span></p>
			<p>So, we have three equivalent method references that map to three different lambdas because of the three different contexts. Method references can be tricky. Check the context and if possible, map the method reference to its equivalent lambda expression. Once in lambda form, it is easier <span class="No-Break">to interpret.</span></p>
			<p>That completes our discussion on method references and concludes <a href="B19793_14.xhtml#_idTextAnchor355"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>. Now, let’s put that knowledge into practice to reinforce the concepts <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-374"><a id="_idTextAnchor374"/>Exercises</h1>
			<ol>
				<li>Dinosaur care tasks are often very similar, but not identical. To make our code cleaner, we can use lambda expressions. Create a custom functional interface called <strong class="source-inline">DinosaurHandler</strong> with a method called <strong class="source-inline">handle(Dinosaur dinosaur)</strong>. Implement it in a lambda expression that sets a dinosaur to be asleep or awake (first, add a property to your <strong class="source-inline">Dinosaur</strong> class <span class="No-Break">if needed).</span></li>
				<li>Lambda expressions are extremely useful with the <strong class="source-inline">java.util.function</strong> interfaces. Let’s use them to <span class="No-Break">manage dinosaurs:</span><ul><li>Write a <strong class="source-inline">Predicate&lt;Dinosaur&gt;</strong> lambda that checks if a dinosaur is <span class="No-Break">a carnivore</span></li><li>Write a <strong class="source-inline">Supplier&lt;Dinosaur&gt;</strong> lambda that returns a <span class="No-Break">new dinosaur</span></li><li>Write a <strong class="source-inline">Consumer&lt;Dinosaur&gt;</strong> lambda that prints a <span class="No-Break">dinosaur’s name</span></li><li>Write a <strong class="source-inline">Function&lt;Dinosaur, String&gt;</strong> lambda that returns a <span class="No-Break">dinosaur’s diet</span></li></ul></li>
				<li>Lambda expressions have specific rules about variable usage. We’re going to create an example of a lambda expression that modifies an “effectively final” variable. Add a variable that tracks the number of dinosaurs and create a lambda expression that increases <span class="No-Break">this count.</span></li>
				<li>Method references can make our code more readable. Write examples of using method references in the context of <span class="No-Break">your park:</span><ul><li><strong class="bold">Bound instance method</strong>: Use <strong class="source-inline">System.out::println</strong> to print <span class="No-Break">dinosaur names.</span></li><li><strong class="bold">Unbound instance method</strong>: Use <strong class="source-inline">Dinosaur::getName</strong> (assume the <strong class="source-inline">Dinosaur</strong> class has a <strong class="source-inline">getName()</strong> method) to get the name of <span class="No-Break">each dinosaur.</span></li><li><strong class="bold">Static method</strong>: Use <strong class="source-inline">Collections::sort</strong> to sort a list of <span class="No-Break">dinosaur names.</span></li><li><strong class="bold">Constructor reference</strong>: Use <strong class="source-inline">Dinosaur::new</strong> to create a new dinosaur (assume the <strong class="source-inline">Dinosaur</strong> class has an <span class="No-Break">appropriate constructor)</span></li></ul></li>
			</ol>
			<h1 id="_idParaDest-375"><a id="_idTextAnchor375"/>Project – agile dinosaur care system</h1>
			<p>Our park is<a id="_idIndexMarker1196"/> growing, and so are the tasks that need to be accomplished. Lambda expressions can simplify our code and improve the efficiency of operations. Let’s integrate them into <span class="No-Break">our system!</span></p>
			<p>Incorporate lambda expressions into your “dinosaur care system” for sorting, filtering, and performing actions on collections of dinosaurs. Furthermore, design a notification system using method references to alert park staff about various events, enhancing communication and responsiveness within <span class="No-Break">our park.</span></p>
			<p>Here are the<a id="_idIndexMarker1197"/> steps. We assume certain methods exist. You’ll have to create those methods according to your <strong class="source-inline">Dinosaur</strong> <span class="No-Break">class’s design:</span></p>
			<ol>
				<li><strong class="bold">Set up your project</strong>: If you haven’t already done so in the previous chapter, create a new Java project in your IDE. Make sure you have a <strong class="source-inline">Dinosaur</strong> class defined with properties such as <strong class="source-inline">name</strong>, <strong class="source-inline">species</strong>, <strong class="source-inline">healthStatus</strong>, and so on. You’ll also want to have a <strong class="source-inline">DinosaurCareSystem</strong> class where the main functionalities of handling dinosaurs <span class="No-Break">are implemented.</span></li>
				<li> <strong class="bold">Incorporate lambda expressions</strong>: lambda expressions can be very handy when dealing with collections. Let’s incorporate them into <span class="No-Break">the system:</span><ul><li><strong class="bold">Sorting</strong>: Suppose you have a list of <strong class="source-inline">Dinosaur</strong> objects and you want to sort them by their name. Use the <strong class="source-inline">sort</strong> method of the <strong class="source-inline">List</strong> interface with a lambda expression. Here’s an example: <strong class="source-inline">dinosaurs.sort((d1, d2) &gt; </strong><span class="No-Break"><strong class="source-inline">d1.getName().compareTo(d2.getName()))</strong></span><span class="No-Break">.</span></li><li><strong class="bold">Filtering</strong>: To filter out dinosaurs that are ill, you could use the stream method with a filter and a lambda. Here’s an example: <strong class="source-inline">List&lt;Dinosaur&gt; illDinosaurs = dinosaurs.stream().filter(d &gt; </strong><span class="No-Break"><strong class="source-inline">d.isIll()).collect(Collectors.toList())</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><strong class="bold">Design a notification system using method references</strong>: Method references can simplify our code when the lambda expression is calling a method directly. In your <strong class="source-inline">DinosaurCareSystem</strong> class, create a method called <strong class="source-inline">sendNotification(String message)</strong>. Then in another method where you are checking dinosaur health status, for example, use a method reference to call <strong class="source-inline">sendNotification</strong> each time a dinosaur is found to be ill. The code may look something like this: <strong class="source-inline">dinosaurs.stream().filter(Dinosaur::isIll).forEach(d &gt; sendNotification(d.getName() + " </strong><span class="No-Break"><strong class="source-inline">is ill."))</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Perform actions on collections</strong>: lambda expressions are great for performing actions on collections. For instance, you may want to increase the health of <a id="_idIndexMarker1198"/>all healthy dinosaurs as part of a <strong class="source-inline">healthboosting</strong> program. With lambdas, you can do this directly on the list: <strong class="source-inline">dinosaurs.forEach(d &gt; </strong><span class="No-Break"><strong class="source-inline">d.increaseHealth(10))</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h1 id="_idParaDest-376"><a id="_idTextAnchor376"/>Summary</h1>
			<p>In this chapter, we learned that lambda expressions make your code more concise. We saw that a functional interface is an interface with just one <strong class="source-inline">abstract</strong> method. Lambda expressions are classes that implement functional interfaces with everything but the bare <span class="No-Break">minimum remaining.</span></p>
			<p>The terms <strong class="source-inline">final</strong> and “effectively final” refer to local variables used inside lambda expressions. Any non-<strong class="source-inline">final</strong> local variable used by a lambda must not change its value, either in the method or the lambda itself. The compiler enforces this, thus making the local variable “effectively final.” This is to ensure that the method’s view of the local variables value is consistent with the lambda’s view (of the local variable’s value). This does not apply to instance or <strong class="source-inline">static</strong> variables or local variables <em class="italic">not</em> used <span class="No-Break">inside lambdas.</span></p>
			<p>We took a deep dive into functional interfaces from the API. We examined predicates (which test a condition), such as <strong class="source-inline">Predicate&lt;T&gt;</strong> and <strong class="source-inline">BiPredicate&lt;T, U&gt;</strong>, plus their primitive consuming counterparts, <strong class="source-inline">DoublePredicate</strong>, <strong class="source-inline">IntPredicate</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">LongPredicate</strong></span><span class="No-Break">.</span></p>
			<p>We also examined <strong class="source-inline">Supplier&lt;T&gt;</strong> (which gives you something) and its primitive consuming specializations, which are <strong class="source-inline">BooleanSupplier</strong>, <strong class="source-inline">DoubleSupplier</strong>, <strong class="source-inline">IntSupplier</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">LongSupplier</strong></span><span class="No-Break">.</span></p>
			<p>We explored consumers (which take but do not give back), <strong class="source-inline">Consumer&lt;T&gt;</strong> and <strong class="source-inline">BiConsumer&lt;T, U&gt;</strong>, and their primitive consuming specializations, <strong class="source-inline">DoubleConsumer</strong>, <strong class="source-inline">IntConsumer</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">LongConsumer</strong></span><span class="No-Break">.</span></p>
			<p>We also looked at functions (which both take and give back), <strong class="source-inline">Function&lt;T, R&gt;</strong> and <strong class="source-inline">BiFunction&lt;T, U, R&gt;</strong>, and their primitive <span class="No-Break">consuming counterparts</span><span class="No-Break">.</span></p>
			<p>Lastly, we examined variations of functions. <strong class="source-inline">UnaryOperator&lt;T&gt;</strong> is a variation of <strong class="source-inline">Function</strong>, where both the input and output types are the same. Similarly, <strong class="source-inline">BinaryOperator&lt;T&gt;</strong> is a variation of <strong class="source-inline">BiFunction</strong>, where the two input types and the output type are all <span class="No-Break">the same.</span></p>
			<p>To make your code even more concise, in certain situations, you can use method references instead of lambda expressions. If your lambda is just invoking one method and there is redundancy concerning parameters, a method reference can <span class="No-Break">be written.</span></p>
			<p>There are four different types of method references: bound, unbound, static, and constructor. A bound method reference is bound to an existing variable in the method, outside of the lambda’s scope. An unbound method reference relies on the instance to be passed at runtime. A static method reference is also considered unbound and executes a <strong class="source-inline">static</strong> method. Lastly, a constructor method reference creates objects using the <strong class="source-inline">::</strong><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break"> syntax.</span></p>
			<p>We also had a look at the importance of context in understanding method references. We saw an example where the same method reference was generating three different lambdas (in the background) due to the three <span class="No-Break">different contexts.</span></p>
			<p>That completes our discussion on lambda expressions. They will be very important as we move on to our next two <span class="No-Break">Stream-related chapters.</span></p>
		</div>
	</body></html>