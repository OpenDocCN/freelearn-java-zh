- en: Chapter 2. JavaServer Faces Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"No two people on earth are alike, and it''s got to be that way in music
    or it isn''t music"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Billie Holiday* |'
  prefs: []
  type: TYPE_TB
- en: 'Java has been a complete success in the server side for a long time: since
    the year 2000\. Businesses have trusted the JVM, Java programming language, and
    abundance of frameworks as their platform of choice for enterprise software. So,
    are we correct in continuing to put our trust in the JVM as digital web engineers?
    I think the answer to that question, and because you are reading this book, is
    yes!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is an expansive overview of the **JavaServer Faces** (**JSF**)
    concepts. We will start with the history and purpose of JSF and how it relates
    to the fundamental design pattern: the **Model-View-Controller** (**MVC**). We
    will explore the life cycle concepts in JSF, which is one of the key concepts
    that separates it from the other Java web application frameworks. Moreover, we
    will examine some JSF code, including the nefarious concept of managed beans.
    We will also cover how a JSF application navigates between the POJOs and pages.
    To sweeten this, we will meander in the powerful expression language for page
    authors. By the time we finish the chapter, we will have built a solid foundation
    of knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JSF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF is a specification to build a web user interface from a component model.
    It encompasses a MVC and templating framework. JSF is a standard library of the
    Java EE platform. The **Java Community Process** (**JCP**) controls the specifications,
    and the current version is JSF 2.2, which is defined by **Java Specification Request**
    (**JSR**) 334 ([https://www.jcp.org/en/jsr/detail?id=344](https://www.jcp.org/en/jsr/detail?id=344)).
  prefs: []
  type: TYPE_NORMAL
- en: Originally, the promise behind JSF was to bring rapid user interface development
    to server-side Java. This statement was true when JSF was first conceived; but
    of course, it is still useful if you would rather not write a lot of JavaScript
    code and hand crafted boilerplate so as to handle the transformation of an HTTP
    request to the Java invocations and back-to-page responses. Web technology and,
    in particular, digital development has leaped off the web pages since JSF 1.0
    was conceived in 2004\. Back then, JavaScript was not taken as a programming language
    so seriously as it is now; there was no responsive web design and there was certainly
    less demand for mobile web programming. Nowadays, it is common to see terms such
    as mobile first or digital by default. This means that websites consider all sorts
    of screen sizes and devices and recognize that people can view the content on
    a smartphone or tablet. Some people (your target customers) do not have access
    to a desktop PC or laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Cameron Moll's pioneering—but now slightly dated—e-book on mobile web design
    ([http://mobilewebbook.com/](http://mobilewebbook.com/)). The UK government places
    great emphasis on the term, Digital by Default ([https://www.gov.uk/service-manual/digital-by-default](https://www.gov.uk/service-manual/digital-by-default)),
    which has been followed up by the expansive Default to Open term from the United
    States Digital Service ([https://playbook.cio.gov/](https://playbook.cio.gov/)).
  prefs: []
  type: TYPE_NORMAL
- en: JSF was conceived as a user interface technology that could allow even a Java
    engineer to build frontend in the same way as a JavaFX (or Swing) application.
    The idea was to allow the developers (not designers) to assemble an HTML page
    using a custom editor. The JSF applications were designed to be themed. The intention
    of the framework was to allow a render kit to produce different forms of output.
    A render kit might generate a PDF output, another type would generate an HTML
    output, and yet another would generate specific mobile content in the form of
    **Wireless Application Protocol** (**WAP**) (WAP was a technology that was afforded
    much attention before Apple produced the first iPhone in 2007). Technology has
    moved on in leaps and bounds!
  prefs: []
  type: TYPE_NORMAL
- en: Although there is much criticism of JSF as web technology to produce serious
    applications, it has the support of the Java EE platform. Facelets is a useful
    template framework to build sharable components and partial content for web pages.
    JSF has a lifecycle model that integrates into a POJO, and this means that it
    works seamlessly with the Context and Dependency Injection (CDI) beans. Moreover,
    JSF has been kept up to date with the changes taking place in the digital landscape.
    JSF 2.2 supports HTML5 friendly markup. It supports AJAX events and allows the
    events to be queued. It allows a W3C sanction ID attribute for all the elements
    for the HTML5 content. JSF 2.2 introduces Faces Flow, which adds the ability to
    take the user through the sets of screens, workflows, and wizards. Above all,
    JSF 2.2 (JSR 334) represents a commitment to continually support a standard component-based
    framework for the Java EE platform.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Mojarra 2.2**'
  prefs: []
  type: TYPE_NORMAL
- en: In order for JSF to become a standard of the Java EE platform, it requires a
    JSR and reference implementation. For JSF, the reference implementation project
    is called Mojarra. The software is open source and supported by the Oracle Corporation
    ([https://javaserverfaces.java.net/](https://javaserverfaces.java.net/)). The
    reference implementation is part of the GlassFish 4 application server.
  prefs: []
  type: TYPE_NORMAL
- en: JSF 1.0 and 2.0 history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of JSF was first discussed around 2001\. It was a part of the Sun
    Microsystems project called Project Rave and then announced as JSR 127\. The technology,
    although an improvement over the action-request-based framework of the era such
    as Apache Struts, was met with lukewarm fanfare in 2003 and 2004\. A maintenance
    version 1.1 was released in 2004, but only in 2006 did the JSF 1.2 specification
    become an official part of the umbrella specification: Java EE 5.'
  prefs: []
  type: TYPE_NORMAL
- en: By this time, however, the developer mindshare had already evolved into the
    AJAX techniques, partial applications, and non-JVM software such as Ruby and Ruby
    on Rails. JSF 1.2 was encumbered by the default templating technology of the platform,
    JavaServer Pages. JSP proved unsuitable for JSF because the life cycle of the
    interception of the requests and the generation of the responses were essentially
    incompatible. The search for alternatives led to the creation of Facelets, which
    were designed to work explicitly with JSF.
  prefs: []
  type: TYPE_NORMAL
- en: In 2009, Facelets became the default template solution in JSF 2.0 (JSR 314),
    which was also a part of Java EE 6\. JSF 2.0 added annotations for validation
    and conversion. JSF 2.0 defined a standard AJAX component life cycle and it also
    added improvements for graphical editors. JSF 2.0 introduced a resource handle
    for the web content, including images, JavaScript, and CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: Key JSF 2.2 features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The big ticket features of the JSF 2.2 specification are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides the support for the HTML5 friendly markup, which is a boon to web
    designers and interface developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Resource Library Contracts is a new system in JSF to build reusable themes
    through bundling the Facelet views, components, style sheets, and other resources
    including internationalization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides the new URI locators that are consistent with the Java EE 7 umbrella
    specification. The Oracle Corporation purchased Sun Microsystems in 2010, and
    so, the old URIs of the form [http://java.sun.com/jsf/core](http://java.sun.com/jsf/core)
    were transformed to [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core)
    reflecting the namespace of the JCP web domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faces Flows allow an application to be modeled as a directed graph of pages
    and views. With Faces Flows, we can build the basis of a workflow application
    in terms of the user interface. As a digital engineer, we can assemble a subdivision
    of the applications in a greater whole. These types of workflows lend themselves
    to the conversational scope of the CDI beans. You will learn more about flows
    in detail in [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows and Finesse"),
    *JSF Flows and Finesse*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless Views allow the developers to build the components that have no server-side
    state. Usually, the JSF components will save the state of the user interface component
    on either the server or the client, but sometimes a view does not require this
    extra resource, and thus, having a stateless view affords the scalability of the
    web application on servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It provides the ability to correctly handle the content of the browser from
    the client window: tab, browser window, pop-up dialog, or modal dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF 2.2 is backward compatible with Faces 2.1 and 2.0\. An application built
    against Faces 2.0 or 2.1 will not require changes in order to run with Faces 2.2;
    however, going the other way and using specific 2.2 features will not run in these
    older environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF is based on the following Java API specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaServer Pages 2.2 and JavaServer Pages Tag Library (JSTL) 1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Servlet 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java EE 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Beans 1.01
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why choose JSF over alternatives?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSF is the only Java web application framework that is certified as a JCP standard
    so far. Of course, there are alternatives; in fact, there may be as many as 100
    different Java web frameworks, and the majority of them will be open source. However,
    they will vary according to the vision, implementation, age of the code base,
    and who actually maintains it as a repository. It is no good for a business if
    the web framework that your application works against is built with yesterday's
    technology because the web is constantly evolving. Equally, the web framework
    has to evolve with the times or it will eventually become irrelevant. Businesses
    trust that JSF is a standard that has the guarantees that the technology will
    be supported for the long term.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, MVC (JSR 371) will be the other standard web application framework
    in Java EE 8\. You will learn about MVC in [Chapter 9](part0087.xhtml#aid-2IV0U1
    "Chapter 9. Java EE MVC Framework"), *Java EE MVC Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: It is perfectly understandable that an application architect may want to choose
    a web framework other than JSF for their business requirements. Apache Struts
    2, Spring MVC, and Apache Wicket are a few that I would mention in passing. Apache
    Struts 2 and Spring MVC are generally considered to be request-oriented frameworks.
    Apache Wicket is a component-oriented framework and a direct competitor to JSF.
    Apache Struts was one of the most famous web application frameworks in the early
    2000s and certainly the first to break the mold.
  prefs: []
  type: TYPE_NORMAL
- en: The world of web frameworks does not stop with Java. Most developers will have
    heard of Ruby on Rails, which is an off-JVM technology. A few engineers will know
    about the Play framework for both the Java and Scala developers, and then there
    are solutions based around the Groovy language such as Grails.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever framework you choose for a web application essentially dictates the
    Java-based frontend architecture for your developer. Whatever you do, my strong
    recommendation is not to invent your own web application framework. The strength
    of open source is the community of developers that is diverse with from thousands
    of different companies, endeavors, and cultures.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose JSF, then it is more than likely that you, as a customer, want
    to maintain your investment in the Java platform. The core strength of your JSF
    enterprise application is the rich components, and you rely on the model to add
    the default benefits such as easier validation, type conversion, and mapping of
    HTTP request parameters so as to bean the properties. Many experienced Java EE
    engineers will have experience in the JSF framework, so you will be in great company.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC design describes a set of design patterns that aim to separate the concerns
    of a user interface from the application logic that semantically binds them. The
    Model describes the business logic. The View denotes the presentation—the abstract
    surface that the user senses and also interacts with. The Controller denotes the
    component that handles the interaction between the model and view. The original
    idea of MVC stemmed from Trygve Reenskaug, who introduced the concept in the Smalltalk
    programming language during the 1970s. The pattern was subsequently implemented
    and popularized in the Smalltalk-80 before it was adopted in the wider software
    engineering community. MVC is famous for its ideas about the division of labor
    and the separation of responsibilities between the components.
  prefs: []
  type: TYPE_NORMAL
- en: We call it MVC patterns because the plural term describes a set of related derivatives
    of the classic pattern as group patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern has subsequently evolved, giving rise to variants such as the
    **Hierarchical model–view–controller** (**HMVC**), **Model-view-presenter** (**MVP**),
    **Model View ViewModel** (**MVVM**), and others that adapted MVC to different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: MVC in JSF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does the MVC map to JSF? This has been answered in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: In JSF and Java EE, the model is the component or a set of components
    that handles the business data and logic. The model is either a CDI bean, EJB,
    or some other component that is compatible with the life cycle of the web container
    and the JSF framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: A lot of the responsibility of the controller logic in the
    classic design pattern is taken care of by the framework. In JSF, one can consider
    the start of the controller as FacesServlet, which is responsible for dispatching
    the incoming HTTP request to the correct managed bean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: In JSF, the view is the rendering group that contains the UI components
    and their respective beans. Usually, the view is described in a page description
    language, for which JSF 2.0 is Facelets. The render kit of JSF composes the UI
    components and beans in a full page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the MVC patterns in a perspective of the
    JSF framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVC in JSF](img/image00374.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Model View Controller pattern is terms of JSF framework
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSF specification defines a **View Declaration Language** (**VDL**) to render
    the output of the pages. In JSF 1.0, this was JavaServer Pages; but in JSF 2.0,
    the VDL was changed to Facelets by default. Facelets are the default view handler
    for JSF 2.0 and are defined as XHTML files.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets can be used in a templating situation. A Facelets file can reference
    a master template as a composition, and the view can provide the content that
    will look like a cookie cutter being supplied to the template. A Facelet that
    utilizes a reference template is known as a template client. The placeholder content
    in the template client will override the default content in the master template.
    In this way, Facelets can be reused in order to share the content. The template
    clients may become master templates and thus, a hierarchy of views can be derived.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets also provide reuse by the custom tags. It is possible for engineers
    to write their own custom tags through the XHTML files and metadata. The designer
    and developer will provide the content through a tag library descriptor file.
  prefs: []
  type: TYPE_NORMAL
- en: The final option to template that Facelets provide is the Composite Component
    Composition. This mechanism allows a composition to be reused in the other Facelet
    views so that they appear like first-class components. The template files, however,
    must be created in a special directory in order to allow the internal composition
    handler to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: The request processing lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF has a request-response processing lifecycle that is built around the HTTP
    protocol. JSF is built on top of the Java Servlet specification that takes care
    of translating the request user agent, which in the majority of the cases, is
    a web browser to a known endpoint. For JSF, the first port of call is `javax.faces.webapp.FacesServlet`.
    This servlet will simply dispatch the incoming request to the controller, and
    this component can elect to generate a response or delegate the output to the
    internal JSF controller implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There are three circumstances for JSF in the request processing lifecycle. The
    first is the invocation to the JSF controller with a Faces request, which ultimately
    generates a Faces response.
  prefs: []
  type: TYPE_NORMAL
- en: The second is a request to retrieve a resource such as a CSS or JavaScript file
    or image or some other media file. However, a Faces resource request, which does
    not require the execution of logic, causes the JSF framework to furnish the output
    as a Faces resource response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last one is a page request to retrieve the content that has nothing to
    do with JSF, and this is called a Non-Faces request and subsequently derives a
    Non-Faces response. An HTTP request to a JAX-RS service endpoint is an example
    of a Non-Faces request and response. Let''s have a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The request processing lifecycle](img/image00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: JSF request and response processing
  prefs: []
  type: TYPE_NORMAL
- en: The JSF framework first determines if the incoming request is for a resource.
    If it is, then the framework serves up the resource and sends the bytes, content
    type, and data to the user agent.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting work happens when the incoming request is treated as a Face
    request; the JSF framework handles this processing in a linear workflow. This
    process is known as the execute and render lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: The execute and render lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the JSF lifecycle to process a Faces request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The execute and render lifecycle](img/image00376.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The execute and render lifecycle phases inside the JSF framework
  prefs: []
  type: TYPE_NORMAL
- en: The standard request processing lifecycle starts with a Faces request stimulus
    to the **Restore View** stage. JSF maintains a `javax.faces.context.FacesContext`
    instance for the lifecycle. This object instance contains all of the information
    that is associated with a single Faces request. FacesContext is passed along to
    the various stages.
  prefs: []
  type: TYPE_NORMAL
- en: Restore View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Restore View is a phase of the lifecycle where the JSF framework ensures that
    the tree of the components and their states match the form when the view was originally
    generated at the response. In other words, JSF has to rebuild the view accurately
    before it can start inserting the changes and apply the form property values from
    the Faces request. The reason for this phase to exist is that the state of the
    overall input can change dynamically between requests. What follows is the technical
    depth description.
  prefs: []
  type: TYPE_NORMAL
- en: Restore View determines if the request is a postback or an initial request according
    to the algorithm. Every view in JSF has its unique identifier, `viewId`, and this
    is usually stored in a map collection internally in the framework's implementation.
    The framework calls the `initView()` method on the `javax.faces.application.ViewHandler`
    instance, which is associated with the view. Restore View constructs or retrieves
    the view so as to display to the user agent.
  prefs: []
  type: TYPE_NORMAL
- en: If the view already exists, then the request is a postback. JSF will then restore
    the view with `viewId` using the previously saved state. The state can be stored
    on the server or client. This behavior is configured from the Web XML deployment
    behavior for the application.
  prefs: []
  type: TYPE_NORMAL
- en: For an entirely new view, JSF creates a new instance of the type `javax.faces.component.UIViewRoot`,
    which is initially empty and sets the associated properties on it, such as the
    locale and character set. JSF then populates the view with the UI components in
    a tree data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Apply Request Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the component tree is restored, JSF maps the request information parameters
    to the component properties. The framework iterates over the component objects
    in the tree. Each component retrieves the data from the request object, which
    are usually the request parameters but can be cookies, session attributes, or
    even header parameters. Hence, the new values are stored with the UI component
    locally. The values are extracted from the request information, and at this phase,
    the values are still strings. This stage is called the Apply Request Values phase.
  prefs: []
  type: TYPE_NORMAL
- en: During this stage, JSF will attempt to apply conversion on the component properties
    where it is appropriate. If the conversion or validation fails, then the error
    message is queued on FacesContext.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Apply Request Values phase adds events to an internal JSF event queue when
    a command button or link is clicked on. JSF has certain special conditions in
    which an event handler is allowed to break the linear flow of processing and skip
    to the final stage: Render Response.'
  prefs: []
  type: TYPE_NORMAL
- en: Process Validations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Process Validation phase is the stage where the submitted string values,
    which are stored with the component, are converted to local values. These local
    values can be Java objects of any type. It is in this phase that the validators
    that are associated with the component can verify the value of the local values.
    If the validation passes and all the required validators are invoked successfully,
    then the JSF life cycle continues to the next phase. If the validation fails or
    there have been conversion errors from the previous lifecycle phase—the Apply
    Request Values phase—then the JSF framework skips directly to the Render Response
    phase. The web user then has a chance to enter the correct data in, say, an HTML
    input form.
  prefs: []
  type: TYPE_NORMAL
- en: As a JSF developer, it is up to you to attach validators to the UI components
    with inputs, which are important to check.
  prefs: []
  type: TYPE_NORMAL
- en: Update Model Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the conversion and validation phases, JSF enters the Update Model Values
    stage. At this point, the local values are considered as safe so as to update
    the model. Remember that in JSF versus MVC parlance, the model is likely to be
    your managed backing bean, CDI bean, or an EJB or aggregate object. JSF updates
    the beans that are referenced by the component.
  prefs: []
  type: TYPE_NORMAL
- en: Invoke Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the life cycle, we arrive at the phase where the model has been updated,
    and conversion and validation has been applied. JSF calls this the Invoke Application
    phase, and here, finally, business logic is invoked. JSF calls the method that
    is named by the action method of the command button or link component. The Invoke
    Application phase is a result of the user submitting an HTML form or invoking
    a navigation anchor link, so the JSF framework executes the corresponding method
    of the backing bean.
  prefs: []
  type: TYPE_NORMAL
- en: The method may elect to return a simple outcome string. Since JSF 2.0, methods
    are allowed to return a simple string that refers to the view by its name. Alternatively,
    the method may build its own response programmatically using the FacesContext
    instance or may return the navigation view ID that is passed to a navigation handler,
    which in turn looks up the next page.
  prefs: []
  type: TYPE_NORMAL
- en: Render Response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last phase in the lifecycle is the Render Response phase. This stage has
    the requirement to encode the Faces response and the JSF framework sends this
    output to the requesting user agent, which is usually a web browser. As soon as
    the data is sent down the network to the client, the life cycle is complete for
    the request and response. A new lifecycle begins on the next request.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Between certain phases, you will have noticed the Process Event stages. JSF
    allows the listeners to be registered against the framework in order to observe
    events. These are called Phase Listeners. They are special because they can be
    active in behavior and cause the lifecycle to skip or they can be passive in behavior
    to just monitor some aspects of the user interface that is interesting to the
    application. These mini-extension points are quite useful and powerful for application
    builders and thus are a major differentiator between JSF and the other web frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: A basic JSF example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered just enough theory on the JSF framework. I think it is time
    for my readers to see some code. The first code is the XHTML file to display a
    basic web page on a site. The source code is available on the book's website in
    the author's public GitHub account at [http://github.com/peter_pilgrim/digital_javaee7](http://github.com/peter_pilgrim/digital_javaee7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the XHTML source code for the initial Facelets view, and the file is
    called `index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is worth reminding you that this file is not an HTML5 document; although
    JSF 2.2 can cope with the document grammar, we must walk before we can run. XHTML
    is a format of HTML that uses an XML schema namespace to add additional tags.
    Hence, there are JSF-specific namespaces for HTML, UI, and F. See further onward
    for a description of these namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:head>`, `<h:body>`, and `<h:form>` custom tags resemble the standard
    HTML element tags that everyone knows about in web development. This is because
    they are designed to reflect this purpose deliberately. In fact, these are the
    JSF customs tags that add the functionalities and in the end, render the equivalent
    HTML element output.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably wondering that what an earth is a `<h:link>` element. This
    is simply JSF's way of rendering an HTML anchor tag. The outcome tag attribute
    references another XHTML directly, and after JSF 2.0, developers are allowed to
    write this in code.
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:commandButton>` tag is an example of a JSF form button that ultimately
    renders an HTML submit element tag. This tag accepts an action attribute that
    refers to a special string. The string is an example of the expression language;
    it references a method name of a bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the JSF managed bean, `BasicFlow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`BasicFlow` is a CDI bean with the request scope life cycle as declared by
    the `@javax.enterprise.context.RequestScoped` annotation. The bean is created
    by the CDI framework at the beginning of the servlet request lifecycle and is
    finished and left for the garbage collection once the servlet response is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.2, we will use the `@javax.inject.Named` annotation to specify the
    bean that is available to the JSF framework. We can explicitly write the annotation
    as `@Named("basicFlow")`, but the default is the camel case identifier of the
    simple class name. We recommend that a digital developer should not use the older
    `@javax.faces.bean.ManagedBean` annotation as it is now targeted for deprecation
    in a future JSF specification.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that your POJOs are actually CDI beans. Confusion can abound with
    JSF if you are using the wrong import for JSF. At deployment time, you will be
    unable to inject or find the backing bean in an expression like `#{basicFlow.serveResponse}`.
    Check that you are importing `javax.enterprise.context.RequestScoped` and not
    importing the deprecated `javax.faces.bean.RequestScoped` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `#{basicFlow.serveResponse}` string is an example of the **Expression Language**
    (**EL**), which is a mechanism for the page content to communicate with the backing
    beans while maintaining a separation of concerns. The first `BasicFlow` element
    refers to the backing bean instance and the second `serverResponse` element refers
    to the `serveResponse()` method. So, this is an EL expression that references
    the backing bean method. We will learn a lot more about expression languages later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the response is a simple string, which is the next VDL file:
    `endState.xhtml`. Strictly speaking, the suffix can be left off and the JSF framework
    will determine the correct view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `endState.xhtml` Facelet view file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a JSF view that allows the user to go back to the start view with an
    `<h:link>` element.
  prefs: []
  type: TYPE_NORMAL
- en: A web deployment descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to get the best out of the JSF framework, we recommend configuring
    a web application deployment descriptor. This file is a special XML document that
    declaratively describes the entry servlet endpoints, servlet mapping, and other
    environment resources. The code for the XML file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file has the `WEB-INF/web.xml` path. In order to activate the
    JSF framework, the deployment descriptor declares the servlet with a fully qualified
    class name; `javax.faces.webapp.FacesServlet`. Note that the servlet is mapped
    to serve the `*.xhtml` files.
  prefs: []
  type: TYPE_NORMAL
- en: We will define the active phase of the current project with the context parameter
    `javax.faces.PROJECT_STAGE` and an appropriate value. In the preceding example,
    the stage is set to `Development` but after the application goes live, then we
    might want to switch the value to `Production`. Switching to `Production` improves
    the performance and disables some of the debugging output.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the deployment descriptor in the book's source code as part of
    the project `ch02/jsf-compositions`. Once you add the project to an IDE—say, IntelliJ,
    Eclipse, or NetBeans—you can view the output from the application server at the
    URL `http://localhost:8080/jsf-compositions-1.0-SNAPSHOT/`.
  prefs: []
  type: TYPE_NORMAL
- en: JSF XML namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a table describing the common JSF and related namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | [http://xmlns.jcp.org/jsf/html](http://xmlns.jcp.org/jsf/html)This
    defines the standard tag JSF library for the HTML renderers and components such
    as `h:link`, `h:commandButton`, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core)This
    defines the standard tag JSF library for the core functionality that is independent
    of any render kit. This library includes the tags to handle the validation and
    conversion. |'
  prefs: []
  type: TYPE_TB
- en: '| `ui` | [http://xmlns.jcp.org/jsf/facelet](http://xmlns.jcp.org/jsf/facelet)This
    defines the standard tag JSF library to template the support including the composition
    of the views. |'
  prefs: []
  type: TYPE_TB
- en: '| `cc` | [http://xmlns.jcp.org/jsf/composite](http://xmlns.jcp.org/jsf/composite)This
    defines the standard `tag` library to build the composite components. |'
  prefs: []
  type: TYPE_TB
- en: '| `jsf` | [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf)This defines
    the tags to support HTML5 friendly output. |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough)This
    defines the tags to support the HTML5 friendly output with the pass-through `tag`
    attributes. |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | [http://xmlns.jcp.org/jsp/jstl/core](http://xmlns.jcp.org/jsp/jstl/core)This
    defines the JSTL 1.2 tag library for the JSP core behaviors. These tags include
    `<c:forEach>`, `<c:if>`, `<c:choose>`, and `<c:catch>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `fn` | [http://xmlns.jcp.org/jsp/jstl/ficmtion](http://xmlns.jcp.org/jsp/jstl/ficmtion)This
    defines the JSTL 1.2 tag library for the JSP functions. These tags include `<fn:upperCase>`,
    `<fn:length>`, and `<fn:contains>`. |'
  prefs: []
  type: TYPE_TB
- en: An abbreviated name such as `fn` must be added to the root XML document element,
    which in the majority of cases is an HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: A Composition example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s delve into some code to demonstrate the JSF composition before we close
    this chapter. We will start with a simple JSF template that lies out a web page
    in two areas: a top area and the main area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `template-top.xhtml` file is the JSF view that performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the template master. So far so good. This resembles a
    standard web page with HTML elements and we can see that the page uses the nested
    DIV elements to structure the content. I will draw your attention to the `<h:outputStylesheet>`
    tag, which denotes that we should include a couple of cascading style sheets as
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `ui:insert` tag is the composition JSF tag that denotes an area of the template
    that will be replaced by a placeholder in a client template. An insertion placeholder
    must have a name and we have two in this example, namely top and content. Note
    that the `ui:insert` tags are inserted in the body content of the HTML `div` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the client template as `composition1.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The key annotation in this file is the `<ui:composition>` JSF custom tag that
    references the master template that is being used. The template attribute refers
    the path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The two `<ui:define>` tags define the name placeholders with the content that
    substitutes for the default content in the master template. In this example, the
    placeholders are top and content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the screenshots of this process. The first screenshot is the initial
    Facelets view, `index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Composition example](img/image00377.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second is the second Facelets view, `endState.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Composition example](img/image00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: JSF serving resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSF expects our web resources to be placed in the `resources` folder by default.
    A quick look at the following file directory will help you understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/resources`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/resources/images`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/resources/javascripts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/resources/styles`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/WEB-INF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/WEB-INF/classes`'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsf-composition/src/main/webapp/WEB-INF/lib`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this simplified view of the Gradle project, we can see the folders, images,
    JavaScript, and CSS files that are placed under the `resource` folder. Let''s
    remind ourselves of the JSF view code again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These tags are essentially referring to two files: `resources/style/top.css`
    and `resources/style/main.css`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for these tags to work, the resource must be placed under the resources
    folder or it can be placed in the `META-INF/resources` folder of a web application
    JAR file that is deployed with the web application. The specification lists the
    following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<ROOT>` is the project web root, `<DEPENDANT-JAR>` is a third-party dependent
    JAR, and `<RES-ID>` is the resource identifier.
  prefs: []
  type: TYPE_NORMAL
- en: '`<RES-ID>` can be further broken up into formal parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The term parts inside `[]` are optional except for the resource name. It is
    therefore possible to have a resource identifier that is completely internationalized,
    versioned, and modularized in a library. Perhaps your project might utilize the
    following resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if you want to buck the trend and change the default location
    for the resources in JSF 2.2? It is possible to configure an alternative folder
    in the `web.xml` deployment descriptor file. You can set a context parameter variable:
    `javax.faces.WEBAPP_RESOURCES_DIRECTORY`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an extract of the descriptor that defines the resources folder as asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will cover the full extent of the JSF custom tags and how to submit the HTML
    forms in [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Building JSF Forms"),
    *Building JSF Forms* and [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF
    Validation and AJAX"), *JSF Validation and AJAX*.
  prefs: []
  type: TYPE_NORMAL
- en: Expression language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This would work as a read-only value. However, it is not possible to apply the
    value to the employee bean using JSF because the expression is not evaluated in
    any life cycle state.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the expression from an immediate to a deferred form, then we will
    see the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the EL is evaluated immediately during the Render Response
    phase of the lifecycle. The JSF implementation performs the evaluation and retrieves
    the value of the `firstName` property from the bean called employee.
  prefs: []
  type: TYPE_NORMAL
- en: When the form is posted back to the server as a Faces request, which by the
    way is also known as a `postback` event, the JSF implementation has a chance to
    retrieve the value at a deferred time. It is at these later life cycle states—Apply
    Request Values, Process Validation, and Update Model—that the value expression
    is evaluated and the value from the Faces request is injected into the target
    bean property.
  prefs: []
  type: TYPE_NORMAL
- en: Value expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A value expression is one that returns a single result. The value is retrieved
    from the object graph in the implementation that manages the collections of the
    Java instances. For Java EE, this is either JSF or JSP provider, and for application
    servers, it is a Context and Dependency Injection provider. CDI maintains a set
    of collections internally of the `@javax.inject.Named` beans. (Please wait for
    the explanation of the named beans or head straight for [Chapter 3](part0035.xhtml#aid-11C3M2
    "Chapter 3. Building JSF Forms"), *Building JSF Forms*.) In particular, JSF traditionally
    keeps a record of the managed beans annotated with `@javax.faces.bean.ManagedBean`.
  prefs: []
  type: TYPE_NORMAL
- en: JSP will search for the named object in the page scope, request scope, session
    scope, and then the application scope of the servlet container. Behind the scenes,
    there is a subclass of the abstract class `javax.el.ELResolver`, which is responsible
    for evaluation. This class has useful methods, such as `getValue()`, `setValue()`,
    `isReadOnly()`, and `invoke()` that developers can use to add evaluation to their
    own applications programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the first port of call of value expressions is the object instance
    with an identified name. This is known as the initial term. Afterwards, the evaluation
    logic can traverse through the object graph through a named property using the
    dot-notation (`.`). The evaluation continues through the subsequent terms in the
    expression. Let's stick with JSF for the moment and consider that the `#{employee.firstName}`
    expression will evaluate a deferred search for the object named employee in the
    scope. The EL resolver will then look up the property in the bean named `firstName`,
    which in turn will be a call to the `getFirstName()` method. The job will be completed
    and the EL resolver returns the result value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: EL also works with Java Collections. In particular, the `java.util.Map` collections
    are treated specially. A standard EL assumes that the collection has a key of
    a String type we can think of this as `Map<String,Object>`. The entries in Map
    may be accessed using the dot notation or square bracket notation `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table of value expressions will make this scheme clear for more
    complex expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | This finds the initial term associated with the name `employee`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `employee.firstName` | This resolves the named instance and invokes `getFirstName()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `employee.department.name` | This resolves the object, invokes `getFirstName()`,
    retrieves the next object, and invokes `getName()` on this object |'
  prefs: []
  type: TYPE_TB
- en: '| `employee["firstName"]` | This is equivalent to the dot notation `employee.firstName`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `employee[''firstName'']` | This is equivalent to the dot notation `employee.firstName`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `capitalCities[''Brazil'']` | This finds the name instance and, assuming
    that `capitalCities` is a type of `java.util.Map`, retrieves the value with the
    key `Brazil` |'
  prefs: []
  type: TYPE_TB
- en: '| `capitalCities["Brazil"]` | This is a map expression equivalent to the previous
    |'
  prefs: []
  type: TYPE_TB
- en: 'The square bracket notation `[]` is very useful with the string that contains
    dashes and/or a period character. This notation helps when you want to extract
    a message from a resource bundle for internationalization purposes. You can write
    a value expression as: `appMessages["registeredTraveller.applicant.firstName.required"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The square bracket notation allows us to write peculiar expressions. We can
    write the following value expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following equivalent Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Map expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The EL handles the Map objects seamlessly with the square bracket notation
    `[]`. If the expression evaluates to a reference that accesses or reads the value
    associated with Map key on the right-hand-side (an `rvalue`), then the EL resolver
    translates to a `Map.get("key")` call. The following are the expressions to read
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the expression is bound to the left-hand side (an `lvalue`), then the EL
    resolver translates to `Map.put("key", newValue)`.
  prefs: []
  type: TYPE_NORMAL
- en: List expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EL can retrieve objects from an index array with the square bracket notation.
    It works exactly like a Map expression except that the key must evaluate to a
    literal integer. In EL, the array index number starts at zero, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, these following value expressions are valid if `departmentList` is a type
    of `java.util.List` and `departmentArray` is a primitive array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the equivalent pseudo Java statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Resolving the initial term
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EL relies on the ability to look up the initial term from the servlet container,
    JSF list of the managed beans, and CDI scopes with the named beans. Essentially,
    you can give a JSF bean any name that you want, except you should avoid predefined
    objects. The initial term is the first part of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the servlet container, you can refer to several predefined objects. As an
    example, `requestScope` is a map collection of all the request scope attributes
    on a page. The request is also a predefined object in the EL that represents the
    `javax.servlet.http.HttpServletRequest` instance that is passed to the JSF view.
    We can use this to retrieve the web application context path in an `lvalue` expression,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is extremely helpful to ensure that the resources can be
    found in a JSF application. It is used to create reliable relative URLs. We will
    explain more in [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation
    and AJAX"), *JSF Validation and AJAX*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolution of the initial term begins by checking whether the initial term
    in the expression is a predefined object or not. If it is a predefined object,
    then the resolver continues this object. If it is not, then the JSF implementation
    searches for the object name in one of the servlet container scopes in this order:
    `requestScope`, `sessionScope`, or `applicationScope`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the object is not found by name, the JSF 2.2 framework will delegate to `ELResolver`,
    which will search for the equivalent CDI scopes for the instance and will then
    look at the registered or annotated managed beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the predefined object instances in the expression
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Predefined Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `applicationScope` | This is a Map collection of the application scope attributes
    (`javax.servlet.ServletContext.getAttributes()`) |'
  prefs: []
  type: TYPE_TB
- en: '| `application` | This refers to the `ServletContext` instance |'
  prefs: []
  type: TYPE_TB
- en: '| `cookie` | This is a Map collection of the cookie names and values |'
  prefs: []
  type: TYPE_TB
- en: '| `facesContext` | This is the `javax.faces.context.FacesContext` instance
    of this page and life cycle |'
  prefs: []
  type: TYPE_TB
- en: '| `header` | This is a Map collection of the HTTP header parameters that only
    yield the first elements of the multiple values |'
  prefs: []
  type: TYPE_TB
- en: '| `headerValues` | This is a Map collection of the HTTP header parameters yielding
    a `String[]` array of values |'
  prefs: []
  type: TYPE_TB
- en: '| `initParam` | This is a Map collection of the web application initialization
    parameters |'
  prefs: []
  type: TYPE_TB
- en: '| `param` | This is a Map collection of the HTTP request parameters with only
    the first element in any array of values |'
  prefs: []
  type: TYPE_TB
- en: '| `paramValue` | This is a Map collection of the HTTP request parameters yielding
    a `String[]` array of values |'
  prefs: []
  type: TYPE_TB
- en: '| `requestScope` | This is a Map collecction of the request scope attributes
    (`HttpServletRequest.getAttributes()`) |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | This refers to the `HttpServletRequest` instance |'
  prefs: []
  type: TYPE_TB
- en: '| `sessionScope` | This is a Map collection of the session scope attributes
    (`HttpSession.getAttributes()`) |'
  prefs: []
  type: TYPE_TB
- en: '| `session` | This refers to the `HttpSession` instance |'
  prefs: []
  type: TYPE_TB
- en: '| `View` | This is the `javax.faces.component.UIViewRoot` instance of the page
    |'
  prefs: []
  type: TYPE_TB
- en: Let's move on to method expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Method expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EL also permits the association to a method on an object instance. This type
    of reference is called a method binding expression. The JSF framework permits
    method expressions to reference the action methods, validators, converters, and
    phase listeners. A method expression invokes a method on a named object instance
    and then returns the results, if any.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of a method expression is an action handler on a managed bean,
    which you already witnessed in the basic JSF example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `#{basicFlow.serverResponse}` expression is a method binding that refers
    to the controller, the CDI bean named `BasicFlow`, and the `serveResponse()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized method expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: EL also supports method invocation with parameters. The parameters can be literal
    constants. They can also be names of the terms in the scope of the page. This
    provides a very powerful way to build applications with the list collections and
    other complicated data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the expression that uses the method parameters code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `process()` method is invoked on the object instance that is resolved with
    the `complexFlow` initial term. The first parameter is a literal string. The second
    parameter is the value of the `subterm`, `productLine`, which we will assume is
    available to the EL resolver.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to get the size of the collection by definition because
    this is a no-arguments call. This expression looks like `#{genericSearchResult.size()}`,
    assuming that the initial term references a type of `java.util.Collection` or
    `java.util.Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use arithmetic operators to perform calculations in the expressions.
    The expressions may also feature the relational and logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In EL, the following are the reserved operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operators: `+` `-` `*` `/` `div` `%` `mod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relational operators: `==` or `eq`, `!=` or `ne`, `<` or `lt`, `>` or `gt`,
    `<=` or `le`, `>=` or `ge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical operators: `&&` and, `||` or, `!` `not`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Empty operator: empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of some of these arithmetic expressions in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the escape character—the backslash (`\`), which prevents the
    JSF view from interpreting the expression. We can also render the expressions
    directly on the page without the need for a `<h:outputText/>` custom tag. This
    is a nice treat for the page authors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Preserve the MVC Model**'
  prefs: []
  type: TYPE_NORMAL
- en: It is better to place business logic in a controller bean rather than populating
    the page with complicated conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Page navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After JSF 2, it is very easy to provide navigation in a controller. In the `BasicFlow`
    controller from the earlier JSF example, we relied on implicit page navigation.
    The developer can specify the next page to render simply by returning a simple
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the controller class again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In JSF 1, the page navigation was determined explicitly in a Faces Configuration
    XML file: `/WEB-INF/faces-config.xml`, which made the development harder because
    of the enforced cognitive indirection. The purpose of `faces-config.xml` is to
    define the configuration for a JSF web application. The developer can define the
    navigation rules, inject bean properties, define the properties file, and declare
    the resource bundles and locales. They can register the converters, validators,
    and renderer components.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit page navigation is useful for the defined information architecture
    paths. Writing the page navigation is easier to share in a team. It can be incredibly
    quick to make prototypes for business stakeholders. However, explicit navigation
    is probably redundant if your controllers and rendered pages map directly in a
    one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSF also supports explicit navigation rules in the Faces Configuration XML file.
    I should warn you that this is the old style in JSF 1.*x* to describe the navigation
    between the pages explicitly. In JSF 2.*x*, navigation rules are no longer required,
    and if you want to describe the page navigation better, remind yourself to learn
    about Faces Flows (See [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows
    and Finesse"), *JSF Flows and Finesse*). However, there is a reasonable chance
    that, in your professional work, you will encounter older JSF applications, and
    therefore, you will need to learn how the JSF navigation rules are designed.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, here is how navigation works explicitly. Suppose that we
    have a simple page where we can choose between a collection of fruits and vegetables
    in a set of pages. We can also elect to cancel the choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a representation of these rules in the standard Faces Configuration
    file, `faces-config.xml`. This file is normally found in `src/main/webapp/WEB-INF`
    in Maven and Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Explicit navigation is determined by a set of rules that the JSF framework applies.
    The developers will write a series of compound elements in the <`navigation-rule>`
    tag. The context of the rule is determined by the `<from-view-id>` element, which
    references a specific view page, `/order-start.xhtml`, or it can be a wildcard
    rule (asterisk `*`) that applies to more than one navigation case. Each navigation
    rule has a collection of the `<navigation-case>` elements. Each case requires
    a `<from-outcome>` and `<to-view-id>` element. The outcome identifies the literal
    string, which is returned by the controller method and the view ID is the destination
    view. So, in the cancellation case, the outcome string identified by cancel will
    navigate to the `/cancel.xhtml` view.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the indirection mapping of the outcome to the view page is
    obvious. The outcome code in the controller remains the same but the destination
    view can change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a JSF controller that handles these navigation rules. This is
    an extract of the `ProductTypeController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `cancel()` method simply returns the cancel outcome, which JSF maps to the
    `/cancel.xhtml` page because the navigation case matches the outcome. The `navigate()`
    method sets outcome depending on the `productType` property. There can only be
    two outcomes in the `fruit` and `vegetable` methods, and the navigation case ensures
    that the `fruit.xhtml` and `vegetable.xhtml` pages are rendered respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Wildcards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigation rules may also have wildcard views. A wildcard navigation rule occurs
    where the asterisk (`*`) character prepends to the URI path in the `<from-view-id>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a website with protected pages that should not be displayable
    unless the user is logged in as a registered user. We can write a navigation rule
    that is shared for all the pages under the protected area. Let''s say we want
    to secure any web pages under the URI `/secured`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The wildcard `from-view-id /secured/*` identifies all the pages that start with
    the `/secured/` prefix. You are allowed to have only one wildcard in a URI path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using wildcards in an outcome brings forth the question of precedence. When
    does a wildcard `view id` take precedence over a direct outcome? Here is a navigation
    case extract of the Faces Configuration XML where we set the source page view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A direct `view id` always has a higher precedence over an equivalent wildcard
    view. JSF chooses the navigation case of a direct view, `stocks.xhtml`, over the
    wildcard view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If there are multiple wildcard views that are in competition for a match, then
    the longest match is chosen. JSF chooses the navigation case in the longest matching
    view, which is in the illustration `/secured/portfolio/*`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JSF explicit page navigation also supports the idea of conditional navigation
    in the Faces configuration file. This allows the developer to declaratively set
    up the navigation rules based on the dynamic state of the application. Conditional
    navigation is achieved by using the `<if>` element tag, as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The body content of `<if>` is a deferred value expression, which is evaluated
    in the JSF lifecycle and should return a Boolean value. In the code, the `#{user.registered}`
    expression is evaluated to the bean with the current logged-in user profile bean
    and property called registered. The `#{!user.registered}` expression evaluates
    the negation—note the use of the exclamation character for the operator.
  prefs: []
  type: TYPE_NORMAL
- en: Static navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete the digital developer story about page navigation, it is time to
    look at static navigation with JSF. Static navigation allows us to traverse from
    one JSF page to another without invoking a managed bean controller. It is useful
    for the page views where there is no requirement for a server-side Java code or
    where there are no HTML input elements. Static navigation is achieved from a combination
    of markups on the Facelets view and explicit navigation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the earlier `Basic JSF` example, we had a page view with `<h:link>`. Let''s
    change this to `<h:commandButton>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The action attribute specifies the name of outcome to navigate. We will replace
    the old element with the `<h:commandButton>` JSF tag. The action attribute specifies
    the value expression. JSF looks for the initial term in several contexts but it
    will also search the Faces configuration to match the navigation rule. For this
    traversal to work, we also require a navigation rule in the Faces configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The navigation rule matches the `your-next-view` outcome from the Facelets view,
    and so JSF can navigate to the destination page.
  prefs: []
  type: TYPE_NORMAL
- en: I think we will stop here regarding the page navigation topic. We will continue
    our developer digital journey with page navigation in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. JSF Validation and AJAX"), *JSF Validation and AJAX*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a robust adventure in the world of JSF. You should be
    able to understand the theory of how the framework has been put together. We covered
    the key features of JSF such as an HTML5 friendly markup and a templating engine.
    JSF is a part of the Java EE platform and is available on many application servers
    and servlet containers. We learned how the JSF framework relates to the Model-View-Controller
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to understand the request and response processing lifecycle
    and the phase change state model in JSF under the execute and render lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the middle chapter, we inspected the JSF basic pages, custom tag libraries,
    Facelets views, and a simple backing bean. We also observed a composition layout
    with both the master and client templates.
  prefs: []
  type: TYPE_NORMAL
- en: We also went in detail in the powerful EL framework, which is a part of Java
    EE 7 and JSF 2.2\. EL is a very important facility for the server-side Java applications,
    especially if they are built against Faces. To finish the journey, we looked at
    both implicit and explicit page navigation.
  prefs: []
  type: TYPE_NORMAL
- en: We now have enough knowledge to constitute a JSF foundation. In the next chapter,
    we will look at beefing up our JSF knowledge with the HTML forms and set the ground
    running with validation. In the subsequent chapters, we will definitely lose the
    XHTML documents and add HTML5 so that we can develop more modern websites.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the questions for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Where else in computer science might one find the Model-View-Controller design
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you think that keen computer scientists and architects wanted to separate
    business logic from the presentation view code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider a situation where you have been contracted by the municipal government
    for a local territory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have been asked to write an electoral roll web application for the voters
    to replace the traditional paper trail. Instead of sending official letters to
    the citizens and waiting to receive the filled-in forms, the citizens will be
    able to register for the electoral roll online. What constitutes the Model-View-Controller
    in this application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parts of the JSF life cycle map to the Model-View-Controller pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe when and where the framework will encounter the Restore View phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the process of an HTML form submission. What happens in JSF transferring
    the contents of an HTML form to the Java POJOS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a customer enters an invalid value in a form, describe the phases of the
    JSF life cycle that will process the Faces request. What do you think is added
    to the Faces response? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why have the JSF specification writers explicitly designed a special Render
    Response phase?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JSF has explicitly separated the valuation from the invocation of business logic
    in a backing bean (or action controller). Other web frameworks have a validation
    code in the backing beans. Outline the pros and cons of both the approaches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the code for chapter 2 and study how the web application is laid out.
    If you are feeling brave, modify one of the project examples. Add another string
    property to the backing bean, and then add a JSF form text field (hint: `<f:inputText>`).
    What happens? If your changes go wrong, you can always revert the changes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
