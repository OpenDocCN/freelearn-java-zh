- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Multiple Bounded Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications consist of more than one domain, or, to stick with Domain-Driven
    Design language, more than one bounded context. The term “**bounded context**”
    tells us that there should be boundaries between the different domains. If we
    don’t have boundaries between different domains, there are no restrictions on
    dependencies between classes in these domains. Eventually, dependencies will grow
    between the domains, coupling them together. This coupling means that the domains
    can no longer evolve in isolation, but can only evolve together. We could just
    as well not have separated our code into different domains in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: The whole reason to separate code into different domains is so that these domains
    can evolve in isolation. This is an application of the Single Responsibility Principle,
    discussed in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029), *Inverting Dependencies*.
    Only, this time, we’re not talking about the responsibilities of a single class,
    but about the responsibilities of a whole group of classes that make up a bounded
    context. If the responsibilities of one bounded context change, we don’t want
    to change the code for other bounded contexts!
  prefs: []
  type: TYPE_NORMAL
- en: Managing bounded contexts, that is, keeping the boundaries between them clear,
    is one of the main challenges of software engineering. Many of the pains developers
    associate with so-called “legacy software” stem from unclear boundaries. And it
    turns out that software doesn’t need long to become “legacy.”
  prefs: []
  type: TYPE_NORMAL
- en: So, unsurprisingly (at least in retrospect), many readers of the first edition
    of this book asked me how to manage multiple bounded contexts with Hexagonal Architecture.
    Unfortunately, the answer is not simple. As is so often the case, there are multiple
    ways to go about it and none of them are right or wrong per se. Let’s discuss
    some ways of separating bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: One hexagon per bounded context?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Hexagonal Architecture and multiple bounded contexts, our
    reflex is to create a separate “hexagon” for each bounded context. The result
    would look something like *Figure 13**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – If each bounded context is implemented as its own hexagon,
    we need an outgoing port, an adapter, and an incoming port for each line of communication
    between bounded contexts](img/Figure_13.1._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – If each bounded context is implemented as its own hexagon, we
    need an outgoing port, an adapter, and an incoming port for each line of communication
    between bounded contexts
  prefs: []
  type: TYPE_NORMAL
- en: Each bounded context lives in its own hexagon, providing input ports to interact
    with it and using output ports to interact with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the bounded contexts don’t need to talk to each other at all, so we
    don’t have any dependencies between the two. In the real world, however, this
    is rarely the case. Let’s assume that the bounded context on the left needs to
    call some functionality of the bounded context on the right.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the architecture elements that Hexagonal Architecture provides us
    with, we add an output port to the first bounded context and an input port to
    the second bounded context. Then, we create an adapter that implements the output
    port, does any necessary mapping, and calls the input port of the second bounded
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Problem solved, right?
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, on paper this looks like a very clean solution. The bounded contexts
    are optimally separated from each other. The dependencies between them are clearly
    structured in the form of ports and adapters. New dependencies between bounded
    contexts require us to explicitly add them to the existing ports or to add a new
    port. It’s unlikely that dependencies creep in “by accident” because there is
    a lot of ritual involved in creating such a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: If we think further than just two bounded contexts, however, it becomes apparent
    that this architecture doesn’t scale very well. For two bounded contexts with
    one dependency, we need to implement one adapter (the box named *Domain Adapter*
    in the preceding figure). If we exclude circular dependencies, we might have to
    implement three adapters for three bounded contexts, six adapters for four bounded
    contexts, and so on, as shown in *Figure 13**.2*.[1](#footnote-043)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-043-backlink) The formula I used to calculate the potential dependencies
    between *n* bounded contexts is *n-1 + n-2 + ... + 1*. The first bounded context
    has *n-1* potential, non-circular dependencies, the second *n-2*, and so on. The
    last bounded context cannot have any dependency on another bounded context because
    every dependency it can have would be a circular dependency, and we don’t want
    to allow circular dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The number of potential dependencies between bounded contexts
    grows disproportionately to the number of bounded contexts, even if we exclude
    circular dependencies](img/Figure_13.2._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The number of potential dependencies between bounded contexts
    grows disproportionately to the number of bounded contexts, even if we exclude
    circular dependencies
  prefs: []
  type: TYPE_NORMAL
- en: For each dependency, we would have to implement one adapter with at least one
    associated input and output port. Each adapter would have to map from one domain
    model to another. This quickly becomes a chore to develop and maintain. If it’s
    a chore and requires more effort than it brings value, the team will take shortcuts
    to avoid it, resulting in an architecture that looks like a Hexagonal Architecture
    at first glance but doesn’t have the benefits it promises.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the original article introducing Hexagonal Architecture, it was
    never the intent of Hexagonal Architecture to encapsulate a single bounded context
    in ports and adapters.[2](#footnote-042) Instead, the intent is to encapsulate
    an *application*. This application may consist of many bounded contexts or none
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-042-backlink) The original article on Hexagonal Architecture:
    [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).'
  prefs: []
  type: TYPE_NORMAL
- en: It *does* make sense to wrap each bounded context in its own hexagon when we’re
    preparing to extract them into their own applications, that is, their own (micro)services.
    That means we should be very certain that the boundaries we’re putting between
    them are the right boundaries, however, and we don’t expect them to change.
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway here is that Hexagonal Architecture doesn’t provide a scalable
    solution for managing multiple bounded contexts in the same application. And it
    doesn’t have to. We can instead take inspiration from Domain-Driven Design to
    decouple our bounded contexts, because within a hexagon, we can do whatever we
    like.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupled bounded contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that the ports and adapters should encapsulate
    the whole application, not each bounded context separately. How do we keep the
    bounded contexts separate from each other, then?
  prefs: []
  type: TYPE_NORMAL
- en: In a simple case, we might have bounded contexts that don’t communicate with
    each other. They provide completely separate paths through the code. In this case,
    we could build dedicated input and output ports for each bounded context like
    in *Figure 13**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – If bounded contexts (dashed lines) don’t need to talk to each
    other, each can implement its own input ports and call its own output ports](img/Figure_13.3._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – If bounded contexts (dashed lines) don’t need to talk to each
    other, each can implement its own input ports and call its own output ports
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a Hexagonal Architecture with two bounded contexts. A web
    adapter is driving the application and a database adapter is driven by the application.
    These adapters are representative of any other input and output adapters – not
    every application is a web application with a database.
  prefs: []
  type: TYPE_NORMAL
- en: Each bounded context exposes its own use cases via one or more dedicated input
    ports. The web adapter knows all input ports and thus can call the functionality
    of all bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having dedicated input ports for each of our bounded contexts, we
    could also implement one “broad” input port through which the web adapter routes
    requests to *multiple* bounded contexts. In this case, the boundaries between
    the contexts would be hidden from the outside of our hexagon. This may or may
    not be desirable depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, each bounded context defines its own output port to the database
    so that it can store and retrieve its data independently of any other bounded
    context.
  prefs: []
  type: TYPE_NORMAL
- en: While splitting the input ports per bounded context is optional, I would strongly
    recommend keeping the output ports that store and retrieve the domain data for
    a bounded context separate from other bounded contexts. If one bounded context
    is concerned with financial transactions and the other with user registrations,
    there should be one (or more) output port that is dedicated to storing and retrieving
    transaction data and another dedicated to storing and retrieving registration
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Each bounded context should have its own persistence. If bounded contexts share
    output ports to store and retrieve data, they will quickly become strongly coupled
    because they both depend on the same data model. Imagine that we need to pull
    one bounded context out of the Hexagonal application and into its own microservice
    because we learned that it has different scalability requirements from the rest
    of the application. If that bounded context shares a database model with another
    bounded context, it becomes very hard to extract. We wouldn’t want the new microservice
    to reach into another application’s database, would we? For the same reason, we
    want to keep the database model of each bounded context separate.
  prefs: []
  type: TYPE_NORMAL
- en: As long as multiple bounded contexts are executed in the same runtime, they
    might share a physical database and participate in the same database transactions.
    But within that database, there should be clear boundaries between the data of
    different bounded contexts, for example, in the form of a separate database schema,
    or at least different database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up the input and output ports like this has the nice effect that the
    bounded contexts are completely decoupled. Each bounded context can evolve by
    itself without affecting the others in any way. But they are only decoupled because
    they’re not talking to each other. What if we have use cases that span multiple
    bounded contexts or if one bounded context needs to speak to another?
  prefs: []
  type: TYPE_NORMAL
- en: Appropriately coupled bounded contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If all coupling could be avoided, software architecture would be a lot easier.
    In real-world applications, a bounded context very likely needs the help of another
    bounded context to do its work.
  prefs: []
  type: TYPE_NORMAL
- en: An example is again our bounded context that is concerned with money transactions.
    For security reasons, we’ll want to log which user has issued a transaction. That
    means that our bounded context needs some information about the user, which lives
    in another bounded context. But our bounded context doesn’t need to be tightly
    coupled to the user management context.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having to know the whole user object in our “transaction management”
    bounded context, it might be enough to just know the user’s ID. While a user object
    in the “registration” context is a complex object with many attributes, a representation
    of a user in the transaction context may only be a wrapper around the user ID.
    In the *Send money* use case, we could now just accept the ID of the user executing
    the transaction as input and then log it. We don’t need to couple the transaction
    context to all the other details of a user.
  prefs: []
  type: TYPE_NORMAL
- en: But we might want to validate that the user is not blocked from transactions.
    In this case, we can use a domain event.[3](#footnote-041) Whenever the status
    of a user changes in the user management context, we trigger a domain event that
    can be received by other bounded contexts. Our transaction context might listen
    to events when a user is newly registered or has been blocked, for example. It
    can then store that information in its own database for later use in the *Send
    money* use case to validate the status of the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-041-backlink) Events in Domain-Driven Design*: Implementing Domain-Driven
    Design* by Vaughn Vernon, Pearson, 2013, [*Chapter 8*](B19916_08.xhtml#_idTextAnchor071).'
  prefs: []
  type: TYPE_NORMAL
- en: Another possible solution is to introduce an application service as the orchestrator
    between the user management and transaction contexts.[4](#footnote-040) The application
    service implements the *Send money* input port. When called, it first asks the
    user management bounded context for the status of the user and then passes the
    status into the *Send money* use case provided by the transaction context – a
    different implementation, but the same effect as when using domain events.
  prefs: []
  type: TYPE_NORMAL
- en: '[4](#footnote-040-backlink) Application Services in Domain-Driven Design*:
    Implementing Domain-Driven Design* by Vaughn Vernon, Pearson, 2013, [*Chapter
    14*](B19916_14.xhtml#_idTextAnchor118).'
  prefs: []
  type: TYPE_NORMAL
- en: These were just two examples of how to “appropriately” couple bounded contexts.
    If you haven’t yet, I recommend reading through the Domain-Driven Design literature
    to get inspired.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to Hexagonal Architecture, appropriately coupling multiple bounded
    contexts may look something like in *Figure 13**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – If we have use cases spanning multiple bounded contexts, we
    can introduce an application service to orchestrate and domain events to share
    information between contexts](img/Figure_13.4._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – If we have use cases spanning multiple bounded contexts, we can
    introduce an application service to orchestrate and domain events to share information
    between contexts
  prefs: []
  type: TYPE_NORMAL
- en: We have introduced an application service as the orchestrator above our bounded
    contexts. The input ports are now implemented by this service instead of by the
    bounded contexts themselves. The application service may call output ports to
    get the required information from other systems and then calls one or more domain
    services provided by the bounded contexts. In addition to orchestrating the calls
    to the bounded contexts, the application service also acts as a **transaction
    boundary** so that we can call multiple domain services in the same database transaction,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: The domain services within the bounded contexts each still use their own database
    output ports to keep the data model between the bounded contexts separated. We
    may decide that this separation is not necessary and use a single database output
    port instead (but we should be aware that sharing a data model leads to very tight
    coupling).
  prefs: []
  type: TYPE_NORMAL
- en: The bounded contexts have access to a set of shared domain events that they
    can emit and listen to, respectively, to exchange information in a loosely coupled
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing boundaries between domains is one of the hardest parts of software
    development. In a small code base, boundaries might not be necessary because the
    mental model of the whole code base still fits into our brain’s working memory.
    But as soon as the code base reaches a certain size, we should make sure to introduce
    boundaries between domains, so we can reason about each domain in isolation. If
    we don’t do this, dependencies will creep in, turning our code base into one of
    those dreaded “big balls of mud.”
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal Architecture is all about managing a boundary between an application
    and the outside world. The boundary is made up of certain input ports provided
    by the application and certain output ports expected by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal Architecture does not help us to manage finer-grained boundaries within
    our application. Inside our “hexagon,” we can do whatever we want. If the code
    base gets too big for our working memory, we should fall back to Domain-Driven
    Design or other concepts to create boundaries within our code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a lightweight method of creating boundaries
    that we can use with or without Hexagonal Architecture.
  prefs: []
  type: TYPE_NORMAL
