- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Managing Multiple Bounded Contexts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个边界上下文
- en: Many applications consist of more than one domain, or, to stick with Domain-Driven
    Design language, more than one bounded context. The term “**bounded context**”
    tells us that there should be boundaries between the different domains. If we
    don’t have boundaries between different domains, there are no restrictions on
    dependencies between classes in these domains. Eventually, dependencies will grow
    between the domains, coupling them together. This coupling means that the domains
    can no longer evolve in isolation, but can only evolve together. We could just
    as well not have separated our code into different domains in the first place!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序由多个领域组成，或者，按照领域驱动设计的语言来说，由多个边界上下文组成。术语“**边界上下文**”告诉我们，不同领域之间应该有边界。如果我们不同领域之间没有边界，那么这些领域中的类之间的依赖关系将没有限制。最终，领域之间的依赖关系会增长，将它们耦合在一起。这种耦合意味着领域不能再独立地进化，而只能一起进化。我们最初甚至可以不把代码分成不同的领域！
- en: The whole reason to separate code into different domains is so that these domains
    can evolve in isolation. This is an application of the Single Responsibility Principle,
    discussed in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029), *Inverting Dependencies*.
    Only, this time, we’re not talking about the responsibilities of a single class,
    but about the responsibilities of a whole group of classes that make up a bounded
    context. If the responsibilities of one bounded context change, we don’t want
    to change the code for other bounded contexts!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分离到不同的领域中的整个原因是为了让这些领域能够独立进化。这是对第 3 章“反转依赖”中讨论的单一职责原则的应用。不过，这次我们不是在谈论单个类的职责，而是在谈论构成边界上下文的一组类的职责。如果一个边界上下文的职责发生变化，我们不希望改变其他边界上下文的代码！
- en: Managing bounded contexts, that is, keeping the boundaries between them clear,
    is one of the main challenges of software engineering. Many of the pains developers
    associate with so-called “legacy software” stem from unclear boundaries. And it
    turns out that software doesn’t need long to become “legacy.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 管理边界上下文，即保持它们之间的边界清晰，是软件工程的主要挑战之一。许多开发者与所谓的“遗留软件”相关的痛苦都源于边界不明确。而且，事实证明，软件不需要很长时间就会变成“遗留”。
- en: So, unsurprisingly (at least in retrospect), many readers of the first edition
    of this book asked me how to manage multiple bounded contexts with Hexagonal Architecture.
    Unfortunately, the answer is not simple. As is so often the case, there are multiple
    ways to go about it and none of them are right or wrong per se. Let’s discuss
    some ways of separating bounded contexts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不出所料（至少在回顾时是这样），这本书第一版的许多读者问我如何使用六边形架构管理多个边界上下文。不幸的是，答案并不简单。就像经常发生的那样，有几种方法可以做到这一点，而且它们本身并没有对错之分。让我们讨论一些分离边界上下文的方法。
- en: One hexagon per bounded context?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个边界上下文一个六边形？
- en: When working with Hexagonal Architecture and multiple bounded contexts, our
    reflex is to create a separate “hexagon” for each bounded context. The result
    would look something like *Figure 13**.1*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当与六边形架构和多个边界上下文一起工作时，我们的本能是为每个边界上下文创建一个单独的“六边形”。结果看起来就像 *图 13.1*。
- en: '![Figure 13.1 – If each bounded context is implemented as its own hexagon,
    we need an outgoing port, an adapter, and an incoming port for each line of communication
    between bounded contexts](img/Figure_13.1._B19916.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 如果每个边界上下文都作为自己的六边形实现，我们需要为边界上下文之间的每条通信线路提供一个输出端口、一个适配器和输入端口](img/Figure_13.1._B19916.jpg)'
- en: Figure 13.1 – If each bounded context is implemented as its own hexagon, we
    need an outgoing port, an adapter, and an incoming port for each line of communication
    between bounded contexts
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 如果每个边界上下文都作为自己的六边形实现，我们需要为边界上下文之间的每条通信线路提供一个输出端口、一个适配器和输入端口
- en: Each bounded context lives in its own hexagon, providing input ports to interact
    with it and using output ports to interact with the outside world.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界上下文都生活在自己的六边形中，提供输入端口以与之交互，并使用输出端口与外界交互。
- en: Ideally, the bounded contexts don’t need to talk to each other at all, so we
    don’t have any dependencies between the two. In the real world, however, this
    is rarely the case. Let’s assume that the bounded context on the left needs to
    call some functionality of the bounded context on the right.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，边界上下文之间根本不需要相互通信，因此两者之间没有任何依赖关系。然而，在现实世界中，这种情况很少见。让我们假设左侧的边界上下文需要调用右侧边界上下文的一些功能。
- en: If we use the architecture elements that Hexagonal Architecture provides us
    with, we add an output port to the first bounded context and an input port to
    the second bounded context. Then, we create an adapter that implements the output
    port, does any necessary mapping, and calls the input port of the second bounded
    context.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用六边形架构提供的架构元素，我们在第一个限制上下文中添加一个输出端口，在第二个限制上下文中添加一个输入端口。然后，我们创建一个适配器，该适配器实现输出端口，进行任何必要的映射，并调用第二个限制上下文的输入端口。
- en: Problem solved, right?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决，对吧？
- en: Indeed, on paper this looks like a very clean solution. The bounded contexts
    are optimally separated from each other. The dependencies between them are clearly
    structured in the form of ports and adapters. New dependencies between bounded
    contexts require us to explicitly add them to the existing ports or to add a new
    port. It’s unlikely that dependencies creep in “by accident” because there is
    a lot of ritual involved in creating such a dependency.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在纸上这看起来是一个非常干净的解决方案。限制上下文之间被最优地分隔开来。它们之间的依赖关系以端口和适配器的形式清晰地结构化。新的限制上下文之间的依赖关系需要我们明确地将它们添加到现有的端口中，或者添加一个新的端口。由于创建这种依赖关系涉及许多仪式，因此依赖关系不太可能“意外”地出现。
- en: If we think further than just two bounded contexts, however, it becomes apparent
    that this architecture doesn’t scale very well. For two bounded contexts with
    one dependency, we need to implement one adapter (the box named *Domain Adapter*
    in the preceding figure). If we exclude circular dependencies, we might have to
    implement three adapters for three bounded contexts, six adapters for four bounded
    contexts, and so on, as shown in *Figure 13**.2*.[1](#footnote-043)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们进一步思考，除了两个限制上下文之外，这种架构的扩展性并不好。对于具有一个依赖关系的两个限制上下文，我们需要实现一个适配器（如图中名为 *领域适配器*
    的框所示）。如果我们排除了循环依赖，我们可能需要为三个限制上下文实现三个适配器，为四个限制上下文实现六个适配器，依此类推，如图 *图 13.2* 所示。[1](#footnote-043)
- en: '[1](#footnote-043-backlink) The formula I used to calculate the potential dependencies
    between *n* bounded contexts is *n-1 + n-2 + ... + 1*. The first bounded context
    has *n-1* potential, non-circular dependencies, the second *n-2*, and so on. The
    last bounded context cannot have any dependency on another bounded context because
    every dependency it can have would be a circular dependency, and we don’t want
    to allow circular dependencies.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-043-backlink) 我用来计算 *n* 个限制上下文之间潜在依赖关系的公式是 *n-1 + n-2 + ... +
    1*。第一个限制上下文有 *n-1* 个潜在的、非循环的依赖关系，第二个有 *n-2*，依此类推。最后一个限制上下文不能依赖于另一个限制上下文，因为它的每个依赖关系都会是一个循环依赖，而我们不想允许循环依赖。'
- en: '![Figure 13.2 – The number of potential dependencies between bounded contexts
    grows disproportionately to the number of bounded contexts, even if we exclude
    circular dependencies](img/Figure_13.2._B19916.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 限制上下文之间的潜在依赖关系数量与限制上下文数量不成比例增长，即使我们排除了循环依赖](img/Figure_13.2._B19916.jpg)'
- en: Figure 13.2 – The number of potential dependencies between bounded contexts
    grows disproportionately to the number of bounded contexts, even if we exclude
    circular dependencies
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 即使排除了循环依赖，限制上下文之间的潜在依赖关系数量与限制上下文数量不成比例增长
- en: For each dependency, we would have to implement one adapter with at least one
    associated input and output port. Each adapter would have to map from one domain
    model to another. This quickly becomes a chore to develop and maintain. If it’s
    a chore and requires more effort than it brings value, the team will take shortcuts
    to avoid it, resulting in an architecture that looks like a Hexagonal Architecture
    at first glance but doesn’t have the benefits it promises.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个依赖关系，我们可能需要实现一个至少包含一个相关输入和输出端口的适配器。每个适配器都必须从一个领域模型映射到另一个领域模型。这很快就会变成一个开发和维护的繁琐工作。如果这是一个繁琐的工作，并且所需的努力超过了它带来的价值，团队将采取捷径来避免它，结果是一个乍一看像六边形架构但缺乏其承诺的架构。
- en: If we look at the original article introducing Hexagonal Architecture, it was
    never the intent of Hexagonal Architecture to encapsulate a single bounded context
    in ports and adapters.[2](#footnote-042) Instead, the intent is to encapsulate
    an *application*. This application may consist of many bounded contexts or none
    at all.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看介绍六边形架构的原始文章，六边形架构的意图从来不是在端口和适配器中封装单个限制上下文。[2](#footnote-042) 相反，其意图是封装一个
    *应用程序*。这个应用程序可能由许多限制上下文组成，也可能没有任何限制上下文。
- en: '[2](#footnote-042-backlink) The original article on Hexagonal Architecture:
    [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-042-backlink) 关于六边形架构的原始文章：[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).'
- en: It *does* make sense to wrap each bounded context in its own hexagon when we’re
    preparing to extract them into their own applications, that is, their own (micro)services.
    That means we should be very certain that the boundaries we’re putting between
    them are the right boundaries, however, and we don’t expect them to change.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备将它们提取到它们自己的应用程序（即它们自己的（微）服务）中时，将每个边界上下文包裹在其自己的六边形中是有意义的。这意味着我们应该非常确定我们放置在他们之间的边界是正确的边界，我们不期望它们会改变。
- en: The takeaway here is that Hexagonal Architecture doesn’t provide a scalable
    solution for managing multiple bounded contexts in the same application. And it
    doesn’t have to. We can instead take inspiration from Domain-Driven Design to
    decouple our bounded contexts, because within a hexagon, we can do whatever we
    like.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，六边形架构并不提供一种可扩展的解决方案来管理同一应用程序中的多个边界上下文。它不必这样做。我们可以从领域驱动设计中汲取灵感，以解耦我们的边界上下文，因为在六边形内部，我们可以做我们喜欢的事情。
- en: Decoupled bounded contexts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦的边界上下文
- en: In the previous section, we learned that the ports and adapters should encapsulate
    the whole application, not each bounded context separately. How do we keep the
    bounded contexts separate from each other, then?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到端口和适配器应该封装整个应用程序，而不是单独封装每个边界上下文。那么，我们如何保持边界上下文之间的分离呢？
- en: In a simple case, we might have bounded contexts that don’t communicate with
    each other. They provide completely separate paths through the code. In this case,
    we could build dedicated input and output ports for each bounded context like
    in *Figure 13**.3*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，我们可能会有不相互通信的边界上下文。它们通过代码提供完全独立的路径。在这种情况下，我们可以为每个边界上下文构建专门的输入和输出端口，就像在*图13.3*中所示。
- en: '![Figure 13.3 – If bounded contexts (dashed lines) don’t need to talk to each
    other, each can implement its own input ports and call its own output ports](img/Figure_13.3._B19916.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 如果边界上下文（虚线）之间不需要相互通信，每个上下文都可以实现自己的输入端口并调用自己的输出端口](img/Figure_13.3._B19916.jpg)'
- en: Figure 13.3 – If bounded contexts (dashed lines) don’t need to talk to each
    other, each can implement its own input ports and call its own output ports
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 如果边界上下文（虚线）之间不需要相互通信，每个上下文都可以实现自己的输入端口并调用自己的输出端口
- en: This example shows a Hexagonal Architecture with two bounded contexts. A web
    adapter is driving the application and a database adapter is driven by the application.
    These adapters are representative of any other input and output adapters – not
    every application is a web application with a database.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个具有两个边界上下文的六边形架构。网络适配器驱动应用程序，而数据库适配器由应用程序驱动。这些适配器代表任何其他输入和输出适配器 – 并非每个应用程序都是具有数据库的Web应用程序。
- en: Each bounded context exposes its own use cases via one or more dedicated input
    ports. The web adapter knows all input ports and thus can call the functionality
    of all bounded contexts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界上下文通过一个或多个专门的输入端口公开其自己的用例。网络适配器知道所有输入端口，因此可以调用所有边界上下文的功能。
- en: Instead of having dedicated input ports for each of our bounded contexts, we
    could also implement one “broad” input port through which the web adapter routes
    requests to *multiple* bounded contexts. In this case, the boundaries between
    the contexts would be hidden from the outside of our hexagon. This may or may
    not be desirable depending on the situation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为我们的每个边界上下文设置专门的输入端口外，我们还可以实现一个“广泛”的输入端口，通过该端口网络适配器将请求路由到多个边界上下文。在这种情况下，上下文之间的边界将对外部我们的六边形隐藏。这可能是或可能不是根据情况而定的。
- en: Furthermore, each bounded context defines its own output port to the database
    so that it can store and retrieve its data independently of any other bounded
    context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个边界上下文定义自己的输出端口到数据库，以便它可以独立于任何其他边界上下文存储和检索其数据。
- en: While splitting the input ports per bounded context is optional, I would strongly
    recommend keeping the output ports that store and retrieve the domain data for
    a bounded context separate from other bounded contexts. If one bounded context
    is concerned with financial transactions and the other with user registrations,
    there should be one (or more) output port that is dedicated to storing and retrieving
    transaction data and another dedicated to storing and retrieving registration
    data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然按边界上下文分割输入端口是可选的，但我强烈建议将存储和检索特定边界上下文领域数据的输出端口与其他边界上下文分开。如果一个边界上下文关注金融交易，而另一个关注用户注册，那么应该有一个（或多个）输出端口专门用于存储和检索交易数据，另一个则专门用于存储和检索注册数据。
- en: Each bounded context should have its own persistence. If bounded contexts share
    output ports to store and retrieve data, they will quickly become strongly coupled
    because they both depend on the same data model. Imagine that we need to pull
    one bounded context out of the Hexagonal application and into its own microservice
    because we learned that it has different scalability requirements from the rest
    of the application. If that bounded context shares a database model with another
    bounded context, it becomes very hard to extract. We wouldn’t want the new microservice
    to reach into another application’s database, would we? For the same reason, we
    want to keep the database model of each bounded context separate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界上下文都应该有自己的持久化存储。如果边界上下文共享输出端口来存储和检索数据，它们会很快变得紧密耦合，因为它们都依赖于相同的数据模型。想象一下，如果我们需要将一个边界上下文从六边形应用中提取出来，成为一个独立的微服务，因为我们了解到它与其他应用的其他部分有不同的可扩展性要求。如果这个边界上下文与另一个边界上下文共享数据库模型，那么提取就会变得非常困难。我们不想让新的微服务触及另一个应用的数据库，对吧？出于同样的原因，我们希望保持每个边界上下文的数据库模型独立。
- en: As long as multiple bounded contexts are executed in the same runtime, they
    might share a physical database and participate in the same database transactions.
    But within that database, there should be clear boundaries between the data of
    different bounded contexts, for example, in the form of a separate database schema,
    or at least different database tables.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只要多个边界上下文在同一个运行时中执行，它们可能共享一个物理数据库并参与相同的数据库事务。但在那个数据库中，不同边界上下文的数据之间应该有清晰的边界，例如，以单独的数据库模式的形式，或者至少不同的数据库表。
- en: Splitting up the input and output ports like this has the nice effect that the
    bounded contexts are completely decoupled. Each bounded context can evolve by
    itself without affecting the others in any way. But they are only decoupled because
    they’re not talking to each other. What if we have use cases that span multiple
    bounded contexts or if one bounded context needs to speak to another?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入和输出端口这样分开，会有一个很好的效果，那就是边界上下文之间完全解耦。每个边界上下文都可以独立发展，而不会以任何方式影响其他上下文。但它们之所以解耦，仅仅是因为它们没有相互交流。如果我们有跨越多个边界上下文的使用案例，或者如果一个边界上下文需要与另一个上下文交流，会怎样呢？
- en: Appropriately coupled bounded contexts
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当地耦合的边界上下文
- en: If all coupling could be avoided, software architecture would be a lot easier.
    In real-world applications, a bounded context very likely needs the help of another
    bounded context to do its work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有耦合都可以避免，软件架构将会容易得多。在现实世界的应用中，一个边界上下文很可能需要另一个边界上下文的支持来完成其工作。
- en: An example is again our bounded context that is concerned with money transactions.
    For security reasons, we’ll want to log which user has issued a transaction. That
    means that our bounded context needs some information about the user, which lives
    in another bounded context. But our bounded context doesn’t need to be tightly
    coupled to the user management context.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，又是我们那个关注货币交易的边界上下文。出于安全考虑，我们希望记录哪个用户发起了一笔交易。这意味着我们的边界上下文需要一些关于用户的信息，这些信息存在于另一个边界上下文中。但我们的边界上下文不需要与用户管理上下文紧密耦合。
- en: Instead of having to know the whole user object in our “transaction management”
    bounded context, it might be enough to just know the user’s ID. While a user object
    in the “registration” context is a complex object with many attributes, a representation
    of a user in the transaction context may only be a wrapper around the user ID.
    In the *Send money* use case, we could now just accept the ID of the user executing
    the transaction as input and then log it. We don’t need to couple the transaction
    context to all the other details of a user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“事务管理”边界上下文中，不必知道整个用户对象，可能只需要知道用户的ID。虽然“注册”上下文中的用户对象是一个具有许多属性的复杂对象，但在事务上下文中，用户的表示可能只是用户ID的包装。在
    *发送金钱* 使用案例中，我们现在可以仅接受执行事务的用户ID作为输入，并将其记录下来。我们不需要将事务上下文耦合到用户的所有其他细节。
- en: But we might want to validate that the user is not blocked from transactions.
    In this case, we can use a domain event.[3](#footnote-041) Whenever the status
    of a user changes in the user management context, we trigger a domain event that
    can be received by other bounded contexts. Our transaction context might listen
    to events when a user is newly registered or has been blocked, for example. It
    can then store that information in its own database for later use in the *Send
    money* use case to validate the status of the user.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可能希望验证用户没有被阻止进行交易。在这种情况下，我们可以使用领域事件。[3](#footnote-041) 当用户管理上下文中用户的状态发生变化时，我们触发一个可以被其他边界上下文接收的领域事件。例如，我们的交易上下文可能会监听当用户新注册或被阻止时的事件。然后它可以将其存储在自己的数据库中，以便在
    *发送金钱* 使用案例中稍后用于验证用户的状态。
- en: '[3](#footnote-041-backlink) Events in Domain-Driven Design*: Implementing Domain-Driven
    Design* by Vaughn Vernon, Pearson, 2013, [*Chapter 8*](B19916_08.xhtml#_idTextAnchor071).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-041-backlink) 领域驱动设计中的事件：Vaughn Vernon 著的《领域驱动设计》实施，Pearson，2013，[*第8章*](B19916_08.xhtml#_idTextAnchor071)。'
- en: Another possible solution is to introduce an application service as the orchestrator
    between the user management and transaction contexts.[4](#footnote-040) The application
    service implements the *Send money* input port. When called, it first asks the
    user management bounded context for the status of the user and then passes the
    status into the *Send money* use case provided by the transaction context – a
    different implementation, but the same effect as when using domain events.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案是在用户管理和事务上下文之间引入一个应用服务作为协调者。[4](#footnote-040) 应用服务实现了 *发送金钱* 输入端口。当被调用时，它首先向用户管理边界上下文询问用户的状态，然后将状态传递给由事务上下文提供的
    *发送金钱* 使用案例 – 一种不同的实现，但效果与使用领域事件时相同。
- en: '[4](#footnote-040-backlink) Application Services in Domain-Driven Design*:
    Implementing Domain-Driven Design* by Vaughn Vernon, Pearson, 2013, [*Chapter
    14*](B19916_14.xhtml#_idTextAnchor118).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-040-backlink) 领域驱动设计中的应用服务：Vaughn Vernon 著的《领域驱动设计》实施，Pearson，2013，[*第14章*](B19916_14.xhtml#_idTextAnchor118)。'
- en: These were just two examples of how to “appropriately” couple bounded contexts.
    If you haven’t yet, I recommend reading through the Domain-Driven Design literature
    to get inspired.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是如何“适当地”耦合边界上下文的两个例子。如果您还没有这样做，我建议您阅读领域驱动设计的文献以获得灵感。
- en: Coming back to Hexagonal Architecture, appropriately coupling multiple bounded
    contexts may look something like in *Figure 13**.4*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回到六边形架构，适当地耦合多个边界上下文可能看起来像 *图13.4*。4。
- en: '![Figure 13.4 – If we have use cases spanning multiple bounded contexts, we
    can introduce an application service to orchestrate and domain events to share
    information between contexts](img/Figure_13.4._B19916.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 如果我们有多边界上下文跨越的使用案例，我们可以引入一个应用服务来协调和领域事件，以便在上下文之间共享信息](img/Figure_13.4._B19916.jpg)'
- en: Figure 13.4 – If we have use cases spanning multiple bounded contexts, we can
    introduce an application service to orchestrate and domain events to share information
    between contexts
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 如果我们有多边界上下文跨越的使用案例，我们可以引入一个应用服务来协调和领域事件，以便在上下文之间共享信息
- en: We have introduced an application service as the orchestrator above our bounded
    contexts. The input ports are now implemented by this service instead of by the
    bounded contexts themselves. The application service may call output ports to
    get the required information from other systems and then calls one or more domain
    services provided by the bounded contexts. In addition to orchestrating the calls
    to the bounded contexts, the application service also acts as a **transaction
    boundary** so that we can call multiple domain services in the same database transaction,
    for example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经引入了一个应用程序服务作为我们有限上下文之上的协调者。现在，输入端口由这个服务而不是由有限上下文本身实现。应用程序服务可以调用输出端口从其他系统获取所需信息，然后调用有限上下文提供的域服务之一或多个。除了协调对有限上下文的调用外，应用程序服务还充当**事务边界**，这样我们就可以在同一个数据库事务中调用多个域服务，例如。
- en: The domain services within the bounded contexts each still use their own database
    output ports to keep the data model between the bounded contexts separated. We
    may decide that this separation is not necessary and use a single database output
    port instead (but we should be aware that sharing a data model leads to very tight
    coupling).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有限上下文内的领域服务仍然使用它们自己的数据库输出端口来保持有限上下文之间的数据模型分离。我们可能会决定这种分离不是必要的，并使用单个数据库输出端口代替（但我们应该意识到共享数据模型会导致非常紧密的耦合）。
- en: The bounded contexts have access to a set of shared domain events that they
    can emit and listen to, respectively, to exchange information in a loosely coupled
    fashion.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有限上下文可以访问一组共享的领域事件，它们可以分别发出和监听，以松散耦合的方式交换信息。
- en: How does this help me build maintainable software?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Managing boundaries between domains is one of the hardest parts of software
    development. In a small code base, boundaries might not be necessary because the
    mental model of the whole code base still fits into our brain’s working memory.
    But as soon as the code base reaches a certain size, we should make sure to introduce
    boundaries between domains, so we can reason about each domain in isolation. If
    we don’t do this, dependencies will creep in, turning our code base into one of
    those dreaded “big balls of mud.”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 管理领域之间的边界是软件开发中最困难的部分之一。在一个小的代码库中，边界可能不是必要的，因为整个代码库的心理模型仍然适合我们的大脑工作记忆。但是，一旦代码库达到一定规模，我们应该确保在领域之间引入边界，这样我们就可以单独推理每个领域。如果我们不这样做，依赖关系就会悄悄进入，使我们的代码库变成那些令人讨厌的“大泥球”之一。
- en: Hexagonal Architecture is all about managing a boundary between an application
    and the outside world. The boundary is made up of certain input ports provided
    by the application and certain output ports expected by the application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构主要关注管理应用程序与外部世界之间的边界。这个边界由应用程序提供的某些输入端口和应用程序期望的某些输出端口组成。
- en: Hexagonal Architecture does not help us to manage finer-grained boundaries within
    our application. Inside our “hexagon,” we can do whatever we want. If the code
    base gets too big for our working memory, we should fall back to Domain-Driven
    Design or other concepts to create boundaries within our code base.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构并不能帮助我们管理应用程序内部更细粒度的边界。在我们的“六边形”内部，我们可以做任何我们想做的事情。如果代码库太大，超出了我们的工作记忆，我们应该退回到领域驱动设计或其他概念，在代码库内部创建边界。
- en: In the next chapter, we will explore a lightweight method of creating boundaries
    that we can use with or without Hexagonal Architecture.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种轻量级的方法来创建边界，我们可以使用或不用六边形架构。
