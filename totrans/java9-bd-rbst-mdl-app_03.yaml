- en: Discovering Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 represents a major release and consists of a large number of internal
    changes to the Java platform. Collectively, these internal changes represent a
    tremendous set of new possibilities for Java developers, some stemming from developer
    requests, others from Oracle-inspired enhancements. In this chapter, we will review
    26 of the most important changes. Each change is related to a **JDK Enhancement
    Proposal** (**JEP**). JEPs are indexed and housed at [openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0).
    You can visit this site for additional information on each JEP.
  prefs: []
  type: TYPE_NORMAL
- en: The JEP program is part of Oracle's support for open source, open innovation,
    and open standards. While other open source Java projects can be found, OpenJDK
    is the only one supported by Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover changes to the Java platform. These changes
    have several impressive implications, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Heap space efficiencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilation process improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated runtime compiler tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing around with the Java Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a long time, there has been no standard shell shipped with the Java programming
    language to experiment with new language features or libraries or for rapid prototyping.
    If you wanted to do this, you could write a test application with a main method,
    compile it with `javac`, and run it. This could be done either at the command
    line or using a Java IDE; however, in both cases, this is not as convenient as
    having an interactive shell for the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting an interactive shell in JDK 9 is as simple as running the following
    command (assuming the `bin` directory of your JDK 9 installation is in the current
    path):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may find it somewhat puzzling that an interactive shell has not been introduced
    earlier in the Java platform as many programming languages, such as Python, Ruby,
    and a number of others, already come with an interactive shell in their earliest
    versions; However, this had still not made it on the priority features list for
    the earlier Java releases, until now, and it is out there and ready for use. The
    Java shell makes use of a JShell API that provides capabilities to enable autocompletion
    or evaluation of expressions and code snippets, among other features. A full chapter
    is dedicated to discussing the details of the Java shell so that developers can
    make the best use out of it.
  prefs: []
  type: TYPE_NORMAL
- en: Taking control of external processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to JDK 9, if you wanted to create a Java process and handle process input/output,
    you had to use either the `Runtime.getRuntime.exec()` method, which allows us
    to execute a command in a separate OS process and get a `java.lang.Process` instance
    over which to provide certain operations in order to manage the external process,
    or use the new `java.lang.ProcessBuilder` class with some more enhancements in
    regard to interacting with the external process and also create a `java.lang.Process`
    instance to represent the external process. Both mechanisms were inflexible and
    also non-portable as the set of commands executed by the external processes were
    highly dependent on the operating system (additional effort had to be exerted
    in order to make the particular process operations portable across multiple operating
    systems). A chapter is dedicated to the new process API, providing developers
    with the knowledge of creating and managing external processes in a much easier
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Boosting performance with G1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The G1 garbage collector was already introduced in JDK 7 and is now enabled
    by default in JDK 9\. It is targeted for systems with multiple processing cores
    and a lot of available memory. What are the benefits of the G1 compared to previous
    types of garbage collectors? How does it achieve these improvements? Is there
    a need to manually tune it, and in what scenarios? These, and several more questions
    regarding G1, will be discussed in a separate chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance with JMH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On many occasions, Java applications may suffer from performance degradation.
    Exacerbating the issue is a lack of performance tests that can provide at least
    a minimal set of guarantees that performance requirements are met and, moreover,
    the performance of certain features will not degrade over time. Measuring performance
    of Java applications is not trivial, especially due to the fact that there is
    a number of compiler and runtime optimizations that may affect performance statistics.
    For that reason, additional measures such as warm-up phases and other tricks must
    be used in order to provide more accurate performance measurements. The Java Microbenchmark
    Harness is a framework that incorporates a number of techniques along with a convenient
    API that can be used for this purpose. It is not a new tool, but is included with
    the distribution of Java 9\. If you have not added JMH to your toolbox yet, read
    the detailed chapter on the usage of JMH in the context of Java 9 application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with HTTP 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP 2.0 is the successor of the HTTP 1.1 protocol, and this new version of
    the protocol addresses some limitations and drawbacks of the previous one. HTTP
    2.0 improves performance in several ways and provides capabilities such as request/response
    multiplexing in a single TCP connection, sending of responses in a server-push,
    flow control, and request prioritization, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Java provides the `java.net.HttpURLConnection` utility that can be used to establish
    a non-secure HTTP 1.1 connection. However, the API was considered difficult to
    maintain and further extended with the support for HTTP 2.0 and, so, an entirely
    new client API was introduced in order to establish a connection via the HTTP
    2.0 or the web socket protocols. The new HTTP 2.0 client, along with the capabilities
    it provides, will be covered in a dedicated chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Encompassing reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is a paradigm used to describe a certain pattern for propagation
    of changes in a system. Reactiveness is not built in Java itself, but reactive
    data flows can be established using third-party libraries such as RxJava or project
    Reactor (part of the Spring Framework). JDK 9 also addresses the need for an API
    that aids the development of highly-responsive applications built around the idea
    of reactive streams by providing the `java.util.concurrent.Flow` class for the
    purpose. The `Flow` class, along with other related changes introduced in JDK
    9, will be covered in a separate chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the wish list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from all of the new stuff in JDK 9, a whole new set of features is expected
    in future releases of the platform. Among these are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generics over primitive types**: This is one of the features planned for
    JDK 10 as part of project Valhalla. Other language enhancements, such as value
    handles, are already part of Java 9 and will be introduced later in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reified generics**: This is another featured part of project Valhalla that
    aims to provide the ability to preserve generic types at runtime. The related
    goals are listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foreign functional interface aims to introduce a new API to call and manage
    native functions. The API addresses some of the drawbacks of JNI and especially
    a lack of simplicity for use by application developers. The foreign functional
    interface is developed as part of project Panama in the JDK ecosystem.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New money and currency API (developed under JSR 354) was initially planned for
    Java 9, but was postponed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New lightweight JSON API (developed under JSR 353) was also planned for Java
    9, but postponed to Java 10.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the new things one may expect in subsequent releases
    of the JDK. Project Penrose aims to bridge the gap between the module system in
    Java and the OSGi module system, and to provide different methodologies for interoperability
    between the two systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Graal VM is another interesting research project that is a potential candidate
    for subsequent releases of the Java platform. It aims to bring the runtime performance
    of Java to dynamic languages such as JavaScript or Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: A chapter dedicated to the future of JDK discusses all of these points in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this brief introductory chapter, we revealed the small universe of capabilities
    provided by JDK 9\. The module system introduced in this release of the platform
    is indisputably a cornerstone in the development of Java applications. We also
    discovered that a number of other major features and changes are introduced in
    JDK 9 that deserve special attention and will be discussed in great detail in
    subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at 26 internal changes to the Java
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Improved Contended Locking [JEP 143]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JVM uses Heap space for classes and objects. The JVM allocates memory on
    the heap whenever we create an object. This helps facilitate Java's garbage collection
    which releases memory previously used to hold objects that no longer have a reference
    to it. Java Stack memory is a bit different and is usually much smaller than heap
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM does a good job of managing data areas that are shared by multiple threads.
    It associates a monitor with every object and class; these monitors have locks
    that are controlled by a single thread at any one time. These locks, controlled
    by the JVM, are, in essence, giving the controlling thread the object's monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is contended locking? When a thread is in a queue for a currently
    locked object, it is said to be in contention for that lock. The following diagram
    shows a high-level view of this contention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f195fbd-f2f1-4152-8fcd-c5a02b2fe215.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding illustration, any threads in waiting cannot
    use a locked object until it is released.
  prefs: []
  type: TYPE_NORMAL
- en: Improvement goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The general goal of JEP 143 was to increase the overall performance of how
    the JVM manages contention over locked Java object monitors. The improvements
    to contended locking were all internal to the JVM and do not require any developer
    actions to benefit from them. The overall improvement goals were related to faster
    operations. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster monitor enter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster monitor exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notifications are the `notify()` and `notifyAll()` operations that are called
    when the locked status of an object is changed. Testing this improvement is not
    something you can easily accomplish. Greater efficiency, at any level, is welcome,
    so this improvement is one we can be thankful for even without any easily observable
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Segmented code cache [JEP 197]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The segmented code cache JEP (197) upgrade was completed and results in faster,
    more efficient execution time. At the core of this change was the segmentation
    of the code cache into three distinct segments--non-method, profiled, and non-profiled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A code cache is the area of memory where the Java Virtual Machine stores generated
    native code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the aforementioned code cache segments will hold a specific type of
    compiled code. As you can see in the following diagram, the code heap areas are
    segmented by type of compiled code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2b14b35-4bed-4a9e-8b9f-bcb5832112c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code heap containing non-method code is for JVM internal code and consists
    of a 3 MB fixed memory block. The rest of the code cache memory is equally allocated
    for the profiled code and non-profiled code segments. You have control of this
    via command-line commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command can be used to define the code heap size for the non-method
    compiled code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command can be used to define the code heap size for the profiled
    compiled methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command can be used to define the code heap size for the non-profiled
    compiled methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This Java 9 feature certainly stands to improve Java application efficiency.
    It also impacts other processes that employ the code cache.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Java compilation, phase two [JEP 199]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JDK Enhancement Proposal 199 is aimed at improving the code compilation
    process. All Java developers will be familiar with the **javac** tool for compiling
    source code to bytecode, which is used by the JVM to run Java programs. **Smart
    Java Compilation**, also referred to as Smart Javac and **sjavac**, adds a *smart*
    wrapper around the javac process. Perhaps the core improvement sjavac adds is
    that only the necessary code is recompiled. Necessary code, in this context, is
    code that has changed since the last compile cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This enhancement might not get developers excited if they only work on small
    projects. Consider, however, the tremendous gains in efficiency when you continuously
    have to recompile your code for medium and large projects. The time developers
    stand to save is enough reason to embrace JEP 199.
  prefs: []
  type: TYPE_NORMAL
- en: How will this change how you compile your code? It probably will not, at least
    not yet. Javac will remain the default compiler. While sjavac offers efficiencies
    regarding incremental builds, Oracle has deemed it to not have sufficient stability
    to become part of the standard compilation workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more information about the smart javac wrapper tool here: [http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html](http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Lint and Doclint warnings [JEP 212]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do not worry if you are not familiar with Lint or Doclint in Java. As you can
    determine from the section title, they are sources that report warnings to javac.
    Let''s take a look at each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lint** analyzes byte code and source code for javac. The goal of Lint is
    to identify security vulnerabilities in the code being analyzed. Lint can also
    provide insights into scalability and thread locking concerns. There is more to
    Lint, and the overall purpose is to save developers time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more about Lint here: [https://en.wikipedia.org/wiki/Lint_(software)](https://en.wikipedia.org/wiki/Lint_(software)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Doclint** is similar to Lint and is specific to javadoc. Both Lint and Doclint
    report errors and warnings during the compile process. Resolution of these warnings
    was the focus of JEP 212\. When using core libraries, there should not be any
    warnings. This mindset led to JEP 212, which has been resolved and implemented
    in Java 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comprehensive list of the Lint and Doclint warnings can be reviewed in the
    [https://bugs.openjdk.java.net](https://bugs.openjdk.java.net) JDK Bug System.
  prefs: []
  type: TYPE_NORMAL
- en: Tiered attribution for javac [JEP 215]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP 215 represents an impressive undertaking to streamline javac's type checking
    schema. Let's first review how type checking works in Java 8; then we will explore
    the changes in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 8, type checking of poly expressions is handled by a **speculative attribution**
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Speculative attribution is a method of type checking as part of javac's compilation
    process. It has a significant processing overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Using the speculative attribution approach to type checking is accurate, but
    lacks efficiency. These checks include argument position, and are exponentially
    slower when testing in the midst of recursion, polymorphism, nested loops, and
    lambda expressions. So the goal with JEP 215 was to change the type checking schema
    to create faster results. The results themselves were not inaccurate with speculative
    attribution; they were just not generated rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new approach, released with Java 9, uses a tiered attribution tool. This
    tool implements a tiered approach for type checking argument expressions for all
    method calls. Permissions are also made for method overriding. In order for this
    new schema to work, new structural types are created for each of the following
    listed types of method arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poly expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diamond instance creation expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The changes to javac from JEP 215 are more complex than what has been highlighted
    in this section. There is no immediate impact to developers other than a more
    efficient javac and time saved.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations pipeline 2.0 [JEP 217]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java annotations refer to a special kind of metadata that resides inside your
    Java source code files. They are not stripped by javac, so that they can remain
    available to the JVM at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations look similar to JavaDocs references because they start with the
    `@` symbol. There are three types of annotations. Let''s examine each:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic form of annotation is a **marker** annotation. These are standalone
    annotations with the only component being the name of the animation. Here is an
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second type of annotation is one that contains a *single value*, or piece
    of data. As you can see in the following code, the annotation, which starts with
    the `@` symbol, is followed by parentheses containing data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way of coding the single value annotation type is to omit the
    `data=` component, as illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The third type of annotation is when there is *more than one data component*.
    With this type of annotation, the `data=` component cannot be omitted. Here is
    an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what has changed in Java 9? To answer this question, we need to recall
    a couple of changes introduced with Java 8 that impacted Java annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These Java 8 related changes impacted Java annotations, but did not usher in
    a change to how javac processed them. There were some hardcoded solutions that
    allowed javac to handle the new annotations, but they were not efficient. Moreover,
    this type of coding (hardcoding workarounds) is difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: So, JEP 217 focused on refactoring the javac annotation pipeline. This refactoring
    was all internal to javac, so it should not be evident to developers.
  prefs: []
  type: TYPE_NORMAL
- en: New version-string scheme [JEP 223]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Java 9, the release numbers did not follow industry standard versioning--**semantic
    versioning**. For example, at the time of writing, the last four JDK releases
    were:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 8 update 131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 8 update 121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 8 update 112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semantic versioning** uses a major, minor, patch (0.0.0) schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major** equates to new API changes that are not backwards compatible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minor** is when functionality is added that is backwards compatible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Patch** refers to bug fixes or minor changes that are backwards compatible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oracle has embraced semantic versioning for Java 9 and beyond. For Java, a
    **major-minor-security** schema will be used for the first three elements of Java
    version numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: A major release consisting of a significant new set of features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: Revisions and bug fixes that are backwards compatible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Fixes deemed critical to improve security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This description of JEP 223 might make the versioning schema seem basic. To
    the contrary, a very detailed set of rules and practices have been developed to
    manage the future version numbers. To demonstrate the complexity, see the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Generating run-time compiler tests automatically [JEP 233]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is arguably the most used programming language and resides on an increasingly
    diverse number of platforms. This exacerbates the problem of running targeted
    compiler tests in an efficient manner. The purpose of JEP 233 was to create a
    tool that could automate the runtime compiler tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool that was created starts by generating a random set of Java source
    code and/or byte code. The generated code will have three key characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Be syntactically correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be semantically correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a random seed that permits reusing the same randomly-generated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code that is randomly generated will be saved in the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These test cases will be stored for later re-use. They can be run from the `j-treg`
    directory or from the tool's makefile. One of the benefits of re-running saved
    tests is to test the stability of your system.
  prefs: []
  type: TYPE_NORMAL
- en: Testing class-file attributes generated by Javac [JEP 235]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lack of, or insufficient, capability to create tests for class-file attributes
    was the impetus behind JEP 235\. The goal is to ensure javac creates a class-file's
    attributes completely and correctly. This suggests that even if some attributes
    are not used by the class-file, all class-files should be generated with a complete
    set of attributes. There also needs to be a way of testing that the class-files
    were created correctly, in regards to the file's attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Java 9, there was no method of testing a class-file's attributes. Running
    a class and testing the code for anticipated or expected results was the most
    commonly used method of testing javac generated class-files. This technique falls
    short of testing to validate the file's attributes.
  prefs: []
  type: TYPE_NORMAL
- en: There are three categories of class-file attributes--attributes used by the
    JVM, optional attributes, and attributes not used by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes used by the JVM include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BootstrapMethods`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConstantValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exceptions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackMapTable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional attributes include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Deprecated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LineNumberTable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalVariableTable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalVariableTypeTable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SourceDebugExtension`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SourceFile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attributes not used by the JVM include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnnotationDefault`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnclosingMethod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnerClasses`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodParameters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeInvisibleAnnotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeInvisibleParameterAnnotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeInvisibleTypeAnnotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeVisibleAnnotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeVisibleParameterAnnotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeVisibleTypeAnnotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Signature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Synthetic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing interned strings in CDS archives [JEP 250]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method in which strings are stored and accessed to and from **Class Data
    Sharing** (**CDS**) archives is inefficient, excessively time consuming, and wastes
    memory. The following diagram illustrates the method in which Java stores interned
    strings in a CDS archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/326abe1b-f83d-421b-b919-49ff22f1cb89.png)'
  prefs: []
  type: TYPE_IMG
- en: The inefficiency stems from the current storage schema. Especially when the
    **Class Data Sharing** tool dumps the classes into the shared archive file, the
    constant pools containing `CONSTANT_String` items have a UTF-8 string representation.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is an 8-bit variable-length character encoding standard.
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the current use of UTF-8, the strings must be converted to string objects,
    instances of the `java.lang.String` class. This conversion takes place on-demand
    which can result in slower systems and unnecessary memory usage. The processing
    time is extremely short, but the memory usage cannot be overlooked. Every character
    in an interned string requires at least 3 bytes of memory and potentially more.
  prefs: []
  type: TYPE_NORMAL
- en: A related problem is that the stored strings are not accessible to all JVM processes.
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CDS archives now allocate specific space on the heap for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91cce5a8-f4ef-419d-881f-a809d4f600f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The string space is mapped using a shared-string table, hash tables, and deduplication.
  prefs: []
  type: TYPE_NORMAL
- en: Deduplication is a data compression technique that eliminates duplicative information
    in an archive.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing JavaFX UI controls and CSS APIs for modularization [JEP 253]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaFX is a set of packages that permits the design and development of media-rich
    graphical user interfaces. JavaFX applications provide developers with a great
    API for creating a consistent interface for applications. **Cascading Style Sheets**
    (**CSS**) can be used to customize the interfaces. One of the great things about
    JavaFX is that the tasks of programming and interface design can easily be separated.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a wonderful visual scripting tool called Scene Builder that allows
    you to create graphical user interfaces by using drag and drop and property settings.
    Scene Builder generates the necessary FXML files that are used by your **Integrated
    Development Environment** (**IDE**) such as NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample UI created with Scene Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0c58de4-e328-41dd-9ea0-821385a82099.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, here is the FXML file created by Scene Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implications for Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, JavaFX controls as well as CSS functionality were only available
    to developers by interfacing with internal APIs. Java 9's modularization has made
    the internal APIs inaccessible. Therefore, JEP 253 was created to define public,
    instead of internal, APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a larger undertaking than it might seem. Here are a few actions that
    were taken as part of this JEP:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving javaFX control skins from the internal to public API (`javafx.scene.skin`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring API consistencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation of a thorough javadoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following classes were moved from internal packages to a public `javafx.scene.control.skin`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `AccordionSkin` | `ButtonBarSkin` | `ButtonSkin` | `CellSkinBase` |'
  prefs: []
  type: TYPE_TB
- en: '| `CheckBoxSkin` | `ChoiceBoxSkin` | `ColorPickerSkin` | `ComboBoxBaseSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ComboBoxListViewSkin` | `ComboBoxPopupControl` | `ContextMenuSkin` | `DateCellSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DatePickerSkin` | `HyperLinkSkin` | `LabelSkin` | `LabeledSkinBase` |'
  prefs: []
  type: TYPE_TB
- en: '| `ListCellSkin` | `ListViewSkin` | `MenuBarSkin` | `MenuButtonSkin` |'
  prefs: []
  type: TYPE_TB
- en: '| `MenuButtonSkinbase` | `NestedTableColumHeader` | `PaginationSkin` | `ProgressBarSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ProgressIndicatorSkin` | `RadioButtonSkin` | `ScrollBarSkin` | `ScrollPaneSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SeparatorSkin` | `SliderSkin` | `SpinnerSkin` | `SplitMenuButtonSkin` |'
  prefs: []
  type: TYPE_TB
- en: '| `SplitPaneSkin` | `TabPaneSkin` | `TableCellSkin` | `TableCellSkinBase` |'
  prefs: []
  type: TYPE_TB
- en: '| `TableColumnHeader` | `TableHeaderRow` | `TableHeaderSkin` | `TableRowSkinBase`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TableViewSkin` | `TableViewSkinBase` | `TextAreaSkin` | `TextFieldSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TextInputControlSkin` | `TitledPaneSkin` | `ToggleButtonSkin` | `TooBarSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TooltipSkin` | `TreeCellSkin` | `TreeTableCellSkin` | `TreeTableRowSkin`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TreeTableViewSkin` | `TreeViewSkin` | `VirtualContainerBase` | `VirtualFlow`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The public `javafx.css` package now has the additional classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CascadingStyle.java:public class CascadingStyle implements Comparable<CascadingStyle>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompoundSelector.java:final public class CompoundSelector extends Selector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CssError.java:public class CssError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Declaration.java:final public class Declaration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rule.java:final public class Rule`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.java:abstract public class Selector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleSelector.java:final public class SimpleSelector extends Selector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Size.java:final public class Size`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Style.java:final public class Style`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stylesheet.java:public class Stylesheet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CssParser.java:final public class CssParser`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact strings [JEP 254]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string data type is an important part of nearly every Java app. While JEP
    254's aim was to make strings more space-efficient, it was approached with caution
    so that existing performance and compatibilities would not be negatively impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-Java 9 status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, string data was stored as an array of chars. This required
    16 bits for each char. It was determined that the majority of String objects could
    be stored with only 8 bits, or 1 byte of storage. This is due to the fact that
    most strings consist of Latin-1 characters.
  prefs: []
  type: TYPE_NORMAL
- en: The ISO Latin-1 Character Set is a single-byte set of character's encodings.
  prefs: []
  type: TYPE_NORMAL
- en: New with Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with Java 9, strings are now internally represented using a byte array
    along with a flag field for encoding references.
  prefs: []
  type: TYPE_NORMAL
- en: Merging selected Xerces 2.11.0 updates into JAXP [JEP 255]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xerces is a library used for parsing XML in Java. It was updated to 2.11.0 in
    late 2010, so JEP 255's aim was to update JAXP to incorporate changes in Xerces
    2.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: JAXP is Java's API for XML processing.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Java 9, the JDK's latest update regarding XML processing was based
    on Xerces 2.7.1\. There were some additional changes to JDK 7 based on Xerces,
    2.10.0\. JEP 255 is a further refinement of the JAXP based on Xerces 2.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xerces 2.11.0 supports the following standards:'
  prefs: []
  type: TYPE_NORMAL
- en: XML 1.0, Fourth Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces in XML 1.0, Second Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML 1.1, Second Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces in XML 1.1, Second Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Inclusions 1.0, Second Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document Object Model** (**DOM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Load & save
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Level 2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversal & Range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element Traversal, First Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple API for XML 2.0.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java APIs for XML Processing** (**JAXP**) 1.4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming API for XML 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Schema 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Schema 1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Schema Definition Language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JDK was updated to include the following Xerces 2.11.0 categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Catalog resolver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datatypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document Object Model Level 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Schema Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XPointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public API for JAXP was not changed in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Updating JavaFX/Media to newer version of GStreamer [JEP 257]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaFX is used for creating desktop and web applications. JavaFX was created
    to replace Swing as Java''s standard GUI library. The `Media` class, `javafx.scene.media.Media`,
    is used to instantiate an object representing a media resource. JavaFX/Media refers
    to the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This class provides referential data to a media resource. The `javafx.scene.media`
    package provides developers with the ability to incorporate media into their JavaFX
    applications. JavaFX/Media utilizes a GStreamer pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: GStreamer is a multimedia processing framework that can be used to build systems
    that take in media from several different formats and, after processing, export
    them in selected formats.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of JEP 257 was to ensure JavaFX/Media was updated to include the
    latest release of GStreamer for stability, performance, and security assurances.
  prefs: []
  type: TYPE_NORMAL
- en: HarfBuzz Font-Layout Engine [JEP 258]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, the layout engine used to handle font complexities; specifically
    fonts that have rendering behaviors beyond what the common Latin fonts have. Java
    used the uniform client interface, also referred to as ICU, as the defacto text
    rendering tool. The ICU layout engine has been depreciated and, in Java 9, has
    been replaced with the HarfBuzz font layout engine.
  prefs: []
  type: TYPE_NORMAL
- en: HarfBuzz is an **OpenType** text rendering engine. This type of layout engine
    has the characteristic of providing script-aware code to help ensure text is laid
    out as desired.
  prefs: []
  type: TYPE_NORMAL
- en: OpenType is an HTML formatted font format specification.
  prefs: []
  type: TYPE_NORMAL
- en: The impetus for the change from the ICU Layout Engine to the HarfBuzz Font Layout
    Engine was IBM's decision to cease supporting the ICU Layout Engine. Therefore,
    the JDK was updated to contain the HarfBuzz Font Layout Engine.
  prefs: []
  type: TYPE_NORMAL
- en: HiDPI graphics on Windows and Linux [JEP 263]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JEP 263 was focused on ensuring the crispness of on-screen components, relative
    to the pixel density of the display. The following terms are relevant to this
    JEP and are provided along with the below listed descriptive information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DPI-aware application**: An application that is able to detect and scale
    images for the display''s specific pixel density'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DPI-unaware application**: An application that makes no attempt to detect
    and scale images for the display''s specific pixel density'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HiDPI graphics**: High dots-per-inch graphics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retina display**: This term was created by Apple to refer to displays with
    a pixel density of at least 300 pixels per inch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Displaying graphics, both images and graphical user interface components, to
    the user is typically of paramount performance. Displaying this imagery in high
    quality can be somewhat problematic. There is large variability in computer monitor
    DPIs. There are three basic approaches to developing for displays:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop apps without regard for the potential different display dimensions.
    In other words, create a DPI-unaware application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a DPI-aware application that selectively uses pre-rendered image sizes
    for a given display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a DPI-aware application that properly scales images up/down to account
    for the specific display the application is run on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, the first two approaches are problematic, and for different reasons.
    With the first approach, the user experience is not considered. Of course, if
    the application was being developed for a very specific display with no expected
    pixel density variability, then this approach could be viable.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach requires a lot of work on the design and development end
    to ensure images for each expected display density are created and implemented
    programmatically. In addition to the tremendous amount of work, the app size will
    unnecessarily increase, and new and different pixel densities will not have been
    accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: The third approach is to create a DPI-aware application with efficient and effective
    scaling capabilities. This approach works well and has been proven with the Mac
    retina displays.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Java 9, automatic scaling and sizing was already implemented in Java
    for the Mac OS X operating system. This capability was added in Java 9 for Windows
    and Linux operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Marlin graphics renderer [JEP 265]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP 265 replaced the Pisces graphics rasterizer with the Marlin graphics renderer
    in the Java 2D API. This API is used to draw 2D graphics and animations.
  prefs: []
  type: TYPE_NORMAL
- en: The goal was to replace Pisces with a rasterizer/renderer that was much more
    efficient and without any quality loss. This goal was realized in Java 9\. An
    intended collateral benefit was to include a developer-accessible API. Previously,
    the means of interfacing with the AWT and Java 2D was internal.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode 8.0.0 [JEP 267]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unicode 8.0.0 was released on June 17, 2015\. JEP 267 focused on updating the
    relevant APIs to support Unicode 8.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: New in Unicode 8.0.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unicode 8.0.0 added nearly 8,000 characters. Here are the highlights of the
    release:'
  prefs: []
  type: TYPE_NORMAL
- en: Ahom script for the Tai Ahom language (India)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arwi, Tamil language (Arabic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cherokee symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CJK unified ideographs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emoji symbols along with flesh-tone symbol modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Georgian lari currency symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lk language (Uganda)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kulango languge (Côte d’Ivoire)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated Classes in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to fully comply with the new Unicode standard, several Java classes
    were updated. The following listed classes were updated for Java 9 to comply with
    the new Unicode standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.awt.font.NumericShaper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Character`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.text.Bidi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.text.BreakIterator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.text.Normalizer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved stack areas for critical sections [JEP 270]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of JEP 270 was to mitigate problems stemming from stack overflows during
    the execution of critical sections. This mitigation took the form of reserving
    additional thread stack space.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-Java 9 situation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JVM throws a `StackOverflowError` when it is asked to perform data computation
    in a thread that has insufficient stack space and does not have permission to
    allocate additional space. This is an asynchronous exception. The JVM can also
    throw the `StackOverflowError` exception synchronously when a method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: When a method is invoked, an internal process is used to report the Stack Overflow.
    While the current schema works sufficiently for reporting the error, there is
    no room for the calling application to easily recover from the error. This can
    result in being more than a nuisance for developers and users. If the `StackOverflowError`
    was thrown during a critical computational operation, the data might be corrupted,
    causing additional problems.
  prefs: []
  type: TYPE_NORMAL
- en: While not the sole cause of these problems, the effected status of locks from
    the `ReentrantLock` class were a common cause of undesirable outcomes. This issue
    was evident in Java 7 because the `ConcurrentHasMap` code implemented the `ReentrantLock`
    class. The `ConcurrentHasMap` code was modified for Java 8, but problems still
    persisted for any implementation of the `ReentrantLock` class. Similar problems
    existed beyond just `ReentrantLock` class usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a broad overview of the `StackOverflowError`
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49c4c434-1548-47f8-84e9-c74bce5c3901.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at how this issue was resolved for Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: New in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the JEP 270 changes for Java 9, a critical section will automatically be
    given additional space so that it can complete its execution and not suffer from
    the `StackOverflowError`. This is predicated on the additional space allocation
    needs being small. The necessary changes have been made to the JVM to permit this
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JVM actually delays the `StackOverflowError`, or at least attempts to,
    while critical sections are executing. In order to capitalize on this new schema,
    methods must be annotated with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When a method has this annotation and a `StackOverflowError` condition exists,
    temporary access to the reserved memory space is granted. The new process is,
    at a high level of abstraction, presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f576b05c-8b60-454e-bb51-3972d50dd8d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic linking of language-defined object models [JEP 276]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java interoperability was enhanced with JEP 276\. The necessary JDK changes
    were made to permit runtime linkers from multiple languages to coexist in a single
    JVM instance. This change applies to high-level operations, as you would expect.
    An example of a relevant high-level operation is the reading or writing of a property
    with elements such as accessors and mutators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level operations apply to objects of unknown types. They can be invoked
    with `INVOKEDYNAMIC` instructions. Here is an example of calling an object''s
    property when the object''s type is unknown at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Proof of concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nashorn is a lightweight, high-performance, JavaScript runtime that permits
    embedding JavaScript in Java applications. This was created for Java 8 and replaced
    the previous JavaScript scripting engine that was based on Mozilla Rhino. Nashorn
    already has this functionality. It provides linkage between high-level operations
    on any object of unknown type, such as `obj.something`, where it produces the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic linker springs into action and provides, when possible, the appropriate
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tests for humongous objects in G1 [JEP 278]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the long-favored features of the Java platform is the behind the scenes
    garbage collection. JEP 278's focus was to create additional WhiteBox tests for
    humongous objects as a feature of the G1 garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: WhiteBox testing is an API used to query JVM internals. The WhiteBox testing
    API was introduced in Java 7 and upgraded in Java 8 and Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The G1 garbage collector works extremely well, but there was room for some
    improved efficiency. The way the G1 garbage collector worked is based on first
    dividing the heap into regions of equal size, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e81f892-f803-458c-ae5b-7f080daa6710.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem with the G1 garbage collector was how humongous objects were handled.
  prefs: []
  type: TYPE_NORMAL
- en: A humongous object in the context of garbage collection, is any object that
    takes up more than one region on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with humongous objects was that if they took up any part of a region
    on the heap, the remaining space was not able to be allocated for other objects.
    In Java 9, the WhiteBox API was extended with four types of new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods with the purpose of blocking full garbage collection and to initiate
    concurrent marking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that can access individual G1 garbage collection heap regions. Access
    to these regions consist of attribute reading, such as with the current state
    of the region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods with direct access to the G1 garbage collection internal variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that can determine if humongous objects reside on the heap and, if so,
    in what regions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving test-failure troubleshooting [JEP 279]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For developers that do a lot of testing, JEP 279 is worth reading about. Additional
    functionality has been added in Java 9 to automatically collect information to
    support troubleshooting test failures as well as timeouts. Collecting readily
    available diagnostic information during tests stands to provide developers and
    engineers with greater fidelity in their logs and other output.
  prefs: []
  type: TYPE_NORMAL
- en: There are two basic types of information in the context of testing--environmental
    and process.
  prefs: []
  type: TYPE_NORMAL
- en: Environmental information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When running tests, the testing environment information can be important for
    troubleshooting efforts. This information includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU loads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O loads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java process information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is also information available during the testing process directly related
    to Java processes. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: C stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core dumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini dumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For additional information on this concept, read about the JDK's regression
    test harness (jtreg).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing string concatenation [JEP 280]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JEP 280 is an interesting enhancement for the Java platform. Prior to Java
    9, string concatenation was translated by javac into `StringBuilder : : append`
    chains. This was a sub-optimal translation methodology often requiring `StringBuilder`
    presizing.'
  prefs: []
  type: TYPE_NORMAL
- en: The enhancement changed the string concatenation bytecode sequence, generated
    by javac, so that it uses `INVOKEDYNAMIC` calls. The purpose of the enhancement
    was to increase optimization and to support future optimizations without the need
    to reformat the javac's bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: See JEP 276 for more information on `INVOKEDYNAMIC`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `INVOKEDYAMIC` calls to `java.lang.invoke.StringConcatFactory` allows
    us to use a methodology similar to lambda expressions instead of using StringBuilder's
    step-wise process. This results in more efficient processing of string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: HotSpot C++ unit-test framework [JEP 281]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HotSpot is the name of the JVM. This Java enhancement was intended to support
    the development of C++ unit tests for the JVM. Here is a partial, non-prioritized,
    list of goals for this enhancement:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create appropriate documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug compile targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework elasticity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual and isolated unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individualized test results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with existing infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal test support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positive and negative testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short execution time testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support all JDK 9 build platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test compile targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test exclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test grouping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing that requires the JVM to be initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests co-located with source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests for platform-dependent code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write and execute unit testing (for classes and methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enhancement is evidence of the increasing extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling GTK 3 on Linux [JEP 283]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GTK+, formally known as the GIMP toolbox, is a cross-platform tool used for
    creating **Graphical User Interfaces** (**GUI**). The tool consists of widgets
    accessible through its API. JEP 283's focus was to ensure GTK 2 and GTK 3 were
    supported on Linux when developing Java applications with graphical components.
    The implementation supports Java apps that employ JavaFX, AWT, and Swing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create Java graphical applications with JavaFX, AWT, and Swing. Here
    is a table to summarize those three approaches as they relate to GTK, prior to
    Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Approach** | **Remarks** |'
  prefs: []
  type: TYPE_TB
- en: '| JavaFX |'
  prefs: []
  type: TYPE_TB
- en: Uses a dynamic GTK function lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacts with AWT and Swing via JFXPanel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses AWT printing functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| AWT |'
  prefs: []
  type: TYPE_TB
- en: Uses a dynamic GTK function lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Swing |'
  prefs: []
  type: TYPE_TB
- en: Uses a dynamic GTK function lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what changes were necessary to implement this JEP? For JavaFX, three specific
    things were changed:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing was added for both GTK 2 and GTK 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functionality was added to dynamically load GTK 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support was added for GTK 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For AWT and Swing, the following changes were implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing was added for both GTK 2 and GTK 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AwtRobot` was migrated to GTK 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileChooserDilaog` was updated for GTK 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functionality was added to dynamically load GTK 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swing GTK LnF was modified to support GTK 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swing GTK LnF is short for Swing GTK look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: New HotSpot build system [JEP 284]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java platform used, prior to Java 9, was a build system riddled with duplicate
    code, redundancies, and other inefficiencies. The build system has been reworked
    for Java 9 based on the build-infra framework. In this context, infra is short
    for infrastructure. The overarching goal for JEP 284 was to upgrade the build
    system to one that was simplified. Specific goals included:'
  prefs: []
  type: TYPE_NORMAL
- en: Leverage existing build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize duplicate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support future enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about Oracle''s infrastructure framework at this site: [http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html](http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some impressive new features of the Java platform,
    with specific focus on javac, JDK libraries, and various test suites. Memory management
    improvements, including heap space efficiencies, memory allocation, and improved
    garbage collection represent a powerful new set of Java platform enhancements.
    Changes regarding the compilation process resulting in greater efficiencies were
    part of our chapter. We also covered important improvements, such as with the
    compilation process, type testing, annotations, and automated runtime compiler
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at several minor language enhancements introduced
    in Java 9.
  prefs: []
  type: TYPE_NORMAL
