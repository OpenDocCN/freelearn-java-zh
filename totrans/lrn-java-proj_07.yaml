- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: In [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118), we learned about arrays
    in Java. We learned that arrays are data structures that are fixed in size. They
    are stored in contiguous memory locations where each location is of the same type.
    We also saw how to declare, initialize, and process arrays. Both the traditional
    and enhanced `for` loops are ideal for processing arrays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19793_06.xhtml#_idTextAnchor118)中，我们学习了Java中的数组。我们了解到数组是固定大小的数据结构。它们存储在连续的内存位置中，每个位置的数据类型相同。我们还看到了如何声明、初始化和处理数组。传统和增强的`for`循环都非常适合处理数组。
- en: In addition, we discussed multi-dimensional arrays, including how they are organized
    and how to process them. Lastly, as arrays are very common, we discussed the `Arrays`
    class, which has several useful methods for processing arrays.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了多维数组，包括它们的组织方式和处理方法。最后，由于数组非常常见，我们讨论了`Arrays`类，它有几个用于处理数组的实用方法。
- en: In this chapter, we will cover methods. Methods enable us to create a named
    block of code that can be executed from elsewhere in the code. Firstly, we will
    explain why methods are so commonplace. You will learn the difference between
    the method definition and the method invocation. We will explore what a method
    signature is and how method overloading enables methods to have the same name,
    without conflict. We will also explain variable arguments (`varargs`), which enable
    a method to be executed with 0 or more arguments. Lastly, Javas’ principle of
    call-by-value for passing arguments (and returning values) will be outlined. By
    the end of this chapter, you will be well able to code and execute methods. In
    addition, you will understand method overloading, `varargs`, and Javas’ call-by-value
    mechanism.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍方法。方法使我们能够创建一个可以执行于代码其他部分的命名代码块。首先，我们将解释为什么方法如此普遍。您将学习方法定义和方法调用的区别。我们将探讨方法签名是什么，以及方法重载如何使方法具有相同的名称，而不产生冲突。我们还将解释变量参数（`varargs`），它允许方法以0个或多个参数执行。最后，我们将概述Java的按值传递参数（和返回值）的原则。到本章结束时，您将能够编写和执行方法。此外，您将理解方法重载、`varargs`和Java的按值调用机制。
- en: 'This chapter covers the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Explaining why methods are important
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释为什么方法很重要
- en: Understanding the difference between method definition and method execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解方法定义和方法执行之间的区别
- en: Exploring method overloading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: Explaining `varargs`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`varargs`
- en: Mastering call by value
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握按值调用
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7)。
- en: Explaining why methods are important
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释为什么方法很重要
- en: Methods are code blocks that are given a name for ease of reference. They can
    accept inputs and return an output. Both the inputs and output are optional. A
    method should do one task and do it well. It is considered good practice to keep
    your methods short (less than 20 lines). The longer the method, the more likely
    it is that the method is doing too much. The maxim of “keep it simple” applies
    here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是为便于引用而命名的代码块。它们可以接受输入并返回输出。输入和输出都是可选的。方法应该完成一个任务并且做得很好。将方法保持简短（少于20行）被认为是良好的实践。方法越长，它做得多的事情就越多。这里的“保持简单”的原则适用。
- en: Flow of control
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流程
- en: 'Simply put, when a method is called (executed), the normal flow of control
    of execution is changed. Let us discuss a simple example that will help demonstrate
    this. This is an important point to appreciate, especially for inexperienced developers.
    *Figure 7**.1* presents the code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当方法被调用（执行）时，执行的控制流程会发生变化。让我们讨论一个简单的例子，这将有助于展示这一点。这是一个重要的观点，特别是对于经验不足的开发者来说。*图7.1*展示了代码：
- en: '![Figure 7.1 – A very simple method](img/B19793_07_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 一个非常简单的函数](img/B19793_07_1.jpg)'
- en: Figure 7.1 – A very simple method
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 一个非常简单的函数
- en: 'In this example, we have two methods: the `main()` method (lines 4 to 8) and
    the `simpleExample()` method (lines 9 to 11). Both exist inside the `Methods`
    class (lines 3 to 12).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个方法：`main()`方法（第4至8行）和`simpleExample()`方法（第9至11行）。它们都存在于`Methods`类中（第3至12行）。
- en: In Java, every program starts with the `main()` method. The JVM calls it on
    our behalf; we do not have to call (or execute) it ourselves. Therefore, in this
    example, the first line in `main()`, line 5, is the first line to execute.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个程序都以`main()`方法开始。JVM代表我们调用它；我们不必自己调用（或执行）它。因此，在这个例子中，`main()`中的第一行，第5行，是第一条要执行的行。
- en: Line 6 is important – it is what we refer to as a method call. There is a direct
    correlation between the `simpleExample()` method definition on line 9 and the
    method call on line 6\. We will discuss this relationship shortly. For the moment,
    just understand that the method call changes the order of execution of the program.
    Normally, Java executes lines of code from top to bottom and this is true. However,
    *method calls alter that*. In this example, when line 6 executes, the next line
    to execute is line 10 (inside the `simpleExample()` method).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行很重要——这就是我们所说的方法调用。第9行的`simpleExample()`方法定义与第6行的方法调用之间存在直接关联。我们将在稍后讨论这种关系。目前，只需理解方法调用改变了程序的执行顺序。通常，Java从上到下执行代码行，这是真的。然而，*方法调用改变了这一点*。在本例中，当第6行执行时，接下来要执行的行是第10行（在`simpleExample()`方法内部）。
- en: So, the `main()` method has now handed over control to the `simpleExample()`
    method, and control will not return to `main()` until `simpleExample()` exits.
    This can occur when execution hits the closing `}` at the end of the `simpleExample()`
    method (line 11). This is what happens in this example. Alternatively, a method
    can exit by using the `return` keyword.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`main()`方法现在已经将控制权交给了`simpleExample()`方法，并且只有在`simpleExample()`方法退出后，控制才会返回到`main()`。这可以在执行到`simpleExample()`方法末尾的闭合`}`时发生（第11行）。这正是本例中的情况。或者，一个方法可以通过使用`return`关键字来退出。
- en: So, line 6 calls the `simpleExample()` method, causing its code to execute.
    Line 10 outputs some text to the screen. The closing `}` on line 11 causes `simpleExample()`
    to exit and control now returns to `main()`, where execution resumes at line 7.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第6行调用了`simpleExample()`方法，导致其代码执行。第10行将一些文本输出到屏幕上。第11行的闭合`}`导致`simpleExample()`退出，现在控制权返回到`main()`，执行从第7行恢复。
- en: 'In summary, the order of execution in this program is illustrated by the output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个程序的执行顺序可以通过输出来说明：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you can see that `println()`, inside the `simpleExample()` method, is
    sandwiched between the two `println()` statements from `main()`. This demonstrates
    that the flow of control was altered by the method call on line 6.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`println()`，在`simpleExample()`方法内部，被`main()`方法中的两个`println()`语句所包围。这表明控制流在第六行的方法调用中被改变。
- en: The stack
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: So, how can a caller method, such as `main()`, simply *resume* where it left
    off after the `simpleExample()` method returns? What about the local variables
    of `main()`?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，调用方法，例如`main()`，如何在`simpleExample()`方法返回后简单地*恢复*到它离开的地方？`main()`的局部变量又是如何的呢？
- en: The ability of a method to resume exactly where it left off, after the method
    it called returns, requires the use of a memory structure called the *stack*.
    We will discuss the stack later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方法能够在调用它的方法返回后精确地恢复到它离开的地方，这需要使用一种称为*栈*的内存结构。我们将在本章后面讨论栈。
- en: Returning to our *why methods are important’ discussion*, two major advantages
    of methods are that they provide abstraction and avoid code duplication. Let’s
    examine these in turn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们关于“为什么方法很重要”的讨论，方法的主要优势有两个：它们提供了抽象并避免了代码重复。我们将依次探讨这些优势。
- en: Abstraction
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is a principle in software engineering where clients of a service,
    are abstracted from the service implementation. This decouples clients, who use
    the service, from knowing how the service is implemented. Thus, if the service
    implementation is changed, the clients are not impacted.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是软件工程中的一个原则，其中服务的客户端被从服务实现中抽象出来。这解耦了使用服务的客户端，使他们不必知道服务是如何实现的。因此，如果服务实现发生变化，客户端不会受到影响。
- en: Take, for example, a McDonald’s drive-thru where you drive up and place your
    order. In this situation, you are the client of the McDonald’s service. You do
    not care how McDonald’s process your order; you simply want to place an order
    and receive the food/drinks. If McDonald’s changes its internal implementation,
    you are shielded (abstracted) from those changes. This is known as abstraction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以麦当劳的免下车服务为例，你开车到那里并下订单。在这种情况下，你是麦当劳服务的客户。你不在乎麦当劳如何处理你的订单；你只是想下订单并收到食物/饮料。如果麦当劳更改其内部实现，你会受到保护（抽象化）免受这些更改的影响。这被称为抽象。
- en: For our purposes, the method itself is the McDonald’s service. The method call
    is the McDonald’s customer. The method call is abstracted from internal changes
    to the method code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的而言，方法本身就像是麦当劳的服务。方法调用就像是麦当劳的客户。方法调用抽象了方法代码的内部变化。
- en: Code duplication
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重复
- en: 'Methods can help us avoid code replication. This has the added benefit of easing
    debugging. Let’s look at a simple example of this. *Figure 7**.2* demonstrates
    duplicated code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以帮助我们避免代码重复。这还有一个额外的优点，就是简化调试。让我们来看一个简单的例子。*图 7.2* 展示了重复的代码：
- en: '![Figure 7.2 – Duplicated code](img/B19793_07_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 重复的代码](img/B19793_07_2.jpg)'
- en: Figure 7.2 – Duplicated code
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 重复的代码
- en: In the preceding figure, lines 8 to 12 are repeated on lines 14 to 18 and lines
    20 to 24\. Each of these sections prompts the user for a number, stores the user
    input in a variable named `number`, and checks to see if the number is in range.
    If the number is out of range, then an error is flagged. While a loop would be
    an obvious improvement, bear in mind that these lines of code could well be in
    separate parts of the program. In addition, for this simple example, we are only
    interested in highlighting code duplication. We simply prompt for a number, accept
    the user’s input, and validate it. The result is five lines of code repeated three
    times.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第 8 行到第 12 行在第 14 行到第 18 行重复，第 20 行到第 24 行也重复。这些部分中的每一个都提示用户输入一个数字，将用户输入存储在名为
    `number` 的变量中，并检查该数字是否在范围内。如果数字超出范围，则标记错误。虽然循环会是一个明显的改进，但请记住，这些代码行可能位于程序的单独部分。此外，对于这个简单的例子，我们只对突出代码重复感兴趣。我们只是提示输入一个数字，接受用户的输入，并验证它。结果是五行代码重复了三次。
- en: 'Now, let’s assume that we want to adjust the upper valid range from 10 to 100\.
    We have to change the prompts on lines 8, 14, and 20\. In addition, the `if` statements
    on lines 10, 16, and 22 need to change. Thus, a simple range adjustment has resulted
    in quite a few code changes and we could easily forget to make one or more of
    the changes required. Let’s refactor the code into a method. *Figure 7**.3* shows
    the refactored code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将有效范围从 10 调整到 100。我们必须修改第 8、14 和 20 行的提示。此外，第 10、16 和 22 行的 `if` 语句也需要修改。因此，简单的范围调整导致了相当多的代码更改，我们很容易忘记进行一个或多个必要的更改。让我们将代码重构为一个方法。*图
    7.3* 展示了重构后的代码：
- en: '![Figure 7.3 – The code from Figure 7.2 refactored to use a method](img/B19793_07_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 将图 7.2 中的代码重构为使用方法](img/B19793_07_3.jpg)'
- en: Figure 7.3 – The code from Figure 7.2 refactored to use a method
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 将图 7.2 中的代码重构为使用方法
- en: In the preceding figure, the method itself is coded from lines 9 to 17 and will
    be explained in detail in the next section. The five lines of repeated code from
    *Figure 7**.2* are coded only once, on lines 11 to 15\. The execution calls of
    the method are on lines 5, 6, and 7; one execution call per line. If we want to
    change the upper valid range from 10 to 100, we just need to change the method
    – that is, lines 11 and 13\. These two changes are *automatically* reflected throughout
    the code. In effect, the three method calls on lines 5, 6, and 7 automatically
    reflect the changes made in the method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，方法本身是从第 9 行到第 17 行编写的，将在下一节中详细解释。*图 7.2* 中的五行重复代码只在第 11 行到第 15 行编写了一次。方法的执行调用在第
    5、6 和 7 行；每行一个执行调用。如果我们想将有效范围从 10 调整到 100，我们只需修改方法即可——即第 11 和第 13 行。这两个更改会*自动*反映在整个代码中。实际上，第
    5、6 和 7 行的三个方法调用会自动反映方法中的更改。
- en: As you can imagine, this situation scales very well. For example, if, in *Figure
    7**.2*, we had duplicated the code 10 times, we would have to make changes in
    10 areas of the code. However, with the method implementation, there is still
    *only one* location to make the change and that is in the method itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这种情况非常易于扩展。例如，如果在*图 7.2* 中我们重复了代码 10 次，我们就需要在代码的 10 个区域进行更改。然而，有了方法实现，仍然只有*一个*地方需要更改，那就是方法本身。
- en: Now that we have justified why methods exist, let’s examine the difference between
    the method itself and the method call.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解释了为什么需要方法，让我们来检查方法本身和方法调用之间的区别。
- en: Understanding the difference between method definition and method execution
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解方法定义和方法执行之间的区别
- en: For those new to programming, it may surprise you to know that there are two
    parts to having a method *do* something. Firstly, we must code the method (the
    method definition). This is similar to a bank machine on the street – it just
    sits there, doing nothing, waiting to be used. Secondly, we must execute the method
    (the method execution). This is similar to a customer “using” the bank machine.
    Remember that the `main` method is the only method that is automatically executed
    by the JVM. Any other method calls have to be explicitly coded.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编程新手来说，可能会惊讶地知道，要让方法*做*某事有两个部分。首先，我们必须编写方法（方法定义）。这类似于街上的自动取款机 – 它只是静静地坐着，什么也不做，等待被使用。其次，我们必须执行方法（方法执行）。这类似于客户“使用”自动取款机。记住，`main`方法是唯一由JVM自动执行的方法。任何其他方法调用都必须明确编码。
- en: Now, let’s examine the method definition and method execution in turn.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们依次检查方法定义和方法执行。
- en: Method definition
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法定义
- en: 'The method definition (declaration) is the method code itself - this is the
    block of code that is executed when the method is called. *Figure 7**.4* presents
    the syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义（声明）本身就是方法代码 - 这是在调用方法时执行的代码块。*图7.4* 展示了语法：
- en: '![Figure 7.4 – The syntax of the method definition](img/B19793_07_4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 方法定义的语法](img/B19793_07_4.jpg)'
- en: Figure 7.4 – The syntax of the method definition
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 方法定义的语法
- en: In the preceding figure, as in other figures, square brackets signify optional
    elements. The `access-modifier` and `static` elements will be discussed in [*Chapter
    8*](B19793_08.xhtml#_idTextAnchor168). The `throws` `someException` element will
    be covered in [*Chapter 11*](B19793_11.xhtml#_idTextAnchor266). In this chapter,
    we will focus on the elements in bold; namely, `return-type` (mandatory), `methodName`
    (mandatory), and `parameters` (optional).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，与其他图一样，方括号表示可选元素。`access-modifier` 和 `static` 元素将在[*第8章*](B19793_08.xhtml#_idTextAnchor168)中讨论。`throws`
    `someException` 元素将在[*第11章*](B19793_11.xhtml#_idTextAnchor266)中介绍。在本章中，我们将重点关注加粗的元素；即，`return-type`（必需）、`methodName`（必需）和`parameters`（可选）。
- en: The return type of the method can be a primitive type, a reference type, or
    `void`. The `void` keyword means that the method is not returning anything. If
    that is the case, you *cannot* simply leave out the return type; you must specify
    `void`. In addition, when you’re not returning anything from a method, you can
    specify `return;` or simply leave out the `return` keyword altogether (which is
    what we have done for all the `main()` methods).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '方法的返回类型可以是原始类型、引用类型或`void`。`void`关键字表示该方法不返回任何内容。如果是这种情况，你*不能*简单地省略返回类型；你必须指定`void`。此外，当你从方法中不返回任何内容时，你可以指定`return;`或完全省略`return`关键字（这是我们为所有`main()`方法所做的那样）。 '
- en: 'Let’s examine a method that accepts input and returns a result. *Figure 7**.5*
    presents such an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个接受输入并返回结果的方法。*图7.5* 展示了这样一个例子：
- en: '![Figure 7.5 – Sample method definition](img/B19793_07_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 示例方法定义](img/B19793_07_5.jpg)'
- en: Figure 7.5 – Sample method definition
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 示例方法定义
- en: In the preceding figure, we have a method that takes in two integers and a mathematical
    operation to be performed using the two integers as operands. For example, if
    `"+"` is passed in, the two numbers are added and the result is returned. Let’s
    review how the method does this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个接受两个整数和一个要使用这两个整数作为操作数执行数学运算的方法。例如，如果传入`"+"`，则两个数字相加并返回结果。让我们回顾一下方法是如何做到这一点的。
- en: Line 15 is very important. For the moment, as stated earlier, [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168)
    will explain both `public` (access-modifier) and `static`. The `return-type` is
    an `int` – meaning, this method returns whole numbers. The name of the method
    is `performCalc`. Method names often begin with verbs and follow camel casing
    style.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行非常重要。目前，如前所述，[*第8章*](B19793_08.xhtml#_idTextAnchor168)将解释`public`（访问修饰符）和`static`。`return-type`是`int`
    – 这意味着这个方法返回整数。方法的名字是`performCalc`。方法名通常以动词开头，并遵循驼峰命名法。
- en: Note that round brackets follow the method name. The round brackets are delimiters
    for the optional input parameters to the method. For each parameter, you must
    specify the data type of the parameter (as Java is a strongly typed language)
    and the parameter’s identifier name. If you have two or more parameters, comma-separate
    them. These parameters are how the method accepts input. In *Figure 7**.5*, we
    have two integers namely `x` and `y`, followed by a `String` called `operation`.
    The scope of any method parameters, in this case, `x`, `y`, and `operation`, is
    the whole of the method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Lines 16-26 encapsulate a `switch` expression. In effect, depending on the mathematical
    `operation` passed in, that operation is performed on the two inputs, `x` and
    `y`. The local `int` variable, `result`, is initialized accordingly. The `result`
    variable is returned on line 27\. As the return type declared on line 15 is an
    `int`, returning `result`, which is also an `int`, is fine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: A method definition in and of itself does not do anything. It just defines a
    block of code. As stated previously, this is similar to a bank machine on the
    street – it just sits there, doing nothing, waiting to be used. For the bank machine
    to be useful, you must “use” it. Similarly, we must “use” the method – this is
    what we call executing the method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Method execution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Executing the method is also known as calling or invoking the method. The method
    that calls the method is known as the “calling” (or caller) method. So, you have
    the calling method and the called method. When you call a method, you pass down
    the required arguments, if there are any. The called method will execute at this
    point. When the called method finishes, control returns to the caller method.
    The called method’s result, if there is one, is also returned. This enables the
    called method to return data to the caller method, where it can be output to the
    screen, stored in a variable, or simply ignored.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Method parameters versus method arguments
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The method definition defines parameters, whereas the method call passes down
    arguments. These terms are often used interchangeably.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.6* presents a code example to help explain this further:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Sample code demonstrating method calls](img/B19793_07_6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Sample code demonstrating method calls
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA inlay hints
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the IntelliJ editor inserts inlay hints when you are coding. In the
    previous figure, the `performCalc` method signature (line 13) specifies that the
    parameters are namely `x`, `y`, and `operation`. That is why on each method call,
    the inlay hint uses these parameter names. For example, on line 5, we typed in
    10 as the first argument; however, IntelliJ, upon inspecting the method signature,
    realized that 10 was mapping to ‘x’ and that is why you see “`performCalc(10,
    2, "+")` and IntelliJ converted that to `performCalc(x: 10, y: 2,` `operation:
    "+").`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.6*, the `performCalc` method (lines 13-26) is unchanged from
    *Figure 7**.5*. However, we can now see the various method calls (lines 5 and
    7-11).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7**.6中，`performCalc`方法（第13-26行）与**图7**.5中的没有变化。然而，我们现在可以看到各种方法调用（第5行和第7-11行）。
- en: Let’s start with line 5\. On the right-hand side of the assignment, we have
    the `performCalc(10, 2, "+")` method call. This method call has higher precedence
    than the assignment, so it is executed first. The IntelliJ IDE does a very nice
    job of highlighting that `10` will be passed into the method as `x`, `2` will
    be passed into the method as `y`, and `"+"` will be passed in as `operation`.
    It is very important to realize that once we get to the method call on line 5,
    the next line of code that’s executed is line 14 – so, from line 5, we jump into
    the `performCalc` method and start executing the `switch` expression on line 14.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第5行开始。在赋值的右侧，我们有`performCalc(10, 2, "+")`方法的调用。这个方法调用比赋值有更高的优先级，所以它首先被执行。IntelliJ
    IDE非常出色地突出显示了`10`将被作为`x`传递给方法，`2`将被作为`y`传递给方法，而`"+"`将作为`operation`传递。非常重要的一点是，一旦我们到达第5行的方法调用，接下来执行的代码是第14行——所以，从第5行开始，我们跳入`performCalc`方法，并开始执行第14行的`switch`表达式。
- en: Since `operation` is `"+"` for this method invocation, line 15 assigns 10 +
    2 (12) to `result`. Line 25 returns `result` back to the calling method (line
    5), where the value 12 is assigned into `result`. Line 6 outputs the return value
    from the `performCalc` invocation on line 5, which is 12.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这次方法调用中的`operation`是`"+"`，第15行将10 + 2（12）赋值给`result`。第25行将`result`的值返回到调用方法（第5行），其中值12被赋值给`result`。第6行输出了第5行`performCalc`调用的返回值，即12。
- en: Different scopes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的作用域
- en: Note that the two `result` variables (lines 5 and 14) are completely different
    as they are in two separate scopes – one is in the `main()` method and the other
    is in the `performCalc` method. As a result, there is no conflict or ambiguity
    whatsoever.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个`result`变量（第5行和第14行）完全不同，因为它们在不同的作用域中——一个在`main()`方法中，另一个在`performCalc`方法中。因此，没有任何冲突或歧义。
- en: Line 7 executes `System.out.println()` with a method call inside the `()` of
    `println`. In this scenario, Java will execute the method call inside the `()`
    of `println`, and whatever the method returns will then be output to the screen.
    So, for line 7, the arguments passed to `performCalc` are `10`, `2`, and `"-"`.
    Therefore, in `performCalc`, `x` is 10, `y` is 2, and `operation` is `"-"`. The
    `switch` expression now executes line 16, resulting in `result` becoming 8 (10
    -2). This `result` is returned (line 25) back to the calling method (line 7),
    where `8` is output to the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行在`println`的`()`内执行了`System.out.println()`方法调用。在这种情况下，Java将执行`println`的`()`内的方法调用，然后方法返回的内容将被输出到屏幕。所以，对于第7行，传递给`performCalc`的参数是`10`、`2`和`"-"`。因此，在`performCalc`中，`x`是10，`y`是2，`operation`是`"-"`。`switch`表达式现在执行第16行，导致`result`变为8（10
    - 2）。这个`result`被返回（第25行）到调用方法（第7行），其中`8`被输出到屏幕。
- en: Lines 8 and 9 operate similarly to line 7 except that the lines of code executed
    in the `switch` expression are different. The method call on line 8 executes line
    17 in the `switch` expression, resulting in `result` being initialized to 20\.
    This value is returned to the calling method (line 8), where `20` is output to
    the screen. The method call on line 9 executes line 18 in the `switch` expression,
    resulting in `result` being initialized to 5, and thus `5` is output to the screen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行和第9行的操作与第7行类似，除了`switch`表达式中执行的代码行不同。第8行的方法调用执行了`switch`表达式中的第17行，导致`result`被初始化为20。这个值被返回到调用方法（第8行），其中`20`被输出到屏幕。第9行的方法调用执行了`switch`表达式中的第18行，导致`result`被初始化为5，因此`5`被输出到屏幕。
- en: Line 10 causes line 19 in the `switch` expression to be executed, initializing
    `result` to `0` (10 % 2). This `result` is returned back to the calling method,
    where, because it is not stored in a variable, it is simply lost/ignored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第10行导致`switch`表达式中的第19行被执行，初始化`result`为`0`（10 % 2）。这个`result`被返回到调用方法，由于它没有被存储在变量中，所以它只是被丢失/忽略。
- en: 'The `performCalc` call on line 11 passes in `"&"`, which executes the `default`
    branch of the `switch` expression. This results in the error message “Unrecognized
    operation: &” being displayed on the screen and -1 being returned. The -1 is then
    output on the screen.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行的`performCalc`调用传递了`"&"`，这执行了`switch`表达式的`default`分支。这导致屏幕上显示错误消息“未识别的操作：&”，并返回-1。然后-1被输出到屏幕。
- en: Now that we know how to define and execute methods, we will move on to discussing
    method overloading, where distinct methods can have the same identifier name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何定义和执行方法，我们将继续讨论方法重载，其中不同的方法可以具有相同的标识符名称。
- en: Exploring method overloading
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: Consider a scenario where you have an algorithm, implemented by a method, that
    operates similarly on various input types – for example, `String` and `int`. It
    would be a shame to have two separately contrived method names, one for each input
    type, such as `doStuffForString(String)` and `doStuffForInt(int)`. It would be
    much better if both methods had the same name – that is, `doStuff` – differentiated
    by their input types, which are `doStuff(String)` and `doStuff(int)`. Thus, there
    will be no contrived method names. This is what method overloading provides. To
    discuss method overloading properly, we must first define the method signature.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你有一个算法，通过一个方法实现，它在各种输入类型上操作相似——例如`String`和`int`。如果为每种输入类型分别构造两个不同的方法名，比如`doStuffForString(String)`和`doStuffForInt(int)`，那就太遗憾了。如果两个方法都有相同的名称——即`doStuff`——并通过它们的输入类型区分，即`doStuff(String)`和`doStuff(int)`，那就好多了。这样就不会有构造的方法名。这正是方法重载提供的。为了正确地讨论方法重载，我们首先必须定义方法签名。
- en: Method signature
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法签名
- en: 'The method signature consists of the method’s name and the optional parameters.
    It does *not* consist of the return type. Let’s look at an example to explain
    this further:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名由方法名和可选参数组成。它*不*包括返回类型。让我们通过一个例子来进一步解释这一点：
- en: '![Figure 7.7 – Method signature](img/B19793_07_7.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 方法签名](img/B19793_07_7.jpg)'
- en: Figure 7.7 – Method signature
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 方法签名
- en: In the preceding figure, the method signature is highlighted in a dashed rectangle.
    It consists of the name of the method, followed by both the type and the order
    of the parameters. What this means is that the signature for the method in *Figure
    7**.7* is `performCalc`, which takes in two integers and a `String`, *in that
    order*. Note that the parameter names do not matter. So, in effect, from the perspective
    of the compiler, the method signature is `performCalc(int,` `int, String)`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，方法签名用虚线矩形突出显示。它由方法名、参数的类型和顺序组成。这意味着图*7.7*中的方法签名是`performCalc`，它接受两个整数和一个`String`，*按此顺序*。请注意，参数名并不重要。因此，实际上，从编译器的角度来看，方法签名是`performCalc(int,
    int, String)`。
- en: Overloading a method
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'A method is overloaded when two or more methods share the same name but the
    parameters are different in type and/or order. This makes sense if you consider
    this from the viewpoint of the compiler. If you call a method that has two or
    more definitions, how will the compiler know which one you are referring to? To
    locate the correct method definition, the compiler compares and matches the method
    call with the overloaded method signatures. *Figure 7**.8* presents an overloaded
    method with various signatures:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个方法具有相同的名称但参数类型和/或顺序不同时，方法就是重载的。如果你从编译器的角度来看，这很有意义。如果你调用一个有两个或多个定义的方法，编译器将如何知道你指的是哪一个？为了定位正确的方法定义，编译器会将方法调用与重载的方法签名进行比较和匹配。*图7.8*展示了一个具有各种签名的重载方法：
- en: '![Figure 7.8 – The method signature’s impact on overloading](img/B19793_07_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 方法签名对重载的影响](img/B19793_07_08.jpg)'
- en: Figure 7.8 – The method signature’s impact on overloading
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 方法签名对重载的影响
- en: In this figure, the `someMethod` method is overloaded several times. The method
    signatures on lines 6 to 10 are `someMethod()`, `someMethod(int)`, `someMethod(double)`,
    `someMethod(String)`, and `someMethod(double,` `int)`, respectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`someMethod`方法被重载了多次。第6到第10行的方法签名分别是`someMethod()`、`someMethod(int)`、`someMethod(double)`、`someMethod(String)`和`someMethod(double,
    int)`。
- en: The interesting cases are the compiler errors on lines 11-13\. The error on
    line 11 is a misleading error from the compiler. In other words, if we comment
    out lines 12 and 13, the compiler error on line 11 disappears. There is nothing
    wrong with line 11 as this is the first time the compiler has seen this particular
    method signature – that is, `someMethod(int, double)`. The problem is that lines
    12 to 13 have the same signatures and the compiler is flagging all lines with
    that signature.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的案例是第11-13行的编译器错误。第11行的错误是编译器的一个误导性错误。换句话说，如果我们注释掉第12和第13行，第11行的编译器错误就会消失。第11行没有问题，因为这是编译器第一次看到这个特定的方法签名——即`someMethod(int,
    double)`。问题是第12到第13行有相同的方法签名，编译器正在标记所有具有该签名的行。
- en: Line 12 reinforces the point that the parameter names do not matter as they
    are not part of the method signature. Therefore, the fact that they are named
    `x` and `y` on line 11 and `a` and `b` on line 12 makes no difference whatsoever.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, line 13 demonstrates that the return type is not part of the method
    signature. Line 13 is a compiler error because its signature, `someMethod(int,
    double)`, is the same as on lines 11 and 12, even though the two methods have
    different return types (`int` and `void`, respectively).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the return type and parameter names are *not* part of the method
    signature. Now that we understand what is (and what is not) part of the method
    signature, let’s look at a simple example of method overloading. *Figure 7**.9*
    presents the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Method overloading example](img/B19793_07_9.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Method overloading example
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an overloaded `add` method. The first version (lines
    10 to 13) takes in two `int` parameters; the second version (lines 14-17) takes
    in two `double` parameters. Their respective signatures are captured on lines
    10 and 14, respectively. Thus, when we call `add` on line 5 and pass down two
    integers, the compiler matches the call with the version of `add` on line 10 because
    that version of `add` takes two integers. Similarly, the call to `add` on line
    7 matches `add` on line 14 because both the call and method signature match (two
    `double` types in both).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how method parameter types and their order affect method
    overloading, let’s examine how Java enables us to execute methods where the number
    of arguments is variable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Explaining varargs
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following situation: you want to call a method, `m1`, but the
    number of arguments may vary. Do you overload the method with each version of
    the method taking in one extra parameter? For example, assuming the argument types
    are of the `String` type, do you overload `m1` when each new version takes in
    an extra `String` parameter? In this case, you would have to code `m1(String)`,
    `m1(String, String)`, `m1(String, String, String)`, and so forth. This is not
    scalable.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where `varargs` comes in. `varargs` is a very flexible language feature
    in Java, specifically provided for this use case. The syntax is that the type
    name is followed by an ellipsis (three dots). *Figure 7**.10* shows `varargs`
    in action:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – varargs example](img/B19793_07_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – varargs example
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 10, `m1(int… )` defines a method signature for the `m1`
    method, defining 0 or more `int` parameters. This is quite different from `String[]`
    defined on line 4 for `main`. In effect, you don’t have to pass in any argument
    to `m1` at all; or you can pass in 1, 2, 3, or more integers. This is shown by
    the method calls (lines 5-8). Internally, in the `m1` method, `varargs` is treated
    as an array. The `for` loop (lines 12-14) demonstrate that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from *Figure 7**.10* is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Line 5 generates no output at all. Line 6 generates `1`; line 7 generates `3`;
    and line 8 generates `6`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine some edge cases with `varargs`. *Figure 7**.11* will help:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – varargs compiler errors](img/B19793_07_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – varargs compiler errors
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that `varargs` must be the last parameter
    in the method definition. Line 10 is fine as it defines the `varargs` parameter
    as the last parameter. However, line 11 is a compiler error because it attempts
    to define a parameter *after* the varargs parameter. This makes sense as all other
    parameters are mandatory; so, if `varargs` can define 0 or more arguments, it
    must be the last parameter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Given that `varargs` is treated as an array, this begs the question, can we
    use an array instead of `varargs`? The answer is no. The compiler errors (lines
    5-8) all relate to the fact that, despite the presence of `m1(int[])` on line
    12, the compiler cannot find the method definition that matches any of these method
    calls.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The last major topic for methods is an important one: call by value. We will
    discuss that now.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Mastering call by value
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java uses call by value when passing arguments to methods and returning results
    from methods. Concisely, this means that Java *makes a copy of something*. Effectively,
    when you are passing an argument to a method, a copy is made of that argument
    and when you are returning a result from a method, a copy is made of that result.
    Why do we care? Well, depending on what you are copying – a primitive or a reference
    has `int` and an example of a reference type is an array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In a method, there is a clear difference between the effect of changes when
    the parameter is a primitive type versus when the parameter is a reference type.
    We will demonstrate this shortly with a code example but first, to appreciate
    the differences, we need to understand what is happening in memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Primitives versus references in memory
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array is an object, whereas a primitive is not. We will discuss objects
    in detail in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), but for now, let’s
    examine the code in *Figure 7**.12*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Sample code containing a primitive and an array](img/B19793_07_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Sample code containing a primitive and an array
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: To understand what the code in the preceding figure looks like in memory, we
    need to discuss the stack, the heap, and references.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The stack is a special area of memory used by methods. Each time a new method
    `A`, is called, a new frame is *pushed* (created) onto the stack. The frame contains,
    among other things, `A`’s local variables and their values. Each frame is stacked
    one on top of the other, like plates. If `A` calls another method, `B`, the existing
    frame for `A` is saved and a new frame for `B` is pushed onto the stack, creating
    a new context. When `B` finishes, its stack frame is *popped* (removed) from the
    stack, and the frame for `A` is restored (with all its local variables and their
    values as they were, prior to the call to `B`). This is why a stack is called
    a **Last-In, First Out** (**LIFO**) structure. For further detail on the stack
    and Java Memory Management in general, please see our previous book: [https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/     1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+     maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For our discussion here, what we need to be aware of is that local variables
    (primitives and/or references) are stored on the stack. Objects are *not* stored
    on the stack; objects are stored on the heap.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heap is an area of memory reserved for objects and arrays are objects. This
    means that arrays are stored on the heap. To access an object, we use a reference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The named identifier used to access an object is known as a reference. A reference
    is similar to a pointer. Consider a TV that has no buttons on it to change the
    channel but does have a remote control. The reference is the remote control and
    the TV is the object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'With these definitions in mind, let’s review the code in *Figure 7**.12*. Line
    5 declares a primitive `int` type called `x` and initializes it to 19\. Line 6
    declares an `int` array, namely `arr`, and initializes `arr[0]` to `1` and `arr[1]`
    to `2`. The array reference is `arr`. *Figure 7**.13* shows the in-memory representation
    of *Figure 7**.12* as we reach line 7:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – In-memory representation of the code from Figure 7.12](img/B19793_07_13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – In-memory representation of the code from Figure 7.12
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that there is a stack frame for the `main`
    method containing the local variables, `x` and `arr`. Note that, for simplicity,
    the `String[] args` parameter in `main` is omitted. Immediately, you can see the
    difference between the way primitives, namely `x`, and references, namely `arr`,
    are stored – `x` and its value are stored on the stack; whereas the value of `arr`
    refers to the object on the heap.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we are now in a position to examine a proper code example
    demonstrating the real impact of call by value when passing primitives versus
    passing references. *Figure 7**.14* represents the code example we will be using:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Call by value passing primitives and references](img/B19793_07_14.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Call by value passing primitives and references
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the `callByValue` method is defined on lines 13-17: the method
    accepts an `int` type and an `int` array in that order and returns an `int`. Line
    14 changes the value of the `int` parameter to -1 and line 15 changes index 0
    of the array to -1\. Lastly, the method returns the value of `x` on line 16.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine the first call to `callByValue`, passing down the `x` and `arr`
    arguments. It is important to note that the `x` and `arr` variables declared in
    `main` are completely separate variables from the `x` and `arr` parameters declared
    in the method `callByValue`. This is because they are in two separate scopes (methods).
    As Java uses call by value, copies of the primitive, `x`, and the reference, `arr`,
    are made and it is the *copies* that are passed into the method `callByValue`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Making a copy of a primitive is like photocopying a blank sheet of paper - if
    you pass the photocopy to someone and they write on it, your original blank sheet
    is still blank. Making a copy of a reference is like copying a remote control
    – if you give the second remote control (the copied one) to someone else, they
    can change the channel on the TV. Crucially, there is only one TV in all of this
    – the copy is made of the remote control, *not* the TV.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This saves memory as copying a reference has a much smaller memory footprint
    that copying a potentially large object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.15* represents the in-memory representation of the code as we are
    about to `return` from the *first* invocation of `callByValue`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call
    to callByValue (line 7)](img/B19793_07_15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call to
    callByValue (line 7)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from the stack in the preceding figure, when we call `callByValue(x,
    arr)` from `main`, the existing frame for `main` is saved and a frame for `callByValue`
    is pushed onto the stack (on top of the frame for `main`). Then the code for `callByValue`
    is executed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Firstly, `x` in changed in the `callByValue` frame. This is the copy of `x`
    from `main`. Note that the value of `x` in (the frame for) `main` remains untouched
    (still 19). Consequently, 19 is output for `x` in `main` (line 8). Thus, a called
    method cannot (directly) change the caller method’s primitive values. We will
    revisit this point shortly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the line `arr[0] = 1;` in `callByValue` does have a material impact
    on `main`. When `callByValue` uses its `arr` reference, which is a copy of the
    `arr` reference from `main`, it changes the one object that both methods share.
    In effect, the array object that `main` is looking at is changed. This is demonstrated
    in `main` after the `callByValue` method returns:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Crucially, `-1` is output for the value at `arr[0]`. Therefore, be aware that
    when passing a reference to a method, the method can change the object that you
    are looking at.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the primitive situation. What if we wanted the called method
    to change the primitive value that’s passed down? This is why `callByValue` is
    returning `x`. The first method call to `callByValue` completely ignores the return
    value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, the second call does not:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The -1 that’s returned from `callByValue` is used to overwrite the value of
    `x` in `main`. As a result, -1 is output for `x` in `main` (line 11).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on methods. Now, let’s put that knowledge into
    practice to reinforce these concepts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining a dinosaur park takes a lot more than just raw passion. It involves
    regular health check-ups for our dinosaurs, ensuring our guests are comfortable,
    and that the park is well-staffed. All these tasks involve methodical processes.
    Luckily, we now know about methods!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add these methods to the same class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The stage of life a dinosaur is in can significantly impact its behavior and
    needs. Write a method that takes a dinosaur’s age and returns whether it’s a hatchling,
    juvenile, or adult.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to remember that our dinosaurs aren’t actually pets – they’re
    large, often hefty creatures with large appetites. Write a method that accepts
    a dinosaur’s weight and calculates how much food it needs daily.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Being on top of our dinosaurs’ average age helps us plan for the future. Design
    a method that accepts an array of dinosaur ages and calculates the average age.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The park isn’t open 24/7 to day visitors. We need some time to clean up the
    popcorn and repair any minor damages to the enclosures. Write a method that checks
    if the park is open or closed based on the current time. (Hint: this method doesn’t
    require any input.)'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Personalization is key to making our guests feel special. Create a method that
    uses a dinosaur’s name and a visitor’s name to craft a personal greeting message.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you’re well aware, safety is our top priority. We need a method to return
    whether we can let in another group of guests (a certain number of people) to
    the park based on the current number of visitors and the maximum number of visitors
    allowed.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Mesozoic Eden assistant
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is going to be our biggest project so far. So, buckle up!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a high-level description. The Mesozoic Eden assistant is an
    interactive console application that assists in managing a dinosaur park. The
    assistant should have features to do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Add or remove dinosaurs
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the park’s opening hours
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greet guests and provide park information
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track visitor counts to ensure the park isn’t overcrowded
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage park staff details
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we won’t let you drown, if you need it, here is a step-by-step guide.
    A starting project will follow these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur`, `Guest`, and `Employee`. Include appropriate properties and methods.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Scanner` class.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Scanner` class.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a menu**: Create a menu that allows the user to interact with the
    park management system.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handle actions**: Each menu item should trigger a certain action, such as
    adding a dinosaur, checking park hours, or greeting a guest.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit the program**: Provide an option for the user to exit the program.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a code snippet to get you started:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, this is a great starting point! But it’s not done. In the preceding code
    snippet, `addDinosaur()`, `checkParkHours()`, `greetGuest()`, `checkVisitorsCount()`,
    and `manageStaff()` are placeholders for methods you need to implement according
    to your data structures and functionality. The `Scanner` class is used to read
    the user’s menu choice from the console.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You can make the project as sophisticated as you like by adding additional features
    and enhancements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our discussion on methods by stating that methods
    are simply code blocks that are given a name for ease of reference. Methods are
    important because they enable us to abstract away the implementation, while at
    the same time helping us to avoid unnecessary code duplication.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to a method: the method definition (or declaration) and
    the method call (or invocation). The method definition declares (among other things)
    the method name, the input parameters, and the return type. The method name and
    the parameter types (including their order) constitute the method signature. The
    method call passes down the arguments (if any) to be used as inputs in the method.
    The return value from a method (if there is one) can be captured by assigning
    the method call to a variable.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading is where the same method name is used across several different
    methods. What distinguishes the various methods is that they have different signatures
    – the parameter types and/or their order will be different. The parameter names
    and return types do not matter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A `varargs` (variable arguments) parameter is specified in a method declaration
    using an ellipsis (three dots). This means that when calling this method, the
    arguments corresponding to that parameter are variable – you can pass down `0`
    or more arguments for that parameter. Internally, in the method, the `varargs`
    parameter is treated as an array.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: When passing arguments to a method, Java uses call by value. This means that
    a copy of the argument is made. Depending on whether you are passing down a primitive
    or a reference has major implications regarding the effect of the changes that
    are made by the called method on the calling method. If it’s a primitive, the
    called method cannot change the primitive that the caller method has (unless the
    caller method deliberately overwrites the variable with the return value). If
    it’s a reference, the called method can change the object that the caller method
    is looking at.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished looking at methods, let’s move on to our first strictly
    **object-oriented programming** (**OOP**) chapter, where we will look at classes,
    objects, and enums.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Object-Oriented Programming'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will take a deep dive into `abstract` classes and the hugely
    important `interface` construct. Following that, we will examine Java’s exception
    framework. Lastly, we will explore selected classes from the Java Core API, such
    as `String` and `StringBuilder`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), *Classes, Objects, and Enums*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), *Inheritance and Polymorphism*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19793_10.xhtml#_idTextAnchor249), *Interfaces and Abstract
    Classes*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19793_11.xhtml#_idTextAnchor266), *Dealing with Exceptions*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19793_12.xhtml#_idTextAnchor293), *Java Core API*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
