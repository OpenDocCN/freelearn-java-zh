- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118), we learned about arrays
    in Java. We learned that arrays are data structures that are fixed in size. They
    are stored in contiguous memory locations where each location is of the same type.
    We also saw how to declare, initialize, and process arrays. Both the traditional
    and enhanced `for` loops are ideal for processing arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we discussed multi-dimensional arrays, including how they are organized
    and how to process them. Lastly, as arrays are very common, we discussed the `Arrays`
    class, which has several useful methods for processing arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover methods. Methods enable us to create a named
    block of code that can be executed from elsewhere in the code. Firstly, we will
    explain why methods are so commonplace. You will learn the difference between
    the method definition and the method invocation. We will explore what a method
    signature is and how method overloading enables methods to have the same name,
    without conflict. We will also explain variable arguments (`varargs`), which enable
    a method to be executed with 0 or more arguments. Lastly, Javas’ principle of
    call-by-value for passing arguments (and returning values) will be outlined. By
    the end of this chapter, you will be well able to code and execute methods. In
    addition, you will understand method overloading, `varargs`, and Javas’ call-by-value
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining why methods are important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between method definition and method execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring method overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining `varargs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering call by value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7).
  prefs: []
  type: TYPE_NORMAL
- en: Explaining why methods are important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are code blocks that are given a name for ease of reference. They can
    accept inputs and return an output. Both the inputs and output are optional. A
    method should do one task and do it well. It is considered good practice to keep
    your methods short (less than 20 lines). The longer the method, the more likely
    it is that the method is doing too much. The maxim of “keep it simple” applies
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Flow of control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simply put, when a method is called (executed), the normal flow of control
    of execution is changed. Let us discuss a simple example that will help demonstrate
    this. This is an important point to appreciate, especially for inexperienced developers.
    *Figure 7**.1* presents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A very simple method](img/B19793_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A very simple method
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have two methods: the `main()` method (lines 4 to 8) and
    the `simpleExample()` method (lines 9 to 11). Both exist inside the `Methods`
    class (lines 3 to 12).'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, every program starts with the `main()` method. The JVM calls it on
    our behalf; we do not have to call (or execute) it ourselves. Therefore, in this
    example, the first line in `main()`, line 5, is the first line to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 is important – it is what we refer to as a method call. There is a direct
    correlation between the `simpleExample()` method definition on line 9 and the
    method call on line 6\. We will discuss this relationship shortly. For the moment,
    just understand that the method call changes the order of execution of the program.
    Normally, Java executes lines of code from top to bottom and this is true. However,
    *method calls alter that*. In this example, when line 6 executes, the next line
    to execute is line 10 (inside the `simpleExample()` method).
  prefs: []
  type: TYPE_NORMAL
- en: So, the `main()` method has now handed over control to the `simpleExample()`
    method, and control will not return to `main()` until `simpleExample()` exits.
    This can occur when execution hits the closing `}` at the end of the `simpleExample()`
    method (line 11). This is what happens in this example. Alternatively, a method
    can exit by using the `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: So, line 6 calls the `simpleExample()` method, causing its code to execute.
    Line 10 outputs some text to the screen. The closing `}` on line 11 causes `simpleExample()`
    to exit and control now returns to `main()`, where execution resumes at line 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the order of execution in this program is illustrated by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that `println()`, inside the `simpleExample()` method, is
    sandwiched between the two `println()` statements from `main()`. This demonstrates
    that the flow of control was altered by the method call on line 6.
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, how can a caller method, such as `main()`, simply *resume* where it left
    off after the `simpleExample()` method returns? What about the local variables
    of `main()`?
  prefs: []
  type: TYPE_NORMAL
- en: The ability of a method to resume exactly where it left off, after the method
    it called returns, requires the use of a memory structure called the *stack*.
    We will discuss the stack later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our *why methods are important’ discussion*, two major advantages
    of methods are that they provide abstraction and avoid code duplication. Let’s
    examine these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstraction is a principle in software engineering where clients of a service,
    are abstracted from the service implementation. This decouples clients, who use
    the service, from knowing how the service is implemented. Thus, if the service
    implementation is changed, the clients are not impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, a McDonald’s drive-thru where you drive up and place your
    order. In this situation, you are the client of the McDonald’s service. You do
    not care how McDonald’s process your order; you simply want to place an order
    and receive the food/drinks. If McDonald’s changes its internal implementation,
    you are shielded (abstracted) from those changes. This is known as abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the method itself is the McDonald’s service. The method call
    is the McDonald’s customer. The method call is abstracted from internal changes
    to the method code.
  prefs: []
  type: TYPE_NORMAL
- en: Code duplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can help us avoid code replication. This has the added benefit of easing
    debugging. Let’s look at a simple example of this. *Figure 7**.2* demonstrates
    duplicated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Duplicated code](img/B19793_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Duplicated code
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, lines 8 to 12 are repeated on lines 14 to 18 and lines
    20 to 24\. Each of these sections prompts the user for a number, stores the user
    input in a variable named `number`, and checks to see if the number is in range.
    If the number is out of range, then an error is flagged. While a loop would be
    an obvious improvement, bear in mind that these lines of code could well be in
    separate parts of the program. In addition, for this simple example, we are only
    interested in highlighting code duplication. We simply prompt for a number, accept
    the user’s input, and validate it. The result is five lines of code repeated three
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s assume that we want to adjust the upper valid range from 10 to 100\.
    We have to change the prompts on lines 8, 14, and 20\. In addition, the `if` statements
    on lines 10, 16, and 22 need to change. Thus, a simple range adjustment has resulted
    in quite a few code changes and we could easily forget to make one or more of
    the changes required. Let’s refactor the code into a method. *Figure 7**.3* shows
    the refactored code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The code from Figure 7.2 refactored to use a method](img/B19793_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The code from Figure 7.2 refactored to use a method
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the method itself is coded from lines 9 to 17 and will
    be explained in detail in the next section. The five lines of repeated code from
    *Figure 7**.2* are coded only once, on lines 11 to 15\. The execution calls of
    the method are on lines 5, 6, and 7; one execution call per line. If we want to
    change the upper valid range from 10 to 100, we just need to change the method
    – that is, lines 11 and 13\. These two changes are *automatically* reflected throughout
    the code. In effect, the three method calls on lines 5, 6, and 7 automatically
    reflect the changes made in the method.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this situation scales very well. For example, if, in *Figure
    7**.2*, we had duplicated the code 10 times, we would have to make changes in
    10 areas of the code. However, with the method implementation, there is still
    *only one* location to make the change and that is in the method itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have justified why methods exist, let’s examine the difference between
    the method itself and the method call.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between method definition and method execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those new to programming, it may surprise you to know that there are two
    parts to having a method *do* something. Firstly, we must code the method (the
    method definition). This is similar to a bank machine on the street – it just
    sits there, doing nothing, waiting to be used. Secondly, we must execute the method
    (the method execution). This is similar to a customer “using” the bank machine.
    Remember that the `main` method is the only method that is automatically executed
    by the JVM. Any other method calls have to be explicitly coded.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the method definition and method execution in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Method definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method definition (declaration) is the method code itself - this is the
    block of code that is executed when the method is called. *Figure 7**.4* presents
    the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The syntax of the method definition](img/B19793_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The syntax of the method definition
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, as in other figures, square brackets signify optional
    elements. The `access-modifier` and `static` elements will be discussed in [*Chapter
    8*](B19793_08.xhtml#_idTextAnchor168). The `throws` `someException` element will
    be covered in [*Chapter 11*](B19793_11.xhtml#_idTextAnchor266). In this chapter,
    we will focus on the elements in bold; namely, `return-type` (mandatory), `methodName`
    (mandatory), and `parameters` (optional).
  prefs: []
  type: TYPE_NORMAL
- en: The return type of the method can be a primitive type, a reference type, or
    `void`. The `void` keyword means that the method is not returning anything. If
    that is the case, you *cannot* simply leave out the return type; you must specify
    `void`. In addition, when you’re not returning anything from a method, you can
    specify `return;` or simply leave out the `return` keyword altogether (which is
    what we have done for all the `main()` methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a method that accepts input and returns a result. *Figure 7**.5*
    presents such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Sample method definition](img/B19793_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Sample method definition
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have a method that takes in two integers and a mathematical
    operation to be performed using the two integers as operands. For example, if
    `"+"` is passed in, the two numbers are added and the result is returned. Let’s
    review how the method does this.
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 is very important. For the moment, as stated earlier, [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168)
    will explain both `public` (access-modifier) and `static`. The `return-type` is
    an `int` – meaning, this method returns whole numbers. The name of the method
    is `performCalc`. Method names often begin with verbs and follow camel casing
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Note that round brackets follow the method name. The round brackets are delimiters
    for the optional input parameters to the method. For each parameter, you must
    specify the data type of the parameter (as Java is a strongly typed language)
    and the parameter’s identifier name. If you have two or more parameters, comma-separate
    them. These parameters are how the method accepts input. In *Figure 7**.5*, we
    have two integers namely `x` and `y`, followed by a `String` called `operation`.
    The scope of any method parameters, in this case, `x`, `y`, and `operation`, is
    the whole of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 16-26 encapsulate a `switch` expression. In effect, depending on the mathematical
    `operation` passed in, that operation is performed on the two inputs, `x` and
    `y`. The local `int` variable, `result`, is initialized accordingly. The `result`
    variable is returned on line 27\. As the return type declared on line 15 is an
    `int`, returning `result`, which is also an `int`, is fine.
  prefs: []
  type: TYPE_NORMAL
- en: A method definition in and of itself does not do anything. It just defines a
    block of code. As stated previously, this is similar to a bank machine on the
    street – it just sits there, doing nothing, waiting to be used. For the bank machine
    to be useful, you must “use” it. Similarly, we must “use” the method – this is
    what we call executing the method.
  prefs: []
  type: TYPE_NORMAL
- en: Method execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Executing the method is also known as calling or invoking the method. The method
    that calls the method is known as the “calling” (or caller) method. So, you have
    the calling method and the called method. When you call a method, you pass down
    the required arguments, if there are any. The called method will execute at this
    point. When the called method finishes, control returns to the caller method.
    The called method’s result, if there is one, is also returned. This enables the
    called method to return data to the caller method, where it can be output to the
    screen, stored in a variable, or simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Method parameters versus method arguments
  prefs: []
  type: TYPE_NORMAL
- en: The method definition defines parameters, whereas the method call passes down
    arguments. These terms are often used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.6* presents a code example to help explain this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Sample code demonstrating method calls](img/B19793_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Sample code demonstrating method calls
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA inlay hints
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the IntelliJ editor inserts inlay hints when you are coding. In the
    previous figure, the `performCalc` method signature (line 13) specifies that the
    parameters are namely `x`, `y`, and `operation`. That is why on each method call,
    the inlay hint uses these parameter names. For example, on line 5, we typed in
    10 as the first argument; however, IntelliJ, upon inspecting the method signature,
    realized that 10 was mapping to ‘x’ and that is why you see “`performCalc(10,
    2, "+")` and IntelliJ converted that to `performCalc(x: 10, y: 2,` `operation:
    "+").`'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.6*, the `performCalc` method (lines 13-26) is unchanged from
    *Figure 7**.5*. However, we can now see the various method calls (lines 5 and
    7-11).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with line 5\. On the right-hand side of the assignment, we have
    the `performCalc(10, 2, "+")` method call. This method call has higher precedence
    than the assignment, so it is executed first. The IntelliJ IDE does a very nice
    job of highlighting that `10` will be passed into the method as `x`, `2` will
    be passed into the method as `y`, and `"+"` will be passed in as `operation`.
    It is very important to realize that once we get to the method call on line 5,
    the next line of code that’s executed is line 14 – so, from line 5, we jump into
    the `performCalc` method and start executing the `switch` expression on line 14.
  prefs: []
  type: TYPE_NORMAL
- en: Since `operation` is `"+"` for this method invocation, line 15 assigns 10 +
    2 (12) to `result`. Line 25 returns `result` back to the calling method (line
    5), where the value 12 is assigned into `result`. Line 6 outputs the return value
    from the `performCalc` invocation on line 5, which is 12.
  prefs: []
  type: TYPE_NORMAL
- en: Different scopes
  prefs: []
  type: TYPE_NORMAL
- en: Note that the two `result` variables (lines 5 and 14) are completely different
    as they are in two separate scopes – one is in the `main()` method and the other
    is in the `performCalc` method. As a result, there is no conflict or ambiguity
    whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Line 7 executes `System.out.println()` with a method call inside the `()` of
    `println`. In this scenario, Java will execute the method call inside the `()`
    of `println`, and whatever the method returns will then be output to the screen.
    So, for line 7, the arguments passed to `performCalc` are `10`, `2`, and `"-"`.
    Therefore, in `performCalc`, `x` is 10, `y` is 2, and `operation` is `"-"`. The
    `switch` expression now executes line 16, resulting in `result` becoming 8 (10
    -2). This `result` is returned (line 25) back to the calling method (line 7),
    where `8` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 8 and 9 operate similarly to line 7 except that the lines of code executed
    in the `switch` expression are different. The method call on line 8 executes line
    17 in the `switch` expression, resulting in `result` being initialized to 20\.
    This value is returned to the calling method (line 8), where `20` is output to
    the screen. The method call on line 9 executes line 18 in the `switch` expression,
    resulting in `result` being initialized to 5, and thus `5` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Line 10 causes line 19 in the `switch` expression to be executed, initializing
    `result` to `0` (10 % 2). This `result` is returned back to the calling method,
    where, because it is not stored in a variable, it is simply lost/ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `performCalc` call on line 11 passes in `"&"`, which executes the `default`
    branch of the `switch` expression. This results in the error message “Unrecognized
    operation: &” being displayed on the screen and -1 being returned. The -1 is then
    output on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to define and execute methods, we will move on to discussing
    method overloading, where distinct methods can have the same identifier name.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring method overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a scenario where you have an algorithm, implemented by a method, that
    operates similarly on various input types – for example, `String` and `int`. It
    would be a shame to have two separately contrived method names, one for each input
    type, such as `doStuffForString(String)` and `doStuffForInt(int)`. It would be
    much better if both methods had the same name – that is, `doStuff` – differentiated
    by their input types, which are `doStuff(String)` and `doStuff(int)`. Thus, there
    will be no contrived method names. This is what method overloading provides. To
    discuss method overloading properly, we must first define the method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Method signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method signature consists of the method’s name and the optional parameters.
    It does *not* consist of the return type. Let’s look at an example to explain
    this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Method signature](img/B19793_07_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Method signature
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the method signature is highlighted in a dashed rectangle.
    It consists of the name of the method, followed by both the type and the order
    of the parameters. What this means is that the signature for the method in *Figure
    7**.7* is `performCalc`, which takes in two integers and a `String`, *in that
    order*. Note that the parameter names do not matter. So, in effect, from the perspective
    of the compiler, the method signature is `performCalc(int,` `int, String)`.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading a method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method is overloaded when two or more methods share the same name but the
    parameters are different in type and/or order. This makes sense if you consider
    this from the viewpoint of the compiler. If you call a method that has two or
    more definitions, how will the compiler know which one you are referring to? To
    locate the correct method definition, the compiler compares and matches the method
    call with the overloaded method signatures. *Figure 7**.8* presents an overloaded
    method with various signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The method signature’s impact on overloading](img/B19793_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – The method signature’s impact on overloading
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the `someMethod` method is overloaded several times. The method
    signatures on lines 6 to 10 are `someMethod()`, `someMethod(int)`, `someMethod(double)`,
    `someMethod(String)`, and `someMethod(double,` `int)`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting cases are the compiler errors on lines 11-13\. The error on
    line 11 is a misleading error from the compiler. In other words, if we comment
    out lines 12 and 13, the compiler error on line 11 disappears. There is nothing
    wrong with line 11 as this is the first time the compiler has seen this particular
    method signature – that is, `someMethod(int, double)`. The problem is that lines
    12 to 13 have the same signatures and the compiler is flagging all lines with
    that signature.
  prefs: []
  type: TYPE_NORMAL
- en: Line 12 reinforces the point that the parameter names do not matter as they
    are not part of the method signature. Therefore, the fact that they are named
    `x` and `y` on line 11 and `a` and `b` on line 12 makes no difference whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, line 13 demonstrates that the return type is not part of the method
    signature. Line 13 is a compiler error because its signature, `someMethod(int,
    double)`, is the same as on lines 11 and 12, even though the two methods have
    different return types (`int` and `void`, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the return type and parameter names are *not* part of the method
    signature. Now that we understand what is (and what is not) part of the method
    signature, let’s look at a simple example of method overloading. *Figure 7**.9*
    presents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Method overloading example](img/B19793_07_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Method overloading example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an overloaded `add` method. The first version (lines
    10 to 13) takes in two `int` parameters; the second version (lines 14-17) takes
    in two `double` parameters. Their respective signatures are captured on lines
    10 and 14, respectively. Thus, when we call `add` on line 5 and pass down two
    integers, the compiler matches the call with the version of `add` on line 10 because
    that version of `add` takes two integers. Similarly, the call to `add` on line
    7 matches `add` on line 14 because both the call and method signature match (two
    `double` types in both).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how method parameter types and their order affect method
    overloading, let’s examine how Java enables us to execute methods where the number
    of arguments is variable.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining varargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following situation: you want to call a method, `m1`, but the
    number of arguments may vary. Do you overload the method with each version of
    the method taking in one extra parameter? For example, assuming the argument types
    are of the `String` type, do you overload `m1` when each new version takes in
    an extra `String` parameter? In this case, you would have to code `m1(String)`,
    `m1(String, String)`, `m1(String, String, String)`, and so forth. This is not
    scalable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where `varargs` comes in. `varargs` is a very flexible language feature
    in Java, specifically provided for this use case. The syntax is that the type
    name is followed by an ellipsis (three dots). *Figure 7**.10* shows `varargs`
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – varargs example](img/B19793_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – varargs example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 10, `m1(int… )` defines a method signature for the `m1`
    method, defining 0 or more `int` parameters. This is quite different from `String[]`
    defined on line 4 for `main`. In effect, you don’t have to pass in any argument
    to `m1` at all; or you can pass in 1, 2, 3, or more integers. This is shown by
    the method calls (lines 5-8). Internally, in the `m1` method, `varargs` is treated
    as an array. The `for` loop (lines 12-14) demonstrate that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from *Figure 7**.10* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Line 5 generates no output at all. Line 6 generates `1`; line 7 generates `3`;
    and line 8 generates `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine some edge cases with `varargs`. *Figure 7**.11* will help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – varargs compiler errors](img/B19793_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – varargs compiler errors
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that `varargs` must be the last parameter
    in the method definition. Line 10 is fine as it defines the `varargs` parameter
    as the last parameter. However, line 11 is a compiler error because it attempts
    to define a parameter *after* the varargs parameter. This makes sense as all other
    parameters are mandatory; so, if `varargs` can define 0 or more arguments, it
    must be the last parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Given that `varargs` is treated as an array, this begs the question, can we
    use an array instead of `varargs`? The answer is no. The compiler errors (lines
    5-8) all relate to the fact that, despite the presence of `m1(int[])` on line
    12, the compiler cannot find the method definition that matches any of these method
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last major topic for methods is an important one: call by value. We will
    discuss that now.'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering call by value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java uses call by value when passing arguments to methods and returning results
    from methods. Concisely, this means that Java *makes a copy of something*. Effectively,
    when you are passing an argument to a method, a copy is made of that argument
    and when you are returning a result from a method, a copy is made of that result.
    Why do we care? Well, depending on what you are copying – a primitive or a reference
    has `int` and an example of a reference type is an array.
  prefs: []
  type: TYPE_NORMAL
- en: In a method, there is a clear difference between the effect of changes when
    the parameter is a primitive type versus when the parameter is a reference type.
    We will demonstrate this shortly with a code example but first, to appreciate
    the differences, we need to understand what is happening in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives versus references in memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array is an object, whereas a primitive is not. We will discuss objects
    in detail in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), but for now, let’s
    examine the code in *Figure 7**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Sample code containing a primitive and an array](img/B19793_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Sample code containing a primitive and an array
  prefs: []
  type: TYPE_NORMAL
- en: To understand what the code in the preceding figure looks like in memory, we
    need to discuss the stack, the heap, and references.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The stack is a special area of memory used by methods. Each time a new method
    `A`, is called, a new frame is *pushed* (created) onto the stack. The frame contains,
    among other things, `A`’s local variables and their values. Each frame is stacked
    one on top of the other, like plates. If `A` calls another method, `B`, the existing
    frame for `A` is saved and a new frame for `B` is pushed onto the stack, creating
    a new context. When `B` finishes, its stack frame is *popped* (removed) from the
    stack, and the frame for `A` is restored (with all its local variables and their
    values as they were, prior to the call to `B`). This is why a stack is called
    a **Last-In, First Out** (**LIFO**) structure. For further detail on the stack
    and Java Memory Management in general, please see our previous book: [https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/     1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+     maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: For our discussion here, what we need to be aware of is that local variables
    (primitives and/or references) are stored on the stack. Objects are *not* stored
    on the stack; objects are stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heap is an area of memory reserved for objects and arrays are objects. This
    means that arrays are stored on the heap. To access an object, we use a reference.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The named identifier used to access an object is known as a reference. A reference
    is similar to a pointer. Consider a TV that has no buttons on it to change the
    channel but does have a remote control. The reference is the remote control and
    the TV is the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these definitions in mind, let’s review the code in *Figure 7**.12*. Line
    5 declares a primitive `int` type called `x` and initializes it to 19\. Line 6
    declares an `int` array, namely `arr`, and initializes `arr[0]` to `1` and `arr[1]`
    to `2`. The array reference is `arr`. *Figure 7**.13* shows the in-memory representation
    of *Figure 7**.12* as we reach line 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – In-memory representation of the code from Figure 7.12](img/B19793_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – In-memory representation of the code from Figure 7.12
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that there is a stack frame for the `main`
    method containing the local variables, `x` and `arr`. Note that, for simplicity,
    the `String[] args` parameter in `main` is omitted. Immediately, you can see the
    difference between the way primitives, namely `x`, and references, namely `arr`,
    are stored – `x` and its value are stored on the stack; whereas the value of `arr`
    refers to the object on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we are now in a position to examine a proper code example
    demonstrating the real impact of call by value when passing primitives versus
    passing references. *Figure 7**.14* represents the code example we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Call by value passing primitives and references](img/B19793_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Call by value passing primitives and references
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the `callByValue` method is defined on lines 13-17: the method
    accepts an `int` type and an `int` array in that order and returns an `int`. Line
    14 changes the value of the `int` parameter to -1 and line 15 changes index 0
    of the array to -1\. Lastly, the method returns the value of `x` on line 16.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine the first call to `callByValue`, passing down the `x` and `arr`
    arguments. It is important to note that the `x` and `arr` variables declared in
    `main` are completely separate variables from the `x` and `arr` parameters declared
    in the method `callByValue`. This is because they are in two separate scopes (methods).
    As Java uses call by value, copies of the primitive, `x`, and the reference, `arr`,
    are made and it is the *copies* that are passed into the method `callByValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Making a copy of a primitive is like photocopying a blank sheet of paper - if
    you pass the photocopy to someone and they write on it, your original blank sheet
    is still blank. Making a copy of a reference is like copying a remote control
    – if you give the second remote control (the copied one) to someone else, they
    can change the channel on the TV. Crucially, there is only one TV in all of this
    – the copy is made of the remote control, *not* the TV.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This saves memory as copying a reference has a much smaller memory footprint
    that copying a potentially large object.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.15* represents the in-memory representation of the code as we are
    about to `return` from the *first* invocation of `callByValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call
    to callByValue (line 7)](img/B19793_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call to
    callByValue (line 7)
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from the stack in the preceding figure, when we call `callByValue(x,
    arr)` from `main`, the existing frame for `main` is saved and a frame for `callByValue`
    is pushed onto the stack (on top of the frame for `main`). Then the code for `callByValue`
    is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, `x` in changed in the `callByValue` frame. This is the copy of `x`
    from `main`. Note that the value of `x` in (the frame for) `main` remains untouched
    (still 19). Consequently, 19 is output for `x` in `main` (line 8). Thus, a called
    method cannot (directly) change the caller method’s primitive values. We will
    revisit this point shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the line `arr[0] = 1;` in `callByValue` does have a material impact
    on `main`. When `callByValue` uses its `arr` reference, which is a copy of the
    `arr` reference from `main`, it changes the one object that both methods share.
    In effect, the array object that `main` is looking at is changed. This is demonstrated
    in `main` after the `callByValue` method returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Crucially, `-1` is output for the value at `arr[0]`. Therefore, be aware that
    when passing a reference to a method, the method can change the object that you
    are looking at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the primitive situation. What if we wanted the called method
    to change the primitive value that’s passed down? This is why `callByValue` is
    returning `x`. The first method call to `callByValue` completely ignores the return
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the second call does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The -1 that’s returned from `callByValue` is used to overwrite the value of
    `x` in `main`. As a result, -1 is output for `x` in `main` (line 11).
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on methods. Now, let’s put that knowledge into
    practice to reinforce these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining a dinosaur park takes a lot more than just raw passion. It involves
    regular health check-ups for our dinosaurs, ensuring our guests are comfortable,
    and that the park is well-staffed. All these tasks involve methodical processes.
    Luckily, we now know about methods!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add these methods to the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: The stage of life a dinosaur is in can significantly impact its behavior and
    needs. Write a method that takes a dinosaur’s age and returns whether it’s a hatchling,
    juvenile, or adult.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to remember that our dinosaurs aren’t actually pets – they’re
    large, often hefty creatures with large appetites. Write a method that accepts
    a dinosaur’s weight and calculates how much food it needs daily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Being on top of our dinosaurs’ average age helps us plan for the future. Design
    a method that accepts an array of dinosaur ages and calculates the average age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The park isn’t open 24/7 to day visitors. We need some time to clean up the
    popcorn and repair any minor damages to the enclosures. Write a method that checks
    if the park is open or closed based on the current time. (Hint: this method doesn’t
    require any input.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Personalization is key to making our guests feel special. Create a method that
    uses a dinosaur’s name and a visitor’s name to craft a personal greeting message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you’re well aware, safety is our top priority. We need a method to return
    whether we can let in another group of guests (a certain number of people) to
    the park based on the current number of visitors and the maximum number of visitors
    allowed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Mesozoic Eden assistant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is going to be our biggest project so far. So, buckle up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a high-level description. The Mesozoic Eden assistant is an
    interactive console application that assists in managing a dinosaur park. The
    assistant should have features to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add or remove dinosaurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the park’s opening hours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greet guests and provide park information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track visitor counts to ensure the park isn’t overcrowded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage park staff details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we won’t let you drown, if you need it, here is a step-by-step guide.
    A starting project will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur`, `Guest`, and `Employee`. Include appropriate properties and methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Scanner` class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Scanner` class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a menu**: Create a menu that allows the user to interact with the
    park management system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handle actions**: Each menu item should trigger a certain action, such as
    adding a dinosaur, checking park hours, or greeting a guest.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit the program**: Provide an option for the user to exit the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a code snippet to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, this is a great starting point! But it’s not done. In the preceding code
    snippet, `addDinosaur()`, `checkParkHours()`, `greetGuest()`, `checkVisitorsCount()`,
    and `manageStaff()` are placeholders for methods you need to implement according
    to your data structures and functionality. The `Scanner` class is used to read
    the user’s menu choice from the console.
  prefs: []
  type: TYPE_NORMAL
- en: You can make the project as sophisticated as you like by adding additional features
    and enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our discussion on methods by stating that methods
    are simply code blocks that are given a name for ease of reference. Methods are
    important because they enable us to abstract away the implementation, while at
    the same time helping us to avoid unnecessary code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to a method: the method definition (or declaration) and
    the method call (or invocation). The method definition declares (among other things)
    the method name, the input parameters, and the return type. The method name and
    the parameter types (including their order) constitute the method signature. The
    method call passes down the arguments (if any) to be used as inputs in the method.
    The return value from a method (if there is one) can be captured by assigning
    the method call to a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading is where the same method name is used across several different
    methods. What distinguishes the various methods is that they have different signatures
    – the parameter types and/or their order will be different. The parameter names
    and return types do not matter.
  prefs: []
  type: TYPE_NORMAL
- en: A `varargs` (variable arguments) parameter is specified in a method declaration
    using an ellipsis (three dots). This means that when calling this method, the
    arguments corresponding to that parameter are variable – you can pass down `0`
    or more arguments for that parameter. Internally, in the method, the `varargs`
    parameter is treated as an array.
  prefs: []
  type: TYPE_NORMAL
- en: When passing arguments to a method, Java uses call by value. This means that
    a copy of the argument is made. Depending on whether you are passing down a primitive
    or a reference has major implications regarding the effect of the changes that
    are made by the called method on the calling method. If it’s a primitive, the
    called method cannot change the primitive that the caller method has (unless the
    caller method deliberately overwrites the variable with the return value). If
    it’s a reference, the called method can change the object that the caller method
    is looking at.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished looking at methods, let’s move on to our first strictly
    **object-oriented programming** (**OOP**) chapter, where we will look at classes,
    objects, and enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Object-Oriented Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will take a deep dive into `abstract` classes and the hugely
    important `interface` construct. Following that, we will examine Java’s exception
    framework. Lastly, we will explore selected classes from the Java Core API, such
    as `String` and `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), *Classes, Objects, and Enums*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), *Inheritance and Polymorphism*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19793_10.xhtml#_idTextAnchor249), *Interfaces and Abstract
    Classes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19793_11.xhtml#_idTextAnchor266), *Dealing with Exceptions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19793_12.xhtml#_idTextAnchor293), *Java Core API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
