- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: In [*Chapter 6*](B19793_06.xhtml#_idTextAnchor118), we learned about arrays
    in Java. We learned that arrays are data structures that are fixed in size. They
    are stored in contiguous memory locations where each location is of the same type.
    We also saw how to declare, initialize, and process arrays. Both the traditional
    and enhanced `for` loops are ideal for processing arrays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19793_06.xhtml#_idTextAnchor118)中，我们学习了Java中的数组。我们了解到数组是固定大小的数据结构。它们存储在连续的内存位置中，每个位置的数据类型相同。我们还看到了如何声明、初始化和处理数组。传统和增强的`for`循环都非常适合处理数组。
- en: In addition, we discussed multi-dimensional arrays, including how they are organized
    and how to process them. Lastly, as arrays are very common, we discussed the `Arrays`
    class, which has several useful methods for processing arrays.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了多维数组，包括它们的组织方式和处理方法。最后，由于数组非常常见，我们讨论了`Arrays`类，它有几个用于处理数组的实用方法。
- en: In this chapter, we will cover methods. Methods enable us to create a named
    block of code that can be executed from elsewhere in the code. Firstly, we will
    explain why methods are so commonplace. You will learn the difference between
    the method definition and the method invocation. We will explore what a method
    signature is and how method overloading enables methods to have the same name,
    without conflict. We will also explain variable arguments (`varargs`), which enable
    a method to be executed with 0 or more arguments. Lastly, Javas’ principle of
    call-by-value for passing arguments (and returning values) will be outlined. By
    the end of this chapter, you will be well able to code and execute methods. In
    addition, you will understand method overloading, `varargs`, and Javas’ call-by-value
    mechanism.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍方法。方法使我们能够创建一个可以执行于代码其他部分的命名代码块。首先，我们将解释为什么方法如此普遍。您将学习方法定义和方法调用的区别。我们将探讨方法签名是什么，以及方法重载如何使方法具有相同的名称，而不产生冲突。我们还将解释变量参数（`varargs`），它允许方法以0个或多个参数执行。最后，我们将概述Java的按值传递参数（和返回值）的原则。到本章结束时，您将能够编写和执行方法。此外，您将理解方法重载、`varargs`和Java的按值调用机制。
- en: 'This chapter covers the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Explaining why methods are important
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释为什么方法很重要
- en: Understanding the difference between method definition and method execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解方法定义和方法执行之间的区别
- en: Exploring method overloading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: Explaining `varargs`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`varargs`
- en: Mastering call by value
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握按值调用
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7)。
- en: Explaining why methods are important
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释为什么方法很重要
- en: Methods are code blocks that are given a name for ease of reference. They can
    accept inputs and return an output. Both the inputs and output are optional. A
    method should do one task and do it well. It is considered good practice to keep
    your methods short (less than 20 lines). The longer the method, the more likely
    it is that the method is doing too much. The maxim of “keep it simple” applies
    here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是为便于引用而命名的代码块。它们可以接受输入并返回输出。输入和输出都是可选的。方法应该完成一个任务并且做得很好。将方法保持简短（少于20行）被认为是良好的实践。方法越长，它做得多的事情就越多。这里的“保持简单”的原则适用。
- en: Flow of control
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流程
- en: 'Simply put, when a method is called (executed), the normal flow of control
    of execution is changed. Let us discuss a simple example that will help demonstrate
    this. This is an important point to appreciate, especially for inexperienced developers.
    *Figure 7**.1* presents the code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当方法被调用（执行）时，执行的控制流程会发生变化。让我们讨论一个简单的例子，这将有助于展示这一点。这是一个重要的观点，特别是对于经验不足的开发者来说。*图7.1*展示了代码：
- en: '![Figure 7.1 – A very simple method](img/B19793_07_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 一个非常简单的函数](img/B19793_07_1.jpg)'
- en: Figure 7.1 – A very simple method
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 一个非常简单的函数
- en: 'In this example, we have two methods: the `main()` method (lines 4 to 8) and
    the `simpleExample()` method (lines 9 to 11). Both exist inside the `Methods`
    class (lines 3 to 12).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个方法：`main()`方法（第4至8行）和`simpleExample()`方法（第9至11行）。它们都存在于`Methods`类中（第3至12行）。
- en: In Java, every program starts with the `main()` method. The JVM calls it on
    our behalf; we do not have to call (or execute) it ourselves. Therefore, in this
    example, the first line in `main()`, line 5, is the first line to execute.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个程序都以`main()`方法开始。JVM代表我们调用它；我们不必自己调用（或执行）它。因此，在这个例子中，`main()`中的第一行，第5行，是第一条要执行的行。
- en: Line 6 is important – it is what we refer to as a method call. There is a direct
    correlation between the `simpleExample()` method definition on line 9 and the
    method call on line 6\. We will discuss this relationship shortly. For the moment,
    just understand that the method call changes the order of execution of the program.
    Normally, Java executes lines of code from top to bottom and this is true. However,
    *method calls alter that*. In this example, when line 6 executes, the next line
    to execute is line 10 (inside the `simpleExample()` method).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行很重要——这就是我们所说的方法调用。第9行的`simpleExample()`方法定义与第6行的方法调用之间存在直接关联。我们将在稍后讨论这种关系。目前，只需理解方法调用改变了程序的执行顺序。通常，Java从上到下执行代码行，这是真的。然而，*方法调用改变了这一点*。在本例中，当第6行执行时，接下来要执行的行是第10行（在`simpleExample()`方法内部）。
- en: So, the `main()` method has now handed over control to the `simpleExample()`
    method, and control will not return to `main()` until `simpleExample()` exits.
    This can occur when execution hits the closing `}` at the end of the `simpleExample()`
    method (line 11). This is what happens in this example. Alternatively, a method
    can exit by using the `return` keyword.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`main()`方法现在已经将控制权交给了`simpleExample()`方法，并且只有在`simpleExample()`方法退出后，控制才会返回到`main()`。这可以在执行到`simpleExample()`方法末尾的闭合`}`时发生（第11行）。这正是本例中的情况。或者，一个方法可以通过使用`return`关键字来退出。
- en: So, line 6 calls the `simpleExample()` method, causing its code to execute.
    Line 10 outputs some text to the screen. The closing `}` on line 11 causes `simpleExample()`
    to exit and control now returns to `main()`, where execution resumes at line 7.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第6行调用了`simpleExample()`方法，导致其代码执行。第10行将一些文本输出到屏幕上。第11行的闭合`}`导致`simpleExample()`退出，现在控制权返回到`main()`，执行从第7行恢复。
- en: 'In summary, the order of execution in this program is illustrated by the output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个程序的执行顺序可以通过输出来说明：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you can see that `println()`, inside the `simpleExample()` method, is
    sandwiched between the two `println()` statements from `main()`. This demonstrates
    that the flow of control was altered by the method call on line 6.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`println()`，在`simpleExample()`方法内部，被`main()`方法中的两个`println()`语句所包围。这表明控制流在第六行的方法调用中被改变。
- en: The stack
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: So, how can a caller method, such as `main()`, simply *resume* where it left
    off after the `simpleExample()` method returns? What about the local variables
    of `main()`?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，调用方法，例如`main()`，如何在`simpleExample()`方法返回后简单地*恢复*到它离开的地方？`main()`的局部变量又是如何的呢？
- en: The ability of a method to resume exactly where it left off, after the method
    it called returns, requires the use of a memory structure called the *stack*.
    We will discuss the stack later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方法能够在调用它的方法返回后精确地恢复到它离开的地方，这需要使用一种称为*栈*的内存结构。我们将在本章后面讨论栈。
- en: Returning to our *why methods are important’ discussion*, two major advantages
    of methods are that they provide abstraction and avoid code duplication. Let’s
    examine these in turn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们关于“为什么方法很重要”的讨论，方法的主要优势有两个：它们提供了抽象并避免了代码重复。我们将依次探讨这些优势。
- en: Abstraction
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is a principle in software engineering where clients of a service,
    are abstracted from the service implementation. This decouples clients, who use
    the service, from knowing how the service is implemented. Thus, if the service
    implementation is changed, the clients are not impacted.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是软件工程中的一个原则，其中服务的客户端被从服务实现中抽象出来。这解耦了使用服务的客户端，使他们不必知道服务是如何实现的。因此，如果服务实现发生变化，客户端不会受到影响。
- en: Take, for example, a McDonald’s drive-thru where you drive up and place your
    order. In this situation, you are the client of the McDonald’s service. You do
    not care how McDonald’s process your order; you simply want to place an order
    and receive the food/drinks. If McDonald’s changes its internal implementation,
    you are shielded (abstracted) from those changes. This is known as abstraction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以麦当劳的免下车服务为例，你开车到那里并下订单。在这种情况下，你是麦当劳服务的客户。你不在乎麦当劳如何处理你的订单；你只是想下订单并收到食物/饮料。如果麦当劳更改其内部实现，你会受到保护（抽象化）免受这些更改的影响。这被称为抽象。
- en: For our purposes, the method itself is the McDonald’s service. The method call
    is the McDonald’s customer. The method call is abstracted from internal changes
    to the method code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的而言，方法本身就像是麦当劳的服务。方法调用就像是麦当劳的客户。方法调用抽象了方法代码的内部变化。
- en: Code duplication
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重复
- en: 'Methods can help us avoid code replication. This has the added benefit of easing
    debugging. Let’s look at a simple example of this. *Figure 7**.2* demonstrates
    duplicated code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以帮助我们避免代码重复。这还有一个额外的优点，就是简化调试。让我们来看一个简单的例子。*图 7.2* 展示了重复的代码：
- en: '![Figure 7.2 – Duplicated code](img/B19793_07_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 重复的代码](img/B19793_07_2.jpg)'
- en: Figure 7.2 – Duplicated code
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 重复的代码
- en: In the preceding figure, lines 8 to 12 are repeated on lines 14 to 18 and lines
    20 to 24\. Each of these sections prompts the user for a number, stores the user
    input in a variable named `number`, and checks to see if the number is in range.
    If the number is out of range, then an error is flagged. While a loop would be
    an obvious improvement, bear in mind that these lines of code could well be in
    separate parts of the program. In addition, for this simple example, we are only
    interested in highlighting code duplication. We simply prompt for a number, accept
    the user’s input, and validate it. The result is five lines of code repeated three
    times.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第 8 行到第 12 行在第 14 行到第 18 行重复，第 20 行到第 24 行也重复。这些部分中的每一个都提示用户输入一个数字，将用户输入存储在名为
    `number` 的变量中，并检查该数字是否在范围内。如果数字超出范围，则标记错误。虽然循环会是一个明显的改进，但请记住，这些代码行可能位于程序的单独部分。此外，对于这个简单的例子，我们只对突出代码重复感兴趣。我们只是提示输入一个数字，接受用户的输入，并验证它。结果是五行代码重复了三次。
- en: 'Now, let’s assume that we want to adjust the upper valid range from 10 to 100\.
    We have to change the prompts on lines 8, 14, and 20\. In addition, the `if` statements
    on lines 10, 16, and 22 need to change. Thus, a simple range adjustment has resulted
    in quite a few code changes and we could easily forget to make one or more of
    the changes required. Let’s refactor the code into a method. *Figure 7**.3* shows
    the refactored code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将有效范围从 10 调整到 100。我们必须修改第 8、14 和 20 行的提示。此外，第 10、16 和 22 行的 `if` 语句也需要修改。因此，简单的范围调整导致了相当多的代码更改，我们很容易忘记进行一个或多个必要的更改。让我们将代码重构为一个方法。*图
    7.3* 展示了重构后的代码：
- en: '![Figure 7.3 – The code from Figure 7.2 refactored to use a method](img/B19793_07_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 将图 7.2 中的代码重构为使用方法](img/B19793_07_3.jpg)'
- en: Figure 7.3 – The code from Figure 7.2 refactored to use a method
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 将图 7.2 中的代码重构为使用方法
- en: In the preceding figure, the method itself is coded from lines 9 to 17 and will
    be explained in detail in the next section. The five lines of repeated code from
    *Figure 7**.2* are coded only once, on lines 11 to 15\. The execution calls of
    the method are on lines 5, 6, and 7; one execution call per line. If we want to
    change the upper valid range from 10 to 100, we just need to change the method
    – that is, lines 11 and 13\. These two changes are *automatically* reflected throughout
    the code. In effect, the three method calls on lines 5, 6, and 7 automatically
    reflect the changes made in the method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，方法本身是从第 9 行到第 17 行编写的，将在下一节中详细解释。*图 7.2* 中的五行重复代码只在第 11 行到第 15 行编写了一次。方法的执行调用在第
    5、6 和 7 行；每行一个执行调用。如果我们想将有效范围从 10 调整到 100，我们只需修改方法即可——即第 11 和第 13 行。这两个更改会*自动*反映在整个代码中。实际上，第
    5、6 和 7 行的三个方法调用会自动反映方法中的更改。
- en: As you can imagine, this situation scales very well. For example, if, in *Figure
    7**.2*, we had duplicated the code 10 times, we would have to make changes in
    10 areas of the code. However, with the method implementation, there is still
    *only one* location to make the change and that is in the method itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这种情况非常易于扩展。例如，如果在*图 7.2* 中我们重复了代码 10 次，我们就需要在代码的 10 个区域进行更改。然而，有了方法实现，仍然只有*一个*地方需要更改，那就是方法本身。
- en: Now that we have justified why methods exist, let’s examine the difference between
    the method itself and the method call.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解释了为什么需要方法，让我们来检查方法本身和方法调用之间的区别。
- en: Understanding the difference between method definition and method execution
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解方法定义和方法执行之间的区别
- en: For those new to programming, it may surprise you to know that there are two
    parts to having a method *do* something. Firstly, we must code the method (the
    method definition). This is similar to a bank machine on the street – it just
    sits there, doing nothing, waiting to be used. Secondly, we must execute the method
    (the method execution). This is similar to a customer “using” the bank machine.
    Remember that the `main` method is the only method that is automatically executed
    by the JVM. Any other method calls have to be explicitly coded.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编程新手来说，可能会惊讶地知道，要让方法*做*某事有两个部分。首先，我们必须编写方法（方法定义）。这类似于街上的自动取款机 – 它只是静静地坐着，什么也不做，等待被使用。其次，我们必须执行方法（方法执行）。这类似于客户“使用”自动取款机。记住，`main`方法是唯一由JVM自动执行的方法。任何其他方法调用都必须明确编码。
- en: Now, let’s examine the method definition and method execution in turn.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们依次检查方法定义和方法执行。
- en: Method definition
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法定义
- en: 'The method definition (declaration) is the method code itself - this is the
    block of code that is executed when the method is called. *Figure 7**.4* presents
    the syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义（声明）本身就是方法代码 - 这是在调用方法时执行的代码块。*图7.4* 展示了语法：
- en: '![Figure 7.4 – The syntax of the method definition](img/B19793_07_4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 方法定义的语法](img/B19793_07_4.jpg)'
- en: Figure 7.4 – The syntax of the method definition
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 方法定义的语法
- en: In the preceding figure, as in other figures, square brackets signify optional
    elements. The `access-modifier` and `static` elements will be discussed in [*Chapter
    8*](B19793_08.xhtml#_idTextAnchor168). The `throws` `someException` element will
    be covered in [*Chapter 11*](B19793_11.xhtml#_idTextAnchor266). In this chapter,
    we will focus on the elements in bold; namely, `return-type` (mandatory), `methodName`
    (mandatory), and `parameters` (optional).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，与其他图一样，方括号表示可选元素。`access-modifier` 和 `static` 元素将在[*第8章*](B19793_08.xhtml#_idTextAnchor168)中讨论。`throws`
    `someException` 元素将在[*第11章*](B19793_11.xhtml#_idTextAnchor266)中介绍。在本章中，我们将重点关注加粗的元素；即，`return-type`（必需）、`methodName`（必需）和`parameters`（可选）。
- en: The return type of the method can be a primitive type, a reference type, or
    `void`. The `void` keyword means that the method is not returning anything. If
    that is the case, you *cannot* simply leave out the return type; you must specify
    `void`. In addition, when you’re not returning anything from a method, you can
    specify `return;` or simply leave out the `return` keyword altogether (which is
    what we have done for all the `main()` methods).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '方法的返回类型可以是原始类型、引用类型或`void`。`void`关键字表示该方法不返回任何内容。如果是这种情况，你*不能*简单地省略返回类型；你必须指定`void`。此外，当你从方法中不返回任何内容时，你可以指定`return;`或完全省略`return`关键字（这是我们为所有`main()`方法所做的那样）。 '
- en: 'Let’s examine a method that accepts input and returns a result. *Figure 7**.5*
    presents such an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个接受输入并返回结果的方法。*图7.5* 展示了这样一个例子：
- en: '![Figure 7.5 – Sample method definition](img/B19793_07_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 示例方法定义](img/B19793_07_5.jpg)'
- en: Figure 7.5 – Sample method definition
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 示例方法定义
- en: In the preceding figure, we have a method that takes in two integers and a mathematical
    operation to be performed using the two integers as operands. For example, if
    `"+"` is passed in, the two numbers are added and the result is returned. Let’s
    review how the method does this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个接受两个整数和一个要使用这两个整数作为操作数执行数学运算的方法。例如，如果传入`"+"`，则两个数字相加并返回结果。让我们回顾一下方法是如何做到这一点的。
- en: Line 15 is very important. For the moment, as stated earlier, [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168)
    will explain both `public` (access-modifier) and `static`. The `return-type` is
    an `int` – meaning, this method returns whole numbers. The name of the method
    is `performCalc`. Method names often begin with verbs and follow camel casing
    style.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行非常重要。目前，如前所述，[*第8章*](B19793_08.xhtml#_idTextAnchor168)将解释`public`（访问修饰符）和`static`。`return-type`是`int`
    – 这意味着这个方法返回整数。方法的名字是`performCalc`。方法名通常以动词开头，并遵循驼峰命名法。
- en: Note that round brackets follow the method name. The round brackets are delimiters
    for the optional input parameters to the method. For each parameter, you must
    specify the data type of the parameter (as Java is a strongly typed language)
    and the parameter’s identifier name. If you have two or more parameters, comma-separate
    them. These parameters are how the method accepts input. In *Figure 7**.5*, we
    have two integers namely `x` and `y`, followed by a `String` called `operation`.
    The scope of any method parameters, in this case, `x`, `y`, and `operation`, is
    the whole of the method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，圆括号跟在方法名后面。圆括号是方法可选输入参数的分隔符。对于每个参数，你必须指定参数的数据类型（因为 Java 是一种强类型语言）和参数的标识符名称。如果你有两个或更多参数，用逗号分隔它们。这些参数是方法接受输入的方式。在
    *图 7.5* 中，我们有两个整数 `x` 和 `y`，后面跟着一个名为 `operation` 的 `String`。在这种情况下，任何方法参数（例如 `x`、`y`
    和 `operation`）的作用域是整个方法。
- en: Lines 16-26 encapsulate a `switch` expression. In effect, depending on the mathematical
    `operation` passed in, that operation is performed on the two inputs, `x` and
    `y`. The local `int` variable, `result`, is initialized accordingly. The `result`
    variable is returned on line 27\. As the return type declared on line 15 is an
    `int`, returning `result`, which is also an `int`, is fine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16-26 行封装了一个 `switch` 表达式。实际上，根据传入的数学 `operation`，该操作会在两个输入 `x` 和 `y` 上执行。局部
    `int` 变量 `result` 根据相应地初始化。第 27 行返回 `result` 变量。由于第 15 行声明的返回类型是 `int`，返回 `result`（它也是一个
    `int`），这是可以的。
- en: A method definition in and of itself does not do anything. It just defines a
    block of code. As stated previously, this is similar to a bank machine on the
    street – it just sits there, doing nothing, waiting to be used. For the bank machine
    to be useful, you must “use” it. Similarly, we must “use” the method – this is
    what we call executing the method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义本身并不做任何事情。它只是定义了一块代码。如前所述，这类似于街上的自动取款机 – 它只是坐在那里，什么也不做，等待被使用。为了让自动取款机有用，你必须“使用”它。同样，我们必须“使用”方法
    – 这就是我们所说的执行方法。
- en: Method execution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法执行
- en: Executing the method is also known as calling or invoking the method. The method
    that calls the method is known as the “calling” (or caller) method. So, you have
    the calling method and the called method. When you call a method, you pass down
    the required arguments, if there are any. The called method will execute at this
    point. When the called method finishes, control returns to the caller method.
    The called method’s result, if there is one, is also returned. This enables the
    called method to return data to the caller method, where it can be output to the
    screen, stored in a variable, or simply ignored.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行方法也称为调用或调用方法。调用方法的方法称为“调用”方法（或调用者方法）。所以，你有调用方法和被调用方法。当你调用一个方法时，如果你有，你会传递所需的参数。被调用方法将在这一点上执行。当被调用方法完成后，控制权返回到调用方法。如果被调用方法有结果，该结果也会返回。这使得被调用方法能够将数据返回给调用方法，在那里它可以输出到屏幕、存储在变量中，或者简单地被忽略。
- en: Method parameters versus method arguments
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数与方法参数
- en: The method definition defines parameters, whereas the method call passes down
    arguments. These terms are often used interchangeably.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义定义了参数，而方法调用传递参数。这些术语通常被交替使用。
- en: '*Figure 7**.6* presents a code example to help explain this further:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.6* 展示了一个代码示例，以帮助进一步解释这一点：'
- en: '![Figure 7.6 – Sample code demonstrating method calls](img/B19793_07_6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 展示方法调用的示例代码](img/B19793_07_6.jpg)'
- en: Figure 7.6 – Sample code demonstrating method calls
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 展示方法调用的示例代码
- en: IntelliJ IDEA inlay hints
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 内联提示
- en: 'Note that the IntelliJ editor inserts inlay hints when you are coding. In the
    previous figure, the `performCalc` method signature (line 13) specifies that the
    parameters are namely `x`, `y`, and `operation`. That is why on each method call,
    the inlay hint uses these parameter names. For example, on line 5, we typed in
    10 as the first argument; however, IntelliJ, upon inspecting the method signature,
    realized that 10 was mapping to ‘x’ and that is why you see “`performCalc(10,
    2, "+")` and IntelliJ converted that to `performCalc(x: 10, y: 2,` `operation:
    "+").`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，当你编码时，IntelliJ 编辑器会插入内联提示。在上一幅图中，`performCalc` 方法签名（第 13 行）指定参数为 `x`、`y`
    和 `operation`。这就是为什么在每个方法调用中，内联提示都使用这些参数名称。例如，在第 5 行，我们输入了 10 作为第一个参数；然而，IntelliJ
    在检查方法签名后意识到 10 映射到 ‘x’，这就是为什么你会看到“`performCalc(10, 2, "+")`”以及 IntelliJ 将其转换为
    `performCalc(x: 10, y: 2, operation: "+")` 的原因。'
- en: In *Figure 7**.6*, the `performCalc` method (lines 13-26) is unchanged from
    *Figure 7**.5*. However, we can now see the various method calls (lines 5 and
    7-11).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7**.6中，`performCalc`方法（第13-26行）与**图7**.5中的没有变化。然而，我们现在可以看到各种方法调用（第5行和第7-11行）。
- en: Let’s start with line 5\. On the right-hand side of the assignment, we have
    the `performCalc(10, 2, "+")` method call. This method call has higher precedence
    than the assignment, so it is executed first. The IntelliJ IDE does a very nice
    job of highlighting that `10` will be passed into the method as `x`, `2` will
    be passed into the method as `y`, and `"+"` will be passed in as `operation`.
    It is very important to realize that once we get to the method call on line 5,
    the next line of code that’s executed is line 14 – so, from line 5, we jump into
    the `performCalc` method and start executing the `switch` expression on line 14.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第5行开始。在赋值的右侧，我们有`performCalc(10, 2, "+")`方法的调用。这个方法调用比赋值有更高的优先级，所以它首先被执行。IntelliJ
    IDE非常出色地突出显示了`10`将被作为`x`传递给方法，`2`将被作为`y`传递给方法，而`"+"`将作为`operation`传递。非常重要的一点是，一旦我们到达第5行的方法调用，接下来执行的代码是第14行——所以，从第5行开始，我们跳入`performCalc`方法，并开始执行第14行的`switch`表达式。
- en: Since `operation` is `"+"` for this method invocation, line 15 assigns 10 +
    2 (12) to `result`. Line 25 returns `result` back to the calling method (line
    5), where the value 12 is assigned into `result`. Line 6 outputs the return value
    from the `performCalc` invocation on line 5, which is 12.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这次方法调用中的`operation`是`"+"`，第15行将10 + 2（12）赋值给`result`。第25行将`result`的值返回到调用方法（第5行），其中值12被赋值给`result`。第6行输出了第5行`performCalc`调用的返回值，即12。
- en: Different scopes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的作用域
- en: Note that the two `result` variables (lines 5 and 14) are completely different
    as they are in two separate scopes – one is in the `main()` method and the other
    is in the `performCalc` method. As a result, there is no conflict or ambiguity
    whatsoever.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个`result`变量（第5行和第14行）完全不同，因为它们在不同的作用域中——一个在`main()`方法中，另一个在`performCalc`方法中。因此，没有任何冲突或歧义。
- en: Line 7 executes `System.out.println()` with a method call inside the `()` of
    `println`. In this scenario, Java will execute the method call inside the `()`
    of `println`, and whatever the method returns will then be output to the screen.
    So, for line 7, the arguments passed to `performCalc` are `10`, `2`, and `"-"`.
    Therefore, in `performCalc`, `x` is 10, `y` is 2, and `operation` is `"-"`. The
    `switch` expression now executes line 16, resulting in `result` becoming 8 (10
    -2). This `result` is returned (line 25) back to the calling method (line 7),
    where `8` is output to the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行在`println`的`()`内执行了`System.out.println()`方法调用。在这种情况下，Java将执行`println`的`()`内的方法调用，然后方法返回的内容将被输出到屏幕。所以，对于第7行，传递给`performCalc`的参数是`10`、`2`和`"-"`。因此，在`performCalc`中，`x`是10，`y`是2，`operation`是`"-"`。`switch`表达式现在执行第16行，导致`result`变为8（10
    - 2）。这个`result`被返回（第25行）到调用方法（第7行），其中`8`被输出到屏幕。
- en: Lines 8 and 9 operate similarly to line 7 except that the lines of code executed
    in the `switch` expression are different. The method call on line 8 executes line
    17 in the `switch` expression, resulting in `result` being initialized to 20\.
    This value is returned to the calling method (line 8), where `20` is output to
    the screen. The method call on line 9 executes line 18 in the `switch` expression,
    resulting in `result` being initialized to 5, and thus `5` is output to the screen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行和第9行的操作与第7行类似，除了`switch`表达式中执行的代码行不同。第8行的方法调用执行了`switch`表达式中的第17行，导致`result`被初始化为20。这个值被返回到调用方法（第8行），其中`20`被输出到屏幕。第9行的方法调用执行了`switch`表达式中的第18行，导致`result`被初始化为5，因此`5`被输出到屏幕。
- en: Line 10 causes line 19 in the `switch` expression to be executed, initializing
    `result` to `0` (10 % 2). This `result` is returned back to the calling method,
    where, because it is not stored in a variable, it is simply lost/ignored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第10行导致`switch`表达式中的第19行被执行，初始化`result`为`0`（10 % 2）。这个`result`被返回到调用方法，由于它没有被存储在变量中，所以它只是被丢失/忽略。
- en: 'The `performCalc` call on line 11 passes in `"&"`, which executes the `default`
    branch of the `switch` expression. This results in the error message “Unrecognized
    operation: &” being displayed on the screen and -1 being returned. The -1 is then
    output on the screen.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行的`performCalc`调用传递了`"&"`，这执行了`switch`表达式的`default`分支。这导致屏幕上显示错误消息“未识别的操作：&”，并返回-1。然后-1被输出到屏幕。
- en: Now that we know how to define and execute methods, we will move on to discussing
    method overloading, where distinct methods can have the same identifier name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何定义和执行方法，我们将继续讨论方法重载，其中不同的方法可以具有相同的标识符名称。
- en: Exploring method overloading
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: Consider a scenario where you have an algorithm, implemented by a method, that
    operates similarly on various input types – for example, `String` and `int`. It
    would be a shame to have two separately contrived method names, one for each input
    type, such as `doStuffForString(String)` and `doStuffForInt(int)`. It would be
    much better if both methods had the same name – that is, `doStuff` – differentiated
    by their input types, which are `doStuff(String)` and `doStuff(int)`. Thus, there
    will be no contrived method names. This is what method overloading provides. To
    discuss method overloading properly, we must first define the method signature.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你有一个算法，通过一个方法实现，它在各种输入类型上操作相似——例如`String`和`int`。如果为每种输入类型分别构造两个不同的方法名，比如`doStuffForString(String)`和`doStuffForInt(int)`，那就太遗憾了。如果两个方法都有相同的名称——即`doStuff`——并通过它们的输入类型区分，即`doStuff(String)`和`doStuff(int)`，那就好多了。这样就不会有构造的方法名。这正是方法重载提供的。为了正确地讨论方法重载，我们首先必须定义方法签名。
- en: Method signature
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法签名
- en: 'The method signature consists of the method’s name and the optional parameters.
    It does *not* consist of the return type. Let’s look at an example to explain
    this further:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名由方法名和可选参数组成。它*不*包括返回类型。让我们通过一个例子来进一步解释这一点：
- en: '![Figure 7.7 – Method signature](img/B19793_07_7.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 方法签名](img/B19793_07_7.jpg)'
- en: Figure 7.7 – Method signature
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 方法签名
- en: In the preceding figure, the method signature is highlighted in a dashed rectangle.
    It consists of the name of the method, followed by both the type and the order
    of the parameters. What this means is that the signature for the method in *Figure
    7**.7* is `performCalc`, which takes in two integers and a `String`, *in that
    order*. Note that the parameter names do not matter. So, in effect, from the perspective
    of the compiler, the method signature is `performCalc(int,` `int, String)`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，方法签名用虚线矩形突出显示。它由方法名、参数的类型和顺序组成。这意味着图*7.7*中的方法签名是`performCalc`，它接受两个整数和一个`String`，*按此顺序*。请注意，参数名并不重要。因此，实际上，从编译器的角度来看，方法签名是`performCalc(int,
    int, String)`。
- en: Overloading a method
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'A method is overloaded when two or more methods share the same name but the
    parameters are different in type and/or order. This makes sense if you consider
    this from the viewpoint of the compiler. If you call a method that has two or
    more definitions, how will the compiler know which one you are referring to? To
    locate the correct method definition, the compiler compares and matches the method
    call with the overloaded method signatures. *Figure 7**.8* presents an overloaded
    method with various signatures:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个方法具有相同的名称但参数类型和/或顺序不同时，方法就是重载的。如果你从编译器的角度来看，这很有意义。如果你调用一个有两个或多个定义的方法，编译器将如何知道你指的是哪一个？为了定位正确的方法定义，编译器会将方法调用与重载的方法签名进行比较和匹配。*图7.8*展示了一个具有各种签名的重载方法：
- en: '![Figure 7.8 – The method signature’s impact on overloading](img/B19793_07_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 方法签名对重载的影响](img/B19793_07_08.jpg)'
- en: Figure 7.8 – The method signature’s impact on overloading
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 方法签名对重载的影响
- en: In this figure, the `someMethod` method is overloaded several times. The method
    signatures on lines 6 to 10 are `someMethod()`, `someMethod(int)`, `someMethod(double)`,
    `someMethod(String)`, and `someMethod(double,` `int)`, respectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`someMethod`方法被重载了多次。第6到第10行的方法签名分别是`someMethod()`、`someMethod(int)`、`someMethod(double)`、`someMethod(String)`和`someMethod(double,
    int)`。
- en: The interesting cases are the compiler errors on lines 11-13\. The error on
    line 11 is a misleading error from the compiler. In other words, if we comment
    out lines 12 and 13, the compiler error on line 11 disappears. There is nothing
    wrong with line 11 as this is the first time the compiler has seen this particular
    method signature – that is, `someMethod(int, double)`. The problem is that lines
    12 to 13 have the same signatures and the compiler is flagging all lines with
    that signature.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的案例是第11-13行的编译器错误。第11行的错误是编译器的一个误导性错误。换句话说，如果我们注释掉第12和第13行，第11行的编译器错误就会消失。第11行没有问题，因为这是编译器第一次看到这个特定的方法签名——即`someMethod(int,
    double)`。问题是第12到第13行有相同的方法签名，编译器正在标记所有具有该签名的行。
- en: Line 12 reinforces the point that the parameter names do not matter as they
    are not part of the method signature. Therefore, the fact that they are named
    `x` and `y` on line 11 and `a` and `b` on line 12 makes no difference whatsoever.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行强调了参数名称并不重要，因为它们不是方法签名的一部分。因此，它们在11行被命名为`x`和`y`，在12行被命名为`a`和`b`，这根本无关紧要。
- en: Similarly, line 13 demonstrates that the return type is not part of the method
    signature. Line 13 is a compiler error because its signature, `someMethod(int,
    double)`, is the same as on lines 11 and 12, even though the two methods have
    different return types (`int` and `void`, respectively).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第13行表明返回类型不是方法签名的一部分。第13行是一个编译器错误，因为它的签名`someMethod(int, double)`与第11行和第12行的签名相同，尽管这两个方法有不同的返回类型（分别是`int`和`void`）。
- en: 'In summary, the return type and parameter names are *not* part of the method
    signature. Now that we understand what is (and what is not) part of the method
    signature, let’s look at a simple example of method overloading. *Figure 7**.9*
    presents the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，返回类型和参数名称都不是方法签名的一部分。现在我们已经了解了方法签名中包含什么（以及不包含什么），让我们看看一个简单的方法重载示例。*图7.9*展示了代码：
- en: '![Figure 7.9 – Method overloading example](img/B19793_07_9.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 方法重载示例](img/B19793_07_9.jpg)'
- en: Figure 7.9 – Method overloading example
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 方法重载示例
- en: In this figure, we have an overloaded `add` method. The first version (lines
    10 to 13) takes in two `int` parameters; the second version (lines 14-17) takes
    in two `double` parameters. Their respective signatures are captured on lines
    10 and 14, respectively. Thus, when we call `add` on line 5 and pass down two
    integers, the compiler matches the call with the version of `add` on line 10 because
    that version of `add` takes two integers. Similarly, the call to `add` on line
    7 matches `add` on line 14 because both the call and method signature match (two
    `double` types in both).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有一个重载的`add`方法。第一个版本（第10到13行）接受两个`int`参数；第二个版本（第14-17行）接受两个`double`参数。它们各自的签名分别在第10行和第14行捕获。因此，当我们第5行调用`add`并传递两个整数时，编译器将调用与第10行的`add`版本匹配，因为该版本的`add`接受两个整数。同样，第7行的`add`调用与第14行的`add`匹配，因为调用和方法签名都匹配（两者都是两个`double`类型）。
- en: Now that we understand how method parameter types and their order affect method
    overloading, let’s examine how Java enables us to execute methods where the number
    of arguments is variable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了方法参数类型及其顺序如何影响方法重载，让我们来看看Java如何使我们能够执行参数数量可变的函数。
- en: Explaining varargs
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释可变参数
- en: 'Consider the following situation: you want to call a method, `m1`, but the
    number of arguments may vary. Do you overload the method with each version of
    the method taking in one extra parameter? For example, assuming the argument types
    are of the `String` type, do you overload `m1` when each new version takes in
    an extra `String` parameter? In this case, you would have to code `m1(String)`,
    `m1(String, String)`, `m1(String, String, String)`, and so forth. This is not
    scalable.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况：你想调用一个方法`m1`，但参数的数量可能不同。你是否需要为每个版本的方法重载，每个版本的方法都多接受一个参数？例如，假设参数类型是`String`类型，你是否在每次新版本中多接受一个`String`参数时重载`m1`？在这种情况下，你将不得不编写`m1(String)`、`m1(String,
    String)`、`m1(String, String, String)`等等。这并不具有可扩展性。
- en: 'This is where `varargs` comes in. `varargs` is a very flexible language feature
    in Java, specifically provided for this use case. The syntax is that the type
    name is followed by an ellipsis (three dots). *Figure 7**.10* shows `varargs`
    in action:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`varargs`发挥作用的地方。`varargs`是Java中一个非常灵活的语言特性，专门为此用例提供。语法是类型名称后跟省略号（三个点）。*图7.10*显示了`varargs`的实际应用：
- en: '![Figure 7.10 – varargs example](img/B19793_07_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 可变参数示例](img/B19793_07_10.jpg)'
- en: Figure 7.10 – varargs example
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 可变参数示例
- en: In this figure, on line 10, `m1(int… )` defines a method signature for the `m1`
    method, defining 0 or more `int` parameters. This is quite different from `String[]`
    defined on line 4 for `main`. In effect, you don’t have to pass in any argument
    to `m1` at all; or you can pass in 1, 2, 3, or more integers. This is shown by
    the method calls (lines 5-8). Internally, in the `m1` method, `varargs` is treated
    as an array. The `for` loop (lines 12-14) demonstrate that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，在第10行，`m1(int… )`为`m1`方法定义了一个方法签名，定义了0个或多个`int`参数。这与第4行定义的`main`的`String[]`非常不同。实际上，你根本不需要向`m1`传递任何参数；或者你可以传递1个、2个、3个或更多的整数。这通过方法调用（第5-8行）显示出来。在`m1`方法内部，`varargs`被视为一个数组。第12-14行的`for`循环展示了这一点。
- en: 'The output from *Figure 7**.10* is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.10*的输出如下：'
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Line 5 generates no output at all. Line 6 generates `1`; line 7 generates `3`;
    and line 8 generates `6`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行没有任何输出。第6行生成`1`；第7行生成`3`；第8行生成`6`。
- en: 'Let’s examine some edge cases with `varargs`. *Figure 7**.11* will help:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*图7.11*来检查一些`varargs`的边缘情况：
- en: '![Figure 7.11 – varargs compiler errors](img/B19793_07_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – varargs编译器错误](img/B19793_07_11.jpg)'
- en: Figure 7.11 – varargs compiler errors
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – varargs编译器错误
- en: In the preceding figure, we can see that `varargs` must be the last parameter
    in the method definition. Line 10 is fine as it defines the `varargs` parameter
    as the last parameter. However, line 11 is a compiler error because it attempts
    to define a parameter *after* the varargs parameter. This makes sense as all other
    parameters are mandatory; so, if `varargs` can define 0 or more arguments, it
    must be the last parameter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到`varargs`必须是方法定义中的最后一个参数。第10行是正确的，因为它将`varargs`参数定义为最后一个参数。然而，第11行是编译器错误，因为它试图在`varargs`参数之后定义一个参数。这是有道理的，因为所有其他参数都是强制性的；所以，如果`varargs`可以定义0个或多个参数，它必须是最后一个参数。
- en: Given that `varargs` is treated as an array, this begs the question, can we
    use an array instead of `varargs`? The answer is no. The compiler errors (lines
    5-8) all relate to the fact that, despite the presence of `m1(int[])` on line
    12, the compiler cannot find the method definition that matches any of these method
    calls.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`varargs`被当作数组处理，这引发了一个问题：我们能否用数组代替`varargs`？答案是：不可以。编译器错误（第5-8行）都与这样一个事实有关，即尽管在第12行有`m1(int[])`的定义，但编译器无法找到与这些方法调用匹配的方法定义。
- en: 'The last major topic for methods is an important one: call by value. We will
    discuss that now.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的最后一个重要主题是按值调用。我们现在将讨论这个主题。
- en: Mastering call by value
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握按值调用
- en: Java uses call by value when passing arguments to methods and returning results
    from methods. Concisely, this means that Java *makes a copy of something*. Effectively,
    when you are passing an argument to a method, a copy is made of that argument
    and when you are returning a result from a method, a copy is made of that result.
    Why do we care? Well, depending on what you are copying – a primitive or a reference
    has `int` and an example of a reference type is an array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Java在向方法传递参数和从方法返回结果时使用按值调用。简而言之，这意味着Java*会复制某个东西*。实际上，当你向方法传递一个参数时，会复制该参数；当你从方法返回一个结果时，会复制该结果。我们为什么要关心这个？好吧，根据你复制的内容——原始类型或引用类型——`int`是一个引用类型的例子。
- en: In a method, there is a clear difference between the effect of changes when
    the parameter is a primitive type versus when the parameter is a reference type.
    We will demonstrate this shortly with a code example but first, to appreciate
    the differences, we need to understand what is happening in memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中，当参数是原始类型和引用类型时，改变的效果有明显的区别。我们将通过一个代码示例来演示这一点，但首先，为了欣赏这些差异，我们需要理解内存中发生了什么。
- en: Primitives versus references in memory
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存中的原始类型与引用类型
- en: 'An array is an object, whereas a primitive is not. We will discuss objects
    in detail in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), but for now, let’s
    examine the code in *Figure 7**.12*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个对象，而原始类型不是。我们将在[*第8章*](B19793_08.xhtml#_idTextAnchor168)中详细讨论对象，但现在，让我们检查*图7.12*中的代码：
- en: '![Figure 7.12 – Sample code containing a primitive and an array](img/B19793_07_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – 包含原始类型和数组的示例代码](img/B19793_07_12.jpg)'
- en: Figure 7.12 – Sample code containing a primitive and an array
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 包含原始类型和数组的示例代码
- en: To understand what the code in the preceding figure looks like in memory, we
    need to discuss the stack, the heap, and references.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解前图中代码在内存中的样子，我们需要讨论栈、堆和引用。
- en: Stack
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: 'The stack is a special area of memory used by methods. Each time a new method
    `A`, is called, a new frame is *pushed* (created) onto the stack. The frame contains,
    among other things, `A`’s local variables and their values. Each frame is stacked
    one on top of the other, like plates. If `A` calls another method, `B`, the existing
    frame for `A` is saved and a new frame for `B` is pushed onto the stack, creating
    a new context. When `B` finishes, its stack frame is *popped* (removed) from the
    stack, and the frame for `A` is restored (with all its local variables and their
    values as they were, prior to the call to `B`). This is why a stack is called
    a **Last-In, First Out** (**LIFO**) structure. For further detail on the stack
    and Java Memory Management in general, please see our previous book: [https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/     1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+     maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是方法使用的一个特殊内存区域。每次调用一个新的方法 `A` 时，就会在栈上 *push*（创建）一个新的帧。该帧包含诸如 `A` 的局部变量及其值等内容。每个帧像盘子一样一个压一个地堆叠起来。如果
    `A` 调用了另一个方法 `B`，则 `A` 的现有帧会被保存，并在栈上为 `B` 推入一个新的帧，从而创建一个新的上下文。当 `B` 执行完毕后，其栈帧会被从栈中
    *pop*（移除），然后恢复 `A` 的帧（包括所有局部变量及其值，就像在调用 `B` 之前一样）。这就是为什么栈被称为 **后进先出**（**LIFO**）结构。有关栈和Java内存管理的更多详细信息，请参阅我们之前的书籍：[https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1)
- en: )
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: For our discussion here, what we need to be aware of is that local variables
    (primitives and/or references) are stored on the stack. Objects are *not* stored
    on the stack; objects are stored on the heap.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这里的讨论，我们需要意识到局部变量（原始数据类型和/或引用）存储在栈上。对象 *不* 存储在栈上；对象存储在堆上。
- en: Heap
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆
- en: The heap is an area of memory reserved for objects and arrays are objects. This
    means that arrays are stored on the heap. To access an object, we use a reference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是为对象和数组预留的内存区域，而数组也是对象。这意味着数组存储在堆上。要访问一个对象，我们使用引用。
- en: References
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: The named identifier used to access an object is known as a reference. A reference
    is similar to a pointer. Consider a TV that has no buttons on it to change the
    channel but does have a remote control. The reference is the remote control and
    the TV is the object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问对象的命名标识符称为引用。引用类似于指针。考虑一台没有按钮来更换频道但有一个遥控器的电视。引用是遥控器，而电视是对象。
- en: 'With these definitions in mind, let’s review the code in *Figure 7**.12*. Line
    5 declares a primitive `int` type called `x` and initializes it to 19\. Line 6
    declares an `int` array, namely `arr`, and initializes `arr[0]` to `1` and `arr[1]`
    to `2`. The array reference is `arr`. *Figure 7**.13* shows the in-memory representation
    of *Figure 7**.12* as we reach line 7:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这些定义之后，让我们回顾一下 *图7.12* 中的代码。第5行声明了一个原始数据类型 `int` 叫做 `x` 并将其初始化为19。第6行声明了一个
    `int` 数组，即 `arr`，并将 `arr[0]` 初始化为 `1`，`arr[1]` 初始化为 `2`。数组引用是 `arr`。*图7.13* 显示了当我们到达第7行时
    *图7.12* 的内存表示：
- en: '![Figure 7.13 – In-memory representation of the code from Figure 7.12](img/B19793_07_13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – 图7.12代码的内存表示](img/B19793_07_13.jpg)'
- en: Figure 7.13 – In-memory representation of the code from Figure 7.12
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 图7.12代码的内存表示
- en: In the preceding figure, we can see that there is a stack frame for the `main`
    method containing the local variables, `x` and `arr`. Note that, for simplicity,
    the `String[] args` parameter in `main` is omitted. Immediately, you can see the
    difference between the way primitives, namely `x`, and references, namely `arr`,
    are stored – `x` and its value are stored on the stack; whereas the value of `arr`
    refers to the object on the heap.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到有一个 `main` 方法的栈帧，其中包含局部变量 `x` 和 `arr`。请注意，为了简化，省略了 `main` 中的 `String[]
    args` 参数。立即，你可以看到原始数据类型（即 `x`）和引用（即 `arr`）的存储方式之间的区别 – `x` 和其值存储在栈上；而 `arr` 的值则指向堆上的对象。
- en: 'With this in mind, we are now in a position to examine a proper code example
    demonstrating the real impact of call by value when passing primitives versus
    passing references. *Figure 7**.14* represents the code example we will be using:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在可以检查一个合适的代码示例，以展示在传递原始数据类型和引用时按值传递的实际影响。*图7.14*代表了我们将要使用的代码示例：
- en: '![Figure 7.14 – Call by value passing primitives and references](img/B19793_07_14.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – 按值传递原始数据类型和引用](img/B19793_07_14.jpg)'
- en: Figure 7.14 – Call by value passing primitives and references
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 按值传递原始数据类型和引用
- en: 'In this figure, the `callByValue` method is defined on lines 13-17: the method
    accepts an `int` type and an `int` array in that order and returns an `int`. Line
    14 changes the value of the `int` parameter to -1 and line 15 changes index 0
    of the array to -1\. Lastly, the method returns the value of `x` on line 16.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`callByValue`方法定义在第13-17行：该方法按顺序接受一个`int`类型和一个`int`数组，并返回一个`int`。第14行将`int`参数的值改为-1，第15行将数组的索引0改为-1。最后，该方法在第16行返回`x`的值。
- en: Let us examine the first call to `callByValue`, passing down the `x` and `arr`
    arguments. It is important to note that the `x` and `arr` variables declared in
    `main` are completely separate variables from the `x` and `arr` parameters declared
    in the method `callByValue`. This is because they are in two separate scopes (methods).
    As Java uses call by value, copies of the primitive, `x`, and the reference, `arr`,
    are made and it is the *copies* that are passed into the method `callByValue`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查对`callByValue`的第一次调用，传递`x`和`arr`参数。重要的是要注意，在`main`中声明的`x`和`arr`变量与在`callByValue`方法中声明的`x`和`arr`参数是完全不同的变量。这是因为它们在两个不同的作用域（方法）中。由于Java使用按值传递，原始数据`x`和引用`arr`的副本被创建，并且传递到`callByValue`方法的是这些*副本*。
- en: Making a copy of a primitive is like photocopying a blank sheet of paper - if
    you pass the photocopy to someone and they write on it, your original blank sheet
    is still blank. Making a copy of a reference is like copying a remote control
    – if you give the second remote control (the copied one) to someone else, they
    can change the channel on the TV. Crucially, there is only one TV in all of this
    – the copy is made of the remote control, *not* the TV.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个原始数据类型就像复印一张空白纸——如果你把复印的纸给某人，他们可以在上面写字，你的原始空白纸仍然是空的。复制一个引用就像复制一个遥控器——如果你把第二个遥控器（复制的那个）给另一个人，他们可以改变电视的频道。关键在于，这里只有一个电视——复制的是遥控器，*而不是*电视。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This saves memory as copying a reference has a much smaller memory footprint
    that copying a potentially large object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以节省内存，因为复制一个引用的内存占用远小于复制一个可能很大的对象。
- en: '*Figure 7**.15* represents the in-memory representation of the code as we are
    about to `return` from the *first* invocation of `callByValue`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.15*代表了在即将从`callByValue`的第一次调用`return`时的内存表示：'
- en: '![Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call
    to callByValue (line 7)](img/B19793_07_15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 - 基于7.14行16的内存视图（基于第一次调用callByValue行7）](img/B19793_07_15.jpg)'
- en: Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call to
    callByValue (line 7)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 - 基于7.14行16的内存视图（基于第一次调用callByValue行7）
- en: 'As can be seen from the stack in the preceding figure, when we call `callByValue(x,
    arr)` from `main`, the existing frame for `main` is saved and a frame for `callByValue`
    is pushed onto the stack (on top of the frame for `main`). Then the code for `callByValue`
    is executed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个图中的堆栈所示，当我们从`main`中调用`callByValue(x, arr)`时，现有的`main`帧被保存，并在`main`帧的上面压入一个`callByValue`帧。然后执行`callByValue`的代码：
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Firstly, `x` in changed in the `callByValue` frame. This is the copy of `x`
    from `main`. Note that the value of `x` in (the frame for) `main` remains untouched
    (still 19). Consequently, 19 is output for `x` in `main` (line 8). Thus, a called
    method cannot (directly) change the caller method’s primitive values. We will
    revisit this point shortly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`callByValue`帧中改变了`x`的值。这是从`main`中复制来的`x`的副本。注意，`main`中的`x`的值保持不变（仍然是19）。因此，`main`中的`x`输出为19（第8行）。因此，被调用的方法不能（直接）改变调用方法的基本值。我们很快会回到这个点上。
- en: 'However, the line `arr[0] = 1;` in `callByValue` does have a material impact
    on `main`. When `callByValue` uses its `arr` reference, which is a copy of the
    `arr` reference from `main`, it changes the one object that both methods share.
    In effect, the array object that `main` is looking at is changed. This is demonstrated
    in `main` after the `callByValue` method returns:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`callByValue` 中的 `arr[0] = 1;` 行确实对 `main` 有实质性影响。当 `callByValue` 使用其 `arr`
    引用，这是从 `main` 复制的 `arr` 引用时，它会改变两个方法共享的一个对象。实际上，`main` 正在查看的数组对象被改变了。这可以在 `callByValue`
    方法返回后的 `main` 中看到：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Crucially, `-1` is output for the value at `arr[0]`. Therefore, be aware that
    when passing a reference to a method, the method can change the object that you
    are looking at.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，`arr[0]` 的值输出为 `-1`。因此，请注意，在传递方法引用时，方法可以更改你正在查看的对象。
- en: 'Let’s revisit the primitive situation. What if we wanted the called method
    to change the primitive value that’s passed down? This is why `callByValue` is
    returning `x`. The first method call to `callByValue` completely ignores the return
    value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下原始情况。如果我们想让被调用的方法改变传递下来的原始值，这是为什么 `callByValue` 会返回 `x`。第一次对 `callByValue`
    的调用完全忽略了返回值：
- en: '[PRE4]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, the second call does not:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二次调用并不：
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The -1 that’s returned from `callByValue` is used to overwrite the value of
    `x` in `main`. As a result, -1 is output for `x` in `main` (line 11).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `callByValue` 返回的 -1 用于覆盖 `main` 中 `x` 的值。因此，`main` 中的 `x` 输出为 -1（第 11 行）。
- en: That completes our discussion on methods. Now, let’s put that knowledge into
    practice to reinforce these concepts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对方法的讨论。现在，让我们将这些知识付诸实践，以巩固这些概念。
- en: Exercises
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Maintaining a dinosaur park takes a lot more than just raw passion. It involves
    regular health check-ups for our dinosaurs, ensuring our guests are comfortable,
    and that the park is well-staffed. All these tasks involve methodical processes.
    Luckily, we now know about methods!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 维护恐龙公园需要的不仅仅是热情。它包括对我们恐龙的定期健康检查，确保我们的客人感到舒适，以及公园有足够的员工。所有这些任务都涉及系统化的过程。幸运的是，我们现在知道了方法！
- en: 'You can add these methods to the same class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些方法添加到同一个类中：
- en: The stage of life a dinosaur is in can significantly impact its behavior and
    needs. Write a method that takes a dinosaur’s age and returns whether it’s a hatchling,
    juvenile, or adult.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恐龙所处的生命阶段可以显著影响其行为和需求。编写一个接受恐龙年龄并返回其是孵化幼体、幼崽还是成年恐龙的方法。
- en: It’s important to remember that our dinosaurs aren’t actually pets – they’re
    large, often hefty creatures with large appetites. Write a method that accepts
    a dinosaur’s weight and calculates how much food it needs daily.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的是要记住，我们的恐龙实际上并不是宠物——它们是体型庞大、通常很重的生物，有着很大的胃口。编写一个接受恐龙体重并计算其每日所需食物量的方法。
- en: Being on top of our dinosaurs’ average age helps us plan for the future. Design
    a method that accepts an array of dinosaur ages and calculates the average age.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解我们恐龙的平均年龄有助于我们规划未来。设计一个接受恐龙年龄数组的数组并计算平均年龄的方法。
- en: 'The park isn’t open 24/7 to day visitors. We need some time to clean up the
    popcorn and repair any minor damages to the enclosures. Write a method that checks
    if the park is open or closed based on the current time. (Hint: this method doesn’t
    require any input.)'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公园不是全天24小时对日间游客开放。我们需要一些时间来清理爆米花和修复围栏的任何轻微损坏。编写一个根据当前时间检查公园是否开放或关闭的方法。（提示：此方法不需要任何输入。）
- en: Personalization is key to making our guests feel special. Create a method that
    uses a dinosaur’s name and a visitor’s name to craft a personal greeting message.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 个性化是让我们的客人感到特别的关键。创建一个使用恐龙的名字和游客的名字来制作个性化问候信息的方法。
- en: As you’re well aware, safety is our top priority. We need a method to return
    whether we can let in another group of guests (a certain number of people) to
    the park based on the current number of visitors and the maximum number of visitors
    allowed.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所意识到的，安全是我们的首要任务。我们需要一种方法来确定我们是否可以让另一组客人（一定数量的人）进入公园，这基于当前游客数量和允许的最大游客数量。
- en: Project – Mesozoic Eden assistant
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 中生代伊甸园助手
- en: This is going to be our biggest project so far. So, buckle up!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的最大项目。所以，系好安全带！
- en: 'Let’s start with a high-level description. The Mesozoic Eden assistant is an
    interactive console application that assists in managing a dinosaur park. The
    assistant should have features to do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从高级描述开始。中生代伊甸园助手是一个交互式控制台应用程序，用于管理恐龙公园。助手应该具备以下功能：
- en: Add or remove dinosaurs
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或删除恐龙
- en: Check the park’s opening hours
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查公园的营业时间
- en: Greet guests and provide park information
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎客人并提供公园信息
- en: Track visitor counts to ensure the park isn’t overcrowded
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪游客数量以确保公园不会过于拥挤
- en: Manage park staff details
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理公园员工详细信息
- en: 'Since we won’t let you drown, if you need it, here is a step-by-step guide.
    A starting project will follow these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会让你淹死，如果你需要，这里有一个逐步指南。起始项目将遵循以下步骤：
- en: '`Dinosaur`, `Guest`, and `Employee`. Include appropriate properties and methods.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dinosaur`、`Guest`和`Employee`。包括适当的属性和方法。'
- en: '`Scanner` class.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Scanner`类。'
- en: '`Scanner` class.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Scanner`类。'
- en: '**Create a menu**: Create a menu that allows the user to interact with the
    park management system.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建菜单**：创建一个菜单，允许用户与公园管理系统交互。'
- en: '**Handle actions**: Each menu item should trigger a certain action, such as
    adding a dinosaur, checking park hours, or greeting a guest.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理操作**：每个菜单项应触发特定的操作，例如添加恐龙、检查公园营业时间或欢迎客人。'
- en: '**Exit the program**: Provide an option for the user to exit the program.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**退出程序**：提供一个选项让用户退出程序。'
- en: 'Here is a code snippet to get you started:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段来帮助你开始：
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, this is a great starting point! But it’s not done. In the preceding code
    snippet, `addDinosaur()`, `checkParkHours()`, `greetGuest()`, `checkVisitorsCount()`,
    and `manageStaff()` are placeholders for methods you need to implement according
    to your data structures and functionality. The `Scanner` class is used to read
    the user’s menu choice from the console.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个很好的起点！但还没有完成。在前面的代码片段中，`addDinosaur()`、`checkParkHours()`、`greetGuest()`、`checkVisitorsCount()`和`manageStaff()`是方法占位符，你需要根据你的数据结构和功能实现这些方法。`Scanner`类用于从控制台读取用户的菜单选择。
- en: You can make the project as sophisticated as you like by adding additional features
    and enhancements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加额外的功能和增强来使项目变得尽可能复杂。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our discussion on methods by stating that methods
    are simply code blocks that are given a name for ease of reference. Methods are
    important because they enable us to abstract away the implementation, while at
    the same time helping us to avoid unnecessary code duplication.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过说明方法只是被赋予名称以便于引用的代码块来开始对方法的讨论。方法之所以重要，是因为它们使我们能够抽象出实现，同时帮助我们避免不必要的代码重复。
- en: 'There are two parts to a method: the method definition (or declaration) and
    the method call (or invocation). The method definition declares (among other things)
    the method name, the input parameters, and the return type. The method name and
    the parameter types (including their order) constitute the method signature. The
    method call passes down the arguments (if any) to be used as inputs in the method.
    The return value from a method (if there is one) can be captured by assigning
    the method call to a variable.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法有两个部分：方法定义（或声明）和方法调用（或调用）。方法定义声明（包括其他内容）了方法名称、输入参数和返回类型。方法名称和参数类型（包括它们的顺序）构成了方法签名。方法调用将（如果有的话）传递参数作为方法的输入。如果方法有返回值，可以通过将方法调用赋值给变量来捕获返回值。
- en: Method overloading is where the same method name is used across several different
    methods. What distinguishes the various methods is that they have different signatures
    – the parameter types and/or their order will be different. The parameter names
    and return types do not matter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载是在几个不同的方法中使用相同的方法名称。区分各种方法的是它们有不同的签名——参数类型和/或它们的顺序将不同。参数名称和返回类型并不重要。
- en: A `varargs` (variable arguments) parameter is specified in a method declaration
    using an ellipsis (three dots). This means that when calling this method, the
    arguments corresponding to that parameter are variable – you can pass down `0`
    or more arguments for that parameter. Internally, in the method, the `varargs`
    parameter is treated as an array.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法声明中使用省略号（三个点）指定了一个`varargs`（可变参数）参数。这意味着在调用此方法时，对应该参数的参数是可变的——你可以传递0个或更多参数。在方法内部，`varargs`参数被视为一个数组。
- en: When passing arguments to a method, Java uses call by value. This means that
    a copy of the argument is made. Depending on whether you are passing down a primitive
    or a reference has major implications regarding the effect of the changes that
    are made by the called method on the calling method. If it’s a primitive, the
    called method cannot change the primitive that the caller method has (unless the
    caller method deliberately overwrites the variable with the return value). If
    it’s a reference, the called method can change the object that the caller method
    is looking at.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当向方法传递参数时，Java使用按值传递。这意味着会创建参数的副本。根据你传递的是原始数据类型还是引用类型，对被调用方法对调用方法产生的影响有重大影响。如果是原始数据类型，被调用方法不能改变调用方法中的原始数据类型（除非调用方法故意用返回值覆盖变量）。如果是引用类型，被调用方法可以改变调用方法正在查看的对象。
- en: Now that we have finished looking at methods, let’s move on to our first strictly
    **object-oriented programming** (**OOP**) chapter, where we will look at classes,
    objects, and enums.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对方法的探讨，让我们继续到我们的第一个严格意义上的**面向对象编程**（**OOP**）章节，我们将探讨类、对象和枚举。
- en: 'Part 2: Object-Oriented Programming'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：面向对象编程
- en: In this part, we will take a deep dive into `abstract` classes and the hugely
    important `interface` construct. Following that, we will examine Java’s exception
    framework. Lastly, we will explore selected classes from the Java Core API, such
    as `String` and `StringBuilder`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将深入探讨`抽象`类和极其重要的`接口`结构。随后，我们将研究Java的异常框架。最后，我们将探索Java核心API中的选定类，例如`String`和`StringBuilder`。
- en: 'This section has the following chapters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), *Classes, Objects, and Enums*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19793_08.xhtml#_idTextAnchor168), *类、对象和枚举*'
- en: '[*Chapter 9*](B19793_09.xhtml#_idTextAnchor205), *Inheritance and Polymorphism*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19793_09.xhtml#_idTextAnchor205), *继承和多态*'
- en: '[*Chapter 10*](B19793_10.xhtml#_idTextAnchor249), *Interfaces and Abstract
    Classes*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19793_10.xhtml#_idTextAnchor249), *接口和抽象类*'
- en: '[*Chapter 11*](B19793_11.xhtml#_idTextAnchor266), *Dealing with Exceptions*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19793_11.xhtml#_idTextAnchor266), *处理异常*'
- en: '[*Chapter 12*](B19793_12.xhtml#_idTextAnchor293), *Java Core API*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19793_12.xhtml#_idTextAnchor293), *Java核心API*'
