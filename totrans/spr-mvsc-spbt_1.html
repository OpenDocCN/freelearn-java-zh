<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Building Microservices with Spring Boot"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Building Microservices with Spring Boot</h1></div></div></div><p>As we discussed in the last lesson, we are moving toward architectures with smaller, independently deployable microservices. This would mean that there will be a huge number of smaller microservices developed.</p><p>An important consequence is that we would need to be able to quickly get off the ground and get running with new components.</p><p>Spring Boot aims to solve the problem of getting off fast with a new component. In this lesson, we will start with understanding the capabilities Spring Boot brings to the table. We will answer the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why Spring Boot?</li><li class="listitem" style="list-style-type: disc">What are the features that Spring Boot provides?</li><li class="listitem" style="list-style-type: disc">What is auto-configuration?</li><li class="listitem" style="list-style-type: disc">What is Spring Boot not?</li><li class="listitem" style="list-style-type: disc">What happens in the background when you use Spring Boot?</li><li class="listitem" style="list-style-type: disc">How do you use Spring Initializr to create new Spring Boot projects?</li><li class="listitem" style="list-style-type: disc">How do you create basic RESTful services with Spring Boot?</li></ul></div><div class="section" title="What is Spring Boot?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec05"/>What is Spring Boot?</h1></div></div></div><p>First of all, let's start with clearing out a few misconceptions about Spring Boot:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spring Boot is not a code generation framework. It does not generate any code.</li><li class="listitem" style="list-style-type: disc">Spring Boot is neither an application server, nor is it a web server. It provides good integration with different ranges of applications and web servers.</li><li class="listitem" style="list-style-type: disc">Spring Boot does not implement any specific frameworks or specifications.</li></ul></div><p>These questions still remain:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is Spring Boot?</li><li class="listitem" style="list-style-type: disc">Why has it become so popular in the last couple of years?</li></ul></div><p>To answer these questions, let's build a quick example. Let's consider an example application that you want to quickly prototype.</p><div class="section" title="Building a Quick Prototype for a Microservice"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec01"/>Building a Quick Prototype for a Microservice</h2></div></div></div><p>Let's say we want to build a microservice with Spring MVC and use JPA (with Hibernate as the implementation) to connect to the database.</p><p>Let's consider the steps in setting up such an application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Decide which versions of Spring MVC, JPA and Hibernate to use.</li><li class="listitem">Set up a Spring context to wire all the different layers together.</li><li class="listitem">Set up a web layer with Spring MVC (including Spring MVC configuration):<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configure beans for DispatcherServlet, handler, resolvers, view resolvers, and so on</li></ul></div></li><li class="listitem">Set up Hibernate in the data layer:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configure beans for SessionFactory, data source, and so on</li></ul></div></li><li class="listitem">Decide and implement how to store your application configuration, which varies between different environments.</li><li class="listitem">Decide how you would want to do your unit testing.</li><li class="listitem">Decide and implement your transaction management strategy.</li><li class="listitem">Decide and implement how to implement security.</li><li class="listitem">Set up your logging framework.</li><li class="listitem">Decide and implement how you want to monitor your application in production.</li><li class="listitem"> Decide and implement a metrics management system to provide statistics about the application.</li><li class="listitem">Decide and implement how to deploy your application to a web or application server.</li></ol></div><p>At least a few of the steps mentioned have to be completed before we can start with building our business logic. And this might take a few weeks at the least.</p><p>When we build microservices, we would want to make a quick start. All the preceding steps will not make it easy to develop a microservice. And that's the problem Spring Boot aims to solve.</p><p>The following quote is an extract from the Spring Boot website (<a class="ulink" href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation</a>):</p><div class="blockquote"><blockquote class="blockquote"><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based applications that you can "just run". We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration</p><p>Spring Boot enables developers to focus on the business logic behind their microservice. It aims to take care of all the nitty-gritty technical details involved in developing microservices.</p></blockquote></div></div><div class="section" title="Primary Goals"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec02"/>Primary Goals</h2></div></div></div><p>The primary goals of Spring Boot are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enable quickly getting off the ground with Spring-based projects.</li><li class="listitem" style="list-style-type: disc">Be opinionated. Make default assumptions based on common usage. Provide configuration options to handle deviations from defaults.</li><li class="listitem" style="list-style-type: disc">Provide a wide range of nonfunctional features out of the box.</li><li class="listitem" style="list-style-type: disc">Do not use code generation and avoid using a lot of XML configuration.</li></ul></div></div><div class="section" title="Nonfunctional Features"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec03"/>Nonfunctional Features</h2></div></div></div><p>A few of the nonfunctional features provided by Spring Boot are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Default handling of versioning and configuration of a wide range of frameworks, servers, and specifications</li><li class="listitem" style="list-style-type: disc">Default options for application security</li><li class="listitem" style="list-style-type: disc">Default application metrics with possibilities to extend</li><li class="listitem" style="list-style-type: disc">Basic application monitoring using health checks</li><li class="listitem" style="list-style-type: disc">Multiple options for externalized configuration</li></ul></div></div></div></div>
<div class="section" title="Spring Boot Hello World"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Spring Boot Hello World</h1></div></div></div><p>We will start with building our first Spring Boot application in this lesson. We will use Maven to manage dependencies.</p><p>The following steps are involved in starting up with a Spring Boot application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Configure <code class="literal">spring-boot-starter-parent</code> in your <code class="literal">pom.xml</code> file.</li><li class="listitem">Configure the <code class="literal">pom.xml</code> file with the required starter projects.</li><li class="listitem">Configure <code class="literal">spring-boot-maven-plugin</code> to be able to run the application.</li><li class="listitem">Create your first Spring Boot launch class.</li></ol></div><p>Let's start with step 1, configuring the starter projects.</p><div class="section" title="Configure spring-boot-starter-parent"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec04"/>Configure spring-boot-starter-parent</h2></div></div></div><p>Let's start with a simple <code class="literal">pom.xml</code> file with <code class="literal">spring-boot-starter-parent</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;project 
     
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
     http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.mastering.spring&lt;/groupId&gt; 
    &lt;artifactId&gt;springboot-example&lt;/artifactId&gt; 
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 
    &lt;name&gt;First Spring Boot Example&lt;/name&gt; 
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;parent&gt; 
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 
      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  
      &lt;version&gt;2.0.0.M1&lt;/version&gt;
    &lt;/parent&gt;
    &lt;properties&gt; 
      &lt;java.version&gt;1.8&lt;/java.version&gt; 
    &lt;/properties&gt;

   &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;spring-milestones&lt;/id&gt;
      &lt;name&gt;Spring Milestones&lt;/name&gt;
      &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
   &lt;/repositories&gt;

   &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;spring-milestones&lt;/id&gt;
      &lt;name&gt;Spring Milestones&lt;/name&gt;
      &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;snapshots&gt;
          &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
     &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;

&lt;/project&gt;</pre></div><p>The first question is this: why do we need <code class="literal">spring-boot-starter-parent</code>?</p><p>A <code class="literal">spring-boot-starter-parent</code> dependency contains the default versions of Java to use, the default versions of dependencies that Spring Boot uses, and the default configuration of the Maven plugins.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note01"/>Note</h3><p>The <code class="literal">spring-boot-starter-parent</code> dependency is the parent POM providing dependency and plugin management for Spring Boot-based applications.</p></div></div><p>Let's look at some of the code inside <code class="literal">spring-boot-starter-parent</code> to get a deeper understanding about <code class="literal">spring-boot-starter-parent</code>.</p></div><div class="section" title="spring-boot-starter-parent"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec05"/>spring-boot-starter-parent</h2></div></div></div><p>The <code class="literal">spring-boot-starter-parent</code> dependency inherits from <code class="literal">spring-boot-dependencies</code>, which is defined at the top of the POM. The following code snippet shows an extract from <code class="literal">spring-boot-starter-parent</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;parent&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
      &lt;version&gt;2.0.0.M1&lt;/version&gt;
      &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
   &lt;/parent&gt;</pre></div><p>The <code class="literal">spring-boot-dependencies</code> provides default dependency management for all the dependencies that Spring Boot uses. The following code shows the different versions of various dependencies that are configured in <code class="literal">spring-boot-dependencies</code>:</p><div class="informalexample"><pre class="programlisting">&lt;activemq.version&gt;5.13.4&lt;/activemq.version&gt;
&lt;aspectj.version&gt;1.8.9&lt;/aspectj.version&gt;
&lt;ehcache.version&gt;2.10.2.2.21&lt;/ehcache.version&gt;
&lt;elasticsearch.version&gt;2.3.4&lt;/elasticsearch.version&gt;
&lt;gson.version&gt;2.7&lt;/gson.version&gt;
&lt;h2.version&gt;1.4.192&lt;/h2.version&gt;
&lt;hazelcast.version&gt;3.6.4&lt;/hazelcast.version&gt;
&lt;hibernate.version&gt;5.0.9.Final&lt;/hibernate.version&gt;
&lt;hibernate-validator.version&gt;5.2.4.Final&lt;/hibernate
  validator.version&gt;
&lt;hsqldb.version&gt;2.3.3&lt;/hsqldb.version&gt;
&lt;htmlunit.version&gt;2.21&lt;/htmlunit.version&gt;
&lt;jackson.version&gt;2.8.1&lt;/jackson.version&gt;
&lt;jersey.version&gt;2.23.1&lt;/jersey.version&gt;
&lt;jetty.version&gt;9.3.11.v20160721&lt;/jetty.version&gt;
&lt;junit.version&gt;4.12&lt;/junit.version&gt;
&lt;mockito.version&gt;1.10.19&lt;/mockito.version&gt;
&lt;selenium.version&gt;2.53.1&lt;/selenium.version&gt;
&lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;
&lt;spring.version&gt;4.3.2.RELEASE&lt;/spring.version&gt;
&lt;spring-amqp.version&gt;1.6.1.RELEASE&lt;/spring-amqp.version&gt;
&lt;spring-batch.version&gt;3.0.7.RELEASE&lt;/spring-batch.version&gt;
&lt;spring-data-releasetrain.version&gt;Hopper-SR2&lt;/spring-
  data-releasetrain.version&gt;
&lt;spring-hateoas.version&gt;0.20.0.RELEASE&lt;/spring-hateoas.version&gt;
&lt;spring-restdocs.version&gt;1.1.1.RELEASE&lt;/spring-restdocs.version&gt;
&lt;spring-security.version&gt;4.1.1.RELEASE&lt;/spring-security.version&gt;
&lt;spring-session.version&gt;1.2.1.RELEASE&lt;/spring-session.version&gt;
&lt;spring-ws.version&gt;2.3.0.RELEASE&lt;/spring-ws.version&gt;
&lt;thymeleaf.version&gt;2.1.5.RELEASE&lt;/thymeleaf.version&gt;
&lt;tomcat.version&gt;8.5.4&lt;/tomcat.version&gt;
&lt;xml-apis.version&gt;1.4.01&lt;/xml-apis.version&gt;</pre></div><p>If we want to override a specific version of a dependency, we can do that by providing a property with the right name in the <code class="literal">pom.xml</code> file of our application. The following code snippet shows an example of configuring our application to use version 1.10.20 of Mockito:</p><div class="informalexample"><pre class="programlisting">    &lt;properties&gt;
     &lt;mockito.version&gt;1.10.20&lt;/mockito.version&gt;
    &lt;/properties&gt;</pre></div><p>The following are some of the other things defined in <code class="literal">spring-boot-starter-parent</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The default Java version<code class="literal">&lt;java.version&gt;1.8&lt;/java.version&gt;</code></li><li class="listitem" style="list-style-type: disc">The default configuration for Maven plugins:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">maven-failsafe-plugin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">maven-surefire-plugin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">git-commit-id-plugin</code></li></ul></div></li></ul></div><p>Compatibility between different versions of frameworks is one of the major problems faced by developers. How do I find the latest Spring Session version that is compatible with a specific version of Spring? The usual answer would be to read the documentation. However, if we use Spring Boot, this is made simple by <code class="literal">spring-boot-starter-parent</code>. If we want to upgrade to a newer Spring version, all that we need to do is to find the <code class="literal">spring-boot-starter-parent</code>dependency for that Spring version. Once we upgrade our application to use that specific version of <code class="literal">spring-boot-starter-parent</code>, we would have all the other dependencies upgraded to the versions compatible with the new Spring version. One less problem for developers to handle. Always make me happy.</p></div><div class="section" title="Configure pom.xml with the Required Starter Projects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Configure pom.xml with the Required Starter Projects</h2></div></div></div><p>Whenever we want to build an application in Spring Boot, we would need to start looking for starter projects. Let's focus on understanding what a starter project is.</p><div class="section" title="Understanding Starter Projects"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Understanding Starter Projects</h3></div></div></div><p>Starters are simplified dependency descriptors customized for different purposes. For example, <code class="literal">spring-boot-starter-web</code> is the starter for building web application, including RESTful, using Spring MVC. It uses Tomcat as the default embedded container. If I want to develop a web application using Spring MVC, all we would need to do is include <code class="literal">spring-boot-starter-web</code> in our dependencies, and we get the following automatically pre-configured:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spring MVC</li><li class="listitem" style="list-style-type: disc">Compatible versions of <code class="literal">jackson-databind</code> (for binding) and hibernate-validator (for form validation)</li><li class="listitem" style="list-style-type: disc"><code class="literal">spring-boot-starter-tomcat</code> (starter project for Tomcat)</li></ul></div><p>The following code snippet shows some of the dependencies configured in <code class="literal">spring-boot-starter-web</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
          &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
          &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
       &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre></div><p>As we can see in the preceding snippet, when we use<code class="literal">spring-boot-starter-web</code>, we get a lot of frameworks auto-configured.</p><p>For the web application we would like to build, we would also want to do some good unit testing and deploy it on Tomcat. The following snippet shows the different starter dependencies that we would need. We would need to add this to our <code class="literal">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;/dependency&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
       &lt;scope&gt;test&lt;/scope&gt;
     &lt;/dependency&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
       &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt;
    &lt;/dependencies&gt;</pre></div><p>We add three starter projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We've already discussed <code class="literal">spring-boot-starter-web</code>. It provides us with the frameworks needed to build a web application with Spring MVC.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">spring-boot-starter-test</code> dependency provides the following test frameworks needed for unit testing:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JUnit</strong></span>: Basic unit test framework</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mockito</strong></span>: For mocking</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hamcrest</strong></span>, <span class="strong"><strong>AssertJ</strong></span>: For readable asserts</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Spring Test</strong></span>: A unit testing framework for spring-context based applications</li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">spring-boot-starter-tomcat</code> dependency is the default for running web applications. We include it for clarity. The <code class="literal">spring-boot-starter-tomcat</code> is the starter for using Tomcat as the embedded servlet container.</li></ul></div><p>We now have our <code class="literal">pom.xml</code> file configured with the starter parent and the required starter projects. Let's add <code class="literal">spring-boot-maven-plugin</code> now, which would enable us to run Spring Boot applications.</p></div></div><div class="section" title="Configuring spring-boot-maven-plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Configuring spring-boot-maven-plugin</h2></div></div></div><p>When we build applications using Spring Boot, there are a couple of situations that are possible:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We would want to run the applications in place without building a JAR or a WAR</li><li class="listitem" style="list-style-type: disc">We would want to build a JAR and a WAR for later deployment</li></ul></div><p>The <code class="literal">spring-boot-maven-plugin</code> dependency provides capabilities for both of the preceding situations. The following snippet shows how we can configure <code class="literal">spring-boot-maven-plugin</code> in an application:</p><div class="informalexample"><pre class="programlisting">    &lt;build&gt;
     &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
     &lt;/plugins&gt;
    &lt;/build&gt;</pre></div><p>The <code class="literal">spring-boot-maven-plugin</code> dependency provides several goals for a Spring Boot application. The most popular goal is run (this can be executed as <code class="literal">mvn spring-boot:run</code> on the command prompt from the root folder of the project).</p></div><div class="section" title="Creating Your First Spring Boot Launch Class"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Creating Your First Spring Boot Launch Class</h2></div></div></div><p>The following class explains how to create a simple Spring Boot launch class. It uses the static run method from the <code class="literal">SpringApplication</code> class, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    package com.mastering.spring.springboot;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot
    autoconfigure.SpringBootApplication;
    import org.springframework.context.ApplicationContext;
    @SpringBootApplication public class Application {
       public static void main(String[] args)
        { 
         ApplicationContext ctx = SpringApplication.run
         (Application.class,args);
        }
     }</pre></div><p>The preceding code is a simple Java <code class="literal">main</code> method executing the static <code class="literal">run</code> method on the <code class="literal">SpringApplication</code> class.</p><div class="section" title="The SpringApplication Class"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>The SpringApplication Class</h3></div></div></div><p>The <code class="literal">SpringApplication</code> class can be used to Bootstrap and launch a Spring application from a Java <code class="literal">main</code> method.</p><p>The following are the steps that are typically performed when a Spring Boot application is bootstrapped:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an instance of Spring's <code class="literal">ApplicationContext</code>.</li><li class="listitem">Enable the functionality to accept command-line arguments and expose them as Spring properties.</li><li class="listitem">Load all the Spring beans as per the configuration.</li></ol></div></div><div class="section" title="The @SpringBootApplication Annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>The @SpringBootApplication Annotation</h3></div></div></div><p>The <code class="literal">@SpringBootApplication</code> annotation is a shortcut for three annotations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Configuration</code>: Indicates that this a Spring application context configuration file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@EnableAutoConfiguration</code>: Enables auto-configuration, an important feature of Spring Boot. We will discuss auto-configuration later in a separate section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ComponentScan</code>: Enables scanning for Spring beans in the package of this class and all its sub packages.</li></ul></div></div></div><div class="section" title="Running Our Hello World Application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Running Our Hello World Application</h2></div></div></div><p>We can run the Hello World application in multiple ways. Let's start running it with the simplest option--running as a Java application. In your IDE, right-click on the application <span class="strong"><strong>class</strong></span> and run it as <span class="strong"><strong>Java Application</strong></span>. The following screenshot shows some of the log from running our <code class="literal">Hello World</code> application:</p><div class="mediaobject"><img alt="Running Our Hello World Application" src="graphics/1.1.jpg"/></div><p>The following are the key things to note:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tomcat server is launched on port <code class="literal">8080</code>--<code class="literal">Tomcat started on port(s): 8080 (http)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DispatcherServlet</code> is configured. This means that Spring MVC Framework is ready to accept requests--<code class="literal">Mapping servlet: 'dispatcherServlet' to [/]</code>.</li><li class="listitem" style="list-style-type: disc">Four filters--<code class="literal">characterEncodingFilter</code>, <code class="literal">hiddenHttpMethodFilter</code>, <code class="literal">httpPutFormContentFilter</code> and <code class="literal">requestContextFilter</code>--are enabled by default</li><li class="listitem" style="list-style-type: disc">The default error page is configured--<code class="literal">Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)</code></li><li class="listitem" style="list-style-type: disc">WebJars are autoconfigured. WebJars enable dependency management for static dependencies such as Bootstrap and query--<code class="literal">Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</code></li></ul></div><p>The following screenshot shows the application layout as of now. We have just two files, <code class="literal">pom.xml</code> and <code class="literal">Application.java</code>:</p><div class="mediaobject"><img alt="Running Our Hello World Application" src="graphics/1.2.jpg"/></div><p>With a simple <code class="literal">pom.xml</code> file and one Java class, we were able to get to launch the Spring MVC application, with all the preceding functionality described. The most important thing about Spring Boot is to understand what happens in the background. Understanding the preceding start up log is the first. Let's look at the Maven dependencies to get a deeper picture.</p><p>The following screenshot shows some of the dependencies that are configured with the basic configuration in the <code class="literal">pom.xml</code> file that we created:</p><div class="mediaobject"><img alt="Running Our Hello World Application" src="graphics/1.3.jpg"/></div><p>Spring Boot does a lot of magic. Once you have the application configured and running, I recommend that you play around with it to gain a deeper understanding that will be useful when you are debugging problems.</p><p>As Spiderman says, with great power, comes great responsibility. This is absolutely true in the case of Spring Boot. In the time to come, the best developers with Spring Boot would be the ones who understand what happens in the background--dependencies and auto-configuration.</p></div><div class="section" title="Auto-configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Auto-configuration</h2></div></div></div><p>To enable us to understand auto-configuration further, let's expand our application class to include a few more lines of code:</p><div class="informalexample"><pre class="programlisting">    ApplicationContext ctx = SpringApplication.run(Application.class,
     args);
    String[] beanNames = ctx.getBeanDefinitionNames();
    Arrays.sort(beanNames);

   for (String beanName : beanNames) {
     System.out.println(beanName);
    }</pre></div><p>We get all the beans that are defined in the Spring application context and print their names. When <code class="literal">Application.java</code> is run as a Java program, it prints the list of beans, as shown in the following output:</p><div class="informalexample"><pre class="programlisting">application
basicErrorController
beanNameHandlerMapping
beanNameViewResolver
characterEncodingFilter
conventionErrorViewResolver
defaultServletHandlerMapping
defaultViewResolver
dispatcherServlet
dispatcherServletRegistration
duplicateServerPropertiesDetector
embeddedServletContainerCustomizerBeanPostProcessor
error
errorAttributes
errorPageCustomizer
errorPageRegistrarBeanPostProcessor
faviconHandlerMapping
faviconRequestHandler
handlerExceptionResolver
hiddenHttpMethodFilter
httpPutFormContentFilter
httpRequestHandlerAdapter
jacksonObjectMapper
jacksonObjectMapperBuilder
jsonComponentModule
localeCharsetMappingsCustomizer
mappingJackson2HttpMessageConverter
mbeanExporter
mbeanServer
messageConverters
multipartConfigElement
multipartResolver
mvcContentNegotiationManager
mvcConversionService
mvcPathMatcher
mvcResourceUrlProvider
mvcUriComponentsContributor
mvcUrlPathHelper
mvcValidator
mvcViewResolver
objectNamingStrategy
autoconfigure.AutoConfigurationPackages
autoconfigure.PropertyPlaceholderAutoConfiguration
autoconfigure.condition.BeanTypeRegistry
autoconfigure.context.ConfigurationPropertiesAutoConfiguration
autoconfigure.info.ProjectInfoAutoConfiguration
autoconfigure.internalCachingMetadataReaderFactory
autoconfigure.jackson.JacksonAutoConfiguration
autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration
autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration
autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration
autoconfigure.jmx.JmxAutoConfiguration
autoconfigure.web.DispatcherServletAutoConfiguration
autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration
autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration
autoconfigure.web.EmbeddedServletContainerAutoConfiguration
autoconfigure.web.EmbeddedServletContainerAutoConfiguration$EmbeddedTomcat
autoconfigure.web.ErrorMvcAutoConfiguration
autoconfigure.web.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration
autoconfigure.web.HttpEncodingAutoConfiguration
autoconfigure.web.HttpMessageConvertersAutoConfiguration
autoconfigure.web.HttpMessageConvertersAutoConfiguration$StringHttpMessageConverterConfiguration
autoconfigure.web.JacksonHttpMessageConvertersConfiguration
autoconfigure.web.JacksonHttpMessageConvertersConfiguration$MappingJackson2HttpMessageConverterConfiguration
autoconfigure.web.MultipartAutoConfiguration
autoconfigure.web.ServerPropertiesAutoConfiguration
autoconfigure.web.WebClientAutoConfiguration
autoconfigure.web.WebClientAutoConfiguration$RestTemplateConfiguration
autoconfigure.web.WebMvcAutoConfiguration
autoconfigure.web.WebMvcAutoConfiguration$EnableWebMvcConfiguration
autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter
autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter$FaviconConfiguration
autoconfigure.websocket.WebSocketAutoConfiguration
autoconfigure.websocket.WebSocketAutoConfiguration$TomcatWebSocketConfiguration
context.properties.ConfigurationPropertiesBindingPostProcessor
context.properties.ConfigurationPropertiesBindingPostProcessor.store
annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor
annotation.ConfigurationClassPostProcessor.importAwareProcessor
annotation.internalAutowiredAnnotationProcessor
annotation.internalCommonAnnotationProcessor
annotation.internalConfigurationAnnotationProcessor
annotation.internalRequiredAnnotationProcessor
event.internalEventListenerFactory
event.internalEventListenerProcessor
preserveErrorControllerTargetClassPostProcessor
propertySourcesPlaceholderConfigurer
requestContextFilter
requestMappingHandlerAdapter
requestMappingHandlerMapping
resourceHandlerMapping
restTemplateBuilder
serverProperties
simpleControllerHandlerAdapter
spring.http.encoding-autoconfigure.web.HttpEncodingProperties
spring.http.multipart-autoconfigure.web.MultipartProperties
spring.info-autoconfigure.info.ProjectInfoProperties
spring.jackson-autoconfigure.jackson.JacksonProperties
spring.mvc-autoconfigure.web.WebMvcProperties
spring.resources-autoconfigure.web.ResourceProperties
standardJacksonObjectMapperBuilderCustomizer
stringHttpMessageConverter
tomcatEmbeddedServletContainerFactory
viewControllerHandlerMapping
viewResolver
websocketContainerCustomizer</pre></div><p>Important things to think about are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Where are these beans defined?</li><li class="listitem" style="list-style-type: disc">How are these beans created?</li></ul></div><p>That's the magic of Spring auto-configuration.</p><p>Whenever we add a new dependency to a Spring Boot project, Spring Boot auto-configuration automatically tries to configure the beans based on the dependency.</p><p>For example, when we add a dependency in <code class="literal">spring-boot-starter-web</code>, the following beans are auto-configured:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">basicErrorController</code>, <code class="literal">handlerExceptionResolver</code>: It is the basic exception handling. It shows a default error page when an exception occurs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">beanNameHandlerMapping</code>: It is used to resolve paths to a handler (controller).</li><li class="listitem" style="list-style-type: disc"><code class="literal">characterEncodingFilter</code>: It provides default character encoding UTF-8.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dispatcherServlet</code>: It is the front controller in Spring MVC applications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">jacksonObjectMapper</code>: It translates objects to JSON and JSON to objects in REST services.</li><li class="listitem" style="list-style-type: disc"><code class="literal">messageConverters</code>: It is the default message converters to convert from objects into XML or JSON and vice versa.</li><li class="listitem" style="list-style-type: disc"><code class="literal">multipartResolver</code>: It provides support to upload files in web applications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mvcValidator</code>: It supports validation of HTTP requests.</li><li class="listitem" style="list-style-type: disc"><code class="literal">viewResolver</code>: It resolves a logical view name to a physical view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">propertySourcesPlaceholderConfigurer</code>: It supports the externalization of application configuration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">requestContextFilter</code>: It defaults the filter for requests.</li><li class="listitem" style="list-style-type: disc"><code class="literal">restTemplateBuilder</code>: It is used to make calls to REST services.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tomcatEmbeddedServletContainerFactory</code>: Tomcat is the default embedded servlet container for Spring Boot-based web applications.</li></ul></div><p>In the next section, let's look at some of the starter projects and the auto-configuration they provide.</p></div><div class="section" title="Starter Projects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Starter Projects</h2></div></div></div><p>The following table shows some of the important starter projects provided by Spring Boot:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Starter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-webservices</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a starter project to develop XMLbased web services.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-web</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a starter project to build Spring MVC-based web applications or RESTful applications. It uses Tomcat as the default embedded servlet container.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-activemq</code></p>
</td><td style="text-align: left" valign="top">
<p>This supports message-based communication using JMS on ActiveMQ.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starterintegration</code></p>
</td><td style="text-align: left" valign="top">
<p>This supports the Spring Integration Framework that provides implementations for Enterprise Integration Patterns.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-test</code></p>
</td><td style="text-align: left" valign="top">
<p>This provides support for various unit testing frameworks, such as JUnit, Mockito, and Hamcrest matchers.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-jdbc</code></p>
</td><td style="text-align: left" valign="top">
<p>This provides support for using Spring JDBC. It configures a Tomcat JDBC connection pool by default.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-startervalidation</code></p>
</td><td style="text-align: left" valign="top">
<p>This provides support for the Java Bean Validation API. Its default implementation is hibernate-validator.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-hateoas</code></p>
</td><td style="text-align: left" valign="top">
<p>HATEOAS stands for Hypermedia as the Engine of Application State. RESTful services that use HATEOAS return links to additional resources that are related to the current context in addition to data.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-jersey</code></p>
</td><td style="text-align: left" valign="top">
<p>JAX-RS is the Java EE standard to develop REST APIs. Jersey is the default implementation. This starter project provides support to build JAX-RS-based REST APIs.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starterwebsocket</code></p>
</td><td style="text-align: left" valign="top">
<p>HTTP is stateless. WebSockets allow you to maintain a connection between the server and the browser. This starter project provides support for Spring WebSockets.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-aop</code></p>
</td><td style="text-align: left" valign="top">
<p>This provides support for Aspect Oriented Programming. It also provides support for AspectJ for advanced aspect-oriented programming.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-amqp</code></p>
</td><td style="text-align: left" valign="top">
<p>With RabbitMQ as the default, this starter project provides message passing with AMQP.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-security</code></p>
</td><td style="text-align: left" valign="top">
<p>This starter project enables auto-configuration for Spring Security.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-data-jpa</code></p>
</td><td style="text-align: left" valign="top">
<p>This provides support for Spring Data JPA. Its default implementation is Hibernate.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a base starter for Spring Boot applications. It provides support for auto-configuration and logging.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-batch</code></p>
</td><td style="text-align: left" valign="top">
<p>This provides support to develop batch applications using Spring Batch.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-cache</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the basic support for caching using Spring Framework.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">spring-boot-starter-datarest</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the support to expose REST services using Spring Data REST.</p>
</td></tr></tbody></table></div><p>Until now, we have set up a basic web application and understood some of the important concepts related to Spring Boot:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Auto-configuration</li><li class="listitem" style="list-style-type: disc">Starter projects</li><li class="listitem" style="list-style-type: disc"><code class="literal">spring-boot-maven-plugin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">spring-boot-starter-parent</code></li><li class="listitem" style="list-style-type: disc">Annotation <code class="literal">@SpringBootApplication</code></li></ul></div><p>Now let's shift our focus to understanding what REST is and building a REST Service.</p></div></div>
<div class="section" title="What is REST?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>What is REST?</h1></div></div></div><p>
<span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>) is basically an architectural style for the web. REST specifies a set of constraints. These constraints ensure that clients (service consumers and browsers) can interact with servers in flexible ways.</p><p>Let's first understand some common terminologies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Server</strong></span>: Service provider. Exposes services which can be consumed by clients.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>: Service consumer. Could be a browser or another system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource</strong></span>: Any information can be a resource: a person, an image, a video, or a product you want to sell.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Representation</strong></span>: A specific way a resource can be represented. For example, the product resource can be represented using JSON, XML, or HTML. Different clients might request different representations of the resource.</li></ul></div><p>Some of the important REST constraints are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client-Server</strong></span>: There should be a server (service provider) and a client (service consumer). This enables loose coupling and independent evolution of the server and client as new technologies emerge.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stateless</strong></span>: Each service should be stateless. Subsequent requests should not depend on some data from a previous request being temporarily stored. Messages should be self-descriptive.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Uniform interface</strong></span>: Each resource has a resource identifier. In the case of web services, we use this URI example: <code class="literal">/users/Jack/todos/1</code>. In this, URI Jack is the name of the user. <code class="literal">1</code> is the ID of the todo we would want to retrieve.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cacheable</strong></span>: The service response should be cacheable. Each response should indicate whether it is cacheable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layered system</strong></span>: The consumer of the service should not assume a direct connection to the service provider. Since requests can be cached, the client might be getting the cached response from a middle layer.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manipulation of resources through representations</strong></span>: A resource can have multiple representations. It should be possible to modify the resource through a message with any of these representations.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hypermedia as the engine of application state</strong></span> (<span class="strong"><strong>HATEOAS</strong></span>): The consumer of a RESTful application should know about only one fixed service URL. All subsequent resources should be discoverable from the links included in the resource representations.</li></ul></div><p>An example response with the HATEOAS link is shown here. This is the response to a request to retrieve all todos:</p><div class="informalexample"><pre class="programlisting">    {  
"_embedded":{ 
"todos":[ 
{ 
"user":"Jill",
"desc":"Learn Hibernate",
"done":false,
"_links":{ 
"self":{ 
"href":"http://localhost:8080/todos/1"
                  },
"todo":{ 
"href":"http://localhost:8080/todos/1"
}
}
}
]
},
"_links":{ 
"self":{ 
"href":"http://localhost:8080/todos"
},
"profile":{ 
"href":"http://localhost:8080/profile/todos"
},
"search":{ 
"href":"http://localhost:8080/todos/search"
}
}
    }</pre></div><p>The preceding response includes links to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Specific todos (<code class="literal">http://localhost:8080/todos/1</code>)</li><li class="listitem" style="list-style-type: disc">Search <code class="literal">resource</code> (<code class="literal">http://localhost:8080/todos/search</code>)</li></ul></div><p>If the service consumer wants to do a search, it has the option of taking the search URL from the response and sending the search request to it. This would reduce coupling between the service provider and the service consumer.</p><p>The initial services we develop will not be adhering to all these constraints. As we move on to the next lessons, we will introduce you to the details of these constraints and add them to the services to make them more RESTful.</p></div>
<div class="section" title="First REST Service"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>First REST Service</h1></div></div></div><p>Let's start with creating a simple REST service returning a welcome message. We will create a simple POJO <code class="literal">WelcomeBean</code> class with a member field called message and one argument constructor, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    package com.mastering.spring.springboot.bean;

    public class WelcomeBean {
      private String message;

       public WelcomeBean(String message) {
         super();
         this.message = message;
       }

      public String getMessage() {
        return message;
      }
    }</pre></div><div class="section" title="Simple Method Returning String"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Simple Method Returning String</h2></div></div></div><p>Let's start with creating a simple REST Controller method returning a string:</p><div class="informalexample"><pre class="programlisting">    @RestController
    public class BasicController {
      @GetMapping("/welcome")
      public String welcome() {
        return "Hello World";
      }
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@RestController</code>: The <code class="literal">@RestController</code> annotation provides a combination of <code class="literal">@ResponseBody</code> and <code class="literal">@Controller</code> annotations. This is typically used to create REST Controllers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@GetMapping("welcome")</code>: <code class="literal">@GetMapping</code> is a shortcut for <code class="literal">@RequestMapping(method = RequestMethod.GET)</code>. This annotation is a readable alternative. The method with this annotation would handle a Get request to the <code class="literal">welcome</code> URI.</li></ul></div><p>If we run <code class="literal">Application.java</code> as a Java application, it would start up the embedded Tomcat container. We can launch up the URL in the browser, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Simple Method Returning String" src="graphics/01_03.jpg"/></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Unit Testing</h3></div></div></div><p>Let's quickly write a unit test to test the preceding <code class="literal">controller</code> method:</p><div class="informalexample"><pre class="programlisting">    @RunWith(SpringRunner.class)
    @WebMvcTest(BasicController.class)
    public class BasicControllerTest {

      @Autowired
      private MockMvc mvc;

      @Test
      public void welcome() throws Exception {
        mvc.perform(
        MockMvcRequestBuilders.get("/welcome")
       .accept(MediaType.APPLICATION_JSON))
       .andExpect(status().isOk())
       .andExpect(content().string(
       equalTo("Hello World")));
      }
    }</pre></div><p>In the preceding unit test, we will launch up a Mock MVC instance with <code class="literal">BasicController</code>. A few quick things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@RunWith(SpringRunner.class)</code>: SpringRunner is a shortcut to the <code class="literal">SpringJUnit4ClassRunner</code> annotation. This launches up a simple Spring context for unit testing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@WebMvcTest(BasicController.class)</code>: This annotation can be used along with SpringRunner to write simple tests for Spring MVC controllers. This will load only the beans annotated with Spring-MVC-related annotations. In this example, we are launching a Web MVC Test context with the class under test being BasicController.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Autowired private MockMvc mvc</code>: Autowires the MockMvc bean that can be used to make requests.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON))</code>: Performs a request to <code class="literal">/welcome</code> with the <code class="literal">Accept</code> header value <code class="literal">application/json</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">andExpect(status().isOk())</code>: Expects that the status of the response is 200 (success).</li><li class="listitem" style="list-style-type: disc"><code class="literal">andExpect(content().string(equalTo("Hello World")))</code>: Expects that the content of the response is equal to <code class="literal">"Hello World"</code>.</li></ul></div></div><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Integration Testing</h3></div></div></div><p>When we do integration testing, we would want to launch the embedded server with all the controllers and beans that are configured. This code snippet shows how we can create a simple integration test:</p><div class="informalexample"><pre class="programlisting">    @RunWith(SpringRunner.class)
    @SpringBootTest(classes = Application.class, 
    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
    public class BasicControllerIT {

      private static final String LOCAL_HOST = 
      "http://localhost:";

      @LocalServerPort
      private int port;

      private TestRestTemplate template = new TestRestTemplate();

      @Test
      public void welcome() throws Exception {
        ResponseEntity&lt;String&gt; response = template
       .getForEntity(createURL("/welcome"), String.class);
        assertThat(response.getBody(), equalTo("Hello World"));
       }

      private String createURL(String uri) {
        return LOCAL_HOST + port + uri;
      }
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code>: It provides additional functionality on top of the Spring <code class="literal">TestContext</code>. Provides support to configure the port for fully running the container and <code class="literal">TestRestTemplate</code> (to execute requests).</li><li class="listitem" style="list-style-type: disc"><code class="literal">@LocalServerPort private int port</code>: The <code class="literal">SpringBootTest</code> would ensure that the port on which the container is running is autowired into the <code class="literal">port</code> variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">private String createURL(String uri)</code>: The method to append the local host URL and port to the URI to create a full URL.</li><li class="listitem" style="list-style-type: disc"><code class="literal">private TestRestTemplate template = new TestRestTemplate()</code>: The <code class="literal">TestRestTemplate</code> is typically used in integration tests. It provides additional functionality on top of <code class="literal">RestTemplate</code>, which is especially useful in the integration test context. It does not follow redirects so that we can assert response location.</li><li class="listitem" style="list-style-type: disc"><code class="literal">template.getForEntity(createURL("/welcome"), String.class)</code>: It executes a get request for the given URI.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertThat(response.getBody(), equalTo("Hello World"))</code>: It asserts that the response body content is <code class="literal">"Hello World"</code>.</li></ul></div></div></div><div class="section" title="Simple REST Method Returning an Object"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Simple REST Method Returning an Object</h2></div></div></div><p>In the previous method, we returned a string. Let's create a method that returns a proper JSON response. Take a look at the following method:</p><div class="informalexample"><pre class="programlisting">    @GetMapping("/welcome-with-object")
    public WelcomeBean welcomeWithObject() {
      return new WelcomeBean("Hello World");
    }</pre></div><p>This preceding method returns a simple <code class="literal">WelcomeBean</code> initialized with a message: <code class="literal">"Hello World"</code>.</p><div class="section" title="Executing a Request"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Executing a Request</h3></div></div></div><p>Let's send a test request and see what response we get. The following screenshot shows the output:</p><div class="mediaobject"><img alt="Executing a Request" src="graphics/01_04.jpg"/></div><p>The response for the <code class="literal">http://localhost:8080/welcome-with-object</code> URL is shown as follows:</p><div class="informalexample"><pre class="programlisting">    {"message":"Hello World"}</pre></div><p>The question that needs to be answered is this: how does the <code class="literal">WelcomeBean</code> object that we returned get converted into JSON?</p><p>Again, it's the magic of Spring Boot auto-configuration. If Jackson is on the classpath of an application, instances of the default object to JSON (and vice versa) converters are auto-configured by Spring Boot.</p></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Unit Testing</h3></div></div></div><p>Let's quickly write a unit test checking for the JSON response. Let's add the test to <code class="literal">BasicControllerTest</code>:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void welcomeWithObject() throws Exception {
      mvc.perform(
       MockMvcRequestBuilders.get("/welcome-with-object")
      .accept(MediaType.APPLICATION_JSON))
      .andExpect(status().isOk())
      .andExpect(content().string(containsString("Hello World")));
    }</pre></div><p>This test is very similar to the earlier unit test except that we are using <code class="literal">containsString</code> to check whether the content contains a substring <code class="literal">"Hello World"</code>. We will learn how to write proper JSON tests a little later.</p></div><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Integration Testing</h3></div></div></div><p>Let's shift our focus to writing an integration test. Let's add a method to <code class="literal">BasicControllerIT</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void welcomeWithObject() throws Exception {
      ResponseEntity&lt;String&gt; response = 
      template.getForEntity(createURL("/welcome-with-object"), 
      String.class);
      assertThat(response.getBody(), 
      containsString("Hello World"));
    }</pre></div><p>This method is similar to the earlier integration test except that we are asserting for a sub-string using the <code class="literal">String</code>method.</p></div></div><div class="section" title="Get Method with Path Variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Get Method with Path Variables</h2></div></div></div><p>Let's shift our attention to path variables. Path variables are used to bind values from the URI to a variable on the controller method. In the following example, we want to parameterize the name so that we can customize the welcome message with a name:</p><div class="informalexample"><pre class="programlisting">    private static final String helloWorldTemplate = "Hello World, 
    %s!";

   @GetMapping("/welcome-with-parameter/name/{name}")
   public WelcomeBean welcomeWithParameter(@PathVariable String name) 
    {
       return new WelcomeBean(String.format(helloWorldTemplate, name));
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@GetMapping("/welcome-with-parameter/name/{name}")</code>: <code class="literal">{name}</code> indicates that this value will be the variable. We can have multiple variable templates in a URI.</li><li class="listitem" style="list-style-type: disc"><code class="literal">welcomeWithParameter(@PathVariable String name)</code>: <code class="literal">@PathVariable</code> ensures that the variable value from the URI is bound to the variable name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">String.format(helloWorldTemplate, name)</code>: A simple string format to replace <code class="literal">%s</code> in the template with the name.</li></ul></div><div class="section" title="Executing a Request"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Executing a Request</h3></div></div></div><p>Let's send a test request and see what response we get. The following screenshot shows the response:</p><div class="mediaobject"><img alt="Executing a Request" src="graphics/01_05.jpg"/></div><p>The response for the <code class="literal">http://localhost:8080/welcome-with-parameter/name/Buddy</code> URL is as follows:</p><div class="informalexample"><pre class="programlisting">    {"message":"Hello World, Buddy!"}</pre></div><p>As expected, the name in the URI is used to form the message in the response.</p></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Unit Testing</h3></div></div></div><p>Let's quickly write a unit test for the preceding method. We would want to pass a name as part of the URI and check whether the response contains the name. The following code shows how we can do that:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void welcomeWithParameter() throws Exception {
      mvc.perform(
      MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")
     .accept(MediaType.APPLICATION_JSON))
     .andExpect(status().isOk())
     .andExpect(
     content().string(containsString("Hello World, Buddy")));
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")</code>: This matches against the variable template in the URI. We pass in the name <code class="literal">Buddy</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.andExpect(content().string(containsString("Hello World, Buddy")))</code>: We expect the response to contain the message with the name.</li></ul></div></div><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Integration Testing</h3></div></div></div><p>The integration test for the preceding method is very simple. Take a look at the following <code class="literal">test</code> method:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void welcomeWithParameter() throws Exception {
      ResponseEntity&lt;String&gt; response = 
      template.getForEntity(
      createURL("/welcome-with-parameter/name/Buddy"), String.class);
      assertThat(response.getBody(), 
      containsString("Hello World, Buddy"));
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">createURL("/welcome-with-parameter/name/Buddy")</code>: This matches against the variable template in the URI. We are passing in the name, Buddy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertThat(response.getBody(), containsString("Hello World, Buddy"))</code>: We expect the response to contain the message with the name.</li></ul></div><p>In this section, we looked at the basics of creating a simple REST service with Spring Boot. We also ensured that we have good unit tests and integration tests. While these are really basic, they lay the foundation for more complex REST services we will build in the next section.</p><p>The unit tests and integration tests we implemented can have better asserts using a JSON comparison instead of a simple substring comparison. We will focus on it in the tests we write for the REST services we will create in the next sections.</p></div></div></div>
<div class="section" title="Creating a Todo Resource"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Creating a Todo Resource</h1></div></div></div><p>We will focus on creating REST services for a basic todo management system. We will create services for the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Retrieving a list of todos for a given user</li><li class="listitem" style="list-style-type: disc">Retrieving details for a specific todo</li><li class="listitem" style="list-style-type: disc">Creating a todo for a user</li></ul></div><div class="section" title="Request Methods, Operations, and Uris"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Request Methods, Operations, and Uris</h2></div></div></div><p>One of the best practices of REST services is to use the appropriate HTTP request method based on the action we perform. In the services we exposed until now, we used the <code class="literal">GET</code> method, as we focused on services that read data.</p><p>The following table shows the appropriate HTTP Request method based on the operation that we perform:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>HTTP Request Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Operation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Read--Retrieve details for a resource</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">POST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Create--Create a new item or resource</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Update/replace</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PATCH</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Update/modify a part of the resource</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DELETE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Delete</p>
</td></tr></tbody></table></div><p>Let's quickly map the services that we want to create to the appropriate request methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Retrieving a list of todos for a given user</strong></span>: This is READ. We will use GET. We will use a URI: <code class="literal">/users/{name}/todos</code>. One more good practice is to use plurals for static things in the URI: users, todo, and so on. This results in more readable URIs.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Retrieving details for a specific todo</strong></span>: Again, we will use <code class="literal">GET</code>. We will use a URI <code class="literal">/users/{name}/todos/{id}</code>. You can see that this is consistent with the earlier URI that we decided for the list of todos.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Creating a todo for a user</strong></span>: For the create operation, the suggested HTTP Request method is <code class="literal">POST</code>. To create a new todo, we will post to <code class="literal">URI /users/{name}/todos</code>.</li></ul></div></div><div class="section" title="Beans and Services"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Beans and Services</h2></div></div></div><p>To be able to retrieve and store details of a todo, we need a Todo bean and a service to retrieve and store the details.</p><p>Let's create a Todo Bean:</p><div class="informalexample"><pre class="programlisting">    public class Todo {
      private int id;
      private String user;

      private String desc;

      private Date targetDate;
      private boolean isDone;

      public Todo() {}

      public Todo(int id, String user, String desc, 
      Date targetDate, boolean isDone) { 
        super();
        this.id = id;
        this.user = user;
        this.desc = desc;
        this.targetDate = targetDate;
        this.isDone = isDone;
      }

       //ALL Getters
    }</pre></div><p>We have a created a simple Todo bean with the ID, the name of user, the description of the todo, the todo target date, and an indicator for the completion status. We added a constructor and getters for all fields.</p><p>Let's add <code class="literal">TodoService</code> now:</p><div class="informalexample"><pre class="programlisting">   @Service
   public class TodoService {
     private static List&lt;Todo&gt; todos = new ArrayList&lt;Todo&gt;();
     private static int todoCount = 3;

     static {
       todos.add(new Todo(1, "Jack", "Learn Spring MVC", 
       new Date(), false));
       todos.add(new Todo(2, "Jack", "Learn Struts", new Date(), 
       false));
       todos.add(new Todo(3, "Jill", "Learn Hibernate", new Date(), 
       false));
      }

     public List&lt;Todo&gt; retrieveTodos(String user) {
       List&lt;Todo&gt; filteredTodos = new ArrayList&lt;Todo&gt;();
       for (Todo todo : todos) {
         if (todo.getUser().equals(user))
         filteredTodos.add(todo);
        }
      return filteredTodos;
     }

    public Todo addTodo(String name, String desc, 
    Date targetDate, boolean isDone) {
      Todo todo = new Todo(++todoCount, name, desc, targetDate, 
      isDone);
      todos.add(todo);
      return todo;
    }

    public Todo retrieveTodo(int id) {
      for (Todo todo : todos) {
      if (todo.getId() == id)
        return todo;
      }
      return null;
     }
   }</pre></div><p>Quick things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To keep things simple, this service does not talk to the database. It maintains an in-memory array list of todos. This list is initialized using a static initializer.</li><li class="listitem" style="list-style-type: disc">We are exposing a couple of simple retrieve methods and a method to add a to-do.</li></ul></div><p>Now that we have the service and bean ready, we can create our first service to retrieve a list of to-do's for a user.</p></div><div class="section" title="Retrieving a Todo List"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Retrieving a Todo List</h2></div></div></div><p>We will create a new <code class="literal">RestController</code> annotation called <code class="literal">TodoController</code>. The code for the retrieve todos method is shown as follows:</p><div class="informalexample"><pre class="programlisting">    @RestController
    public class TodoController {
     @Autowired
     private TodoService todoService;

     @GetMapping("/users/{name}/todos")
     public List&lt;Todo&gt; retrieveTodos(@PathVariable String name) {
       return todoService.retrieveTodos(name);
     }
    }</pre></div><p>A couple of things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are autowiring the todo service using the <code class="literal">@Autowired</code> annotation</li><li class="listitem" style="list-style-type: disc">We use the <code class="literal">@GetMapping</code> annotation to map the Get request for the <code class="literal">"/users/{name}/todos"</code> URI to the <code class="literal">retrieveTodos</code> method</li></ul></div><div class="section" title="Executing the Service"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Executing the Service</h3></div></div></div><p>Let's send a test request and see what response we get. The following screenshot shows the output:</p><div class="mediaobject"><img alt="Executing the Service" src="graphics/01_06.jpg"/></div><p>The response for the <code class="literal">http://localhost:8080/users/Jack/todos</code> URL is as follows:</p><div class="informalexample"><pre class="programlisting">   [
    {"id":1,"user":"Jack","desc":"Learn Spring    
     MVC","targetDate":1481607268779,"done":false},  
    {"id":2,"user":"Jack","desc":"Learn 
    Struts","targetDate":1481607268779, "done":false}
   ]</pre></div></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Unit Testing</h3></div></div></div><p>The code to unit test the <code class="literal">TodoController</code> class is shown in the following screenshot:</p><div class="informalexample"><pre class="programlisting">   @RunWith(SpringRunner.class)
   @WebMvcTest(TodoController.class)
   public class TodoControllerTest {

    @Autowired
    private MockMvc mvc;

    @MockBean
    private TodoService service;

    @Test
    public void retrieveTodos() throws Exception {
     List&lt;Todo&gt; mockList = Arrays.asList(new Todo(1, "Jack",
     "Learn Spring MVC", new Date(), false), new Todo(2, "Jack",
     "Learn Struts", new Date(), false));

     when(service.retrieveTodos(anyString())).thenReturn(mockList);

     MvcResult result = mvc
    .perform(MockMvcRequestBuilders.get("/users
    /Jack/todos").accept(MediaType.APPLICATION_JSON))
    .andExpect(status().isOk()).andReturn();

    String expected = "["
     + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" +","
     + "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]";

     JSONAssert.assertEquals(expected, result.getResponse()
      .getContentAsString(), false);
     }
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are writing a unit test. So, we want to test only the logic present in the <code class="literal">TodoController</code> class. So, we initialize a Mock MVC framework with only the <code class="literal">TodoController</code> class using <code class="literal">@WebMvcTest(TodoController.class)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@MockBean private TodoService service</code>: We are mocking out the <code class="literal">TodoService</code> using the <code class="literal">@MockBean</code>annotation. In test classes that are run with <code class="literal">SpringRunner</code>, the beans defined with <code class="literal">@MockBean</code> will be replaced by a mock, created using the Mockito framework.</li><li class="listitem" style="list-style-type: disc"><code class="literal">when(service.retrieveTodos(anyString())).thenReturn(mockList)</code>: We are mocking the <code class="literal">retrieveTodos</code> service method to return the mock list.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MvcResult result = ..</code>: We are accepting the result of the request into an MvcResult variable to enable us to perform assertions on the response.</li><li class="listitem" style="list-style-type: disc"><code class="literal">JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(), false)</code>: JSONAssert is a very useful framework to perform asserts on JSON. It compares the response text with the expected value. <code class="literal">JSONAssert</code> is intelligent enough to ignore values that are not specified. Another advantage is a clear failure message in case of assertion failures. The last parameter, false, indicates using non-strict mode. If it is changed to true, then the expected should exactly match the result.</li></ul></div></div><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"/>Integration Testing</h3></div></div></div><p>The code to perform integration testing on the <code class="literal">TodoController</code> class is shown in the following code snippet. It launches up the entire Spring context with all the controllers and beans defined:</p><div class="informalexample"><pre class="programlisting">   @RunWith(SpringJUnit4ClassRunner.class)
   @SpringBootTest(classes = Application.class, webEnvironment =     
   SpringBootTest.WebEnvironment.RANDOM_PORT)
   public class TodoControllerIT {

    @LocalServerPort
    private int port;

    private TestRestTemplate template = new TestRestTemplate();

    @Test
    public void retrieveTodos() throws Exception {
     String expected = "["
     + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" + ","
     + "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]";

     String uri = "/users/Jack/todos";

     ResponseEntity&lt;String&gt; response =
     template.getForEntity(createUrl(uri), String.class);

     JSONAssert.assertEquals(expected, response.getBody(), false);
    }

     private String createUrl(String uri) {
     return "http://localhost:" + port + uri;
    }
  }</pre></div><p>This test is very similar to the integration test for <code class="literal">BasicController</code>, except that we are using <code class="literal">JSONAssert</code> to assert the response.</p></div></div><div class="section" title="Retrieving Details for a Specific Todo"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Retrieving Details for a Specific Todo</h2></div></div></div><p>We will now add the method to retrieve details for a specific Todo:</p><div class="informalexample"><pre class="programlisting">    @GetMapping(path = "/users/{name}/todos/{id}")
    public Todo retrieveTodo(@PathVariable String name, @PathVariable 
    int id) {
      return todoService.retrieveTodo(id);
    }</pre></div><p>A couple of things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The URI mapped is <code class="literal">/users/{name}/todos/{id}</code></li><li class="listitem" style="list-style-type: disc">We have two path variables defined for <code class="literal">name</code> and <code class="literal">id</code></li></ul></div><div class="section" title="Executing the Service"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec15"/>Executing the Service</h3></div></div></div><p>Let's send a test request and see what response we will get, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Executing the Service" src="graphics/01_07.jpg"/></div><p>The response for the <code class="literal">http://localhost:8080/users/Jack/todos/1</code> URL is shown as follows:</p><div class="informalexample"><pre class="programlisting">    {"id":1,"user":"Jack","desc":"Learn Spring MVC", 
    "targetDate":1481607268779,"done":false}</pre></div></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec16"/>Unit Testing</h3></div></div></div><p>The code to unit test <code class="literal">retrieveTodo</code> is as follows:</p><div class="informalexample"><pre class="programlisting">     @Test
     public void retrieveTodo() throws Exception {
       Todo mockTodo = new Todo(1, "Jack", "Learn Spring MVC", 
       new Date(), false);

       when(service.retrieveTodo(anyInt())).thenReturn(mockTodo);

       MvcResult result = mvc.perform(
       MockMvcRequestBuilders.get("/users/Jack/todos/1")
       .accept(MediaType.APPLICATION_JSON))
       .andExpect(status().isOk()).andReturn();

       String expected = "{id:1,user:Jack,desc:\"Learn Spring
       MVC\",done:false}";

      JSONAssert.assertEquals(expected, 
       result.getResponse().getContentAsString(), false);

     }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">when(service.retrieveTodo(anyInt())).thenReturn(mockTodo)</code>: We are mocking the <code class="literal">retrieveTodo</code> service method to return the mock todo.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MvcResult result = ..</code>: We are accepting the result of the request into an MvcResult variable to enable us to perform assertions on the response.</li><li class="listitem" style="list-style-type: disc"><code class="literal">JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(), false)</code>: Asserts whether the result is as expected.</li></ul></div></div><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec17"/>Integration Testing</h3></div></div></div><p>The code to perform integration testing on <code class="literal">retrieveTodos</code> in <code class="literal">TodoController</code> is shown in the following code snippet. This would be added to the <code class="literal">TodoControllerIT</code> class:</p><div class="informalexample"><pre class="programlisting">     @Test
     public void retrieveTodo() throws Exception {
       String expected = "{id:1,user:Jack,desc:\"Learn Spring   
       MVC\",done:false}";
       ResponseEntity&lt;String&gt; response = template.getForEntity(
       createUrl("/users/Jack/todos/1"), String.class);
       JSONAssert.assertEquals(expected, response.getBody(), false);
     }</pre></div></div></div><div class="section" title="Adding A Todo"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Adding A Todo</h2></div></div></div><p>We will now add the method to create a new Todo. The HTTP method to be used for creation is <code class="literal">Post</code>. We will post to a <code class="literal">"/users/{name}/todos"</code> URI:</p><div class="informalexample"><pre class="programlisting">    @PostMapping("/users/{name}/todos")
    ResponseEntity&lt;?&gt; add(@PathVariable String name,
    @RequestBody Todo todo) { 
      Todo createdTodo = todoService.addTodo(name, todo.getDesc(),
      todo.getTargetDate(), todo.isDone());
      if (createdTodo == null) {
         return ResponseEntity.noContent().build();
      }

     URI location = ServletUriComponentsBuilder.fromCurrentRequest()

    .path("/{id}").buildAndExpand(createdTodo.getId()).toUri();
    return ResponseEntity.created(location).build();
   }</pre></div><p>A few things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@PostMapping("/users/{name}/todos")</code>: <code class="literal">@PostMapping</code> annotations map the <code class="literal">add()</code> method to the HTTP Request with a <code class="literal">POST</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ResponseEntity&lt;?&gt; add(@PathVariable String name, @RequestBody Todo todo)</code>: An HTTP post request should ideally return the URI to the created resources. We use <code class="literal">ResourceEntity</code> to do this. <code class="literal">@RequestBody</code> binds the body of the request directly to the bean.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ResponseEntity.noContent().build()</code>: Used to return that the creation of the resource failed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(createdTodo.getId()).toUri()</code>: Forms the URI for the created resource that can be returned in the response.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ResponseEntity.created(location).build()</code>: Returns a status of <code class="literal">201(CREATED)</code> with a link to the resource created.</li></ul></div><div class="section" title="Postman"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec18"/>Postman</h3></div></div></div><p>If you are on Mac, you might want to try the Paw application as well.</p><p>Let's send a test request and see what response we get. The following screenshot shows the response:</p><div class="mediaobject"><img alt="Postman" src="graphics/01_08.jpg"/></div><p>We will use Postman app to interact with the REST Services. You can install it from the website, <a class="ulink" href="https://www.getpostman.com/">https://www.getpostman.com/</a>. It is available on Windows and Mac. A Google Chrome plugin is also available.</p></div><div class="section" title="Executing the POST Service"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec19"/>Executing the POST Service</h3></div></div></div><p>To create a new Todo using <code class="literal">POST</code>, we would need to include the JSON for the Todo in the body of the request. The following screenshot shows how we can use the Postman app to create the request and the response after executing the request:</p><div class="mediaobject"><img alt="Executing the POST Service" src="graphics/01_09.jpg"/></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are sending a POST request. So, we choose the <code class="literal">POST</code> from the top-left dropdown.</li><li class="listitem" style="list-style-type: disc">To send the Todo JSON as part of the body of the request, we select the <code class="literal">raw</code> option in the <code class="literal">Body</code> tab (highlighted with a blue dot). We choose the content type as JSON (<code class="literal">application/json</code>).</li><li class="listitem" style="list-style-type: disc">Once the request is successfully executed, you can see the status of the request in the bar in the middle of the screen: <code class="literal">Status: 201 Created</code>.</li><li class="listitem" style="list-style-type: disc">The location is <code class="literal">http://localhost:8080/users/Jack/todos/5</code>. This is the URI of the newly created todo that is received in the response.</li></ul></div><p>Complete details of the request to <code class="literal">http://localhost:8080/users/Jack/todos</code> are shown in the block, as follows:</p><div class="informalexample"><pre class="programlisting">    Header
    Content-Type:application/json

   Body
    {
      "user": "Jack",
      "desc": "Learn Spring Boot",
       "done": false
     }</pre></div></div><div class="section" title="Unit Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec20"/>Unit Testing</h3></div></div></div><p>The code to unit test the created Todo is shown as follows:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void createTodo() throws Exception {
     Todo mockTodo = new Todo(CREATED_TODO_ID, "Jack", 
     "Learn Spring MVC", new Date(), false);
     String todo = "{"user":"Jack","desc":"Learn Spring MVC",     
     "done":false}";

    when(service.addTodo(anyString(), anyString(),   
    isNull(),anyBoolean()))
    .thenReturn(mockTodo);

   mvc
    .perform(MockMvcRequestBuilders.post("/users/Jack/todos")
    .content(todo)
    .contentType(MediaType.APPLICATION_JSON)
    )
    .andExpect(status().isCreated())
    .andExpect(
      header().string("location",containsString("/users/Jack/todos/"
     + CREATED_TODO_ID)));
   }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">String todo = "{"user":"Jack","desc":"Learn Spring MVC","done":false}"</code>: The Todo content to post to the create todo service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo)</code>: Mocks the service to return a dummy todo.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))</code>: Creates a POST to a given URI with the given content type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">andExpect(status().isCreated())</code>: Expects that the status is created.</li><li class="listitem" style="list-style-type: disc"><code class="literal">andExpect(header().string("location",containsString("/users/Jack/todos/" + CREATED_TODO_ID)))</code>: Expects that the header contains <code class="literal">location</code> with the URI of created resource.</li></ul></div></div><div class="section" title="Integration Testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec21"/>Integration Testing</h3></div></div></div><p>The code to perform integration testing on the created todo in <code class="literal">TodoController</code> is shown as follows. This would be added to the <code class="literal">TodoControllerIT</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void addTodo() throws Exception {
      Todo todo = new Todo(-1, "Jill", "Learn Hibernate", new Date(),  
      false);
      URI location = template
     .postForLocation(createUrl("/users/Jill/todos"),todo);
      assertThat(location.getPath(), 
      containsString("/users/Jill/todos/4"));
    }</pre></div><p>A few important things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">URI location = template.postForLocation(createUrl("/users/Jill/todos"), todo)</code>: <code class="literal">postForLocation</code> is a utility method especially useful in tests to create new resources. We are posting the todo to the given URI and getting the location from the header.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertThat(location.getPath(), containsString("/users/Jill/todos/4"))</code>: Asserts that the location contains the path to the newly created resource.</li></ul></div></div></div></div>
<div class="section" title="Spring Initializr"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Spring Initializr</h1></div></div></div><p>Do you want to auto-generate Spring Boot projects? Do you want to quickly get started with developing your application? Spring Initializr is the answer.</p><p>Spring Initializr is hosted at <a class="ulink" href="http://start.spring.io">http://start.spring.io</a>. The following screenshot shows how the website looks:</p><div class="mediaobject"><img alt="Spring Initializr" src="graphics/01_10.jpg"/></div><p>Spring Initializr provides a lot of flexibility in creating projects. You have options to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Choose your build tool: Maven or Gradle.</li><li class="listitem" style="list-style-type: disc">Choose the Spring Boot version you want to use.</li><li class="listitem" style="list-style-type: disc">Configure a <code class="literal">Group ID</code> and <code class="literal">Artifact ID</code> for your component.</li><li class="listitem" style="list-style-type: disc">Choose the starters (dependencies) that you would want for your project. You can click on the link at the bottom of the screen, <code class="literal">Switch to the full version</code>, to see all the starter projects you can choose from.</li><li class="listitem" style="list-style-type: disc">Choose how to package your component: JAR or WAR.</li><li class="listitem" style="list-style-type: disc">Choose the Java version you want to use.</li><li class="listitem" style="list-style-type: disc">Choose the JVM language you want to use.</li></ul></div><p>The following screenshot shows some of the options Spring Initializr provides when you expand (click on the link) to the full version:</p><div class="mediaobject"><img alt="Spring Initializr" src="graphics/01_11.jpg"/></div><div class="section" title="Creating Your First Spring Initializr Project"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Creating Your First Spring Initializr Project</h2></div></div></div><p>We will use the full version and enter the values, as follows:</p><div class="mediaobject"><img alt="Creating Your First Spring Initializr Project" src="graphics/01_12.jpg"/></div><p>Things to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Build tool</code>: <code class="literal">Maven</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring Boot version</code>: Choose the latest available</li><li class="listitem" style="list-style-type: disc"><code class="literal">Group</code>: <code class="literal">com.mastering.spring</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Artifact</code>: <code class="literal">first-spring-initializr</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Selected dependencies</code>: Choose <code class="literal">Web, JPA, Actuator and Dev Tools</code>. Type in each one of these in the textbox and press <span class="emphasis"><em>Enter</em></span> to choose them. We will learn more about Actuator and Dev Tools in the next section</li><li class="listitem" style="list-style-type: disc"><code class="literal">Java version</code>: <code class="literal">1.8</code></li></ul></div><p>Go ahead and click on the <span class="strong"><strong>Generate Project</strong></span> button. This will create a <code class="literal">.zip</code> file and you can download it to your computer.</p><p>The following screenshot shows the structure of the project created:</p><div class="mediaobject"><img alt="Creating Your First Spring Initializr Project" src="graphics/01_13.jpg"/></div><p>We will now import this project into your IDE. In Eclipse, you can perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Launch Eclipse.</li><li class="listitem">Navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Import</strong></span>.</li><li class="listitem">Choose the existing Maven projects.</li><li class="listitem">Browse and select the folder that is the root of the Maven project (the one containing the <code class="literal">pom.xml</code> file).</li><li class="listitem">Proceed with the defaults and click on <span class="strong"><strong>Finish</strong></span><code class="literal">.</code></li></ol></div><p>This will import the project into Eclipse. The following screenshot shows the structure of the project in Eclipse:</p><div class="mediaobject"><img alt="Creating Your First Spring Initializr Project" src="graphics/01_14.jpg"/></div><p>Let's look at some of the important files from the generated project.</p><div class="section" title="pom.xml"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec22"/>pom.xml</h3></div></div></div><p>The following snippet shows the dependencies that are declared:</p><div class="informalexample"><pre class="programlisting">&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;</pre></div><p>A few other important observations are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The packaging for this component is <code class="literal">.jar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.springframework.boot:spring-boot-starter-parent</code> is declared as the parent POM</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;java.version&gt;1.8&lt;/java.version&gt;</code>: The Java version is 1.8</li><li class="listitem" style="list-style-type: disc">Spring Boot Maven Plugin (<code class="literal">org.springframework.boot:spring-boot-maven-plugin</code>) is configured as a plugin</li></ul></div></div><div class="section" title="FirstSpringInitializrApplication.java Class"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec23"/>FirstSpringInitializrApplication.java Class</h3></div></div></div><p>
<code class="literal">FirstSpringInitializrApplication.java</code> is the launcher for Spring Boot:</p><div class="informalexample"><pre class="programlisting">    package com.mastering.spring;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure
    .SpringBootApplication;

    @SpringBootApplication
    public class FirstSpringInitializrApplication {
       public static void main(String[] args) {
        SpringApplication.run(FirstSpringInitializrApplication.class,   
        args);
      }
    }</pre></div></div><div class="section" title="FirstSpringInitializrApplicationTests Class"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec24"/>FirstSpringInitializrApplicationTests Class</h3></div></div></div><p>
<code class="literal">FirstSpringInitializrApplicationTests</code> contains the basic context that can be used to start writing the tests as we start developing the application:</p><div class="informalexample"><pre class="programlisting">    package com.mastering.spring;
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.junit4.SpringRunner;

    @RunWith(SpringRunner.class)
    @SpringBootTest
    public class FirstSpringInitializrApplicationTests {

      @Test
      public void contextLoads() {
      }
   }</pre></div></div></div></div>
<div class="section" title="A Quick Peek into Auto-Configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>A Quick Peek into Auto-Configuration</h1></div></div></div><p>Auto-configuration is one of the most important features of Spring Boot. In this section, we will take a quick peek behind the scenes to understand how Spring Boot auto-configuration works.</p><p>Most of the Spring Boot auto-configuration magic comes from <code class="literal">spring-boot-autoconfigure-{version}.jar</code>. When we start any Spring Boot applications, a number of beans get auto-configured. How does this happen?</p><p>The following screenshot shows an extract from <code class="literal">spring.factories</code> from <code class="literal">spring-boot-autoconfigure-{version}.jar</code>. We have filtered out some of the configuration in the interest of space:</p><div class="mediaobject"><img alt="A Quick Peek into Auto-Configuration" src="graphics/01_15.jpg"/></div><p>The preceding list of auto-configuration classes is run whenever a Spring Boot application is launched. Let's take a quick look at one of them:</p><p>
<code class="literal">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code>.</p><p>Here's a small snippet:</p><div class="informalexample"><pre class="programlisting">@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
WebMvcConfigurerAdapter.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(DispatcherServletAutoConfiguration.class)
public class WebMvcAutoConfiguration {</pre></div><p>Some of the important points to note are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class })</code>: This auto-configuration is enabled if any of the mentioned classes are in the classpath. When we add a web starter project, we bring in dependencies with all these classes. Hence, this auto-configuration will be enabled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>: This auto-configuration is enabled only if the application does not explicitly declare a bean of the <code class="literal">WebMvcConfigurationSupport.class</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</code>: This specifies the precedence of this specific auto-configuration.</li></ul></div><p>Let's look at another small snippet showing one of the methods from the same class:</p><div class="informalexample"><pre class="programlisting">    @Bean
    @ConditionalOnBean(ViewResolver.class)
    @ConditionalOnMissingBean(name = "viewResolver", 
    value = ContentNegotiatingViewResolver.class)
    public ContentNegotiatingViewResolver 
    viewResolver(BeanFactory beanFactory) {
      ContentNegotiatingViewResolver resolver = new 
      ContentNegotiatingViewResolver();
      resolver.setContentNegotiationManager
      (beanFactory.getBean(ContentNegotiationManager.class));
      resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return resolver;
     }</pre></div><p>View resolvers are one of the beans configured by <code class="literal">WebMvcAutoConfiguration</code> class. The preceding snippet ensures that if a view resolver is not provided by the application, then Spring Boot auto-configures a default view resolver. Here are a few important points to note:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@ConditionalOnBean(ViewResolver.class)</code>: Create this bean if <code class="literal">ViewResolver.class</code> is on the classpath</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)</code>: Create this bean if there are no explicitly declared beans of the name <code class="literal">viewResolver</code> and of type <code class="literal">ContentNegotiatingViewResolver.class</code></li><li class="listitem" style="list-style-type: disc">The rest of the method is configured in the view resolver</li></ul></div><p>To summarize, all the auto-configuration logic is executed at the start of a Spring Boot application. If a specific class (from a specific dependency or starter project) is available on the classpath, then the auto configuration classes are executed. These auto-configuration classes look at what beans are already configured. Based on the existing beans, they enable the creation of the default beans.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>Spring Boot makes the development of Spring-based applications easy. It enables us to create production-ready applications from day one of a project.</p><p>In this lesson, we covered the basics of Spring Boot and REST services. We discussed the different features of Spring Boot and created a few REST services with great tests. We understood what happens in the background with an in-depth look at auto-configuration.</p><p>In the next lesson, we will shift our attention toward adding more features to the REST services.</p></div>
<div class="section" title="Assessments"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Assessments</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The _______ class can be used to bootstrap and launch a Spring application from a Java main method.</li><li class="listitem">Which of the following methods is used to append the local host URL and port to the URI to create a full URL?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Private URL(String uri)</li><li class="listitem">private String create(String uri)</li><li class="listitem">private String CreateURL(String uri)</li><li class="listitem">private String createURL(String uri)</li></ol></div></li><li class="listitem">State whether True or False: Tomcat server is launched on port 8080--Tomcat started on port(s): 8080 (http).</li><li class="listitem">Which of the following starter templates provides support for various unit testing frameworks such as JUnit, Mockito, and Hamcrest? These frameworks does the work of orchestrating the lock contention in Spring Boot.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">spring-boot-starter-test </li><li class="listitem">spring-boot-starter-testframe </li><li class="listitem">spring-boot-starter-unittest </li><li class="listitem">spring-boot-starter-testorchestration</li></ol></div></li><li class="listitem">State whether True or False: The multipartResolver does not provide support to upload files in web applications.</li></ol></div></div></body></html>