- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discusses Spring Security’s session management functionality.
    It starts off with an example of how Spring Security defends against session fixation.
    We will then discuss how concurrency control can be leveraged to restrict access
    to software licensed on a per-user basis. We will also see how session management
    can be leveraged for administrative functions. Last, we will explore how `HttpSession`
    is used in Spring Security and how we can manage sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Session management/session fixation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing logged-in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `HttpSession` is used in Spring Security and how to control creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `DebugFilter` class to discover where `HttpSession` was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/qaJyz](https://packt.link/qaJyz).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring session fixation protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are using the security namespace style of configuration, session fixation
    protection is already configured on our behalf. If we wanted to explicitly configure
    it to mirror the default settings, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Session fixation protection** is a feature of the framework that you most
    likely won’t even notice unless you try to act as a malicious user. We’ll show
    you how to simulate a session-stealing attack; before we do, it’s important to
    understand what session fixation does and the type of attack it prevents.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding session fixation attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Session fixation is a type of attack whereby a malicious user attempts to steal
    the session of an unauthenticated user of your system. This can be done by using
    a variety of techniques that result in the attacker obtaining the unique session
    identifier of the user (for example, `JSESSIONID`). If the attacker creates a
    cookie or a URL parameter with the user’s `JSESSIONID` identifier in it, they
    can access the user’s session.
  prefs: []
  type: TYPE_NORMAL
- en: Although this is obviously a problem, typically, if a user is unauthenticated,
    they haven’t entered any sensitive information. This becomes a more critical problem
    if the same session identifier continues to be used after a user has been authenticated.
    If the same identifier is used after authentication, the attacker may now gain
    access to the authenticated user’s session without even having to know their username
    or password!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may scoff in disbelief and think this is extremely unlikely
    to happen in the real world. In fact, session-stealing attacks happen frequently.
    We would suggest that you spend some time reading the very informative articles
    and case studies on the subject, published by the **Open Web Application Security
    Project** (**OWASP**) organization ([http://www.owasp.org/](http://www.owasp.org/)).
    Specifically, you will want to read the OWASP top 10 lists. Attackers and malicious
    users are real, and they can do very real damage to your users, your application,
    or your company if you don’t understand the techniques that they commonly use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how a session fixation attack works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Session fixation attack](img/B21757_14_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Session fixation attack
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we see that by fixing the session identifier to a known value,
    the attacker bypasses the normal authentication process and gains unauthorized
    access to the victim’s account or session. This type of attack underscores the
    importance of properly managing and securing session identifiers to prevent session
    fixation vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how an attack like this works, we’ll see what Spring Security
    can do to prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing session fixation attacks with Spring Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we can prevent the same session that the user had prior to authentication
    from being used after authentication, we can effectively render the attacker’s
    knowledge of the session ID useless. Spring Security session fixation protection
    solves this problem by explicitly creating a new session when a user is authenticated
    and invalidating their old session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Preventing session fixation attacks with Spring Security](img/B21757_14_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Preventing session fixation attacks with Spring Security
  prefs: []
  type: TYPE_NORMAL
- en: We can see that a new filter, `o.s.s.web.session.SessionManagementFilter`, is
    responsible for evaluating if a particular user is newly authenticated. If the
    user is newly authenticated, a configured `o.s.s.web.authentication.session.SessionAuthenticationStrategy`
    interface determines what to do. `o.s.s.web.authentication.session.SessionFixation`
    **ProtectionStrategy** will create a new session (if the user already had one)
    and copy the contents of the existing session to the new one. That’s pretty much
    it—seems simple. However, as we can see in the preceding diagram, it effectively
    prevents the malicious user from reusing the session ID after the unknown user
    is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a session fixation attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you may want to see what’s involved in simulating a session
    fixation attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter14.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll first need to disable session fixation protection in the `SecurityConfig.java`
    file by adding the `sessionManagement()` method as a child of the `HTTP` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to open two browsers. We’ll initiate the session in Google
    Chrome, steal it from there, and our attacker will log in using the stolen session
    in Firefox. We will use the *Google Chrome* and *Firefox Web Developer* add-ons
    in order to view and manipulate cookies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the JBCP calendar home page in Google Chrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Open Developer Tools**: Right-click on the web page and select **Inspect**,
    or press *Ctrl + Shift + I* (Windows/Linux) or *Cmd + Opt + I* (Mac) to open the
    Developer Tools.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigate to the Application Tab**: In the Developer Tools, you will see a
    menu at the top. Click on the **Application** tab.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locate Cookies in the Sidebar**: On the left sidebar, you should see a **Cookies**
    section. Expand it to see the list of domains with their associated cookies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select the Specific Domain**: Click on the domain relevant to the website
    you are interested in. This will display the list of cookies associated with that
    domain.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View the Cookie Values**: You can see the details of each cookie, including
    its name, value, domain, path, and so on. Look for the specific cookie you are
    interested in, and you will find its value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Cookies explorer in Google Chrome](img/B21757_14_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Cookies explorer in Google Chrome
  prefs: []
  type: TYPE_NORMAL
- en: Select the `JSESSIONID` cookie, copy the value of `JSESSIONID` did not change
    after you logged in, making you vulnerable to a session fixation attack!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Firefox, open the JBCP calendar website. You will have been assigned a session
    cookie, which you can view by using *Ctrl + F2* to open the **bottom: Cookie**
    console. Then, type in *cookie list [enter]* to bring up cookies for the current
    page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To complete our hack, we’ll click on the `JSESSIONID` cookie that we copied
    to the clipboard from Google Chrome, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Cookies hack in Firefox](img/B21757_14_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Cookies hack in Firefox
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that newer versions of Firefox include web developer tools, too.
    However, you will need to ensure that you are using the extension and not the
    built-in one, as it provides additional capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our session fixation hack is complete! If you now reload the page in Firefox,
    you will see that you are logged in as the same user who was logged in using Google
    Chrome, but without the knowledge of the username and password. Are you scared
    of malicious users yet?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, re-enable session fixation protection and try this exercise again. You’ll
    see that, in this case, the `JSESSIONID` changes after the user logs in. Based
    on our understanding of how session fixation attacks occur, this means that we
    have reduced the likelihood of an unsuspecting user falling victim to this type
    of attack. Excellent job!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cautious developers should note that there are many methods of stealing session
    cookies, some of which—such as `XSS`—may make even session fixation-protected
    sites vulnerable. Please consult the OWASP site for additional resources on preventing
    these types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the session-fixation-protection options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `session-fixation-protection` attribute has the following three options
    that allow you to alter its behavior; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `none()` | This option disables session fixation protection and (unless other
    `sessionManagement()` attributes are non-default) does not configure `SessionManagementFilter`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `migrateSession()` | When the user is authenticated and a new session is
    allocated, it ensures that all attributes of the old session are moved to the
    new session. |'
  prefs: []
  type: TYPE_TB
- en: '| `newSession()` | When the user is authenticated, a new session is created
    and no attributes from the old (unauthenticated) session will be migrated. |'
  prefs: []
  type: TYPE_TB
- en: Table 14.1 – session-fixation-protection options
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the default behavior of `migrateSession()` will be appropriate
    for sites that wish to retain important attributes of the user’s session (such
    as click interest and shopping carts) after the user has been authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the number of concurrent sessions per user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the software industry, software is often sold on a per-user basis. This means
    that, as software developers, we have an interest in ensuring that only a single
    session per user exists, to combat the sharing of accounts. Spring Security’s
    concurrent session control ensures that a single user cannot have more than a
    fixed number of active sessions simultaneously (typically one). Ensuring that
    this maximum limit is enforced involves several components working in tandem to
    accurately track changes in user session activity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s configure the feature, review how it works, and then test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring concurrent session control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have understood the different components involved in concurrent
    session control, setting it up should make much more sense. Let’s take a look
    at the following steps to configure concurrent session control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you update your `SecurityConfig.java` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to enable `o.s.s.web.session.HttpSessionEventPublisher` in the
    `SecurityConfig.java` deployment descriptor so that the servlet container will
    notify Spring Security (through `HttpSessionEventPublisher`) of session life cycle
    events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these two configuration bits in place, concurrent session control will
    now be activated. Let’s see what it actually does, and then we’ll demonstrate
    how it can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding concurrent session control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent session control uses `o.s.s.core.session.SessionRegistry` to maintain
    a list of active HTTP sessions and the authenticated users with which they are
    associated. As sessions are created and expired, the registry is updated in real
    time based on the session life cycle events published by `HttpSessionEventPublisher`
    to track the number of active sessions per authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Concurrent session control](img/B21757_14_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Concurrent session control
  prefs: []
  type: TYPE_NORMAL
- en: An extension of `SessionAuthenticationStrategy`, `o.s.s.web.authentication.session.ConcurrentSessionControlStrategy`
    is the method by which new sessions are tracked and the method by which concurrency
    control is actually enforced. Each time a user accesses the secured site, `SessionManagementFilter`
    is used to check the active session against `SessionRegistry`. If the user’s active
    session isn’t in the list of active sessions tracked in `SessionRegistry`, the
    least recently used session is immediately expired.
  prefs: []
  type: TYPE_NORMAL
- en: The secondary actor in the modified concurrent session control filter chain
    is `o.s.s.web.session.ConcurrentSessionFilter`. This filter will recognize expired
    sessions (typically, sessions that have been expired either by the servlet container
    or forcibly by the `ConcurrentSessionControlStrategy` interface) and notify the
    user that their session has expired.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood how concurrent session control works, it should
    be easy for us to reproduce a scenario in which it is enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrent session control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did when verifying session fixation protection, we will need to access
    two web browsers by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Google Chrome, log in to the site as `user1@example.com/user1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in Firefox, log in to the site as the same user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, go back to Google Chrome and take any action. You will see a message
    indicating that your session has expired, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Testing concurrent session control](img/B21757_14_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Testing concurrent session control
  prefs: []
  type: TYPE_NORMAL
- en: If you were using this application and received this message, you’d probably
    be confused. This is because it’s obviously not a friendly method of being notified
    that only a single user can access the application at a time. However, it does
    illustrate that the session has been forcibly expired by the software.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent session control tends to be a very difficult concept for new Spring
    Security users to grasp. Many users try to implement it without truly understanding
    how it works and what the benefits are. If you’re trying to enable this powerful
    feature and it doesn’t seem to be working as you expect, make sure you have everything
    configured correctly, and then review the theoretical explanations in this section—hopefully,
    they will help you understand what may be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When a session expiration event occurs, we should probably redirect the user
    to the login page and provide them with a message to indicate what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring expired session redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, there is a simple method for directing users to a friendly page
    (typically the login page) when they are flagged by concurrent session control—simply
    specify the `expired-url` attribute and set it to a valid page in your application.
    Update your `SecurityConfig.java` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our application, this will redirect the user to the standard
    login form. We will then use the query parameter to display a friendly message,
    indicating that we determined that they had multiple active sessions and should
    log in again. Update your `login.xhtml` page to use this parameter to display
    our message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and give it a try by logging in as the user `admin1@example.com/admin1`
    using both Google Chrome and Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, you should see a login page with a custom error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – A concurrent session login page custom error message](img/B21757_14_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – A concurrent session login page custom error message
  prefs: []
  type: TYPE_NORMAL
- en: After setting up redirection for expired sessions, we’ll delve into typical
    challenges associated with concurrency control.
  prefs: []
  type: TYPE_NORMAL
- en: Common problems with concurrency control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few common reasons that logging in with the same user does not trigger
    a logout event. The first occurs when using the custom `UserDetails` (as we did
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*) while
    the equals and `hashCode` methods are not properly implemented. This occurs because
    the default `SessionRegistry` implementation uses an in-memory map to store `UserDetails`.
    In order to resolve this, you must ensure that you have properly implemented the
    `hashCode` and equals methods.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem occurs when restarting the application container while the
    user sessions are persisted to a disk. When the container has started back up,
    the users who were already logged in with a valid session are logged in. However,
    the in-memory map of `SessionRegistry` that is used to determine if the user is
    already logged in will be empty. This means that Spring Security will report that
    the user is not logged in, even though the user is. To solve this problem, either
    a custom `SessionRegistry` is required along with disabling session persistence
    within the container, or you must implement a container-specific way to ensure
    that the persisted sessions get populated into the in-memory map at startup.
  prefs: []
  type: TYPE_NORMAL
- en: The last common reason we will cover is that concurrency control will not work
    in a clustered environment with the default `SessionRegistry` implementation.
    The default implementation uses an in-memory map. This means that if `user1` logs
    in to `application server A`, the fact that they are logged in will be associated
    with that server. Thus, if `user1` then authenticates to `Application Server B`,
    the previously associated authentication will be unknown to `Application` `Server
    B`.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing authentication instead of forcing logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Security can also prevent a user from being able to log in to the application
    if the user already has a session. This means that instead of forcing the original
    user to log out, Spring Security will prevent the second user from being able
    to log in. The configuration changes can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the updates and log in to the calendar application with Google Chrome.
    Now, attempt to log in to the calendar application with Firefox using the same
    user. You should see our custom error message from our `login.xhtml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – A custom error message preventing authentication for concurrent
    sessions](img/B21757_14_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – A custom error message preventing authentication for concurrent
    sessions
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a disadvantage to this approach that may not be apparent without some
    thought. Try closing Google Chrome without logging out and then opening it up
    again. Now, attempt to log in to the application again. You will observe that
    you are unable to log in. This is because when the browser is closed, the `JSESSIONID`
    cookie is deleted. However, the application is not aware of this, so the user
    is still considered authenticated. You can think of this as a kind of memory leak,
    since `HttpSession` still exists but there is no pointer to it (the `JSESSIONID`
    cookie is gone). It is not until the session times out that our user will be able
    to authenticate again. Thankfully, once the session times out, our `SessionEventPublisher`
    interface will remove the user from our `SessionRegistry` interface. What we can
    take away from this is that if a user forgets to log out and closes the browser,
    they will not be able to log in to the application until the session times out.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Just as in [*Chapter 7*](B21757_07.xhtml#_idTextAnchor220), *Remember-**m**e
    Services*, this experiment may not work if the browser decides to remember a session
    even after the browser is closed. Typically, this will happen if a plugin or the
    browser is configured to restore sessions. In this event, you might want to delete
    the `JSESSIONID` cookie manually to simulate the browser being closed.
  prefs: []
  type: TYPE_NORMAL
- en: Other benefits of concurrent session control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another benefit of concurrent session control is that `SessionRegistry` exists
    to track active (and, optionally, expired) sessions. This means that we can get
    runtime information about what user activity exists in our system (for authenticated
    users, at least) by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even do this if you don’t want to enable concurrent session control.
    Simply set `maximumSessions` to `-1`, and session tracking will remain enabled,
    even though no maximum will be enforced. Instead, we will use the explicit bean
    configuration provided in the `SessionConfig.java` file of this chapter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already added the import of the `SessionConfig.java` file to the `SecurityConfig.java`
    file. So, all that we need to do is reference the custom configuration in our
    `SecurityConfig.java` file. Go ahead and replace the current `sessionManagement`
    and `maximumSessions` configurations with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our application will allow an unlimited number of authentications for the
    same user. However, we can use `SessionRegistry` to forcibly log out the users.
    Let’s see how we can use this information to enhance the security of our users.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying active sessions for a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve probably seen how many websites allow a user to view and forcibly log
    out sessions for their account. We can easily use this forcible logout functionality
    to do the same. We have already provided `UserSessionController`, which obtains
    the active sessions for the currently logged-in user. You can see the implementation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our sessions method will use a Spring `Authentication`. If we were not using
    a Spring MVC, we could also get the current `Authentication` from `SecurityContextHolder`,
    as discussed in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*.
    The principal is then used to obtain all the `SessionInformation` objects for
    the current user. The information is easily displayed by iterating over the `SessionInformation`
    objects in our `sessions.xhtml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now safely start the JBCP calendar application and log in to it using
    `user1@example.com/user1` in Google Chrome. Now, log in using Firefox and click
    on the `user1@example.com` link in the upper-right corner. You will then see both
    sessions listed on the display, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9 – A list of available sessions](img/B21757_14_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – A list of available sessions
  prefs: []
  type: TYPE_NORMAL
- en: While in Firefox, click on the `deleteSession` method of `UserSessionsController`.
    This indicates that the session should be terminated. Now, navigate to any page
    within Google Chrome. You will see the custom message saying that the session
    has been forcibly terminated. While the message could use updating, we see that
    this is a nice feature for users to terminate other active sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Other possible uses include allowing an administrator to list and manage all
    active sessions, displaying the number of active users on the site, or even extending
    the information to include things like an IP address or location information.
  prefs: []
  type: TYPE_NORMAL
- en: How Spring Security use the HttpSession method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already discussed how Spring Security uses `SecurityContextHolder`
    to determine the currently logged-in user. However, we have not explained how
    `SecurityContextHolder` gets automatically populated by Spring Security. The secret
    to this lies in the `o.s.s.web.context.SecurityContextPersistenceFilter` filter
    and the `o.s.s.web.context.SecurityContextRepository` interface. Let’s take a
    look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Spring Security usage of the HttpSession](img/B21757_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Spring Security usage of the HttpSession
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an explanation for each step shown in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of each web request, `SecurityContextPersistenceFilter` is
    responsible for obtaining the current `SecurityContext` implementation using `SecurityContextRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately afterward, `SecurityContextPersistenceFilter` sets `SecurityContext`
    on `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the remainder of the web request, `SecurityContext` is available via `SecurityContextHolder`.
    For example, if a Spring MVC controller or `CalendarService` wanted to access
    `SecurityContext`, it could use `SecurityContextHolder` to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, at the end of each request, `SecurityContextPersistenceFilter` gets the
    `SecurityContext` from `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately afterward, `SecurityContextPersistenceFilter` saves `SecurityContext`
    in `SecurityContextRepository`. This ensures that if `SecurityContext` is updated
    at any point during the web requests (that is, when a user creates a new account,
    as done in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*),
    `SecurityContext` is saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, `SecurityContextPersistenceFilter` clears `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The question that now arises: How is this related to `HttpSession`? This is
    all tied together by the default `SecurityContextRepository` implementation, which
    uses `HttpSession`.'
  prefs: []
  type: TYPE_NORMAL
- en: The HttpSessionSecurityContextRepository interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default implementation of `SecurityContextRepository`, `o.s.s.web.context.HttpSessionSecurityContextRepository`,
    uses `HttpSession` to retrieve and store the current `SecurityContext` implementation.
    There are no other `SecurityContextRepository` implementations provided out of
    the box. However, since the usage of `HttpSession` is abstracted behind the `SecurityContextRepository`
    interface, we could easily write our own implementation if we desired.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring how Spring Security uses HttpSession
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Security has the ability to configure when the session is created by
    Spring Security. This can be done with the `http` element’s `create-session` attribute.
    A summary of the options can be seen in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ifRequired` | Spring Security will create a session only if one is required
    (the default value). |'
  prefs: []
  type: TYPE_TB
- en: '| `always` | Spring Security will proactively create a session if one does
    not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `never` | Spring Security will never create a session but will make use of
    one if the application does create it. This means that if there is a `HttpSession`
    method, `SecurityContext` will be persisted or retrieve from it. |'
  prefs: []
  type: TYPE_TB
- en: '| `stateless` | Spring Security will not create a session and will ignore the
    session for obtaining a Spring `Authentication`. In such instances, `NullSecurityContextRepository`
    is used, which will always state that the current `SecurityContext` is `null`.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 14.2 – The session-fixation-protection options
  prefs: []
  type: TYPE_NORMAL
- en: In practice, controlling session creation can be more difficult than it first
    appears. This is because the attributes only control a subset of Spring Security’s
    usage of `HttpSession`. It does not apply to any other components, such as `HttpSession`
    method was created, we can add Spring Security’s `DebugFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Spring Security’s DebugFilter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps and learn about how to debug with
    `DebugFilter` of Spring Security:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `SecurityConfig.java` file to have a session policy of `NEVER`.
    Also, add the `debug` flag to `true` on the `@EnableWebSecurity` annotation so
    that we can track when the session was created. The updates can be seen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you start up the application, you should see something similar to the
    following code written to standard output. If you have not already, ensure that
    you have logging enabled across all levels of the Spring Security debugger category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, clear out your cookies (this can be done in Firefox with *Shift + Ctrl
    + Delete*), start up the application, and navigate directly to `http://localhost:8080`.
    When we look at the cookies, as we did earlier in the chapter, we can see that
    `JSESSIONID` is created even though we stated that Spring Security should never
    create `HttpSession`. Look at the logs again, and you will see a call stack of
    the code that created `HttpSession` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are several other uses for `DebugFilter`, which we encourage you to explore
    on your own, for example, determining when a request will match a particular URL,
    which Spring Security filters are being invoked, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should be familiar with how Spring Security
    manages sessions and protects against session fixation attacks. We also know how
    to use Spring Security’s concurrency control to prevent the same user from being
    authenticated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the utilization of concurrency control to allow a user to terminate
    sessions associated with their account. Also, we saw how to configure Spring Security’s
    creation of sessions. We also covered how to use Spring Security’s `DebugFilter`
    filter to troubleshoot issues related to Spring.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about security, including determining when a `HttpSession` method
    was created and the cause of it.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion about Spring Security’s session management. In
    the next chapter, we will discuss some specifics about integrating Spring Security
    with other frameworks.
  prefs: []
  type: TYPE_NORMAL
