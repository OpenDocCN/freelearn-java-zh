["```java\nmvn archetype:generate \\\n  -DarchetypeGroupId=de.rieckpil.archetypes  \\\n  -DarchetypeArtifactId=testing-toolkit \\\n  -DarchetypeVersion=1.0.0 \\\n  -DgroupId=dev.davivieira \\\n  -DartifactId=application \\\n  -Dversion=1.0-SNAPSHOT \\\n  -Dpackage=dev.davivieira.topologyinventory.application \\\n  -DinteractiveMode=false\n```", "```java\n$ cd topology-inventory\n$ mvn archetype:generate ...\n```", "```java\n<modules>\n    <module>domain</module>\n    <module>application</module>\n</modules>\n```", "```java\nmodule application {\n    requires domain;\n    requires static lombok;\n}\n```", "```java\n<dependency>\n    groupId>dev.davivieira</groupId>\n    <artifactId>domain</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <scope>compile</scope>\n</dependency>\n```", "```java\n<dependency>\n    <groupId>io.cucumber</groupId>\n    <artifactId>cucumber-java</artifactId>\n    <version>6.10.4</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>io.cucumber</groupId>\n    <artifactId>cucumber-junit</artifactId>\n    <version>6.10.4</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>io.cucumber</groupId>\n    <artifactId>cucumber-picocontainer</artifactId>\n    <version>6.10.4</version>\n    <scope>test</scope>\n</dependency>\n```", "```java\n@RouterAdd\nFeature: Can I add an edge router to a core router?\n  Scenario: Adding an edge router to a core router\n    Given I have an edge router\n    And I have a core router\n    Then I add an edge router to a core router\n  Scenario: Adding a core router to another core router\n    Given I have a core router\n    And I have another core router\n    Then I add this core router to the core router\n```", "```java\n@RouterCreate\nFeature: Can I create a new router?\n  Scenario: Creating a new core router\n    Given I provide all required data to create a core\n          router\n    Then A new core router is created\n  Scenario: Creating a new edge router\n    Given I provide all required data to create an edge\n      router\n    Then A new edge router is created\n```", "```java\n@RouterRemove\nFeature: Can I remove routers?\n  Scenario: Removing an edge router from a core router\n    Given The core router has at least one edge\n          router connected to it\n    And The switch has no networks attached to it\n    And The edge router has no switches attached to it\n    Then I remove the edge router from the core router\n  Scenario: Removing a core router from another core router\n    Given The core router has at least one core router\n          connected to it\n    And The core router has no other routers connected to\n        it\n    Then I remove the core router from another core router\n```", "```java\npackage dev.davivieira.topologyinventory.\n  application.usecases;\nimport dev.davivieira.topologyinventory.domain.\n  entity.CoreRouter;\nimport dev.davivieira.topologyinventory.domain.\n  entity.Router;\nimport dev.davivieira.topologyinventory.domain.vo.IP;\nimport dev.davivieira.topologyinventory.domain.vo.Id;\nimport dev.davivieira.topologyinventory.domain.vo.Location;\nimport dev.davivieira.topologyinventory.domain.vo.Model;\nimport dev.davivieira.topologyinventory.domain.\n  vo.RouterType;\nimport dev.davivieira.topologyinventory.domain.vo.Vendor;\npublic interface RouterManagementUseCase {\n    Router createRouter(\n            Vendor vendor,\n            Model model,\n            IP ip,\n            Location location,\n            RouterType routerType);\n    CoreRouter addRouterToCoreRouter(\n            Router router, CoreRouter coreRouter);\n    Router removeRouterFromCoreRouter(\n            Router router, CoreRouter coreRouter);\n    Router retrieveRouter(Id id);\n    Router persistRouter(Router router);\n}\n```", "```java\n@SwitchAdd\nFeature: Can I add a switch to an edge router?\n  Scenario: Adding a switch to an edge router\n    Given I provide a switch\n    Then I add the switch to the edge router\n```", "```java\n@SwitchCreate\nFeature: Can I create new switches?\n  Scenario: Creating a new switch\n    Given I provide all required data to create a switch\n    RouterCreate.feature file, in the sense that if we provide all the required data, a new Switch object is created.\nFinally, we create the `SwitchRemove.feature` file:\n\n```", "```java\n\n So, to remove a switch from an edge router, we have to make sure the switch has no networks connected to it. This is what the preceding scenario asserts.\nNow, let’s define the use case interface for switch management, based on the Cucumber scenarios we just created.\nDefining the use case interface for switch management\nAs we did with routers, we will do the same for switches by creating a use case interface to define the switch management operations, based on the written descriptions we made previously in our Cucumber feature files:\n\n```", "```java\n\n The `createSwitch`, `addSwitchToEdgeRouter`, and `removeSwitchFromEdgeRouter` methods correspond to the Cucumber `SwitchCreate.feature`, `SwitchAdd.feature`, and `SwitchRemove.feature` feature files, respectively. The `createSwitch` method receives all the required parameters to construct a `Switch` object. Both the `addSwitchToEdgeRouter` and `removeSwitchFromEdgeRouter` methods receive a switch and an edge router as parameters, and both methods return `EdgeRouter`.\nTo finish the definition of use cases, we still need to create the Cucumber feature files and interfaces for networks. Let’s do that!\nCreating written descriptions for network management use cases\nFor networks, we will continue to follow the same pattern of the add, create, and remove operations previously used on routers and switches. Let’s start with the `NetworkAdd.feature` file:\n\n```", "```java\n\n This is a simple scenario to ensure that we’re able to add networks to a switch.\nFollowing the addition of networks, we have the `NetworkCreate.feature` file:\n\n```", "```java\n\n For network creation, as we did with routers and switches, we make sure that all required data is properly provided so that a new network is created.\nFinally, we have the `NetworkRemove.feature` file:\n\n```", "```java\n\n It follows the same structure as the adding scenario but checks the system’s capability to remove networks from a switch.\nNow that we have Cucumber scenarios for network management, let’s define a use case interface to perform such scenarios.\nDefining the use case interface for network management\nThe `NetworkManagementUseCase` interface follows the same structure as previously defined interfaces, where we declared methods for creation, addition, and removal operations:\n\n```", "```java\n\n Here, again, we declare the `createNetwork`, `addNetworkToSwitch`, and `removeNetworkFromSwitch` methods based on the written descriptions from the Cucumber feature files. These three method declarations in the `NetworkManagementUseCase` interface represent the first step in implementing the capabilities that will allow us to manage networks, as described in the scenarios we created using Cucumber.\nIn this section, we learned about an approach to start use case development by first describing the behaviors and scenarios expected from the system. Once the scenarios were thoroughly explored, we then utilized them as a reference to define the use case interfaces that will allow the system to perform the behaviors described in the scenarios.\nNow that we have all the use case interfaces to manage routers, switches, and networks, we can provide an input port implementation for each of these use case interfaces.\nImplementing use cases with input ports\nInput ports are a central element of the Application hexagon. They play a crucial integration role because it is through them that we bridge the gap between the Domain and Framework hexagons. We can get external data from an output port and forward that data to the Domain hexagon by using output ports. Once the Domain hexagon’s business logic is applied to the data, the Application hexagon moves that data downstream until it reaches one of the output adapters in the Framework hexagon.\nWhen creating the Application hexagon, you’re able to define output port interfaces, but because there is no Framework hexagon yet to provide an output adapter as an implementation, you’re not able to use these output ports.\nYou’ll see output port declarations in the following code, but they are not being used yet. We’re just preparing the Application hexagon to work when we have the Framework hexagon to provide the implementations.\nThe following steps will help us to implement use cases with input ports:\n\n1.  We start by creating a `RouterManagementOutputPort` field in the `RouterManagementInputPort` class:\n\n    ```", "```java\n\n    We created this `RouterManagementOutputPort` interface field because we don’t want to depend directly on its implementation. Remember, output adapters implement output ports.\n\n     2.  Next, we implement the `createRouter` method:\n\n    ```", "```java\n\n    With the `createRouter` method, we’ll receive all the required parameters to construct a `Router` object. Object creation is delegated to the `getRouter` method from the `RouterFactory` class.\n\n     3.  Next, we implement the `retrieveRouter` method:\n\n    ```", "```java\n\n    It’s a very straightforward method that uses `Id` to obtain the `Router` objects, using the `retrieveRouter` method from the `RouterManagementOutputPort` output port.\n\n     4.  Next, we implement the `persistRouter` method:\n\n    ```", "```java\n\n    To persist a router, we need to pass the `Router` object we want to persist. This method is generally used after any operation that creates new `Router` objects or causes changes in existing ones.\n\n     5.  Next, we implement the `addRouterToCoreRouter` method:\n\n    ```", "```java\n\n    To add `Router` to `CoreRouter`, we call the `addRouter` method from `CoreRouter`. We’re not persisting `Router` because we don’t have an adapter to allow us to do that. So, we just return the added `Router` object.\n\n     6.  Finally, we implement `removeRouterFromCoreRouter`:\n\n    ```", "```java\n\n    Again, we use one of the methods present in the `CoreRoute` class. Here, we call the `removeRouter` method to remove `Router` from `CoreRouter`. Then, we return `removedRouter`, instead of actually removing it from an external data source.\n\nThe first method we implemented, `createRouter`, can produce either core or edge routers. To accomplish this, we need to provide a factory method directly in the Domain hexagon, in a class called `RouterFactory`. The following is how we implement this `getRouter` factory method:\n\n```", "```java\n\n The `RouterType` parameter, which we pass to the `getRouter` method, has only two possible values – `CORE` and `EDGE`. The switch looks into one of these two values to determine which `builder` method to use. If `RouterType` is `CORE`, then the `builder` method from `CoreRouter` is called. Otherwise, the `builder` method from `EdgeRouter` is used, as we can see here:\n\n```", "```java\n\n If neither `CORE` nor `EDGE` is informed, the default behavior is to throw an exception saying that no valid router type was informed.\nLet’s implement the `SwitchManagementUseCase` interface with `SwitchManagementInputPort`:\n\n1.  We will start by implementing the `createSwitch` method:\n\n    ```", "```java\n\n    For the `createSwitch` method, we don’t need a factory method to create objects because there are no `Switch` object variations as compared to routers. Instead, we generate `Switch` objects, using the `builder` method directly from the `Switch` class.\n\n     2.  Next, we implement the `addSwitchToEdgeRouter` method:\n\n    ```", "```java\n\n    Then, we have `addSwitchToEdgeRouter`, which receives `Switch` and `EdgeRouter` as parameters, to add switches to an edge router. There is no way to persist switches without persisting routers as well. That’s why we did not put a persistence method here. By doing that, we enforce all switch persistence operations to occur only when we persist routers.\n\n    Remember that `Router` is an aggregate (a cluster of domain objects) that controls the life cycle of other entities and value objects, including `Switch`-type objects.\n\n     3.  Finally, we implement the `removeSwitchFromEdgeRouter` method:\n\n    ```", "```java\n\n    The last method, `removeSwitchFromEdgeRouter`, receives the same parameters, `Switch` and `EdgeRouter`, and removes switches from edge routers using the `removeSwitch` method present in an `EdgeRouter` instance.\n\nNow, let’s see how we can implement the `NetworkManagementUseCase` interface with `NetworkManagementInputPort`:\n\n1.  We start by implementing the `createNetwork` method:\n\n    ```", "```java\n\n    To create a new network, we use all the received method parameters in conjunction with the `builder` method from the `Network` class.\n\n     2.  Next, we implement `addNetworkToSwitch`:\n\n    ```", "```java\n\n    Here, we receive the `Network` and `Switch` objects. Then, we call the `addNetworkToSwitch` method on `Switch` by passing the `Network` object as a parameter. Then, we return a `Switch` object with the added `Network` object.\n\n     3.  Finally, we implement the `removeNetworkFromSwitch` method:\n\n    ```", "```java\n\n    We receive the `Network` and `Switch` objects as parameters, like in the `addNetworkToSwitch` method. However, to remove the network from a switch, we call `removeNetworkFromSwitch` from the `Switch` object.\n\nThat completes implementing input ports for router, switch, and network management. To ensure everything works as expected, let’s create Cucumber tests based on the written use case descriptions and the input ports we just created.\nTesting the Application hexagon\nAn interesting and useful thing about Cucumber is that we can use the written scenario description provided in the feature file to tailor unit tests. In addition, these written scenarios provide an easy way to understand and implement the hexagonal system’s use cases. We’re also laying the groundwork for the development of unit tests in the Application hexagon.\nSo, the tests we’re about to build in this section are a continuation of the written scenario descriptions we created for the router, switch, and network management operations. Our goal here is to test input port implementations to ensure these ports work as expected when input adapters call them.\nTo get started, we need to create the `ApplicationTest` test class to enable Cucumber:\n\n```", "```java\n\n The important part is the `@RunWith` annotation, which triggers the initialization of the Cucumber engine.\nLet’s start by creating tests to check whether the system is capable of adding routers.\nIn the same way that we created a `RouterAdd.feature` file, we’ll create its counterpart as a `RouterAdd.java` test class. The location for both files will resemble the following:\n\n*   `src/test/java/dev/davivieira/topologyinventory/application/RouterAdd.java`\n*   `src/test/resources/dev/davivieira/topologyinventory/application/routers/RouterAdd.feature`\n\nThe following steps walk you through adding an edge router to a core router:\n\n1.  The first step is to get an edge router:\n\n    ```", "```java\n\n    Here, we use the `createRouter` method from `RouterManagementUseCase` to create edge router objects. We need to cast the returned object to an `EdgeRouter` type because the `createRouter` method returns `Router`. Then, to make sure that we received a proper router object, we call `assertNotNull` on `edgeRouter`.\n\n     2.  Now that we have `EdgeRouter`, we need to create `CoreRouter` by using the `createRouter` method again:\n\n    ```", "```java\n\n    This code follows the exact same pattern as the first step. The only difference is that we pass `CORE` as `RouterType` to the `createRouter` method from `RouterManagementUseCase`.\n\n     3.  With these two objects, `EdgeRouter` and `CoreRouter`, we can now test adding the former to the latter:\n\n    ```", "```java\n\n    The `addRouterToCoreRouter` method receives `EdgeRouter` and `CoreRouter` as parameters. At the end of the method, we compare the actual and expected edge router IDs to confirm whether the edge router has been added correctly to the core router.\n\nTo test the execution of the Cucumber scenario steps from `RouterAdd.feature`, we have to run the following Maven command:\n\n```", "```java\n\n The output will be similar to the one shown here:\n\n```", "```java\n\n The Cucumber test passes through the testing methods in the `RouterAdd.java` file in the same order as they were declared in the `RouterAdd.feature` file.\nNow, let’s see how we can implement the `RouterCreate.java` test class for the `RouterCreate.feature` file. Their file locations will resemble the following:\n\n*   `RouterCreate.java` file: `src/test/java/dev/davivieira/topologyinventory/application/RouterCreate.java`\n*   `RouterCreate.feature` file: `src/test/resources/dev/davivieira/topologyinventory/application/routers/RouterCreate.feature`\n\nThe following scenario steps walk through creating a new core router in the system:\n\n1.  The first step is to create a new core router:\n\n    ```", "```java\n\n    We provide all the required data to the `createRouter` method from `RouterManagementUseCase` in order to create the new core router.\n\n     2.  Then, we proceed to confirm whether the router created was indeed a core router:\n\n    ```", "```java\n\n    The first assertion checks whether we received a null pointer. The second assertion looks into the router’s type to confirm that it’s a core router.\n\nThe following scenario steps involve checking whether we can simply create an edge router by using the `createRouter` method from `RouterManagementUseCase`:\n\n1.  First, we create an edge router:\n\n    ```", "```java\n\n    We follow the same procedure for creating the core router objects, but now, we set the `EDGE` parameter as `RouterType` for object creation.\n\n     2.  In the last scenario step, we just execute the assertions:\n\n    ```", "```java\n\n    The first assertion checks with the `assertNotNull` method whether the router reference is not `null`. Then, it proceeds by executing `assertEquals` to check whether the router created is `EdgeRouter`.\n\nTo run the tests related to the creation of routers, we will execute the following Maven command in the project root directory:\n\n```", "```java\n\n The test result should contain the following output:\n\n```", "```java\n\n Now that we’re done with the scenario to create routers, let’s see how to implement the `RouterRemove.java` test class for the `RouterRemove.feature` file. The file locations are as follows:\n\n*   `src/test/java/dev/davivieira/topologyinventory/application/RouterRemove.java`\n*   `src/test/resources/dev/davivieira/topologyinventory/application/routers/RouterRemove.feature`\n\nWe have to create the methods to test a scenario where we want to remove an edge router from a core router:\n\n1.  To get started, we first need to know whether the core router we are working with has at least an edge router connected to it:\n\n    ```", "```java\n\n    From a core router, we search for an edge router connected to it. Then, we store the returned edge router in the `edgeRouter` variable. Following that, we assert the type of router to confirm whether we have an edge router.\n\n     2.  Next, we have to check that there are no networks attached to the switch connected to the edge router. We have to check this; otherwise, we will not be able to remove the switch from the edge router:\n\n    ```", "```java\n\n    To assert a switch has no networks connected to it, we first check the size of the networks on the switch. It should return `1`. Then, we remove the network and check the size again. It should return `0`.\n\n    We must ensure that the switch has no networks attached to it to make that switch eligible for removal.\n\n     3.  Next, we can proceed to check that there are no switches connected to the edge router:\n\n    ```", "```java\n\n    Here, we remove the switch using the `removeSwitch` method, followed by an assertion to confirm that the edge router has no more switches connected.\n\n     4.  Now, we can test the removal of the edge router from the core router:\n\n    ```", "```java\n\n    To test the removal of an edge router from the core router, we first get the edge router ID of the router we intend to remove. We store this ID in the `actualID` variable. Then, we proceed to the actual removal. The `removeRouterFromCoreRouter` method returns the removed router. So, we can use the removed router ID, stored in the `expectedID` variable, to check with the `assertEquals` method whether the router was really removed.\n\nTo confirm the tests related to router removal are working, we execute the Maven test goal in the project root directory:\n\n```", "```java\n\n The results you get after executing the tests should be similar to the following output:\n\n```", "```java\n\n The preceding output provides the execution details of the four testing methods involved in removing the edge router from the core router.\nWe have completed the testing part of router management. For switch and network management, we follow the same ideas. In the book’s GitHub repository, you can access the topology and inventory code with all its tests.\nSummary\nIn this chapter, on top of the Domain hexagon, we built the Application hexagon with use cases and ports. For use cases, we heavily relied on a behavior-driven development tool called Cucumber. With Cucumber, we can express use cases supported by the system not only in code terms but also in written text.\nWe started by creating Cucumber feature files containing the use case written descriptions, and then we used them as a reference to create use case interfaces. These interfaces were then implemented by input ports that provided a concrete way to achieve the use case goals. Finally, we built use case tests, based again on the written description provided by Cucumber.\nBy implementing and testing the Application hexagon in this way, we leveraged the special capabilities of Cucumber to express the system’s behavior in a declarative and straightforward form, and we used these same capabilities to implement and test the entire Application hexagon.\nOn top of the Application hexagon and the features it provides, we need to decide how such features will be exposed. Also, some of these require access to external data sources. We’ll address all these concerns by developing the Framework hexagon in the next chapter.\nQuestions\n\n1.  What do we call files where we declare Cucumber scenarios?\n2.  On which other Java module does the Application hexagon depend?\n3.  Which hexagonal architecture component is used to implement use cases?\n\nAnswers\n\n1.  They are called feature files.\n2.  It depends on the Domain hexagon Java module.\n3.  Input ports are utilized to implement use cases.\n\n```"]