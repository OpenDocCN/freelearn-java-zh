<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Date Calculator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you've been developing in Java for any serious length of time, you know one thing to be true--working with dates is awful. The <kbd class="calibre16">java.util.Date</kbd> class, with its related classes, shipped with 1.0, and <kbd class="calibre16">Calendar</kbd> and its related classes coming along in 1.1. Even early on, problems were apparent. For example, the Javadoc on <kbd class="calibre16">Date</kbd> says this--<em class="calibre20">Unfortunately, the API for these functions was not amenable to internationalization</em>. As a result, <kbd class="calibre16">Calendar</kbd> was introduced in 1.1. Sure, there have been other enhancements down through the years, but given Java's strict adherence to backwards compatibility, there's only so much the language architects can do. As much as they may want to fix those APIs, their hands are tied.</p>
<p class="mce-root">Fortunately, <strong class="calibre8">Java Specification Request</strong> (<strong class="calibre8">JSR 310</strong>) was filed. Led by Stephen Colebourne, an effort was begun to create a new API, based on the very popular open source library, Joda-Time. In this chapter, we'll take an in-depth look at this new API, then build a simple command-line utility to perform date and time math, which will give us an opportunity to see some of this API in action.</p>
<p class="mce-root">This chapter, then, will be covering the following topics:</p>
<ul class="calibre13">
<li class="calibre14">The Java 8 Date/Time API</li>
<li class="calibre14">Revisiting command-line utilities</li>
<li class="calibre14">Text parsing</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Like the project in <a href="bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 18</a>, <em class="calibre20">Managing Processes in Java</em>, this project is fairly simple, conceptually. The end goal is a command-line utility to perform various date and time calculations. However, while we're at it, it would be very nice if the actual date/time work were to be put in a reusable library, so that's what we'll do. This leaves us with two projects, which we'll set up, like last time, as a multi-module Maven project.</p>
<p class="mce-root">The parent POM will look something like this:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;project <br class="calibre2"/>      <br class="calibre2"/>      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0<br class="calibre2"/>      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 

      &lt;artifactId&gt;datecalc-master&lt;/artifactId&gt; 
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
      &lt;packaging&gt;pom&lt;/packaging&gt; 
      &lt;modules&gt; 
        &lt;module&gt;datecalc-lib&lt;/module&gt; 
        &lt;module&gt;datecalc-cli&lt;/module&gt; 
      &lt;/modules&gt; 
    &lt;/project&gt; </pre>
<p class="mce-root">If you read <a href="bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 18</a>, <em class="calibre20">Managing Processes in Java</em>, or have worked with multi-module Maven builds before, there's nothing new here. It's included simply for completeness. If this is foreign to you, take a moment to review the first few pages of Chapter 18 before continuing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the library</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Since we'd like to be able to reuse this tool in other projects, we'll start by building a library that exposes its functionality. All of the functionality we'll need is built into the platform, so our POM file is very simple:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;project <br class="calibre2"/>       <br class="calibre2"/>      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0<br class="calibre2"/>      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
      &lt;parent&gt; 
        &lt;groupId&gt;com.steeplesoft&lt;/groupId&gt; 
          &lt;artifactId&gt;datecalc-master&lt;/artifactId&gt; 
          &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
      &lt;/parent&gt; 
      &lt;artifactId&gt;datecalc-lib&lt;/artifactId&gt; 
      &lt;packaging&gt;jar&lt;/packaging&gt; 
      &lt;dependencies&gt; 
        &lt;dependency&gt; 
          &lt;groupId&gt;org.testng&lt;/groupId&gt; 
          &lt;artifactId&gt;testng&lt;/artifactId&gt; 
          &lt;version&gt;6.9.9&lt;/version&gt; 
          &lt;scope&gt;test&lt;/scope&gt; 
        &lt;/dependency&gt; 
      &lt;/dependencies&gt; 
    &lt;/project&gt; </pre>
<p class="mce-root">There are <strong class="calibre8">almost</strong> no external dependencies. The only dependency listed is on the testing library, TestNG. We didn't talk much about testing in the last chapter (rest assured, there are tests in the project). In this chapter, we'll introduce the topic of testing and show some examples.</p>
<p class="mce-root">Now we need to define our module. Remember that these are Java 9 projects, so we want to make use of the module functionality to help protect our internal classes from accidental public exposure. Our module is very simple. We need to give it a name, then export our public API package, as follows:</p>
<pre class="calibre21">    module datecalc.lib { 
      exports com.steeplesoft.datecalc; 
    } </pre>
<p class="mce-root">Since everything we need is already in the JDK, we have nothing to declare beyond what we export.</p>
<p class="mce-root">With our project set up, let's take a quick look at the functional requirements. Our intent with this project is to build a system that allows the user to provide an arbitrary string representing a date or time calculation expression and get a response. The string may look something like <kbd class="calibre16">"today + 2 weeks"</kbd> to find out the date 2 weeks from today, <kbd class="calibre16">"now + 3 hours 15 minutes"</kbd> to find out what time it is in 3 hours and 15 minutes, or <kbd class="calibre16">"2016/07/04 - 1776/07/04"</kbd> to find out how many years, months, and days are between the two dates. The processing of these expressions will be one line at a time, so the ability to pass in, for example, a text document with multiple expressions and get multiple results is explicitly excluded from the scope. This can be implemented easily enough, of course, by any consuming application or library.</p>
<p class="mce-root">So, now we have a project set up and ready to go, and we have a rough sketch of its fairly simple functional requirements. We're ready to start coding. Before we do that, let's take a quick tour of the new <kbd class="calibre16">java.time</kbd> package to get a better sense of what we'll be seeing in this project, as well as some of the functionality we <strong class="calibre8">won't</strong> be using in this simple project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A timely interlude</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 8, two primary date-related classes were <kbd class="calibre16">Date</kbd> and <kbd class="calibre16">Calendar</kbd> (and, of course, <kbd class="calibre16">GregorianCalendar</kbd>). The new <kbd class="calibre16">java.time</kbd> package offers several new classes, such as <kbd class="calibre16">Duration</kbd>, <kbd class="calibre16">Period</kbd>, <kbd class="calibre16">Clock</kbd>, <kbd class="calibre16">Instant</kbd>, <kbd class="calibre16">LocalDate</kbd>, <kbd class="calibre16">LocalTime</kbd>, <kbd class="calibre16">LocalDateTime</kbd>, and <kbd class="calibre16">ZonedDateTime</kbd>. There is a plethora of supporting classes, but these are the primary starting points. Let's take a quick look at each.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Duration</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">Duration</kbd> is a <strong class="calibre8">time-based unit of time</strong>. While it may sound odd to phrase it that way, the wording was chosen to distinguish it from a date-based unit of time, which we'll look at next. In plain English, it's a measurement of time, such as <strong class="calibre8">10 seconds</strong>, <strong class="calibre8">1 hour</strong>, or <strong class="calibre8">100 nanoseconds</strong>. <kbd class="calibre16">Duration</kbd> is measured in seconds, but there are a number of methods to get a representation of the duration in other units of measure, which are as follows:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">getNano()</kbd>: This is <kbd class="calibre16">Duration</kbd> in nanosecods</li>
<li class="calibre14"><kbd class="calibre16">getSeconds()</kbd>: This is <kbd class="calibre16">Duration</kbd> in seconds</li>
<li class="calibre14"><kbd class="calibre16">get(TemporalUnit)</kbd>: This is <kbd class="calibre16">Duration</kbd> in a unit of measure specified</li>
</ul>
<p class="mce-root">There are also a variety of arithmetic methods, which are mentioned as follows:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">add</kbd>/<kbd class="calibre16">minus (int amount, TemporalUnit unit)</kbd></li>
<li class="calibre14"><kbd class="calibre16">add</kbd>/<kbd class="calibre16">minus (Duration)</kbd></li>
<li class="calibre14"><kbd class="calibre16">addDays</kbd>/<kbd class="calibre16">minusDays(long)</kbd></li>
<li class="calibre14"><kbd class="calibre16">addHours</kbd>/<kbd class="calibre16">minusHours(long)</kbd></li>
<li class="calibre14"><kbd class="calibre16">addMillis</kbd>/<kbd class="calibre16">minusMillis(long)</kbd></li>
<li class="calibre14"><kbd class="calibre16">addMinutes</kbd>/<kbd class="calibre16">minusMinutes(long)</kbd></li>
<li class="calibre14"><kbd class="calibre16">addNanos</kbd>/<kbd class="calibre16">minusNanos(long)</kbd></li>
<li class="calibre14"><kbd class="calibre16">addSeconds</kbd>/<kbd class="calibre16">minusSeconds(long)</kbd></li>
<li class="calibre14"><kbd class="calibre16">dividedBy</kbd>/<kbd class="calibre16">multipliedBy</kbd></li>
</ul>
<p class="mce-root">We also have a number of convenient factory and extraction methods, such as the following:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">ofDays(long)</kbd>/<kbd class="calibre16">toDays()</kbd></li>
<li class="calibre14"><kbd class="calibre16">ofHours(long)</kbd>/<kbd class="calibre16"><kbd class="calibre79">toHours()</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">ofMinutes(long)</kbd>/<kbd class="calibre16">toMinutes()</kbd></li>
<li class="calibre14"><kbd class="calibre16">ofSeconds(long)</kbd>/<kbd class="calibre16">toSeconds()</kbd></li>
</ul>
<p class="mce-root">A <kbd class="calibre16">parse()</kbd> method is also supplied. Unfortunately, perhaps, for some, the input for this method may not be what you might expect. Since we're dealing with a duration that is often, say, in hours and minutes, you might expect the method to accept something like "1:37" for 1 hour and 37 minutes. However, that will cause the system to throw <kbd class="calibre16">DateTimeParseException</kbd>. What the method expects to receive is a string in an ISO-8601 format, which looks like this--<kbd class="calibre16">PnDTnHnMn.nS</kbd>. That's pretty fantastic, isn't it? While it may be confusing at first, it's not too bad once you understand it:</p>
<ul class="calibre13">
<li class="calibre14">The first character is an optional <kbd class="calibre16">+</kbd> (plus) or <kbd class="calibre16">-</kbd> (minus) sign.</li>
<li class="calibre14">The next character is <kbd class="calibre16">P</kbd> and can be either uppercase or lowercase.</li>
<li class="calibre14">What follows is at least one of four sections indicating days (<kbd class="calibre16">D</kbd>), hours (<kbd class="calibre16">H</kbd>), minutes (<kbd class="calibre16">M</kbd>), and seconds (<kbd class="calibre16">S</kbd>). Again, case doesn't matter.</li>
<li class="calibre14">They must be declared in this order.</li>
<li class="calibre14">Each section has a numeric part that includes an optional <kbd class="calibre16">+</kbd> or <kbd class="calibre16">-</kbd> sign, one or more ASCII digits, and the unit of measure indicator. The seconds amount may be fractional (expressed as a floating point number) and may use a period or a comma.</li>
<li class="calibre14">The letter <kbd class="calibre16">T</kbd> must come before the first instance of hours, minutes, or seconds.</li>
</ul>
<p class="mce-root">Simple, right? It may not be very friendly to a non-technical audience, but that it supports encoding a duration in a string that allows unambiguous parsing is a huge step forward.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Period</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">Period</kbd> is a date-based unit of time. Whereas <kbd class="calibre16">Duration</kbd> was about time (hours, minutes, seconds, and so on), <kbd class="calibre16">Period</kbd> is about years, weeks, months, and so forth. Like <kbd class="calibre16">Duration</kbd>, it exposes several arithmetic methods to add and subtract, though these deal with years, months, and days. It also offers <kbd class="calibre16">plus(long amount, TemporalUnit unit)</kbd> (and the equivalent <kbd class="calibre16">minus</kbd>) as well.</p>
<p class="mce-root">Also, like <kbd class="calibre16">Duration</kbd>, <kbd class="calibre16">Period</kbd> has a <kbd class="calibre16">parse()</kbd> method, which also takes an ISO-8601 format that looks like this--<kbd class="calibre16">PnYnMnD</kbd> and <kbd class="calibre16">PnW</kbd>. Based on the discussion earlier, the structure is probably pretty obvious:</p>
<ul class="calibre13">
<li class="calibre14">The string starts with an optional sign, followed by the letter <kbd class="calibre16">P</kbd>.</li>
<li class="calibre14">After that, for the first form, come three sections, at least one of which must be present--years (<kbd class="calibre16">Y</kbd>), months(<kbd class="calibre16">M</kbd>), and days (<kbd class="calibre16">D</kbd>).</li>
<li class="calibre14">For the second form, there is only one section--weeks (<kbd class="calibre16">W</kbd>).</li>
<li class="calibre14">The amount in each section can have a positive or negative sign.</li>
<li class="calibre14">The <kbd class="calibre16">W</kbd> unit can't be combined with the others. Internally, the amount is multiplied by <kbd class="calibre16">7</kbd> and treated as days.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Clock</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">Clock</kbd> is an abstract class that provides access to the current instant (which we will see next), date, and time using a timezone. Prior to Java 8, we would have to call <kbd class="calibre16">System.currentTimeInMillis()</kbd> and <kbd class="calibre16">TimeZone.getDefault()</kbd> to calculate these values. <kbd class="calibre16">Clock</kbd> provides a nice interface to get that from one object.</p>
<p class="mce-root">The Javadoc states that the use of <kbd class="calibre16">Clock</kbd> is purely optional. In fact, the major date/time classes have a <kbd class="calibre16">now()</kbd> method that uses the system clock to get their value. If, however, you need to provide an alternate implementation (say, in testing, you need the <kbd class="calibre16">LocalTime</kbd> in another timezone), this abstract class can be extended to provide the functionality needed, and can then be passed to the appropriate <kbd class="calibre16">now()</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Instant</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An <kbd class="calibre16">Instant</kbd> is a single, exact point in time (or <strong class="calibre8">on the timeline</strong>, you'll see the Javadoc say). This class offers arithmetic methods, much like <kbd class="calibre16">Period</kbd> and <kbd class="calibre16">Duration</kbd>. Parsing is also an option, with the string being an ISO-8601 instant format such as <kbd class="calibre16">1977-02-16T08:15:30Z</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">LocalDate</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">LocalDate</kbd> is a date without a timezone. While the value of this class is a date (year, month, and day), there are accessor methods for other values, which are as follows:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">getDayOfWeek()</kbd>: This returns the <kbd class="calibre16">DayOfWeek</kbd> enum for the day of the week represented by the date.</li>
<li class="calibre14"><kbd class="calibre16">getDayOfYear()</kbd>: This returns the day of the year (1 to 365, or 366 for leap years) represented by the date. This is a 1-based counter from January 1 of the specified year.</li>
<li class="calibre14"><kbd class="calibre16">getEra()</kbd>: This returns the ISO era for the given date.</li>
</ul>
<p class="mce-root">Local dates can be parsed from a string, of course, but, this time, the format seems much more reasonable--<kbd class="calibre16">yyyy-mm-dd</kbd>. If you need a different format, the <kbd class="calibre16">parse()</kbd> method has been overridden to allow you to specify the <kbd class="calibre16">DateTimeFormatter</kbd> that can handle the format of the string.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">LocalTime</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">LocalTime</kbd> is the time-based equivalent of <kbd class="calibre16">LocalDate</kbd>. It stores <kbd class="calibre16">HH:MM:SS</kbd>, but does <strong class="calibre8">not</strong> store the timezone. Parsing times requires the format above, but, just like <kbd class="calibre16">LocalDate</kbd>, does allow you to specify a <kbd class="calibre16">DateTimeFormatter</kbd> for alternate string representations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">LocalDateTime</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">LocalDateTime</kbd> is basically a combination of the last two classes. All of the arithmetic, factory, and extraction methods apply as expected. Parsing the text is also a combination of the two, except that <kbd class="calibre16">T</kbd> must separate the date and time portions of the string--<kbd class="calibre16">'2016-01-01T00:00:00'</kbd>. This class <strong class="calibre8">does not</strong> store or represent a timezone.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">ZonedDateTime</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you need to represent a date/time <strong class="calibre8">and</strong> a timezone, then <kbd class="calibre16">ZonedDateTime</kbd> is the class you need. As you might expect, this class' interface is a combination of <kbd class="calibre16">LocalDate</kbd> and <kbd class="calibre16">LocalTime</kbd>, with extra methods added for handling the timezone.</p>
<p class="mce-root">As shown at length in the overview of duration's API (and hinted at, though not as clearly shown in the other classes), one of the strong points of this new API is the ability to manipulate and process various date and time artifacts mathematically. It is precisely this functionality that we will spend most of our time with in this project as we explore this new library.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Back to our code</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first part of the process we need to tackle is parsing the user-provided string into something we can use programmatically. If you were to search for a parser generator, you would find a myriad of options, with tools such as Antlr and JavaCC showing up near the top. It's tempting to turn to one of these tools, but our purposes here are pretty simple, and the grammar is not all that complex. Our functional requirements include:</p>
<ul class="calibre13">
<li class="calibre14">We want to be able to add/subtract time to/from a date or a time</li>
<li class="calibre14">We want to be able to subtract one date or time from another to get the difference between the two</li>
<li class="calibre14">We want to be able to convert a time from one timezone to another</li>
</ul>
<p class="mce-root">For something as simple as this, a parser is far too expensive, both in terms of complexity and binary size. We can easily write a parser using tools built into the JDK, which is what we'll do.</p>
<p class="mce-root">To set the stage before we get into the code, the plan is this--we will define a number of <strong class="calibre8">tokens</strong> to represent logical parts of a date calculation expression. Using regular expressions, we will break down the given string, returning a list of these tokens, which will then be processed <strong class="calibre8">left to right</strong> to return the result.</p>
<p class="mce-root">That said, let's make a list of the types of token we'll need. We'll need one for a date, a time, the operator, any numeric amount, the unit of measure, and the timezone. Obviously, we won't need each of these for every expression, but that should cover all of our given use cases.</p>
<p class="mce-root">Let's start with a base class for our tokens. When defining a type hierarchy, it's always good to ask whether you want a base class or an interface. Using an interface gives the developer extra flexibility with regard to the class hierarchy should the need arise to extend a different class. A base class, however, allows us to provide default behavior at the cost of some rigidity in the hierarchy of the type. To make our <kbd class="calibre16">Token</kbd> implementations as simple as possible, we'd like to put as much in the base class as possible, so we'll use a base class as follows:</p>
<pre class="calibre21">    public abstract class Token&lt;T&gt; {<br class="calibre2"/>      protected T value;<br class="calibre2"/>      public interface Info {<br class="calibre2"/>        String getRegex();<br class="calibre2"/>        Token getToken(String text);<br class="calibre2"/>      }<br class="calibre2"/>      public T getValue() {<br class="calibre2"/>        return value;<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Java 8 did introduce a means to provide default behavior from an interface, that being a <strong class="calibre8">default methods</strong>. A default method is a method on an interface that provides a concrete implementation, which is a significant departure from interfaces. Prior to this change, all interfaces could do was define the method signature and force the implementing class to define the body. This allows us to add methods to an interface and provide a default implementation so that existing implementations of the interface need not change. In our case, the behavior we're providing is the storing of a value (the instance variable <kbd class="calibre16">value</kbd>) and the accessor for it (<kbd class="calibre16">getValue()</kbd>), so an interface with a default method is not appropriate.</p>
<p class="mce-root">Note that we've also defined a nested interface, <kbd class="calibre16">Info</kbd>, which we will cover in more detail when we get to the parser.</p>
<p class="mce-root">With our base class defined, we can now create the tokens we will need as follows:</p>
<pre class="calibre21">    public class DateToken extends Token&lt;LocalDate&gt; { 
      private static final String TODAY = "today"; 
      public static String REGEX = 
        "\d{4}[-/][01]\d[-/][0123]\d|today"; </pre>
<p class="mce-root">To start the class, we define two constants. <kbd class="calibre16">TODAY</kbd> is a special string that we will allow the user to specify today's date. The second is the regular expression we'll use to identify a date string:</p>
<pre class="calibre21">    "\d{4}[-/][01]\d[-/][0123]\d|today" </pre>
<p class="mce-root">It's no secret that regular expressions are ugly, and as these things go, this one's not too terribly complicated. We're matching 4 digits (<kbd class="calibre16">\d{4}</kbd>), either a - or / (<kbd class="calibre16">[-/]</kbd>), a 0 or 1 followed by any digit (<kbd class="calibre16">[01]\d</kbd>), another - or /, then a 0, 1, 2, or 3 followed by any digit. Finally, the last segment, <kbd class="calibre16">|today</kbd>, tells the system to match on the pattern that comes before, <strong class="calibre8">or</strong> the text <kbd class="calibre16">today</kbd>. All this regular expression can do is identify a string that <strong class="calibre8">looks</strong> like a date. In its current form, it can't actually ensure that it is valid. We can probably make a regex that can do exactly that, but the complexity that would introduce is just not worth it. What we can do though is let the JDK validate the string for us, which we'll do in the <kbd class="calibre16">of</kbd> method, as shown here:</p>
<pre class="calibre21">    public static DateToken of(String text) { 
      try { 
        return TODAY.equals(text.toLowerCase()) ? 
          new DateToken(LocalDate.now()) : 
          new DateToken( 
            LocalDate.parse(text.replace("/", "-"))); 
      } catch (DateTimeParseException ex) { 
          throw new DateCalcException( 
            "Invalid date format: " + text); 
        } 
    } </pre>
<p class="mce-root">Here, we've defined a static method to handle the creation of the <kbd class="calibre16">DateToken</kbd> instance. If the user provides the string <kbd class="calibre16">today</kbd>, we provide the value <kbd class="calibre16">LocalDate.now()</kbd>, which does what you think it might. Otherwise, we pass the string to <kbd class="calibre16">LocalDate.parse()</kbd>, changing any forward slashes to dashes, as that's what the method expects. If the user provided an invalid date, but the regular expression still matched it, we'll get an error here. Since we have built-in support to validate the string, we can content ourselves with letting the system do the heavy lifting for us.</p>
<p class="mce-root">The other tokens look very similar. Rather than showing each class, much of which would be very familiar, we'll skip most of those classes and just look at the regular expressions, as some are quite complex. Take a look at the following code:</p>
<pre class="calibre21">    public class IntegerToken extends Token&lt;Integer&gt; { 
      public static final String REGEX = "\d+"; </pre>
<p class="mce-root">Well, that one's not too bad, is it? One or more digits will match here:</p>
<pre class="calibre21">    public class OperatorToken extends Token&lt;String&gt; { 
      public static final String REGEX = "\+|-|to"; </pre>
<p class="mce-root">Another relatively simple one, which will match a +, a -, or the <kbd class="calibre16">to</kbd> text:</p>
<pre class="calibre21">    public class TimeToken extends Token&lt;LocalTime&gt; { 
      private static final String NOW = "now"; 
      public static final String REGEX = 
        "(?:[01]?\d|2[0-3]):[0-5]\d *(?:[AaPp][Mm])?|now"; </pre>
<p class="mce-root">The regular expression breaks down like this:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">(?:</kbd>: This is a non-capturing group. We need to group some rules together, but we don't want them to show up as separate groups when we process this in our Java code.</li>
<li class="calibre14"><kbd class="calibre16">[01]?</kbd>: This is a zero or a one. The <kbd class="calibre16">?</kbd> indicates that this should occur once or not at all.</li>
<li class="calibre14"><kbd class="calibre16">|2[0-3]</kbd>: We either want to match the first half, <strong class="calibre3">or</strong> this section, which will be a 2 followed by a 0, 1, 2, or 3.</li>
<li class="calibre14"><kbd class="calibre16">)</kbd>: This ends the non-capturing group. This group will allow us to match 12 or 24-hour times.</li>
<li class="calibre14"><kbd class="calibre16">:</kbd>: This position requires a colon. Its presence is not optional.</li>
<li class="calibre14"><kbd class="calibre16">[0-5]\d</kbd>: Next, the pattern must match a digit of <kbd class="calibre16">0-5</kbd> followed by another digit. This is the minutes portion of the time.</li>
<li class="calibre14"><kbd class="calibre16">' *'</kbd>: It's hard to see, so I've added quotes to help indicate it, but we want to match 0 or more (as indicated by the asterisk) spaces.</li>
<li class="calibre14"><kbd class="calibre16">(?:</kbd>: This is another non-capturing group.</li>
<li class="calibre14"><kbd class="calibre16">[AaPp][Mm]</kbd>: These are the <kbd class="calibre16">A</kbd> or <kbd class="calibre16">P</kbd> letters (of either case) followed by an <kbd class="calibre16">M</kbd> (also of either case).</li>
<li class="calibre14"><kbd class="calibre16">)?</kbd>: We end the non-capturing group, but mark it with a <kbd class="calibre16">?</kbd> to indicate that it should occur once or not all. This group lets us capture any <kbd class="calibre16">AM</kbd>/<kbd class="calibre16">PM</kbd> designation.</li>
<li class="calibre14"><kbd class="calibre16">|now</kbd>: Much like today above, we allow the user to specify this string to indicate the current time.</li>
</ul>
<p class="mce-root">Again, this pattern may match an invalid time string, but we'll let <kbd class="calibre16">LocalTime.parse()</kbd> handle that for us in <kbd class="calibre16">TimeToken.of()</kbd>:</p>
<pre class="calibre21">    public static TimeToken of(final String text) { 
      String time = text.toLowerCase(); 
      if (NOW.equals(time)) { 
        return new TimeToken(LocalTime.now()); 
      } else { 
          try { 
            if (time.length() &lt;5) { 
                time = "0" + time; 
            } 
            if (time.contains("am") || time.contains("pm")) { 
              final DateTimeFormatter formatter = 
                new DateTimeFormatterBuilder() 
                .parseCaseInsensitive() 
                .appendPattern("hh:mma") 
                .toFormatter(); 
                return new 
                TimeToken(LocalTime.parse( 
                  time.replaceAll(" ", ""), formatter)); 
            } else { 
                return new TimeToken(LocalTime.parse(time)); 
            } 
          } catch (DateTimeParseException ex) { 
              throw new DateCalcException( 
              "Invalid time format: " + text); 
            } 
        }<br class="calibre2"/>    } </pre>
<p class="mce-root">This is a bit more complex than others, primarily because of the default format expected by <kbd class="calibre16">LocalTime.parse()</kbd>, which is an ISO-8601 time format. Typically, time is specified in a 12-hour format with an am/pm designation. Unfortunately, that's not how the API works, so we have to make adjustments.</p>
<p class="mce-root">First, we pad the hour, if needed. Second, we look to see if the user specified <kbd class="calibre16">"am"</kbd> or <kbd class="calibre16">"pm"</kbd>. If so, we need to create a special formatter, which is done via <kbd class="calibre16">DateTimeFormatterBuilder</kbd>. We start by telling the builder to build a case-insensitve formatter. If we don't do that, <kbd class="calibre16">"AM"</kbd> will work, but <kbd class="calibre16">"am"</kbd> will not. Next, we append the pattern we want, which is hours, minutes, and am/pm, then build the formatter. Finally, we can parse our text, which we do by passing the string and the formatter to <kbd class="calibre16">LocalTime.parse()</kbd>. If all goes well, we'll get a <kbd class="calibre16">LocalTime</kbd> instance back. If not, we get an <kbd class="calibre16">Exception</kbd> instance, which we will handle. Note that we call <kbd class="calibre16">replaceAll()</kbd> on our string. We do that to strip any spaces out between the time and am/pm. Otherwise, the parse will fail.</p>
<p class="mce-root">Finally, we come to our <kbd class="calibre16">UnitOfMeasureToken</kbd>. This token isn't necessarily complex, but it's certainly not simple. For our units of measure, we want to support the words <kbd class="calibre16">year</kbd>, <kbd class="calibre16">month</kbd>, <kbd class="calibre16">day</kbd>, <kbd class="calibre16">week</kbd>, <kbd class="calibre16">hour</kbd>, <kbd class="calibre16">minute</kbd>, and <kbd class="calibre16">second</kbd>, all of which can be plural, and most of which can be abbreviated to their initial character. This makes the regular expression interesting:</p>
<pre class="calibre21">    public class UnitOfMeasureToken extends Token&lt;ChronoUnit&gt; { 
      public static final String REGEX =<br class="calibre2"/>        "years|year|y|months|month|weeks|week|w|days|<br class="calibre2"/>         day|d|hours|hour|h|minutes|minute|m|seconds|second|s"; 
      private static final Map&lt;String, ChronoUnit&gt; VALID_UNITS = <br class="calibre2"/>        new HashMap&lt;&gt;(); </pre>
<p class="mce-root">That's not so much complex as ugly. We have a list of possible strings, separated by the logical <kbd class="calibre16">OR</kbd> operator, the vertical pipe. It is probably possible to write a regular expression that searches for each word, or parts of it, but such an expression will likely be very difficult to write correctly, and almost certainly hard to debug or change. Simple and clear is almost always better than clever and complex.</p>
<p class="mce-root">There's one last element here that needs discussion: <kbd class="calibre16">VALID_UNITS</kbd>. In a static initializer, we build a <kbd class="calibre16">Map</kbd> to allow looking up the correct <kbd class="calibre16">ChronoUnit</kbd>:</p>
<pre class="calibre21">    static { 
      VALID_UNITS.put("year", ChronoUnit.YEARS); 
      VALID_UNITS.put("years", ChronoUnit.YEARS); 
      VALID_UNITS.put("months", ChronoUnit.MONTHS); 
      VALID_UNITS.put("month", ChronoUnit.MONTHS); </pre>
<p class="mce-root">And so on.</p>
<p class="mce-root">We're now ready to take a look at the parser, which is as follows:</p>
<pre class="calibre21">    public class DateCalcExpressionParser { 
      private final List&lt;InfoWrapper&gt; infos = new ArrayList&lt;&gt;(); 
 
      public DateCalcExpressionParser() { 
        addTokenInfo(new DateToken.Info()); 
        addTokenInfo(new TimeToken.Info()); 
        addTokenInfo(new IntegerToken.Info()); 
        addTokenInfo(new OperatorToken.Info()); 
        addTokenInfo(new UnitOfMeasureToken.Info()); 
      } 
      private void addTokenInfo(Token.Info info) { 
        infos.add(new InfoWrapper(info)); 
      } </pre>
<p class="mce-root">When we build our parser, we register each of our <kbd class="calibre16">Token</kbd> classes in a <kbd class="calibre16">List</kbd>, but we see two new types: <kbd class="calibre16">Token.Info</kbd> and <kbd class="calibre16">InfoWrapper</kbd>. <kbd class="calibre16">Token.Info</kbd> is an interface nested inside the <kbd class="calibre16">Token</kbd> class:</p>
<pre class="calibre21">    public interface Info { 
      String getRegex(); 
      Token getToken(String text); 
    } </pre>
<p class="mce-root">We have added this interface to give us a convenient way to get the regular expression for a <kbd class="calibre16">Token</kbd> class, as well as the <kbd class="calibre16">Token</kbd>, without having to resort to reflection. <kbd class="calibre16">DateToken.Info</kbd>, for example, looks like this:</p>
<pre class="calibre21">    public static class Info implements Token.Info { 
      @Override 
      public String getRegex() { 
        return REGEX; 
      } 
 
      @Override 
      public DateToken getToken(String text) { 
        return of(text); 
      } 
    } </pre>
<p class="mce-root">Since this is a nested class, we get easy access to members, including statics, of the enclosing class.</p>
<p class="mce-root">The next new type, <kbd class="calibre16">InfoWrapper</kbd>, looks like this:</p>
<pre class="calibre21">    private class InfoWrapper { 
      Token.Info info; 
      Pattern pattern; 
 
      InfoWrapper(Token.Info info) { 
        this.info = info; 
        pattern = Pattern.compile("^(" + info.getRegex() + ")"); 
      } 
    } </pre>
<p class="mce-root">This is a simple, private class, so some of the normal encapsulation rules can be set aside (although, should this class ever be made public, this would certainly need to be cleaned up). What we're doing, though, is storing a compiled version of the token's regular expression. Note that we're wrapping the regular expression with a couple of extra characters. The first, the caret (<kbd class="calibre16">^</kbd>), says that the match must be at the beginning of the text. We're also wrapping the regular expression in parentheses. However, this time this is a capturing group. We'll see why in the following parse method:</p>
<pre class="calibre21">    public List&lt;Token&gt; parse(String text) { 
      final Queue&lt;Token&gt; tokens = new ArrayDeque&lt;&gt;(); 
 
      if (text != null) { 
        text = text.trim(); 
        if (!text.isEmpty()) { 
          boolean matchFound = false; 
          for (InfoWrapper iw : infos) { 
            final Matcher matcher = iw.pattern.matcher(text); 
            if (matcher.find()) { 
              matchFound = true; 
              String match = matcher.group().trim(); 
              tokens.add(iw.info.getToken(match)); 
              tokens.addAll( 
                parse(text.substring(match.length()))); 
                break; 
            } 
          } 
          if (!matchFound) { 
            throw new DateCalcException( 
              "Could not parse the expression: " + text); 
          } 
        } 
      } 
 
      return tokens; 
    } </pre>
<p class="mce-root">We start by making sure that <kbd class="calibre16">text</kbd> is not null, then <kbd class="calibre16">trim()</kbd> it, then make sure it's not empty. With the sanity checks done, we loop through the <kbd class="calibre16">List</kbd> of info wrappers to find a match. Remember that the pattern compiled is a capturing group looking at the start of the text, so we loop through each <kbd class="calibre16">Pattern</kbd> until one matches. If we don't find a match, we throw an <kbd class="calibre16">Exception</kbd>.</p>
<p class="mce-root">Once we find a match, we extract the matching text from <kbd class="calibre16">Matcher</kbd>, then, using <kbd class="calibre16">Token.Info</kbd>, we call <kbd class="calibre16">getToken()</kbd> to get a <kbd class="calibre16">Token</kbd> instance for the matching <kbd class="calibre16">Pattern</kbd>. We store that in our list, then recursively call the <kbd class="calibre16">parse()</kbd> method, passing a substring of text starting after our match. That removes the matched text from the original, then repeats the process until the string is empty. Once the recursion ends and things unwind, we return a <kbd class="calibre16">Queue</kbd> of tokens that represent the string the user provided. We use a <kbd class="calibre16">Queue</kbd> instead of, say, a <kbd class="calibre16">List</kbd>, as that will make processing a bit easier. We now have a parser, but our work is only half done. Now we need to process those tokens.</p>
<p class="mce-root">In the spirit of Separation of Concerns, we've encapsulated the processing of these tokens--the actual calculation of the expression--in a separate class, <kbd class="calibre16">DateCalculator</kbd>, which uses our parser. Consider the following code:</p>
<pre class="calibre21">    public class DateCalculator { 
      public DateCalculatorResult calculate(String text) { 
        final DateCalcExpressionParser parser = 
          new DateCalcExpressionParser(); 
        final Queue&lt;Token&gt; tokens = parser.parse(text); 
 
        if (tokens.size() &gt; 0) { 
          if (tokens.peek() instanceof DateToken) { 
            return handleDateExpression(tokens); 
          } else if (tokens.peek() instanceof TimeToken) { 
              return handleTimeExpression(tokens); 
            } 
        } 
        throw new DateCalcException("An invalid expression<br class="calibre2"/>          was given: " + text); 
    } </pre>
<p class="mce-root">Each time <kbd class="calibre16">calculate()</kbd> is called, we create a new instance of the parser. Also, note that, as we look at the rest of the code, we pass the <kbd class="calibre16">Queue</kbd> around. While that does make the method signatures a bit bigger, it also makes the class thread-safe, as there's no state held in the class itself.</p>
<p class="mce-root">After our <kbd class="calibre16">isEmpty()</kbd> check, we can see where the <kbd class="calibre16">Queue</kbd> API comes in handy. By calling <kbd class="calibre16">poll()</kbd>, we get a reference to the next element in the collection, but--and this is important--<strong class="calibre8">we leave the element in the collection</strong>. This lets us look at it without altering the state of the collection. Based on the type of the first element in the collection, we delegate to the appropriate method.</p>
<p class="mce-root">For handling dates, the expression syntax is <kbd class="calibre16">&lt;date&gt; &lt;operator&gt; &lt;date | number unit_of_measure&gt;</kbd>. We can start our processing, then, by extracting a <kbd class="calibre16">DateToken</kbd> and an <kbd class="calibre16">OperatorToken</kbd>, as follows:</p>
<pre class="calibre21">    private DateCalculatorResult handleDateExpression( 
      final Queue&lt;Token&gt; tokens) { 
        DateToken startDateToken = (DateToken) tokens.poll(); 
        validateToken(tokens.peek(), OperatorToken.class); 
        OperatorToken operatorToken = (OperatorToken) tokens.poll(); 
        Token thirdToken = tokens.peek(); 
 
        if (thirdToken instanceof IntegerToken) { 
          return performDateMath(startDateToken, operatorToken,<br class="calibre2"/>            tokens); 
        } else if (thirdToken instanceof DateToken) { 
            return getDateDiff(startDateToken, tokens.poll()); 
          } else { 
              throw new DateCalcException("Invalid expression"); 
            } 
    } </pre>
<p class="mce-root">To retrieve an element from a <kbd class="calibre16">Queue</kbd>, we use the <kbd class="calibre16">poll()</kbd> method, and we can safely cast that to <kbd class="calibre16">DateToken</kbd> since we checked that in the calling method. Next, we <kbd class="calibre16">peek()</kbd> at the next element and, via the <kbd class="calibre16">validateToken()</kbd> method, we verify that the element is not null and is of the type desired. If the token is valid, we can <kbd class="calibre16">poll()</kbd> and cast safely. Next, we <kbd class="calibre16">peek()</kbd> at the third token. Based on its type, we delegate to the correct method to finish the processing. If we find an unexpected <kbd class="calibre16">Token</kbd> type, we throw an <kbd class="calibre16">Exception</kbd>.</p>
<p class="mce-root">Before looking at those calculation methods, let's look at <kbd class="calibre16">validateToken()</kbd>:</p>
<pre class="calibre21">    private void validateToken(final Token token,<br class="calibre2"/>      final Class&lt;? extends Token&gt; expected) { 
        if (token == null || ! 
          token.getClass().isAssignableFrom(expected)) { 
            throw new DateCalcException(String.format( 
              "Invalid format: Expected %s, found %s", 
               expected, token != null ? 
               token.getClass().getSimpleName() : "null")); 
        } 
    } </pre>
<p class="mce-root">There's nothing too terribly exciting here, but eagle-eyed readers might notice that we're returning the class name of our token, and, by doing so, we're leaking the name of a non-exported class to the end user. That's probably not ideal, but we'll leave fixing that as an exercise for the reader.</p>
<p class="mce-root">The method to perform date math looks like this:</p>
<pre class="calibre21">    private DateCalculatorResult performDateMath( 
      final DateToken startDateToken, 
      final OperatorToken operatorToken, 
      final Queue&lt;Token&gt; tokens) { 
        LocalDate result = startDateToken.getValue(); 
        int negate = operatorToken.isAddition() ? 1 : -1; 
 
        while (!tokens.isEmpty()) { 
          validateToken(tokens.peek(), IntegerToken.class); 
          int amount = ((IntegerToken) tokens.poll()).getValue() *<br class="calibre2"/>            negate; 
          validateToken(tokens.peek(), UnitOfMeasureToken.class); 
          result = result.plus(amount, <br class="calibre2"/>          ((UnitOfMeasureToken) tokens.poll()).getValue()); 
        } 
 
        return new DateCalculatorResult(result); 
    } </pre>
<p class="mce-root">Since we already have our starting and operator tokens, we pass those in, as well as the <kbd class="calibre16">Queue</kbd> so that we can process the remaining tokens. Our first step is to determine if the operator is a plus or a minus, assigning a positive <kbd class="calibre16">1</kbd> or a <kbd class="calibre16">-1</kbd> to <kbd class="calibre16">negate</kbd> as appropriate. We do this so we can use a single method, <kbd class="calibre16">LocalDate.plus()</kbd>. If the operator is a minus, we add a negative number and get the same result as subtracting the original number.</p>
<p class="mce-root">Finally, we loop through the remaining tokens, verifying each one before we process it. We get the <kbd class="calibre16">IntegerToken</kbd>; grab its value; multiply it by our negative modifier, <kbd class="calibre16">negate</kbd>; then add that value to the <kbd class="calibre16">LocalDate</kbd> using the <kbd class="calibre16">UnitOfMeasureToken</kbd> to tell what <strong class="calibre8">kind</strong> of value we're adding.</p>
<p class="mce-root">Calculating the difference between dates is pretty straightforward, as we see here:</p>
<pre class="calibre21">    private DateCalculatorResult getDateDiff( 
      final DateToken startDateToken, final Token thirdToken) { 
        LocalDate one = startDateToken.getValue(); 
        LocalDate two = ((DateToken) thirdToken).getValue(); 
        return (one.isBefore(two)) ? new<br class="calibre2"/>          DateCalculatorResult(Period.between(one, two)) : new<br class="calibre2"/>            DateCalculatorResult(Period.between(two, one)); 
    } </pre>
<p class="mce-root">We extract the <kbd class="calibre16">LocalDate</kbd> from our two <kbd class="calibre16">DateToken</kbd> variables, then call <kbd class="calibre16">Period.between()</kbd>, which returns a <kbd class="calibre16">Period</kbd> that indicates the elapsed amount of time between the two dates. We do check to see which date comes first so that we return a positive <kbd class="calibre16">Period</kbd> to the user as a convenience, since most people don't typically think in terms of negative periods.</p>
<p class="mce-root">The time-based methods are largely identical. The big difference is the time difference method:</p>
<pre class="calibre21">    private DateCalculatorResult getTimeDiff( 
      final OperatorToken operatorToken, 
      final TimeToken startTimeToken, 
      final Token thirdToken) throws DateCalcException { 
        LocalTime startTime = startTimeToken.getValue(); 
        LocalTime endTime = ((TimeToken) thirdToken).getValue(); 
        return new DateCalculatorResult( 
          Duration.between(startTime, endTime).abs()); 
    } </pre>
<p class="mce-root">The notable difference here is the use of <kbd class="calibre16">Duration.between()</kbd>. It looks identical to <kbd class="calibre16">Period.between()</kbd>, but the <kbd class="calibre16">Duration</kbd> class offers a method that <kbd class="calibre16">Period</kbd> does not: <kbd class="calibre16">abs()</kbd>. This method lets us return the absolute value of <kbd class="calibre16">Period</kbd>, so we can pass our <kbd class="calibre16">LocalTime</kbd> variable to <kbd class="calibre16">between()</kbd> in any order we want.</p>
<p class="mce-root">One final note before we leave this--we are wrapping our results in a <kbd class="calibre16">DateCalculatorResult</kbd> instance. Since the various operations return several different, unrelated types, this allows us to return a single type from our <kbd class="calibre16">calculate()</kbd> method. It will be up to the calling code to extract the appropriate value. We'll do that in our command-line interface, which we'll look at in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A brief interlude on testing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we move on, we need to visit a topic we've not discussed yet, that being testing. Anyone who has been in the industry for a while has likely heard the term <strong class="calibre8">Test-Driven Development</strong> (or <strong class="calibre8">TDD</strong> for short). It's an approach to software development that posits that the first thing that should be written is a test, which will fail (since there's no code to run), then the code should be written that makes the test <strong class="calibre8">green</strong>, a reference to the green indicator given in IDEs and other tools to indicate that the test has passed. This process repeats as many times as necessary to build the final system, always making changes in small increments, and always starting with a test. A myriad of books have been written on the topic, which is both hotly debated and oftentimes heavily nuanced. The exact way the approach is implemented, if at all, almost always comes in flavors.</p>
<p class="mce-root">Clearly, in our work here, we haven't followed the TDD principle strictly, but that doesn't mean we haven't tested. While TDD purists are likely to quibble, my general approach tends to be a bit looser on the testing side until my API starts to solidify some. How long this takes depends on how familiar I am with the technologies being used. If I'm very familiar with them, I might sketch out a quick interface, then scaffold a test based on that as a means of testing the API itself, then iterate over that. For new libraries, I might write a very broad test to help drive the investigation of the new library, using the test framework as a means for bootstrapping a runtime environment in which I can experiment. Regardless, at the end of the development effort, the new system should be <strong class="calibre8">fully</strong> tested (with the exact definition of <strong class="calibre8">fully</strong> being another hotly debated concept), which is what I have striven for here. A full treatise on testing and test-driven development is beyond our scope here, though.</p>
<p class="mce-root">When it comes to testing in Java, you have a <strong class="calibre8">lot</strong> of options. However, the two most common ones are TestNG and JUnit, with JUnit probably being the most popular. Which one should you pick? That depends. If you are working with an existing code-base, you should probably use whatever is already in use, unless you have a good reason to do otherwise. For example, the library could be old and no longer supported, it could be demonstrably insufficient for your needs, or you've been given an express directive to update/replace the existing system. If any of those conditions, or others similar to these, are true, we circle back to the question--<em class="calibre20">Which should I choose?</em> Again, that depends. JUnit is extremely popular and common, so using it might make sense in order to lower the barrier of entry into a project. However, TestNG has what some feel to be a much better, cleaner API. For example, TestNG does not require the use of static methods for certain test setup methods. It also aims to be much more than just a unit testing framework, providing tools for unit, functional, end-to-end, and integration testing. For our tests here, we will be using TestNG.</p>
<p class="mce-root">To get started with TestNG, we need to add it to our project. To do that, we will add a test dependency to the Maven POM file as follows:</p>
<pre class="calibre21">    &lt;properties&gt;<br class="calibre2"/>      &lt;testng.version&gt;6.9.9&lt;/testng.version&gt;<br class="calibre2"/>    &lt;/properties&gt;
    &lt;dependencies&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;org.testng&lt;/groupId&gt;   
        &lt;artifactId&gt;testng&lt;/artifactId&gt;   
        &lt;version&gt;${testng.version}&lt;/version&gt;   
        &lt;scope&gt;test&lt;/scope&gt; 
      &lt;/dependency&gt;   
    &lt;/dependencies&gt; </pre>
<p class="mce-root">Writing the tests is very simple. With the defaults of the TestNG Maven plugin, the class simply needs to be in <kbd class="calibre16">src/test/java</kbd> and end with the <kbd class="calibre16">Test</kbd> string. Each test method needs to be annotated with <kbd class="calibre16">@Test</kbd>.</p>
<p class="mce-root">There are a number of tests in the library module, so let's start with some of the very basic ones that test the regular expressions used by the tokens to identify and extract the relevant parts of the expression. For example, consider the following piece of code:</p>
<pre class="calibre21">    public class RegexTest { 
      @Test 
      public void dateTokenRegex() { 
        testPattern(DateToken.REGEX, "2016-01-01"); 
        testPattern(DateToken.REGEX, "today"); 
      } 
      private void testPattern(String pattern, String text) { 
        testPattern(pattern, text, false); 
      } 
 
      private void testPattern(String pattern, String text, 
        boolean exact) { 
          Pattern p = Pattern.compile("(" + pattern + ")"); 
          final Matcher matcher = p.matcher(text); 
 
          Assert.assertTrue(matcher.find()); 
          if (exact) { 
            Assert.assertEquals(matcher.group(), text); 
          } 
      } </pre>
<p class="mce-root">This is a very basic test of the <kbd class="calibre16">DateToken</kbd> regular expression. The test delegates to the <kbd class="calibre16">testPattern()</kbd> method, passing the regular expression to test, and a string to test it with. Our functionality is tested by following these steps:</p>
<ol class="calibre18">
<li class="chapter">Compiling the <kbd class="calibre16">Pattern</kbd>.</li>
<li class="chapter">Creating a <kbd class="calibre16">Matcher</kbd>.</li>
<li class="chapter">Calling the <kbd class="calibre16">matcher.find()</kbd> method.</li>
</ol>
<p class="mce-root">With that, the logic of the system under test is exercised. What remains is to verify that it worked as expected. We do that with our call to <kbd class="calibre16">Assert.assertTrue()</kbd>. We assert that <kbd class="calibre16">matcher.find()</kbd> returns <kbd class="calibre16">true</kbd>. If the regex is correct, we should get a <kbd class="calibre16">true</kbd> response. If the regex is not correct, we'll get a <kbd class="calibre16">false</kbd> response. In the latter case, <kbd class="calibre16">assertTrue()</kbd> will throw an <kbd class="calibre16">Exception</kbd> and the test will fail.</p>
<p class="mce-root">This test is certainly very basic. It could--should--be more robust. It should test a greater variety of strings. It should include some strings known to be bad to make sure we're not getting incorrect results in our tests. There are probably a myriad of other enhancements that could be made. The point here, though, is to show a simple test to demonstrate how to set up a TestNG-based environment. Before moving on, let's look at a couple more examples.</p>
<p class="mce-root">Here's a test to check for failure (a <strong class="calibre8">negative test</strong>):</p>
<pre class="calibre21">    @Test 
    public void invalidStringsShouldFail() { 
      try { 
        parser.parse("2016/12/25 this is nonsense"); 
        Assert.fail("A DateCalcException should have been<br class="calibre2"/>          thrown (Unable to identify token)"); 
      } catch (DateCalcException dce) { 
      } 
    } </pre>
<p class="mce-root">In this test, we expect the call to <kbd class="calibre16">parse()</kbd> to fail, with a <kbd class="calibre16">DateCalcException</kbd>. Should the call <strong class="calibre8">not</strong> fail, we have a call to <kbd class="calibre16">Assert.fail()</kbd> that will force the test to fail with the message provided. If the <kbd class="calibre16">Exception</kbd> is thrown, it's swallowed silently and the test finishes successfully.</p>
<p class="mce-root">Swallowing the <kbd class="calibre16">Exception</kbd> is one approach, but you can also tell TestNG to expect an <kbd class="calibre16">Exception</kbd> to be thrown, as we've done here via the <kbd class="calibre16">expectedExceptions</kbd> attribute:</p>
<pre class="calibre21">    @Test(expectedExceptions = {DateCalcException.class}) 
    public void shouldRejectBadTimes() { 
      parser.parse("22:89"); 
    } </pre>
<p class="mce-root">Again, we're passing a bad string to the parser. However, this time, we're telling TestNG to expect the exception via the annotation--<kbd class="calibre16">@Test(expectedExceptions = {DateCalcException.class})</kbd>.</p>
<p class="mce-root">Much more could be written on testing in general and TestNG in particular. A thorough treatment of both topics is beyond our scope, but if you are not familiar with either topic, you would be well served to find one of the many great resources available and study them thoroughly.</p>
<p class="mce-root">For now, let's turn our attention to the command-line interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the command-line interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the last chapter, we built a command-line tool using the Crest library from Tomitribe, and it worked out pretty well, so we will return to the library in building this command line as well.</p>
<p class="mce-root">To enable Crest in our project, we must do two things. First, we have to configure our POM file as follows:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;org.tomitribe&lt;/groupId&gt; 
      &lt;artifactId&gt;tomitribe-crest&lt;/artifactId&gt; 
      &lt;version&gt;0.8&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">We must also update our module definition in <kbd class="calibre16">src/main/java/module-info.java</kbd> as follows:</p>
<pre class="calibre21">    module datecalc.cli { 
      requires datecalc.lib; 
      requires tomitribe.crest; 
      requires tomitribe.crest.api; 
     
      exports com.steeplesoft.datecalc.cli; 
    } </pre>
<p class="mce-root">We can now define our CLI class like this:</p>
<pre class="calibre21">    public class DateCalc { 
      @Command 
      public void dateCalc(String... args) { 
        final String expression = String.join(" ", args); 
        final DateCalculator dc = new DateCalculator(); 
        final DateCalculatorResult dcr = dc.calculate(expression); </pre>
<p class="mce-root">Unlike in the last chapter, this command line will be extremely simple, as the only input we need is the expression to evaluate. With the preceding method signature, we tell Crest to pass all of the command-line arguments as the <kbd class="calibre16">args</kbd> value, which we then join back together via <kbd class="calibre16">String.join()</kbd> into <kbd class="calibre16">expression</kbd>. Next, we create our calculator and calculate the result.</p>
<p class="mce-root">We now need to interrogate our <kbd class="calibre16">DateCalcResult</kbd> to determine the nature of the expression. Consider the following piece of code as an example:</p>
<pre class="calibre21">    String result = ""; 
    if (dcr.getDate().isPresent()) { 
      result = dcr.getDate().get().toString(); 
    } else if (dcr.getTime().isPresent()) { 
      result = dcr.getTime().get().toString(); 
    } else if (dcr.getDuration().isPresent()) { 
      result = processDuration(dcr.getDuration().get()); 
    } else if (dcr.getPeriod().isPresent()) { 
      result = processPeriod(dcr.getPeriod().get()); 
    } 
    System.out.println(String.format("'%s' equals '%s'", 
      expression, result)); </pre>
<p class="mce-root">The <kbd class="calibre16">LocalDate</kbd> and <kbd class="calibre16">LocalTime</kbd> responses are pretty straightforward--we can simply call the <kbd class="calibre16">toString()</kbd> method on them, as the defaults are, for our purposes here, perfectly acceptable. Duration and periods are a bit more complicated. Both provide a number of methods to extract the details. We will hide those details in separate methods:</p>
<pre class="calibre21">    private String processDuration(Duration d) { 
      long hours = d.toHoursPart(); 
      long minutes = d.toMinutesPart(); 
      long seconds = d.toSecondsPart(); 
      String result = ""; 
   
      if (hours &gt; 0) { 
        result += hours + " hours, "; 
      } 
      result += minutes + " minutes, "; 
      if (seconds &gt; 0) { 
        result += seconds + " seconds"; 
      } 
 
      return result; 
    } </pre>
<p class="mce-root">The method itself is pretty simple--we extract the various parts from <kbd class="calibre16">Duration</kbd>, then build the string based on whether or not the part returns values.</p>
<p class="mce-root">The date-related method, <kbd class="calibre16">processPeriod()</kbd>, is similar:</p>
<pre class="calibre21">    private String processPeriod(Period p) { 
      long years = p.getYears(); 
      long months = p.getMonths(); 
      long days = p.getDays(); 
      String result = ""; 
 
      if (years &gt; 0) { 
        result += years + " years, "; 
      } 
      if (months &gt; 0) { 
        result += months + " months, "; 
      } 
      if (days &gt; 0) { 
        result += days + " days"; 
      } 
      return result; 
    } </pre>
<p class="mce-root">Each of these methods returns the result as a string, which we then write to standard out. And that's it. It's not a terribly complicated command-line utility, but the purpose of the exercise here is found mostly in the library.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Our date calculator is now complete. The utility itself is not too terribly complex, although, it did serve as expected, which has to be a vehicle for experimenting with Java 8's Date/Time API. In addition to the new date/time API, we scratched the surface of regular expressions, a very powerful and complex tool to parse strings. We also revisited the command-line utility library from the last chapter, and dipped our toes in the waters of unit testing and test-driven development.</p>
<p class="mce-root">In the next chapter, we'll get a bit more ambitious and step into the world of social media, building an app to help us aggregate some of our favorite services into a single application.</p>


            </article>

            
        </section>
    </div>



  </body></html>