["```java\nimport scala.language.implicitConversions\n```", "```java\n// part of Predef in Scala\nimplicit def int2Integer(x: Int): java.lang.Integer = x.asInstanceOf[java.lang.Integer]\nimplicit def Integer2int(x: java.lang.Integer): Int = x.asInstanceOf[Int]\n\n```", "```java\nval integer: Integer = RandomInt.randomInt()\nval int: Int = math.abs(integer)\n```", "```java\ntype String = java.lang.String\n```", "```java\n@inline implicit def augmentString(x: String): StringOps = new StringOps(x)\n\nscala> \"I'm a string\".flatMap(_.toString * 2) ++ \", look what I can do\"\nres1: String = II''mm aa ssttrriinngg, look what I can do\n```", "```java\ncase class A[T](a: T)\ncase class B[T](a: T)\n\nimplicit def a2A[T](a: T): A[T] = A(a)\nimplicit def a2B[T](a: T): B[T] = B(a)\n\ndef ab[C](a: B[A[C]]): Unit = println(a)\n```", "```java\nscala> ab(A(\"A\"))\nB(A(A))\n\nscala> ab(\"A\")\n          ^\n       error: type mismatch;\n        found : String(\"A\")\n        required: B[A[?]]\n```", "```java\nscala> ab(\"A\" : A[String])\nB(A(A))\n```", "```java\nscala> implicit val directions: List[String] = List(\"North\", \"West\", \"South\", \"East\")\ndirections: List[String] = List(north, west, south, east)\nscala> implicit val grades: Map[Char, String] = Map('A' -> \"90%\", 'B' -> \"80%\", 'C' -> \"70%\", 'D' -> \"60%\", 'F' -> \"0%\")\ngrades: Map[Char,String] = ChampHashMap(F -> 0%, A -> 90%, B -> 80%, C -> 70%, D -> 60%)\nscala> println(\"B\" + 42: String)\nB42\nscala> println((\"B\" + 42): String)\nB42\nscala> println(\"B\" + (42: String))\njava.lang.IndexOutOfBoundsException: 42\n  at scala.collection.LinearSeqOps.apply(LinearSeq.scala:74)\n  at scala.collection.LinearSeqOps.apply$(LinearSeq.scala:71)\n  at scala.collection.immutable.List.apply(List.scala:72)\n  ... 38 elided\nscala> \"B\" + 'C'\nres3: String = BC\nscala> \"B\" + ('C': String)\nres4: String = B70%\nscala> \"B\" + (2: String)\nres5: String = BSouth\n```", "```java\ncase class A[T](a: T)\ncase class B[T](a: T)\n\ndef ab[C](name: String)(a: A[C])(implicit b: B[C]): Unit =\n  println(s\"$name$a$b\")\n```", "```java\nscala> ab(\"1\")(A(\"A\"))\n                ^\n    error: could not find implicit value for parameter b: B[String]\n```", "```java\nscala> implicit val b = B(\"[Implicit]\")\nb: B[String] = B([Implicit])\n\nscala> ab(\"1\")(A(\"A\"))\n1A(A)B([Implicit])\n```", "```java\nscala> implicit val c = B(\"[Another Implicit]\")\nc: B[String] = B([Another Implicit])\n\nscala> ab(\"1\")(A(\"A\"))\n                ^\n       error: ambiguous implicit values:\n        both value b of type => B[String]\n        and value c of type => B[String]\n        match expected type B[String]\n```", "```java\nscala> ab(\"1\")(A(\"A\"))(b)\n1A(A)B([Implicit])\n\nscala> ab(\"1\")(A(\"A\"))(c)\n1A(A)B([Another Implicit])\n```", "```java\nscala> implicit def randomLong: Long = scala.util.Random.nextLong()\nrandomLong: Long\n\nscala> def withTimestamp(s: String)(implicit time: Long): Unit = println(s\"$time: $s\")\nwithTimestamp: (s: String)(implicit time: Long)Unit\n\nscala> withTimestamp(\"First\")\n-3416379805929107640: First\n\nscala> withTimestamp(\"Second\")\n8464636473881709888: Second\n```", "```java\nscala> implicit def recursiveLong(implicit seed: Long): Long = scala.util.Random.nextLong(seed)\nrecursiveLong: (implicit seed: Long)Long\n\nscala> withTimestamp(\"Third\")\n                    ^\n       error: diverging implicit expansion for type Long\n       starting with method recursiveLong\n```", "```java\nobject Application {\n  case class Configuration(name: String)\n  implicit val cfg: Configuration = Configuration(\"test\")\n  class Persistence(implicit cfg: Configuration) {\n    class Database(implicit cfg: Configuration) {\n      def query(id: Long)(implicit cfg: Configuration) = ???\n      def update(id: Long, name: String)(implicit cfg: Configuration) = ???\n    }\n    new Database().query(1L)\n  }\n}\n```", "```java\ndef filter(p: T => Boolean)(implicit executor: ExecutionContext): Future[T] = ...\n```", "```java\ncase class A[T](a: T) { def doA(): T = a }\nA(\"I'm an A\").doB() // does not compile\n```", "```java\ncase class B[T](b: T) { def doB(): T = b }\n\nimport scala.language.implicitConversions\nimplicit def a2b[T](a: A[T]): B[T] = B(a.a)\n\nA(\"I'm an A\").doB() // works\n```", "```java\nimplicit class C[T](a: A[T]) { def doC(): T = a.a }\nA(\"I'm an A\").doC()\n```", "```java\ncase class CanEqual(hash: Int)\n\ndef equal[CA, CB](a: CA, b: CB)(implicit ca: CA => CanEqual, cb: CB => CanEqual): Boolean = ca(a).hash == ca(a).hash\n```", "```java\ndef equalsWithBounds[CA <% CanEqual, CB <% CanEqual](a: CA, b: CB): Boolean = {\n  val hashA = implicitly[CA => CanEqual].apply(a).hash\n  val hashB = implicitly[CB => CanEqual].apply(b).hash\n  hashA == hashB \n}\n```", "```java\n@inline def implicitly[T](implicit e: T) = e\n```", "```java\ndef equalsWithPassing[CA <% CanEqual, CB <% CanEqual](a: CA, b: CB): Boolean = equal(a, b)\n```", "```java\ntrait CanEqual[T] { def hash(t: T): Int }\n\ndef equal[CA, CB](a: CA, b: CB)(implicit ca: CanEqual[CA], cb: CanEqual[CB]): Boolean =\n  ca.hash(a) == cb.hash(b)\n```", "```java\ndef equalBounds[CA: CanEqual, CB: CanEqual](a: CA, b: CB): Boolean = {\n  val hashA = implicitly[CanEqual[CA]].hash(a) \n  val hashB = implicitly[CanEqual[CB]].hash(b)\n  hashA == hashB\n}\n```", "```java\ndef equalDelegate[CA: CanEqual, CB: CanEqual](a: CA, b: CB): Boolean = equal(a, b)\n```", "```java\nimplicit val stringEqual: CanEqual[String] = new CanEqual[String] {\n  def hash(in: String): Int = in.hashCode()\n}\n```", "```java\nimplicit val intEqual: CanEqual[Int] = (in: Int) => in\n```", "```java\nimplicit val intEqual: CanEqual[Int] = identity _\n```", "```java\nscala> equal(10, 20)\nres5: Boolean = false\nscala> equalBounds(\"10\", \"20\")\nres6: Boolean = false\nscala> equalDelegate(10, \"20\")\nres7: Boolean = false\nscala> equalDelegate(1598, \"20\")\nres8: Boolean = true\n```", "```java\ntrait Cable {\n  def connect(): Boolean\n}\ncase class Usb(orientation: Boolean) extends Cable {\n  override def connect(): Boolean = orientation\n}\ncase class Lightning(length: Int) extends Cable {\n  override def connect(): Boolean = length > 100\n}\ncase class UsbC(kind: String) extends Cable {\n  override def connect(): Boolean = kind.contains(\"USB 3.1\")\n}\ndef connectCable(c: Cable): Boolean = c.connect()\n```", "```java\nscala> connectCable(Usb(false))\nres9: Boolean = false\nscala> connectCable(Lightning(150))\nres10: Boolean = true\n```", "```java\ncase class Usb(orientation: Boolean)\ncase class Lightning(length: Int)\ncase class UsbC[Kind](kind: Kind)\n```", "```java\ntrait Cable[C] {\n  def connect(c: C): Boolean\n}\n```", "```java\nimplicit val UsbCable: Cable[Usb] = new Cable[Usb] {\n  override def connect(c: Usb): Boolean = c.orientation\n}\n```", "```java\nimplicit val LightningCable: Cable[Lightning] = (_: Lightning).length > 100\n```", "```java\nimplicit val UsbCCableString: Cable[UsbC[String]] = \n  (_: UsbC[String]).kind.contains(\"USB 3.1\")\n```", "```java\ndef connectCable[C : Cable](c: C): Boolean = implicitly[Cable[C]].connect(c)\n```", "```java\nscala> connectCable(Usb(false))\nres11: Boolean = false\nscala> connectCable(Lightning(150))\nres12: Boolean = true\nscala> connectCable(UsbC(\"USB 3.1\"))\nres13: Boolean = true\n```", "```java\nimplicit def usbCCableDelegate[T](implicit conn: T => Boolean): Cable[UsbC[T]] = (c: UsbC[T]) => conn(c.kind)\n```", "```java\nimplicit val symbolConnect: Symbol => Boolean = \n  (_: Symbol).name.toLowerCase.contains(\"cable\")\n\nscala> connectCable(UsbC('NonameCable))\nres18: Boolean = true\nscala> connectCable(UsbC('FakeKable))\nres19: Boolean = false\n```", "```java\nimplicit val isEven: Int => Boolean = i => i % 2 == 0\nimplicit val hexChar: Char => Boolean = c => c >= 'A' && c <='F'\n\n```", "```java\nscala> connectCable(UsbC(10))\nres23: Boolean = true\nscala> connectCable(UsbC(11))\nres24: Boolean = false\nscala> connectCable(UsbC('D'))\nres25: Boolean = true\n```", "```java\nimplicit def adapt[A, B](implicit ev1: Cable[A], ev2: Cable[B]): Cable[(A, B)] = new Cable[(A, B)] {\n  def connect(ab: (A, B)): Boolean = \n    ev1.connect(ab._1) && ev2.connect(ab._2) \n}\n```", "```java\nimplicit def adapt[A: Cable, B: Cable]: Cable[(A, B)] =\n  (ab: (A, B)) => \n    implicitly[Cable[A]].connect(ab._1) &&\n    implicitly[Cable[B]].connect(ab._2)\n```", "```java\nscala> val usb2usbC = (Usb(false), UsbC('NonameCable))\nusb2usbC: (Usb, UsbC[Symbol]) = (Usb(false),UsbC('NonameCable))\n\nscala> connectCable(usb2usbC)\nres33: Boolean = false\n\nscala> val lightning2usbC = (Lightning(150), UsbC('NonameCable))\nlightning2usbC: (Lightning, UsbC[Symbol]) = (Lightning(150),UsbC('NonameCable))\n\nscala> connectCable(lightning2usbC)\nres34: Boolean = true\n```", "```java\nscala> val usbC2usb2lightning2usbC = ((UsbC('NonameCable), Usb(false)), (Lightning(150), UsbC(\"USB 3.1\")))\nusbC2usb2lightning2usbC: ((UsbC[Symbol], Usb), (Lightning, UsbC[String])) = ((UsbC('NonameCable),Usb(false)),(Lightning(150),UsbC(USB 3.1)))\n\nscala> connectCable(usbC2usb2lightning2usbC)\nres35: Boolean = false\n\nscala> val noUsbC_Long_Cable = (UsbC('NonameCable), (Lightning(150), UsbC(10L)))\nnoUsbC_Long_Cable: (UsbC[Symbol], (Lightning, UsbC[Long])) = (UsbC('NonameCable),(Lightning(150),UsbC(10)))\n\nscala> connectCable(noUsbC_Long_Cable)\n                     ^\n       error: could not find implicit value for evidence parameter of type Cable[(UsbC[Symbol], (Lightning, UsbC[Long]))]\n```", "```java\n@scala.annotation.implicitNotFound(\"Cannot connect cable of type ${C}\")\ntrait Cable[C] {\n  def connect(c: C): Boolean\n}\n```", "```java\nscala> connectCable(noUsbC_Long_Cable)\n                     ^\n       error: Cannot connect cable of type (UsbC[Symbol], (Lightning, UsbC[Long]))\n```", "```java\nabstract class UsbConnector\ncase class Usb(orientation: Boolean) extends UsbConnector\ncase class Lightning(length: Int) extends UsbConnector\ncase class UsbC[Kind](kind: Kind) extends UsbConnector\n```", "```java\nimplicit val usbCable: Cable[UsbConnector] = new Cable[UsbConnector] {\n  override def connect(c: UsbConnector): Boolean = {\n    println(s\"Connecting $c\")\n    true\n  }\n}\n```", "```java\nscala> connectCable(UsbC(\"3.1\"))\n                   ^\n       error: could not find implicit value for evidence parameter of type Cable[UsbC[String]]\n```", "```java\nCable[UsbConnector] <:< Cable[UsbC[String]]\n```", "```java\nimplicitly[Cable[UsbConnector] <:< Cable[UsbC[String]]]\n                 ^\n        error: Cannot prove that Cable[UsbConnector] <:< Cable[UsbC[String]]\n```", "```java\ntrait Cable[-C] {\n  def connect(c: C): Boolean\n}\n```", "```java\nscala> implicitly[Cable[UsbConnector] <:< Cable[UsbC[String]]]\nres1: TypeClassVariance.Cable[TypeClassVariance.UsbConnector] <:< TypeClassVariance.Cable[TypeClassVariance.UsbC[String]] = generalized constraint\n\nscala> connectCable(UsbC(\"3.1\"))\nConnecting UsbC(3.1)\n```", "```java\nimplicit val usbCCable: Cable[UsbC[String]] = new Cable[UsbC[String]] {\n  override def connect(c: UsbC[String]): Boolean = {\n    println(s\"Connecting USB C ${c.kind}\")\n    true\n  }\n}\n\nscala> connectCable(UsbC(\"3.1\"))\nConnecting UsbC(3.1)\n```", "```java\nimplicit def usbPolyCable[T <: UsbConnector]: Cable[T] = new Cable[T] {\n  override def connect(c: T): Boolean = {\n    println(s\"Poly-Connecting $c\")\n    true\n  }\n}\n```", "```java\nscala> implicitly[Cable[UsbConnector] <:< Cable[UsbC[String]]]\n ^\n error: Cannot prove that Cable[UsbConnector] <:< Cable[UsbC[String]].\n```", "```java\nscala> connectCable(UsbC(\"3.1\"))\nPoly-Connecting UsbC(3.1)\n```", "```java\nscala> connectCable(UsbC(\"3.1\"))\nConnecting USB C 3.1\n```", "```java\n\npackage object resolution {\n  implicit val a: TS = new TS(\"val in package object\") // (1)\n}\n\npackage resolution {\n  class TS(override val toString: String)\n  class Parent {\n    // implicit val c: TS = new TS(\"val in parent class\") // (2)\n  }\n  trait Mixin {\n    // implicit val d: TS = new TS(\"val in mixin\") // (3)\n  }\n  // import Outer._ // (4)\n  class Outer {\n    // implicit val e: TS = new TS(\"val in outer class\") // (5)\n    // import Inner._ // (6)\n\n    class Inner(/*implicit (7) */ val arg: TS = implicitly[TS]) extends Parent with Mixin {\n      // implicit val f: TS = new TS(\"val in inner class\") (8)\n      private val resolve = implicitly[TS]\n    }\n    object Inner {\n      implicit val g: TS = new TS(\"val in companion object\")\n    }\n  }\n  object Outer {\n    implicit val h: TS = new TS(\"val in parent companion object\")\n  }\n}\n```", "```java\nimport scala.language.implicitConversions\n\ntrait ParentA { def name: String }\ntrait ParentB\nclass ChildA(val name: String) extends ParentA with ParentB\n\nobject ParentB {\n  implicit def a2Char(a: ParentA): Char = a.name.head\n\n}\nobject ParentA {\n  implicit def a2Int(a: ParentA): Int = a.hashCode()\n  implicit val ordering = new Ordering[ChildA] {\n    override def compare(a: ChildA, b: ChildA): Int =\n      implicitly[Ordering[String]].compare(a.name, b.name)\n  }\n}\nobject ChildA {\n  implicit def a2String(a: ParentA): String = a.name\n}\n\ntrait Test {\n  def test(a: ChildA) = {\n    val _: Int = a // companion object of ParentA\n    val _: String = a // companion object of ChildA\n    val _: Char = a // companion object of ParentB\n  }\n  def constructor[T: Ordering](in: T*): List[T] = in.toList.sorted // companion object of type constructor\n  constructor(new ChildA(\"A\"), new ChildA(\"B\")).sorted // companion object of type parameters\n}\n```"]