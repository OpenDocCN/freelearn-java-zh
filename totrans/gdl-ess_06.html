<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;The Real-world Project with Gradle"><div class="book" id="1565U2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. The Real-world Project with Gradle</h1></div></div></div><p class="calibre8">Until now, we have discussed about building the Java project, web project, Gradle life cycle, and multi-module feature of Gradle. As we know, before Gradle, there were many other build tools in the market, out of which the most popular ones are Ant and Maven. Since many project build scripts were already written in these two build tools. In this chapter, we will discuss different migration strategies to migrate the projects existing build scripts from Ant, Maven, to Gradle. Along with this, we will also focus on integrating Gradle build script to Continuous Integration tools like Jenkins and generating Java docs for the code.</p></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;The Real-world Project with Gradle">
<div class="book" title="Migrating from an Ant-based project"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec32" class="calibre1"/>Migrating from an Ant-based project</h1></div></div></div><p class="calibre8">Ant is <a id="id205" class="calibre1"/>one of the initial and most popular build tools, which made build and deployment processes much simpler as compared to other native script-based build tools. Still, you can find many projects that use Ant build script to build the project. Ant was developed on the philosophy of imperative programming model, which tells the system what to do and also how to do it. Thus, you have the benefit of controlling each and every action or step of your build script. The following is the sample Ant build script to build any Java project. Here, we are considering only minimal required tasks to build a Java project, since our purpose is to discuss the strategies to migrate from Ant scripts to Gradle scripts:</p><div class="informalexample"><pre class="programlisting">&lt;project name="Ant build project" default="createJar"&gt;
  &lt;target name="clean" description="clean the existing dirs"&gt;
    &lt;delete dir="build"/&gt;
    &lt;delete dir="dist"/&gt;
  &lt;/target&gt;

  &lt;target name="compile" description="compile the source"
    depends="clean"&gt;
    &lt;mkdir dir="build"/&gt;
    &lt;mkdir dir="dist"/&gt;
    &lt;mkdir dir="build/classes"/&gt;
    &lt;javac srcdir="src" destdir="build/classes"/&gt;
  &lt;/target&gt;
  &lt;target name="createJar" depends="compile" description="create the
    jar"&gt;
    &lt;jar jarfile="dist/JavaProject-1.0.jar" basedir="build/classes"/&gt;
  &lt;/target&gt;
&lt;/project&gt;</pre></div><p class="calibre8">Here, we <a id="id206" class="calibre1"/>have defined three targets such as <code class="literal">clean</code>, <code class="literal">compile</code>, and <code class="literal">createJar</code>, which will delete the directories, create the directories, compile the Java file present in source directories, and finally create the <code class="literal">.jar</code> file, respectively. There are three different strategies that a developer can follow in order to migrate the build scripts from Ant to Gradle, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Importing an Ant file</li><li class="listitem">Using AntBuilder API</li><li class="listitem">Rewriting Ant tasks to Gradle tasks</li></ul></div><p class="calibre8">We will discuss each of them with an example.</p></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;The Real-world Project with Gradle">
<div class="book" title="Migrating from an Ant-based project">
<div class="book" title="Importing an Ant file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec50" class="calibre1"/>Importing an Ant file</h2></div></div></div><p class="calibre8">The very first and simplest approach for migration is to directly import your Ant script file into a Gradle script. Consider the following structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">C:\GRADLE\CHAPTER6</strong></span>
<span class="strong"><strong class="calibre9">│   build_import.gradle</strong></span>
<span class="strong"><strong class="calibre9">│   build.xml</strong></span>
<span class="strong"><strong class="calibre9">│</strong></span>
<span class="strong"><strong class="calibre9">└───src</strong></span>
<span class="strong"><strong class="calibre9">    └───main</strong></span>
<span class="strong"><strong class="calibre9">        └───java</strong></span>
<span class="strong"><strong class="calibre9">            └───ch6</strong></span>
<span class="strong"><strong class="calibre9">                    SampleJava.java</strong></span>
</pre></div><p class="calibre8">Here, the project name is <code class="literal">Chapter6</code>, the Java source directory is <code class="literal">src/main/java</code>, and the Ant build script file is <code class="literal">build.xml</code>. The source code of <code class="literal">build.xml</code> is mentioned above. Now, as a part of the migration, create the <code class="literal">build_import.gradle</code> file with the following contents:</p><div class="informalexample"><pre class="programlisting">ant.importBuild 'build.xml'</pre></div><p class="calibre8">That is all. Yes, we have successfully migrated the Ant build script to Gradle script. Now, try to execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle –b build_import.gradle createJar</strong></span>
<span class="strong"><strong class="calibre9">:clean</strong></span>
<span class="strong"><strong class="calibre9">:compile</strong></span>
<span class="strong"><strong class="calibre9">:createJar</strong></span>
<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong class="calibre9">Total time: 3.045 secs</strong></span>
</pre></div><p class="calibre8">After executing<a id="id207" class="calibre1"/> this, you can find the <code class="literal">build</code>/<code class="literal">classes</code> and <code class="literal">dist</code> directory in the project directory, and <code class="literal">dist</code> contains the <code class="literal">JavaProject.jar</code> file.</p></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;The Real-world Project with Gradle">
<div class="book" title="Migrating from an Ant-based project">
<div class="book" title="Using AntBuilder API"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec51" class="calibre1"/>Using AntBuilder API</h2></div></div></div><p class="calibre8">Another <a id="id208" class="calibre1"/>approach to migrate is using AntBuilder API. By default, Gradle provides an AntBuilder object <code class="literal">ant</code> to the user. The user can use this object directly in the Gradle script to call the Ant tasks. The following is the sample code of the <code class="literal">build_antbuilder.gradle</code> file using AntBuilder API:</p><div class="informalexample"><pre class="programlisting">task cleanDir &lt;&lt; {
  ant.delete(dir:"build")
  ant.delete(dir:"dist")
}

task compileSrc(dependsOn:'cleanDir') &lt;&lt; {
  ant.mkdir(dir:"build/classes")
  ant.mkdir(dir:"dist")
  ant.javac(srcdir:"src", destdir:"build/classes", includeantruntime:"false")
}
task createJar(dependsOn:'compileSrc') &lt;&lt; {
  ant.jar(destfile: "dist/JavaProject-1.0.jar", basedir:"build/classes")
}</pre></div><p class="calibre8">Here, you can see we have used different Ant tasks such as <code class="literal">mkdir</code>, <code class="literal">javac</code>, <code class="literal">jar</code>, and so on, as a method of an <code class="literal">ant</code> object. Now, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle –b build_antbuilder.gradle createJar</strong></span>
<span class="strong"><strong class="calibre9">:cleanDir</strong></span>
<span class="strong"><strong class="calibre9">:compileSrc</strong></span>
<span class="strong"><strong class="calibre9">:createJar</strong></span>
<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong class="calibre9">Total time: 3.437 secs</strong></span>
</pre></div><p class="calibre8">Here also, you <a id="id209" class="calibre1"/>will find the same output, that is, it will create the <code class="literal">build</code>/<code class="literal">classes</code> directory in which you can find class files and the <code class="literal">dist</code> directory in which you can find the <code class="literal">.jar</code> file.</p></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;The Real-world Project with Gradle">
<div class="book" title="Migrating from an Ant-based project">
<div class="book" title="Rewriting Ant tasks to Gradle tasks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec52" class="calibre1"/>Rewriting Ant tasks to Gradle tasks</h2></div></div></div><p class="calibre8">This<a id="id210" class="calibre1"/> is the final approach. Using this approach rather than using an <code class="literal">ant</code> object, you actually rewrite the complete build logic or functionality using the actual Gradle tasks. One simple approach to follow this strategy is that the user first needs to logically understand the complete flow file written in Ant and then convert it into a Gradle script step by step. For all the targets defined in Ant, the user can create tasks in Gradle, and for all the tasks defined in Ant, the user can use Gradle features to replicate the same behavior. Gradle provides different standard plugins to support most of the steps of the build requirement. A plugin has its own life cycle, and with the help of plugins, the user can avoid rewriting lot of boiler-plate scripts for a common build functionality. One such plugin is the <code class="literal">java</code> plugin. We have already seen the <code class="literal">java</code> plugin details in <a class="calibre1" title="Chapter 2. Building Java Projects" href="part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 2</a>, <span class="strong"><em class="calibre10">Building Java Projects</em></span>. If we want to migrate this Ant script to Gradle script in order to build a Java project, the user can simply use a <code class="literal">Java</code> plugin and job is done.</p><p class="calibre8">Consider the <code class="literal">build.gradle</code> file with the following contents:</p><div class="informalexample"><pre class="programlisting">apply plugin:'java'</pre></div><p class="calibre8">If a developer follows the default conventions of a <code class="literal">java</code> plugin, he only needs to write this one line to build a Java project, and on executing the <code class="literal">gradle build</code> command, all the required steps would be done such as compiling code, executing unit test cases, and preparing a <code class="literal">.jar</code> file. However, this is not the case always; many legacy projects do not follow the conventions and they might have their own conventions. The <code class="literal">gradle</code> plugin provides the flexibility to configure the plugin based on the project's need. We will rewrite the Ant script into Gradle script in the following sample code:</p><div class="informalexample"><pre class="programlisting">apply plugin:'java'

task cleanDir &lt;&lt; {
  delete "build"
  delete "dist"
}

task createDirs(dependsOn:'cleanDir') &lt;&lt; {
  def classes = file("build/classes")
  def dist = file("dist")
  classes.mkdirs()
  dist.mkdirs()
  
}
compileJava {
  File classesDir = file("build/classes")
  FileTree srcDir = fileTree(dir: "src")
  source srcDir
  destinationDir classesDir
}
task createJar(type: Jar) {
  destinationDir = file("dist")
  baseName = "JavaProject-1.0"
  from "build/classes"
}
createJar.dependsOn compileJava
compileJava.dependsOn createDirs</pre></div><p class="calibre8">The <a id="id211" class="calibre1"/>preceding code snippet shows how you can rewrite the Ant script to Gradle script. On executing the <code class="literal">gradle createJar</code> command, it will generate the same output which was generated by following above migration strategies.</p></div></div></div>
<div class="book" title="Migrating from a Maven project" id="164MG1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec33" class="calibre1"/>Migrating from a Maven project</h1></div></div></div><p class="calibre8">Maven, one<a id="id212" class="calibre1"/> of the another build tool, which got most popularity after Ant and it also came with dependency management solution to the problem that the users were facing in Ant. The first problem in Ant was imperative programing where user has to write lots of boiler plate code. Another problem was dependency management. Ant does not have any in-built dependency management solution (Ant later integrated with Ivy for dependency management). A user has to write each and every JAR file path in the build file that it needs to download, and in case of transitive dependencies, it is too complex for the user to identify each and every dependent JAR and mention the JAR name in the build file. Also, in case of version conflicts, it consumes lots of a developer's efforts. Maven came with the declarative programing model and in-built dependency management solution. Gradle is also built on the top of these principles; thus, migrating from Maven to Gradle seems very comfortable for the user.</p><p class="calibre8">Like Ant migration, Gradle does not provide any import feature or in-built Maven object. A user needs to rewrite the Maven script to the Gradle script. The following are some of the concepts that will help you to smoothly migrate from Maven to Gradle:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Plugin declaration</li><li class="listitem">Common conventions</li><li class="listitem">Dependency management</li><li class="listitem">Repositories configuration</li></ul></div><p class="calibre8">Let's move towards the explanation of these concepts:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Plugin declaration</strong></span>: The plugin<a id="id213" class="calibre1"/> is the key driver for both Maven and Gradle functionalities. Same as Maven plugins, Gradle also packages most of its functionalities into plugins. In Maven, a user includes the plugin in the following XML format:<div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;artifactId&gt;pluginName&lt;/artifactId&gt;
  &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/plugin&gt;</pre></div><p class="calibre25">To include a plugin, the user only needs to write the <code class="literal">apply plugin</code> statement as follows:</p><div class="informalexample"><pre class="programlisting">apply plugin: '&lt;plugin name&gt;'</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Common conventions</strong></span>: In <a id="id214" class="calibre1"/>both Maven and Gradle, a plugin always comes with some common conventions for its functionalities. For example, if a user includes a <code class="literal">java</code> plugin, the common convention is that the source code location should be <code class="literal">src/main/java</code>, test code location should be <code class="literal">src/test/java</code>, and so on. If a user includes a plugin and follows the same convention, then he can avoid writing any boiler-plate code that could save both his time and effort.</li><li class="listitem"><span class="strong"><strong class="calibre9">Dependency management</strong></span>: Both <a id="id215" class="calibre1"/>Maven and Gradle come with in-built dependency management features. A user does not need to bother about each and every individual JAR required for the project. He just needs to mention the first-level dependency in the project, the rest all is taken care by the build tool.<p class="calibre25">In Maven, a user can mention the dependency in the following format:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt; org.apache.logging.log4j&lt;/ groupId&gt;
  &lt;artifactId&gt;log4j-core &lt;/ artifactId&gt;
  &lt;version&gt;1.2&lt;/version&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre25">To define the dependency in Gradle, a user has to use the following syntax:</p><div class="informalexample"><pre class="programlisting">dependencies{
compile(' org.apache.logging.log4j: log4j-core:1.2') 
}</pre></div><p class="calibre25">What scope is to Maven, the dependency configuration is to Gradle. You might have observed the scope attribute in Maven and dependency <a id="id216" class="calibre1"/>configuration attributes in Gradle. In Maven, scope identifies at which phase of build dependency needs to be downloaded. In Gradle, dependency configurations fulfill the same need.</p></li><li class="listitem"><span class="strong"><strong class="calibre9">Repositories configuration</strong></span>: Whenever <a id="id217" class="calibre1"/>we talk about dependencies, the first thing that comes into mind is the repository. This is the location from where you download dependencies. The following is the code snippet that can help you mention the repository location in Maven:<div class="informalexample"><pre class="programlisting">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;repository_1&lt;/id&gt;
    &lt;name&gt;custom Name&lt;/name&gt;
    &lt;url&gt; http://companylocalrepository.org &lt;/url&gt;
   &lt;/repository&gt;
&lt;/repositories&gt;</pre></div><p class="calibre25">In Gradle, you can mention the repository using the following syntax:</p><div class="informalexample"><pre class="programlisting">repositories {
  maven {
    url "http://companylocalrepository.org"
  }
}</pre></div></li></ul></div><p class="calibre8">As we have seen, both Maven and Gradle follow the same philosophy for building any project. The main difference is Maven uses XML that is good at structure, but can be a pain while configuring the build script, whereas Gradle uses Groovy script that is a DSL and offers great flexibility while managing and altering the default behavior.</p></div>
<div class="book" title="Publishing artifacts" id="173721-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec34" class="calibre1"/>Publishing artifacts</h1></div></div></div><p class="calibre8">Building <a id="id218" class="calibre1"/>a software does not make much sense unless you publish your software to some common repositories so that, if needed, it can be reused by other software or projects. We have discussed the repositories while downloading the dependencies. The other aspect of repositories is uploading the build outcome (JAR, WAR, EAR, and so on) to some common location so that it could be downloaded by other developers. The different plugins in Gradle provide an automated way to publish the default artifacts of the plugin. For example, a <code class="literal">java</code> plugin provides a task to upload a JAR file, a <code class="literal">war</code> plugin provides a task to upload a WAR file, a <code class="literal">scala</code> plugin provides a task to upload a JAR file, and so on. A user just needs to configure the <span class="strong"><em class="calibre10">upload repository</em></span> location. If a user does not want to upload the default build artifact or a user wants to upload some custom artifacts, he can easily customize Gradle tasks to upload the other artifacts and also as per his custom requirements.</p><p class="calibre8">As we have <a id="id219" class="calibre1"/>seen, a <code class="literal">java</code> plugin provides different configurations such as compile, testCompile, runtime, and so on, to download JAR for a specific scope. To upload artifacts, Gradle provides one additional configuration, <a id="id220" class="calibre1"/>
<span class="strong"><strong class="calibre9">archives</strong></span>. A user can configure the artifact in archives configuration, and using the <code class="literal">uploadArchive</code> task, he can upload the artifacts to a repository.</p><p class="calibre8">The following is the sample example of the build file (<code class="literal">build_uploadArtifact.gradle</code>) to upload a JAR file generated by a <code class="literal">java</code> plugin:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
version=1.0
repositories {
  mavenCentral()
}
dependencies {
  compile ('log4j:log4j:1.2.16')
}
uploadArchives {
  repositories {
    maven {
      credentials {
        username "user1"
        password "user1"
      }
      url "http://company.private.repo"
    }
  }
}</pre></div><p class="calibre8">You can execute the <code class="literal">gradle –b build_uploadArtifact.gradle uploadArchives</code> command to upload the artifacts. As a part of life cycle, it will build and upload the artifacts.</p><p class="calibre8">In the preceding example, the <code class="literal">uploadArchives</code> task uploads the artifact to a repository (mentioned in the URL). If it is a secured repository, you can provide a username and password, or else ignore it. You have noticed that we have not mentioned archives here, so what <a id="id221" class="calibre1"/>would get uploaded? As we have already discussed, a <code class="literal">java</code> plugin builds the JAR file, a <code class="literal">war</code> plugin builds the WAR file, and so on. Thus, the default artifact generated by a plugin would be uploaded by default as a part of the <code class="literal">uploadArchives</code> task. We will see another example as to how to upload your custom artifact.</p><p class="calibre8">The following is the <code class="literal">build_uploadCustom.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
archivesBaseName="JavaProject" // to customize Jar Name
version=1.0
repositories {
  mavenCentral()
}
def customFile= file('configurations.xml')
task customZip(type: Zip) {
  from 'src'
}
artifacts {
  archives customFile
  archives customZip
}
uploadArchives {
  repositories {
    flatDir {dirs "./tempRepo"}
  }
}</pre></div><p class="calibre8">Now, execute the <code class="literal">gradle –b build_uploadCustom.gradle uploadArchives</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt;gradle -b build_uploadCustom.gradle uploadArchives</strong></span>
<span class="strong"><strong class="calibre9">:customZip UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:jar UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:uploadArchives</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 4.014 secs</strong></span>
</pre></div><p class="calibre8">Here, you can find that a new directory <code class="literal">tempRepo</code> is created after executing the build script. This contains all the above artifacts (ZIP, JAR, and XML files) that are published by the Gradle script.</p><p class="calibre8">In the preceding example, we have covered the following two cases:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Uploading a custom file (a XML and ZIP file along with the default artifact)</li><li class="listitem">Uploading to a local file system (not on a central repository)</li></ul></div><p class="calibre8">If you <a id="id222" class="calibre1"/>configure any other custom file (JAR, WAR, or any other file) to the archives, it will also get uploaded to the repository. Here, we have configured two additional files, one <code class="literal">.xml</code> file and one <code class="literal">.zip</code> file along with the default Java artifact. If you want to share your artifacts with your team mates and at the same time do not want to upload the artifact to the repository, unless it passes integration tests, Gradle gives you the flexibility to upload the file to a local file system using <code class="literal">flatDir</code>.</p><p class="calibre8">Gradle recently introduced a <code class="literal">maven-publish</code> plugin to have more control over the publishing process. It gives you many additional flexibilities along with the default publish tasks. A user can modify the POM file, publish multiple modules, and so on.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre8">You can find more details at <a class="calibre1" href="https://docs.gradle.org/current/userguide/publishing_maven.html">https://docs.gradle.org/current/userguide/publishing_maven.html</a>.</p></div></div>
<div class="book" title="Continuous Integration" id="181NK1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec35" class="calibre1"/>Continuous Integration</h1></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre9">Continuous Integration</strong></span> (<span class="strong"><strong class="calibre9">CI</strong></span>) is <a id="id223" class="calibre1"/>one of the most popular buzzwords you can read everywhere. As is apparent from its name, CI is the process of integrating the code base each time; whenever any one makes commits to the repository. It compiles the code, run the unit test cases and prepare the build. One of the benefits a user gets here is, if there are compile issues and integration issues, a user can figure out at early stages, rather than it being too late. The following is the generic workflow the CI tool follows:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Continuous Integration" class="calibre11"/><div class="caption"><p class="calibre26">Figure 6.1</p></div></div><p class="calibre12"> </p><p class="calibre8">How does <a id="id224" class="calibre1"/>Gradle fit into this flow? To plan the build and deployment automation solution for any software, we need a different set of tools to work together to achieve the common goal. Jenkins is one of the integration tools that helps to integrate the complete workflow. It also works on the concept of plugins; you can add different plugins to Jenkins (for example, Gradle, Git, Svn, and so on) as per your need and configure them to plan the automation flow.</p><p class="calibre8">Here, we are assuming that you have installed Jenkins. You can install a <span class="strong"><strong class="calibre9">Gradle plugin</strong></span> by navigating to <span class="strong"><strong class="calibre9">Manage Jenkins</strong></span> | <span class="strong"><strong class="calibre9">Manage Plugins</strong></span> | <span class="strong"><strong class="calibre9">Search for Gradle</strong></span>.</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Continuous Integration" class="calibre11"/><div class="caption"><p class="calibre26">Figure 6.2</p></div></div><p class="calibre12"> </p><p class="calibre8">Once a plugin is installed, you can configure jobs in Jenkins using the following screenshot:</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Continuous Integration" class="calibre11"/><div class="caption"><p class="calibre26">Figure 6.3</p></div></div><p class="calibre12"> </p><p class="calibre8">Under <a id="id225" class="calibre1"/>project configuration screen, you need to configure the repository path. By default, Jenkins provides CVS and SVN plugins. If you need any other repository (perforce or Git), you can add the respective plugins. After repository configuration, you need to configure the <span class="strong"><strong class="calibre9">Build Triggers</strong></span>. It allows you to trigger build periodically or, if you want to build on every commit, you can choose <span class="strong"><strong class="calibre9">Poll SCM</strong></span>. Now, it is time to configure your build script that will build your project.</p><p class="calibre8">Under the <span class="strong"><strong class="calibre9">Build</strong></span> menu, you can choose <span class="strong"><strong class="calibre9">Invoke Gradle script</strong></span>:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Continuous Integration" class="calibre11"/><div class="caption"><p class="calibre26">Figure 6.4</p></div></div><p class="calibre12"> </p><p class="calibre8">If you are <a id="id226" class="calibre1"/>using the default build file name <code class="literal">build.gradle</code>, there is no need to configure the build file. Under <span class="strong"><strong class="calibre9">Task</strong></span>, you can mention the name of the task you want to execute. For example, if you want to build the project, you can mention <code class="literal">build</code> in the text box.</p><p class="calibre8">Once the configuration is done, you can click on <span class="strong"><strong class="calibre9">Build Now</strong></span> on the left menu to build the project. Once done, click on the respective build number and it will display <span class="strong"><strong class="calibre9">Console Output</strong></span> on the main screen:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Continuous Integration" class="calibre11"/><div class="caption"><p class="calibre26">Figure 6.5</p></div></div><p class="calibre12"> </p></div>
<div class="book" title="Generating documentation" id="190861-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec36" class="calibre1"/>Generating documentation</h1></div></div></div><p class="calibre8">Documentation<a id="id227" class="calibre1"/> is <a id="id228" class="calibre1"/>one of the important part of development life cycle, which does not get enough attention from developers. If code is not properly documented, it always increases the maintenance efforts and also it takes time for the new team member to understand the code, if the code lacks the documentation. When you apply <span class="strong"><strong class="calibre9">Java plugin</strong></span> to your build file, Gradle provides you a <code class="literal">javadoc</code> task. By default, Gradle generates the initial documentation for your code, even if the user does not mention any <span class="strong"><strong class="calibre9">Javadoc</strong></span> in the file.</p><p class="calibre8">Consider the following Java sample code:</p><div class="informalexample"><pre class="programlisting">package ch6;
public class SampleTask  {
  public static void main(String[] args) {
    System.out.println("Building Project");

  }
  public String greetings(String name) {
    return "hello "+name;
  }
}</pre></div><p class="calibre8">Now, try to execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle clean javadoc</strong></span>
<span class="strong"><strong class="calibre9">:clean</strong></span>
<span class="strong"><strong class="calibre9">:cleanDir</strong></span>
<span class="strong"><strong class="calibre9">:createDirs</strong></span>
<span class="strong"><strong class="calibre9">:compileJava</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:javadoc</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 4.341 secs</strong></span>
</pre></div><p class="calibre8">This command <a id="id229" class="calibre1"/>will generate the basic Java docs at <code class="literal">&lt;project&gt; \build\docs\javadoc</code>.</p><p class="calibre8">As per requirements, you can add your own tags (<code class="literal">@description</code>, <code class="literal">@param</code>, and so on) and details to the above class and get the updated Java docs.</p></div>
<div class="book" title="Summary" id="19UOO1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec37" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we discussed different migration strategies from existing build tools to Gradle, which could be very handy for users who are planning to migrate their existing Ant and Maven scripts to Gradle. We also discussed how to publish artifacts to repositories, which is a key functionality of any build tool, which help the users to always fetch the latest artifacts from the repositories. We discussed CI framework with the help of Jenkins and how Gradle fits into this flow, while automating the build and deployment solution. Finally, we discussed how to generate documents for the Java code.</p><p class="calibre8">In the next chapter, we will be discussing how to integrate TestNG with Gradle, which would help the user to run test cases as a part of the Gradle build. We will also be discussing integration testing strategies and Gradle integration with code analysis and code coverage tools.</p></div></body></html>