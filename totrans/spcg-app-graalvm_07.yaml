- en: '*Chapter 5*: Graal Ahead-of-Time Compiler and Native Image'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：Graal提前编译器和原生图像'
- en: Graal ahead-of-time compilation helps build native images that start up faster,
    and have a smaller footprint than traditional Java applications. Native images
    are critical for modern-day cloud-native deployments. GraalVM comes bundled with
    a tool called `native-image` that is used to compile ahead of time and generate
    native images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Graal的提前编译有助于构建启动速度更快、占用空间更小的原生图像，比传统的Java应用程序更小。原生图像对于现代云原生部署至关重要。GraalVM附带了一个名为`native-image`的工具，用于提前编译并生成原生图像。
- en: '`native-image` compiles the code into an executable that can run standalone
    without a virtual machine. The executable includes all the classes, dependencies,
    libraries, and more importantly, all the virtual machine functionalities such
    as memory management, thread management, and so on. The virtual machine functionality
    is packaged as a runtime called Substrate VM. We briefly covered Substrate VM
    in [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    in the *Substrate VM (Graal AOT and native image)* section. In this chapter, we
    will gain a deeper understanding of native images. We will learn how to build,
    run, and optimize native images with a sample.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`native-image`将代码编译成一个可以在没有虚拟机的情况下独立运行的可执行文件。该可执行文件包括所有类、依赖项、库，以及更重要的是，所有虚拟机功能，如内存管理、线程管理等。虚拟机功能被打包成一个名为Substrate
    VM的运行时。我们在[*第3章*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054)的*Substrate VM（Graal
    AOT和原生图像）*部分简要介绍了Substrate VM。在本章中，我们将更深入地了解原生图像。我们将通过一个示例学习如何构建、运行和优化原生图像。'
- en: Native images can only perform static code optimizations and do not have the
    advantage of runtime optimizations that just-in-time compilers perform. We will
    explore profile-guided optimization, which is a technique that can be used to
    optimize native images, by using runtime profiling data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 原生图像只能执行静态代码优化，并且没有即时编译器所具有的运行时优化的优势。我们将通过使用运行时分析数据来探索基于配置的优化，这是一种可以用来优化原生图像的技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding how to build and run native images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何构建和运行原生图像
- en: Understanding the architecture of a native image, and how the compilation works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解原生图像的架构以及编译过程是如何工作的
- en: Exploring various tools, compilers, and runtime configurations to analyze and
    optimize the way native images are built and executed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索各种工具、编译器和运行时配置，以分析和优化原生图像的构建和执行方式
- en: Understanding how to optimize native images using **Profile-Guided Optimization**
    (**PGO**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用**配置指导优化**（**PGO**）来优化原生图像
- en: Understanding the limitations of native images, and how to overcome these limitations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解原生图像的限制以及如何克服这些限制
- en: Understanding how memory is managed by native images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解原生图像如何管理内存
- en: By the end of this chapter, you will have a clear understanding of Graal ahead-of-time
    compilation and hands-on experience in building and optimizing native images.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将清楚地理解Graal的提前编译，并在构建和优化原生图像方面获得实践经验。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using the following tools and sample code for exploring and understanding
    Graal ahead-of-time compilation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下工具和示例代码来探索和理解Graal的提前编译：
- en: '`native-image` tool.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native-image`工具。'
- en: '**GraalVM Dashboard**: We will be using GraalVM Dashboard in this chapter to
    analyze the native images that we create.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraalVM仪表板**：在本章中，我们将使用GraalVM仪表板来分析我们创建的原生图像。'
- en: '**Access to GitHub**: There are some sample code snippets, which are available
    in a Git repository. The code can be downloaded from [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问GitHub**：有一些示例代码片段，可以在Git仓库中找到。代码可以从[https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05)下载。'
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3ftfzNr.](https://bit.ly/3ftfzNr.)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在[https://bit.ly/3ftfzNr.](https://bit.ly/3ftfzNr.)找到。
- en: Building native images
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建原生图像
- en: In this section, we will build a native image, using the Graal Native Image
    builder (`native-image`).Let's start by installing the Native Image builder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Graal Native Image构建器(`native-image`)构建一个原生图像。让我们先安装Native Image构建器。
- en: '`native-image` can be installed using GraalVM Updater with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令通过GraalVM更新器安装`native-image`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The tool is directly installed in the `/bin` folder of `GRAALVM_HOME`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 工具直接安装在`GRAALVM_HOME`的`/bin`文件夹中。
- en: Let's now create a native image of `FibonacciCalculator`, from the *Graal compiler
    configurations* section in [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`FibonacciCalculator`的本地镜像，从[*第4章*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077)的*Graal即时编译器配置*部分。
- en: 'To create a native image, compile the Java file and run `native-image FibonacciCalculator
    –no-fallback -noserver`. The following screenshot shows the output after running
    the command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建本地镜像，编译Java文件并运行`native-image FibonacciCalculator –no-fallback -noserver`。以下截图显示了运行命令后的输出：
- en: '![Figure 5.1 – FibonacciCalculator – generating a Native Image console output'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – FibonacciCalculator – 生成本地镜像控制台输出'
- en: '](img/B16878_Figure_5.1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.1.jpg)'
- en: Figure 5.1 – FibonacciCalculator – generating a Native Image console output
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – FibonacciCalculator – 生成本地镜像控制台输出
- en: 'Native Image compilation takes time, as it has to perform a lot of static code
    analysis to optimize the image that is generated. The following diagram shows
    the flow of ahead-of-time compilation performed by the Native Image builder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本地镜像编译需要时间，因为它必须执行大量的静态代码分析以优化生成的镜像。以下图表显示了本地镜像构建器执行的预编译器编译流程：
- en: '![Figure 5.2 – Native Image pipeline flow'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 本地镜像管道流程'
- en: '](img/B16878_Figure_5.2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.2.jpg)'
- en: Figure 5.2 – Native Image pipeline flow
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 本地镜像管道流程
- en: 'Let''s try to understand this picture better:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们努力更好地理解这张图片：
- en: The ahead-of-time compiler loads all the application code and dependency libraries
    and classes and packages them along with the Java Development Kit classes and
    Substrate VM classes.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译器加载所有应用程序代码、依赖库和类，并将它们与Java开发工具包类和基底虚拟机类一起打包。
- en: Substrate VM has all the virtual machine functionality that is required to run
    the application. This includes memory management, garbage collection, thread management,
    scheduling, and so on.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基底虚拟机具有运行应用程序所需的所有虚拟机功能。这包括内存管理、垃圾回收、线程管理、调度等。
- en: 'The compiler then performs the following optimization on the code before building
    the native image:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后编译器在构建本地镜像之前对代码执行以下优化：
- en: a. `META-INF/native-image/reflect-config.json`). It is also possible to configure
    other dynamic features such as JNI, proxies, and so on. The configuration files
    need to be in `CLASSPATH`, then the compiler takes care of including these features
    in the final native image.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `META-INF/native-image/reflect-config.json`) 它还可能配置其他动态功能，如JNI、代理等。配置文件需要放在`CLASSPATH`中，然后编译器会负责将这些功能包含在最终的本地镜像中。
- en: b. `static` and `static final` fields, `enum` constants, `java.lang.Class` objects,
    and so on.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `static`和`static final`字段、`enum`常量、`java.lang.Class`对象等。
- en: The final native image has the code section, where the final optimized binary
    code is placed, and in the data section of the executable, the heap image is written.
    This will help load the native image quickly.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的本地镜像包含代码部分，其中放置了最终优化的二进制代码，以及在可执行文件的数据部分，写入堆镜像。这将有助于快速加载本地镜像。
- en: 'Here is a higher-level flow of how points-to analysis and region analysis work
    at build time and runtime:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构建时和运行时点到分析和区域分析的高级流程：
- en: '![Figure 5.3 – Native Image pipeline – points-to analysis and region analysis'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 本地镜像管道 – 点到分析和区域分析'
- en: '](img/B16878_Figure_5.3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.3.jpg)'
- en: Figure 5.3 – Native Image pipeline – points-to analysis and region analysis
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 本地镜像管道 – 点到分析和区域分析
- en: 'Let''s understand this picture in detail:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解这张图片：
- en: At build time, the points-to analysis scans through the application code, dependencies,
    and JDK to find reachable code.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时，点到分析扫描应用程序代码、依赖项和JDK以查找可到达的代码。
- en: The region analysis captures the heap region metadata, which includes region
    mappings and the region entry/exit. Region analysis also uses the reachable code
    to identify which static elements need to be initialized.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域分析捕获堆区域元数据，包括区域映射和区域进入/退出。区域分析还使用可到达的代码来识别哪些静态元素需要初始化。
- en: The code is generated with the reachable code and the region metadata.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是根据可到达的代码和区域元数据生成的。
- en: At runtime, the heap allocator allocates ahead of time using the region mappings
    and the region manager handles the entry and exit.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，堆分配器使用区域映射预先分配内存，而区域管理器处理进入和退出。
- en: 'Let''s now run the native image by issuing `./fibonaccicalculator` from the
    command line. The following is a screenshot of executing the native image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过命令行运行原生图像，执行 `./fibonaccicalculator`。以下是一个执行原生图像的截图：
- en: '![Figure 5.4 – FibonacciCalculator – running fibonaccicalculator native image
    console output'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – FibonacciCalculator – 运行 FibonacciCalculator 原生图像控制台输出'
- en: '](img/B16878_Figure_5.4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.4.jpg)'
- en: Figure 5.4 – FibonacciCalculator – running fibonaccicalculator native image
    console output
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – FibonacciCalculator – 运行 FibonacciCalculator 原生图像控制台输出
- en: One of the biggest disadvantages of ahead-of-time compilation is that the compiler
    never gets to profile the runtime to optimize the code, which happens very well
    with just-in-time compilation. To bring the best of both worlds together, we can
    use the PGO technique. We covered PGO briefly in [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054),
    *GraalVM Architecture*. Let's see it in action and understand it in a little more
    depth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译编译的一个最大的缺点是编译器永远不会对运行时进行配置以优化代码，而即时编译（JIT）则可以很好地完成这项工作。为了将两者的优点结合起来，我们可以使用
    PGO 技术。我们在 *第 3 章* 的 *GraalVM 架构* 中简要介绍了 PGO。让我们看看它的实际应用，并更深入地理解它。
- en: Analyzing the native image with GraalVM Dashboard
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GraalVM 仪表板分析原生图像
- en: To gain a deeper understanding of how the points-to analysis and region analysis
    works, we can use GraalVM Dashboard. In this section, we will create a dump while
    building the native image and use GraalVM to visualize the Native Image builder
    perform points-to analysis and region analysis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解点分析（points-to analysis）和区域分析（region analysis）的工作原理，我们可以使用 GraalVM 仪表板。在本节中，我们将构建原生图像时创建转储，并使用
    GraalVM 可视化原生图像构建器执行点分析和区域分析。
- en: In the section *Debugging and Monitoring applications* from [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*, we briefly covered GraalVM Dashboard. GraalVM Dashboard
    is a very powerful tool specifically for native images. In this section, we will
    generate a dashboard dump of our `FibonnacciCalculator` sample, and explore how
    we can use GraalVM Dashboard to gain insights into the native image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章* 的 *调试和监控应用程序* 部分（[B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077]），*Graal
    即时编译器* 中，我们简要介绍了 GraalVM 仪表板。GraalVM 仪表板是一个专门针对原生图像的非常强大的工具。在本节中，我们将生成 `FibonnacciCalculator`
    示例的仪表板转储，并探讨如何使用 GraalVM 仪表板深入了解原生图像。
- en: 'To generate the dashboard dump, we have to use the `-H:DashboardDump=<name
    of the file>` flag. For our `FibonacciCalculator`, we use the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成仪表板转储，我们必须使用 `-H:DashboardDump=<文件名>` 标志。对于我们的 `FibonacciCalculator`，我们使用以下命令：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the output generated by this command. The command
    created a `dashboard.bgv` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此命令生成的输出。该命令创建了一个 `dashboard.bgv` 文件：
- en: '![Figure 5.5 – FibonacciCalculator – generating the dashboard dump console
    output'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – FibonacciCalculator – 生成仪表板转储控制台输出'
- en: '](img/B16878_Figure_5.5.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.5.jpg)'
- en: Figure 5.5 – FibonacciCalculator – generating the dashboard dump console output
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – FibonacciCalculator – 生成仪表板转储控制台输出
- en: 'We also used the `-H:DashboardAll` flag to dump all the parameters. The following
    are alternative flags that we can use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 `-H:DashboardAll` 标志来转储所有参数。以下是可以使用的替代标志：
- en: '`-H:+DashboardHeap`: This flag only dumps the image heap.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H:+DashboardHeap`: 此标志仅转储图像堆。'
- en: '`-H:+DashboardCode`: This flag generates the code size, broken down by method.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H:+DashboardCode`: 此标志生成代码大小，按方法细分。'
- en: '`-H:+DashboardPointsTo`: This flag creates a dump of the points-to analysis
    that the Native Image builder has performed.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H:+DashboardPointsTo`: 此标志创建原生图像构建器执行的点分析转储。'
- en: Now let's load this `dashboard.bgv`, and analyze the results. We need to upload
    the `dashboard.bgv` file to GraalVM Dashboard. Open the browser and go to [https://www.graalvm.org/docs/tools/dashboard/](https://www.graalvm.org/docs/tools/dashboard/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们加载这个 `dashboard.bgv` 文件，并分析结果。我们需要将 `dashboard.bgv` 文件上传到 GraalVM 仪表板。打开浏览器并访问
    [https://www.graalvm.org/docs/tools/dashboard/](https://www.graalvm.org/docs/tools/dashboard/)。
- en: 'We should then see the following screen:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下屏幕：
- en: '![Figure 5.6 – GraalVM Dashboard home page'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – GraalVM 仪表板主页'
- en: '](img/B16878_Figure_5.6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.6.jpg)'
- en: Figure 5.6 – GraalVM Dashboard home page
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – GraalVM 仪表板主页
- en: 'Click on the **+ Load data** button at the top left. You will get a dialog
    box as shown in the next screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Upload dashboard dump file window'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.7.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Upload dashboard dump file window
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `dashboard.bgv` file that we generated. You will immediately see
    the dashboard, as shown in *Figure 5.8*. You will find two reports that are generated
    on the left side – **Code Size Breakdown** and **Heap Size Breakdown**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code size breakdown report
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code size breakdown report provides the size of the code of various classes
    categorized into blocks. The size of the block represents the size of the code.
    The following figure shows the initial dashboard screen when we select the `dashboard.bgv`
    we generated in the previous section. By hovering over the blocks, we get more
    clear size breakdowns by method. We can double-click on these blocks to dig down
    deeper:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Code size breakdown dashboard'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.8.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Code size breakdown dashboard
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the report we see when we double-click on the
    FibonacciCalculator block. Once again, we can double-click on the call graph:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Code size breakdown – details report'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.9.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Code size breakdown – details report
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the call graph. This helps us understand the
    points-to analysis that the Native Image builder has performed. This can be used
    to identify opportunities to optimize the source code if we identify any classes''
    or methods'' dependencies that are not used:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Code points-to dependency report'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Code points-to dependency report
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at heap size breakdown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Heap size breakdown
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heap size breakdown provides a detailed insight into heap allocation and also
    provides a deep dive into the heap. We can double-click on these blocks to understand
    these heap allocations. The following screenshot shows the heap size breakdown
    report for `FibonacciCalculator`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Heap Size Breakdown dashboard'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Heap Size Breakdown dashboard
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how we can use GraalVM Dashboard to analyze native
    images. Now let's look at how we can optimize our native images using PGO.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PGO
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using PGO, we can run the native image with an option to generate a runtime
    profile. The JVM creates a profile file, `.iprof`, which can be used to recompile
    the native image, to further optimize it. The following diagram (recall it from
    the *Profile Guided Optimization (PGO)* section in [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054)*,*
    *GraalVM Architecture*) shows how PGO works:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Native Image – profile-guided optimization pipeline flow'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Native Image – profile-guided optimization pipeline flow
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the native image compilation pipeline flow using
    PGO. Let''s understand this flow better:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The initial native image is instrumented to create a profile by passing the
    `–pgo-instrument` flag argument, while bundling the native image. This will generate
    a native image with instrumentation code.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run the native image with several inputs, a profile is created by the
    native image. This profile is a file generated in the same directory with the
    `.iprof` extension.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have run through all the use cases, to ensure that the profile created
    covers all the paths. We can then rebuild the native image by passing the `.iprof`
    file as a parameter along with the `--pgo` argument.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will generate the optimized native image.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now build an optimized native image of our `FibonacciCalculator` class.
    Let''s first start by creating an instrumented native image by running the following
    command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command will build the native image using the profile information. The
    following screenshot shows the output of building the native image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – FibonacciCalculator – generating PGO profile console output'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.13.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – FibonacciCalculator – generating PGO profile console output
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate the `fibonaccicalculator.iprof` file in the current directory.
    Let''s now use this profile to rebuild our native image using the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will rebuild the native image, with the optimum executable. The following
    screenshot shows the output when we build the native image with the profile:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – FibonacciCalculator – generating profile-guided optimized native
    image console output'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.14.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – FibonacciCalculator – generating profile-guided optimized native
    image console output
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s execute the optimized file. The following screenshot shows the output
    results when we run the optimized native image:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – FibonacciCalculator – running PGO image console output'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.15.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – FibonacciCalculator – running PGO image console output
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it''s much faster than the original native image. Let''s now
    compare the values. The following graph shows the compression:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – FibonacciCalculator – native image versus PGO native image
    comparison'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.16.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – FibonacciCalculator – native image versus PGO native image comparison
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, PGO performs much faster and better.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is all good, if you compare this with the JIT, we see that native
    image does not perform so well. Let''s compare this with JIT (both Graal and Java
    HotSpot). The following graph shows the comparison:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – FibonacciCalculator – Graal JIT versus Java HotSpot versus
    native image versus PGO native image comparison'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.17.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – FibonacciCalculator – Graal JIT versus Java HotSpot versus native
    image versus PGO native image comparison
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: This highlights one of the key points, that native images are not always optimum.
    In this case, it is definitely not, because of the heap allocation that we are
    doing with the large arrays that we are building. This directly impacts the performance.
    This is one of the areas where it's important as a developer to optimize the code.
    Native images use the Serial GC, hence it's not a good idea to use native images
    for large heaps.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s optimize the code and see if native images run faster than JIT. Here
    is the optimized code, which does the exact same logic, but uses less Heap:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are the final results of running this code with Graal JIT and Native Image.
    As you''ll see in the following screenshots, Native Image does not take any time
    for startup and performs much faster than JIT. Let''s run the optimized code with
    Graal JIT. Following is the output after running the optimized code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – FibonacciCalculator2 – running optimized code with Graal'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.18.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – FibonacciCalculator2 – running optimized code with Graal
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the native image of the optimized code. The next screenshot
    shows the output after running the native image:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – FibonacciCalculator2 – running optimized code as a native image'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.19.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – FibonacciCalculator2 – running optimized code as a native image
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'If you chart the performance, you can see a significant improvement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – FibonacciCalculator2 – Graal JIT versus Native Image'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.20.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – FibonacciCalculator2 – Graal JIT versus Native Image
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand the limitations of AOT compilation and use the
    right approach. Let's quickly go through some of the compiler configurations for
    building native images.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Native image configuration
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A native image build is highly configurable and it is always recommended to
    provide all the build configuration in the `native-image.properties` file. As
    the `native-image` tool takes a JAR file as an input, it is recommended to package
    `native-image.properties` in `META-INF/native-image/<unique-application-identifier>`
    within the JAR file. A unique application identifier is used to avoid any collision
    of resources. These paths have to be unique, as they will be configured on `CLASSPATH`.
    The `native-image` tool uses `CLASSPATH` to load these resources while building.
    Apart from `native-image.properties`, there are various other configuration files
    that can be packaged. We will cover some of the important configurations in this
    section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the typical format of the `native-image.properties` file followed
    by an explanation of each of the sections in the properties file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Requires`: The `Requires` property is used to list all the language examples,
    such as `language:llvm` `language:python.`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JavaArgs`: We can pass regular Java arguments using this property.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageName`: This can be used to provide a custom name for the native image
    that is generated. By default, the native image is named after the JAR file or
    Mainclass file (all in lowercase letters). For example, our `FibonnaciCalculator.class`
    generates `fibonaccicalculator`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageName`：此参数可用于为生成的原生图像提供自定义名称。默认情况下，原生图像的名称与 JAR 文件或 Mainclass 文件（全部为小写字母）相同。例如，我们的
    `FibonnaciCalculator.class` 生成 `fibonaccicalculator`。'
- en: '`Args`: This is the most commonly used property. It can be used to provide
    the native-image arguments. The arguments can also be passed from the command
    line, but it is much better from the configuration management perspective to have
    them listed in `native-image.properties`, so that it can go into Git (or any source
    code repository) and track any changes. The following table explains some of the
    important arguments that are typically used:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Args`：这是最常用的属性。它可以用来提供原生图像的参数。参数也可以从命令行传递，但从配置管理的角度来看，将它们列在 `native-image.properties`
    文件中会更好，这样就可以将其放入 Git（或任何源代码仓库）并跟踪任何更改。以下表格解释了一些通常使用的参数：'
- en: '![](img/B16878_Table_5.1.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![表 5.1](img/B16878_Table_5.1.jpg)'
- en: Please refer to [https://www.graalvm.org/reference-manual/native-image/Options/](https://www.graalvm.org/reference-manual/native-image/Options/)
    for the complete list of options.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [https://www.graalvm.org/reference-manual/native-image/Options/](https://www.graalvm.org/reference-manual/native-image/Options/)
    以获取选项的完整列表。
- en: Hosted options and resource configurations
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机选项和资源配置
- en: 'We can configure various resources using various parameters. These resource
    declarations are normally configured in an external JSON file, and various `-H:`
    flags can be made to point to these resource files. The syntax is `-H<Resource
    Flag>=${.}/jsonfile.json`. The following table lists some of the important arguments
    that are used:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种参数来配置各种资源。这些资源声明通常配置在外部 JSON 文件中，并且可以使用各种 `-H:` 标志将其指向这些资源文件。语法是 `-H<Resource
    Flag>=${.}/jsonfile.json`。以下表格列出了使用的一些重要参数：
- en: '![](img/B16878_Table_5.1a.jpg)![](img/B16878_Table_5.1b.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![表 5.1a](img/B16878_Table_5.1a.jpg)![表 5.1b](img/B16878_Table_5.1b.jpg)'
- en: '`native-images.properties` captures all the configuration parameters, and it
    is a good practice to pass configurations through the `native-image.properties`
    file, as it''s easy to manage it in a source code configuration management tool.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`native-images.properties` 捕获所有配置参数，并且通过 `native-image.properties` 文件传递配置是一个好习惯，因为它在源代码配置管理工具中易于管理。'
- en: GraalVM comes with an agent that tracks the dynamic features of a Java program
    at runtime. This helps in identifying and configuring the native image build with
    dynamic features. To run the Java application with the Native image agent, we
    need to pass `-agentlib:native-image-agent=config-output-dir=<path to config dir>`.
    The agent tracks the execution and intercepts calls that look up classes, methods,
    resources, and proxies. The agent then generates `jni-config.json`, `reflect-config.json`,
    `proxy-config.json`, and `resource-config.json` in the config directory passed
    as the parameter. It's a good practice to run the application multiple times,
    with different test cases, to ensure that the complete code is covered, and the
    agent gets to catch most of the dynamic calls. When we run iterations, it is important
    to use `-agentlib:native-image-agent=config-merge-dir=<path to config dir>` so
    that the configuration files are not overwritten but merged.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 随附一个代理，该代理在运行时跟踪 Java 程序的动态特性。这有助于识别和配置具有动态特性的原生图像构建。要使用原生图像代理运行 Java
    应用程序，我们需要传递 `-agentlib:native-image-agent=config-output-dir=<path to config dir>`。代理跟踪执行并拦截查找类、方法、资源和代理的调用。然后代理在作为参数传递的配置目录中生成
    `jni-config.json`、`reflect-config.json`、`proxy-config.json` 和 `resource-config.json`。运行应用程序多次，使用不同的测试用例，以确保完整代码被覆盖，并且代理能够捕获大多数动态调用是一个好习惯。当我们运行迭代时，使用
    `-agentlib:native-image-agent=config-merge-dir=<path to config dir>` 非常重要，这样配置文件就不会被覆盖，而是合并。
- en: We can generate Graal graphs with native images, to analyze how the native image
    is running. In the next section, we will explore how to generate these Graal graphs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原生图像生成 Graal 图，以分析原生图像的运行情况。在下一节中，我们将探讨如何生成这些 Graal 图。
- en: Generating Graal graphs for native images
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为原生图像生成 Graal 图
- en: Graal graphs can be generated even for native images. Graal graphs can be generated
    during build time or at runtime. Let's explore this feature in this section using
    our `FibonnaciCalculator` application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是原生图像也可以生成 Graal 图。Graal 图可以在构建时或运行时生成。让我们在本节中使用我们的 `FibonnaciCalculator`
    应用程序来探索这个功能。
- en: 'Let''s generate the dump for `FibonacciCalculator` using this command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用此命令生成`FibonacciCalculator`的转储：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command generates a lot of graphs for every class that is initialized.
    We can use the `-H:MethodFilter` flag to specify the class and method that we
    want to generate a graph for. The command would look something like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为每个初始化的类生成大量图表。我们可以使用`-H:MethodFilter`标志指定我们想要为其生成图表的类和方法。命令看起来可能像这样：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Please refer to the section *Graal intermediate representation* from [*Chapter
    4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077), *Graal Just-In-Time Compiler*,
    to know how to read these graphs and understand opportunities for optimizing the
    code. Optimizing the source code is critical for native images as there are no
    runtime optimizations like we have in just-in-time compilers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第4章](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077)的*Graal中间表示*部分，了解如何阅读这些图表并理解优化代码的机会。对于原生图像，优化源代码至关重要，因为我们没有像即时编译器那样的运行时优化。
- en: Understanding how native images manage memory
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解原生图像如何管理内存
- en: Native images come bundled with Substrate VM, which has the functionality of
    managing memory, including garbage collection. As we saw in the *Building native
    images* section, the heap allocation happens as part of the image creation to
    speed up the startup. These are classes that are initialized at build time. Refer
    to *Figure 5.3* to see how the Native Image builder initialized the heap region
    after performing static region analysis. At runtime, a garbage collector manages
    the memory. There are two garbage collection configurations that the Native Image
    builder supports. Let's understand these two garbage collection configurations
    in the following subsections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 原生图像与Substrate VM捆绑在一起，该VM具有管理内存的功能，包括垃圾收集。正如我们在*构建原生图像*部分所看到的，堆分配是图像创建的一部分，以加快启动速度。这些是在构建时初始化的类。请参阅*图5.3*以了解原生图像构建器在执行静态区域分析后如何初始化堆区域。在运行时，垃圾收集器管理内存。原生图像构建器支持两种垃圾收集配置。以下小节将介绍这两种垃圾收集配置。
- en: The Serial garbage collector
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列垃圾收集器
- en: The Serial Garbage Collector (GC) is the default that gets built into the native
    image. This is available both on the Community and Enterprise edition. This garbage
    collector is optimized for a low memory footprint and small heap size. We can
    use the `--gc=serial` flag to explicitly use the Serial GC. The Serial GC is a
    simple implementation of the GC.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 序列垃圾收集器（GC）是默认集成到原生图像中的。这在社区版和企业版中都是可用的。此垃圾收集器针对低内存占用和小堆大小进行了优化。我们可以使用`--gc=serial`标志显式使用序列垃圾收集器。序列垃圾收集器是GC的简单实现。
- en: 'The Serial GC divides the heap into two regions, that is, young and old. The
    following figure shows how the Serial GC works:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 序列垃圾收集器将堆分为两个区域，即年轻代和老年代。以下图示显示了序列垃圾收集器的工作原理：
- en: '![Figure 5.21 – Serial GC heap architecture'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21 – 序列垃圾收集器堆架构'
- en: '](img/B16878_Figure_5.21.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.21.jpg)'
- en: Figure 5.21 – Serial GC heap architecture
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 – 序列垃圾收集器堆架构
- en: The young generation is used for new objects. It is triggered when the young
    generation block is full and all the objects that are not used are reclaimed.
    When the old generation blocks become full, a full collection is triggered. Young
    collections run faster and a full collection is more time-consuming at runtime.
    This behavior can be tweaked using the argument `-XX:PercentTimeInIncrementalCollection`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 年轻代用于新对象。当年轻代块满且所有未使用的对象被回收时，会触发。当老年代块满时，会触发完全收集。年轻代收集运行得更快，而在运行时完全收集更耗时。可以使用`-XX:PercentTimeInIncrementalCollection`参数来调整此行为。
- en: 'By default, this percentage is 50\. This can be increased to reduce the number
    of full collections, improving the performance, but will have a negative effect
    on the memory size. Depending on the memory profiling, while testing the application,
    we can optimize this parameter for better performance and memory footprint. Here
    is an example of how to pass this parameter at runtime:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此百分比是50%。这可以增加到减少完全收集的次数，从而提高性能，但会对内存大小产生负面影响。根据内存分析，在测试应用程序时，我们可以优化此参数以获得更好的性能和内存占用。以下是如何在运行时传递此参数的示例：
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This parameter can also be passed at build time:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数也可以在构建时传递：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are other arguments that can also be used for fine-tuning, such as `-XX:MaximumYoungGenerationSizePercent`.
    This argument can be used to tweak the maximum percentage the young generation
    block should occupy of the overall heap.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用其他参数来进行微调，例如`-XX:MaximumYoungGenerationSizePercent`。这个参数可以用来调整年轻代块应该占整体堆的最大百分比。
- en: The Serial GC is single-threaded and works well for small heaps. The following
    figure shows how the Serial GC works. The application threads are paused to reclaim
    the memory. It is called a *Stop the World* event. During this time, the **Garbage
    Collector Thread** runs and reclaims the memory. This has an impact on the performance
    of the application if the heap size is large and if there are a lot of threads
    running. The Serial GC is very good for small processes with small heap sizes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 序列GC是单线程的，对于小堆来说效果很好。以下图示展示了序列GC的工作方式。应用程序线程被暂停以回收内存。这被称为*停止世界*事件。在这段时间内，**垃圾收集线程**运行并回收内存。如果堆大小很大且有很多线程运行，这将对应用程序的性能产生影响。序列GC非常适合小进程和小堆大小。
- en: '![Figure 5.22 – Serial GC heap flow'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.22 – 序列GC堆流程'
- en: '](img/B16878_Figure_5.22.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.22.jpg)'
- en: Figure 5.22 – Serial GC heap flow
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 – 序列GC堆流程
- en: By default, the Serial GC assumes an 80% heap size, before it starts the GC
    thread. This can be changed using the `-XX:MaximumHeapSizePercent` flag. There
    are other flags that can be used to fine-tune the performance of the Serial GC.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，序列GC假设在启动GC线程之前堆大小为80%，这可以通过`-XX:MaximumHeapSizePercent`标志来更改。还有其他标志可以用来微调序列GC的性能。
- en: The G1 Garbage Collector
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: G1垃圾收集器
- en: The G1 Garbage Collector is the more recent and advanced implementation of the
    garbage collector. This is only available in the Enterprise edition. The G1 Garbage
    Collector can be enabled using the flag `--gc=G1`. G1 provides the right balance
    of throughput and latency. Throughput is the average time spent running the code
    versus GC. Higher throughput means we have more CPU cycles for code, rather than
    the GC thread. Latency is the amount of time the *Stop The World* event takes
    or the time taken to pause the code execution. The less latency, the better for
    us. G1 targets high throughput and low latency. Here is how it works.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾收集器是更近期的、更高级的垃圾收集器实现。这仅在企业版中可用。可以使用`--gc=G1`标志启用G1垃圾收集器。G1提供了吞吐量和延迟之间的正确平衡。吞吐量是运行代码的平均时间与GC的时间之比。更高的吞吐量意味着我们有更多的CPU周期用于代码，而不是GC线程。延迟是*停止世界*事件所需的时间或暂停代码执行的时间。延迟越少，对我们来说越好。G1的目标是高吞吐量和低延迟。以下是它的工作方式。
- en: G1 divides the whole heap into small regions. G1 runs concurrent threads to
    find all live objects, and the Java application is never paused, and keeps track
    of all the pointers between regions, and tries to collect regions so that there
    are shorter pauses in the program. G1 might also move live objects and consolidate
    them into regions and tries to make the regions empty.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: G1将整个堆划分为小区域。G1运行并发线程以查找所有活动对象，Java应用程序永远不会暂停，并跟踪区域间的所有指针，并尝试收集区域以使程序中的暂停时间更短。G1也可能移动活动对象并将它们合并到区域中，并尝试使区域为空。
- en: '![Figure 5.23 – G1 GC heap flow'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23 – G1 GC堆流程'
- en: '](img/B16878_Figure_5.23.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16878_Figure_5.23.jpg)'
- en: Figure 5.23 – G1 GC heap flow
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23 – G1 GC堆流程
- en: The previous diagram shows how G1 GC works by dividing into regions. The allocation
    of objects into the regions is based on trying to allocate memory in empty regions
    and trying to empty the regions by consolidating the objects into regions, like
    partitioning and de-partitioning. The idea is to optimally manage and collect
    the regions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示展示了G1 GC如何通过划分区域来工作。对象分配到区域是基于尝试在空区域分配内存，并通过将对象合并到区域中（如分区和去分区）来尝试清空区域。其理念是优化管理和收集区域。
- en: 'G1 garbage collector has a larger footprint than the Serial GC and is for longer-running,
    larger heap sizes. There are various parameters that can be used to fine-tune
    the performance of G1 GC. Listed next are some of them (`-H` are the parameters
    passed during the building of the image and `-XX` is passed while running the
    image):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾收集器的占用空间比序列GC大，适用于运行时间更长、堆大小更大的情况。可以使用各种参数来微调G1 GC的性能。以下列出了一些参数（`-H`是在构建镜像时传递的参数，`-XX`是在运行镜像时传递的）：
- en: '`-H:G1HeapRegionSize`: This is the size of each region.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H:G1HeapRegionSize`：这是每个区域的大小。'
- en: '-`XX:MaxRAMPercentage`: Percentage of physical memory size that is used as
    the heap size.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxRAMPercentage`：用作堆大小的物理内存大小的百分比。'
- en: '`-XX:ConcGCThreads`: Number of concurrent GC threads. This needs to be optimized
    for the best performance.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:ConcGCThreads`：并发GC线程的数量。这需要优化以获得最佳性能。'
- en: '`-XX:G1HeapWastePercent`: The garbage collector stops claiming when it reaches
    this percentage. This will allow lower latency and higher throughput, however,
    it is critical to set an optimum value, as if it''s too high, then the objects
    will never get collected, and the application memory footprint will always be
    high.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:G1HeapWastePercent`：垃圾收集器达到此百分比时停止声明。这将允许更低的延迟和更高的吞吐量，但是，设置一个最佳值是至关重要的，因为如果它太高，那么对象将永远不会被收集，应用程序的内存占用将始终很高。'
- en: The choice of using the right garbage collector and the configuration is critical
    for the performance and memory footprint of the application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的垃圾回收器和配置对于应用程序的性能和内存占用至关重要。
- en: Managing the heap size and generating heap dumps
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理堆大小和生成堆转储
- en: 'Heap size can be manually set using the following runtime parameters passed
    to the native image while running them. `-Xmx` sets the maximum heap size, `-Xms`
    sets the minimum heap size, and `-Xmn` sets the size of the young generation region,
    in bytes. Here is an example of how these arguments can be used at runtime:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下在运行原生图像时传递的运行时参数手动设置堆大小。`-Xmx`设置最大堆大小，`-Xms`设置最小堆大小，`-Xmn`设置年轻代区域的大小，以字节为单位。以下是如何在运行时使用这些参数的示例：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At build time, we can pass arguments to configure the heap size. This is a
    critical configuration and has to be done with a lot of care as this has a direct
    impact on the memory footprint and performance of the native image. The following
    command is an example that configures the minimum heap size, maximum heap size,
    and the maximum new size of the heap:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时，我们可以传递参数来配置堆大小。这是一个关键的配置，必须非常小心地进行，因为这将直接影响原生图像的内存占用和性能。以下命令是一个配置最小堆大小、最大堆大小和堆的最大新大小的示例：
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Heap dumps are the most important for debugging any memory leaks and memory
    management issues. We typically use tools such as VisualVM to do such heap dump
    analysis. Native images are not built with `-H:+AllowVMInspection` flag. This
    will create a native image that can generate a stack dump when we send a USR1
    signal (`sudo kill -USR1` or `-SIGUSR1` or `QUIT/BREAK` keys) and a runtime compilation
    information dump when we send a USR2 signal (`sudo kill -USR2` or `-SIGUSR2` –
    you can check the exact signal using the `kill -l` command). This feature is available
    only in the Enterprise edition.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 堆转储对于调试任何内存泄漏和内存管理问题至关重要。我们通常使用VisualVM等工具进行此类堆转储分析。原生图像不是使用`-H:+AllowVMInspection`标志构建的。这将创建一个原生图像，当发送USR1信号（`sudo
    kill -USR1`或`-SIGUSR1`或`QUIT/BREAK`键）时可以生成堆栈转储，当发送USR2信号（`sudo kill -USR2`或`-SIGUSR2`
    – 您可以使用`kill -l`命令检查确切的信号）时可以生成运行时编译信息转储。此功能仅适用于企业版。
- en: We can also programmatically create heap dumps by calling `org.graalvm.nativeimage.VMRuntime#dumpHeap`
    when required.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在需要时调用`org.graalvm.nativeimage.VMRuntime#dumpHeap`来程序化地创建堆转储。
- en: Building static native images and native shared libraries
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建静态原生图像和原生共享库
- en: Static native images are statically linked binaries that do not need any additional
    dependent libraries at runtime. These are very useful when we are building microservice
    applications as native images so that they can be easily packaged into Docker,
    without worrying about dependencies. Static images are best for building container-based
    microservices.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 静态原生图像是静态链接的二进制文件，在运行时不需要任何额外的依赖库。当我们将微服务应用程序构建为原生图像时，这些图像非常有用，因为它们可以轻松地打包到Docker中，无需担心依赖关系。静态图像最适合构建基于容器的微服务。
- en: At the time of writing this book, this feature is only available for Linux AMD64
    on Java 11\. Please refer to [https://www.graalvm.org/reference-manual/native-image/StaticImages/](https://www.graalvm.org/reference-manual/native-image/StaticImages/)
    for the latest updates and the process of building static native images.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，此功能仅适用于Java 11的Linux AMD64。请参阅[https://www.graalvm.org/reference-manual/native-image/StaticImages/](https://www.graalvm.org/reference-manual/native-image/StaticImages/)以获取最新更新和构建静态原生图像的过程。
- en: The Native Image builder also builds shared libraries. Sometimes you may want
    to create your code as a shared library that is used by some other application.
    For that, you have to pass the `–shared` flag to build a shared library, instead
    of an executable one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 原生图像构建器还会构建共享库。有时您可能希望将代码作为共享库创建，该库被某些其他应用程序使用。为此，您必须传递 `–shared` 标志来构建共享库，而不是可执行库。
- en: Debugging native images
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试原生图像
- en: 'Debugging a native image requires building the image with debug info. We can
    use `-H:GenerateDebugInfo=1`. Here is an example of using this argument for `FibonnacciCalculator`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 调试原生图像需要构建包含调试信息的图像。我们可以使用 `-H:GenerateDebugInfo=1`。以下是一个为 `FibonnacciCalculator`
    使用此参数的示例：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The generated image has debug information in the form of the **GNU Debugger**
    (**GDB**). This can be used to debug the code at runtime. The following shows
    the output of running the preceding command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图像以 **GNU 调试器** (**GDB**) 的形式包含调试信息。这可以用于在运行时调试代码。以下显示了运行前述命令的输出：
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will generate a `sources` directory, which holds the cache that is generated
    by the native image builder. This cache brings JDSK, GraalVM, and application
    classes to help with debugging. The following is the output of listing the contents
    of the `sources` directory:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 `sources` 目录，其中包含由原生图像构建器生成的缓存。此缓存将 JDSK、GraalVM 和应用程序类引入以帮助调试。以下是列出
    `sources` 目录内容的输出：
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To debug native images, we need the `gdb` utility. Please refer to [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)
    for how to install `gdb` for your target machine. Once properly installed, we
    should be able to enter the `gdb` shell by executing the `gdb` command. The following
    shows the typical output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试原生图像，我们需要 `gdb` 工具。有关如何在您的目标机器上安装 `gdb` 的信息，请参阅[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)。一旦正确安装，我们应该能够通过执行
    `gdb` 命令进入 `gdb` 壳。以下显示了典型的输出：
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to point to the directories where we generated the source files in
    the previous step. We can do that by executing the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指向我们在上一步中生成源文件的目录。我们可以通过执行以下命令来完成：
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the environment is set, we can use `gdb` to set the breakpoints and debug.
    Please refer to [https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)
    for detailed documentation on how to use `gdb` to debug executables.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦环境设置完成，我们就可以使用 `gdb` 来设置断点和调试。有关如何使用 `gdb` 调试可执行文件的详细文档，请参阅[https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)。
- en: At the time of writing this book, debug information can be used to perform breakpoints,
    single-stepping, stack backtrace, printing primitive values, the casting and printing
    of objects, path expressions, and references by method name and static data. Please
    refer to [https://www.graalvm.org/reference-manual/native-image/DebugInfo/](https://www.graalvm.org/reference-manual/native-image/DebugInfo/)
    for more details.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，调试信息可用于执行断点、单步执行、堆栈回溯、打印原始值、对象的转换和打印、路径表达式以及通过方法名和静态数据引用。有关更多详细信息，请参阅[https://www.graalvm.org/reference-manual/native-image/DebugInfo/](https://www.graalvm.org/reference-manual/native-image/DebugInfo/)。
- en: Limitations of Graal AOT (Native Image)
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Graal AOT (Native Image) 的局限性
- en: In this section, we will go through some of the limitations of Graal AOT and
    native images.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Graal AOT 和原生图像的一些局限性。
- en: 'Graal ahead-of-time compilation performs static analysis with the closed-world
    assumption. It assumes that all the classes that are reachable at runtime are
    available during build time. This has a direct implication on writing any code
    that requires dynamic loading – such as Reflection, JNI, Proxies, and so on. However,
    the Graal AOT compiler (`native-image`) provides a way to provide this metadata
    in the form of JSON manifest files. These files can be packaged along with the
    JAR file, as an input for the compiler:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 的时间前编译假设了一个封闭世界的静态分析。它假设在运行时可达的所有类在构建时都是可用的。这对编写任何需要动态加载的代码（如反射、JNI、代理等）有直接影响。然而，Graal
    AOT 编译器（`native-image`）提供了一种以 JSON 清单文件的形式提供此元数据的方法。这些文件可以与 JAR 文件一起打包，作为编译器的输入：
- en: 'Loading classes dynamically: Classes that are loaded at runtime, which will
    not be visible to the AOT compiler at build time, need to be specific in the configuration
    file. These configuration files are typically saved under `META-INF/native-image/`,
    and should be in `CLASSPATH`. If the class is not found during the compilation
    of the configuration file, it will throw a `ClassNotFoundException`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载类：在运行时加载的类，在构建时对AOT编译器不可见，需要在配置文件中指定。这些配置文件通常保存在`META-INF/native-image/`下，应在`CLASSPATH`中。如果在编译配置文件时找不到类，它将抛出`ClassNotFoundException`。
- en: 'Reflection: Any call to the `java.lang.reflect` API to list the methods and
    fields or invoke them using the reflection API has to be configured in the `reflect-config.json`
    file under `META-INF/native-image/`. The compiler tries to identify these reflective
    elements through static analysis.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射：任何调用`java.lang.reflect` API来列出方法和字段或使用反射API调用它们的调用都必须在`META-INF/native-image/`下的`reflect-config.json`文件中进行配置。编译器试图通过静态分析来识别这些反射元素。
- en: 'Dynamic Proxy: Dynamic proxy classes that are generated instances of `java.lang.reflect.Proxy`
    need to be defined during build time. The interfaces need to be configured in
    proxy-config.json.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态代理：生成的动态代理类是`java.lang.reflect.Proxy`的实例，需要在构建时定义。代理配置需要在`proxy-config.json`中配置接口。
- en: '`jni-config.json.`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jni-config.json.`'
- en: 'Serialization: Java serialization also accesses a lot of class metadata dynamically.
    Even these accesses need to be configured ahead of time.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化：Java序列化也会动态访问大量的类元数据。即使是这些访问也需要提前配置。
- en: 'You can find more details about the other limitations here: [https://www.graalvm.org/reference-manual/native-image/Limitations/](https://www.graalvm.org/reference-manual/native-image/Limitations/).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到有关其他限制的更多详细信息：[https://www.graalvm.org/reference-manual/native-image/Limitations/](https://www.graalvm.org/reference-manual/native-image/Limitations/)。
- en: GraalVM containers
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraalVM容器
- en: 'GraalVM also comes packaged as a Docker container. It can be directly pulled
    from the Docker Registry ([ghcr.io](http://ghcr.io)) or can be used as a base
    image to build custom images. Here are some of the key commands to use GraalVM
    containers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM还打包为Docker容器。可以直接从Docker Registry ([ghcr.io](http://ghcr.io))拉取，也可以用作构建自定义镜像的基础镜像。以下是一些使用GraalVM容器的关键命令：
- en: 'To pull the Docker image: `docker pull ghcr.io/graalvm/graalvm-ce:latest`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取Docker镜像：`docker pull ghcr.io/graalvm/graalvm-ce:latest`
- en: 'To run the container: `docker run -it ghcr.io/graalvm/graalvm-ce:latest bash`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行容器：`docker run -it ghcr.io/graalvm/graalvm-ce:latest bash`
- en: 'To use in the Dockerfile as a base image: `FROM ghcr.io/graalvm/graalvm-ce:latest`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Dockerfile中作为基础镜像使用：`FROM ghcr.io/graalvm/graalvm-ce:latest`
- en: We will be exploring more about GraalVM containers in [*Chapter 9*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169),
    *GraalVM Polyglot – LLVM, Ruby, and WASM*, when we talk about building microservices
    on GraalVM.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到在GraalVM上构建微服务时，我们将在[*第9章*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169)
    *GraalVM Polyglot – LLVM, Ruby, and WASM*中进一步探讨关于GraalVM容器的更多内容。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through Graal just-in-time and ahead-of-time compilers
    in detail. We took sample code and looked at how Graal JIT performs various optimizations.
    We also went through, in detail, how to understand Graal graphs. This is critical
    knowledge that will help in analyzing and identifying optimizations that we can
    do during development, to speed up Graal JIT compilation at runtime.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了Graal的即时编译器和提前编译器。我们取了示例代码并查看Graal JIT如何执行各种优化。我们还详细介绍了如何理解Graal图。这是在开发期间分析和识别我们可以做的优化，以加快运行时Graal
    JIT编译速度的关键知识。
- en: The chapter provided detailed instructions on how to build native images, and
    how to optimize native images using profile-guided optimization. We took sample
    code and compiled native image, and also found out how a native image works internally.
    We identified code issues that might cause native images to run slower than just-in-time
    compilers. We also covered the limitations of native images, and when to use native
    images. We explored various build time and runtime configurations to optimize
    a build and running native images.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于如何构建原生图像以及如何使用配置文件引导优化来优化原生图像的详细说明。我们取了示例代码并编译了原生图像，还发现了原生图像的内部工作原理。我们识别了可能导致原生图像运行速度比即时编译器慢的代码问题。我们还涵盖了原生图像的限制以及何时使用原生图像。我们探索了各种构建时间和运行时配置以优化构建和运行原生图像。
- en: In the next chapter, we will get into understanding the Truffle language implementation
    framework and how to build polyglot applications.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解Truffle语言实现框架以及如何构建多语言应用。
- en: Questions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are native images created?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生镜像是如何创建的？
- en: What is points-to analysis?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是指针分析？
- en: What is region analysis?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是区域分析？
- en: What are the Serial GC and the G1 GC?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是串行GC和G1 GC？
- en: How do you optimize native images? What is PGO?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何优化原生镜像？什么是PGO？
- en: What are the limitations of native images?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生镜像有哪些限制？
- en: Further reading
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: GraalVM Enterprise edition ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM Enterprise版本 ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
- en: Graal VM Native Image documents ([https://www.graalvm.org/reference-manual/native-image/](https://www.graalvm.org/reference-manual/native-image/))
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graal VM Native Image文档 ([https://www.graalvm.org/reference-manual/native-image/](https://www.graalvm.org/reference-manual/native-image/))
