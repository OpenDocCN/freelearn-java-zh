- en: '*Chapter 5*: Graal Ahead-of-Time Compiler and Native Image'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graal ahead-of-time compilation helps build native images that start up faster,
    and have a smaller footprint than traditional Java applications. Native images
    are critical for modern-day cloud-native deployments. GraalVM comes bundled with
    a tool called `native-image` that is used to compile ahead of time and generate
    native images.
  prefs: []
  type: TYPE_NORMAL
- en: '`native-image` compiles the code into an executable that can run standalone
    without a virtual machine. The executable includes all the classes, dependencies,
    libraries, and more importantly, all the virtual machine functionalities such
    as memory management, thread management, and so on. The virtual machine functionality
    is packaged as a runtime called Substrate VM. We briefly covered Substrate VM
    in [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    in the *Substrate VM (Graal AOT and native image)* section. In this chapter, we
    will gain a deeper understanding of native images. We will learn how to build,
    run, and optimize native images with a sample.'
  prefs: []
  type: TYPE_NORMAL
- en: Native images can only perform static code optimizations and do not have the
    advantage of runtime optimizations that just-in-time compilers perform. We will
    explore profile-guided optimization, which is a technique that can be used to
    optimize native images, by using runtime profiling data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to build and run native images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the architecture of a native image, and how the compilation works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring various tools, compilers, and runtime configurations to analyze and
    optimize the way native images are built and executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to optimize native images using **Profile-Guided Optimization**
    (**PGO**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the limitations of native images, and how to overcome these limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how memory is managed by native images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a clear understanding of Graal ahead-of-time
    compilation and hands-on experience in building and optimizing native images.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the following tools and sample code for exploring and understanding
    Graal ahead-of-time compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`native-image` tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraalVM Dashboard**: We will be using GraalVM Dashboard in this chapter to
    analyze the native images that we create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access to GitHub**: There are some sample code snippets, which are available
    in a Git repository. The code can be downloaded from [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter05).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3ftfzNr.](https://bit.ly/3ftfzNr.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building native images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a native image, using the Graal Native Image
    builder (`native-image`).Let's start by installing the Native Image builder.
  prefs: []
  type: TYPE_NORMAL
- en: '`native-image` can be installed using GraalVM Updater with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The tool is directly installed in the `/bin` folder of `GRAALVM_HOME`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create a native image of `FibonacciCalculator`, from the *Graal compiler
    configurations* section in [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a native image, compile the Java file and run `native-image FibonacciCalculator
    –no-fallback -noserver`. The following screenshot shows the output after running
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – FibonacciCalculator – generating a Native Image console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – FibonacciCalculator – generating a Native Image console output
  prefs: []
  type: TYPE_NORMAL
- en: 'Native Image compilation takes time, as it has to perform a lot of static code
    analysis to optimize the image that is generated. The following diagram shows
    the flow of ahead-of-time compilation performed by the Native Image builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Native Image pipeline flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Native Image pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand this picture better:'
  prefs: []
  type: TYPE_NORMAL
- en: The ahead-of-time compiler loads all the application code and dependency libraries
    and classes and packages them along with the Java Development Kit classes and
    Substrate VM classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substrate VM has all the virtual machine functionality that is required to run
    the application. This includes memory management, garbage collection, thread management,
    scheduling, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compiler then performs the following optimization on the code before building
    the native image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. `META-INF/native-image/reflect-config.json`). It is also possible to configure
    other dynamic features such as JNI, proxies, and so on. The configuration files
    need to be in `CLASSPATH`, then the compiler takes care of including these features
    in the final native image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. `static` and `static final` fields, `enum` constants, `java.lang.Class` objects,
    and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final native image has the code section, where the final optimized binary
    code is placed, and in the data section of the executable, the heap image is written.
    This will help load the native image quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a higher-level flow of how points-to analysis and region analysis work
    at build time and runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Native Image pipeline – points-to analysis and region analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Native Image pipeline – points-to analysis and region analysis
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this picture in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: At build time, the points-to analysis scans through the application code, dependencies,
    and JDK to find reachable code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region analysis captures the heap region metadata, which includes region
    mappings and the region entry/exit. Region analysis also uses the reachable code
    to identify which static elements need to be initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is generated with the reachable code and the region metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime, the heap allocator allocates ahead of time using the region mappings
    and the region manager handles the entry and exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now run the native image by issuing `./fibonaccicalculator` from the
    command line. The following is a screenshot of executing the native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – FibonacciCalculator – running fibonaccicalculator native image
    console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – FibonacciCalculator – running fibonaccicalculator native image
    console output
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest disadvantages of ahead-of-time compilation is that the compiler
    never gets to profile the runtime to optimize the code, which happens very well
    with just-in-time compilation. To bring the best of both worlds together, we can
    use the PGO technique. We covered PGO briefly in [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054),
    *GraalVM Architecture*. Let's see it in action and understand it in a little more
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the native image with GraalVM Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To gain a deeper understanding of how the points-to analysis and region analysis
    works, we can use GraalVM Dashboard. In this section, we will create a dump while
    building the native image and use GraalVM to visualize the Native Image builder
    perform points-to analysis and region analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the section *Debugging and Monitoring applications* from [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*, we briefly covered GraalVM Dashboard. GraalVM Dashboard
    is a very powerful tool specifically for native images. In this section, we will
    generate a dashboard dump of our `FibonnacciCalculator` sample, and explore how
    we can use GraalVM Dashboard to gain insights into the native image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the dashboard dump, we have to use the `-H:DashboardDump=<name
    of the file>` flag. For our `FibonacciCalculator`, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output generated by this command. The command
    created a `dashboard.bgv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – FibonacciCalculator – generating the dashboard dump console
    output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – FibonacciCalculator – generating the dashboard dump console output
  prefs: []
  type: TYPE_NORMAL
- en: 'We also used the `-H:DashboardAll` flag to dump all the parameters. The following
    are alternative flags that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-H:+DashboardHeap`: This flag only dumps the image heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-H:+DashboardCode`: This flag generates the code size, broken down by method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-H:+DashboardPointsTo`: This flag creates a dump of the points-to analysis
    that the Native Image builder has performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's load this `dashboard.bgv`, and analyze the results. We need to upload
    the `dashboard.bgv` file to GraalVM Dashboard. Open the browser and go to [https://www.graalvm.org/docs/tools/dashboard/](https://www.graalvm.org/docs/tools/dashboard/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We should then see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – GraalVM Dashboard home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – GraalVM Dashboard home page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **+ Load data** button at the top left. You will get a dialog
    box as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Upload dashboard dump file window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Upload dashboard dump file window
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `dashboard.bgv` file that we generated. You will immediately see
    the dashboard, as shown in *Figure 5.8*. You will find two reports that are generated
    on the left side – **Code Size Breakdown** and **Heap Size Breakdown**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code size breakdown report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code size breakdown report provides the size of the code of various classes
    categorized into blocks. The size of the block represents the size of the code.
    The following figure shows the initial dashboard screen when we select the `dashboard.bgv`
    we generated in the previous section. By hovering over the blocks, we get more
    clear size breakdowns by method. We can double-click on these blocks to dig down
    deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Code size breakdown dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Code size breakdown dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the report we see when we double-click on the
    FibonacciCalculator block. Once again, we can double-click on the call graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Code size breakdown – details report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Code size breakdown – details report
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the call graph. This helps us understand the
    points-to analysis that the Native Image builder has performed. This can be used
    to identify opportunities to optimize the source code if we identify any classes''
    or methods'' dependencies that are not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Code points-to dependency report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Code points-to dependency report
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at heap size breakdown.
  prefs: []
  type: TYPE_NORMAL
- en: Heap size breakdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heap size breakdown provides a detailed insight into heap allocation and also
    provides a deep dive into the heap. We can double-click on these blocks to understand
    these heap allocations. The following screenshot shows the heap size breakdown
    report for `FibonacciCalculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Heap Size Breakdown dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Heap Size Breakdown dashboard
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how we can use GraalVM Dashboard to analyze native
    images. Now let's look at how we can optimize our native images using PGO.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PGO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using PGO, we can run the native image with an option to generate a runtime
    profile. The JVM creates a profile file, `.iprof`, which can be used to recompile
    the native image, to further optimize it. The following diagram (recall it from
    the *Profile Guided Optimization (PGO)* section in [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054)*,*
    *GraalVM Architecture*) shows how PGO works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Native Image – profile-guided optimization pipeline flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Native Image – profile-guided optimization pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the native image compilation pipeline flow using
    PGO. Let''s understand this flow better:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial native image is instrumented to create a profile by passing the
    `–pgo-instrument` flag argument, while bundling the native image. This will generate
    a native image with instrumentation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run the native image with several inputs, a profile is created by the
    native image. This profile is a file generated in the same directory with the
    `.iprof` extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have run through all the use cases, to ensure that the profile created
    covers all the paths. We can then rebuild the native image by passing the `.iprof`
    file as a parameter along with the `--pgo` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will generate the optimized native image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now build an optimized native image of our `FibonacciCalculator` class.
    Let''s first start by creating an instrumented native image by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will build the native image using the profile information. The
    following screenshot shows the output of building the native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – FibonacciCalculator – generating PGO profile console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – FibonacciCalculator – generating PGO profile console output
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate the `fibonaccicalculator.iprof` file in the current directory.
    Let''s now use this profile to rebuild our native image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will rebuild the native image, with the optimum executable. The following
    screenshot shows the output when we build the native image with the profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – FibonacciCalculator – generating profile-guided optimized native
    image console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – FibonacciCalculator – generating profile-guided optimized native
    image console output
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s execute the optimized file. The following screenshot shows the output
    results when we run the optimized native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – FibonacciCalculator – running PGO image console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – FibonacciCalculator – running PGO image console output
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it''s much faster than the original native image. Let''s now
    compare the values. The following graph shows the compression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – FibonacciCalculator – native image versus PGO native image
    comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – FibonacciCalculator – native image versus PGO native image comparison
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, PGO performs much faster and better.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is all good, if you compare this with the JIT, we see that native
    image does not perform so well. Let''s compare this with JIT (both Graal and Java
    HotSpot). The following graph shows the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – FibonacciCalculator – Graal JIT versus Java HotSpot versus
    native image versus PGO native image comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – FibonacciCalculator – Graal JIT versus Java HotSpot versus native
    image versus PGO native image comparison
  prefs: []
  type: TYPE_NORMAL
- en: This highlights one of the key points, that native images are not always optimum.
    In this case, it is definitely not, because of the heap allocation that we are
    doing with the large arrays that we are building. This directly impacts the performance.
    This is one of the areas where it's important as a developer to optimize the code.
    Native images use the Serial GC, hence it's not a good idea to use native images
    for large heaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s optimize the code and see if native images run faster than JIT. Here
    is the optimized code, which does the exact same logic, but uses less Heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the final results of running this code with Graal JIT and Native Image.
    As you''ll see in the following screenshots, Native Image does not take any time
    for startup and performs much faster than JIT. Let''s run the optimized code with
    Graal JIT. Following is the output after running the optimized code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – FibonacciCalculator2 – running optimized code with Graal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – FibonacciCalculator2 – running optimized code with Graal
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the native image of the optimized code. The next screenshot
    shows the output after running the native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – FibonacciCalculator2 – running optimized code as a native image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – FibonacciCalculator2 – running optimized code as a native image
  prefs: []
  type: TYPE_NORMAL
- en: 'If you chart the performance, you can see a significant improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – FibonacciCalculator2 – Graal JIT versus Native Image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – FibonacciCalculator2 – Graal JIT versus Native Image
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand the limitations of AOT compilation and use the
    right approach. Let's quickly go through some of the compiler configurations for
    building native images.
  prefs: []
  type: TYPE_NORMAL
- en: Native image configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A native image build is highly configurable and it is always recommended to
    provide all the build configuration in the `native-image.properties` file. As
    the `native-image` tool takes a JAR file as an input, it is recommended to package
    `native-image.properties` in `META-INF/native-image/<unique-application-identifier>`
    within the JAR file. A unique application identifier is used to avoid any collision
    of resources. These paths have to be unique, as they will be configured on `CLASSPATH`.
    The `native-image` tool uses `CLASSPATH` to load these resources while building.
    Apart from `native-image.properties`, there are various other configuration files
    that can be packaged. We will cover some of the important configurations in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the typical format of the `native-image.properties` file followed
    by an explanation of each of the sections in the properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Requires`: The `Requires` property is used to list all the language examples,
    such as `language:llvm` `language:python.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JavaArgs`: We can pass regular Java arguments using this property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageName`: This can be used to provide a custom name for the native image
    that is generated. By default, the native image is named after the JAR file or
    Mainclass file (all in lowercase letters). For example, our `FibonnaciCalculator.class`
    generates `fibonaccicalculator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Args`: This is the most commonly used property. It can be used to provide
    the native-image arguments. The arguments can also be passed from the command
    line, but it is much better from the configuration management perspective to have
    them listed in `native-image.properties`, so that it can go into Git (or any source
    code repository) and track any changes. The following table explains some of the
    important arguments that are typically used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B16878_Table_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please refer to [https://www.graalvm.org/reference-manual/native-image/Options/](https://www.graalvm.org/reference-manual/native-image/Options/)
    for the complete list of options.
  prefs: []
  type: TYPE_NORMAL
- en: Hosted options and resource configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can configure various resources using various parameters. These resource
    declarations are normally configured in an external JSON file, and various `-H:`
    flags can be made to point to these resource files. The syntax is `-H<Resource
    Flag>=${.}/jsonfile.json`. The following table lists some of the important arguments
    that are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16878_Table_5.1a.jpg)![](img/B16878_Table_5.1b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`native-images.properties` captures all the configuration parameters, and it
    is a good practice to pass configurations through the `native-image.properties`
    file, as it''s easy to manage it in a source code configuration management tool.'
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM comes with an agent that tracks the dynamic features of a Java program
    at runtime. This helps in identifying and configuring the native image build with
    dynamic features. To run the Java application with the Native image agent, we
    need to pass `-agentlib:native-image-agent=config-output-dir=<path to config dir>`.
    The agent tracks the execution and intercepts calls that look up classes, methods,
    resources, and proxies. The agent then generates `jni-config.json`, `reflect-config.json`,
    `proxy-config.json`, and `resource-config.json` in the config directory passed
    as the parameter. It's a good practice to run the application multiple times,
    with different test cases, to ensure that the complete code is covered, and the
    agent gets to catch most of the dynamic calls. When we run iterations, it is important
    to use `-agentlib:native-image-agent=config-merge-dir=<path to config dir>` so
    that the configuration files are not overwritten but merged.
  prefs: []
  type: TYPE_NORMAL
- en: We can generate Graal graphs with native images, to analyze how the native image
    is running. In the next section, we will explore how to generate these Graal graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Graal graphs for native images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graal graphs can be generated even for native images. Graal graphs can be generated
    during build time or at runtime. Let's explore this feature in this section using
    our `FibonnaciCalculator` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate the dump for `FibonacciCalculator` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates a lot of graphs for every class that is initialized.
    We can use the `-H:MethodFilter` flag to specify the class and method that we
    want to generate a graph for. The command would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the section *Graal intermediate representation* from [*Chapter
    4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077), *Graal Just-In-Time Compiler*,
    to know how to read these graphs and understand opportunities for optimizing the
    code. Optimizing the source code is critical for native images as there are no
    runtime optimizations like we have in just-in-time compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how native images manage memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Native images come bundled with Substrate VM, which has the functionality of
    managing memory, including garbage collection. As we saw in the *Building native
    images* section, the heap allocation happens as part of the image creation to
    speed up the startup. These are classes that are initialized at build time. Refer
    to *Figure 5.3* to see how the Native Image builder initialized the heap region
    after performing static region analysis. At runtime, a garbage collector manages
    the memory. There are two garbage collection configurations that the Native Image
    builder supports. Let's understand these two garbage collection configurations
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: The Serial garbage collector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Serial Garbage Collector (GC) is the default that gets built into the native
    image. This is available both on the Community and Enterprise edition. This garbage
    collector is optimized for a low memory footprint and small heap size. We can
    use the `--gc=serial` flag to explicitly use the Serial GC. The Serial GC is a
    simple implementation of the GC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Serial GC divides the heap into two regions, that is, young and old. The
    following figure shows how the Serial GC works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Serial GC heap architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – Serial GC heap architecture
  prefs: []
  type: TYPE_NORMAL
- en: The young generation is used for new objects. It is triggered when the young
    generation block is full and all the objects that are not used are reclaimed.
    When the old generation blocks become full, a full collection is triggered. Young
    collections run faster and a full collection is more time-consuming at runtime.
    This behavior can be tweaked using the argument `-XX:PercentTimeInIncrementalCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this percentage is 50\. This can be increased to reduce the number
    of full collections, improving the performance, but will have a negative effect
    on the memory size. Depending on the memory profiling, while testing the application,
    we can optimize this parameter for better performance and memory footprint. Here
    is an example of how to pass this parameter at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This parameter can also be passed at build time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are other arguments that can also be used for fine-tuning, such as `-XX:MaximumYoungGenerationSizePercent`.
    This argument can be used to tweak the maximum percentage the young generation
    block should occupy of the overall heap.
  prefs: []
  type: TYPE_NORMAL
- en: The Serial GC is single-threaded and works well for small heaps. The following
    figure shows how the Serial GC works. The application threads are paused to reclaim
    the memory. It is called a *Stop the World* event. During this time, the **Garbage
    Collector Thread** runs and reclaims the memory. This has an impact on the performance
    of the application if the heap size is large and if there are a lot of threads
    running. The Serial GC is very good for small processes with small heap sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Serial GC heap flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.22 – Serial GC heap flow
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Serial GC assumes an 80% heap size, before it starts the GC
    thread. This can be changed using the `-XX:MaximumHeapSizePercent` flag. There
    are other flags that can be used to fine-tune the performance of the Serial GC.
  prefs: []
  type: TYPE_NORMAL
- en: The G1 Garbage Collector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The G1 Garbage Collector is the more recent and advanced implementation of the
    garbage collector. This is only available in the Enterprise edition. The G1 Garbage
    Collector can be enabled using the flag `--gc=G1`. G1 provides the right balance
    of throughput and latency. Throughput is the average time spent running the code
    versus GC. Higher throughput means we have more CPU cycles for code, rather than
    the GC thread. Latency is the amount of time the *Stop The World* event takes
    or the time taken to pause the code execution. The less latency, the better for
    us. G1 targets high throughput and low latency. Here is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: G1 divides the whole heap into small regions. G1 runs concurrent threads to
    find all live objects, and the Java application is never paused, and keeps track
    of all the pointers between regions, and tries to collect regions so that there
    are shorter pauses in the program. G1 might also move live objects and consolidate
    them into regions and tries to make the regions empty.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – G1 GC heap flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_5.23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – G1 GC heap flow
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram shows how G1 GC works by dividing into regions. The allocation
    of objects into the regions is based on trying to allocate memory in empty regions
    and trying to empty the regions by consolidating the objects into regions, like
    partitioning and de-partitioning. The idea is to optimally manage and collect
    the regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'G1 garbage collector has a larger footprint than the Serial GC and is for longer-running,
    larger heap sizes. There are various parameters that can be used to fine-tune
    the performance of G1 GC. Listed next are some of them (`-H` are the parameters
    passed during the building of the image and `-XX` is passed while running the
    image):'
  prefs: []
  type: TYPE_NORMAL
- en: '`-H:G1HeapRegionSize`: This is the size of each region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-`XX:MaxRAMPercentage`: Percentage of physical memory size that is used as
    the heap size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:ConcGCThreads`: Number of concurrent GC threads. This needs to be optimized
    for the best performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:G1HeapWastePercent`: The garbage collector stops claiming when it reaches
    this percentage. This will allow lower latency and higher throughput, however,
    it is critical to set an optimum value, as if it''s too high, then the objects
    will never get collected, and the application memory footprint will always be
    high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of using the right garbage collector and the configuration is critical
    for the performance and memory footprint of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the heap size and generating heap dumps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heap size can be manually set using the following runtime parameters passed
    to the native image while running them. `-Xmx` sets the maximum heap size, `-Xms`
    sets the minimum heap size, and `-Xmn` sets the size of the young generation region,
    in bytes. Here is an example of how these arguments can be used at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At build time, we can pass arguments to configure the heap size. This is a
    critical configuration and has to be done with a lot of care as this has a direct
    impact on the memory footprint and performance of the native image. The following
    command is an example that configures the minimum heap size, maximum heap size,
    and the maximum new size of the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Heap dumps are the most important for debugging any memory leaks and memory
    management issues. We typically use tools such as VisualVM to do such heap dump
    analysis. Native images are not built with `-H:+AllowVMInspection` flag. This
    will create a native image that can generate a stack dump when we send a USR1
    signal (`sudo kill -USR1` or `-SIGUSR1` or `QUIT/BREAK` keys) and a runtime compilation
    information dump when we send a USR2 signal (`sudo kill -USR2` or `-SIGUSR2` –
    you can check the exact signal using the `kill -l` command). This feature is available
    only in the Enterprise edition.
  prefs: []
  type: TYPE_NORMAL
- en: We can also programmatically create heap dumps by calling `org.graalvm.nativeimage.VMRuntime#dumpHeap`
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: Building static native images and native shared libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static native images are statically linked binaries that do not need any additional
    dependent libraries at runtime. These are very useful when we are building microservice
    applications as native images so that they can be easily packaged into Docker,
    without worrying about dependencies. Static images are best for building container-based
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, this feature is only available for Linux AMD64
    on Java 11\. Please refer to [https://www.graalvm.org/reference-manual/native-image/StaticImages/](https://www.graalvm.org/reference-manual/native-image/StaticImages/)
    for the latest updates and the process of building static native images.
  prefs: []
  type: TYPE_NORMAL
- en: The Native Image builder also builds shared libraries. Sometimes you may want
    to create your code as a shared library that is used by some other application.
    For that, you have to pass the `–shared` flag to build a shared library, instead
    of an executable one.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging native images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging a native image requires building the image with debug info. We can
    use `-H:GenerateDebugInfo=1`. Here is an example of using this argument for `FibonnacciCalculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated image has debug information in the form of the **GNU Debugger**
    (**GDB**). This can be used to debug the code at runtime. The following shows
    the output of running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a `sources` directory, which holds the cache that is generated
    by the native image builder. This cache brings JDSK, GraalVM, and application
    classes to help with debugging. The following is the output of listing the contents
    of the `sources` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To debug native images, we need the `gdb` utility. Please refer to [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)
    for how to install `gdb` for your target machine. Once properly installed, we
    should be able to enter the `gdb` shell by executing the `gdb` command. The following
    shows the typical output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to point to the directories where we generated the source files in
    the previous step. We can do that by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once the environment is set, we can use `gdb` to set the breakpoints and debug.
    Please refer to [https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)
    for detailed documentation on how to use `gdb` to debug executables.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, debug information can be used to perform breakpoints,
    single-stepping, stack backtrace, printing primitive values, the casting and printing
    of objects, path expressions, and references by method name and static data. Please
    refer to [https://www.graalvm.org/reference-manual/native-image/DebugInfo/](https://www.graalvm.org/reference-manual/native-image/DebugInfo/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Graal AOT (Native Image)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through some of the limitations of Graal AOT and
    native images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graal ahead-of-time compilation performs static analysis with the closed-world
    assumption. It assumes that all the classes that are reachable at runtime are
    available during build time. This has a direct implication on writing any code
    that requires dynamic loading – such as Reflection, JNI, Proxies, and so on. However,
    the Graal AOT compiler (`native-image`) provides a way to provide this metadata
    in the form of JSON manifest files. These files can be packaged along with the
    JAR file, as an input for the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading classes dynamically: Classes that are loaded at runtime, which will
    not be visible to the AOT compiler at build time, need to be specific in the configuration
    file. These configuration files are typically saved under `META-INF/native-image/`,
    and should be in `CLASSPATH`. If the class is not found during the compilation
    of the configuration file, it will throw a `ClassNotFoundException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reflection: Any call to the `java.lang.reflect` API to list the methods and
    fields or invoke them using the reflection API has to be configured in the `reflect-config.json`
    file under `META-INF/native-image/`. The compiler tries to identify these reflective
    elements through static analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic Proxy: Dynamic proxy classes that are generated instances of `java.lang.reflect.Proxy`
    need to be defined during build time. The interfaces need to be configured in
    proxy-config.json.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jni-config.json.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Serialization: Java serialization also accesses a lot of class metadata dynamically.
    Even these accesses need to be configured ahead of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more details about the other limitations here: [https://www.graalvm.org/reference-manual/native-image/Limitations/](https://www.graalvm.org/reference-manual/native-image/Limitations/).'
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraalVM also comes packaged as a Docker container. It can be directly pulled
    from the Docker Registry ([ghcr.io](http://ghcr.io)) or can be used as a base
    image to build custom images. Here are some of the key commands to use GraalVM
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To pull the Docker image: `docker pull ghcr.io/graalvm/graalvm-ce:latest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the container: `docker run -it ghcr.io/graalvm/graalvm-ce:latest bash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use in the Dockerfile as a base image: `FROM ghcr.io/graalvm/graalvm-ce:latest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be exploring more about GraalVM containers in [*Chapter 9*](B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169),
    *GraalVM Polyglot – LLVM, Ruby, and WASM*, when we talk about building microservices
    on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through Graal just-in-time and ahead-of-time compilers
    in detail. We took sample code and looked at how Graal JIT performs various optimizations.
    We also went through, in detail, how to understand Graal graphs. This is critical
    knowledge that will help in analyzing and identifying optimizations that we can
    do during development, to speed up Graal JIT compilation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter provided detailed instructions on how to build native images, and
    how to optimize native images using profile-guided optimization. We took sample
    code and compiled native image, and also found out how a native image works internally.
    We identified code issues that might cause native images to run slower than just-in-time
    compilers. We also covered the limitations of native images, and when to use native
    images. We explored various build time and runtime configurations to optimize
    a build and running native images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get into understanding the Truffle language implementation
    framework and how to build polyglot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are native images created?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is points-to analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is region analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the Serial GC and the G1 GC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you optimize native images? What is PGO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the limitations of native images?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM Enterprise edition ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graal VM Native Image documents ([https://www.graalvm.org/reference-manual/native-image/](https://www.graalvm.org/reference-manual/native-image/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
