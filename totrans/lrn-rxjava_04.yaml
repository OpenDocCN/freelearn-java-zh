- en: Combining Observables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并 Observables
- en: We have covered many operators that suppress, transform, reduce, and collect
    emissions. These operators can do a lot of work, but what about combining multiple
    Observables and consolidating them into one? If we want to accomplish more with
    ReactiveX, we need to take multiple streams of data and events and make them work
    together, and there are operators and factories to achieve this. These combining
    operators and factories also work safely with Observables occurring on different
    threads (discussed in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization*).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了许多抑制、转换、减少和收集发射的操作符。这些操作符可以做很多工作，但关于将多个 Observable 合并并统一它们呢？如果我们想用 ReactiveX
    完成更多的工作，我们需要将多个数据流和事件流结合起来，使它们协同工作，并且有操作符和工厂可以实现这一点。这些组合操作符和工厂也可以安全地与在不同线程上发生的
    Observables 一起工作（在第 6 章[4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml]，*并发与并行化*中讨论）。
- en: 'This is where we start to transition from making RxJava useful to making it
    powerful. We will cover the following operations to combine Observables:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始从使 RxJava 有用转变为使其强大的地方。我们将介绍以下操作来合并 Observables：
- en: Merging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并
- en: Concatenating
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: Ambiguous
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不明确
- en: Zipping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Combine latest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合最新
- en: Grouping
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组
- en: Merging
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并
- en: A common task done in ReactiveX is taking two or more `Observable<T>` instances
    and merging them into one `Observable<T>`. This merged `Observable<T>` will subscribe
    to all of its merged sources simultaneously, making it effective for merging both
    finite and infinite Observables. There are a few ways that we can leverage this
    merging behavior using factories as well as operators.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ReactiveX 中，一个常见的任务是将两个或多个 `Observable<T>` 实例合并成一个 `Observable<T>`。这个合并的 `Observable<T>`
    将会同时订阅其所有合并的源，这使得它对于合并有限和无限 Observable 都非常有效。我们可以通过工厂以及操作符来利用这种合并行为。
- en: Observable.merge() and mergeWith()
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable.merge()` 和 `mergeWith()`'
- en: The `Observable.merge()` operator will take two or more `Observable<T>` sources
    emitting the same type `T` and then consolidate them into a single `Observable<T>`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.merge()` 操作符将接受两个或更多发射相同类型 `T` 的 `Observable<T>` 源，并将它们合并成一个单一的
    `Observable<T>`。'
- en: 'If we have only two to four `Observable<T>` sources to merge, you can pass
    each one as an argument to the `Observable.merge()` factory. In the following
    code snippet, I have merged two `Observable<String>` instances into one `Observable<String>`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只有两个到四个要合并的 `Observable<T>` 源，你可以将每个源作为参数传递给 `Observable.merge()` 工厂。在下面的代码片段中，我将两个
    `Observable<String>` 实例合并成了一个 `Observable<String>`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alternatively, you can use `mergeWith()`, which is the operator version of `Observable.merge()`**:**
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `mergeWith()`，它是 `Observable.merge()` 操作符的版本**：**
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Observable.merge()` factory and the `mergeWith()` operator will subscribe
    to all the specified sources simultaneously, but will likely fire the emissions
    in order if they are cold and on the same thread. This is just an implementation
    detail, and you should use `Observable.concat()` if you explicitly want to fire
    elements of each `Observable` sequentially and keep their emissions in a sequential
    order.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.merge()` 工厂和 `mergeWith()` 操作符将同时订阅所有指定的源，但如果它们是冷源并且在同一线程上，则可能会按顺序触发发射。这只是一个实现细节，如果你明确想要按顺序触发每个
    `Observable` 的元素并保持它们的发射顺序，应使用 `Observable.concat()`。'
- en: You should not rely on ordering when using merge factories and operators even
    if ordering seems to be preserved. Having said that, the order of emissions from
    each source Observable is maintained. The way the sources are merged is an implementation
    detail, so use concatenation factories and operators if you want to guarantee
    order.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使看起来顺序被保留了，在使用合并工厂和操作符时也不应依赖于顺序。话虽如此，每个源 Observable 的发射顺序是保持的。源是如何合并的是实现细节，所以如果你想保证顺序，应使用连接工厂和操作符。
- en: 'If you have more than four `Observable<T>` sources, you can use the `Observable.mergeArray()`
    to pass a varargs of `Observable[]` instances that you want to merge, as shown
    in the following code snippet. Since RxJava 2.0 was written for JDK 6+ and has
    no access to a `@SafeVarargs` annotation, you will likely get some type safety
    warnings:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多于四个 `Observable<T>` 源，你可以使用 `Observable.mergeArray()` 来传递一个包含你想要合并的 `Observable[]`
    实例的 varargs，如下面的代码片段所示。由于 RxJava 2.0 是为 JDK 6+ 编写的，并且没有访问 `@SafeVarargs` 注解，你可能会收到一些类型安全警告：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can pass `Iterable<Observable<T>>` to `Observable.merge()` as well. It
    will merge all the `Observable<T>` instances in that `Iterable`. I could achieve
    the preceding example in a more type-safe way by putting all these sources in
    `List<Observable<T>>` and passing them to `Observable.merge()`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `Iterable<Observable<T>>` 传递给 `Observable.merge()`。它将合并该 `Iterable` 中所有的
    `Observable<T>` 实例。我可以通过将这些源放入 `List<Observable<T>>` 并将它们传递给 `Observable.merge()`
    来以前更安全的方式实现上述示例：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason `mergeArray()` gets its own method and is not a `merge()` overload
    instead is to avoid ambiguity with the Java 8 compiler and its treatment with
    functional types. This is true for all the `xxxArray()` operators.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeArray()` 获得自己的方法而不是作为 `merge()` 的重载，原因是为了避免与 Java 8 编译器及其对函数类型的处理产生歧义。这对于所有
    `xxxArray()` 操作符都适用。'
- en: 'The `Observable.merge()` works with infinite Observables. Since it will subscribe
    to all Observables and fire their emissions as soon as they are available, you
    can merge multiple infinite sources into a single stream. Here, we merge two `Observable.interval()`
    sources that emit at one second and 300 millisecond intervals, respectively. But
    before we merge, we do some math with the emitted index to figure out how much
    time has elapsed and emit it with the source name in a string. We let this process
    run for three seconds:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.merge()` 与无限可观察对象一起工作。由于它将订阅所有可观察对象并在它们可用时立即触发它们的发射，因此您可以将多个无限源合并成一个单一的流。在这里，我们合并了两个分别以一秒和300毫秒间隔发射的
    `Observable.interval()` 源。但在合并之前，我们使用发射的索引进行一些数学运算，以确定已经过去的时间，并将其与源名称一起以字符串形式发射。我们让这个过程运行三秒钟：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To summarize, `Observable.merge()` will combine multiple `Observable<T>` sources
    emitting the same type `T` and consolidate into a single `Observable<T>`. It works
    on infinite Observables and does not necessarily guarantee that the emissions
    come in any order. If you care about the emissions being strictly ordered by having
    each `Observable` source fired sequentially, you will likely want to use `Observable.concat()`,
    which we will cover shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Observable.merge()` 将多个发射相同类型 `T` 的 `Observable<T>` 源合并并整合成一个单一的 `Observable<T>`。它适用于无限可观察对象，并且并不保证发射的顺序。如果您关心发射的严格顺序，并且希望每个
    `Observable` 源按顺序触发，那么您可能希望使用 `Observable.concat()`，我们将在稍后介绍。
- en: flatMap()
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`flatMap()`'
- en: One of the most powerful and critical operators in RxJava is `flatMap()`. If
    you have to invest time in understanding any RxJava operator, this is the one.
    It is an operator that performs a dynamic `Observable.merge()` by taking each
    emission and mapping it to an `Observable`. Then, it merges the emissions from
    the resulting Observables into a single stream.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 中，`flatMap()` 是最强大且至关重要的操作符之一。如果您必须投入时间来理解任何 RxJava 操作符，那么这个就是您需要关注的。它是一个执行动态
    `Observable.merge()` 的操作符，通过将每个发射映射到一个 `Observable`。然后，它将结果可观察对象的发射合并成一个单一的流。
- en: 'The simplest application of `flatMap()` is to map *one emission to many emissions*.
    Say, we want to emit the characters from each string coming from `Observable<String>`**.**
    We can use `flatMap()` to specify a `Function<T,Observable<R>>` lambda that maps
    each string to an `Observable<String>`**, **which will emit the letters. Note
    that the mapped `Observable<R>` can emit any type `R`, different from the source
    `T` emissions.  In this example, it just happened to be `String`, like the source:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()` 的最简单应用是将 *一个发射映射到多个发射*。比如说，我们想要发射来自 `Observable<String>` 的每个字符串中的字符。我们可以使用
    `flatMap()` 来指定一个 `Function<T,Observable<R>>` lambda，它将每个字符串映射到一个 `Observable<String>`，这将发射字母。请注意，映射的
    `Observable<R>` 可以发射任何类型的 `R`，这与源 `T` 的发射不同。在这个例子中，它恰好是 `String`，就像源一样：'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have taken those five string emissions and mapped them (through `flatMap()`)
    to emit the letters from each one. We did this by calling each string's `split()`
    method, and we passed it an empty `String` argument `""`, which will separate
    on every character. This returns an array `String[]` containing all the characters,
    which we pass to `Observable.fromArray()` to emit each one. The `flatMap()` expects
    each emission to yield an `Observable`, and it will merge all the resulting Observables
    and emit their values in a single stream.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这五个字符串输出映射（通过 `flatMap()`）为每个输出中的字母。我们通过调用每个字符串的 `split()` 方法来实现这一点，并传递一个空的字符串参数
    `""`，这将根据每个字符进行分隔。这返回一个包含所有字符的 `String[]` 数组，我们将其传递给 `Observable.fromArray()`
    以输出每个字符。`flatMap()` 期望每个输出产生一个 `Observable`，然后它会合并所有生成的 `Observable` 并以单个流输出它们的值。
- en: 'Here is another example: let''s take a sequence of `String` values (each a
    concatenated series of values separated by `"/"`), use  `flatMap()` on them, and
    filter for only numeric values before converting them into `Integer` emissions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：让我们取一个 `String` 值序列（每个值都是一个由 `"/"` 分隔的值串联），对它们使用 `flatMap()`，然后在将它们转换为
    `Integer` 输出之前只过滤出数值：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We broke up each `String` by the `/` character, which yielded an array. We turned
    that into an `Observable` and used `flatMap()` on it to emit each `String`. We
    filtered only for String values that are numeric using a regular expression `[0-9]+`
    (eliminating `FOXTROT`, `TANGO`, and `WHISKEY`) and then turned each emission
    into an **`Integer`.**
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `/` 字符将每个 `String` 分割，这产生了一个数组。我们将这个数组转换为一个 `Observable`，并使用 `flatMap()`
    在它上面输出每个 `String`。我们使用正则表达式 `[0-9]+`（消除 `FOXTROT`、`TANGO` 和 `WHISKEY`）只过滤出数值字符串，然后将每个输出转换为
    **`Integer`**。
- en: 'Just like `Observable.merge()`, you can also map emissions to infinite `Observables`
    and merge them. For instance, we can emit simple `Integer` values from `Observable<Integer>` but
    use `flatMap()` on them to drive an `Observable.interval()`, where each one serves
    as the period argument. In the following code snippet, we emit the values `2`,
    `3`, `10`, and `7`, which will yield interval Observables that emit at 2 seconds,
    3 seconds, 10 seconds, and 7 seconds, respectively. These four Observables will
    be merged into a single stream:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Observable.merge()` 一样，你还可以将输出映射到无限 `Observable` 并合并它们。例如，我们可以从 `Observable<Integer>`
    中输出简单的 `Integer` 值，但使用 `flatMap()` 来驱动 `Observable.interval()`，其中每个值都作为周期参数。在以下代码片段中，我们输出值
    `2`、`3`、`10` 和 `7`，这将分别产生在 2 秒、3 秒、10 秒和 7 秒输出的间隔 `Observable`。这四个 `Observable`
    将合并成一个单一的流：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Observable.merge()` operator will accept a fixed number of `Observable`
    sources. But `flatMap()` will dynamically keep adding new `Observable` sources
    for each emission that comes in. This means that you can keep merging new incoming
    Observables over time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.merge()` 操作符将接受固定数量的 `Observable` 源。但 `flatMap()` 会根据每个输入的输出动态地添加新的
    `Observable` 源。这意味着你可以随着时间的推移持续合并新的输入 `Observable`。'
- en: 'Another quick note about `flatMap()` is it can be used in many clever ways.
    To this day, I keep finding new ways to use it. But another way you can get creative
    is to evaluate each emission within `flatMap()` and figure out what kind of `Observable`
    you want to return. For example, if my previous example emitted an emission of
    `0` to `flatMap()`, this will break the resulting `Observable.interval()`. But
    I can use an `if` statement to check whether it is `0` and return `Observable.empty()`
    instead, as used in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `flatMap()` 的另一个快速笔记是它可以以许多巧妙的方式使用。时至今日，我仍在不断发现使用它的新方法。但你可以用另一种方式发挥创意，那就是在
    `flatMap()` 中评估每个输出，并确定你想要返回哪种类型的 `Observable`。例如，如果我的前一个例子向 `flatMap()` 输出了一个
    `0`，这将破坏生成的 `Observable.interval()`。但我可以使用一个 `if` 语句来检查它是否为 `0`，并返回 `Observable.empty()`，就像以下代码片段中所示：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, this is probably too clever as you can just put `filter()` before
    `flatMap()` and filter out emissions that are equal to `0`. But the point is that
    you can evaluate an emission in `flatMap()` and determine what kind of `Observable`
    you want to return.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可能有点过于巧妙，因为你可以在 `flatMap()` 前面直接使用 `filter()` 来过滤掉等于 `0` 的输出。但重点是，你可以在 `flatMap()`
    中评估一个输出，并确定你想要返回哪种 `Observable`。
- en: The `flatMap()` is also a great way to take a hot Observable UI event stream
    (such as JavaFX or Android button clicks) and `flatMap()` each of those events
    to an entire process within `flatMap()`. The failure and error recovery can be
    handled entirely within that `flatMap()`, so each instance of the process does
    not disrupt future button clicks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()` 也是将热 Observables UI 事件流（如 JavaFX 或 Android 按钮点击）扁平映射到 `flatMap()`
    内部整个过程的绝佳方式。失败和错误恢复可以完全在 `flatMap()` 内部处理，因此每个流程实例都不会干扰未来的按钮点击。'
- en: If you do not want rapid button clicks to produce several redundant instances
    of a process, you can disable the button using `doOnNext()` or leverage `switchMap()`
    to kill previous processes, which we will discuss in [Chapter 7](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Switching, Throttling, Windowing, and Buffering.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你不想快速按钮点击产生多个冗余的流程实例，你可以使用 `doOnNext()` 禁用按钮，或者利用 `switchMap()` 杀死之前的流程，我们将在第
    7 章[切换、节流、窗口化和缓冲](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml)中讨论。 '
- en: 'Note that there are many flavors and variants of `flatMap()`, accepting a number
    of overloads that we will not get into deeply for the sake of brevity. We can
    pass a second combiner argument, which is a `BiFunction<T,U,R>` lambda, to associate
    the originally emitted `T` value with each flat-mapped `U` value and turn both
    into an `R` value. In our earlier example of emitting letters from each string,
    we can associate each letter with the original string emission it was mapped from:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`flatMap()` 有许多变体和风味，接受许多重载，为了简洁起见，我们不会深入探讨。我们可以传递一个第二个组合器参数，它是一个 `BiFunction<T,U,R>`
    lambda，将最初发射的 `T` 值与每个扁平映射的 `U` 值关联，并将两者都转换为 `R` 值。在我们的早期示例中，我们可以将每个字母与它映射的原始字符串发射关联起来：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also use `flatMapIterable()` to map each `T` emission into an `Iterable<R>`
    instead of an `Observable<R>`. It will then emit all the `R` values for each `Iterable<R>`,
    saving us the step and overhead of converting it into an `Observable`. There are
    also `flatMap()` variants that map to Singles `(flatMapSingle())`, Maybes **`(flatMapMaybe())`**,
    and Completables `(flatMapCompletable())`. A lot of these overloads also apply
    to `concatMap()`, which we will cover next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `flatMapIterable()` 将每个 `T` 发射映射到 `Iterable<R>` 而不是 `Observable<R>`。然后它将为每个
    `Iterable<R>` 发射所有的 `R` 值，从而节省我们将其转换为 `Observable` 的步骤和开销。还有将到 Singles `(flatMapSingle())`、Maybes
    **`(flatMapMaybe())`** 和 Completables `(flatMapCompletable())` 的 `flatMap()` 变体。许多这些重载也适用于
    `concatMap()`，我们将在下一节中介绍。
- en: Concatenation
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接操作
- en: 'Concatenation is remarkably similar to merging, but with an important nuance:
    it will fire elements of each provided `Observable` sequentially and in the order
    specified. It will not move on to the next `Observable` until the current one
    calls `onComplete()`. This makes it great to ensure that merged Observables fire
    their emissions in a guaranteed order. However, it is often a poor choice for
    infinite Observables, as an infinite `Observable` will indefinitely hold up the
    queue and forever leave subsequent Observables waiting.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 连接操作与合并操作非常相似，但有一个重要的细微差别：它将按顺序依次发射每个提供的 `Observable` 的元素，并且按照指定的顺序。它将在当前 `Observable`
    调用 `onComplete()` 之前不会移动到下一个 `Observable`。这使得它非常适合确保合并的 Observables 以保证的顺序发射它们的发射。然而，对于无限
    Observables 来说，这通常是一个较差的选择，因为无限的 `Observable` 将无限期地阻塞队列，并永远让后续的 Observables 等待。
- en: We will cover the factories and operators used for concatenation. You will find
    that they are much like the merging ones except that they have the sequential
    behavior.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍用于连接操作的工厂和算子。你会发现它们与合并操作非常相似，只是它们具有顺序行为。
- en: You should prefer concatenation when you want to guarantee that Observables
    fire their emissions in order. If you do not care about ordering, prefer merging
    instead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要确保 Observables 按顺序发射它们的发射时，你应该选择连接操作。如果你不关心顺序，则选择合并操作。
- en: Observable.concat() and concatWith()
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable.concat()` 和 `concatWith()`'
- en: The `Observable.concat()` factory is the concatenation equivalent to `Observable.merge()`.
    It will combine the emissions of multiple Observables, but will fire each one
    sequentially and only move to the next after `onComplete()` is called.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.concat()` 工厂是 `Observable.merge()` 的连接等价物。它将组合多个 Observables 的发射，但将按顺序依次发射每个，并且只有在调用
    `onComplete()` 之后才会移动到下一个。'
- en: 'In the following code, we have two source Observables emitting strings. We
    can use `Observable.concat()` to fire the emissions from the first one and then
    fire the emissions from the second one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有两个源可观察对象（Observables）发出字符串。我们可以使用`Observable.concat()`来触发第一个可观察对象的发射，然后触发第二个可观察对象的发射：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the same output as our `Observable.merge()` example earlier. But as
    discussed in the merging section, we should use `Observable.concat()` to guarantee
    emission ordering, as merging does not guarantee it. You can also use the `concatWith()`
    operator to accomplish the same thing, as shown in the following code line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前我们的`Observable.merge()`示例的输出相同。但如合并部分所述，我们应该使用`Observable.concat()`来保证发射顺序，因为合并不保证顺序。你还可以使用`concatWith()`操作符来完成相同的事情，如下面的代码行所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we use `Observable.concat()` with infinite Observables, it will forever emit
    from the first one it encounters and prevent any following Observables from firing.
    If we ever want to put an infinite `Observable` anywhere in a concatenation operation,
    it would likely be specified last. This ensures that it does not hold up any Observables
    following it because there are none. We can also use `take()` operators to make
    infinite Observables finite.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`Observable.concat()`与无限可观察对象，它将永远从遇到的第一个可观察对象发出，并阻止任何后续的可观察对象触发。如果我们想在连接操作中任何地方放置一个无限`Observable`，它可能被指定为最后一个。这确保了它不会阻止其后的任何可观察对象，因为后面没有可观察对象。我们还可以使用`take()`操作符将无限可观察对象变为有限。
- en: 'Here, we fire an `Observable` that emits every second, but only take two emissions
    from it. After that, it will call `onComplete()` and dispose it. Then, a second
    `Observable` concatenated after it will emit forever (or in this case, when the
    application quits after five seconds). Since this second `Observable`  is the
    last one specified in `Observable.concat()`, it will not hold up any subsequent
    Observables by being infinite:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们触发一个每秒发出一次的可观察对象，但只从它那里获取两个发射。之后，它将调用`onComplete()`并销毁它。然后，一个在它之后连接的可观察对象将永远发出（或在这种情况下，在应用在五秒后退出时）。由于这个第二个可观察对象是`Observable.concat()`中指定的最后一个，它不会因为无限而阻止任何后续的可观察对象：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are concatenation counterparts for arrays and `Iterable<Observable<T>>`
    inputs as well, just like there is for merging. The `Observable.concatArray()`
    factory will fire off each `Observable` sequentially in an `Observable[]` array.
    The `Observable.concat()` factory will also accept an `Iterable<Observable<T>>`
    and fire off each `Observable<T**>**` in the same manner.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组和`Iterable<Observable<T>>`输入，也存在与合并相同的连接对应物。`Observable.concatArray()`工厂将按顺序在`Observable[]`数组中触发每个`Observable`。`Observable.concat()`工厂也将接受一个`Iterable<Observable<T>>`，并以相同的方式触发每个`Observable<T**>**`。
- en: Note there are a few variants of `concatMap()`. Use `concatMapIterable()` when
    you want to map each emission to an `Iterable<T>` instead of an `Observable<T>`**. **It
    will emit all `T` values for each `Iterable<T>`, saving you the step and overhead
    of turning each one into an `Observable<T>`. There is also a `concatMapEager()`
    operator that will eagerly subscribe to all `Observable` sources it receives and
    will cache the emissions until it is their turn to emit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`concatMap()`有几个变体。当你想要将每个发射映射到`Iterable<T>`而不是`Observable<T>`时，使用`concatMapIterable()`。它将为每个`Iterable<T>`发出所有的`T`值，从而节省了将每个值转换为`Observable<T>`的步骤和开销。还有一个`concatMapEager()`操作符，它将贪婪地订阅它接收到的所有`Observable`源，并将发射缓存起来，直到轮到它们发射。
- en: concatMap()
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concatMap()
- en: Just as there is `flatMap()`, which dynamically merges Observables derived off
    each emission, there is a concatenation counterpart called `concatMap()`**.**
    You should prefer this operator if you care about ordering and want each `Observable`
    mapped from each emission to finish before starting the next one. More specifically, `concatMap()`
    will merge each mapped `Observable` sequentially and fire it one at a time. It
    will only move to the next Observable when the current one calls `onComplete()`.
    If source emissions produce Observables faster than `concatMap()` can emit from
    them, those Observables will be queued.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如存在`flatMap()`，它动态合并从每个发射派生的可观察对象一样，还有一个称为`concatMap()`的连接对应物。如果你关心顺序，并且想要每个从每个发射映射的可观察对象在开始下一个之前完成，你应该优先使用此操作符。更具体地说，`concatMap()`将按顺序合并每个映射的可观察对象，并逐个触发它们。它只有在当前的可观察对象调用`onComplete()`时才会移动到下一个可观察对象。如果源发射的可观察对象比`concatMap()`从它们发出要快，那么这些可观察对象将被排队。
- en: 'Our earlier `flatMap()` examples would be better suited for `concatMap()` if
    we explicitly cared about emission order. Although our example here has the same
    output as the `flatMap()` example, we should use `concatMap()` when we explicitly
    care about maintaining ordering and want to process each mapped `Observable` sequentially:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`flatMap()`示例如果我们要显式关注发射顺序，将更适合使用`concatMap()`。尽管我们这里的示例与`flatMap()`示例具有相同的输出，但当我们显式关注保持顺序并希望按顺序处理每个映射的`Observable`时，我们应该使用`concatMap()`：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, it is unlikely that you will ever want to use `concatMap()` to map to
    infinite Observables. As you can guess, this would result in subsequent Observables
    never firing. You will likely want to use `flatMap()` instead, and we will see
    it used in concurrency examples in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml), *Concurrency
    and Parallelization*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您不太可能想要将`concatMap()`映射到无限`Observable`。正如您所猜测的，这将导致后续的`Observable`永远不会触发。您可能会想使用`flatMap()`，我们将在第6章的并发示例中看到它的使用，*并发与并行化*。
- en: Ambiguous
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊
- en: After covering merging and concatenation, let's get an easy combine operation
    out of the way. The `Observable.amb()` factory (**amb** stands for **ambiguous**)
    will accept an `Iterable<Observable<T>>` and emit the emissions of the first `Observable`
    that emits, while the others are disposed of. The first `Observable` with an emission
    is the one whose emissions go through. This is helpful when you have multiple
    sources for the same data or events and you want the fastest one to win.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了合并和连接之后，让我们先处理一个简单的组合操作。`Observable.amb()`工厂（**amb**代表**模糊**）将接受一个`Iterable<Observable<T>>`，并发射第一个发射的`Observable`的发射，而其他`Observable`将被销毁。第一个发射的`Observable`是发射通过的那个。这在您有多个相同数据或事件源且希望最快的一个获胜时很有用。
- en: 'Here, we have two interval sources and we combine them with the `Observable.amb()`
    factory. If one emits every second while the other every 300 milliseconds, the
    latter is going to win because it will emit first:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个间隔源，我们使用`Observable.amb()`工厂将它们组合起来。如果一个每秒发射一次，而另一个每300毫秒发射一次，那么后者将会获胜，因为它会先发射：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also use an `ambWith()` operator, which will accomplish the same result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`ambWith()`运算符，它将实现相同的结果：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also use `Observable.ambArray()` to specify a `varargs` array rather
    than `Iterable<Observable<T>>`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Observable.ambArray()`来指定一个`varargs`数组而不是`Iterable<Observable<T>>`。
- en: Zipping
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩
- en: 'Zipping allows you to take an emission from each `Observable` source and combine
    it into a single emission. Each `Observable` can emit a different type, but you
    can combine these different emitted types into a single emission. Here is an example,
    If we have an `Observable<String>` and an `Observable<Integer>`, we can zip each
    `String` and `Integer` together in a one-to-one pairing and concatenate it with
    a lambda:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩允许您从每个`Observable`源中取出发射，并将其组合成一个单一的发射。每个`Observable`可以发射不同的类型，但您可以将这些不同发射的类型组合成一个单一的发射。以下是一个示例，如果我们有一个`Observable<String>`和一个`Observable<Integer>`，我们可以将每个`String`和`Integer`配对成一个一对一的配对，并用lambda函数连接它们：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `zip()` function received both `Alpha` and a `1` and then paired them up
    into a concatenated string separated by a dash `-` and pushed it forward. Then,
    it received `Beta` and `2` and emitted them forward as a concatenation, and so
    on. An emission from one `Observable` must wait to get paired with an emission
    from the other `Observable`. If one `Observable` calls `onComplete()` and the
    other still has emissions waiting to get paired, those emissions will simply drop,
    since they have nothing to couple with. This happened to the `6` emission since
    we only had five string emissions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数接收了`Alpha`和`1`，然后将它们配对成一个由破折号`-`分隔的连接字符串，并将其推向前。然后，它接收`Beta`和`2`，并将它们作为连接发射出去，依此类推。一个`Observable`的发射必须等待与另一个`Observable`的发射配对。如果一个`Observable`调用`onComplete()`而另一个`Observable`仍有等待配对的发射，那么这些发射将简单地丢弃，因为它们没有可以配对的。这就是为什么`6`发射发生了，因为我们只有五个字符串发射。'
- en: 'You can also accomplish this using a `zipWith()` operator, as shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`zipWith()`运算符来完成此操作，如下所示：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can pass up to nine `Observable` instances to the `Observable.zip()` factory.
    If you need more than that, you can pass an `Iterable<Observable<T>>` or use `zipArray()`
    to provide an `Observable[]` array. Note that if one or more sources are producing
    emissions faster than another, `zip()` will queue up those rapid emissions as
    they wait on the slower source to provide emissions. This could cause undesirable
    performance issues as each source queues in memory. If you only care about zipping
    the latest emission from each source rather than catching up an entire queue,
    you will want to use `combineLatest()`, which we will cover later in this section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `Observable.zip()` 工厂传递多达九个 `Observable` 实例。如果你需要更多，你可以传递一个 `Iterable<Observable<T>>`
    或使用 `zipArray()` 来提供一个 `Observable[]` 数组。请注意，如果一个或多个源产生的发射速度比另一个快，`zip()` 将在等待较慢的源提供发射时排队快速发射。这可能会导致不希望的性能问题，因为每个源都会在内存中排队。如果你只关心将每个源的最近一次发射压缩在一起，而不是赶上整个队列，你将想要使用
    `combineLatest()`，我们将在本节稍后介绍。
- en: Use `Observable.zipIterable()` to pass a Boolean `delayError` argument to delay
    errors until all sources terminate and an int `bufferSize` to hint an expected
    number of elements from each source for queue size optimization. You may specify
    the latter to increase performance in certain scenarios by buffering emissions
    before they are zipped.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Observable.zipIterable()` 传递一个布尔值 `delayError` 参数以延迟错误，直到所有源终止，并传递一个整型 `bufferSize`
    以提示每个源期望的元素数量以优化队列大小。你可以指定后者，在某些场景中通过在压缩之前缓冲发射来提高性能。
- en: 'Zipping can also be helpful in slowing down emissions using `Observable.interval()`.
    Here, we zip each string with a 1-second interval. This will slow each string
    emission by one second, but keep in mind the five string emissions will likely
    be queued as they wait for an interval emission to pair with:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Observable.interval()` 也可以通过压缩来减慢发射。在这里，我们以1秒的间隔压缩每个字符串。这将使每个字符串发射延迟一秒，但请注意，五个字符串发射可能会排队等待间隔发射配对：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Combine latest
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合最新
- en: The `Observable.combineLatest()` factory is somewhat similar to `zip()`, but
    for every emission that fires from one of the sources, it will immediately couple
    up with the latest emission from every other source. It will not queue up unpaired
    emissions for each source, but rather cache and pair the latest one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.combineLatest()` 工厂与 `zip()` 有一些相似之处，但对于每个源发射的每个发射，它都会立即与每个其他源的最近一次发射耦合。它不会为每个源排队未配对的发射，而是缓存并配对最新的一个。'
- en: 'Here, let''s use `Observable.combineLatest()` between two interval Observables,
    the first emitting at 300 milliseconds and the other every one second:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们使用两个间隔观察者之间的 `Observable.combineLatest()`，第一个每300毫秒发射一次，另一个每秒发射一次：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a lot going on here, but let's try to break it down. `source1` is emitting
    every 300 milliseconds, but the first two emissions do not yet have anything to
    pair with from `source2`, which emits every second, and no emission has occurred
    yet. Finally, after one second, `source2` pushes its first emission `0`, and it
    pairs with the latest emission `2` (the third emission) from `source1`. Note that
    the two previous emissions `0` and `1` from `source1` were completely forgotten
    because the third emission `2` is now the latest emission. `source1` then pushes
    `3`, `4`, and then `5` at 300 millisecond intervals, but `0` is still the latest
    emission from `source2`, so all three pair with it. Then, `source2` emits its
    second emission `1`, and it pairs with `5`, the latest emission from `source2`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，但让我们尝试将其分解。`source1` 每300毫秒发射一次，但前两次发射还没有与每秒发射一次的 `source2` 中的任何内容配对，并且还没有发生任何发射。最后，经过一秒钟后，`source2`
    推出其第一次发射 `0`，并与 `source1` 的最新发射 `2`（第三次发射）配对。请注意，`source1` 的前两次发射 `0` 和 `1` 被完全遗忘，因为第三次发射
    `2` 现在是最新发射。然后，`source1` 每300毫秒发射 `3`、`4` 和 `5`，但 `0` 仍然是 `source2` 的最新发射，所以所有三个都与它配对。然后，`source2`
    发射其第二次发射 `1`，并与 `source2` 的最新发射 `5` 配对。
- en: In simpler terms, when one source fires, it couples with the latest emissions
    from the others. `Observable.combineLatest()` is especially helpful in combining
    UI inputs, as previous user inputs are frequently irrelevant and only the latest
    is of concern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，当一个源触发时，它会与来自其他源的最近一次发射耦合。`Observable.combineLatest()` 在组合UI输入时特别有用，因为之前的用户输入通常是不相关的，只有最新的输入才是关注的重点。
- en: withLatestFrom()
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: withLatestFrom()
- en: 'Similar to `Observable.combineLatest()`, but not exactly the same, is the `withLatestfrom()`
    operator. It will map each `T` emission with the latest values from other Observables
    and combine them, but it will only take *one* emission from each of the other
    Observables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Observable.combineLatest()` 类似，但并不完全相同的是 `withLatestfrom()` 操作符。它将映射每个 `T`
    发射与其他 Observables 的最新值，并将它们组合起来，但它将只从每个其他 Observables 中取 *一个* 发射：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see here, `source2` emits every one second while `source1` emits
    every 300 milliseconds. When you call `withLatestFrom()` on `source2` and pass
    it `source1`, it will combine with the latest emission from `source1` but it does
    not care about any previous or subsequent emissions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`source2` 每秒发射一次，而 `source1` 每隔 300 毫秒发射一次。当您在 `source2` 上调用 `withLatestFrom()`
    并传递 `source1` 时，它将与 `source1` 的最新发射结合，但它不会关心任何之前的或随后的发射。
- en: You can pass up to four `Observable` instances of any varying types to `withLatestFrom()`.
    If you need more than that, you can pass it an `Iterable<Observable<T>>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向 `withLatestFrom()` 传递最多四个任何类型的 `Observable` 实例。如果您需要更多，您可以传递一个 `Iterable<Observable<T>>`。
- en: Grouping
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: A powerful operation that you can achieve with RxJava is to group emissions
    by a specified key into separate Observables. This can be achieved by calling
    the `groupBy()` operator, which accepts a lambda mapping each emission to a key.
    It will then return an `Observable<GroupedObservable<K,T>>`, which emits a special
    type of `Observable` called `GroupedObservable`. `GroupedObservable<K,T>` is just
    like any other `Observable`, but it has the key `K` value accessible as a property.
    It will emit the `T` emissions that are mapped for that given key.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RxJava 可以实现的一个强大操作是将发射按指定的键分组到单独的 Observables 中。这可以通过调用 `groupBy()` 操作符来实现，它接受一个将每个发射映射到键的
    lambda 表达式。然后它将返回一个 `Observable<GroupedObservable<K,T>>`，它发出一种特殊类型的 `Observable`，称为
    `GroupedObservable`。`GroupedObservable<K,T>` 就像任何其他 `Observable` 一样，但它有一个可访问的键
    `K` 值作为属性。它将发出映射给该特定键的 `T` 发射。
- en: 'For instance, we can use the `groupBy()` operator to group emissions for an
    `Observable<String>` by each String''s length. We will subscribe to it in a moment,
    but here is how we declare it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `groupBy()` 操作符来按每个 `String` 的长度对 `Observable<String>` 的发射进行分组。我们稍后将订阅它，但这里是如何声明它的：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will likely need to use `flatMap()` on each `GroupedObservable`, but within
    that `flatMap()` operation, we may want to reduce or collect those common-key
    emissions (since this will return a `Single`, we will need to use `flatMapSingle()`).
    Let''s call `toList()` so that we can emit the emissions as lists grouped by their
    lengths:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在每个 `GroupedObservable` 上使用 `flatMap()`，但在那个 `flatMap()` 操作中，我们可能希望减少或收集那些具有相同键的发射（因为这将返回一个
    `Single`，我们需要使用 `flatMapSingle()`）。让我们调用 `toList()` 以便我们可以将发射作为按长度分组的列表发出：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Beta` is the only emission with length four, so it is the only element in
    the list for that length key. `Alpha`, `Beta`, and `Gamma` all have lengths of
    five, so they were emitted from the same `GroupedObservable`emitting items for
    the length five and were collected into the same list. `Epsilon` was the only
    emission with length seven so it was the only element in its list.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Beta` 是唯一长度为四的发射，所以它是该长度键列表中的唯一元素。`Alpha`、`Beta` 和 `Gamma` 都有五个长度，所以它们是从同一个
    `GroupedObservable` 发射的，这些发射是为长度五而发射的，并被收集到同一个列表中。`Epsilon` 是唯一长度为七的发射，所以它是其列表中的唯一元素。'
- en: 'Keep in mind that `GroupedObservable` also has a `getKey()` method, which returns
    the key value identified with that `GroupedObservable.` If we wanted to simply
    concatenate the `String` emissions for each `GroupedObservable` and then concatenate
    the `length` key in form of it, we could do it like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`GroupedObservable` 也有一个 `getKey()` 方法，它返回与该 `GroupedObservable` 相关联的键值。如果我们想简单地连接每个
    `GroupedObservable` 的 `String` 发射，然后将 `length` 键以这种形式连接起来，我们可以这样做：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note closely that `GroupedObservables` are a weird combination of a hot and
    cold `Observable`. They are not cold in that they will not replay missed emissions
    to a second `Observer`, but they will cache emissions and flush them to the first
    `Observer`, ensuring none are missed. If you need to replay the emissions, collect
    them into a list, like we did earlier, and perform your operations against that
    list. You can also use caching operators, which we will learn about in the next
    chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意，`GroupedObservables` 是一种热和冷 `Observable` 的奇怪组合。它们之所以不冷，是因为它们不会将未播放的发射重放到第二个
    `Observer`，但它们会缓存发射并将它们刷新到第一个 `Observer`，确保没有丢失。如果您需要重放发射，可以将它们收集到一个列表中，就像我们之前做的那样，然后对该列表执行操作。您还可以使用缓存操作符，我们将在下一章中学习这些操作符。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered combining Observables in various useful ways. Merging
    is helpful in combining and simultaneously firing multiple Observables and combining
    their emissions into a single stream. The `flatMap()` operator is especially critical
    to know, as dynamically merging Observables derived from emissions opens a lot
    of useful functionality in RxJava. Concatenation is similar to merging, but it
    fires off the source Observables sequentially rather than all at once. Combining
    with ambiguous allows us to select the first `Observable` to emit and fire its
    emissions. Zipping allows you to combine emissions from multiple Observables,
    whereas combine latest combines the latest emissions from each source every time
    one of them fires. Finally, grouping allows you to split up an `Observable` into
    several `GroupedObservables`,  each with emissions that have a common key.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了以各种有用的方式组合 `Observable`。合并有助于组合和同时触发多个 `Observable`，并将它们的发射合并成一个单一的数据流。`flatMap()`
    操作符特别关键，因为动态合并从发射中派生的 `Observable` 在 RxJava 中打开了大量有用的功能。连接类似于合并，但它按顺序触发源 `Observable`，而不是一次性触发。与模糊组合一起使用，我们可以选择第一个发射并触发其发射的
    `Observable`。压缩允许您将多个 `Observable` 的发射组合在一起，而 `combineLatest` 则在每个源触发时将每个源的最新发射合并在一起。最后，分组允许您将一个
    `Observable` 分割成几个 `GroupedObservables`，每个 `GroupedObservables` 都有具有公共键的发射。
- en: Take time to explore combining Observables and experiment to see how they work.
    They are critical to unlock functionalities in RxJava and quickly express event
    and data transformations. We will look at some powerful applications with `flatMap()`
    when we cover concurrency in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization*, where we will also cover how to multitask and
    parallelize.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 抽时间探索组合 `Observable` 并进行实验，看看它们是如何工作的。它们对于解锁 RxJava 的功能以及快速表达事件和数据转换至关重要。当我们介绍并发性时，我们将在第
    6 章 `[并发和并行化](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml)` 中查看一些使用 `flatMap()`
    的强大应用，我们还将介绍如何进行多任务处理和并行化。
