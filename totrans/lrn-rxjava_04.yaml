- en: Combining Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered many operators that suppress, transform, reduce, and collect
    emissions. These operators can do a lot of work, but what about combining multiple
    Observables and consolidating them into one? If we want to accomplish more with
    ReactiveX, we need to take multiple streams of data and events and make them work
    together, and there are operators and factories to achieve this. These combining
    operators and factories also work safely with Observables occurring on different
    threads (discussed in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we start to transition from making RxJava useful to making it
    powerful. We will cover the following operations to combine Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine latest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task done in ReactiveX is taking two or more `Observable<T>` instances
    and merging them into one `Observable<T>`. This merged `Observable<T>` will subscribe
    to all of its merged sources simultaneously, making it effective for merging both
    finite and infinite Observables. There are a few ways that we can leverage this
    merging behavior using factories as well as operators.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.merge() and mergeWith()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Observable.merge()` operator will take two or more `Observable<T>` sources
    emitting the same type `T` and then consolidate them into a single `Observable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have only two to four `Observable<T>` sources to merge, you can pass
    each one as an argument to the `Observable.merge()` factory. In the following
    code snippet, I have merged two `Observable<String>` instances into one `Observable<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use `mergeWith()`, which is the operator version of `Observable.merge()`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable.merge()` factory and the `mergeWith()` operator will subscribe
    to all the specified sources simultaneously, but will likely fire the emissions
    in order if they are cold and on the same thread. This is just an implementation
    detail, and you should use `Observable.concat()` if you explicitly want to fire
    elements of each `Observable` sequentially and keep their emissions in a sequential
    order.
  prefs: []
  type: TYPE_NORMAL
- en: You should not rely on ordering when using merge factories and operators even
    if ordering seems to be preserved. Having said that, the order of emissions from
    each source Observable is maintained. The way the sources are merged is an implementation
    detail, so use concatenation factories and operators if you want to guarantee
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have more than four `Observable<T>` sources, you can use the `Observable.mergeArray()`
    to pass a varargs of `Observable[]` instances that you want to merge, as shown
    in the following code snippet. Since RxJava 2.0 was written for JDK 6+ and has
    no access to a `@SafeVarargs` annotation, you will likely get some type safety
    warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass `Iterable<Observable<T>>` to `Observable.merge()` as well. It
    will merge all the `Observable<T>` instances in that `Iterable`. I could achieve
    the preceding example in a more type-safe way by putting all these sources in
    `List<Observable<T>>` and passing them to `Observable.merge()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reason `mergeArray()` gets its own method and is not a `merge()` overload
    instead is to avoid ambiguity with the Java 8 compiler and its treatment with
    functional types. This is true for all the `xxxArray()` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observable.merge()` works with infinite Observables. Since it will subscribe
    to all Observables and fire their emissions as soon as they are available, you
    can merge multiple infinite sources into a single stream. Here, we merge two `Observable.interval()`
    sources that emit at one second and 300 millisecond intervals, respectively. But
    before we merge, we do some math with the emitted index to figure out how much
    time has elapsed and emit it with the source name in a string. We let this process
    run for three seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, `Observable.merge()` will combine multiple `Observable<T>` sources
    emitting the same type `T` and consolidate into a single `Observable<T>`. It works
    on infinite Observables and does not necessarily guarantee that the emissions
    come in any order. If you care about the emissions being strictly ordered by having
    each `Observable` source fired sequentially, you will likely want to use `Observable.concat()`,
    which we will cover shortly.
  prefs: []
  type: TYPE_NORMAL
- en: flatMap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful and critical operators in RxJava is `flatMap()`. If
    you have to invest time in understanding any RxJava operator, this is the one.
    It is an operator that performs a dynamic `Observable.merge()` by taking each
    emission and mapping it to an `Observable`. Then, it merges the emissions from
    the resulting Observables into a single stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest application of `flatMap()` is to map *one emission to many emissions*.
    Say, we want to emit the characters from each string coming from `Observable<String>`**.**
    We can use `flatMap()` to specify a `Function<T,Observable<R>>` lambda that maps
    each string to an `Observable<String>`**, **which will emit the letters. Note
    that the mapped `Observable<R>` can emit any type `R`, different from the source
    `T` emissions.  In this example, it just happened to be `String`, like the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have taken those five string emissions and mapped them (through `flatMap()`)
    to emit the letters from each one. We did this by calling each string's `split()`
    method, and we passed it an empty `String` argument `""`, which will separate
    on every character. This returns an array `String[]` containing all the characters,
    which we pass to `Observable.fromArray()` to emit each one. The `flatMap()` expects
    each emission to yield an `Observable`, and it will merge all the resulting Observables
    and emit their values in a single stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example: let''s take a sequence of `String` values (each a
    concatenated series of values separated by `"/"`), use  `flatMap()` on them, and
    filter for only numeric values before converting them into `Integer` emissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We broke up each `String` by the `/` character, which yielded an array. We turned
    that into an `Observable` and used `flatMap()` on it to emit each `String`. We
    filtered only for String values that are numeric using a regular expression `[0-9]+`
    (eliminating `FOXTROT`, `TANGO`, and `WHISKEY`) and then turned each emission
    into an **`Integer`.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `Observable.merge()`, you can also map emissions to infinite `Observables`
    and merge them. For instance, we can emit simple `Integer` values from `Observable<Integer>` but
    use `flatMap()` on them to drive an `Observable.interval()`, where each one serves
    as the period argument. In the following code snippet, we emit the values `2`,
    `3`, `10`, and `7`, which will yield interval Observables that emit at 2 seconds,
    3 seconds, 10 seconds, and 7 seconds, respectively. These four Observables will
    be merged into a single stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable.merge()` operator will accept a fixed number of `Observable`
    sources. But `flatMap()` will dynamically keep adding new `Observable` sources
    for each emission that comes in. This means that you can keep merging new incoming
    Observables over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quick note about `flatMap()` is it can be used in many clever ways.
    To this day, I keep finding new ways to use it. But another way you can get creative
    is to evaluate each emission within `flatMap()` and figure out what kind of `Observable`
    you want to return. For example, if my previous example emitted an emission of
    `0` to `flatMap()`, this will break the resulting `Observable.interval()`. But
    I can use an `if` statement to check whether it is `0` and return `Observable.empty()`
    instead, as used in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is probably too clever as you can just put `filter()` before
    `flatMap()` and filter out emissions that are equal to `0`. But the point is that
    you can evaluate an emission in `flatMap()` and determine what kind of `Observable`
    you want to return.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap()` is also a great way to take a hot Observable UI event stream
    (such as JavaFX or Android button clicks) and `flatMap()` each of those events
    to an entire process within `flatMap()`. The failure and error recovery can be
    handled entirely within that `flatMap()`, so each instance of the process does
    not disrupt future button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want rapid button clicks to produce several redundant instances
    of a process, you can disable the button using `doOnNext()` or leverage `switchMap()`
    to kill previous processes, which we will discuss in [Chapter 7](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Switching, Throttling, Windowing, and Buffering.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are many flavors and variants of `flatMap()`, accepting a number
    of overloads that we will not get into deeply for the sake of brevity. We can
    pass a second combiner argument, which is a `BiFunction<T,U,R>` lambda, to associate
    the originally emitted `T` value with each flat-mapped `U` value and turn both
    into an `R` value. In our earlier example of emitting letters from each string,
    we can associate each letter with the original string emission it was mapped from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can also use `flatMapIterable()` to map each `T` emission into an `Iterable<R>`
    instead of an `Observable<R>`. It will then emit all the `R` values for each `Iterable<R>`,
    saving us the step and overhead of converting it into an `Observable`. There are
    also `flatMap()` variants that map to Singles `(flatMapSingle())`, Maybes **`(flatMapMaybe())`**,
    and Completables `(flatMapCompletable())`. A lot of these overloads also apply
    to `concatMap()`, which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concatenation is remarkably similar to merging, but with an important nuance:
    it will fire elements of each provided `Observable` sequentially and in the order
    specified. It will not move on to the next `Observable` until the current one
    calls `onComplete()`. This makes it great to ensure that merged Observables fire
    their emissions in a guaranteed order. However, it is often a poor choice for
    infinite Observables, as an infinite `Observable` will indefinitely hold up the
    queue and forever leave subsequent Observables waiting.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the factories and operators used for concatenation. You will find
    that they are much like the merging ones except that they have the sequential
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: You should prefer concatenation when you want to guarantee that Observables
    fire their emissions in order. If you do not care about ordering, prefer merging
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.concat() and concatWith()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Observable.concat()` factory is the concatenation equivalent to `Observable.merge()`.
    It will combine the emissions of multiple Observables, but will fire each one
    sequentially and only move to the next after `onComplete()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have two source Observables emitting strings. We
    can use `Observable.concat()` to fire the emissions from the first one and then
    fire the emissions from the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same output as our `Observable.merge()` example earlier. But as
    discussed in the merging section, we should use `Observable.concat()` to guarantee
    emission ordering, as merging does not guarantee it. You can also use the `concatWith()`
    operator to accomplish the same thing, as shown in the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we use `Observable.concat()` with infinite Observables, it will forever emit
    from the first one it encounters and prevent any following Observables from firing.
    If we ever want to put an infinite `Observable` anywhere in a concatenation operation,
    it would likely be specified last. This ensures that it does not hold up any Observables
    following it because there are none. We can also use `take()` operators to make
    infinite Observables finite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we fire an `Observable` that emits every second, but only take two emissions
    from it. After that, it will call `onComplete()` and dispose it. Then, a second
    `Observable` concatenated after it will emit forever (or in this case, when the
    application quits after five seconds). Since this second `Observable`  is the
    last one specified in `Observable.concat()`, it will not hold up any subsequent
    Observables by being infinite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are concatenation counterparts for arrays and `Iterable<Observable<T>>`
    inputs as well, just like there is for merging. The `Observable.concatArray()`
    factory will fire off each `Observable` sequentially in an `Observable[]` array.
    The `Observable.concat()` factory will also accept an `Iterable<Observable<T>>`
    and fire off each `Observable<T**>**` in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note there are a few variants of `concatMap()`. Use `concatMapIterable()` when
    you want to map each emission to an `Iterable<T>` instead of an `Observable<T>`**. **It
    will emit all `T` values for each `Iterable<T>`, saving you the step and overhead
    of turning each one into an `Observable<T>`. There is also a `concatMapEager()`
    operator that will eagerly subscribe to all `Observable` sources it receives and
    will cache the emissions until it is their turn to emit.
  prefs: []
  type: TYPE_NORMAL
- en: concatMap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as there is `flatMap()`, which dynamically merges Observables derived off
    each emission, there is a concatenation counterpart called `concatMap()`**.**
    You should prefer this operator if you care about ordering and want each `Observable`
    mapped from each emission to finish before starting the next one. More specifically, `concatMap()`
    will merge each mapped `Observable` sequentially and fire it one at a time. It
    will only move to the next Observable when the current one calls `onComplete()`.
    If source emissions produce Observables faster than `concatMap()` can emit from
    them, those Observables will be queued.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our earlier `flatMap()` examples would be better suited for `concatMap()` if
    we explicitly cared about emission order. Although our example here has the same
    output as the `flatMap()` example, we should use `concatMap()` when we explicitly
    care about maintaining ordering and want to process each mapped `Observable` sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Again, it is unlikely that you will ever want to use `concatMap()` to map to
    infinite Observables. As you can guess, this would result in subsequent Observables
    never firing. You will likely want to use `flatMap()` instead, and we will see
    it used in concurrency examples in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml), *Concurrency
    and Parallelization*.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After covering merging and concatenation, let's get an easy combine operation
    out of the way. The `Observable.amb()` factory (**amb** stands for **ambiguous**)
    will accept an `Iterable<Observable<T>>` and emit the emissions of the first `Observable`
    that emits, while the others are disposed of. The first `Observable` with an emission
    is the one whose emissions go through. This is helpful when you have multiple
    sources for the same data or events and you want the fastest one to win.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have two interval sources and we combine them with the `Observable.amb()`
    factory. If one emits every second while the other every 300 milliseconds, the
    latter is going to win because it will emit first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use an `ambWith()` operator, which will accomplish the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `Observable.ambArray()` to specify a `varargs` array rather
    than `Iterable<Observable<T>>`.
  prefs: []
  type: TYPE_NORMAL
- en: Zipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zipping allows you to take an emission from each `Observable` source and combine
    it into a single emission. Each `Observable` can emit a different type, but you
    can combine these different emitted types into a single emission. Here is an example,
    If we have an `Observable<String>` and an `Observable<Integer>`, we can zip each
    `String` and `Integer` together in a one-to-one pairing and concatenate it with
    a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `zip()` function received both `Alpha` and a `1` and then paired them up
    into a concatenated string separated by a dash `-` and pushed it forward. Then,
    it received `Beta` and `2` and emitted them forward as a concatenation, and so
    on. An emission from one `Observable` must wait to get paired with an emission
    from the other `Observable`. If one `Observable` calls `onComplete()` and the
    other still has emissions waiting to get paired, those emissions will simply drop,
    since they have nothing to couple with. This happened to the `6` emission since
    we only had five string emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also accomplish this using a `zipWith()` operator, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can pass up to nine `Observable` instances to the `Observable.zip()` factory.
    If you need more than that, you can pass an `Iterable<Observable<T>>` or use `zipArray()`
    to provide an `Observable[]` array. Note that if one or more sources are producing
    emissions faster than another, `zip()` will queue up those rapid emissions as
    they wait on the slower source to provide emissions. This could cause undesirable
    performance issues as each source queues in memory. If you only care about zipping
    the latest emission from each source rather than catching up an entire queue,
    you will want to use `combineLatest()`, which we will cover later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Use `Observable.zipIterable()` to pass a Boolean `delayError` argument to delay
    errors until all sources terminate and an int `bufferSize` to hint an expected
    number of elements from each source for queue size optimization. You may specify
    the latter to increase performance in certain scenarios by buffering emissions
    before they are zipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zipping can also be helpful in slowing down emissions using `Observable.interval()`.
    Here, we zip each string with a 1-second interval. This will slow each string
    emission by one second, but keep in mind the five string emissions will likely
    be queued as they wait for an interval emission to pair with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Combine latest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Observable.combineLatest()` factory is somewhat similar to `zip()`, but
    for every emission that fires from one of the sources, it will immediately couple
    up with the latest emission from every other source. It will not queue up unpaired
    emissions for each source, but rather cache and pair the latest one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, let''s use `Observable.combineLatest()` between two interval Observables,
    the first emitting at 300 milliseconds and the other every one second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot going on here, but let's try to break it down. `source1` is emitting
    every 300 milliseconds, but the first two emissions do not yet have anything to
    pair with from `source2`, which emits every second, and no emission has occurred
    yet. Finally, after one second, `source2` pushes its first emission `0`, and it
    pairs with the latest emission `2` (the third emission) from `source1`. Note that
    the two previous emissions `0` and `1` from `source1` were completely forgotten
    because the third emission `2` is now the latest emission. `source1` then pushes
    `3`, `4`, and then `5` at 300 millisecond intervals, but `0` is still the latest
    emission from `source2`, so all three pair with it. Then, `source2` emits its
    second emission `1`, and it pairs with `5`, the latest emission from `source2`.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, when one source fires, it couples with the latest emissions
    from the others. `Observable.combineLatest()` is especially helpful in combining
    UI inputs, as previous user inputs are frequently irrelevant and only the latest
    is of concern.
  prefs: []
  type: TYPE_NORMAL
- en: withLatestFrom()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `Observable.combineLatest()`, but not exactly the same, is the `withLatestfrom()`
    operator. It will map each `T` emission with the latest values from other Observables
    and combine them, but it will only take *one* emission from each of the other
    Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, `source2` emits every one second while `source1` emits
    every 300 milliseconds. When you call `withLatestFrom()` on `source2` and pass
    it `source1`, it will combine with the latest emission from `source1` but it does
    not care about any previous or subsequent emissions.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass up to four `Observable` instances of any varying types to `withLatestFrom()`.
    If you need more than that, you can pass it an `Iterable<Observable<T>>`.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A powerful operation that you can achieve with RxJava is to group emissions
    by a specified key into separate Observables. This can be achieved by calling
    the `groupBy()` operator, which accepts a lambda mapping each emission to a key.
    It will then return an `Observable<GroupedObservable<K,T>>`, which emits a special
    type of `Observable` called `GroupedObservable`. `GroupedObservable<K,T>` is just
    like any other `Observable`, but it has the key `K` value accessible as a property.
    It will emit the `T` emissions that are mapped for that given key.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can use the `groupBy()` operator to group emissions for an
    `Observable<String>` by each String''s length. We will subscribe to it in a moment,
    but here is how we declare it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will likely need to use `flatMap()` on each `GroupedObservable`, but within
    that `flatMap()` operation, we may want to reduce or collect those common-key
    emissions (since this will return a `Single`, we will need to use `flatMapSingle()`).
    Let''s call `toList()` so that we can emit the emissions as lists grouped by their
    lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`Beta` is the only emission with length four, so it is the only element in
    the list for that length key. `Alpha`, `Beta`, and `Gamma` all have lengths of
    five, so they were emitted from the same `GroupedObservable`emitting items for
    the length five and were collected into the same list. `Epsilon` was the only
    emission with length seven so it was the only element in its list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that `GroupedObservable` also has a `getKey()` method, which returns
    the key value identified with that `GroupedObservable.` If we wanted to simply
    concatenate the `String` emissions for each `GroupedObservable` and then concatenate
    the `length` key in form of it, we could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note closely that `GroupedObservables` are a weird combination of a hot and
    cold `Observable`. They are not cold in that they will not replay missed emissions
    to a second `Observer`, but they will cache emissions and flush them to the first
    `Observer`, ensuring none are missed. If you need to replay the emissions, collect
    them into a list, like we did earlier, and perform your operations against that
    list. You can also use caching operators, which we will learn about in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered combining Observables in various useful ways. Merging
    is helpful in combining and simultaneously firing multiple Observables and combining
    their emissions into a single stream. The `flatMap()` operator is especially critical
    to know, as dynamically merging Observables derived from emissions opens a lot
    of useful functionality in RxJava. Concatenation is similar to merging, but it
    fires off the source Observables sequentially rather than all at once. Combining
    with ambiguous allows us to select the first `Observable` to emit and fire its
    emissions. Zipping allows you to combine emissions from multiple Observables,
    whereas combine latest combines the latest emissions from each source every time
    one of them fires. Finally, grouping allows you to split up an `Observable` into
    several `GroupedObservables`,  each with emissions that have a common key.
  prefs: []
  type: TYPE_NORMAL
- en: Take time to explore combining Observables and experiment to see how they work.
    They are critical to unlock functionalities in RxJava and quickly express event
    and data transformations. We will look at some powerful applications with `flatMap()`
    when we cover concurrency in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization*, where we will also cover how to multitask and
    parallelize.
  prefs: []
  type: TYPE_NORMAL
