<html><head></head><body>
		<div id="_idContainer134">
			<h1 id="_idParaDest-334"><a id="_idTextAnchor336"/>Chapter 15: What's New in Java?</h1>
			<p><strong class="bold">Java</strong>, as is obvious, has been the <em class="italic">leitmotif</em> of this book. Even if, in some of the previous chapters, we focused on more general concepts such as architectural design and software life cycle management, the main goal of this book is to provide Java software engineers with a compendium of architectural concepts, ultimately supporting them to become better architects.</p>
			<p>With this in mind, we cannot avoid a few words regarding the status of Java technology today, especially regarding the latest releases.</p>
			<p>In this chapter, we are going to discuss the following topics:</p>
			<ul>
				<li>Java versioning</li>
				<li>Vendor ecosystem</li>
				<li>What's new in Java 17</li>
			</ul>
			<p>So, let's start with an overview of Java versioning.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor337"/>Java versioning</h1>
			<p>There <a id="_idIndexMarker1895"/>have been many changes made to the <strong class="bold">Java versioning</strong> scheme and schedule over its history. One first thing to note is that, at the very beginning, Java versioning used to follow a <em class="italic">1.x</em> scheme, with <strong class="bold">1.3</strong> essentially being the first widespread version.</p>
			<p>Since <strong class="bold">version 1.5</strong>, however, the versioning scheme ditched the <em class="italic">1.x</em> prefix, so we had <strong class="bold">Java 5</strong>, <strong class="bold">6</strong>, and so on.</p>
			<p>Another important <a id="_idIndexMarker1896"/>point to make is about naming. The very<a id="_idIndexMarker1897"/> first versions were called <strong class="bold">JDKs</strong> (short for <strong class="bold">Java Development Kit</strong> – more about this in a bit). Then, from<a id="_idIndexMarker1898"/> versions <strong class="bold">1.2</strong> to <strong class="bold">5</strong>, the platform was named <strong class="bold">J2SE</strong> (for <strong class="bold">Java 2 Standard Edition</strong>). Since <strong class="bold">Java 6</strong>, at the time of writing, the platform is <a id="_idIndexMarker1899"/>referred to as <strong class="bold">Java SE</strong> (for <strong class="bold">Java Standard Edition</strong>).</p>
			<p>The most important thing to know about the JDK, a term that most of us are familiar with, is that until <strong class="bold">Java 8</strong>, the<a id="_idIndexMarker1900"/> Java platform was distributed in two versions, the <strong class="bold">Java Runtime Environment </strong>(<strong class="bold">JRE</strong>) and the <a id="_idIndexMarker1901"/>JDK. The JRE was basically a stripped-down version of the JDK, lacking all the development tools (such as the javac compiler). As said, since Java 8, only the JDK version is officially distributed.</p>
			<p>In terms of release timelines, older Java releases used to have a long and non-uniform scheme, with major versions being released in intervals varying from between 1 and 3 years. Since <strong class="bold">Java 9</strong>, though, the <a id="_idIndexMarker1902"/>platform's evolution has followed a 6-month release timeline for major versions.</p>
			<p>One more point relates<a id="_idIndexMarker1903"/> to <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>) releases. Roughly every 2 or 3 years, a version is considered LTS. This basically means a longer official support cycle (up to 10 years, depending on the vendor) with more features added (while non-LTS releases usually have fewer and simpler new features).</p>
			<p>Last but not least, each <a id="_idIndexMarker1904"/>major version (both LTS and non-LTS ones) also brings with it a set of minor versions, shipping patches, bug fixes, and security fixes.</p>
			<p>In the following diagram, you can see the graphical representation of the support life cycle for some of the most important Java releases:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_15.1_B16354.jpg" alt="Figure 15.1 – Version support life cycle for some Java releases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Version support life cycle for some Java releases</p>
			<p>Other than the<a id="_idIndexMarker1905"/> version numbering, a further important consideration concerns the vendor ecosystem.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor338"/>Vendor ecosystem</h2>
			<p>As many of you know, Java <a id="_idIndexMarker1906"/>was released as a project by (the now defunct) Sun Microsystems. It was originally developed as a language for clients and what would later be called the <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>). Ironically, nowadays, it's rarely used in such scenarios and, conversely, very <a id="_idIndexMarker1907"/>much used for server-side enterprise applications, which was likely not the first use case in mind when Java was designed.</p>
			<p>In 2006, Sun released Java technology as open source under the GPL license. Sun later went out of business and was acquired by Oracle in 2010. With that transition, the Java ecosystem started to be governed mostly by Oracle itself.</p>
			<p>Java releases are <em class="italic">certified</em> using<a id="_idIndexMarker1908"/> the <strong class="bold">Technology Compatibility Kit</strong> (<strong class="bold">TCK</strong>), which is a test suite used for testing the compatibility of Java distribution with the specifications included in a specific version. And talking of Java distributions, the most important project here is OpenJDK. </p>
			<h3>OpenJDK distributions</h3>
			<p><strong class="bold">OpenJDK</strong> is the main source <a id="_idIndexMarker1909"/>code repository from which many widespread JDK implementations have been derived, including the Oracle Java distribution.</p>
			<p>We know that Oracle leads the open source development of Java within the OpenJDK community. OpenJDK is essentially the reference implementation of Java technology. Oracle ships the Oracle OpenJDK (which is free and not supported commercially) and the Oracle JDK (which is commercially supported under a paid subscription).</p>
			<p>Many other vendors provide their <a id="_idIndexMarker1910"/>own distributions, with small differences between them. All such distributions are created starting from the OpenJDK open source code base:</p>
			<ul>
				<li><strong class="bold">AdoptOpenJDK</strong> is a <a id="_idIndexMarker1911"/>multivendor project for distributing <em class="italic">vanilla</em> OpenJDK builds (<a href="https://adoptopenjdk.net">https://adoptopenjdk.net</a>).</li>
				<li>Red Hat provides its own build featuring support for the Red Hat Enterprise Linux operating <a id="_idIndexMarker1912"/>system and some add-ons, such as support for the Shenandoah garbage collection implementation (<a href="https://developers.redhat.com/products/openjdk">https://developers.redhat.com/products/openjdk</a>).</li>
				<li>Azul Technology <a id="_idIndexMarker1913"/>builds a commercially supported implementation, including some proprietary garbage collection features (<a href="https://www.azul.com/downloads">https://www.azul.com/downloads</a>).</li>
				<li>AWS ships <strong class="bold">Corretto</strong>, an OpenJDK <a id="_idIndexMarker1914"/>build designed to run on the AWS Cloud infrastructure (<a href="https://aws.amazon.com/it/corretto">https://aws.amazon.com/it/corretto</a>).</li>
				<li>IBM ships <strong class="bold">OpenJ9</strong>, originally <a id="_idIndexMarker1915"/>developed for running on mainframe technology and now available, under the OpenJDK umbrella, for other architectures (<a href="https://www.eclipse.org/openj9">https://www.eclipse.org/openj9</a>).</li>
				<li><strong class="bold">GraalVM</strong> is an<a id="_idIndexMarker1916"/> interesting concept built on top of OpenJDK (we have already seen some of its features in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>, when discussing the native compilation of Quarkus). GraalVM comes from the experience of Oracle Labs and brings a lot of different and interesting things to the Java technology, including a module for native compilation (as we mentioned before), and modules for <strong class="source-inline">polyglot</strong> usage, in order to run code written in <strong class="bold">Python</strong>, <strong class="bold">JavaScript</strong>, <strong class="bold">Ruby</strong>, and more.</li>
			</ul>
			<p>These are the most commonly used Java distributions. The choice, unless you are looking for a very specific feature, is mostly dependent on circumstances, such as existing support contracts or commercial pricing. In the absence of specific needs, AdoptOpenJDK is usually a good place to start.</p>
			<p>A recent ecosystem report built<a id="_idIndexMarker1917"/> by <strong class="bold">Snyk</strong> (<a href="https://snyk.io/jvm-ecosystem-report-2021">https://snyk.io/jvm-ecosystem-report-2021</a>), shows that the builds of AdoptOpenJDK are the most popular by far (around 44%), followed by the different flavors (commercial and otherwise) of the Oracle distribution. Another important piece of news from the report is the growing adoption of <strong class="bold">Java 11</strong> and the move away from Java 8. However, we will see how the adoption of <strong class="bold">Java 17</strong> will grow in the upcoming months and years.</p>
			<p>In this regard, let's see what's new in the latest version of Java, Java 17.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor339"/>What's new in Java 17</h1>
			<p><strong class="bold">Java 17</strong> is an LTS release, meaning that, depending on the vendor, it will be supported for more than 5 years (up to 10, in some cases). It was released in September 2021.</p>
			<p>Let's look at some of the new features<a id="_idIndexMarker1918"/> introduced with this version.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor340"/>Sealed classes</h2>
			<p><strong class="bold">Sealed classes</strong> were<a id="_idIndexMarker1919"/> introduced with Java 15, and the feature became officially supported with Java 17. They provide a way to declaratively define classes and interfaces while restricting <a id="_idIndexMarker1920"/>which objects can extend it or implement such classes and interfaces.</p>
			<p>This can be particularly useful in specific cases, such as if you are defining an API, as you can, at design time, control some aspects of the usage of APIs.</p>
			<p>Here is a simple example:</p>
			<p class="source-code">public sealed class Payment permits Instant, Wire, </p>
			<p class="source-code">  CreditCard […]</p>
			<p>In this example, we declare a <strong class="source-inline">Payment</strong> class, and we define that only <strong class="source-inline">Instant</strong>, <strong class="source-inline">Wire</strong>, and <strong class="source-inline">CreditCard</strong> can extend it. In this particular example, we suppose these classes are in the same package as <strong class="source-inline">Payment</strong>, but it is possible to explicitly declare the full package if we wanted to place it somewhere else.</p>
			<p>Also, the exact same syntax can be applied to interfaces:</p>
			<p class="source-code">public sealed interface Payment permits Instant, Wire, </p>
			<p class="source-code">  CreditCard […]</p>
			<p>This is the same behavior, just for<a id="_idIndexMarker1921"/> interfaces, so the implementation is allowed only for the interfaces listed. </p>
			<p>It's worth noticing that a compile-time error is raised if non-allowed operations (such as extending a class with a non-declared type) are performed. This will help the code to be more stable and testable.</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor341"/>Pattern matching for switch statements</h2>
			<p>This is a preview feature, meaning<a id="_idIndexMarker1922"/> that it must be enabled (by passing a command-line parameter to the JVM) and is not officially completely supported (even if the exact boundaries of support are defined by each vendor).</p>
			<p>This feature is about extending the behavior of the <strong class="source-inline">switch</strong> construct. </p>
			<p>While there are many different<a id="_idIndexMarker1923"/> potential use cases (and more will likely be refined and finalized in the upcoming releases), these three are the main ones:</p>
			<ul>
				<li><strong class="bold">Type checking</strong>: The <strong class="source-inline">switch</strong> construct can<a id="_idIndexMarker1924"/> behave like an <strong class="source-inline">instanceof</strong> operator, checking by type as in the following example:<p class="source-code">[…]</p><p class="source-code">switch (o) {</p><p class="source-code">    case Instant i -&gt; System.out.println("It is an </p><p class="source-code">      instant payment");</p><p class="source-code">    case Wire w    -&gt; System.out.println("It is a wire </p><p class="source-code">      transfer");</p><p class="source-code">    case CreditCard c -&gt; System.out.println("It is a </p><p class="source-code">      credit card transaction");</p><p class="source-code">      default -&gt; System.out.println("It is another </p><p class="source-code">        kind of payment");</p><p class="source-code">        };</p><p class="source-code">[…]</p></li>
				<li><strong class="bold">Null safety</strong>: While, in the <a id="_idIndexMarker1925"/>previous implementations, the <strong class="source-inline">switch</strong> expressions raised a <strong class="source-inline">NullPointerException</strong> if the object evaluated is <strong class="source-inline">null</strong>, with this new null safety feature, it is possible to explicitly check for the <strong class="source-inline">null</strong> case. In this example, the <strong class="source-inline">switch</strong> expression checks over a string variable, also checking the <strong class="source-inline">null</strong> case:<p class="source-code">switch (s) {</p><p class="source-code">  case "USD", "EUR" -&gt; System.out.println("Supported </p><p class="source-code">    currencies");</p><p class="source-code">  case null    -&gt; System.out.println("The String </p><p class="source-code">    is null");</p><p class="source-code">        default    -&gt; System.out.println("Unsupported </p><p class="source-code">          currencies");</p><p class="source-code">    }</p></li>
				<li><strong class="bold">Refining patterns</strong>: It is possible to <a id="_idIndexMarker1926"/>use a syntax for expressing more than one<a id="_idIndexMarker1927"/> condition in a <strong class="source-inline">switch</strong> branch. So, essentially, the following construct is allowed:<p class="source-code">switch (o) {</p><p class="source-code">    case Instant i &amp;&amp; i.getAmount() &gt; 100-&gt; </p><p class="source-code">      System.out.println("It is an high value instant </p><p class="source-code">        payment");</p><p class="source-code">    case Instant i -&gt; System.out.println("It is a </p><p class="source-code">      generic instant payment");</p><p class="source-code">    case Wire w    -&gt; System.out.println("It is a wire </p><p class="source-code">      transfer");</p></li>
			</ul>
			<p>As you can see, this is a nice feature allowing for compact and readable code.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor342"/>Strongly encapsulating JDK internals</h2>
			<p>Since Java 9, there's been a <a id="_idIndexMarker1928"/>progressive effort to restrict access to the JDK internals. This is meant to discourage the direct utilization of classes residing in packages such as <strong class="source-inline">sun.*</strong>, <strong class="source-inline">com.sun.*</strong>, <strong class="source-inline">jdk.*</strong>, and more. The goal of this restriction is to reduce coupling to a specific JVM version (hence freeing the JVM developers up to evolve such classes, even introducing breaking changes if necessary) and enhance security.</p>
			<p>To do so, the JDK progressively offered alternatives. Moreover, since Java 9 (and up to Java 16), source code using those internal classes and methods must be compiled by passing the <strong class="source-inline">--illegal-access</strong> parameter, which can be configured to permit, deny, or print warnings with details of usage.</p>
			<p>In Java 17, this parameter is <a id="_idIndexMarker1929"/>no longer usable. Instead, it is possible to use the <strong class="source-inline">--add-open</strong> parameter, which allows us to declare specific packages that can be used. It is a common opinion that even this possibility will progressively be denied in upcoming versions, to completely deny the explicit usage of JDK internals in custom code.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor343"/>More changes in Java 17</h2>
			<p>A lot of other changes have <a id="_idIndexMarker1930"/>been added to Java 17. Here are some highlights:</p>
			<ul>
				<li><strong class="bold">Support for the macOS/AArch64</strong>: This allows the compilation and execution of Java code on Mac machines running on M1 chips.</li>
				<li><strong class="bold">Enhanced pseudo-random number generators</strong>: This is a partial refactoring of utilities for pseudo-random number generation, including the deletion of duplicated code and the pluggability of different algorithms.</li>
				<li><strong class="bold">Foreign function and memory API</strong>: This is an incubating set of features (which are still not stable and will be subject to further evolution) aimed at simplifying and securing access to resources (code and data) living outside the JVM. This means being able to access memory locations and call methods not managed or implemented in the JVM. To do so in previous versions, you were required to <a id="_idIndexMarker1931"/>use <strong class="bold">Java Native Interfaces</strong> (<strong class="bold">JNI</strong>) classes, which are generally considered less secure (and more complex to use).</li>
				<li><strong class="bold">Context-specific deserialization filters</strong>: As a part of an effort started some JVM versions ago, this is a way to define validation for code deserialization. Serialization and deserialization of classes are generally considered potential security issues, as specifically crafted payloads can execute arbitrary (and unsafe) operations. This feature allows the definition of filters to <em class="italic">prevalidate</em> the kind of code allowed in deserialization operations.</li>
				<li><strong class="bold">Deprecation of the applet API for removal</strong>: Applets haven't been used for a long time, for many reasons, including performance and security issues. Moreover, most (if not all) of the modern browsers don't support them anymore. So, they are being deprecated and will be completely removed from the JDK.</li>
				<li><strong class="bold">Deprecation of the security manager for removal</strong>: The security manager is an API primarily intended for usage along with applets. It was released in <strong class="bold">Java 1.0</strong>. It has been progressively abandoned, both due to complexity and performance issues and because applets are now less commonly used. So, it is now deprecated and will be removed in an upcoming version of the JDK.</li>
				<li><strong class="bold">Vector API</strong>: This is a new <a id="_idIndexMarker1932"/>API in the incubation phase (meaning it will be subject to<a id="_idIndexMarker1933"/> changes and further evolution). It aims to define a new API for the computation of vectors. Other than being simple to use, this API is designed to compile code, specifically targeting available optimizations for supported CPU architectures, thereby boosting performance where possible.</li>
			</ul>
			<p>While a number of other features have been added, modified, and removed, the preceding ones are the most important and impactful.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor344"/>Summary</h1>
			<p>In this chapter, we have looked at some of the novelties introduced with the latest release of the Java platform (17).</p>
			<p>We have had the opportunity to have a look at the Java versioning scheme and release schedule. We had a quick overview of the Java vendor ecosystem, a snapshot of what is an evolving situation at the time of writing. The same applies to the newest functionalities of the platform itself. While some features are notable by themselves, of course, many will be modified further in the near future.</p>
			<p>This completes our journey into cloud-native architectures with Java. I hope I have provided some interesting insights and ideas, and I wish the best of luck to every reader in defining elegant and successful applications and having satisfying careers as software architects.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor345"/>Further reading</h1>
			<ul>
				<li>Oracle, <em class="italic">JDK 17 Release Notes </em>(<a href="https://www.oracle.com/java/technologies/javase/17-relnote-issues.html">https://www.oracle.com/java/technologies/javase/17-relnote-issues.html</a>)</li>
				<li>Java Magazine, Mitch Wagner, <em class="italic">Is Java SE open source software? The short answer is 'yes.'</em> (<a href="https://blogs.oracle.com/javamagazine/post/java-se-open-source-license">https://blogs.oracle.com/javamagazine/post/java-se-open-source-license</a>)</li>
			</ul>
		</div>
	</body></html>