- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving, Deleting, and Updating with NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the concepts and features of NgRx.
    We learned the importance of state management as it provides a single source for
    the application to have a unidirectional data flow and reduces the responsibility
    of components. We also learned the building blocks of NgRx, which are actions,
    effects, reducers, and selectors. Lastly, we implemented the getting and displaying
    of the anti-heroes list feature using NgRx in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will now complete our application’s missing features – saving,
    deleting, and updating data by still using NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item without side effects using NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an item with side effects using NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an item with side effects using NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an item with side effects using NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The link to the finished version of the code is [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-13/superheroes).
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item without a side effect using NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first see how to delete items without using side effects
    in NgRx. As we learned in the previous chapter, side effects are used to call
    external APIs to retrieve data. This means that without using effects, we will
    delete the data by dispatching an action to invoke a reducer base on the dispatched
    type. This section will help us see the difference in the flow and behavior of
    using effects in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the delete action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to create the action for the delete feature. In our project,
    in the `anti-hero/state/anti-hero.actions.ts` file, we will add a new action interface
    and a new function for deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the implementation of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added a new action named
    `REMOVE_ANTI_HERO_STATE`. We have also created an action with the newly created
    type, which has a `props` parameter that accepts an anti-hero ID. The ID is needed
    for the reducer to identify what data we should delete from our store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the delete reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s create the reducer for deleting data from our store. The first thing
    we need to think of is what our reducer would look like if it could remove a single
    piece of data from an array using the provided ID. One way we can implement this
    is by using the `filter()` function to extract the data in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the following code in the `anti-hero/state/anti-hero.reducers.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added a new reducer for
    our delete feature. This accepts the anti-hero ID coming from the `removeAntiHeroState`
    action and returns the new state with the modified `antiHeroes` value where the
    anti-hero data that has the given ID is already filtered. If the reducer successfully
    modifies the value of the `antiHeroes` state, any selectors subscribed to the
    changes of this state will emit the new value in the component.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching the action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step we need to do is to dispatch the action in our component. To implement
    this step, we need to call a dispatch when the **Delete** button for each piece
    of anti-hero data is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: In the `anti-hero/components/anti-hero-list.component.ts` file, we have added
    `emittethatch`, which passes the selected anti-hero object and `TableAction`,
    based on the button clicked by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a recap of the code we have implemented for this feature in the
    following files:'
  prefs: []
  type: TYPE_NORMAL
- en: anti-hero-list.component.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: anti-hero-list.component.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: table-actions.enum.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that if the `1`, which represents
    the value for **Delete enum**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to dispatch the `REMOVE_ANTI_HERO_STATE` action in the list component
    when the **Delete** button has emitted an event. To implement this part, we will
    add the following code in the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: list.component.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: list.component.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we created a function that checks the action
    triggered by the user with the `TableActions` value. If `TableActions` has a delete
    value, we will dispatch `REMOVE_ANTI_HERO_STATE` and pass the ID of the anti-hero
    object that will be used by the reducer we have created.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully implemented the delete feature of our application with
    NgRx, but in this case, we are only deleting the items in our UI, and we are not
    syncing the changes in the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement the use of side effects in the deleting
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item with side effects using NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will improve the delete functionality by adding effects
    in our state. Our current delete feature only removes the data in the store but
    does not sync the changes in the database. This means that if we refresh our application,
    the data that we have deleted will be available again.
  prefs: []
  type: TYPE_NORMAL
- en: To sync the changes in the database, what we should do is create an effect that
    will invoke the delete API. Let’s have a look at the step-by-step changes in our
    code in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new action type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step we need to do is create a new action type. The effects in NgRx
    will use the new action type for deleting feature later.
  prefs: []
  type: TYPE_NORMAL
- en: We will add `REMOVE_ANTI_HERO_API` in the `AntiHeroActions` enum under the `anti-hero/state/anti-hero.actions.ts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the added action in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code example that a new action type was added for
    our actions. Take note that we do not need to create a new action for this type
    as we will be calling an effect instead of an action once this action type is
    dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the delete effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step we need to do is to create the effect for the delete feature.
    In the `anti-hero/state/anti-hero.effect.ts` file, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have created a new effect
    for our delete action; this has a type of `REMOVE_ANTI_HERO_API`, which calls
    the `deleteAntiHero()` function in `AntiHeroService` for the data deletion based
    on the passed ID, and once the API is successful.
  prefs: []
  type: TYPE_NORMAL
- en: The effect will dispatch another action, `REMOVE_ANTI_HERO_STATE`, which we
    created in the previous section, which removes the anti-hero from the store. This
    means that the data we delete from the database will also be deleted from our
    NgRx store.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step for this feature is to modify the action being dispatched in the
    `list.component.ts` file. In the previous section, we call the `REMOVE_ANTI_HERO_STATE`
    action directly in our component; we will change this into `REMOVE_ANTI_HERO_API`
    as we should now call the effect, which will invoke the API and at the same time
    will call the `REMOVE_ANTI_HERO_STATE` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we are now dispatching the effect in our list
    component. This will call the API first before updating our store in the application;
    the changes in our store and database are synced.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement the addition of data with side effects
    to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item with side effects using NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the *add* functionality with side effects
    in NgRx. The steps are similar to how we implemented the delete feature. We will
    create the building blocks step by step and create the dispatch logic in our component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step we need to do is create the required action types and actions
    for our add feature. To implement the actions, we can think of how we created
    the actions for the delete feature.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is the same. There are two action types that we need to create,
    and these are `ADD_ANTI_HERO_API` and `ADD_ANTI_HERO_STATE`. The first type will
    be used by the effect that will call the API, and the second type will be used
    by the reducer that will modify the state by adding the newly created data.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the two action types, we also need to create an action using
    the `createAction()` function for the `ADD_ANTI_HERO_STATE` type. The effect will
    dispatch this once the API has been successfully called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added the two new types
    in `AntiHeroActions`. We have also created a new action with the `ADD_ANTI_HERO_STATE`
    type, which accepts an `antiHero` property that will be pushed as a new item in
    the anti-hero state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step we need to do is to create the effect for the *add* feature.
    In the `anti-hero/state/anti-hero.effect.ts` file, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have created an effect similar
    to the effect for the delete feature. This effect uses the `ADD_ANTI_HERO_API`
    type and invokes the `addAntiHero()` function from `antiHeroService` to call the
    POST API to add new data to the database.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully calling the POST API, the effect will dispatch the `ADD_ANTI_HERO_STATE`
    action and pass the new anti-hero data coming from the API response to be added
    by the reducer. We have also added a `tap` operator, which calls a `navigate`
    function that will navigate to the list page after creating the new anti-hero.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the effects, we need to sync the changes implemented in the database
    with our store, and the reducer will do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added a new reducer for
    our *add* feature. This accepts the new anti-hero data coming from the `addAntiHeroState`
    action and returns the new state with the modified `antiHeroes` value where the
    new anti-hero is already added in the array.
  prefs: []
  type: TYPE_NORMAL
- en: If the reducer successfully modifies the value of the `antiHeroes` state, any
    selectors subscribed to the changes of this state will emit the new value in the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching the action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step we need to do is to dispatch the action in our component. To implement
    this step, we will invoke the dispatch action once the `anti-hero/components/anti-hero-form.component.ts`
    file, we have added an emitter that passes the value of the form and the button
    label to identify if the action is created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a recap of the code we have implemented for this anti-hero form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that the anti-hero form emits the
    form value as an anti-hero object that will be passed to the effect.
  prefs: []
  type: TYPE_NORMAL
- en: This also gives the current action, as we will also be using this anti-hero
    form component for the update. Once the button is clicked, we need to have a function
    in the `form.component.ts` file that will dispatch the effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have created the `formAction()`
    function, which dispatches an action based on the passed value from the anti-hero
    form component.
  prefs: []
  type: TYPE_NORMAL
- en: This uses a `switch` statement, as this will also be called when the action
    is `update`. We have now successfully created the *add* feature for our application
    using the building blocks of NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement the modification of data with side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an item with a side effect using NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, we will implement the final missing feature, which is
    the *update* functionality, where we will create the building blocks step by step
    and the dispatch logic in our component as we did for the *add* and *delete* features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step we need to do is to create the required action types and actions
    for our update feature. We will first create the two action types we need, which
    are `MODIFY_ANTI_HERO_API` and `MODIFY_ANTI_HERO_STATE`. The first type will be
    used by the effect that will call the API, and the second type will be used by
    the reducer that will modify the state by changing the data based on the new anti-hero
    object.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the two action types, we also need to create an action using
    the `createAction()` function for the `MODIFY_ANTI_HERO_STATE` type. The effect
    will dispatch this once the API has been successfully called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added the two new types
    in `AntiHeroActions`. We have also created a new action with the `MODIFY_ANTI_HERO_STATE`
    type, which accepts an `antiHero` property that will be used to modify the current
    values in the store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step we need to do is to create the effect for the *add* feature.
    In the `anti-hero/state/anti-hero.effect.ts` file, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have created an effect similar
    to the effect for the *add* and *delete* features. This effect uses the `MODIFY_ANTI_HERO_API`
    type and invokes the `updateAntiHero()` function from `antiHeroService` to call
    the PUT API to modify the anti-hero with the ID parameter in the database.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully calling the PUT API, the effect will dispatch the `MODIFY_ANTI_HERO_STATE`
    action and pass the modified anti-hero data coming from the API response to be
    added by the reducer, and the same as with the *add* effect, we have also added
    a `tap` operator, which calls a `navigate` function that will navigate to the
    list page after modifying the anti-hero.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the effects, we need to sync the changes implemented in the database
    with our store, and the reducer will do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added a new reducer for
    our update feature. This accepts the modified anti-hero data coming from the `addAntiHeroState`
    action and returns the new state with the modified `antiHeroes` value, where we
    replace the anti-hero with the given ID with the new object using the `map()`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: If the reducer successfully modifies the value of the `antiHeroes` state, any
    selectors subscribed to the changes of this state will emit the new value in the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching the action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step we need to do is to dispatch the action to our component. To implement
    this step, we will do the same steps as we did for the *add* feature. We will
    still use the `anti-hero/components/anti-hero-form.component.ts` file for updating
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference here is that we will bind the selected anti-hero value in
    our form; the anti-hero form component should accept an anti-hero object and should
    patch the value in the form group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added the `checkAction()`
    function, which checks whether we have passed an anti-hero object in the anti-hero
    form component.
  prefs: []
  type: TYPE_NORMAL
- en: This indicates that if the object is not null, this will be an *Update* action,
    and we must display the selected anti-hero details in each field by binding the
    form using the `patchValue()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s have the code implementation for the `form` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added a new case in the
    `formAction()` function, which also dispatches an action but of type `MODIFY_ANTI_HERO_API`.
  prefs: []
  type: TYPE_NORMAL
- en: We have also used the `selectAntiHero()` selector to select the anti-hero using
    the ID in our URL route that will be passed in our `anti-hero-form.component.ts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things we have learned; we have completed the CRUD features of applications
    using the building blocks of NgRx, and we have learned the difference between
    using and not using side effects in state management. Side effects are essential
    for our changes in the store to be synced with the database.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned, step by step, how to create the building blocks of NgRx
    with the different actions we need for our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to apply security features in Angular,
    such as adding user login and logout, retrieving user profile information, protecting
    application routes, and calling an API with protected endpoints.
  prefs: []
  type: TYPE_NORMAL
