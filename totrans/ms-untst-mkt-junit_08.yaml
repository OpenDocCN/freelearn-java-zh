- en: Chapter 8. Playing with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Any program is only as good as it is useful."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Linus Torvalds
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Enterprise applications store, retrieve, transmit, manipulate, and analyze
    data. Storing, processing, and analyzing data is very critical to any business.
    The **Business Intelligence** (**BI**) process transforms data into meaningful
    information for business. BI analyzes statistical data and helps with decision
    making and predictions for businesses, such as risk assessment, planning and forecasting,
    and analyzing buying trends. Information can be stored in a file or to a database.
    Querying and accessing data from a relational database is easier than the file
    system. This chapter covers the unit testing of the database layer. The following
    topics are covered in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing the persistence layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing clean data access code using Spring JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing of JDBC code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing of Spring JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section elaborates on the separation of concerns. Enterprise application
    information can be represented using the following building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What**: This represents the information to store. We cannot store everything;
    so, categorization of the data to be stored is very important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Who**: This represents the actors. Information is a sensitive thing and it''s
    important to control access across users; for example, an employee should not
    be able to access the salary information of another employee, but a manager or
    member of HR staff can access salary data of the staff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data store**: This represents information and its accessibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process**: This represents the processing of data. Any information doesn''t
    make any sense unless some action is performed on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram describes the key information blocks of an enterprise
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating concerns](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This section covers the **Store** block and unit testing the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the components of a loosely coupled application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating concerns](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The view component represents the JSPs, taglibs, widgets, and so on. Writing
    automated JUnit tests for the view components is not easy and requires manual
    effort. We'll skip the view components in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We unit tested the controller logic component in [Chapter 7](part0043_split_000.html#page
    "Chapter 7. Unit Testing the Web Tier"), *Unit Testing the Web Tier*.
  prefs: []
  type: TYPE_NORMAL
- en: Controller logic component accesses the business logic component. The business
    logic component performs the business logic and delegates data access to the persistence
    logic component. We'll cover the unit testing of business logic in the forthcoming
    chapters. Mock objects are used to mimic the persistence or data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: The persistence logic layer or database client layer is responsible for managing
    the database connection, retrieving data from a database, and storing data back
    in the database. Unit testing the data access layer is very important; if anything
    goes wrong in this layer, the application will fail. We can unit test the data
    access logic in isolation from the database, and perform the integration test
    to verify the application and database integrity.
  prefs: []
  type: TYPE_NORMAL
- en: You can have 100 percent test coverage of your database access code. However,
    if this code is misused by the controllers and/or the view layer, the whole application
    is useless. You need integration tests to verify the wiring, which will be covered
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Databases represent a data store or a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the data access layer from the business logic layer helps us to make
    changes to the database without affecting the business logic layer, and it allows
    us to unit test the business logic layer in isolation from the database. Suppose
    you are using the MySQL database and you want to migrate to SQL server. Then,
    in that case, you don't have to touch the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing the persistence logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll build a Phonebook application and store phone numbers.
    We'll use the **Apache Derby** database for persistence. Derby can be downloaded
    from [http://db.apache.org/derby/](http://db.apache.org/derby/).
  prefs: []
  type: TYPE_NORMAL
- en: You can use better built-in databases such as H2\. It has more features and
    is less restrictive than Derby; however, we're using Derby for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to run Derby:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the binary media file and extract the media to a preferred location.
    We'll refer to it as `DERBY_HOME` in the next steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a Windows machine, go to `DERBY_HOME\bin` and execute the `startNetworkServer.bat`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will launch a command prompt and print a message to the console that the
    database server has started, such as **started and ready to accept connections
    on port 1527**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a Java project to test the Phonebook application. Follow the
    ensuing steps to build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse and create a Java project named **DatabaseAccess**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `PhoneEntry` class to store phone details. The following are the class
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a data access interface for Phonebook. The following are the API details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a database access interface implementation to communicate with the database.
    The following are the data access object details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `PhoneBookDerbyDao` class is a Derby implementation of the dao.
    It has configuration attributes such as `driver`, `protocol`, and `dbName`, and
    getters or setters. The `loadDriver()` method loads the database driver and gets
    invoked from the `PhoneBookDerbyDao` constructor. The `getConnection()` method
    connects to a Derby database and establishes a connection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `create` behavior, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `create` method first acquires a database connection and creates a prepared
    statement from `connection`. Then, it populates the prepared statement with the
    `PhoneEntry` values, executes the prepared statement, and then commits the connection.
    The `finally` block closes the resources. Then, the prepared statement is closed
    and the connection is closed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to unit test the JDBC API call since we didn't configure the database
    yet. We'll unit test the `create()` behavior in isolation from the database. Create
    a `PhoneBookDerbyDaoTest` JUnit test under the `test\com.packt.database.dao` package.
    To run the test in isolation from the database, we need to bypass the `loadDriver`
    and `getConnection` methods. So, we need a fake object to test the class and need
    mock objects to mock out the JDBC configuration classes, such as `Connection`,
    `ResultSet`, and `PreparedStatement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TestablePhoneBookDerbyDao` is the fake object implementation of the dao. We
    created a mock `Connection` object and returned from the fake object''s `getConnection`
    method. The following is the JUnit test for the dao class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`PhoneBookDerbyDao` needs `PreparedStatement` to pass the `PhoneEntry` details
    to the database. Create the mock `PreparedStatement` and `connection` methods.
    Update the test class and add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the `create` method with `PhoneEntry` and verify whether the `PhoneEntry`
    detail was passed to the `statement` object. Finally, verify whether `connection`
    was committed, and `statement` and `connection` were closed, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Overuse of argument captors can lead to fragile tests because your system under
    test is no longer a black box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll verify the data retrieval logic and enhance the `searchByNumber()` method
    to retrieve `PhoneEntry` by number. The following is the logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, the following statements are executed in sequence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A database `Connection` is acquired. Then, `PreparedStatement` is created from
    the `Connection` object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, `PreparedStatement` is populated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, `PreparedStatement` is executed and `ResultSet` is returned.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ResultSet` is iterated and the `PhoneEntry` objects are populated from `ResultSet`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the JDBC resources are closed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To unit test this logic, we need mock `ResultSet`, `PreparedStatement`, and
    `Connection` objects. The `ResultSet` object will be stubbed to return a `PhoneEntry`
    object, the `PreparedStatement` object will be stubbed to return the mock `ResultSet`
    object, and the `Connection` object will be stubbed to return the mock `PreparedStatement`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a persistence logic unit test, the following things are verified:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JDBC API call sequence, such as connection, was committed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources were closed or cleaned up
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping `ResultSet` to model object (POJO)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the test code to verify the logic:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should write a unit test for `update`, `delete`, and `serachByXXX` behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simplifying persistence with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the `PhoneBookDerbyDao` class. It has 398 lines to support create,
    read, update, and delete (CRUD) operations. Every method performs almost similar
    tasks. The following tasks are invoked from the CRUD methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing connection parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through the results (only in the read method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating the model objects (only in the read method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing any exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing the ResultSet (only in the read method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing the statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring framework provides APIs to reduce JDBC code duplication. Spring JDBC
    hides the low-level details and allows us to concentrate on business logic. We'll
    implement `PhoneBookDao` using Spring JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version of JDBC JAR and its dependencies from [http://maven.springframework.org/release/org/springframework/spring/](http://maven.springframework.org/release/org/springframework/spring/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the ensuing steps to implement Spring JDBC and simplify the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse, open the `DatabaseAccess` project, and edit `.classpath` to
    add the following Spring dependencies shown in the screenshot:![Simplifying persistence
    with Spring](img/00114.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `PhoneBookDerbySpringDao` class that implements the `PhoneBookDao`
    interface. The following is the Spring implementation of the `create` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`JdbcTemplate` simplifies the use of JDBC; it handles the resources and helps
    to avoid common errors such as not closing the connection. It creates and populates
    the `statement` object, iterates through the `ResultSet` object, which leaves
    the application code to provide SQL, and extracts results. `PhoneBookDerbySpringDao`
    contains a `JdbcTemplate` instance and delegates the database tasks to the `jdbcTemplate`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`JdbcTemplate` has an update method for insert and update operations. It takes
    a SQL query and parameters. The new Spring version of the `create()` method invokes
    the `update()` method on `jdbcTemplate` and passes `PhoneEntry` details. Now the
    `create` method looks simple, just two lines of code. The Spring framework handles
    the resource life cycle.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a JUnit class named `PhoneBookDerbySpringDaoTest` for unit testing.
    We''ll create a `jdbcTemplate` mock and pass it to dao. The following is the JUnit
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Look at the new Spring dao; it is only 54 lines long. The class looks neat,
    simple, and readable. It doesn't handle resources, it rather concentrates on data
    access.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verifying the system integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests let us find bugs that unit testing couldn't catch. We have
    unit tested the JDBC API usages in isolation from the database, but we need to
    test the integration of data and data access API, such as the JDBC driver, connection,
    and rollback. In this section, we'll test the data access layer with a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the database table before we start writing tests. Download
    the code from the Packt Publishing website and import the project `DatabaseAccess`
    in your Eclipse workspace, go to the `com.packt.database.util` package and run
    the `DatabaseManager` class. It will create the table. The following is the fairly
    simple table creation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the steps to test the JDBC code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a source folder named `integration` for the database centric tests, such
    as `src` or `test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new JUnit test named `PhoneBookDerbyJdbcDaoIntegrationTest` and add
    the following lines to test the create, search, update, and delete functionalities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The integration test creates a `PhoneBookDerbyJdbcDao` instance and calls the
    `PhoneBookDerbyJdbcDao` method to assert results.
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides the module or utility library for integration tests. The following
    are the steps to write JUnit tests using the Spring transaction management API
    and `SpringJUnit4ClassRunner`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring supports XML-based configuration and wiring beans. Create an XML file
    named `integration.xml` in the `integration` source package. Modify the XML file
    and define the `dataSource`, `transactionManager`, and `JdbcTemplate` Spring beans.
    The following is the XML body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about Spring beans, visit [http://docs.spring.io/spring/docs/1.2.9/reference/beans.html](http://docs.spring.io/spring/docs/1.2.9/reference/beans.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A `dataSource` bean is defined with `driverClassName`, `url`, and `username`.
    The `dataSource` reference is passed to the `jdbcTemplate` and `transactionManager`
    beans.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Spring supports automatic transaction rollback after test execution. It helps
    us to shield the development database against getting corrupted. The test runner
    needs to have a reference to a transaction manager bean before test execution.
    `SpringJUnit4ClassRunner` handles the integration tests. Add a `PhoneBookDerbySpringDaoIntegrationTest`
    JUnit test and add the following lines to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@ContextConfiguration({ "classpath:integration.xml" })` annotation instructs
    the JUnit runner to load Spring beans from a classpath location. It will load
    three beans from the `integration.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The class level `@Transactional` annotation makes all methods transactional.
  prefs: []
  type: TYPE_NORMAL
- en: The `@TransactionConfiguration(transactionManager = "transactionManager", defaultRollback
    = true)` annotation defines the transaction manager, and the `defaultRollback`
    attribute tells the transaction manager to roll back all transactions after the
    end of a given test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following things happen when the JUnit test is run:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring beans are loaded from the `integration.xml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transaction manager is configured to roll back all transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jdbcTemplate` bean is automatically wired to the test class member `jdbcTemplate`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init` method creates a new instance of the dao class and passes the `jdbcTemplate`
    bean to the dao.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test first executes and then creates, updates, and deletes `PhoneEntry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After test execution, the transaction manager rolls back the transaction. No
    data is created or modified or deleted from or to the `PhoneBook` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the JUnit test runs, the following Spring console log is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The log shows that a transaction has begun, and finally the transaction is rolled
    back. However, the transaction was not rolled back due to any exception, rather
    it got rolled back due to the transactional setting `[defaultRollback = true]`.
    The log shows that `testException` is equal to `null`, which implies that no exception
    was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the unit testing strategy for the database layer; it
    provided an example of unit testing in isolation from the database, writing clean
    JDBC code with Spring, and writing integration tests with database. We also learned
    about the configured automatic transaction rollback in Spring JDBC integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to unit test the data access layer components in isolation
    from the database, write neat JDBC code using Spring, and write integration tests
    using Spring API.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the service layer and testing legacy code testing.
  prefs: []
  type: TYPE_NORMAL
