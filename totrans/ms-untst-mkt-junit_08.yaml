- en: Chapter 8. Playing with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。玩转数据
- en: '"Any program is only as good as it is useful."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"任何程序的价值仅在于它的实用性。"'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Linus Torvalds
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——林纳斯·托瓦兹
- en: 'Enterprise applications store, retrieve, transmit, manipulate, and analyze
    data. Storing, processing, and analyzing data is very critical to any business.
    The **Business Intelligence** (**BI**) process transforms data into meaningful
    information for business. BI analyzes statistical data and helps with decision
    making and predictions for businesses, such as risk assessment, planning and forecasting,
    and analyzing buying trends. Information can be stored in a file or to a database.
    Querying and accessing data from a relational database is easier than the file
    system. This chapter covers the unit testing of the database layer. The following
    topics are covered in depth:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序存储、检索、传输、操作和分析数据。存储、处理和分析数据对任何业务都至关重要。**商业智能**（**BI**）过程将数据转换为对业务有意义的情报。BI分析统计数据，帮助业务进行决策和预测，例如风险评估、计划和预测以及分析购买趋势。信息可以存储在文件或数据库中。从关系型数据库查询和访问数据比文件系统更容易。本章涵盖了数据库层的单元测试。以下主题将进行深入探讨：
- en: Separation of concerns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离关注点
- en: Unit testing the persistence layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试持久化层
- en: Writing clean data access code using Spring JDBC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring JDBC编写干净的数据库访问代码
- en: Integration testing of JDBC code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC代码的集成测试
- en: Integration testing of Spring JDBC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring JDBC的集成测试
- en: Separating concerns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离关注点
- en: 'This section elaborates on the separation of concerns. Enterprise application
    information can be represented using the following building blocks:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细阐述了分离关注点。企业应用程序的信息可以使用以下构建块表示：
- en: '**What**: This represents the information to store. We cannot store everything;
    so, categorization of the data to be stored is very important.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**什么**：这代表要存储的信息。我们无法存储一切；因此，对要存储的数据进行分类非常重要。'
- en: '**Who**: This represents the actors. Information is a sensitive thing and it''s
    important to control access across users; for example, an employee should not
    be able to access the salary information of another employee, but a manager or
    member of HR staff can access salary data of the staff.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谁**：这代表参与者。信息是敏感的，控制用户之间的访问权限很重要；例如，员工不应能够访问其他员工的薪酬信息，但经理或人力资源部门的员工可以访问员工的薪酬数据。'
- en: '**Data store**: This represents information and its accessibility.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：这代表信息和其可访问性。'
- en: '**Process**: This represents the processing of data. Any information doesn''t
    make any sense unless some action is performed on it.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**：这代表数据处理。除非对信息执行某些操作，否则任何信息都没有意义。'
- en: 'The following diagram describes the key information blocks of an enterprise
    application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了企业应用程序的关键信息块：
- en: '![Separating concerns](img/00112.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![分离关注点](img/00112.jpeg)'
- en: This section covers the **Store** block and unit testing the data access layer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了**存储**块和单元测试数据访问层。
- en: 'The following diagram represents the components of a loosely coupled application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了一个松散耦合应用程序的组件：
- en: '![Separating concerns](img/00113.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![分离关注点](img/00113.jpeg)'
- en: The view component represents the JSPs, taglibs, widgets, and so on. Writing
    automated JUnit tests for the view components is not easy and requires manual
    effort. We'll skip the view components in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组件代表JSP、标签库、小部件等。为视图组件编写自动化的JUnit测试并不容易，需要手动工作。我们将在本章中跳过视图组件。
- en: We unit tested the controller logic component in [Chapter 7](part0043_split_000.html#page
    "Chapter 7. Unit Testing the Web Tier"), *Unit Testing the Web Tier*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](part0043_split_000.html#page "第7章。单元测试Web层")中单元测试了控制器逻辑组件，*单元测试Web层*。
- en: Controller logic component accesses the business logic component. The business
    logic component performs the business logic and delegates data access to the persistence
    logic component. We'll cover the unit testing of business logic in the forthcoming
    chapters. Mock objects are used to mimic the persistence or data access layer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器逻辑组件访问业务逻辑组件。业务逻辑组件执行业务逻辑并将数据访问委托给持久化逻辑组件。我们将在接下来的章节中介绍业务逻辑的单元测试。使用模拟对象来模拟持久化或数据访问层。
- en: The persistence logic layer or database client layer is responsible for managing
    the database connection, retrieving data from a database, and storing data back
    in the database. Unit testing the data access layer is very important; if anything
    goes wrong in this layer, the application will fail. We can unit test the data
    access logic in isolation from the database, and perform the integration test
    to verify the application and database integrity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 持久逻辑层或数据库客户端层负责管理数据库连接，从数据库检索数据，并将数据存储回数据库。对数据访问层进行单元测试非常重要；如果在这个层中出现问题，应用程序将失败。我们可以从数据库中独立地对数据访问逻辑进行单元测试，并执行集成测试以验证应用程序和数据库的完整性。
- en: You can have 100 percent test coverage of your database access code. However,
    if this code is misused by the controllers and/or the view layer, the whole application
    is useless. You need integration tests to verify the wiring, which will be covered
    later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对数据库访问代码实现 100% 的测试覆盖率。然而，如果控制器和/或视图层误用了此代码，整个应用程序将变得无用。您需要集成测试来验证连接，这将在稍后介绍。
- en: Databases represent a data store or a relational database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库代表一个数据存储或关系数据库。
- en: Separating the data access layer from the business logic layer helps us to make
    changes to the database without affecting the business logic layer, and it allows
    us to unit test the business logic layer in isolation from the database. Suppose
    you are using the MySQL database and you want to migrate to SQL server. Then,
    in that case, you don't have to touch the business logic layer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据访问层从业务逻辑层分离出来，有助于我们在不影响业务逻辑层的情况下修改数据库，并允许我们独立于数据库对业务逻辑层进行单元测试。假设您正在使用 MySQL
    数据库，并希望迁移到 SQL Server。在这种情况下，您不需要修改业务逻辑层。
- en: Unit testing the persistence logic
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试持久逻辑
- en: In this section, we'll build a Phonebook application and store phone numbers.
    We'll use the **Apache Derby** database for persistence. Derby can be downloaded
    from [http://db.apache.org/derby/](http://db.apache.org/derby/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个电话簿应用程序并存储电话号码。我们将使用 **Apache Derby** 数据库进行持久化。Derby 可以从 [http://db.apache.org/derby/](http://db.apache.org/derby/)
    下载。
- en: You can use better built-in databases such as H2\. It has more features and
    is less restrictive than Derby; however, we're using Derby for simplicity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用更好的内置数据库，例如 H2。它具有更多功能，比 Derby 更少限制；然而，我们为了简单起见使用 Derby。
- en: 'The following are the steps to run Derby:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行 Derby 的步骤：
- en: Download the binary media file and extract the media to a preferred location.
    We'll refer to it as `DERBY_HOME` in the next steps.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载二进制媒体文件并将其提取到首选位置。在接下来的步骤中，我们将将其称为 `DERBY_HOME`。
- en: On a Windows machine, go to `DERBY_HOME\bin` and execute the `startNetworkServer.bat`
    file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，转到 `DERBY_HOME\bin` 并执行 `startNetworkServer.bat` 文件。
- en: It will launch a command prompt and print a message to the console that the
    database server has started, such as **started and ready to accept connections
    on port 1527**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将启动一个命令提示符，并在控制台打印一条消息，表明数据库服务器已启动，例如 **已启动并准备好在端口 1527 接受连接**。
- en: 'We will create a Java project to test the Phonebook application. Follow the
    ensuing steps to build the application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 Java 项目来测试电话簿应用程序。按照以下步骤构建应用程序：
- en: Launch Eclipse and create a Java project named **DatabaseAccess**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse 并创建一个名为 **DatabaseAccess** 的 Java 项目。
- en: 'Add a `PhoneEntry` class to store phone details. The following are the class
    details:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `PhoneEntry` 类来存储电话详情。以下是类的详情：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a data access interface for Phonebook. The following are the API details:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为电话簿创建一个数据访问接口。以下是 API 详情：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a database access interface implementation to communicate with the database.
    The following are the data access object details:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据库访问接口实现，用于与数据库通信。以下是数据访问对象详情：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `PhoneBookDerbyDao` class is a Derby implementation of the dao.
    It has configuration attributes such as `driver`, `protocol`, and `dbName`, and
    getters or setters. The `loadDriver()` method loads the database driver and gets
    invoked from the `PhoneBookDerbyDao` constructor. The `getConnection()` method
    connects to a Derby database and establishes a connection.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`PhoneBookDerbyDao` 类是 dao 的 Derby 实现。它具有配置属性，如 `driver`、`protocol` 和 `dbName`，以及获取器或设置器。`loadDriver()`
    方法加载数据库驱动程序，并从 `PhoneBookDerbyDao` 构造函数中调用。`getConnection()` 方法连接到 Derby 数据库并建立连接。
- en: 'Implement the `create` behavior, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下 `create` 行为：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `create` method first acquires a database connection and creates a prepared
    statement from `connection`. Then, it populates the prepared statement with the
    `PhoneEntry` values, executes the prepared statement, and then commits the connection.
    The `finally` block closes the resources. Then, the prepared statement is closed
    and the connection is closed.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`create` 方法首先获取数据库连接，并从 `connection` 创建一个预处理语句。然后，它使用 `PhoneEntry` 值填充预处理语句，执行预处理语句，然后提交连接。在
    `finally` 块中关闭资源。然后，关闭预处理语句和连接。'
- en: We need to unit test the JDBC API call since we didn't configure the database
    yet. We'll unit test the `create()` behavior in isolation from the database. Create
    a `PhoneBookDerbyDaoTest` JUnit test under the `test\com.packt.database.dao` package.
    To run the test in isolation from the database, we need to bypass the `loadDriver`
    and `getConnection` methods. So, we need a fake object to test the class and need
    mock objects to mock out the JDBC configuration classes, such as `Connection`,
    `ResultSet`, and `PreparedStatement`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对 JDBC API 调用进行单元测试，因为我们还没有配置数据库。我们将独立于数据库测试 `create()` 行为。在 `test\com.packt.database.dao`
    包下创建一个 `PhoneBookDerbyDaoTest` JUnit 测试。为了独立于数据库运行测试，我们需要绕过 `loadDriver` 和 `getConnection`
    方法。因此，我们需要一个假对象来测试该类，并需要模拟对象来模拟 JDBC 配置类，例如 `Connection`、`ResultSet` 和 `PreparedStatement`。
- en: '`TestablePhoneBookDerbyDao` is the fake object implementation of the dao. We
    created a mock `Connection` object and returned from the fake object''s `getConnection`
    method. The following is the JUnit test for the dao class:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TestablePhoneBookDerbyDao` 是 dao 的假对象实现。我们创建了一个模拟的 `Connection` 对象，并从假对象的
    `getConnection` 方法返回。以下是对 dao 类的 JUnit 测试：'
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`PhoneBookDerbyDao` needs `PreparedStatement` to pass the `PhoneEntry` details
    to the database. Create the mock `PreparedStatement` and `connection` methods.
    Update the test class and add the following lines:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PhoneBookDerbyDao` 需要 `PreparedStatement` 来将 `PhoneEntry` 细节传递到数据库。创建模拟的 `PreparedStatement`
    和 `connection` 方法。更新测试类并添加以下行：'
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Invoke the `create` method with `PhoneEntry` and verify whether the `PhoneEntry`
    detail was passed to the `statement` object. Finally, verify whether `connection`
    was committed, and `statement` and `connection` were closed, as follows:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `PhoneEntry` 调用 `create` 方法，并验证 `PhoneEntry` 细节是否传递给了 `statement` 对象。最后，验证
    `connection` 是否已提交，以及 `statement` 和 `connection` 是否已关闭，如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Overuse of argument captors can lead to fragile tests because your system under
    test is no longer a black box.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 过度使用参数捕获器可能导致测试脆弱，因为你的测试系统不再是黑盒。
- en: 'We''ll verify the data retrieval logic and enhance the `searchByNumber()` method
    to retrieve `PhoneEntry` by number. The following is the logic:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将验证数据检索逻辑，并增强 `searchByNumber()` 方法以按数字检索 `PhoneEntry`。以下是对逻辑的描述：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, the following statements are executed in sequence:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下语句按顺序执行：
- en: A database `Connection` is acquired. Then, `PreparedStatement` is created from
    the `Connection` object.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取数据库 `Connection`。然后，从 `Connection` 对象创建 `PreparedStatement`。
- en: After this, `PreparedStatement` is populated.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，填充 `PreparedStatement`。
- en: Now, `PreparedStatement` is executed and `ResultSet` is returned.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行 `PreparedStatement` 并返回 `ResultSet`。
- en: '`ResultSet` is iterated and the `PhoneEntry` objects are populated from `ResultSet`.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ResultSet` 被迭代，并从 `ResultSet` 中填充 `PhoneEntry` 对象。'
- en: Finally, the JDBC resources are closed.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭 JDBC 资源。
- en: To unit test this logic, we need mock `ResultSet`, `PreparedStatement`, and
    `Connection` objects. The `ResultSet` object will be stubbed to return a `PhoneEntry`
    object, the `PreparedStatement` object will be stubbed to return the mock `ResultSet`
    object, and the `Connection` object will be stubbed to return the mock `PreparedStatement`
    object.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了单元测试这个逻辑，我们需要模拟 `ResultSet`、`PreparedStatement` 和 `Connection` 对象。`ResultSet`
    对象将被模拟以返回一个 `PhoneEntry` 对象，`PreparedStatement` 对象将被模拟以返回模拟的 `ResultSet` 对象，而
    `Connection` 对象将被模拟以返回模拟的 `PreparedStatement` 对象。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In a persistence logic unit test, the following things are verified:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在持久化逻辑单元测试中，以下事项被验证：
- en: The JDBC API call sequence, such as connection, was committed
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC API 调用序列，如连接，已被提交
- en: Resources were closed or cleaned up
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源已被关闭或清理
- en: Mapping `ResultSet` to model object (POJO)
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `ResultSet` 映射到模型对象（POJO）
- en: 'The following is the test code to verify the logic:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是对逻辑进行验证的测试代码：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We should write a unit test for `update`, `delete`, and `serachByXXX` behaviors.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该为 `update`、`delete` 和 `searchByXXX` 行为编写单元测试。
- en: Simplifying persistence with Spring
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 简化持久化
- en: 'Look at the `PhoneBookDerbyDao` class. It has 398 lines to support create,
    read, update, and delete (CRUD) operations. Every method performs almost similar
    tasks. The following tasks are invoked from the CRUD methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `PhoneBookDerbyDao` 类。它有 398 行代码来支持创建、读取、更新和删除（CRUD）操作。每个方法执行几乎相似的任务。以下任务是从
    CRUD 方法中调用的：
- en: Passing connection parameters
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递连接参数
- en: Opening a connection
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开连接
- en: Creating a statement
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建语句
- en: Preparing the statement
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备语句
- en: Executing the statement
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行语句
- en: Iterating through the results (only in the read method)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历结果（仅在读取方法中）
- en: Populating the model objects (only in the read method)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充模型对象（仅在读取方法中）
- en: Processing any exception
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理任何异常
- en: Handling transactions
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事务
- en: Closing the ResultSet (only in the read method)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭 ResultSet（仅在读取方法中）
- en: Closing the statement
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭语句
- en: Closing the connection
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭连接
- en: The Spring framework provides APIs to reduce JDBC code duplication. Spring JDBC
    hides the low-level details and allows us to concentrate on business logic. We'll
    implement `PhoneBookDao` using Spring JDBC.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了 API 来减少 JDBC 代码的重复。Spring JDBC 隐藏了底层细节，使我们能够专注于业务逻辑。我们将使用 Spring
    JDBC 实现 `PhoneBookDao`。
- en: Download the latest version of JDBC JAR and its dependencies from [http://maven.springframework.org/release/org/springframework/spring/](http://maven.springframework.org/release/org/springframework/spring/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://maven.springframework.org/release/org/springframework/spring/](http://maven.springframework.org/release/org/springframework/spring/)
    下载最新的 JDBC JAR 及其依赖项。
- en: 'Follow the ensuing steps to implement Spring JDBC and simplify the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现 Spring JDBC 并简化代码：
- en: Launch Eclipse, open the `DatabaseAccess` project, and edit `.classpath` to
    add the following Spring dependencies shown in the screenshot:![Simplifying persistence
    with Spring](img/00114.jpeg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse，打开 `DatabaseAccess` 项目，并编辑 `.classpath` 以添加屏幕截图所示的以下 Spring 依赖项：![使用
    Spring 简化持久化](img/00114.jpeg)
- en: 'Create a `PhoneBookDerbySpringDao` class that implements the `PhoneBookDao`
    interface. The following is the Spring implementation of the `create` method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现 `PhoneBookDao` 接口的 `PhoneBookDerbySpringDao` 类。以下是对 Spring `create` 方法的实现：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`JdbcTemplate` simplifies the use of JDBC; it handles the resources and helps
    to avoid common errors such as not closing the connection. It creates and populates
    the `statement` object, iterates through the `ResultSet` object, which leaves
    the application code to provide SQL, and extracts results. `PhoneBookDerbySpringDao`
    contains a `JdbcTemplate` instance and delegates the database tasks to the `jdbcTemplate`.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 简化了 JDBC 的使用；它处理资源并帮助避免常见的错误，例如未关闭连接。它创建并填充 `statement` 对象，遍历
    `ResultSet` 对象，这使应用程序代码提供 SQL 并提取结果。`PhoneBookDerbySpringDao` 包含一个 `JdbcTemplate`
    实例并将数据库任务委托给 `jdbcTemplate`。'
- en: '`JdbcTemplate` has an update method for insert and update operations. It takes
    a SQL query and parameters. The new Spring version of the `create()` method invokes
    the `update()` method on `jdbcTemplate` and passes `PhoneEntry` details. Now the
    `create` method looks simple, just two lines of code. The Spring framework handles
    the resource life cycle.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 有一个用于插入和更新操作的更新方法。它接受一个 SQL 查询和参数。新版本的 Spring `create()` 方法在
    `jdbcTemplate` 上调用 `update()` 方法并传递 `PhoneEntry` 详细信息。现在 `create` 方法看起来很简单，只有两行代码。Spring
    框架处理资源生命周期。'
- en: 'Create a JUnit class named `PhoneBookDerbySpringDaoTest` for unit testing.
    We''ll create a `jdbcTemplate` mock and pass it to dao. The following is the JUnit
    implementation:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PhoneBookDerbySpringDaoTest` 的 JUnit 类进行单元测试。我们将创建一个 `jdbcTemplate`
    模拟对象并将其传递给 dao。以下是对 JUnit 的实现：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Look at the new Spring dao; it is only 54 lines long. The class looks neat,
    simple, and readable. It doesn't handle resources, it rather concentrates on data
    access.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看新的 Spring dao；它只有 54 行代码。这个类看起来整洁、简单且易于阅读。它不处理资源，而是专注于数据访问。
- en: Verifying the system integrity
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证系统完整性
- en: Integration tests let us find bugs that unit testing couldn't catch. We have
    unit tested the JDBC API usages in isolation from the database, but we need to
    test the integration of data and data access API, such as the JDBC driver, connection,
    and rollback. In this section, we'll test the data access layer with a database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试使我们能够找到单元测试无法捕获的错误。我们已经对 JDBC API 的使用进行了单元测试，但我们需要测试数据与数据访问 API 的集成，例如 JDBC
    驱动程序、连接和回滚。在本节中，我们将使用数据库测试数据访问层。
- en: 'We need to create the database table before we start writing tests. Download
    the code from the Packt Publishing website and import the project `DatabaseAccess`
    in your Eclipse workspace, go to the `com.packt.database.util` package and run
    the `DatabaseManager` class. It will create the table. The following is the fairly
    simple table creation code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写测试之前，我们需要创建数据库表。从 Packt Publishing 网站下载代码，并将项目 `DatabaseAccess` 导入到您的 Eclipse
    工作空间中，转到 `com.packt.database.util` 包并运行 `DatabaseManager` 类。它将创建表。以下为相对简单的表创建代码：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the steps to test the JDBC code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在测试 JDBC 代码时的步骤：
- en: Create a source folder named `integration` for the database centric tests, such
    as `src` or `test`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数据库相关的测试创建一个名为 `integration` 的源文件夹，例如 `src` 或 `test`。
- en: 'Create a new JUnit test named `PhoneBookDerbyJdbcDaoIntegrationTest` and add
    the following lines to test the create, search, update, and delete functionalities:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PhoneBookDerbyJdbcDaoIntegrationTest` 的新 JUnit 测试，并添加以下行以测试创建、搜索、更新和删除功能：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The integration test creates a `PhoneBookDerbyJdbcDao` instance and calls the
    `PhoneBookDerbyJdbcDao` method to assert results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试创建一个 `PhoneBookDerbyJdbcDao` 实例，并调用 `PhoneBookDerbyJdbcDao` 方法以断言结果。
- en: Writing integration tests with Spring
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 编写集成测试
- en: 'Spring provides the module or utility library for integration tests. The following
    are the steps to write JUnit tests using the Spring transaction management API
    and `SpringJUnit4ClassRunner`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了模块或实用库以进行集成测试。以下是用 Spring 事务管理 API 和 `SpringJUnit4ClassRunner` 编写
    JUnit 测试的步骤：
- en: 'Spring supports XML-based configuration and wiring beans. Create an XML file
    named `integration.xml` in the `integration` source package. Modify the XML file
    and define the `dataSource`, `transactionManager`, and `JdbcTemplate` Spring beans.
    The following is the XML body:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring 支持基于 XML 的配置和 Bean 连接。在 `integration` 源包中创建一个名为 `integration.xml` 的 XML
    文件。修改 XML 文件并定义 `dataSource`、`transactionManager` 和 `JdbcTemplate` Spring Bean。以下为
    XML 内容：
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To find out more about Spring beans, visit [http://docs.spring.io/spring/docs/1.2.9/reference/beans.html](http://docs.spring.io/spring/docs/1.2.9/reference/beans.html).
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解更多关于 Spring Bean 的信息，请访问 [http://docs.spring.io/spring/docs/1.2.9/reference/beans.html](http://docs.spring.io/spring/docs/1.2.9/reference/beans.html)。
- en: A `dataSource` bean is defined with `driverClassName`, `url`, and `username`.
    The `dataSource` reference is passed to the `jdbcTemplate` and `transactionManager`
    beans.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了一个带有 `driverClassName`、`url` 和 `username` 的 `dataSource` Bean。将 `dataSource`
    引用传递给 `jdbcTemplate` 和 `transactionManager` Bean。
- en: 'Spring supports automatic transaction rollback after test execution. It helps
    us to shield the development database against getting corrupted. The test runner
    needs to have a reference to a transaction manager bean before test execution.
    `SpringJUnit4ClassRunner` handles the integration tests. Add a `PhoneBookDerbySpringDaoIntegrationTest`
    JUnit test and add the following lines to it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring 支持在测试执行后自动回滚事务。这有助于我们保护开发数据库免受损坏。测试运行器在测试执行之前需要引用一个事务管理器 Bean。`SpringJUnit4ClassRunner`
    处理集成测试。添加一个 `PhoneBookDerbySpringDaoIntegrationTest` JUnit 测试，并向其中添加以下行：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@ContextConfiguration({ "classpath:integration.xml" })` annotation instructs
    the JUnit runner to load Spring beans from a classpath location. It will load
    three beans from the `integration.xml` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration({ "classpath:integration.xml" })` 注解指示 JUnit 运行器从类路径位置加载
    Spring Bean。它将从 `integration.xml` 文件中加载三个 Bean。'
- en: The class level `@Transactional` annotation makes all methods transactional.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的 `@Transactional` 注解使所有方法都具有事务性。
- en: The `@TransactionConfiguration(transactionManager = "transactionManager", defaultRollback
    = true)` annotation defines the transaction manager, and the `defaultRollback`
    attribute tells the transaction manager to roll back all transactions after the
    end of a given test.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TransactionConfiguration(transactionManager = "transactionManager", defaultRollback
    = true)` 注解定义了事务管理器，`defaultRollback` 属性告诉事务管理器在给定测试结束后回滚所有事务。'
- en: 'The following things happen when the JUnit test is run:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 JUnit 测试时，以下事情会发生：
- en: Spring beans are loaded from the `integration.xml` file.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Bean 从 `integration.xml` 文件中加载。
- en: A transaction manager is configured to roll back all transactions.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了一个事务管理器以回滚所有事务。
- en: The `jdbcTemplate` bean is automatically wired to the test class member `jdbcTemplate`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdbcTemplate` Bean 会自动连接到测试类的成员 `jdbcTemplate`。'
- en: The `init` method creates a new instance of the dao class and passes the `jdbcTemplate`
    bean to the dao.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 方法创建 dao 类的新实例，并将 `jdbcTemplate` Bean 传递给 dao。'
- en: The test first executes and then creates, updates, and deletes `PhoneEntry`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试首先执行，然后创建、更新和删除 `PhoneEntry`。
- en: After test execution, the transaction manager rolls back the transaction. No
    data is created or modified or deleted from or to the `PhoneBook` table.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试执行后，事务管理器回滚事务。没有数据被创建、修改或从 `PhoneBook` 表中删除。
- en: 'When the JUnit test runs, the following Spring console log is shown:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JUnit 测试运行时，以下 Spring 控制台日志显示：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The log shows that a transaction has begun, and finally the transaction is rolled
    back. However, the transaction was not rolled back due to any exception, rather
    it got rolled back due to the transactional setting `[defaultRollback = true]`.
    The log shows that `testException` is equal to `null`, which implies that no exception
    was thrown.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示，一个事务已经开始，最终事务被回滚。然而，事务回滚并不是由于任何异常，而是由于事务设置 `[defaultRollback = true]`。日志显示
    `testException` 等于 `null`，这意味着没有抛出异常。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained the unit testing strategy for the database layer; it
    provided an example of unit testing in isolation from the database, writing clean
    JDBC code with Spring, and writing integration tests with database. We also learned
    about the configured automatic transaction rollback in Spring JDBC integration
    tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了数据库层的单元测试策略；它提供了一个与数据库隔离的单元测试示例，使用 Spring 编写干净的 JDBC 代码，以及使用数据库编写集成测试。我们还了解了在
    Spring JDBC 集成测试中配置的自动事务回滚。
- en: You should now be able to unit test the data access layer components in isolation
    from the database, write neat JDBC code using Spring, and write integration tests
    using Spring API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够独立于数据库对数据访问层组件进行单元测试，使用 Spring 编写整洁的 JDBC 代码，并使用 Spring API 编写集成测试。
- en: The next chapter covers the service layer and testing legacy code testing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖服务层和测试遗留代码。
