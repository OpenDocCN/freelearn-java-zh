- en: Chapter 5. Scala Type System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered how to work with lists, which made us familiar
    with some design principles of the whole collections library. We also covered
    how to generalize to sequences and covered some more relevant data structures.
    Finally, we also covered how collections relate to monads and how we can use that
    knowledge to use some powerful abstractions in our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the `type` system and polymorphism. We will also
    cover the different types of variance, which provides a way to constrain parameterized
    types. Finally, we will cover some advanced `types` such as abstract type members,
    option, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Scala is statically typed. This means that the type of variables are known at
    compile time. The main advantage of statically typed languages is that a lot of
    checks can be done by the compiler, thus increasing the number of trivial bugs
    that are caught at an early stage. Statically typed languages are also friendlier
    to refactoring, as the programmer can feel safer about their changes as long as
    the code compiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Scala is more than statically typed. In this chapter, we will see
    how Scala''s expressive type system enables and enforces statically typed sound
    abstractions. The ability to infer types reduces the programmers'' workload of
    annotating the program with redundant type information. This chapter will build
    upon the fundamentals required for the next chapter, where will be talking about
    type classes and a type of polymorphism they enable: ad hoc polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the Scala type hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the features the Scala type system provides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify abstractions that the Scala type system enables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type Basics and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at different types and polymorphism. We'll start
    with the unified type system of Scala and end with existential types.
  prefs: []
  type: TYPE_NORMAL
- en: A Unified Type System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala has a unified type system. What this means is that all types, including
    "primitive" types, inherit from a common type. `Any` is a supertype of all types.
    It is often called the top type, and defines universal methods such as `equals`,
    `hashCode,` and `toString`. `Nothing` is a subtype of all types, and is often
    called the bottom type. There is no value that has a type of `Nothing`, so a common
    use case for it is to signal non-termination: a thrown exception, a program exit,
    or an infinite loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Any` has two direct subclasses: `AnyVal` and `AnyRef`. Value types are represented
    by `AnyVal. AnyRef` represents the reference types. There are nine non-nullable
    predefined value types: `Double`, `Float`, `Long`, `Boolean`, `Unit`, `Byte`,
    `Char`, `Short,` and `Int`. All of these types are similar in other programming
    languages, except Unit. There is one instance of `Unit`, which is declared like
    `()`. Unit is an important return type as all the functions in Scala must return
    something. All non-value types are defined as reference types. Every user-defined
    type in Scala is a subtype of `AnyRef`. Comparing AnyRef to a Java runtime environment,
    `AnyRef` is similar to `java.lang.Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: Null is a subtype of all reference types. It contains a single value identified
    by the literal `null`. Null is used for operating between other programming languages
    but it is not recommended to use it in Scala. Scala provides other safer options
    to `null,` which we shall cover later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Parametric polymorphism** is what allows you to write generic code for values
    of different types without losing the advantages of static typing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without polymorphism, a generic list type structure would always look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Having to deal with the `Any` type in these cases means that we can''t recover
    any type information about the individual members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Without polymorphism, we would be forced to use casts and thus would lack type
    safety (since casts are dynamic and happen at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala enables polymorphism through the specification of `type` variables, which
    you probably already came across when implementing generic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Type Inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common problem of statically typed languages is that they provide too much
    "syntactic overhead". Scala rectifies this issue by introducing type interface.
    In Scala, type inference is local and it will consider one expression at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type inference reduces the need for most type annotations. For example, declaring
    the type of variable is not necessary in Scala, as the compiler can identify the
    type from the initialization expression. Return types of methods are also successfully
    identified by the compiler, as they resemble to the body type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is not able to infer a result type from recursive methods, though.
    The following declaration will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message is enough to identify the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Parameterized Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Parameterized types** are the same as generic types in Java. A generic type
    is a generic class or interface that is parameterized over types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Generic types can interact with type checking using bounds or variance. We'll
    cover variance in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Bounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala allows programmers to restrict polymorphic variables using bounds. These
    bounds express subtype ( `<:`) or supertype ( `:>`) relationships. For example,
    if we''ve defined our `drop1` method before as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following wouldn''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Existential Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An existential type in Scala is a type with some unknown parts in it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An existential type includes references to type members that we know exist,
    but whose concrete values we don't care about. In the preceding code, `T` is a
    type we don't know concretely, but that we know exists. Using existential types,
    we can leave some parts of your program unknown, and still typecheck it with different
    implementations for those unknown parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try the following, it won''t compile, because an `Array[String]` is
    not an `Array[Any]` (will see why in the next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, `foo` is parameterized to accept any `T`. But now we have to carry around
    this `type` parameter, and we only care about methods on `Array` and not what
    the `Array` contains. We can therefore use existential types to get around this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is common, so Scala provides us with "wildcards" for when we don''t
    want to name a type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Generalizing the Implementation of the Binary Tree'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we''ll be generalizing an implementation of a binary search
    tree. Let''s assume you have the following definition for a binary search tree
    of integers. We want to generalize our implementation of a binary search tree
    from an `IntTree` to a `Tree[A]`. Perform the necessary modifications to the code
    to support the new definition and also have the `insert` and `search` methods
    work on the new definition. You may need to modify the `insert` and `search` definitions
    to provide a generic comparison function. We would like to use this new generic
    data structure to store information about the users that visit our website, which
    are being modeled as the `User(username: String, country: String)` case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous definition supports these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Start by modifying the ADT for trees from `IntTree` to a `Tree[A]`. Perform
    the necessary modifications to `IntNode` (to become Node[A] and `IntEmpty` to
    become `Empty`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that `IntEmpty` is an object, so there''s a single instance for the type
    `IntEmpty`.type. What should `Empty` be a subtype of? For now, transform `Empty`
    into a case class: case class `Empty[A]() extends Tree[A]`. We''ll look at a better
    way to define this type later.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `insert` definition to accept an extra comparison function as a
    function parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the code accordingly to take the new `comp` parameter into account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `search` definition to accept an extra `comparison` function as
    a function parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the code accordingly to take the new `comp` parameter into account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a comparison function for `User` and use it to populate a `Tree[User]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `def usersOfCountry(country: String, tree: Tree[User])`: `Int`
    function that returns the number of users of a given country in a `Tree[User]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we covered the unified type system of Scala and how Scala achieves
    polymorphism. We also introduced type inference and the basic rules of when it's
    applied. Bounds were also introduced as a convenient way to restrict polymorphic
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variance provides a way to constrain parameterized types. It defines a subtyping
    relationship between parameterized types based on the subtyping relationship of
    their component types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have the following class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'How can `Box` of `Tools` relate to one another? Scala provides three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Covariant: `Box[Hammer] <: Box[Tool] if Hammer <: Tool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contravariant: `Box[Tool] <: Box[Hammer] if Tool <: Hammer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Invariant: There''s no subtyping relationship between `Box[Tool]` and `Box[Hammer]`
    independently of the subtyping relationship of `Tool` and `Hammer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to define a function called `isSuitable`, which
    takes a `Box[HandTool]` and tests if the box is suitable to accommodate the tool
    it attempts to box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you pass a box of hammers to the function? After all, a hammer is a `HandTool`,
    so if the function wants to determine the suitability of the box based on the
    underlying tool, it should accept a `Box[Hammer]`. However, if you run the code
    as it is, you''ll get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that `Box[Hammer]` is not a subtype of `Box[HandTool]`,
    despite `Hammer` being a subtype of `HandTool`. In this case, we want `Box[B]`
    to be a subtype of `Box[A]` if `B` is a subtype of `A`. This is what covariance
    is. We can then tell the Scala compiler that `Box[A]` is a covariant on `A` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Contravariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s assume that we have operators that specialize on specific tools,
    so you have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You have a problem which requires an operator to be capable of working with
    hammers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Can you pass an operator of `HandTool` to fix this? After all, a hammer is a
    `HandTool`, so if the operator is capable of working with hand tools, they should
    be able to work with hammers.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you try the code, you get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that `Operator[HandTool]` is not a subtype of `Operator[Hammer]`,
    despite `Hammer` being a subtype of `HandTool`. In this case, we want `Operator[A]`
    to be a subtype of `Operator[B]` if `B` is a subtype of `A`. This is what contravariance
    is. We can tell the Scala compiler that `Operator[A]` is a contravariant on `A`
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Invariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, type parameters are invariant because the compiler has no way of
    guessing what you intend to model with a given type. On the other hand, the compiler
    helps you by forbidding the definition of types that may be unsound. For example,
    if you declare the `Operator` class as a covariant, you get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By defining `Operator` to be covariant, you would say that an `Operator[Hammer]`
    could be used in place of an `Operator[HandTool]`. So, an operator capable of
    only using a `Hammer` would be able to operate on any `HandTool`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the definitions of `Box[+A]` and `Operator[-A]`, notice that type
    `A` only appears in the return type of methods of `Box[+A]` and only in the parameters
    of methods of `Operator[-A]`. So, a type that only produces values of type `A`
    can be made covariant on `A`, and a type that consumes values of type `A` can
    be made contravariant on `A`.
  prefs: []
  type: TYPE_NORMAL
- en: You can deduce by the previous points that mutable data types are necessarily
    invariant (they have `getters` and `setters`, so they both produce and consume
    values).
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, Java has an issue with this, as Java arrays are covariant. This means
    that some code that is valid at compile time can fail at runtime. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, most collections are covariant (for example, `List[+A]`). However,
    you may be wondering how the `::` methods and similar are implemented, since they
    may have a type in a contravariant position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, methods such as `::` are implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This actually allows collections to always get parameterized on the more specific
    type they''re able to. Notice how the following list gets lifted to a list of
    `HandTool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Implementing Covariance and the Database for Tools'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we''ll be making our previous implementation of `Tree[A]`
    covariant on `A`. We also want to start building a database for the tools we''ve
    defined so far. We have extended the definition of tools to now have a weight
    and a price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Start by defining `Tree` as `Tree[+A]`. You can now define `Empty` as a case
    object extending `Tree[Nothing]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define some comparison function for tools. For instance, you can compare tools
    by weight, by price, or by a combination of both. Experiment with the different
    comparison functions when creating trees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `def merge[A](tree1: Tree[A], tree2: Tree[A], comp: (A, A) =>
    Boolean): Tr``ee[A]` function, which merges two trees into one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we've covered variance as a way to define subtyping relationships
    on types based on their component types.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have come from Java, most of these things may not be surprising. As such,
    let's look at some other features of Scala's type system.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Type Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract type members are type members of an object or class that are left abstract.
    They can provide some abstraction without the verbosity of type parameters. If
    a type is intended to be used existentially in most cases, we can cut some verbosity
    by using a type member instead of a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to an abstract type variable using the hash operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Structural Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala supports structural types: type requirements that are expressed by an
    interface structure instead of a concrete type. Structural typing provides a feature
    similar to what dynamic languages allow you to do when they support duck typing,
    but in a static typed implementation checked up at compile time. However, bear
    in mind that Scala uses reflection to call methods on structural types, and that
    this has a cost on performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Structural types are not very common in Scala codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously visited the `Null` type in the Scala hierarchy, but commented
    that null is rarely seen in Scala code. The reason behind this is the existence
    of the `Option` type in Scala's standard library. If you have worked with Java
    in the past, chances are you came across a `NullPointerException` at some point.
    That usually happens when some method returns `null` when the programmer was not
    expecting it to and not dealing with that possibility in the client code. Scala
    tries to solve the problem by making optional types explicit via the `Option[A]`
    trait. `Option[A]` is a container for an optional value of type `A`. If the value
    is present, then `Option[A]` is an instance of `Some[A]`, otherwise it is the
    `None o`bject. By making optional values explicit at the type level, there's no
    way to accidentally rely on the presence of a value that is really optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an `Option` using the `Some` case class or by assigning the
    `None` object. When working with Java libraries, you can use the factory method
    of the `Option` companion object that creates `None` if the given parameter is
    null, and wraps the parameter in a Some otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Option` trait defines a get method that returns the wrapped value in case
    of a Some, and throws a `NoSuchElementException` in case of a `None`. A safer
    method is `getOrElse`, which returns the wrapped value in case of a Some, but
    a default value in case of a None. Do note that the default value in the `getOrElse`
    method is a by-name-parameter, so it will only be evaluated in case of a `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A convenient way to work with Options is by using pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A nice feature of `Option` is that it extends `Traversable`, so you have all
    the `map`, `flatMap`, `fold`, `reduce`, and other methods we visited in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Higher Kind Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala can abstract over types of a higher kind . You can think of it as types
    of types. A common use case for it is if you want to abstract over several types
    of containers for several types of data. You may want to define an interface for
    these containers without nailing down the value''s type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Type Erasure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To incur in no runtime overhead, the Java Virtual Machine performs type erasure.
    Among other things, type erasure replaces all type parameters in generic types
    with their bounds or `Object` if the type parameters are unbounded. This results
    in bytecode that only contains ordinary classes, interfaces, and methods, and
    makes sure that no new classes are created for parameterized types. This leads
    to some pitfalls when we attempt to match on generic type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As such, you should always avoid matching on generic type parameters. If it
    is impossible to refactor the method that performs the pattern matching, try to
    control the type of value passed into the function by boxing the input which has
    a type parameter with a container that specifies the type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Finding an Element Based on a Given Predicate'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we want to provide our `Tree` with functionality to find
    an element in it based on a given predicate. More concretely, we want to implement
    the `def find[A](tree: Tree[A], predicate: A => Boolean): Option[A]` function.
    The function should return `None` if no element is found that satisfies the predicate,
    or `Some` with the first element (in order) that satisfies it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to return the first element in order, so we need to assume that the
    tree is a search tree and traverse it in order. Implement the `def inOrder[A](tree:
    Tree[A]): Iterator[A]` method that returns an `Iterator` with the in-order traversal
    of elements in the `Tree`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the previously implemented method, now rely on the `find` method of `Iterator`
    to implement the `target` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to find the cheapest tool with a weight below 100\. Implement the function
    that should be used when creating the tree, and the predicate to be used in the
    `find` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the `type` system and polymorphism. We also covered
    the different types of variance which provide a way to constrain parameterized
    types. Finally, we covered some advanced `types` such as abstract type members,
    option, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover `implicits,` which will make working with
    external libraries more pleasant. We will cover implicit conversions and finally
    cover ad hoc polymorphism through the use of type classes.
  prefs: []
  type: TYPE_NORMAL
