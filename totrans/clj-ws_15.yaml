- en: '15\. The Frontend: A ClojureScript UI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go over the basics of React's virtual DOM and lifecycle
    and then provide the tools necessary to build a rich user interface for the data
    application outlined in the previous chapters. We will see how to call JavaScript
    code from ClojureScript and how to convert between JavaScript and ClojureScript
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build a rich user interface
    for a data application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure is a hosted language, which means that it runs on top of another language.
    In the same way that Clojure runs on top of the JVM, ClojureScript runs on top
    of JavaScript. More precisely, a ClojureScript program is transpiled into a JavaScript
    program that can run in the browser, on the server side, and in any environment
    where JavaScript is supported. For example, consider Node.js, an open source JavaScript
    server environment that allows us to execute JavaScript programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of ClojureScript and how to create
    a ClojureScript program that runs in the browser. We will build a small frontend
    application on top of the Reagent framework that connects to an HTTP endpoint
    and displays **User Interface** (**UI**) components that the user can interact
    with. We will use Hiccup as a markup language for the UI components and discover
    how to execute JavaScript code from ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: We will build an application using Figwheel, which supports hot code reloading.
    When your application is up, you will modify it either by changing its code or
    by evaluating code in the REPL. Your application will be magically updated without
    ever needing to refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn how to organize the different components of a Reagent application:
    the CSS, the HTML, and the `cljs` files. We will build several Reagent components
    that access and modify the state of the app and fetch data from the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Hiccup instead of HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hiccup is a library for representing HTML in Clojure. In *Activity 6.01*, *Generating
    HTML from Clojure Vectors*, you implemented a simplified version of Hiccup. As
    you''ll remember, Hiccup uses:'
  prefs: []
  type: TYPE_NORMAL
- en: Vectors to represent elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps to represent an element's attributes (including styles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a Hiccup vector, the first element is a keyword that specifies the corresponding
    HTML element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:div` for a `<div>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:span` for a `<span>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:img` for a `<img>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Hiccup, an empty `<div>` is represented by `[:div]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second element is an optional map that represents the element''s attributes
    where the names of the attributes follow the kebab-case convention: we separate
    the words with one underscore character (`on-click` instead of `onClick`).'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `[:div {:class "myDiv"}]` represents `<div class="myDiv"></div>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in HTML, the `style` attribute is a string while in Hiccup it is
    a map where the keys follow the kebab-case convention. For example, consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This represents the following in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, color: white denotes that the color of the `Hello Hiccup` text and `background-color`
    will be blue within the `div` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the optional map of attributes, we have the children—as many as we
    want. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It represents the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can nest Hiccup elements as children of Hiccup elements. For instance, consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This represents the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In Hiccup, we can specify the class of an element in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying an element''s attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using Hiccup shorthand, by appending a dot and the name of the class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compared to HTML, Hiccup is more compact and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can blend code and data in Hiccup to generate UI components
    dynamically without requiring an additional template language, like we usually
    do in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say we want to create a list of 10 `todo` items. We would
    usually write them down manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can generate the exact same Hiccup element with `map` and `into`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Getting Started with Reagent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reagent is a minimalistic ClojureScript wrapper for React.js. React.js is a
    JavaScript library for building a UI.
  prefs: []
  type: TYPE_NORMAL
- en: A Reagent component is similar to a Hiccup component except that the first element
    can be either a keyword or a function. When it's a keyword, it is a Hiccup component
    and when it's a function, Reagent calls the function in order to render the component
    and passes to the function the remaining parts of the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Reagent app is made of three parts: the ClojureScript code, the HTML page,
    and the CSS rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reagent, like in React, the HTML page is minimalistic: it is mainly a `<div>`
    element with an ID, usually `<div id="app">`.'
  prefs: []
  type: TYPE_NORMAL
- en: The CSS rules work the same as in any JavaScript application. The ClojureScript
    code usually starts at the core.cljs file, which renders the main component of
    the application. In the exercises and the activities of this chapter, the app
    will be made of a single namespace, but in a production application, the application
    is split into several namespaces, like in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: In Reagent, the state of the application is stored in a ratom (shorthand for
    reagent/atom), which has the same interface as regular Clojure atoms. The difference
    between a ratom and a Clojure atom is that when a ratom changes, the UI is rerendered.
  prefs: []
  type: TYPE_NORMAL
- en: React.js embraces the functional programming approach and encourages the developer
    to build their frontend application from components that manipulate data structures.
    The data structures are rendered by React in the browser's **Document Object Model**
    (**DOM**) in a very efficient way. React keeps the developer's mind free from
    having to deal with the DOM at a low level, enabling them to focus on the business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure's data-oriented approach, its immutable data structures, and the way
    it manages changes via atoms make React and ClojureScript a powerful combination.
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual DOM and Component Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build an application in React.js, we don't deal directly with the DOM,
    which is the browser's rendering mechanism and object model. Instead, React exposes
    a virtual DOM to the developer and keeps the implementation details hidden from
    them. This is what makes React so powerful. In a nutshell, when developing a React
    application, the developer writes React components that return data structures
    and the React frameworks automatically update the DOM and render the component
    on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, React is smart enough to calculate the smallest amount of DOM changes
    that are required in order to update the state of the UI, which makes React applications
    highly performant.
  prefs: []
  type: TYPE_NORMAL
- en: If a complex component's behavior is required by the application, such as doing
    something special as soon as the component is mounted or just before the component
    is updated, React provides lifecycle methods that the component can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.01: Creating a Reagent Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a very simple Hiccup component in
    Reagent: an image with a couple of CSS properties. The CSS properties that we
    are going to use through the chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding: 7px; // the inner padding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cursor: pointer; // the type of cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Margin-left: 10px; // horizontal spacing between elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Margin-bottom: 10px; // vertical spacing between elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Border: 1px solid gray; // a 1px solid border of color gray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Border-radius: 10px; // the radius of the corners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Color: gray; // the text color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Font-size: 15px; // the size of the font'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Float: left; horizontal alignment instead of the default vertical alignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the command-line prompt, create a new Figwheel project using the following
    Leiningen command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change folder to the `packt-clj.reagent-sandbox/` directory and type the following
    command to launch the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.1: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.1: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under the current folder, open the `src/packt_clj/reagent_sandbox/core.cljs`
    file in your preferred editor and take a look at the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code renders the UI by calling the `reagent/render-component` function
    with two arguments. The first is the Reagent component to render `[hello-world]`
    and the HTML element where the component is going to be rendered – in our case,
    the element whose ID is `app`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s look now at the `hello-world` function that renders the main component
    of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`hello-world` returns a vector, a Hiccup component of type `:div`, with two
    children. The first child is `[:h1 (:text @app-state)]`, which is an `:h1` component
    with text that comes from the `:text` value of the dereferencing of the `app-state`
    atom (see *Chapter 12*, *Concurrency*, about atoms). The second child is `[:h3
    "Edit this and watch it change!"]`, which is an `:h3` component with fixed text.
    Let''s see that in action!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the Terminal window where you ran lein figwheel. You are in a Figwheel
    REPL. You should see a prompt like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s switch to the packt-clj.reagent-sandbox.core namespace by typing
    the following in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s inspect the state of our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And let''s modify the value of `:text` in the atom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application immediately updates with the new text:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.2: Printing the updated text'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.2: Printing the updated text'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, `app-state` is a ratom; therefore, when it changes,
    Reagent rerenders the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.02: Displaying an Image with Style'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s render an image with a couple of CSS properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/packt_clj/reagent_sandbox/core.cljs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first part creates an image component and the second part includes an instance
    of the image component as part of the main component of the app. The moment you
    save the file, your app should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.3: Rendering the image'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.3: Rendering the image'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we call hot code reloading: you change the code and the app updates
    immediately without refreshing the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Component State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Reagent, the behavior of a component depends on the state of the component.
    The state is stored in two places:'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments passed to the component when the component is instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ratom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments passed to the component cannot be modified by the component but a
    ratom can be modified. This is useful when we want to allow a component to change
    the state of itself (or of another component) upon user interaction (for example,
    a click).
  prefs: []
  type: TYPE_NORMAL
- en: To build real-life production applications with complex application state, we
    use a framework on top of Reagent, for instance, Reframe, a popular framework
    for writing single-page applications on top of Reagent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.03: A Button that Modifies Its Text'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a toggle button whose initial text is "ON" and that changes its
    text to "OFF" when we click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/packt_clj/reagent_sandbox/core.cljs`. We add to the `app-state` ratom
    information about whether the button is on or off by including a :`button-on?`
    key whose initial value is `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we create the `button` component with the text of the button depending
    on the value of `:button-on?` and the click handler toggles the value of `:button-on?`.
    Notice that the click handler is referenced by `:on-click` (while in plain HTML,
    it''s `onClick`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we instantiate the button as part of our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to your browser window, **refresh the page**, click on the button, and
    see how the text modifies itself. In this case, we have to refresh the page because
    we have changed the initial state of the app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also change the state of the button via the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The UI is updated immediately. We don't need to refresh the page due to hot
    reload. Clicking on the button or swapping the ratom are two equivalent ways to
    update the state of the app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Components with Children Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw when we introduced Hiccup, we can programmatically generate child
    components inside a Reagent component. For instance, we can start from an array
    of image URLs and convert each URL into an image component. This way, we are able
    to programmatically generate a grid of images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.04: Creating a Grid of Images'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a component that renders a collection of images in a grid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/packt_clj/reagent_sandbox/core.cljs`. First, we create an `image-with-width`
    component that receives the image width as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a grid component as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a vector of image URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we instantiate the image grid with `my-images`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when we switch to the browser window, we see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.4: The image grid'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.4: The image grid'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to get a better understanding of `image-grid`, let''s inspect the
    `Hiccup` vector returned by the `image-grid` function in the REPL when we pass
    to it the first three elements of `my-images`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's a `:div` component with three children, where each child is a `:div` element
    with a `style` map and a nested `image-with-width-component`.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Reload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you noticed that `app-state` is defined via `defonce` and not via `def`,
    like we usually define vars in Clojure?
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `defonce` and `def` is that when `defonce` is called
    twice, the second call has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `a` is now `1`. In the context of hot reloading, defonce is crucial.
    The reason is that with hot code reloading, we want:'
  prefs: []
  type: TYPE_NORMAL
- en: The code to be reloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of the app to remain the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those two desires seem contradictory because the initial state of the `app`
    is defined in the code. As a consequence, reloading the code seems to imply re-initializing
    the state of the `app`. Here, `defonce` comes to the rescue. The code that sets
    the initial state of the `app` is called only once!
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious, you can, just for the sake of understanding the difference
    between `defonce` and `def`, replace `defonce` with `def` in the code of the app
    you built and see how the app comes back to its initial state each time we save
    a code change.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Interop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it''s time to learn how in ClojureScript, we can interop with the underlying
    JavaScript language. By interop, we mean mainly:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the window global object from ClojureScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a JavaScript function from ClojureScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between JavaScript and ClojureScript objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to access the window scope, we use the `js/` prefix. For instance,
    `js/document` represents the document object and `js/Math.abs` represents the
    `abs` function in the `Math` scope. In order to call a method on a JavaScript
    object, we use dot notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(. js/Math abs -3)` is equivalent to `Math/abs(3)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(. js/document (getElementById "app"))` corresponds to `document. getElementById("app")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you can fully understand the expression in `src/packt_clj/reagent_sandbox/core.cljs`
    that renders the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When we want to convert between JavaScript and ClojureScript objects, we use
    the js->clj and clj->js functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the JavaScript object {total: 42}, represented in the REPL as
    #js {:total 42}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that ClojureScript keywords are converted into strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the JavaScript object `{total: 42}`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`clj->js` works recursively, which means that nested objects are also converted
    to JavaScript objects. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `#js` notation to generate a JavaScript object, but note
    that it is not recursive. `#js {:total 42}` in ClojureScript generates `{total:
    42}` in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the other direction, from JavaScript to ClojureScript? You use the
    `js->clj` function. `(js->clj #js {"total" 42})` returns the ClojureScript object
    `{"total" 42}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want JavaScript strings to be converted to ClojureScript keywords, you
    need to keywordize the keys by passing extra args to `js->clj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This returns the ClojureScript object `{:total 42}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.05: Fetching Data from an HTTP Endpoint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use our JavaScript interop knowledge to fetch data from an HTTP endpoint
    that returns JSON, namely [https://packt.live/2RURzar](https://packt.live/2RURzar).
    This endpoint returns a JSON array made of three objects with data about images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, we would fetch the JSON by using the JavaScript `fetch` function
    and two promises to convert the server response into a JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In ClojureScript, the preceding code translates to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It prints a ClojureScript vector to the console with three ClojureScript objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the pieces are now in place to build a small frontend application that displays
    a grid of images from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.01: Displaying a Grid of Images from the Internet'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are asked to write a frontend application for a freelancer graphics editor
    that displays a grid of six images from and two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: A button that clears the images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button that hides the authors' names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This button can be used by the graphics editor to see the author names to add
    to the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Figwheel project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two buttons; one will clear images and the other will hide author names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon completing the activity, you should be able to see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: Expected outcome'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_15_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.5: Expected outcome'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 758.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.02: Tennis Players with Ranking'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's wrap up this chapter by combining the knowledge gained from it with the
    material we covered in *Chapter 14*, *HTTP with Ring*. In the activity of *Chapter
    14*, *HTTP with Ring*, we built an HTTP API server that returned data about tennis
    players. In the current activity, you are asked to build a frontend for this HTTP
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to build a web app that:'
  prefs: []
  type: TYPE_NORMAL
- en: Displays the names of all the tennis players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displays the ranking of any tennis player when the user clicks on their name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before starting, you need to perform the activity from *Chapter 14*, *HTTP with
    Ring*, with a slight change in the code of the server to support API requests
    from the web app we are going to build. The current activity is going to request
    data from this server. By default, web servers don't allow requests that come
    from another host. In our case, the API server runs on port `8080` while the frontend
    server runs on port `3449`. In order to allow requests that come from the frontend
    app to be served by the API server, we need to configure the API server so that
    it allows **Cross-Origin Resource Sharing** (**CORS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting the activity, you''ll need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the folder that contains the code of *Activity 14.01*, *Exposing Historic
    Tennis Results and ELO Calculations via REST*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dependency to the `deps.edn` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `packt-clj/src/packt_clj/tennis/api.clj` file and add the following
    line in the `require` expression at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `packt-clj/src/packt_clj/tennis/api.clj` file and add the following
    two lines in the definition of the `run` function at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run` function should now look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the server as explained in *Activity 14.01*, Exposing Historic Tennis
    Results and ELO Calculations via REST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new Figwheel project that uses Reagent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write code that fetches tennis player data from the server from *Chapter 14*,
    HTTP with Ring, and inserts it into the application state of your new ClojureScript
    app. You'll also want a field in the application state for the current player
    when a player has been selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write views for displaying the list of players and for displaying a single player
    with their data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate handlers for the links that select the player to view, and for the
    buttons that load and clear the list of players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon completing the current activity, you should see something like this in
    your browser:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.6: List of players'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_15_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.6: List of players'
  prefs: []
  type: TYPE_NORMAL
- en: 'And when the user clicks on Michael Stich, the app looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: The rating of a player'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_15_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.7: The rating of a player'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 762.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the basics of how to build a frontend application
    in ClojureScript using Reagent, a wrapper around React.js.
  prefs: []
  type: TYPE_NORMAL
- en: We built a couple of Reagent components using the Hiccup markup language, which
    uses Clojure collections to define the HTML structure and properties. The state
    of the application is stored in a Reagent atom that you interacted with through
    the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to call JavaScript code from ClojureScript and how to convert between
    JavaScript and ClojureScript objects. You used these interop features to fetch
    image data from an HTTP server and convert the data into a ClojureScript object.
  prefs: []
  type: TYPE_NORMAL
- en: We've reached the end of the book. You've seen a lot of new things since the
    first pages of *Chapter 1*, *Hello REPL!*. Beyond the syntactic basics, you've
    learned a lot about functional programming and, even more importantly, how to
    think in a functional way. It's one thing to know what immutability is and something
    else entirely to know how to accomplish tasks using immutable data. By focusing
    intensively on collections, we were able to show you some of Clojure's most distinctive
    features, such as lazy sequences, while building up your mental library of useful
    patterns for solving problems. Clojure is often considered a data-centric language,
    so collections are a key part of that. Programming is more than just mastering
    language features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our other focus has been on getting things done with Clojure, and that means
    knowing how to navigate in the Clojure tooling ecosystem. You''ve learned how
    to set up projects, how to use Leiningen for both Clojure and ClojureScript projects,
    and how to organize your namespaces. Platforms and interop are an important part
    of that picture too: you know the basics of using Java or JavaScript features
    in your Clojure(Script). Testing is another necessary skill for any real-world
    project. You know about that too now. You''ve also seen enough of macros and Clojure''s
    concurrency tools that you will know where to start the first time you need them
    to solve a complex problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you've worked with databases and web servers. On just about any software
    project, at least one of those two technologies will be present. Often, both will
    be. These are both vast topics in their own right, of course, but by now you have
    an idea of how to approach them in a Clojure way—and in a ClojureScript way, as
    you've done in this chapter. And beyond the details, we hope that your first steps
    in Clojure have opened your eyes to new ways of thinking about programming. That
    way, you'll be able to learn whatever you need down the road.
  prefs: []
  type: TYPE_NORMAL
