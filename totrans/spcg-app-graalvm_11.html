<html><head></head><body>
		<div id="_idContainer139">
			<h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor151"/>Chapter 8</em>: GraalVM Polyglot – Java on Truffle, Python, and R</h1>
			<p>In the previous chapter, we covered JavaScript and Node.js interpreters and interoperability between languages. In this chapter, we will cover other language implementations such as the following:</p>
			<ul>
				<li>Java on Truffle (also called Espresso): Java implementation on Truffle</li>
				<li>GraalPython: Python language interpreter implementation</li>
				<li>FastR: R language interpreter implementation</li>
			</ul>
			<p>All of these language implementations are still in the <em class="italic">experimental</em> phase so are not released for production at the time of writing the book. However, we will explore the features and build some code to understand the various concepts. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding Python, R, and Java/Truffle interpreters</li>
				<li>Learning about and exploring language interoperability</li>
				<li>Understanding the compatibility and limitations of these various language interpreters</li>
			</ul>
			<p>By the end of this chapter, you will have hands-on experience in building polyglot applications with Python, R, and Java/Truffle interpreters.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor152"/>Technical requirements</h1>
			<p>This chapter requires the following to follow along with the various coding/hands-on sections:</p>
			<ul>
				<li>The latest version of GraalVM. </li>
				<li>Various language Graal runtimes. We will cover in the chapter how to install and run these runtimes.</li>
				<li>Access to GitHub: There are some sample code snippets, which are available in a Git repository. The code can be downloaded from the following link: <a href="https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08">https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08</a>.</li>
				<li>The Code in Action video for this chapter can be found at <a href="https://bit.ly/3fj2iIr">https://bit.ly/3fj2iIr</a>.</li>
			</ul>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor153"/>Understanding Espresso (Java on Truffle)</h1>
			<p>GraalVM 21.0 is a major release that introduces a new guest language runtime called Java on Truffle. Before this, we had the option to run Java using HotSpot (which we<a id="_idIndexMarker632"/> covered in detail in <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, Hotspot, and GraalJIT</em>), on Graal JIT (which we covered in <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>), or as a native image with Graal AOT (which we covered in <a href="B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Graal Ahead-of-Time Compiler and Native Image</em>). With GraalVM 21.0, Java on Truffle is the new runtime, which can run Java. It is codenamed Espresso. This is still in the <em class="italic">experimental</em> phase and is not production-ready at the time of writing this book. In this section, we will understand how to run Java applications with this new runtime, and how this can help polyglot programming. </p>
			<p>Espresso is a cut-down version of JVM but implements all the core components of JVM, such as the bytecode interpreter, bytecode verifier, Java Native Interface, the Java Debug Wire Protocol, and so<a id="_idIndexMarker633"/> on. Espresso reuses all the classes and native libraries from GraalVM. Espresso implements the <strong class="bold">JRE</strong> (<strong class="bold">Java Runtime Environment</strong>) library <strong class="source-inline">libjvm. so</strong> APIs. The following figure shows the Espresso stack architecture:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_8.1_B16878.jpg" alt="Figure 8.1 – Espresso stack architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Espresso stack architecture</p>
			<p>The figure shows how Espresso is implemented on top of Truffle. </p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor154"/>Why do we need Java on Java?</h2>
			<p>Running Java on Truffle (Espresso) is <a id="_idIndexMarker634"/>counter-intuitive, and you might wonder<a id="_idIndexMarker635"/> about the advantage of running Java on Truffle, which adds an additional layer on top of Graal. The following are some of the advantages of running Espresso:</p>
			<ul>
				<li><strong class="bold">Hotswap methods, lambdas, and access modifiers at runtime/debug time</strong>: Espresso provides a way to hot-swap methods, lambdas, and access modifiers at runtime during debugging. This is a great feature for developers as it allows them to change the code completely while debugging, and without stopping the runtime and recompiling, the changes take effect at runtime. This speeds up the developer's workflow and increases productivity. It also helps the developers experiment and try things out before committing the code. </li>
				<li><strong class="bold">A sandbox to run untrusted Java code</strong>: Espresso runs like a sandbox on top of Truffle, which can run with access restrictions. This is a great way to run untrusted Java code, by providing specific access. Please refer to the <em class="italic">JavaScript embedded code in Java</em> section in <a href="B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 7</em></a>, <em class="italic">GraalVM Polyglot  - JavaScript and Node.js,</em> to understand more about how to configure the access restrictions.</li>
				<li><strong class="bold">Interoperability between JVM and non-JVM using the same memory space</strong>: Before Espresso, passing data between Java applications and non-JVM dynamic guest languages was not done in the same memory space. This might be because of the performance impact. With Espresso, we can pass data between Java and<a id="_idIndexMarker636"/> non-JVM guest languages in the same memory space. This increases the performance of the application.</li>
				<li><strong class="bold">Leveraging Truffle tools and instrumentation</strong>: Running Java on Truffle will help in using all the analysis, diagnosis, and debugging tools developed with Truffle instrumentation. (Refer to the <em class="italic">Understanding Truffle instrumentation </em>section of <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>.)</li>
				<li><strong class="bold">Ahead-of-time compilation</strong>: Espresso is fully built-in in Java, and so are Truffle and Graal. This enables <a id="_idIndexMarker637"/>Espresso to embed into the native image, just like other Truffle guest language interpreters do. This helps in running dynamic code (such as Reflection, JNI, and so on), which was one of the limitations of building native images (refer to the <em class="italic">Native image configuration</em> section of <a href="B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Graal Ahead-of-Time Compiler and Native Image</em>, for more details). We can now look at segregating the code that requires these dynamic features, and run it on Truffle, while the other parts of the code can be built to <strong class="source-inline">native-image</strong>. </li>
				<li><strong class="bold">Running mixed versions of Java</strong>: Espresso provides the required isolation layer to run Java code that is written in Java 8 to run on Java 11. The Java 8 code can be run on Espresso, which might be running on GraalVM Java 11. This helps in running older code, without changing it, and could be a step in carefully modernizing the code, instead of the big-bang modernization approach that we adopt when we move from the older version of Java to the newer version of Java. </li>
			</ul>
			<p>Let's now install and run simple Java code on Espresso.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor155"/>Installing and running Espresso</h2>
			<p>Espresso is an<a id="_idIndexMarker638"/> optional runtime; it has to be downloaded and installed separately using the Graal Updater tool. Here is the command to install <a id="_idIndexMarker639"/>Espresso:</p>
			<p class="source-code">gu install espresso</p>
			<p>To test whether Espresso is installed, let's execute a simple <strong class="source-inline">HelloEspresso.java</strong> application. It is a very simple <strong class="source-inline">Hello World</strong> program, which prints a message. Check out the following code for <strong class="source-inline">HelloEspresso.java</strong>:</p>
			<p class="source-code">public class HelloEspresso {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        System.out.println("Hello Welcome to Espresso!!!");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's compile this application using <strong class="source-inline">javac</strong> and run it with the following command:</p>
			<p class="source-code">javac HelloEspresso.java</p>
			<p>To run Java on Truffle, we just have to pass <strong class="source-inline">-truffle</strong> as a command-line argument to <strong class="source-inline">java</strong>. After running this, we should see the following output:</p>
			<p class="source-code">java -truffle HelloEspresso</p>
			<p class="source-code">Hello Welcome to Espresso!!!</p>
			<p>This validates the installation. We can also use the <strong class="source-inline">-jar</strong> argument along with <strong class="source-inline">-truffle</strong> to run a JAR file. Now let's explore the polyglot capabilities of Espresso.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor156"/>Exploring polyglot interoperability with Espresso</h2>
			<p>Espresso is<a id="_idIndexMarker640"/> built on Truffle and implements the Truffle polyglot and interoperability APIs. In this section, we will explore these features. </p>
			<p>Before we start <a id="_idIndexMarker641"/>using the polyglot features, we have to install Espresso polyglot features. To install Espresso polyglot features, we may have to download the Espresso JAR file. You can find the latest version at <a href="https://www.oracle.com/downloads/graalvm-downloads.html">https://www.oracle.com/downloads/graalvm-downloads.html</a>. </p>
			<p>The following screenshot shows the JAR file that we will have to download, at the time of writing the book: </p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_8.2_B16878.jpg" alt="Figure 8.2 – Java on Truffe JAR file download &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Java on Truffe JAR file download </p>
			<p>Once we download this file, we can install it by running the following command: </p>
			<p class="source-code">sudo gu install -L espresso-installable-svm-svmee-java11-darwin-amd64-21.0.0.2.jar</p>
			<p>Once the installation is successful, we have to rebuild the <strong class="source-inline">libpolyglot</strong> native image, to include Espresso libraries. This library is required to run polyglot support:</p>
			<p class="source-code">sudo gu rebuild-images libpolyglot -cp ${GRAALVM_HOME}/lib/graalvm/lib-espresso.jar</p>
			<p>This will rebuild the <strong class="source-inline">libpolyglot</strong> native image. We are now ready to use the polyglot capabilities of Espresso. Let's explore these features in the following section.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor157"/>Exploring Espresso interoperability with other Truffle languages</h2>
			<p>As you're now <a id="_idIndexMarker642"/>aware, Espresso implements the Truffle implementation framework and the <strong class="source-inline">com.oracle.truffle.espresso.polyglot.Polyglot</strong> class implements the polyglot in Espresso. Like any other guest language, we use <strong class="source-inline">-polyglot</strong> in the command-line argument to let Truffle know how to create the polyglot context. Espresso injects a <strong class="source-inline">Polyglot</strong> object into the code, which can be used to interoperate with other languages. Let's explore polyglot programming with Espresso by running the following code:</p>
			<p class="source-code">import com.oracle.truffle.espresso.polyglot.Polyglot;</p>
			<p class="source-code">public class EspressoPolyglot {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Object hello = Polyglot.eval("js",                "print('Hello from JS on Espresso');");</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's<a id="_idIndexMarker643"/> understand the preceding code. The <strong class="source-inline">Polyglot</strong> object provides context for running dynamic languages. The <strong class="source-inline">Polyglot.eval()</strong> method runs foreign language code. The first parameter suggests that it is JavaScript code, and the second parameter is the actual JavaScript code that we want to execute. Let's compile this code with the following command:</p>
			<p class="source-code">javac -cp ${GRAALVM_HOME}/languages/java/lib/polyglot.jar  EspressoPolyglot.java</p>
			<p>In this command, we are explicitly passing the <strong class="source-inline">polyglot.jar</strong> file in the <strong class="source-inline">-cp</strong> argument (<strong class="source-inline">CLASSPATH</strong>). <strong class="source-inline">polyglot.jar</strong> has all the polyglot implementation of Espresso, including the <strong class="source-inline">com.oracle.truffle.espresso.polyglot.Polyglot</strong> import.</p>
			<p>Let's now run the Java application on Espresso. We should pass the <strong class="source-inline">-truffle</strong> argument to run it on Espresso, if we don't do that, it runs on Host JVM. We can see the following output: </p>
			<p class="source-code">java -truffle --polyglot EspressoPolyglot</p>
			<p class="source-code">[To redirect Truffle log output to a file use one of the following options:</p>
			<p class="source-code">* '--log.file=&lt;path&gt;' if the option is passed using a guest language launcher.</p>
			<p class="source-code">* '-Dpolyglot.log.file=&lt;path&gt;' if the option is passed using the host Java launcher.</p>
			<p class="source-code">* Configure logging using the polyglot embedding API.]</p>
			<p class="source-code">Hello from JS on Espresso</p>
			<p>Similarly, we can<a id="_idIndexMarker644"/> call other language code. Java is a typed language, unlike other dynamically typed languages on Truffle. When we exchange data between Espresso (Java on Truffle) and other dynamically typed languages such as JavaScript, Python, and so on, we need a way to cast the data types. The <strong class="source-inline">polyglot</strong> object provides a way to cast the data with the <strong class="source-inline">Polyglot.cast()</strong> method. Let's use a simple application to understand how to cast the data, with the following code:</p>
			<p class="source-code">import com.oracle.truffle.espresso.polyglot.Polyglot;</p>
			<p class="source-code">import com.oracle.truffle.espresso.polyglot.Interop;</p>
			<p>Import the <strong class="source-inline">Polyglot</strong> and <strong class="source-inline">Interop</strong> classes. The <strong class="source-inline">Polyglot</strong> class helps us to run guest languages and the <strong class="source-inline">Interop</strong> class implements the Truffle interoperability API, which abstracts the data types between guest languages. Truffle defines an interoperability protocol that provides a clear specification on how the data and message (method calls) exchange happens between Truffle languages, tools, and embedders:</p>
			<p class="source-code">public class EspressoPolyglotCast {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Object stringObject = Polyglot.eval("js",                "'This is a JavaScript String'");</p>
			<p class="source-code">            Object integerObject = Polyglot.eval("js",                "1000");</p>
			<p class="source-code">            Object doubleObject = Polyglot.eval("js",                "10.12345");</p>
			<p class="source-code">            Object arrayObject = Polyglot.eval("js",                "[1234, 10.2233, 'String element',400,500,                    'Another Sttring element']");</p>
			<p class="source-code">            Object booleanObject = Polyglot.eval("js",                 "10 &gt; 5");</p>
			<p>In the preceding code snippet, we are evaluating<a id="_idIndexMarker645"/> various JavaScript code snippets that return a string, integer, double, an <strong class="source-inline">array</strong> of integers and a <strong class="source-inline">boolean</strong> value. These values are assigned to a generic <strong class="source-inline">Object</strong>, and then later cast to the respective Java type <strong class="source-inline">String</strong>, <strong class="source-inline">Integer</strong>, <strong class="source-inline">Double</strong>, <strong class="source-inline">Integer[]</strong>, and <strong class="source-inline">Boolean</strong> objects using <strong class="source-inline">Polyglot.cast()</strong>, as observed in the following code snippet: </p>
			<p class="source-code">            String localStringObject =                Polyglot.cast(String.class, stringObject);</p>
			<p class="source-code">            Integer localIntegerObject =                Polyglot.cast(Integer.class, integerObject);</p>
			<p class="source-code">            Double localDoubleObject =                Polyglot.cast(Double.class, doubleObject);</p>
			<p class="source-code">            Boolean localBooleanObject =                Polyglot.cast(Boolean.class, booleanObject);</p>
			<p class="source-code">            System.out.println("\nString Object : "                + localStringObject                     + ", \nInteger : " + localIntegerObject                     + ", \nDouble : " + localDoubleObject                     + ", \nBoolean : " + localBooleanObject); </p>
			<p>Next, we'll print the values. To handle arrays, let's use the <strong class="source-inline">Interop</strong> class to get information about the array object, such as the size of the array with <strong class="source-inline">Interop.getArraySize()</strong>, and iterate through the array with <strong class="source-inline">Interop.readArrayElement()</strong>. <strong class="source-inline">Interop</strong> also provides a way to check the type of the object and extract the value<a id="_idIndexMarker646"/> in a specific data type. In our example, we have evaluated a JavaScript array that has a sequence of integer, double, and string objects. We will use <strong class="source-inline">Interop.fitsInInt()</strong>, <strong class="source-inline">Interop.fitsInDouble()</strong>, and <strong class="source-inline">Interop.isString()</strong> methods to check the types, and accordingly extract the values using <strong class="source-inline">Interop.asInt()</strong>, <strong class="source-inline">Interop.asDouble()</strong>, and <strong class="source-inline">Interop.asString()</strong> methods. The following is the code snippet:</p>
			<p class="source-code">            long sizeOfArray =                Interop.getArraySize(arrayObject);</p>
			<p class="source-code">            System.out.println(            "\n Array of objects with Size : " + sizeOfArray );</p>
			<p class="source-code">            for (int i=0; i&lt;sizeOfArray; i++) {</p>
			<p class="source-code">                Object currentElement =                    Interop.readArrayElement</p>
			<p class="source-code">                    (arrayObject, i);</p>
			<p class="source-code">                if (Interop.fitsInInt(currentElement)) {</p>
			<p class="source-code">                    System.out.println("Integer Element: "                       +Interop.asInt(currentElement));</p>
			<p class="source-code">                }</p>
			<p class="source-code">                if (Interop.fitsInDouble(currentElement)) {</p>
			<p class="source-code">                    System.out.println("Double Element: "                        + Interop.asDouble(currentElement));</p>
			<p class="source-code">                }</p>
			<p class="source-code">                if (Interop.isString(currentElement)) {</p>
			<p class="source-code">                    System.out.println("String Element: "                        + Interop.asString(currentElement));</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>These values are then printed. Let's compile <a id="_idIndexMarker647"/>and run this application. The following is the output:</p>
			<p class="source-code">javac -cp ${GRAALVM_HOME}/languages/java/lib/polyglot.jar  EspressoPolyglotCast.java </p>
			<p class="source-code">espresso git:(main) java -truffle --polyglot EspressoPolyglotCast                                        </p>
			<p class="source-code">String Object : This is a JavaScript String, </p>
			<p class="source-code">Integer : 1000, </p>
			<p class="source-code">Double : 10.12345, </p>
			<p class="source-code">Boolean : true</p>
			<p class="source-code">Array of objects with Size : 6</p>
			<p class="source-code">Integer Element: 1234</p>
			<p class="source-code">Double Element: 1234.0</p>
			<p class="source-code">Double Element: 10.2233</p>
			<p class="source-code">String Element: String element</p>
			<p class="source-code">Integer Element: 400</p>
			<p class="source-code">Double Element: 400.0</p>
			<p class="source-code">Integer Element: 500</p>
			<p class="source-code">Double Element: 500.0</p>
			<p class="source-code">String Element: Another String element</p>
			<p>In the output, we can<a id="_idIndexMarker648"/> see how a dynamically cast language (JavaScript) is captured in a generic <strong class="source-inline">Object</strong> and later cast to specific types. We can also use <strong class="source-inline">Polyglot.isForeignObject(&lt;object&gt;)</strong> to check whether the passed object is a local object or a foreign object.</p>
			<p>We saw how we can call other Truffle languages from Espresso, the same way other languages are invoked with <strong class="source-inline">Context polyglot = Context.newBuilder().allowAllAccess(true).build()</strong> and using bindings (refer to the <em class="italic">Bindings</em> section of <a href="B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 7</em></a>, <em class="italic">GraalVM Polyglot  - JavaScript and Node.js</em>) to exchange data and invoke methods. </p>
			<p>Java on Truffle Espresso is in very early releases and is at an experimental stage at the time of writing this book. There are a lot of limitations at present, such as a lack of support for the JVM Tool Interface and Java <a id="_idIndexMarker649"/>Management Extensions. There are even a lot of performance issues at this point. Please refer to <a href="https://www.graalvm.org/reference-manual/java-on-truffle/">https://www.graalvm.org/reference-manual/java-on-truffle/</a> for the latest updates.</p>
			<p>Let's now look at two of the most important languages for machine learning – Python and R. </p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor158"/>Understanding GraalPython – the Python Truffle interpreter</h1>
			<p>GraalVM provides a Python<a id="_idIndexMarker650"/> runtime. The Python runtime is 3.8 version-compliant and is still in the <em class="italic">experimental</em> phase at the time of writing this book. In this section, we will install and understand how Python runs on Truffle and Graal. We will also build some sample code, to understand the interoperability features of Graal Python.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor159"/>Installing Graal Python</h2>
			<p>Graal Python is an<a id="_idIndexMarker651"/> optional runtime and is not installed by default along with GraalVM. To download it, you have to use the Graal Updater tool. The following command downloads and installs Graal Python:</p>
			<p class="source-code">gu install python</p>
			<p>To validate the installation, let's run simple Python code. The following is the source code of <strong class="source-inline">HelloGraalPython.py</strong>:</p>
			<p class="source-code">print("Hello Graal Python")</p>
			<p>It's a very simple Hello World application where we are printing the message. Let's run this application using <strong class="source-inline">graalpython</strong>:</p>
			<p class="source-code"><strong class="source-inline">graalpython HelloGraalPython.py</strong></p>
			<p>When we execute the preceding command, we should see the output shown next:</p>
			<p class="source-code">graalpython HelloGraalPython.py </p>
			<p class="source-code">Hello Graal Python</p>
			<p>The preceding output shows that the application is running, and <strong class="source-inline">graalpython</strong> is working. </p>
			<p><strong class="source-inline">graalpython</strong> also supports a virtual environment. The following command will create a virtual environment:</p>
			<p class="source-code">graalpython -m venv &lt;name-of-virtual-env&gt;</p>
			<p>This command will create a virtual environment directory, which will be an isolated environment. GraalPython also comes with <strong class="source-inline">ginstall</strong>, a tool to install supported libraries. The following command will install <strong class="source-inline">numpy</strong> for <strong class="source-inline">graalpython</strong>. <strong class="source-inline">pip</strong> can also be used to install libraries:</p>
			<p class="source-code">graalpython -m ginstall install numpy</p>
			<p>Let's now understand how the GraalPython compilation and interpreter pipeline works.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor160"/>Understanding the graalpython compilation and interpreter pipeline </h2>
			<p>Graalpython is a slightly <a id="_idIndexMarker652"/>different compilation/interpreter pipeline. To<a id="_idIndexMarker653"/> improve the performance of parsing, Graalpython uses an intermediate<a id="_idIndexMarker654"/> representation called <strong class="bold">Simple Syntax Tree</strong> (<strong class="bold">SST</strong>) and <strong class="bold">Scope Tree</strong> (<strong class="bold">ST</strong>). SST is<a id="_idIndexMarker655"/> a simpler representation of the source file, mirroring the source. Typically, when SST is translated to AST, one node in SST may translate to multiple nodes in AST. ST captures the scope information of variables and functions. Together SST and ST are serialized to a <strong class="source-inline">.pyc</strong> file, after the parsing. This is done to speed up the parsing. The next time we run the Python program, <strong class="source-inline">Graalpython</strong> looks for the <strong class="source-inline">.pyc</strong> file and validates whether the file exists, and if it matches the Python source code, then it will deserialize that to build the SST and ST. Otherwise, it will do a full parsing using ANTLR. The following figure shows the full flow. The diagram does not capture all the details. Refer to the <em class="italic">Exploring the Truffle Interpreter/Compiler pipeline</em> section in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview,</em> for a more detailed explanation on how Truffle interpreters and Graal JIT execute the code:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_8.3_B16878.jpg" alt="Figure 8.3 – Graalpython compilation/interpreter pipeline &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Graalpython compilation/interpreter pipeline </p>
			<p>Once the SST<a id="_idIndexMarker656"/> and ST are created, they are then converted to an AST<a id="_idIndexMarker657"/> intermediate representation and optimized. The final specialized AST is submitted to GraalJIT for further execution after partial evaluation, and the usual flow continues, as explained in <em class="italic">Exploring the Truffle interpreter/compiler pipeline</em> section of <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>.</p>
			<p>So far, we have learned how to run Python programs with GraalPython and how GraalPython optimizes the parsing and optimizes the code using Truffle and GraalJIT. Let's now explore the polyglot interoperability features of GraalPython.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor161"/>Exploring interoperability between Java and Python</h2>
			<p>In this section, we will explore the<a id="_idIndexMarker658"/> interoperability between Java and Python with sample Java code. The following code calculates the sum of Fibonacci numbers. This class has a <strong class="source-inline">findFibonacci()</strong> method, which takes in the number of Fibonacci numbers we need and returns an array of those Fibonacci numbers:</p>
			<p class="source-code">public class FibonacciCalculator{</p>
			<p class="source-code">    public int[] findFibonacci(int count) {</p>
			<p class="source-code">        int fib1 = 0;</p>
			<p class="source-code">        int fib2 = 1;</p>
			<p class="source-code">        int currentFib, index;</p>
			<p class="source-code">        int [] fibNumbersArray = new int[count];</p>
			<p class="source-code">        for(index=2; index &lt; count; ++index ) {</p>
			<p class="source-code">            currentFib = fib1 + fib2;</p>
			<p class="source-code">            fib1 = fib2;</p>
			<p class="source-code">            fib2 = currentFib;</p>
			<p class="source-code">            fibNumbersArray[index - 1] = currentFib;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return fibNumbersArray;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String args[]) {    </p>
			<p class="source-code">        FibonacciCalculator fibCal =             new FibonacciCalculator();</p>
			<p class="source-code">        int[] fibs = fibCal.findFibonacci(10);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's now call the <strong class="source-inline">findFibonacci()</strong> method from Python code. The following is the Python code for calling the method and iterating<a id="_idIndexMarker659"/> through the array that is returned by the Java class:</p>
			<p class="source-code">import java</p>
			<p class="source-code">import time</p>
			<p class="source-code">fib = java.type("FibonacciCalculator")()</p>
			<p class="source-code">result = fib.findFibonacci(10)</p>
			<p class="source-code">print("Fibonacci number ")</p>
			<p class="source-code">for num in result:</p>
			<p class="source-code">    print(num)</p>
			<p>In the preceding code, we are using <strong class="source-inline">java.type()</strong> to load the Java class, and we are directly using the returned value as a Python object to call the <strong class="source-inline">findFibonacci()</strong> method, by passing a parameter. We are then able to parse through the result that is returned by the method. Let's compile the Java code and run the Python code. The following shows the terminal output:</p>
			<p class="source-code">javac FibonacciCalculator.java</p>
			<p class="source-code">graalpython --jvm --vm.cp=. FibCal.py</p>
			<p class="source-code">Fibonacci number </p>
			<p class="source-code">0</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">3</p>
			<p class="source-code">5</p>
			<p class="source-code">8</p>
			<p class="source-code">13</p>
			<p class="source-code">21</p>
			<p class="source-code">34</p>
			<p>We can see that we are able to call the Java method and get an array of integers and iterate through that, without any extra code for conversion. </p>
			<p>Now let's create a simple Python function that uses NumPy to do some quick analysis on a dataset. NumPy is a high-performing Python library for array/matrix manipulations and is widely used in machine learning. To appreciate the value of Graal polyglot, imagine a use case where <a id="_idIndexMarker660"/>we have a dataset that has information about various heart attack cases, organized by age, sex, cholesterol levels, chest pain level, and so on, and we want to understand what the average age of the people who had a heart attack after level 3 (high) chest pain is. That is what we will build in this section, to understand the polyglot interoperability between Java and Python, and how we can use the NumPy Python library. </p>
			<p>We will use the dataset that is provided on Kaggle on heart attack analysis (<a href="https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset">https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset</a>). This dataset has information about the various heart attack cases, with age, cholesterol levels, sex, chest pain levels, and so on. Here is the Python code to perform the analysis: </p>
			<p class="source-code">import site</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import polyglot as poly</p>
			<p class="source-code">def heartAnalysis():</p>
			<p class="source-code">    heartData = np.genfromtxt('heart.csv', delimiter=',')</p>
			<p class="source-code">    dataOfPeopleWith3ChestPain =         heartData[np.where(heartData[:,2]&gt;2)]</p>
			<p class="source-code">    averageAgeofPeopleWith3ChestPain =        np.average(dataOfPeopleWith3ChestPain[:,0])</p>
			<p class="source-code">    # Average age of people who are getting level 3 and     greater chest pain</p>
			<p class="source-code">    return averageAgeofPeopleWith3ChestPain</p>
			<p class="source-code">poly.export_value("hearAnalysis", heartAnalysis)</p>
			<p>In the preceding <a id="_idIndexMarker661"/>code, we are loading the CSV file into a matrix. Here, we are particularly interested in the third column (indexed as <strong class="source-inline">2</strong>). We are loading all the rows where the third column value is greater than 2, and storing it in another variable. We are then averaging that matrix and returning it. This would have taken a lot of code if we had to do the same in Java. Now, let's call this code from Java. </p>
			<p>In the following Java code, we will be importing the function definition using the key through the <strong class="source-inline">Binding</strong> object. Here's the complete Java code:</p>
			<p class="source-code">public class NumPyJavaExample {</p>
			<p class="source-code">    public void callPythonMethods() {</p>
			<p class="source-code">        Context ctx =</p>
			<p class="source-code">        Context.newBuilder().allowAllAccess(true).build();</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            File fibCal = new File("./numpy-example.py");</p>
			<p class="source-code">            ctx.eval(Source.newBuilder("python",                fibCal).build());</p>
			<p class="source-code">            Value hearAnalysisFn =                ctx.getBindings("python")                    .getMember("heartAnalysis");</p>
			<p class="source-code">            Value heartAnalysisReport =                hearAnalysisFn.execute();</p>
			<p class="source-code">            System.out.println(                "Average age of people who are getting level 3                     and greater chest pain :" +                        heartAnalysisReport.toString());</p>
			<p class="source-code">        }   catch (Exception e) {</p>
			<p class="source-code">            System.out.println("Exception : " );</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        NumPyJavaExample obj = new NumPyJavaExample();</p>
			<p class="source-code">        obj.callPythonMethods();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the previous Java code, we are <a id="_idIndexMarker662"/>creating a <strong class="source-inline">Context</strong> object and evaluating the Python code in <strong class="source-inline">numpy-example.py</strong>. We are then accessing the function definition through binding and invoking the Python function and are able to get the value. We are printing the value that is returned. The following is the output of running this Java code:</p>
			<p class="source-code">$ java NumPyJavaExample</p>
			<p class="source-code">Average age of people who are getting level 3 and greater chest pain :55.869565217391305</p>
			<p>In the preceding output, we can see that the first call took time, however, the subsequent calls took almost no time at all to execute. This not only demonstrates how we can interoperate with Python code from Java code but also how Truffle and Graal optimize the execution. </p>
			<p>In this section, we <a id="_idIndexMarker663"/>explored Java and Python interoperability. In the next section, we will explore interoperability between dynamic languages with Python.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor162"/>Exploring interoperability between Python and other dynamic languages</h2>
			<p>To explore interoperability <a id="_idIndexMarker664"/>between Python and other dynamic languages, let's use the same <strong class="source-inline">numpy-example.py</strong> that we used in the previous section. Let's call this method from JavaScript. </p>
			<p>The following is the JavaScipt that calls the Python code:</p>
			<p class="source-code">function callNumPyExmple() {</p>
			<p class="source-code">    Polyglot.evalFile('python', './numpy-example.py');</p>
			<p class="source-code">    heartAnalysis = Polyglot.import('heartAnalysis');</p>
			<p class="source-code">    result = heartAnalysis();</p>
			<p class="source-code">    return result;</p>
			<p class="source-code">}</p>
			<p class="source-code">result = callNumPyExmple();</p>
			<p class="source-code">print ('Average age of people who are getting level 3 and     greater chest pain : '+  String(result));</p>
			<p>In the previous code, we can see how we are importing the Python <strong class="source-inline">heartAnalysis()</strong> function in JavaScript using the <strong class="source-inline">Polyglot.import()</strong> function. This returns the average value that we are printing. Let's run this code, and we can see the following result: </p>
			<p class="source-code">$ js --polyglot numpy-caller.js</p>
			<p class="source-code">Average age of people who are getting level 3 and greater chest pain : 55.869565217391305</p>
			<p>Let's now create JavaScript code, which will have functions to calculate squares. To demonstrate how JavaScript code<a id="_idIndexMarker665"/> can be called from Python, here's the JavaScript code:</p>
			<p class="source-code">var helloMathMessage = " Hello Math.js";</p>
			<p class="source-code">function square(a) {</p>
			<p class="source-code">    return a*a;</p>
			<p class="source-code">}</p>
			<p class="source-code">Polyglot.export('square', square);</p>
			<p class="source-code">Polyglot.export('message', helloMathMessage)</p>
			<p>It's a very simple JavaScript function that returns the square of the passed value. We are also exporting the <strong class="source-inline">square()</strong> function and a variable message, which carries the value of the <strong class="source-inline">helloMathMessage</strong> variable. </p>
			<p>Now let's invoke this method from Python code. The following is the Python code that will import and invoke the preceding JavaScript methods:</p>
			<p class="source-code">import polyglot</p>
			<p class="source-code">polyglot.eval(path="./math.js", language="js")</p>
			<p class="source-code">message = polyglot.import_value('message')</p>
			<p class="source-code">square = polyglot.import_value('square')</p>
			<p class="source-code">print ("Square numbers by calling JS-&gt;Python: " +     str(square(10, 20)))</p>
			<p class="source-code">print ("Hello message from JS: " + message)</p>
			<p>In this code, we are using the Python <strong class="source-inline">polyglot</strong> object to evaluate the JavaScript file. We then imported all the exported functions/variables by calling the <strong class="source-inline">polyglot.import_value()</strong> function, by using the same key used by JavaScript to export functions or variables. We are then able to invoke those functions and access the <strong class="source-inline">message</strong> variable and print the values. The following output is what you get after you run the preceding code:</p>
			<p class="source-code">$ graalpython --jvm --polyglot mathUser.py</p>
			<p class="source-code">Square numbers by calling JS-&gt;Python: 100</p>
			<p class="source-code">Hello messagr from JS:  Hello Math.js  </p>
			<p>We can see how Python<a id="_idIndexMarker666"/> code is importing and invoking JavaScript code. This demonstrates two-way interoperability. The code is very similar to other languages, such as R and Ruby.</p>
			<p>In this section, we explored and gained a good understanding of how the Python interpreter works with Truffle to run optimally on GraalVM. Let's now explore and understand the R language interpreter on GraalVM.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor163"/>Understanding FastR – the R Truffle interpreter</h1>
			<p>GraalVM provides <a id="_idIndexMarker667"/>an R Truffle interpreter for a GNU-compatible R runtime. This runtime supports R programs and <strong class="bold">REPL</strong> (<strong class="bold">read-eval-print-loop</strong>) mode, where we can rapidly test the code while we write the code interactively. FastR is the project that developed this R runtime. </p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor164"/>Installing and running R </h2>
			<p>Just like Graal Python, the R<a id="_idIndexMarker668"/> runtime does not come with GraalVM by default. We have to <a id="_idIndexMarker669"/>download and install it using Graal Updater. Use the following command to download and install R and Rscript:</p>
			<p class="source-code">gu install r</p>
			<p>To run R, we need the OpenMP runtime library. This can be installed using <strong class="source-inline">apt-get install libcomp1</strong> on Ubuntu and <strong class="source-inline">yum install libcomp</strong> on Oracle Linux. The library is installed in macOS by default. Apart from this, you will need C/C++/Fortran, if the R code has C/C++/Fortran code. R is also in the experimental phase at the time of writing this book, so not everything is supported yet. Please refer to the GraalVM documentation (<a href="https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/">https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/</a>) for the latest information. </p>
			<p>Let's now test R. To<a id="_idIndexMarker670"/> explore the R interpreter, let's run it in interactive mode. The following terminal output<a id="_idIndexMarker671"/> shows the interactive mode to test R installation: </p>
			<p class="source-code">R</p>
			<p class="source-code">R version 3.6.1 (FastR)</p>
			<p class="source-code">Copyright (c) 2013-19, Oracle and/or its affiliates</p>
			<p class="source-code">Copyright (c) 1995-2018, The R Core Team</p>
			<p class="source-code">Copyright (c) 2018 The R Foundation for Statistical Computing</p>
			<p class="source-code">Copyright (c) 2012-4 Purdue University</p>
			<p class="source-code">Copyright (c) 1997-2002, Makoto Matsumoto and Takuji Nishimura</p>
			<p class="source-code">All rights reserved.</p>
			<p class="source-code">FastR is free software and comes with ABSOLUTELY NO WARRANTY.</p>
			<p class="source-code">You are welcome to redistribute it under certain conditions.</p>
			<p class="source-code">Type 'license()' or 'licence()' for distribution details.</p>
			<p class="source-code">R is a collaborative project with many contributors.</p>
			<p class="source-code">Type 'contributors()' for more information.</p>
			<p class="source-code">Type 'q()' to quit R.</p>
			<p class="source-code">[Previously saved workspace restored]</p>
			<p>We see that we <a id="_idIndexMarker672"/>are using the FastR GraalVM version from the version numbers listed <a id="_idIndexMarker673"/>in the preceding output. Let's now test whether our FastR interpreter is working by running some Python commands as shown next:</p>
			<p class="source-code">&gt; 1+1</p>
			<p class="source-code">[1] 2</p>
			<p class="source-code">&gt; abs(-200)</p>
			<p class="source-code">[1] 200</p>
			<p>We can see that it is interactively providing the results. Let's now just plot a simple example. The best way is to call <strong class="source-inline">example()</strong>, which will show the plot, as shown next: </p>
			<p class="source-code">&gt; example (plot)</p>
			<p class="source-code">plot&gt; require(stats) # for lowess, rpois, rnorm</p>
			<p class="source-code">plot&gt; plot(cars)</p>
			<p class="source-code">plot&gt; lines(lowess(cars))</p>
			<p class="source-code">NULL</p>
			<p class="source-code">plot&gt; plot(sin, -pi, 2*pi) # see ?plot.function</p>
			<p class="source-code">NULL</p>
			<p class="source-code">plot&gt; ## Discrete Distribution Plot:</p>
			<p class="source-code">plot&gt; plot(table(rpois(100, 5)), type = "h", col = "red", lwd = 10,</p>
			<p class="source-code">plot+      main = "rpois(100, lambda = 5)")</p>
			<p class="source-code">NULL</p>
			<p class="source-code">plot&gt; ## Simple quantiles/ECDF, see ecdf() {library(stats)} for a better one:</p>
			<p class="source-code">plot&gt; plot(x &lt;- sort(rnorm(47)), type = "s", main = "plot(x, type = \"s\")")</p>
			<p class="source-code">plot&gt; points(x, cex = .5, col = "dark red")</p>
			<p>This will result in <a id="_idIndexMarker674"/>a pop-up window <a id="_idIndexMarker675"/>with the plotted graph. The following figure shows a screenshot of the graph that popped up:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_8.4_B16878.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – R Plot output screenshot</p>
			<p>At the time of <a id="_idIndexMarker676"/>writing this book, some warnings appeared while running the preceding <strong class="source-inline">plot</strong> commands. These <a id="_idIndexMarker677"/>warnings list some of the limitations of FastR. However, this might change in upcoming versions. The following are the warnings that popped up: </p>
			<p class="source-code">NULL</p>
			<p class="source-code">Warning messages:</p>
			<p class="source-code">1: In lines.default(lowess(cars)) :</p>
			<p class="source-code">  lines.default not supported. Note: FastR does not support graphics package and most of its functions. Please use grid package or grid based packages like lattice instead.</p>
			<p class="source-code">2: In plot.function(sin, -pi, 2 * pi) :</p>
			<p class="source-code">  plot.function not supported. Note: FastR does not support graphics package and most of its functions. Please use grid package or grid based packages like lattice instead.</p>
			<p class="source-code">3: In axis(...) :</p>
			<p class="source-code">  axis not supported. Note: FastR does not support graphics package and most of its functions. Please use grid package or grid based packages like lattice instead.</p>
			<p class="source-code">4: In points.default(x, cex = 0.5, col = "dark red") :</p>
			<p class="source-code">  points.default not supported. Note: FastR does not support graphics package and most of its functions. Please use grid package or grid based packages like lattice instead.</p>
			<p class="source-code">&gt;</p>
			<p>Now that we can<a id="_idIndexMarker678"/> see R is working fine, let's now explore the interoperability<a id="_idIndexMarker679"/> features of FastR. </p>
			<h2 id="_idParaDest-158">Exploring the inter<a id="_idTextAnchor165"/>operability of R</h2>
			<p>In this section, to explore<a id="_idIndexMarker680"/> polyglot and interoperability with R, we will run some inline JavaScript and also load sample JavaScript code and import the exported functions and variables. We will use R interactive mode to do this so that it's easy to understand. To run R in polyglot mode, we have to pass the <strong class="source-inline">--polyglot</strong> argument. The following is the command:</p>
			<p class="source-code">R --polyglot</p>
			<p>This will start the R runtime in interactive mode with the following output: </p>
			<p class="source-code">R version 3.6.1 (FastR)</p>
			<p class="source-code">Copyright (c) 2013-19, Oracle and/or its affiliates</p>
			<p class="source-code">Copyright (c) 1995-2018, The R Core Team</p>
			<p class="source-code">Copyright (c) 2018 The R Foundation for Statistical Computing</p>
			<p class="source-code">Copyright (c) 2012-4 Purdue University</p>
			<p class="source-code">Copyright (c) 1997-2002, Makoto Matsumoto and Takuji Nishimura</p>
			<p class="source-code">All rights reserved.</p>
			<p class="source-code">FastR is free software and comes with ABSOLUTELY NO WARRANTY.</p>
			<p class="source-code">You are welcome to redistribute it under certain conditions.</p>
			<p class="source-code">Type 'license()' or 'licence()' for distribution details.</p>
			<p class="source-code">R is a collaborative project with many contributors.</p>
			<p class="source-code">Type 'contributors()' for more information.</p>
			<p class="source-code">Type 'q()' to quit R.</p>
			<p class="source-code">[Previously saved workspace restored]</p>
			<p class="source-code">&gt; </p>
			<p>Now, let's start with <a id="_idIndexMarker681"/>simple inline JavaScript:</p>
			<p class="source-code">&gt; x &lt;- eval.polyglot('js','[100,200,300,400]')</p>
			<p class="source-code">&gt; print(x)</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">[1] 100 200 300 400</p>
			<p class="source-code">&gt; print(x[3])</p>
			<p class="source-code">[1] 300</p>
			<p>In the preceding interactive session, we are calling the <strong class="source-inline">eval.polyglot()</strong> function, with the language ID and the expression. In this case, we are specifying it as JavaScript with a language ID of <strong class="source-inline">js</strong> and then passing an array of elements. Then we are printing the array and the third element in the array. The <strong class="source-inline">eval.polyglot()</strong> function provides the polyglot<a id="_idIndexMarker682"/> context and runs other language code. Now let's load a simple JavaScript code file. The following is the code for <strong class="source-inline">math.js</strong>: </p>
			<p class="source-code">var helloMathMessage = " Hello Math.js";</p>
			<p class="source-code">function add(a, b) {</p>
			<p class="source-code">    print("message from js: add() called");</p>
			<p class="source-code">    return a+b;</p>
			<p class="source-code">}</p>
			<p class="source-code">function subtract(a, b) {</p>
			<p class="source-code">    print("message from js: subtract() called");</p>
			<p class="source-code">    return a-b;</p>
			<p class="source-code">}</p>
			<p class="source-code">function multiply(a, b) {</p>
			<p class="source-code">    print("message from js: multiply() called");</p>
			<p class="source-code">    return a*b;</p>
			<p class="source-code">}</p>
			<p class="source-code">Polyglot.export('add', add);</p>
			<p class="source-code">Polyglot.export('subtract', subtract);</p>
			<p class="source-code">Polyglot.export('multiply', multiply);</p>
			<p class="source-code">Polyglot.export('message', helloMathMessage)</p>
			<p>The preceding code is very straightforward. We have defined the <strong class="source-inline">add()</strong>, <strong class="source-inline">subtract()</strong>, and <strong class="source-inline">multiply()</strong> functions and a simple variable, <strong class="source-inline">message</strong>, which has a string value, <strong class="source-inline">Hello Math.js</strong>. We are then using <strong class="source-inline">Polyglot.export()</strong> to export it for other languages to have access to these functions and the variable. </p>
			<p>Now let's load this<a id="_idIndexMarker683"/> JavaScript file and execute the exported code; we will be running the instructions in interactive mode. You'll find the interactive session here, with an explanation of what we are doing:</p>
			<p class="source-code">&gt; mathjs &lt;- eval.polyglot('js', path='/chapter8/r/math.js')</p>
			<p>This instruction loads the JavaScript file. Make sure that the path is updated with the exact path where you have the JavaScript file. Now let's import the exported functions and variable into R:</p>
			<p class="source-code">&gt; message &lt;- import('message')</p>
			<p class="source-code">&gt; add &lt;- import('add')</p>
			<p class="source-code">&gt; subtract &lt;- import('subtract')</p>
			<p class="source-code">&gt; multiply &lt;- import('multiply')</p>
			<p>In the preceding instructions, we are using the <strong class="source-inline">import()</strong> function to import the exported functions and variables. It is very important to use the same string that we used to export in the JavaScript file. These imports are assigned to a variable. Now let's call these functions and print the variable:</p>
			<p class="source-code">&gt; add(10,20)</p>
			<p class="source-code">message from js: add() called</p>
			<p class="source-code">[1] 30</p>
			<p class="source-code">&gt; subtract(30,20)</p>
			<p class="source-code">message from js: subtract() called</p>
			<p class="source-code">[1] 10</p>
			<p class="source-code">&gt; multiply(10,40)</p>
			<p class="source-code">message from js: multiply() called</p>
			<p class="source-code">[1] 400</p>
			<p class="source-code">&gt; print(message)</p>
			<p class="source-code">[1] " Hello Math.js"</p>
			<p class="source-code">&gt;</p>
			<p>As you can see, we can <a id="_idIndexMarker684"/>call the JavaScript functions and print the variable. This demonstrates how we can use JavaScript but we can similarly use all other Truffle languages. Let's now explore how to access a Java class from R. Here is the code for the <strong class="source-inline">HelloRPolyglot</strong> class, which we will be calling from R: </p>
			<p class="source-code">import org.graalvm.polyglot.Context;</p>
			<p class="source-code">import org.graalvm.polyglot.Value;</p>
			<p class="source-code">public class HelloRPolyglot {</p>
			<p class="source-code">    public String hello(String name) {</p>
			<p class="source-code">        System.out.println("Hello Welcome from hello");</p>
			<p class="source-code">        return "Hello Welcome from hello " + name;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void helloStatic() {</p>
			<p class="source-code">        System.out.println("Hello from Static hello()");</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Context polyglot = Context.create();</p>
			<p class="source-code">            Value array = polyglot.eval("js",                 "print('Hello from JS inline in HelloRPolyglot                     class')");</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        HelloRPolyglot.helloStatic();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's understand the<a id="_idIndexMarker685"/> preceding code. We have a static method, <strong class="source-inline">helloStatic()</strong>, that calls inline JavaScript, which prints a message, and we have another method, <strong class="source-inline">hello()</strong>, that takes an argument and prints a <strong class="source-inline">hello</strong> message.</p>
			<p>Let's compile and run the Java class to test whether it works fine. The following shows the console output:</p>
			<p class="source-code">javac HelloRPolyglot.java</p>
			<p class="source-code">java HelloRPolyglot</p>
			<p class="source-code">Hello Welcome to R Polyglot!!!</p>
			<p class="source-code">Hello from JS inline in HelloRPolyglot class</p>
			<p>Now that the class is working fine, let's start the R interactive mode. This time, we have to pass the <strong class="source-inline">--jvm</strong> argument to let the R runtime know that we will be using Java, and also pass the <strong class="source-inline">--vm</strong> argument, to set <strong class="source-inline">CLASSPATH</strong> to the current directory where we have the Java class file: </p>
			<p class="source-code">R --jvm --vm.cp=.        </p>
			<p class="source-code">R version 3.6.1 (FastR)</p>
			<p class="source-code">Copyright (c) 2013-19, Oracle and/or its affiliates</p>
			<p class="source-code">Copyright (c) 1995-2018, The R Core Team</p>
			<p class="source-code">Copyright (c) 2018 The R Foundation for Statistical Computing</p>
			<p class="source-code">Copyright (c) 2012-4 Purdue University</p>
			<p class="source-code">Copyright (c) 1997-2002, Makoto Matsumoto and Takuji Nishimura</p>
			<p class="source-code">All rights reserved.</p>
			<p class="source-code">FastR is free software and comes with ABSOLUTELY NO WARRANTY.</p>
			<p class="source-code">You are welcome to redistribute it under certain conditions.</p>
			<p class="source-code">Type 'license()' or 'licence()' for distribution details.</p>
			<p class="source-code">R is a collaborative project with many contributors.</p>
			<p class="source-code">Type 'contributors()' for more information.</p>
			<p class="source-code">Type 'q()' to quit R.</p>
			<p class="source-code">[Previously saved workspace restored]</p>
			<p class="source-code">&gt;</p>
			<p>Now that the <a id="_idIndexMarker686"/>R is loaded, let's run the instructions to call the <strong class="source-inline">hello()</strong> method in the Java class. We use the <strong class="source-inline">java.type()</strong> function to load the class. The following is the interactive session:</p>
			<p class="source-code">&gt; class &lt;- java.type('HelloRPolyglot')</p>
			<p class="source-code">&gt; print(class)</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$main</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$helloStatic</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$class</p>
			<p class="source-code">[polyglot value]</p>
			<p>In the preceding interactive session, we can see that the class is loaded successfully, and when we print the<a id="_idIndexMarker687"/> class, we see that it lists the various methods in it. Now let's create an instance of this class. We use the <strong class="source-inline">new()</strong> function to do that. The following is the output of the interactive session with the <strong class="source-inline">new()</strong> function:</p>
			<p class="source-code">&gt; object &lt;- new(class)</p>
			<p class="source-code">&gt; print(object)</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$main</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$helloStatic</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$class</p>
			<p class="source-code">[polyglot value]</p>
			<p class="source-code">$hello</p>
			<p class="source-code">[polyglot value]</p>
			<p>In the preceding code, we can see that the object is successfully created, as it prints all the methods in the <a id="_idIndexMarker688"/>class. Now let's call these methods. We will use the class to call the static method and object to call <strong class="source-inline">hello()</strong>, by passing a parameter. The following is the output of the interactive session:</p>
			<p class="source-code">&gt; class$helloStatic()</p>
			<p class="source-code">Hello from Static heloo()</p>
			<p class="source-code">Hello from JS inline in HelloRPolyglot class</p>
			<p class="source-code">NULL</p>
			<p class="source-code">&gt; object$hello('FastR')</p>
			<p class="source-code">Hello Welcome from hello</p>
			<p class="source-code">[1] "Hello Welcome from hello FastR"</p>
			<p class="source-code">&gt;</p>
			<p>In the preceding session, we can see the output of calling both the methods.</p>
			<p>Let's take a <a id="_idIndexMarker689"/>real-life example of how we can use the power of plotting a graph using R and use the plotted graph in <a id="_idIndexMarker690"/>Node.js. Earlier in the chapter, we used a dataset that we got from Kaggle that has heart attack data. Let's use that dataset to plot a graph comparing the ages of people and their cholesterol levels on a web page that is generated by Node.js.</p>
			<p>Let's initialize a Node.js project with npm init. The following is the output console where we are providing the name of the project and other project parameters:</p>
			<p class="source-code">$ npm init</p>
			<p class="source-code">This utility will walk you through creating a package.json file.</p>
			<p class="source-code">It only covers the most common items, and tries to guess sensible defaults.</p>
			<p class="source-code">See `npm help init` for definitive documentation on these fields and exactly what they do.</p>
			<p class="source-code">Use `npm install &lt;pkg&gt;` afterwards to install a package and save it as a dependency in the package.json file.</p>
			<p class="source-code">Press ^C at any time to quit.</p>
			<p class="source-code">package name: (plotwithr-node)</p>
			<p class="source-code">version: (1.0.0)</p>
			<p class="source-code">description:</p>
			<p class="source-code">entry point: (plotWithR.js)</p>
			<p class="source-code">test command:</p>
			<p class="source-code">git repository:</p>
			<p class="source-code">keywords:</p>
			<p class="source-code">author:</p>
			<p class="source-code">license: (ISC)</p>
			<p class="source-code">About to write to /Users/vijaykumarab/AB-Home/Developer/GraalVM-book/Code/chapter8/r/plotWithR-node/package.json:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "plotwithr-node",</p>
			<p class="source-code">  "version": "1.0.0",</p>
			<p class="source-code">  "description": "",</p>
			<p class="source-code">  "main": "plotWithR.js",</p>
			<p class="source-code">  "scripts": {</p>
			<p class="source-code">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "author": "",</p>
			<p class="source-code">  "license": "ISC"</p>
			<p class="source-code">}</p>
			<p class="source-code">Is this OK? (yes)</p>
			<p>This should<a id="_idIndexMarker691"/> generate a Node.js boilerplate. We will need the Express.js library to  expose a REST endpoint. Let's <a id="_idIndexMarker692"/>now install the express library and use <strong class="source-inline">--save</strong> to update the <strong class="source-inline">package.json</strong> file with the dependency. Here's the output:</p>
			<p class="source-code">$ npm install express --save</p>
			<p class="source-code">added 50 packages, and audited 51 packages in 2s</p>
			<p class="source-code">found 0 vulnerabilities</p>
			<p>Let's now write the Node.js code to load the dataset (<strong class="source-inline">heart.csv</strong>) and render a bar chart as a <strong class="source-inline">scalar vector graph</strong> (<strong class="source-inline">SVG</strong>). To plot, we will be using the Lattice package (you can find more details about this library at <a href="https://www.statmethods.net/advgraphs/trellis.html">https://www.statmethods.net/advgraphs/trellis.html</a>).</p>
			<p>So, here's the Node.js code:</p>
			<p class="source-code">const express = require('express')</p>
			<p class="source-code">const app = express()</p>
			<p class="source-code">app.get('/plot', function (req, res) {</p>
			<p class="source-code">  var text = ""</p>
			<p class="source-code">  text += Polyglot.eval('R',</p>
			<p class="source-code">    `svg();</p>
			<p class="source-code">     require(lattice);</p>
			<p class="source-code">     data &lt;- read.csv("heart.csv", header = TRUE)</p>
			<p class="source-code">     print(barchart(data$age~data$chol,           main="Age vs Cholestral levels"))</p>
			<p class="source-code">     grDevices:::svg.off()</p>
			<p class="source-code">    `);</p>
			<p class="source-code">  res.send(text)</p>
			<p class="source-code">})</p>
			<p class="source-code">app.listen(3000, function () {</p>
			<p class="source-code">  console.log('Plot with R -  listening on port 3000!')</p>
			<p class="source-code">})</p>
			<p>Let's go <a id="_idIndexMarker693"/>through the code to understand it. We are loading <strong class="source-inline">Express.js</strong> and defining a <strong class="source-inline">'/plot'</strong> endpoint. We are using <strong class="source-inline">Polyglot.eval()</strong> to run our R code. We are initializing the SVG and loading the Lattice package. We are then loading the <strong class="source-inline">heart.csv</strong> file and rendering the graph as a <a id="_idIndexMarker694"/>bar chart, and then adding the SVG response, generated to the HTML as a response for the <strong class="source-inline">/plot</strong> endpoint. </p>
			<p>Let's now run this code. The following shows the output after running the code:</p>
			<p class="source-code">node --jvm --polyglot plotWithR.js</p>
			<p class="source-code">Plot with R - listening on port 3000!</p>
			<p class="source-code">Loading required package: lattice</p>
			<p>Go to http://locahost:3000/plot to invoke the endpoint, on a browser. The following <a id="_idIndexMarker695"/>figure shows a <a id="_idIndexMarker696"/>screenshot of the output:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_8.5_B16878.jpg" alt="Figure 8.5 – Output of calling /plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Output of calling /plot</p>
			<p>R is a very powerful<a id="_idIndexMarker697"/> language for statistical computations and machine learning. This opens up opportunities for us to embed R code or call R code within the same runtime, from various other languages. If we had to do the same logic in Java, it might take a lot of effort. </p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor166"/>Summary</h1>
			<p>In this chapter, we went into the details of how Python, R, and Java on Truffle interpreters are implemented in Truffle. We also explored the polyglot interoperability features that these languages provide, along with coding examples. We understood the differences in the way each of these languages is interpreted. The chapter provided a hands-on walkthrough of how to run code and write polyglot applications in these various languages. We used very simple code so that you could easily understand the concepts and API to implement polyglot applications.</p>
			<p>You should be able to use this knowledge to write polyglot applications on GraalVM. Though most of these languages are still in the experimental phase at the time of writing the book, they provide great opportunities to build high-performance polyglot applications. </p>
			<p>In the next chapter, you will gain good hands-on experience and understanding of how polyglot works, how to build Python and R applications on GraalVM, and how to interoperate between these programs. You will also gain a good knowledge of GraalVM's new runtime, Java on Truffle.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor167"/>Questions</h1>
			<ol>
				<li>What is Java on Truffle?</li>
				<li>What are the advantages of Java on Truffle?</li>
				<li>What is the use of the <strong class="source-inline">Polyglot.cast()</strong> method?</li>
				<li>What are SST and ST?</li>
				<li>What is a <strong class="source-inline">.pyc</strong> file?</li>
				<li>What is the polyglot binding method used to exchange data and function definitions in GraalPython?</li>
				<li>How can you import other language definitions in R?</li>
				<li>How can you load a Java class in R?</li>
			</ol>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor168"/>Further reading</h1>
			<ul>
				<li>GraalVM Enterprise Edition: <a href="https://docs.oracle.com/en/graalvm/enterprise/19/index.html">https://docs.oracle.com/en/graalvm/enterprise/19/index.html</a></li>
				<li>GraalVM Language Reference: <a href="https://www.graalvm.org/reference-manual/languages/">https://www.graalvm.org/reference-manual/languages/</a>.</li>
			</ul>
		</div>
	</body></html>