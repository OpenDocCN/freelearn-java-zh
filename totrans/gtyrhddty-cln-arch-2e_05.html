<html><head></head><body>
<div id="_idContainer039">
<h1 class="hapter-number" id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.2.1">Implementing a Use Case</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Let’s finally look at how we can manifest the architecture we have discussed in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">actual code.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Since the application, web, and persistence layers are so loosely coupled in our architecture, we’re totally free to model our domain code as we see fit. </span><span class="koboSpan" id="kobo.5.2">We can do </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">DDD</span></strong><span class="koboSpan" id="kobo.9.1">), implement a rich or anemic domain model, or invent our own way of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">doing things.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This chapter describes an opinionated way of implementing use cases within the Hexagonal Architecture style we introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">previous chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">As is fitting for a domain-centric architecture, we’ll start with a domain entity and then build a use case </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">around it.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.15.1">Implementing the domain model</span></h1>
<p><span class="koboSpan" id="kobo.16.1">We</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.17.1"> want to implement the use case of sending money from one account to another. </span><span class="koboSpan" id="kobo.17.2">One way to model this in an object-oriented fashion is to create an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.18.1">Account</span></strong><span class="koboSpan" id="kobo.19.1"> entity that allows us to withdraw money from a source account and deposit it into a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">target account:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.21.1"><img alt="" src="image/code-5.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.22.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.23.1">Account</span></strong><span class="koboSpan" id="kobo.24.1"> entity provides the current snapshot of an actual account. </span><span class="koboSpan" id="kobo.24.2">Every withdrawal from and deposit to an account is captured in an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.25.1">Activity</span></strong><span class="koboSpan" id="kobo.26.1"> entity. </span><span class="koboSpan" id="kobo.26.2">Since it would not be wise to always load all activities of an account into memory, the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.27.1">Account</span></strong><span class="koboSpan" id="kobo.28.1"> entity only holds a window of the last few days or weeks of activities, captured in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.29.1">ActivityWindow</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.30.1">value object.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">To still be able to calculate the current account balance, the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.32.1">Account</span></strong><span class="koboSpan" id="kobo.33.1"> entity additionally has the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.34.1">baselineBalance</span></strong><span class="koboSpan" id="kobo.35.1"> attribute, representing the balance the account had just before the first activity of the activity window. </span><span class="koboSpan" id="kobo.35.2">The total balance, then, is the baseline balance plus the balance of all activities in </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the window.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">With this model, withdrawing and depositing money into an account is a matter of adding a new activity to the activity window, as is done in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.38.1">withdraw()</span></strong><span class="koboSpan" id="kobo.39.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.40.1">deposit()</span></strong><span class="koboSpan" id="kobo.41.1"> methods. </span><span class="koboSpan" id="kobo.41.2">Before we can withdraw, we check the business rule that says that we cannot</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.42.1"> overdraw </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">an account.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Now that we have an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.45.1">Account</span></strong><span class="koboSpan" id="kobo.46.1"> that allows us to withdraw and deposit money, we can move outward to build a use case </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">around it.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.48.1">A use case in a nutshell</span></h1>
<p><span class="koboSpan" id="kobo.49.1">First, let’s discuss what a use case</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.50.1"> actually does. </span><span class="koboSpan" id="kobo.50.2">Usually, it follows </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.52.1">Take </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">the input.</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Validate the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">business rules.</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">Manipulate the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">model state.</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">Return </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the output.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.60.1">A use case takes input from an incoming adapter. </span><span class="koboSpan" id="kobo.60.2">You might wonder why I didn’t call the first step </span><em class="itali"><span class="koboSpan" id="kobo.61.1">Validate input</span></em><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">The answer is that I believe use case code should only be concerned with domain logic and we shouldn’t pollute it with input validation. </span><span class="koboSpan" id="kobo.62.3">So, we’ll do input validation somewhere else, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">see shortly.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">The use case is, however, responsible for validating business rules. </span><span class="koboSpan" id="kobo.64.2">It shares this responsibility with the domain entities. </span><span class="koboSpan" id="kobo.64.3">We’ll discuss the distinction between </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">input validation</span></strong><span class="koboSpan" id="kobo.66.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">business rule validation </span></strong><span class="koboSpan" id="kobo.68.1">later in </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">If the business rules were satisfied, the use case then manipulates the state of the model in one way or another, based on the input. </span><span class="koboSpan" id="kobo.70.2">Usually, it will change the state of a domain object and pass this new state to a port implemented by the persistence adapter to be persisted. </span><span class="koboSpan" id="kobo.70.3">If the use case drives other side effects than persistence, it invokes an appropriate adapter for each </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">side effect.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">The last step is to translate the return value from the outgoing adapter into an output object, which will be</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.73.1"> returned to the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">calling adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">With these steps in mind, let’s see how we can</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.76.1"> implement </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.77.1">our </span><em class="itali"><span class="koboSpan" id="kobo.78.1">Send money</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.79.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">To avoid the problem of broad services discussed in </span><a href="B19916_05.xhtml"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.81.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.82.1">, </span><em class="itali"><span class="koboSpan" id="kobo.83.1">What’s Wrong with Layers?</span></em><span class="koboSpan" id="kobo.84.1">, we’ll create a separate service class for each use case instead of putting all use cases into a single </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">service class.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">a teaser:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.88.1"><img alt="" src="image/code-5.2.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.89.1">The service implements the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.90.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.91.1"> incoming port interface and calls </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.93.1">Load</span></strong></span><strong class="sour e-inline"><span class="koboSpan" id="kobo.94.1">
AccountPort</span></strong><span class="koboSpan" id="kobo.95.1"> outgoing port interface to load an account and </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">the </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.97.1">UpdateAccountState</span></strong></span><strong class="sour e-inline"><span class="koboSpan" id="kobo.98.1">
Port</span></strong><span class="koboSpan" id="kobo.99.1"> port to persist an updated account state in </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The service also sets the boundary for a database transaction, as implied by the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.102.1">@Transactional</span></strong><span class="koboSpan" id="kobo.103.1"> annotation. </span><span class="koboSpan" id="kobo.103.2">More about this in </span><a href="B19916_07.xhtml#_idTextAnchor062"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.104.1">Chapter 7</span></em></span></a><em class="itali"><span class="koboSpan" id="kobo.105.1">, Implementing a </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.106.1">Persistence Adapter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.108.1">Figure 5</span></em></span><em class="itali"><span class="koboSpan" id="kobo.109.1">.1 </span></em><span class="koboSpan" id="kobo.110.1">provides a visual</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.111.1"> overview of the</span><a id="_idIndexMarker084"/> <span class="No-Break"><span class="koboSpan" id="kobo.112.1">relevant components:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.113.1"><img alt="Figure 5.1 – A service implements a use case, modifies the domain model, and calls an outgoing port to persist the modified state" src="image/Figure_05.01_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.114.1">Figure 5.1 – A service implements a use case, modifies the domain model, and calls an outgoing port to persist the modified state</span></p>
<p class="allout-heading"><span class="koboSpan" id="kobo.115.1">Note</span></p>
<p class="allout"><strong class="sour e-inline"><span class="koboSpan" id="kobo.116.1">UpdateAccountStatePort</span></strong><span class="koboSpan" id="kobo.117.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.118.1">LoadAccountPort</span></strong><span class="koboSpan" id="kobo.119.1">, in this example, are port interfaces implemented by a persistence adapter. </span><span class="koboSpan" id="kobo.119.2">If they are often used together, we could also combine them into a broader interface. </span><span class="koboSpan" id="kobo.119.3">We could even call that interface </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.120.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.121.1"> to stick with the DDD language. </span><span class="koboSpan" id="kobo.121.2">In this example, and in the rest of the book, I chose to use the name “Repository” only in the persistence adapter, but you may choose </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">different names!</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">Let’s take care of those </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.124.1">TODO</span></strong><span class="koboSpan" id="kobo.125.1"> comments we left in the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">preceding code.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.127.1">Validating input</span></h1>
<p><span class="koboSpan" id="kobo.128.1">Now, we’re talking about</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.129.1"> validating input, even though I just claimed that it’s not the responsibility of a use case class. </span><span class="koboSpan" id="kobo.129.2">I still think, however, that it belongs in the application layer, so this is the place to </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">discuss it.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Why not let the calling adapter validate the input before sending it to the use case? </span><span class="koboSpan" id="kobo.131.2">Well, do we want to trust the caller to have validated everything as needed for the use case? </span><span class="koboSpan" id="kobo.131.3">Also, the use case might be called by more than one adapter, so the validation would have to be implemented by each adapter, and one might get it wrong or forget </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">it altogether.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">The application layer should care about input validation because, well, otherwise it might get invalid input from outside the application core. </span><span class="koboSpan" id="kobo.133.2">This might cause damage to the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">our model.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">But where do we put the input validation if not in the use </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">case class?</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">We’ll let the</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.138.1"> input model take care of it. </span><span class="koboSpan" id="kobo.138.2">For the </span><em class="itali"><span class="koboSpan" id="kobo.139.1">Send money</span></em><span class="koboSpan" id="kobo.140.1"> use case, the input model is the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.141.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.142.1"> class we have already seen in the previous code example. </span><span class="koboSpan" id="kobo.142.2">More precisely, we’ll do the validation within </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the constructor:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.144.1"><img alt="" src="image/code-5.3.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.145.1">To send money, we need the IDs of the source and target account and the amount of money that is to be transferred. </span><span class="koboSpan" id="kobo.145.2">None of the parameters may be </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.146.1">null</span></strong><span class="koboSpan" id="kobo.147.1"> and the amount must be greater than zero. </span><span class="koboSpan" id="kobo.147.2">If any of these conditions is violated, we simply refuse object creation by throwing an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">during construction.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">By using a </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">record</span></strong><span class="koboSpan" id="kobo.151.1"> to implement </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.153.1">, we make it </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">immutable</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">So, once constructed successfully, we can be sure that the state is valid and cannot be changed to </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">something invalid.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Since </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.158.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.159.1"> is part of the use cases’ API, it’s located in the incoming port package. </span><span class="koboSpan" id="kobo.159.2">Thus, the validation remains in the core of the application (at the edge of the hexagon of our architecture) but does not pollute the sacred use </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">case code.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">But do we really want to implement each validation check by hand when there are libraries that can do the dirty work for us? </span><span class="koboSpan" id="kobo.161.2">I have often heard statements such as “You shouldn’t use libraries in your model classes.” </span><span class="koboSpan" id="kobo.161.3">There’s wisdom in reducing dependencies to a minimum, of course, but if we can get away with a small-footprint dependency that saves us time, then why not use it? </span><span class="koboSpan" id="kobo.161.4">Let’s explore what this might look like with Java’s Bean </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">Validation API.</span></span><span class="No-Break"><span class="supers ript"><span id="footnote-021-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-021"><span class="koboSpan" id="kobo.163.1">1</span></a></span></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-021">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-021-backlink"><span class="koboSpan" id="kobo.164.1">1</span></a><span class="koboSpan" id="kobo.165.1">	Bean </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">Validation: </span></span><a href="https://beanvalidation.org/"><span class="No-Break"><span class="koboSpan" id="kobo.167.1">https://beanvalidation.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.168.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.169.1">Bean Validation</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.170.1"> allows us to express the validation rules we need as annotations on the fields of </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">a class:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.172.1"><img alt="" src="image/code-5.4.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.173.1">The class </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.174.1">Validator</span></strong><span class="koboSpan" id="kobo.175.1"> provides the method </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.176.1">validate()</span></strong><span class="koboSpan" id="kobo.177.1">, which we simply call as the last statement in the constructor. </span><span class="koboSpan" id="kobo.177.2">This will evaluate the Bean Validation annotations on the fields (</span><strong class="sour e-inline"><span class="koboSpan" id="kobo.178.1">@NotNull</span></strong><span class="koboSpan" id="kobo.179.1">, in this case) and throw an exception in case of a violation. </span><span class="koboSpan" id="kobo.179.2">If the default Bean Validation annotations are not expressive enough for a certain validation, we can implement our own annotations and validators as we did with the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.180.1">@</span></strong><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.181.1">PositiveMoney</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.182.1"> annotation.</span></span><span class="No-Break"><span class="supers ript"><span id="footnote-020-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-020"><span class="koboSpan" id="kobo.183.1">2</span></a></span></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-020">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-020-backlink"><span class="koboSpan" id="kobo.184.1">2</span></a><span class="koboSpan" id="kobo.185.1">	You can find the full code implementing the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.186.1">@PositiveMoney</span></strong><span class="koboSpan" id="kobo.187.1"> annotation and validator in the GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">at </span></span><a href="https://github.com/thombergs/buckpal"><span class="No-Break"><span class="koboSpan" id="kobo.189.1">https://github.com/thombergs/buckpal</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.191.1">The implementation of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.192.1">Validator</span></strong><span class="koboSpan" id="kobo.193.1"> class might look </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.195.1"><img alt="" src="image/code-5.5.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.196.1">With validation located in the input model, we have created an </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">anti-corruption layer</span></strong><span class="koboSpan" id="kobo.198.1"> around our use case implementations. </span><span class="koboSpan" id="kobo.198.2">This is not a layer in the sense of a layered architecture, calling the next layer below it, but instead a thin, protective screen around our use cases that bounces bad input back to </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the caller.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Note that the term “command,” as used in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.201.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.202.1"> class, does not match the common interpretation of the “command pattern.”</span><span class="supers ript"><span id="footnote-019-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-019"><span class="koboSpan" id="kobo.203.1">3</span></a></span> </span><span class="koboSpan" id="kobo.204.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">command pattern</span></strong><span class="koboSpan" id="kobo.206.1">, a command is executable, that is, it has a method called </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.207.1">execute()</span></strong><span class="koboSpan" id="kobo.208.1"> that actually invokes the </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.209.1">use case. </span><span class="koboSpan" id="kobo.209.2">In our case, the command is just a data transfer object that transfers the required parameters to the use case service that executes the command. </span><span class="koboSpan" id="kobo.209.3">We could call it </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.210.1">SendMoneyDTO</span></strong><span class="koboSpan" id="kobo.211.1"> instead, but I like the term “command” to make it very clear that we’re changing the model state with this </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">use case.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-019">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-019-backlink"><span class="koboSpan" id="kobo.213.1">3</span></a><span class="koboSpan" id="kobo.214.1">	Command </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">pattern: </span></span><a href="https://en.wikipedia.org/wiki/Command_pattern"><span class="No-Break"><span class="koboSpan" id="kobo.216.1">https://en.wikipedia.org/wiki/Command_pattern</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.217.1">.</span></span></p>
</div>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.218.1">The power of constructors</span></h1>
<p><span class="koboSpan" id="kobo.219.1">Our </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">input model</span></strong><span class="koboSpan" id="kobo.221.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.222.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.223.1">, puts a </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.224.1">lot of responsibility on its constructor. </span><span class="koboSpan" id="kobo.224.2">Since the class is</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.225.1"> immutable, the constructor’s argument list contains a parameter for each attribute of the class. </span><span class="koboSpan" id="kobo.225.2">And since the constructor also validates the parameters, it’s not possible to create an object with an </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">invalid state.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">In our case, the constructor has only three parameters. </span><span class="koboSpan" id="kobo.227.2">What if we had more parameters? </span><span class="koboSpan" id="kobo.227.3">Couldn’t we use the builder pattern to make it more convenient to use? </span><span class="koboSpan" id="kobo.227.4">We could make the constructor with the long parameter list private and hide the call to it in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.228.1">build()</span></strong><span class="koboSpan" id="kobo.229.1"> method of our builder. </span><span class="koboSpan" id="kobo.229.2">Then, instead of having to call a constructor with 20 parameters, we could build an object </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.231.1"><img alt="" src="image/code-5.6.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.232.1">We can still let our constructor do the validation so that the builder cannot construct an object with an </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">invalid state.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Sound good? </span><span class="koboSpan" id="kobo.234.2">Think about what happens if we have to add another field to </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.235.1">SendMoneyCommandBuilder</span></strong><span class="koboSpan" id="kobo.236.1"> (which will happen quite a few times in the lifetime of a software project). </span><span class="koboSpan" id="kobo.236.2">We add the new field to the constructor and to the builder. </span><span class="koboSpan" id="kobo.236.3">Then, a colleague (or a phone call, an email, a butterfly…) interrupts our train of thought. </span><span class="koboSpan" id="kobo.236.4">After the break, we go back to coding and forget to add the new field to the code that calls the builder to create </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">an object.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">We don’t get a word of warning from the compiler about trying to create an immutable object in an invalid state! </span><span class="koboSpan" id="kobo.238.2">Sure, at runtime – hopefully in a unit test – our validation logic will still kick in and throw an error because we missed </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">But if we use the </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.241.1">constructor directly instead of hiding it behind a builder, each time a new field is added or an existing field is removed, we can just follow the trail of compile errors to reflect that change in the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Long parameter </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.244.1">lists can even be formatted nicely, and good IDEs help with parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">name hints:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.246.1"><img alt="Figure 5.2 – The IDE shows parameter name hints in parameter lists to help us ﻿to not get lost" src="image/Figure_05.02_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.247.1">Figure 5.2 – The IDE shows parameter name hints in parameter lists to help us to not get lost</span></p>
<p><span class="koboSpan" id="kobo.248.1">To make the preceding code even more readable and safer to work with, we can introduce immutable </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">value objects</span></strong><span class="koboSpan" id="kobo.250.1"> to replace some of the primitives we used as constructor parameters. </span><span class="koboSpan" id="kobo.250.2">A value object is an object whose value is its identity. </span><span class="koboSpan" id="kobo.250.3">Two value objects with the same value are considered the same. </span><span class="koboSpan" id="kobo.250.4">Instead of passing the street, city, zip code, country, and state separately, we could combine them into an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.251.1">Address</span></strong><span class="koboSpan" id="kobo.252.1"> value object, for example, because they belong together. </span><span class="koboSpan" id="kobo.252.2">We could even go a step further and create </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.253.1">City</span></strong><span class="koboSpan" id="kobo.254.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.255.1">ZipCode</span></strong><span class="koboSpan" id="kobo.256.1"> value objects, for example. </span><span class="koboSpan" id="kobo.256.2">This would reduce the chance of confusing one </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.257.1">String</span></strong><span class="koboSpan" id="kobo.258.1"> parameter with another, because the compiler would complain if we tried to pass a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.259.1">City</span></strong><span class="koboSpan" id="kobo.260.1"> into a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.261.1">ZipCode</span></strong><span class="koboSpan" id="kobo.262.1"> parameter and </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">There are cases</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.265.1"> where a builder</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.266.1"> may be the better solution, though. </span><span class="koboSpan" id="kobo.266.2">If some parameters in </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.267.1">ClassWithManyFields</span></strong><span class="koboSpan" id="kobo.268.1"> from the preceding example were optional, for example, we would have to pass </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.269.1">null</span></strong><span class="koboSpan" id="kobo.270.1"> values into the constructor, which is ugly at best. </span><span class="koboSpan" id="kobo.270.2">A builder would allow us to define only the required parameters. </span><span class="koboSpan" id="kobo.270.3">But if using builders, we should make very sure that the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.271.1">build()</span></strong><span class="koboSpan" id="kobo.272.1"> method fails loudly when we forget to define a required parameter because the compiler doesn’t check that </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">for us!</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.274.1">Different input models for different use cases</span></h1>
<p><span class="koboSpan" id="kobo.275.1">We might be tempted to </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.276.1">use the same input model for different use cases. </span><span class="koboSpan" id="kobo.276.2">Let’s </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.277.1">consider the </span><em class="itali"><span class="koboSpan" id="kobo.278.1">Register account</span></em><span class="koboSpan" id="kobo.279.1"> and </span><em class="itali"><span class="koboSpan" id="kobo.280.1">Update account details</span></em><span class="koboSpan" id="kobo.281.1"> use cases. </span><span class="koboSpan" id="kobo.281.2">Both will initially need almost the same input, namely some account details, such as a username and </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">email address.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">The </span><em class="itali"><span class="koboSpan" id="kobo.284.1">Update </span></em><span class="koboSpan" id="kobo.285.1">use case will need the ID of the account that needs to be updated, however, while the </span><em class="itali"><span class="koboSpan" id="kobo.286.1">Register </span></em><span class="koboSpan" id="kobo.287.1">use case does not. </span><span class="koboSpan" id="kobo.287.2">If both use cases use the same input model, we will always have to pass a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.288.1">null</span></strong><span class="koboSpan" id="kobo.289.1"> account ID into the </span><em class="itali"><span class="koboSpan" id="kobo.290.1">Register </span></em><span class="koboSpan" id="kobo.291.1">use case. </span><span class="koboSpan" id="kobo.291.2">This is annoying at best, and detrimental at worst, because both use cases are coupled to evolve </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">together now.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">Allowing </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.294.1">null</span></strong><span class="koboSpan" id="kobo.295.1"> as a valid state of a field in our immutable command object is a code smell by itself. </span><span class="koboSpan" id="kobo.295.2">But more importantly, how are we handling input validation now? </span><span class="koboSpan" id="kobo.295.3">Validation has to be different for the </span><em class="itali"><span class="koboSpan" id="kobo.296.1">Register </span></em><span class="koboSpan" id="kobo.297.1">and </span><em class="itali"><span class="koboSpan" id="kobo.298.1">Update </span></em><span class="koboSpan" id="kobo.299.1">use cases since one needs an ID and the other doesn’t. </span><span class="koboSpan" id="kobo.299.2">We’d have to build custom validation logic into the use cases themselves, polluting our sacred business code with input </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">validation concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Also, what do we do if the account ID field accidentally has a non-null value in the </span><em class="itali"><span class="koboSpan" id="kobo.302.1">Register account</span></em><span class="koboSpan" id="kobo.303.1"> use case? </span><span class="koboSpan" id="kobo.303.2">Do we throw an error? </span><span class="koboSpan" id="kobo.303.3">Do we simply ignore it? </span><span class="koboSpan" id="kobo.303.4">These are the questions the maintenance engineers – including future us – will ask when seeing </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">A dedicated </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.306.1">input model for each use case makes the use case much clearer and </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.307.1">also decouples it from other use cases, preventing unwanted side effects. </span><span class="koboSpan" id="kobo.307.2">It comes at a cost, however, because we have to map incoming data to different input models for different use cases. </span><span class="koboSpan" id="kobo.307.3">We’ll discuss this mapping strategy along with other mapping strategies in </span><a href="B19916_09.xhtml#_idTextAnchor081"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.308.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.309.1">, </span><em class="itali"><span class="koboSpan" id="kobo.310.1">Mapping </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.311.1">between Boundaries</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.313.1">Validating business rules</span></h1>
<p><span class="koboSpan" id="kobo.314.1">While validating input is not part of </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.315.1">the use case logic, validating business rules definitely is. </span><span class="koboSpan" id="kobo.315.2">Business rules are the core of the application and should be handled with appropriate care. </span><span class="koboSpan" id="kobo.315.3">But when are we dealing with input validation and when are we dealing with a </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">business rule?</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">A very pragmatic distinction between the two is that validating a business rule requires access to the current state of the domain model while validating input does not. </span><span class="koboSpan" id="kobo.317.2">Input validation can be implemented declaratively, as we did with the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.318.1">@NotNull</span></strong><span class="koboSpan" id="kobo.319.1"> annotations previously, while a business rule needs </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">more context.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">We might also say that input validation is a syntactic validation, while a business rule is a semantic validation in the context of a </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Let’s take the rule </span><em class="itali"><span class="koboSpan" id="kobo.324.1">the source account must not be overdrawn</span></em><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">As per the previous definition, this is a business rule since it needs access to the current state of the model to check the balance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">source account.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">In contrast, the rule </span><em class="itali"><span class="koboSpan" id="kobo.328.1">the transfer amount must be greater than zero</span></em><span class="koboSpan" id="kobo.329.1"> can be validated without access to the model and thus can be implemented as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">input validation.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">I’m aware that this distinction may be subject to debate. </span><span class="koboSpan" id="kobo.331.2">You might argue that the transfer amount is so important that validating it should be considered a business rule in </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">any case.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">The distinction helps us, however, to place certain validations within the code base and easily find them again later on. </span><span class="koboSpan" id="kobo.333.2">It’s as simple as answering the question of whether the validation needs access to the current model state or not. </span><span class="koboSpan" id="kobo.333.3">This not only helps us to implement the rule in the first place but it also helps the future maintenance engineer to find it again. </span><span class="koboSpan" id="kobo.333.4">It’s also a great example of my claim from </span><a href="B19916_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.334.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.335.1">, </span><em class="itali"><span class="koboSpan" id="kobo.336.1">Maintainability</span></em><span class="koboSpan" id="kobo.337.1">, that maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">supports decision-making.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">So, how do we implement a </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">business rule?</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">The best way is to put the business rules</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.342.1"> into a domain entity as we did for the rule </span><em class="itali"><span class="koboSpan" id="kobo.343.1">the source account must not </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.344.1">be overdrawn</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.346.1"><img alt="" src="image/code-5.7.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.347.1">This way, the business rule is easy to locate and reason about because it’s right next to the business logic that requires this rule to </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">be honored.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">If it’s not feasible to validate a business rule in a domain entity, we can do it in the use case code before it starts working on the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">domain entities:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.351.1"><img alt="" src="image/code-5.8.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.352.1">We call a method that does the actual validation and throws a dedicated exception if this validation fails. </span><span class="koboSpan" id="kobo.352.2">The adapter interfacing with the user can then display this exception to the user as an error message or handle it in any other way it </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">deems fit.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">In the preceding case, the</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.355.1"> validation simply checks whether the source and target accounts actually exist in the database. </span><span class="koboSpan" id="kobo.355.2">More complex business rules might require us to load the domain model from the database first and then do some checks on its state. </span><span class="koboSpan" id="kobo.355.3">If we have to load the domain model anyway, we should implement the business rule in the domain entities themselves, as we did with the rule </span><em class="itali"><span class="koboSpan" id="kobo.356.1">the source account must not </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.357.1">be overdrawn</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.359.1">Rich versus anemic domain model</span></h1>
<p><span class="koboSpan" id="kobo.360.1">Our architecture</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.361.1"> style leaves open how to</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.362.1"> implement our domain model. </span><span class="koboSpan" id="kobo.362.2">This is a blessing because we can do what seems right in our context, and a curse because we don’t have any guidelines to </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">help us.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">A frequent discussion is whether to implement a </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">rich domain model</span></strong><span class="koboSpan" id="kobo.366.1"> following the DDD philosophy or an “</span><strong class="bold"><span class="koboSpan" id="kobo.367.1">anemic</span></strong><span class="koboSpan" id="kobo.368.1">” </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">domain model</span></strong><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">Let’s discuss how each of these fits into </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">our architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">In a rich domain model, as much of the domain logic as possible is implemented within the entities at the core of the application. </span><span class="koboSpan" id="kobo.372.2">The entities provide methods to change the state and only allow changes that are valid according to the business rules. </span><span class="koboSpan" id="kobo.372.3">This is the way we pursued the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.373.1">Account</span></strong><span class="koboSpan" id="kobo.374.1"> entity previously. </span><span class="koboSpan" id="kobo.374.2">Where is our use case implementation in </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">this scenario?</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">In this case, our use case serves as an entry point to the domain model. </span><span class="koboSpan" id="kobo.376.2">A use case then only represents the intent of the user and translates it into orchestrated method calls to the domain entities, which do the actual work. </span><span class="koboSpan" id="kobo.376.3">Many of the business rules are located in the entities instead of the use </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">case implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">The </span><em class="itali"><span class="koboSpan" id="kobo.379.1">Send money</span></em><span class="koboSpan" id="kobo.380.1"> use case service would load the source and target account entities, call their </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.381.1">withdraw()</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.383.1">deposit()</span></strong><span class="koboSpan" id="kobo.384.1"> methods, and send them back to </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">the database.</span></span><span class="No-Break"><span class="supers ript"><span id="footnote-018-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-018"><span class="koboSpan" id="kobo.386.1">4</span></a></span></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-018">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-018-backlink"><span class="koboSpan" id="kobo.387.1">4</span></a><span class="koboSpan" id="kobo.388.1">	Actually, the </span><em class="itali"><span class="koboSpan" id="kobo.389.1">Send Money</span></em><span class="koboSpan" id="kobo.390.1"> use case would also have to make sure that no other money transfer to and from the source and target account was happening at the same time to avoid overdrawing </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">an account.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.392.1">In an “anemic” domain model, the entities themselves are very thin. </span><span class="koboSpan" id="kobo.392.2">They usually only provide fields to hold the state and getter and setter methods to read and change the state. </span><span class="koboSpan" id="kobo.392.3">They don’t contain any </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">domain logic.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">This means that the domain logic is implemented in the use case classes. </span><span class="koboSpan" id="kobo.394.2">They are responsible for validating business rules, changing the state of the entities, and passing them into the outgoing ports responsible for storing them in the database. </span><span class="koboSpan" id="kobo.394.3">The “richness” is contained within the use cases instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the entities.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Either style, and</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.397.1"> any number of other styles, can be</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.398.1"> implemented using the architecture approach discussed in this book. </span><span class="koboSpan" id="kobo.398.2">Feel free to choose the one that fits </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">your needs.</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.400.1">Different output models for different use cases</span></h1>
<p><span class="koboSpan" id="kobo.401.1">Once the use</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.402.1"> case </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.403.1">has done its work, what should it return to </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the caller?</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Similar to the input, it has benefits if the output is as specific to the use case as possible. </span><span class="koboSpan" id="kobo.405.2">The output should only include the data that is really needed for the caller </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">In the example code of the </span><em class="itali"><span class="koboSpan" id="kobo.408.1">Send money</span></em><span class="koboSpan" id="kobo.409.1"> use case, we return a Boolean. </span><span class="koboSpan" id="kobo.409.2">This is the minimal and most specific value we could possibly return in </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">this context.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">We might be tempted to return a complete </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.412.1">Account</span></strong><span class="koboSpan" id="kobo.413.1"> with the updated entity to the caller. </span><span class="koboSpan" id="kobo.413.2">Perhaps the caller is interested in the new balance of </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the account.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">But do we really want to make the </span><em class="itali"><span class="koboSpan" id="kobo.416.1">Send money</span></em><span class="koboSpan" id="kobo.417.1"> use case return this data? </span><span class="koboSpan" id="kobo.417.2">Does the caller really need it? </span><span class="koboSpan" id="kobo.417.3">If so, shouldn’t we create a dedicated use case for accessing that data that can be used by </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">different callers?</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">There is no single right answer to these questions. </span><span class="koboSpan" id="kobo.419.2">But we should ask them to try to keep our use cases as specific as possible. </span><span class="koboSpan" id="kobo.419.3">When in doubt, return as little </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Sharing the same output model between use cases also tends to tightly couple those use cases. </span><span class="koboSpan" id="kobo.421.2">If one of the use cases needs a new field in the output model, the other use cases have to handle this field as well, even if it’s irrelevant to them. </span><span class="koboSpan" id="kobo.421.3">Shared models tend to grow tumorously for multiple reasons in the long run. </span><span class="koboSpan" id="kobo.421.4">Applying the Single Responsibility Principle and keeping models separated helps in decoupling </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">For the same reason, we </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.424.1">might want to resist the temptation to use our </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.425.1">domain entities as the output model. </span><span class="koboSpan" id="kobo.425.2">We don’t want our domain entities to change for more reasons than necessary. </span><span class="koboSpan" id="kobo.425.3">However, we’ll talk more about using entities as input or output models in </span><a href="B19916_11.xhtml#_idTextAnchor096"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.426.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.427.1">, </span><em class="itali"><span class="koboSpan" id="kobo.428.1">Taking </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.429.1">Shortcuts Consciously</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">.</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.431.1">What about read-only use cases?</span></h1>
<p><span class="koboSpan" id="kobo.432.1">As of now, we have</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.433.1"> discussed how we might implement a use case that modifies the </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.434.1">state of our model. </span><span class="koboSpan" id="kobo.434.2">How do we go about implementing read-only cases? </span><span class="koboSpan" id="kobo.434.3">Let’s assume the UI needs to display the balance of an account. </span><span class="koboSpan" id="kobo.434.4">Do we create a specific use case implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">for this?</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">It’s awkward to talk of use cases for read-only operations like this one. </span><span class="koboSpan" id="kobo.436.2">Sure, the UI needs the data for a use case we might call </span><em class="itali"><span class="koboSpan" id="kobo.437.1">View Account Balance</span></em><span class="koboSpan" id="kobo.438.1">, but in some cases, calling this a “use case” is a bit artificial. </span><span class="koboSpan" id="kobo.438.2">If this is considered a use case in the context of the project, by all means, we should implement it just like the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">other ones.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">From the viewpoint of the application core, however, this is a simple query for data. </span><span class="koboSpan" id="kobo.440.2">So, if it’s not considered a use case in the context of the project, we can implement it as a query to set it apart from the real </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">One way of doing this within our architecture style is to create a dedicated incoming port for the query and implement it in a “</span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">query service:”</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.444.1"><img alt="" src="image/code-5.9.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.445.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">query service</span></strong><span class="koboSpan" id="kobo.447.1"> acts just as our “command” use case services do. </span><span class="koboSpan" id="kobo.447.2">It implements an incoming port we named </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.448.1">GetAccountBalanceUseCase</span></strong><span class="koboSpan" id="kobo.449.1"> and calls the outgoing port, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.450.1">LoadAccountPort</span></strong><span class="koboSpan" id="kobo.451.1">, to actually load the data from the database. </span><span class="koboSpan" id="kobo.451.2">It’s using the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.452.1">GetAccountBalanceQuery</span></strong><span class="koboSpan" id="kobo.453.1"> type as its </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">input model.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">This way, read-only queries are clearly distinguishable from modifying use cases (or “commands”) in our code base. </span><span class="koboSpan" id="kobo.455.2">We just have to look at the names of the input types to know which we’re dealing with. </span><span class="koboSpan" id="kobo.455.3">This </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.456.1">plays nicely with concepts </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.457.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Command-Query Separation</span></strong><span class="koboSpan" id="kobo.459.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.460.1">CQS</span></strong><span class="koboSpan" id="kobo.461.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">Command-Query Responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.463.1">Segregation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.465.1">CQRS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">In the preceding code, the</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.468.1"> service doesn’t really do any work other than passing the query </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.469.1">on to the outgoing port. </span><span class="koboSpan" id="kobo.469.2">If we use the same model across layers, we can take a shortcut and let the client call the outgoing port directly. </span><span class="koboSpan" id="kobo.469.3">We’ll talk about this shortcut in </span><a href="B19916_11.xhtml#_idTextAnchor096"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.470.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.471.1">, </span><em class="itali"><span class="koboSpan" id="kobo.472.1">Taking </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.473.1">Shortcuts Consciously</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.475.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.476.1">Our architecture lets us implement the domain logic as we see fit, but if we model the input and output of our use cases independently, we avoid unwanted </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">Yes, it’s more work than just sharing models between use cases. </span><span class="koboSpan" id="kobo.478.2">We have to introduce a separate model for each use case and map between this model and </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">our entities.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">But use case-specific models allow for a crisp understanding of a use case, making it easier to maintain in the long run. </span><span class="koboSpan" id="kobo.480.2">Also, they allow multiple developers to work on different use cases in parallel without stepping on each </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">other’s toes.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Together with tight input validation, use case-specific input and output models go a long way toward a maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">In the next chapter, we’re taking a step “outward” from the center of our application and will explore building a web adapter that provides a channel for users to talk to our </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">use case.</span></span></p>
</div>
</body></html>