<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Server-Side Components with Internationalization</h1>
                </header>
            
            <article>
                
<p>Having a login form is arguably one of the most common requirements in web applications. In this chapter, you will learn how to implement a reusable and extensible login form that supports multiple languages, and see the <span>advantages of favoring </span><em>composition</em><span> </span>over<em> extension</em><span> </span><span>when implementing UI components. Through examples, we'll discuss why <em>extension</em> is not always the best approach, and we'll explore several alternatives for implementing custom server-side UI components with Vaadin.</span></p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Extending layout components</li>
<li>Using the <kbd>Composite</kbd> class</li>
<li>Externalization of Java Strings</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be<span> </span>required<span> </span>to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-03</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/fu8W3W">https://goo.gl/fu8W3W</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using extensions to develop a UI component</h1>
                </header>
            
            <article>
                
<p>Let's explore how to implement a login form component. The first idea that comes to mind when starting to develop a UI component is to extend, in the Java sense, an existing component. Most of the time, the natural<span> </span>choice<span> </span>is to extend a layout component such as<span> </span><kbd>VerticalLayout</kbd><span> </span>or<span> </span><kbd>HorizontalLayout</kbd>. For example, a login form usually<span> </span>includes<span> </span>at least a <span class="packt_screen">username</span> field, a <span class="packt_screen">password</span> field, a <span class="packt_screen">login</span> button, and a <span class="packt_screen">remember me</span><span> </span>checkbox, with all of them aligned vertically. So, let's start by directly extending <kbd>VerticalLayout</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending VerticalLayout</h1>
                </header>
            
            <article>
                
<p>The following snippet of code shows a typical way of extending<span> </span><kbd>VerticalLayout</kbd><span> </span>to implement a UI component, in this case, the login form:</p>
<pre>public class LoginFormLayout <strong>extends VerticalLayout</strong> {

    private TextField username = new PasswordField();
    private PasswordField password = new PasswordField();
    private Button logIn = new Button();
    private CheckBox rememberMe = new CheckBox();
 
    public LoginFormLayout() {
        ...
        addComponents(username, password, logIn, rememberMe);
    }
    ...
}</pre>
<p>The logic to handle events and additional UI configuration that might be required is omitted in the previous example.</p>
<div class="packt_infobox">The full implementation of the<span> </span><kbd>LoginFormLayout</kbd><span> </span>class is located in the<span> </span><kbd>Data-centric-Applications-with-Vaadin-8/chapter-03</kbd><span> </span>Maven project of <span>the source code that accompanies this book.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why avoid extension?</h1>
                </header>
            
            <article>
                
<div>
<p>What is wrong with the previous implementation? Well, there's nothing inherently wrong with it. However, it can be highly improved. The<span> </span><kbd>LoginFormLayout</kbd><span> </span>class violates encapsulation! Clients of the class know that a<span> </span><kbd>VerticalLayout</kbd><span> </span>is used. All public methods of<span> </span><kbd>VerticalLayout</kbd><span> </span>are exposed to clients of<span> </span><kbd>LoginFormLayout</kbd>. If, for some reason, the implementation needs to change to a different layout (a<span> </span><kbd>FormLayout</kbd>,<span> </span><kbd>CssLayout</kbd>, or even a<span> </span><kbd>Panel</kbd>, for instance), clients calling any method in<span> </span><kbd>VerticalLayout</kbd><span> </span>that are not in the new base layout class would break.</p>
<p>To the outside<span> </span>world,<span> </span><kbd>LoginFormLayout</kbd><span> </span>is a<span> </span><kbd>Layout</kbd>. The purpose of a login form is not to serve as a layout (to position other<span> </span>components),<span> </span>but to show the fields that are required to authenticate users with the application. So, let's try to get more encapsulation into the design!</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using composition to develop custom components</h1>
                </header>
            
            <article>
                
<p>If extending<span> </span><kbd>VerticalLayout</kbd><span> </span>is a problem, a possible solution is to not extend any class at all. However,<span> </span>in<span> </span>that case, we wouldn't get a<span> </span><kbd>Component</kbd>, but a class of which instances cannot be added to the components tree. What about extending a more suitable component in the hierarchy? Let's start with interfaces. The following figure shows some of the top interfaces in the hierarchy:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8fadb91a-9c91-4591-b36a-3ad65a8595e9.jpg" style=""/></div>
<p>Going up the hierarchy, we find the<span> </span><kbd>Component</kbd><span> </span>interface which has more than 20 methods that would require an implementation. The other interfaces inherit these 20+ methods and add some more.<span> </span>Fortunately, Vaadin provides abstract implementations for these interfaces. The following figure shows some of the equivalent implementations:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50d0b746-91f7-4bba-9f98-57031e8165df.jpg" style=""/></div>
<p><kbd>AbstractComponent</kbd><span> </span>is the default implementation of<span> </span><kbd>Component</kbd>. Many Vaadin components directly extend this class. It's not a convenient class for the login form, though, since it's too general and doesn't offer methods to add other<span> </span>components<span> </span>to it.<span> </span><kbd>AbstractField</kbd><span> </span>and<span> </span><kbd>AbstractListing</kbd><span> </span>can be discarded as well because the login form is not just a field showing a value or a list of values, respectively.</p>
<p>The next candidates are the<span> </span><kbd>AbstractSingleComponentContainer</kbd>, <kbd>AbstractComponentContainer</kbd>, and<span> </span><kbd>AbstractLayout</kbd><span> </span>classes. These classes help with the implementation of layouts, but as we discussed previously, a login form shouldn't look like a layout to the external world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a factory</h1>
                </header>
            
            <article>
                
<p>How about a factory of components? The following is an implementation of a factory with a method that returns a<span> </span><kbd>Component</kbd>:</p>
<pre>public class LoginFormFactory {

    public static <strong>Component getComponent()</strong> {

        ... create and configure all required components

        return new VerticalLayout(
                username, password, button, rememberMe);
    }
}</pre>
<p class="mce-root">This hides the implementation<span> </span>details<span> </span>but also makes it more difficult and complex to offer functionality to the clients. For example, how would clients of the class get the username or password values introduced by the user in the form? One option is to implement getters in the factory class, but that would require some more<span> </span>adjustments<span> </span>in the<span> </span><kbd>LoginFormFactory</kbd><span> </span>class. At the end of the day, this kind of implementation would require you to implement (and maintain) two highly coupled classes for a single custom component. Not a very good idea.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Composite class</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you have some experience with Vaadin, chances are that you already know the<span> </span><kbd>CustomComponent</kbd><span> </span>class. The<span> </span><kbd>Composite</kbd><span> </span>class works in the same way as the<span> </span><kbd>CustomComponent</kbd><span> </span>class, but it's more<span> </span>lightweight<span> </span>since it only adds a simple<span> </span><kbd>&lt;div&gt;</kbd><span> </span>element to the DOM in the browser. The<span> </span><kbd>Composite</kbd><span> </span>class<span> eases</span><span> </span>the development of compositions of components by eliminating some of the problems previously described.<span> </span><kbd>Composite</kbd><span> </span>directly extends<span> </span><kbd>AbstractComponent</kbd><span>, </span>which means that any class extending<span> </span><kbd>Composite</kbd><span> </span>is a<span> </span><kbd>Component</kbd><span> </span>itself that can be added to any Vaadin layout. A<span> </span><kbd>Composite</kbd><span> </span>can specify a composition root that serves as the root of the components tree (usually a layout), for example:</p>
<pre>public class LoginFormComponent <strong>extends Composite</strong> {

    public LoginFormComponent() {

        ... create and configure all required components

        VerticalLayout <strong>layout = new VerticalLayout</strong>(
                username, password, button, rememberMe);

        <strong>setCompositionRoot(layout)</strong>;
    }

    ... getters and setters
}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the LoginForm class</h1>
                </header>
            
            <article>
                
<p>Vaadin comes with a<span> </span><kbd>LoginForm</kbd><span> </span>class that, by default, renders a username and a password field. It also adds<span> </span><em>auto-completion</em><span> </span>and<span> </span><em>auto-fill</em><span> </span>in the browser. The<span> </span><kbd>LoginForm</kbd><span> </span>class is a good candidate for extension (and you have to extend it if you want to override its defaults). For example, the following snippet of code creates a <kbd>loginForm</kbd> and a listener that is invoked when the user clicks the <span class="packt_screen">login</span> button:</p>
<pre>LoginForm loginForm = new LoginForm()
loginForm.addLoginListener(e -&gt;  {
    String password = e.getLoginParameter("password");
    String username = e.getLoginParameter("username");
    ...
});</pre>
<p>To add more fields to the form, override the<span> </span><kbd>createContent</kbd><span> </span>method. For example:</p>
<pre>LoginForm loginForm = new LoginForm() {
    @Override
    protected Component <strong>createContent</strong>(TextField username,
            PasswordField password, Button loginButton) {

        CheckBox rememberMe = new CheckBox();
        rememberMe.setCaption("Remember me");

        <strong>return new VerticalLayout(username, password, loginButton,
                rememberMe)</strong>;
    }
};</pre>
<p>Despite its design for<span> </span>extension, it's always a good idea to hide implementation details by extending<span> </span><kbd>Composite</kbd><span> </span>and abstracting away the underlying<span> </span><kbd>LoginForm</kbd><span> </span>class. The following snippet of code shows a first iteration of the new<span> </span><kbd>LoginFormComponent</kbd><span> </span>class:</p>
<pre>public class LoginFormComponent <strong>extends Composite</strong> {

    private TextField username;
    private PasswordField password;
    private CheckBox rememberMe = new CheckBox();

    public LoginFormComponent() {
        LoginForm <strong>loginForm = new LoginForm()</strong> {
            @Override
            protected Component createContent(TextField username,
                    PasswordField password, Button loginButton) {
                LoginFormComponent.this.username = userNameField;
                LoginFormComponent.this.password = passwordField;

                rememberMe.setCaption("Remember me");

                return new VerticalLayout(username,password,
                        loginButton, rememberMe);
            }
        };

        <strong>setCompositionRoot(loginForm);</strong>
    }
}</pre>
<p>The<span> </span><kbd>createContent</kbd><span> </span>method is called internally by the<span> </span><kbd>LoginForm</kbd><span> </span>class. Notice how the<span> </span><kbd>username</kbd><span> </span>and<span> </span><kbd>password</kbd><span> </span>variables are assigned to references in the<span> </span><kbd>LoginFormComponent</kbd><span> </span>class. These references can be used later to<span> </span>retrieve<span> </span>the values in the fields.</p>
<p>Allowing clients of the<span> </span><kbd>LoginFormComponent</kbd><span> </span>class to be notified when the user clicks the <span class="packt_screen">login</span> button can be implemented with a custom<span> </span><kbd>LoginListener</kbd><span> </span>interface:</p>
<pre>public class LoginFormComponent extends Composite {

    public interface <strong>LoginListener</strong> {
        void <strong>logInClicked</strong>(LoginFormComponent loginForm);
    }
    ...

    private <strong>LoginListener loginListener</strong>;

    public LoginFormComponent(LoginListener <strong>loginListener</strong>) {
        this();
        this.loginListener = loginListener;
    }

    public LoginFormComponent() {
        ...

        loginForm.addLoginListener(this::<strong>logInClicked</strong>);
        ...
    }
 
    public void setLoginListener(LoginListener loginListener) {
        this.loginListener = loginListener;
    }

    private void <strong>logInClicked</strong>(LoginForm.LoginEvent loginEvent) {
        if (loginListener != null) {
            <strong>loginListener.logInClicked(this);</strong>
        }
    }
}</pre>
<p>The<span> </span><kbd>LoginListener</kbd><span> </span>interface defines one method that accepts a<span> </span><kbd>LoginFormComponent</kbd>. Now, it's easy to define getters to allow clients to obtain the values in the fields:</p>
<pre>public class LoginFormComponent extends Composite {
    ...

    public String <strong>getUsername</strong>() {
        return username.getValue();
    }

    public String <strong>getPassword</strong>() {
        return password.getValue();
    }

    public boolean <strong>isRememberMe</strong>() {
        return rememberMe.getValue();
    }
}</pre>
<p>If a new component is added to the login form in future, it's possible to add a getter to return the value in the added field without<span> </span>breaking<span> </span>existing clients of the class.</p>
<div class="packt_infobox">The final version of the <kbd>LoginFormComponent</kbd><span> </span>class can be found in the<span> </span><kbd>Data-centric-Applications-with-Vaadin-8\chapter-03</kbd><span> </span>Maven project of the source code that accompanies this book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using internationalization for Multiple Language Support</h1>
                </header>
            
            <article>
                
<p><strong>Internationalization</strong><span> </span>is the process of making an application ready to support several languages and data formats. An internationalized application can be adapted for a particular language and region, a process known as<span> </span><em>localization</em>, which consists of adding a specific set of resources (usually text, images, and data formats) to an internationalized application. Ideally, localization should not require rebuilding the application, but only adding the localized resources and, at most, restarting the web container.</p>
<p class="mce-root">Addressing internationalization early in a software development project and knowing the audience makes the process much easier. Internationalization is orthogonal to all the application layers, and the process of localizing can involve translating and defining several resources such as texts, images, videos, audio files, number formats, date formats, currency symbols, and even colors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing hardcoded strings</h1>
                </header>
            
            <article>
                
<p>Custom reusable UI components should not depend on the mechanism used to handle internationalization. The<span> </span><kbd>LoginFormComponent</kbd>, for instance, should include setters (or<span> </span>alternatively,<span> </span>parameters in the constructor) to configure the captions of the inner UI components. The following implementation shows how to use setters to configure captions in the login form:</p>
<pre>public class LoginFormComponent extends Composite {
    ...

    private String <strong>usernameCaption</strong> = "Username";
    private String passwordCaption = "Password";
    private String loginButtonCaption = "Log in";
    private String rememberMeCaption = "Remember me";

    public LoginFormComponent() {
        LoginForm loginForm = new LoginForm() {
            @Override
            protected Component createContent(...) {
                username.setPlaceholder(<strong>usernameCaption</strong>);
                password.setPlaceholder(passwordCaption);
                loginButton.setCaption(loginButtonCaption);
                rememberMe.setCaption(rememberMeCaption);
                ... 
           }
        };

        ...
    }

    public void <strong>setUsernameCaption</strong>(String usernameCaption) {
        <strong>this.usernameCaption</strong> = usernameCaption;
    }

    ... similar setters for password, login, and remember me ...
} </pre>
<p class="mce-root">It's a good idea to provide defaults and a method to set all the captions in one call. The implementation<span> </span>in<span> </span>the<span> </span>example<span> </span>application includes such features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting localized strings</h1>
                </header>
            
            <article>
                
<p>At this point, the<span> </span><kbd>LoginFormComponent</kbd><span> </span>can be internationalized. The next step is to pass the strings containing the captions in the correct language. Usually, the<span> </span><kbd>Locale</kbd><span> </span>and<span> </span><kbd>ResourceBundle</kbd><span> </span>standard Java classes are good enough to externalize localized messages. However, it is also a good idea to isolate string externalization logic into a separate class that allows clients to add resource bundles and get localized strings by name. Encapsulating this logic into a separate class allows you to change the<span> </span>underlying<span> </span>mechanism<span> </span>(for example, to read the messages from a database) and add features such as caching without affecting the rest of the application.</p>
<p>The following is an implementation of the<span> </span><kbd>Messages</kbd><span> utility </span>class used to encapsulate string externalization logic:</p>
<pre>public class <strong>Messages</strong> { 
 
    private static final TreeSet&lt;String&gt; baseNames = 
            new TreeSet&lt;&gt;(); 
 
    public static void <strong>addBundle</strong>(String <strong>baseName</strong>) { 
        baseNames.add(baseName); 
    } 
 
    public static String get(String key) { 
        return baseNames.stream() 
                .map(baseName -&gt; <strong>ResourceBundle</strong>.<strong>getBundle</strong>( 
                        <strong>baseName</strong>, <strong>UI.getCurrent().getLocale()</strong>)) 
                .filter(bundle -&gt; bundle.containsKey(key)) 
                .map(bundle -&gt; bundle.getString(key)) 
                .findFirst().get(); 
    } 
 
} </pre>
<p>This class can be used to register a<span> </span><em>base name</em><span> </span>used internally by the standard<span> </span><kbd>ResourceBundle</kbd><span> </span>class. This base name should match the name of the properties files with the translations. For example, to add English and Spanish messages, you have to create two files,<span> </span><kbd>messages_en.properties</kbd><span> </span>and<span> </span><kbd>messages_es.properties</kbd>. The <kbd>messages</kbd> part in the name of these files corresponds to the<span> </span><em>base name</em>. You can load these resource<span> </span>bundles<span> </span>by calling<span> </span><kbd>Messages.addBundle("messages")</kbd>.</p>
<div class="packt_infobox">The<span> </span><kbd>Messages</kbd><span> </span>class is located in the <kbd>Data-centric-Applications-with-Vaadin-8\chapter-03</kbd> Maven project of the source code that accompanies this book. The class includes a method to get all the available languages that you can use to allow end users to change the language from the UI.</div>
<p>Supporting a new language is as<span> </span>easy<span> </span>(or complicated) as adding a new<span> </span><kbd>.properties</kbd><span> </span>file (in the<span> </span><kbd>resources</kbd><span> </span>directory) containing the translated properties. For example, a<span> </span><kbd>messages_en.properties</kbd><span> </span>file could define the following properties:</p>
<pre>auth.username=Username<br/>auth.password=Password<br/>auth.login=Login<br/>auth.rememberMe=Remember me<br/>auth.logout=Logout<br/>auth.bad.credentials=Wrong username or password</pre>
<p>To support Spanish, for example, you would have to add a<span> </span><kbd>messages_es.properties</kbd><span> </span>file with the following content:</p>
<pre>auth.username=Usuario<br/>auth.password=Contrase\u00f1a<br/>auth.login=Acceder<br/>auth.rememberMe=Recordarme<br/>auth.logout=Salir<br/>auth.bad.credentials=Usuario o contraseña incorrectos</pre>
<div class="packt_tip">Note that you have to use<span> <em>unicode scape</em></span><em> syntax</em><span> </span>if you want to include special<span> </span>characters<span> </span>(like the Spanish<span> </span><em>n</em><span> </span>with a<span> </span><em>tilde</em><span> </span>in the example).</div>
<p>You can get a message in the language of the browser by calling<span> </span><kbd>Messages.get("property")</kbd>. For example, the following snippet of code sets the correct<span> </span>labels<span> </span>for the components in the<span> </span><kbd>LoginFormComponent</kbd>:</p>
<pre>loginForm.setCaptions( 
        Messages.get("auth.username"), 
        Messages.get("auth.password"), 
        Messages.get("auth.login"), 
        Messages.get("auth.rememberMe")); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting and setting the locale</h1>
                </header>
            
            <article>
                
<p>Vaadin automatically sets the<span> </span><kbd>Locale</kbd><span> </span>reported by the browser. You can get this<span> </span><kbd>Locale</kbd><span> </span>by calling the<span> </span><kbd>UI::getLocale()</kbd><span> </span>method and the<span> </span><kbd>UI::setLocale(Locale)</kbd><span> </span>method to set the<span> </span><kbd>Locale</kbd><span> </span>for the current user. The example application in this chapter uses the locale reported by the browser. There's no need do anything else except add the resource bundle using the helper<span> </span><kbd>Messages</kbd><span> </span>class. The example application does this in a static block in the<span> </span><kbd>UI</kbd><span> </span>implementation (the<span> </span><kbd>VaadinUI</kbd><span> </span>class):</p>
<pre>static {
    Messages.addBundle("messages");
}</pre>
<p>In more complex scenarios, you should use an event listener such as<span> </span><kbd>ServletContextListener</kbd><span> </span>to add the resource bundle when the context starts, for example.</p>
<div class="packt_tip">You can configure your browser in a different language to test this functionality. How to configure this may depend on your browser and operating system vendor. In Chrome, however, you can use the<span> </span><span class="packt_screen">Language</span><span> </span>settings. Just move the language that you wish to test to the top of the list. You have to restart Chrome for this change to take effect.</div>
<p><span>The following is</span><span> </span>a<span> screenshot</span><span> </span><span>of the</span><span> </span><kbd>LoginFormComponent</kbd><span> </span><span>using the Spanish locale:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f35b3de-cc5e-43d0-af68-5d8a7fe59631.png" style=""/></div>
<div class="packt_tip">Internationalization requires a constant effort<span> </span>throughout<span> </span>the development of UIs. Try to catch yourself<span> </span><em>hard-coding</em><span> </span>strings and<span> </span>immediately<span> </span>fix them by creating an entry in the appropriate properties file. Incorporate this practice into your coding routine.</div>
<p>When implementing truly internationalized applications, you should have a well-defined and simple process that<span> </span>allows<span> </span>translators to create all the localizations (translations) for new resources. A way of doing this is by using<span> </span>well-defined<span> </span>directories or files that translators can take and complete (by translating the strings, for example) before a new production-ready artifact is constructed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this<span> </span>chapter<span>, </span>we learned how to design UI components with the help of object-oriented techniques by considering several approaches such as extending layout components, extending a specialized component, and using composition with the help of the <kbd>Composite</kbd> class. We developed a<span> </span><kbd>LoginForm</kbd><span> </span>class that uses the browser's language to show captions in the appropriate language.</p>
<p>In the next<span> </span>chapter<span>,</span> you will learn how to make the login form functional by adding authentication and authorization capabilities.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>