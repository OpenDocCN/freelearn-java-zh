<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Problem of Side Effects</h1>
                </header>
            
            <article>
                
<p>Pure functional programming is all about removing side effects and mutations. We remove them for a reason. In this chapter, we will see how shared mutable states and side-effecting functions can cause problems and why it is best to reduce them.</p>
<p>The topics discussed are as follows:</p>
<ul>
<li>Side effects</li>
<li>Mutable states</li>
<li>Pure functions</li>
<li>Generally encountered side effects</li>
<li>Pure functional paradigms in different programming languages</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Side effects</h1>
                </header>
            
            <article>
                
<p>So what exactly are side effects and why should they be avoided? For this discussion, we can define a side effect as some instructions in a function's code that modify the environment outside the scope of this function. The most common example of a side effect is an exception thrown by a program. Throwing an exception is a side effect because if you don't handle it, it will disrupt the program outside the scope of this function. So the program will break at this point and will stop its execution.</p>
<p>Take, for example, the function of the <em>Soda Machine</em> example from the previous chapter. The function that simulates coin-insertion throws an exception if there are no soda cans in the slot machine. So if you try to call that function on an empty soda machine, your program will never proceed past the function call site, because an exception will be thrown. That is, unless you handle this exception with a <kbd>try</kbd> statement<span> at the same call site. Note that this puts the burden of handling side effects on the client, which is probably not what we want to do.</span></p>
<p class="mce-root"/>
<p>Another side effect that you will encounter is a null returned from a function. For example, you have a database of users. You can add a function that queries the database and gets a user back given their ID:</p>
<pre>case class User(name: String)<br/>def getUser(id: Int): User =<br/> if (Set(1, 2, 3).contains(id)) User(s"User-$id")   <br/> else null</pre>
<p>Sometimes this function will be called with IDs of users that do not exist in the database. A traditional Java solution to the problem of data that does not exist is to return a null. Returning a null quickly creates a problem. It violates the expectation of the programmer that calls this function. The function return type is set to <kbd>User</kbd>. The programmer will rightfully expect to get an object of the <kbd>User</kbd> type out of this function. Therefore, they may try to call some of the <kbd>User</kbd> methods on that object:</p>
<pre>println(getUser(1 ).name)  // User-1<br/>println(getUser(10).name)  // NullPointerException</pre>
<p>Calling a method of the <kbd>User</kbd> type on null will result in a null pointer exception unless you first verify that the object is not null.</p>
<p class="mce-root"/>
<p>One problem here is that side effects are not reflected anywhere in the function's signature. Moreover, their handling is not enforced by the compiler. In Java, of course, you are required to declare some exceptions thrown by the functions in their signatures. However, it has proven to be a bad design decision, and most languages do not require such a declaration. Moreover, even in Java, no declaration is made to specify that the function can return a null. Unless the programmer remembers that such side effects occur in the program, they may not handle them. So unless they handle the side effects, the program may be error-prone.</p>
<p>The main problem here is the extra mental load on the programmer. They are required to continually remember all the side effects that their functions may produce. Because if they don't, they will also forget to handle them properly. T<span>hus, their code can introduce bugs.</span> This problem is caused by the fact that the compiler does not enforce the handling of the side effects. The side effects are certain phenomena that are generated by the code at runtime. These <span>phenomena are where local functions influence or are influenced by the outer environment without this being stated explicitly in the function type. These influences may then be generated by the function code, depending on the input values it receives at runtime. </span>The compiler knows nothing about them. For example, the phenomenon of a function returning null, or an exception happening and the program being disrupted at that point. These things happen at runtime. At compile time, the compiler does not do any checks on whether they are appropriately treated.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutable states</h1>
                </header>
            
            <article>
                
<p>A mutable state, to put it simply, is data that can be changed. For example, at one point in time, you may read some variable, <em>x</em>, and find that it points to some data. At another time, you may read a different value from the same variable. The value is different because the variable is mutable and another part of the program mutated it.</p>
<p>Let's look at why exactly the mutable state is not desirable. Imagine you have an online game. It relies on multiple threads, and the concurrency architecture of choice is the actors model. You have an actor that is supposed to track the users currently present in the game. Tracking can be implemented as a mutable collection inside the actor. Users log in and out of the game by sending messages to this actor. So, every time a message for logging in arrives at the actor, the user is added to the list of logged-in users. When users want to log out, they are removed from the list:</p>
<pre>class GameState(notifications: ActorRef) extends Actor {<br/>  val onlineUsers = collection.mutable.ListBuffer[User]()<br/>  def receive = {<br/>    case Connect   (u) =&gt; onlineUsers += u<br/>    case Disconnect(u) =&gt; onlineUsers -= u<br/>    case Round         =&gt; notifications ! RewardWinners(onlineUsers)<br/>  }<br/>}</pre>
<p>Now, imagine you want to find the users that have reached a particular score to congratulate them via an email notification. You may want to do that at the end of each round (assuming it's a round-based game), which is modeled by another message sent to the <kbd>GameState</kbd> actor. One way to implement this is to send a list of all the users to a separate notifications actor that will do the job:</p>
<pre>case Round =&gt; notifications ! RewardWinners(onlineUsers)</pre>
<p>Let's imagine that the job of looking up and notifying the users takes a while to complete. We can simulate the delay via the <kbd>Thread.sleep(1000)</kbd> statement. This statement pauses the execution of the current thread at the line where it is called for 1,000 milliseconds or 1 second. Let's see how this works:</p>
<pre>class NotificationsActor extends Actor {<br/>  def receive = {<br/>    case RewardWinners(users) =&gt;<br/>     Thread.sleep(1000)<br/>    val winners = users.filter(_.score &gt;= 100)<br/>    if (winners.nonEmpty) winners.foreach { u =&gt;<br/>      println(s"User $u is rewarded!") }<br/>    else println("No one to reward!")<br/>  }<br/>}</pre>
<p>The communication protocol is defined as follows:</p>
<pre>sealed trait Protocol<br/>case class   Connect (user : User      ) extends Protocol<br/>case class   Disconnect (user : User      ) extends Protocol<br/>case class   RewardWinners(users: Seq[User]) extends Protocol<br/>case object  Round                    extends Protocol</pre>
<p>Now, let's assume the following environment:</p>
<pre>val system = ActorSystem("GameActors")<br/>val notifications = system.actorOf(Props[NotificationsActor], name = "notifications")<br/>val gameState     = system.actorOf(Props(classOf[GameState], notifications), name = "gameState")<br/>val u1 = User("User1", 10)<br/>val u2 = User("User2", 100)</pre>
<p>We have an actor system, an actor for the game state, and an actor for notifications. Also, we have two users. The second user, <kbd>User2</kbd>, is a <em>winning</em> user because their score is <kbd>&gt;= 100</kbd>. Consider what happens if a <em>winning</em> user with the required score logs out immediately after we complete the round:</p>
<pre>gameState ! Connect(u1)<br/>gameState ! Connect(u2)<br/>gameState ! Round<br/>gameState ! Disconnect(u2)</pre>
<p>Such a user will not be notified. Things go wrong here because the collection we sent to the actor that takes care of notifications is mutable. It is shared between the <kbd>GameState</kbd> actor and <kbd>NotificationActor</kbd>. This means that once a user logs out, they are removed from the collection by the <kbd>GameState</kbd> actor, which means that it will also be removed from the collection of the <kbd>NotificationActor</kbd> because it is the same collection.</p>
<p>The preceding example demonstrates the problem of the shared mutable state in action. Again, this is extra mental load on the programmer. No longer can you reason in the scope of only one thread if you have an object shared with another thread. You must expand your scope of reasoning to all the threads that own this object. Because for all you know, the shared mutable object can be changed at any time. The actor model is supposed to help you to reason as if your program were single-threaded and no other threads existed. However, it won't help if you keep using a shared mutable state.</p>
<p>The traditional approach to managing a shared mutable state is to use locks and monitors. The principle behind it is that a thread that is doing modifications to an object is supposed to take a lock on some monitor so that nobody else will be able to perform a modification while this thread deals with the object. However, this does not remove the mental load from the programmer. You still need to take into account threads other than the one you are currently programming. In practice, it is tough to debug programs that involve concurrency and a shared mutable state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pure functions</h1>
                </header>
            
            <article>
                
<p>In the previous sections, we have shown you how mutations and side effects can make the code harder to read and write. In this section, we will introduce the notion of pure functions, that is, the functions that do not produce side effects. It is central to pure functional programming. The functional paradigm dictates that you should express your program with the help of functions that do not produce any side effects. How would you model a situation where you need to throw an exception with the help of a pure function? Take the familiar <em>Soda Machine</em> example.</p>
<p>This is the slightly shortened version of the <em>Soda Machine</em> example we encountered in our previous discussions on side effects:</p>
<pre>var cans = 0<br/>def insertCoin(): SodaCan =<br/>  if (cans &gt; 0) { cans -= 1; new SodaCan }<br/>  else throw new RuntimeException("Out of soda cans!")<br/>println(insertCoin())</pre>
<p>We can avoid throwing an exception from the function by returning a result wrapped in another data structure:</p>
<pre>def insertCoin(): Try[SodaCan] = Try {<br/>  if (cans &gt; 0) { cans -= 1; new SodaCan }<br/>  else throw new RuntimeException("Out of soda cans!")<br/>}</pre>
<p>In our case, we are not returning a pure result but <span>an encapsulated result in the form of </span>a <kbd>Try</kbd> of the result. The behavior of <kbd>Try</kbd> is to trap the possibility of an exception being thrown within its body for further handling. <kbd>Try</kbd>, as discussed in previous chapters, is a data structure that can contain either a value or an exception. So, if the soda machine is out of cans, we no longer throw an exception. We return the information that an error has occurred from the function.</p>
<p>The benefit here compared to the comparative analysis is as follows. There is no longer an unexpected side effect happening in this function. An error that can happen no longer interrupts the entire flow of the program. Moreover,<span> the call site user of the function</span> must handle the error to access the result. Because the result is wrapped into the data structure, we cannot access that result unless we first unwrap the data structure that it is wrapped into.</p>
<p>We can access the result by analyzing what exactly was returned. If it is a value, we know precisely that no error has happened. If it is an exception, we know that we need to handle it. At this point, we can say that the compiler enforces the handling of the error. The fact that the error can occur is reflected in the return type of the function. Hence, there is no longer a way to use the return value directly after it is returned. If you try to use it directly without first handling the possibility of an error, you will get a compile-time error. Because you will be trying to use the <kbd>Try</kbd> data structure as if it were the type that it wraps.</p>
<p>Another feature of purely functional programming is that it avoids using mutable data structures. Let's have another look at the example of the actors exchanging data with <span>one </span> another. What if instead of exchanging a mutable data structure we exchanged an immutable data structure? An immutable list? Check out the following:</p>
<pre>class GameState(notifications: ActorRef) extends Actor {<br/>  var onlineUsers = List[User]()<br/>  def receive = {<br/>    case Connect   (u) =&gt; onlineUsers :+= u<br/>    case Disconnect(u) =&gt; onlineUsers = onlineUsers.filter(_ != u)<br/>    case Round         =&gt; notifications ! RewardWinners(onlineUsers)<br/>  }<br/>}</pre>
<p>As you recall, in the previous example, we had a problem with the list being modified from another thread when <kbd>NotificationActor</kbd> was trying to use it. Now, if we use an immutable list instead of a mutable list, the problem of mutation from another thread goes by itself, since immutable data structures cannot be mutated. A data structure that is immutable is automatically thread-safe. You can guarantee that nothing will mutate the data structure. Hence, you can share it freely with any other thread.</p>
<p>This argument can be extended by exchanging data with other methods as well. Imagine you have some mutable data structures and some <kbd>blackBox</kbd> methods:</p>
<pre>val listMutable  : Seq[Int] = collection.mutable.ListBuffer[Int](1, 2, 3)<br/>def blackBox(x: Seq[Int]): Unit = ???<br/>blackBox(listMutable)  // Anything could happen to listMutable here, because it is mutable</pre>
<p>After these <kbd>blackBox</kbd> methods have gone forth on this data structure, how do you know what exactly is contained in it now? You can't have any guarantee of a mutable data structure unless you know exactly what happens in the black box method. Now, consider an example of an immutable list and the same situation of a black box method being called on this list:</p>
<pre>val listImmutable: Seq[Int] = List(1, 2, 3)<br/>def blackBox(x: Seq[Int]): Unit = ???<br/>blackBox(listImmutable) // No matter what happens, listImmutable remains the same, because it is immutable</pre>
<p>Do you have any guarantee of<span> </span><span>what is contained in this list after the black box method did its job? You do because the list is immutable. Nothing can modify this list. So you can freely pass it around, not only to other threads, but also to other methods within one thread, and be confident that it is not modified.</span></p>
<p>The benefit of such an approach is that there is no longer a need to extend the scope of your reasoning beyond your current local scope. If you are calling a black box method on an immutable data structure, there is no need for you to know exactly what happens in this method. This method will never modify an immutable data structure and knowing that is enough. So, if you're working in a multithreaded environment, or if you are working only with immutable data structures, no longer do you need to worry about things such as synchronization or taking locks. You know that your immutable data structure will never be changed by any thread.</p>
<p>So far, we've discussed the property of purity from an intuitive perspective. Now let's look at a more scientific way of defining it—the concept of referential transparency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referential transparency</h1>
                </header>
            
            <article>
                
<p>The concepts of immutability and lack of side effects are encompassed by the term <strong>referential transparency</strong>. With a referentially transparent function, you can substitute the function call with the result it returns without changing the semantics of the program.</p>
<p>Let's see how it works on an example. Consider another type of side effect—logging. The function returns the name of a user with a given ID, but it also writes that name into a log—the standard output, in this case:</p>
<pre>def getUserName(id: Int): String = {<br/>  val name = s"User-$id"<br/>  println(s"LOG: Requested user: $name")<br/>  name<br/>}<br/>val u = getUserName(10)</pre>
<p>Can we substitute the call of the preceding function with the result it computes? Let's try:</p>
<pre>val u = "User-10"</pre>
<p>The semantics would not be the same in this case. The original program prints the log to the standard output. The current program does not. This is so because the standard output occurred in the function that we have replaced with the result it computed, as a side effect.</p>
<p>Now, let's consider another program:</p>
<pre>def getUserNamePure(id: Int): (List[String], String) = {<br/>  val name = s"User-$id"<br/>  val log  = List(s"LOG: Requested user: $name")<br/>  (log, name)<br/>}<br/>val u = getUserNamePure(10)</pre>
<p>The function does the same thing, but instead of producing a side effect of logging, it includes the information that the side effect should have occurred into a list of all the messages that were supposed to be logged. Now we can return the list with the messages together with the result of the function.</p>
<p>Can we substitute their function call with the result it computes without losing the semantics of the program? Check out the following:</p>
<pre>val u = (List("LOG: Requested user: User-10"), "User-10")</pre>
<p>Now the answer is yes. The original function computed the list with all the messages it produced and returned it together with the value it computed, without actually producing any side effects. Since there were no side effects produced in the process, we can substitute the function call with its result without changing the semantics of the program. The function is referentially transparent.</p>
<p>As you can see from the preceding example, in a referentially transparent function, all of the side effects are reflected in the return type and are usually represented by a specific data structure. This style may look verbose and unreadable to you at first because you are returning a pair with some extra stuff from your function. However, don't forget that one of the main principles of engineering is that of abstraction. So the unreadable code you see here can be abstracted away if you have proper abstractions. This can be done without losing the benefits we have achieved. The benefits include reducing the mental load on the programmer, the ability to explain your program locally, and the ability to exclude side effects from the equation.</p>
<p>And such abstractions have been invented. Languages such as Scala or Haskell have excellent support for such abstractions. Later in this book, we will dive much deeper into how they work and how you can write programs with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generally encountered side effects</h1>
                </header>
            
            <article>
                
<p>In this section, we will talk more about the side effects commonly encountered in programs. Some of them we have already introduced, and others you may already know from your everyday programming. However, it is crucial for you to pay particular attention to such side effects, because this way, you learn to distinguish them in an ordinary program.</p>
<p>When writing programs (and when living our lives in general), very often, we get used to things without even paying attention to them. Certain things may be a source of headaches and problems, and the first step to resolving the problems is to name the things that cause them.</p>
<p>As functional programming aims to eliminate side effects, it is reasonable for us to name some of the side effects that cause pain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error</h1>
                </header>
            
            <article>
                
<p>The first effect we will be discussing is the effect of an error. An error is produced when something goes wrong in your program. In imperative languages, it is usually modeled by an exception. An exception is a phenomenon produced by a line of the program that disrupts the execution flow of the program at that point. Usually, it propagates up the call stack, disrupting the execution at its parent call stacks too. If left unhandled, exceptions propagate to the topmost call-stack frame, and the program will crash.</p>
<p>Consider an example of division by zero:</p>
<pre>def division(n1: Double, n2: Double): Double =<br/>  if (n2 == 0) throw new RuntimeException("Division by zero!")<br/>  else n1 / n2</pre>
<p>We have a division function that checks whether its denominator is zero. If it is, the function throws an exception. Now, consider calling this function as follows:</p>
<pre>division(1, 0)<br/>println("This line will never be executed")</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The execution of the main program will not progress further than the line where we tried to call the division function, the second argument of which is zero. This is because the error will happen in the function and will get propagated up the stack, eventually crashing the program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Absence of result</h1>
                </header>
            
            <article>
                
<p>Consider a situation where we have a function that is supposed to make a database query. Specifically, we have users in our database, and we want a function to retrieve a user by their ID. Now, what will happen when there is no user with a given ID in the database? Consider the following:</p>
<pre>def getUser(id: Int): User =<br/>  if (Set(1, 2, 3).contains(id)) User(s"User-$id")<br/>  else null</pre>
<p>The solution of imperative languages is a null returned from the function. In <a href="67d28304-c855-47aa-afb6-b74fa5a0dd28.xhtml" target="_blank">Chapter 3</a>, <em>Functional Data Structures</em>, we saw how this is dangerous. The compiler doesn't know that null can be returned from the function. More precisely, it doesn't even know this is a possibility. The compiler allows for functions returning <kbd>null</kbd> and does not warn us about a possible null return value. The imperative style embraces this possibility. So we have a situation in imperative languages where potentially every function that returns an object may also return null. If we do not check that the result of that function is not null, we risk bugs. And to check the result of the function, we need to keep in mind the possibility of it returning null. And this is an extra mental load.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delay and asynchronous computations</h1>
                </header>
            
            <article>
                
<p>Imagine your program performs an HTTP call. For example, it tries to retrieve some JSON object from a web API. It can take some time; it may even take several seconds to complete.</p>
<p>Imagine that you want to make some competition within a function and return some value based on the result of the API request. You run into a problem here because the result of the API call was not available immediately. The fact that you need to wait for a specific long-running operation to complete is also a side effect.</p>
<p>You can block on this long-running operation and resume your competition once the result arrives. However, this function will also block any functions that are calling it. In the context of a performance-critical environment, this may be an issue. For example, consider a web server. It has several threads to serve all the incoming requests. If its operations take too long to complete, it will quickly run out of threads. And some requests will end up waiting for a long time in the queue for a free thread.</p>
<p>So, you always need to keep in mind that some of your functions are blocking and take time to return. This is an extra piece of information to keep in mind. This produces an extra mental load for you. The side effect of delayed computation causes all of this.</p>
<p>The solution used in modern web servers is to make your server asynchronous. This means that you never wait for a long-running operation. You specify what to do next using a callback and continue according to that callback once the result is in place. This can lead to a situation known as callback hell. The problem is that when you overuse callbacks, the execution flow of the program becomes quite obscure.</p>
<p>Usually, when something in the program is not apparent, this indicates a need for an abstraction. So it can be a good idea to abstract away callbacks.</p>
<p>Functional programming also has a means to abstract away long-running computations. With it, you can write your code as if they were returning immediately. The data type of <kbd>Future</kbd> is present both in Scala and Java, and also in many modern programming languages. It servers precisely the purpose of abstracting long-running computations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>In an example <span>in the <em>Referential Transparency</em></span> <span>section of</span> this chapter, we saw how logging can also be a side effect. Logging can be done using a separate login framework, or it can be as simple as writing to the standard output.</p>
<p>Things may get tricky with logging when you work in an unfamiliar environment. For example, if it is the environment of your desktop computer, everything is simple. You run a program from your terminal, and it outputs everything to the terminal. However, what if it is a web server? Often, you need to output your log into a separate file for it to be readable afterward. Alternatively, what if you are writing a mobile application? The program runs on a separate device, and it is not always the case that a print statement causes an output to your terminal. You may need to use some system-specific logging API, native to the environment you are working in.</p>
<p>Now imagine you have a program that has <kbd>print</kbd> statements pretty much everywhere in it. You suddenly start to understand that some of your functions try to interact with the environment outside of its scope when logging. Specifically, the logging API particular to the environment under which you are working. Now you need to modify this logging call to match the expectations of the environment.</p>
<p>A function that writes to a log interacts with the environment outside its scope. This means we can treat such calls as side effects according to our definition. Since you need to pay attention to these intricacies when working in different environments, it is fair to say they contribute to your mental load.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Input-output operations</h1>
                </header>
            
            <article>
                
<p>The final side effect that we'll discuss here are <strong>input-output</strong> (<strong>IO</strong>) operations to the filesystem, or to the network. We can say that these operations are side effects because they depend on the environment so much.</p>
<p>In the case of IO operations on the filesystem, the success of the operation depends on whether the filesystem contains the specified file or if the file is readable. When performing network operations, the operation depends on whether we have a reliable internet connection or any firewalls.</p>
<p>When debugging an IO program, lots of moving parts come to our attention. Do we have access to the desired filesystem? What about the ownership of the files we are trying to read or write? What about the permissions the current user has? What about filesystems of different operating systems? Linux and Windows have very different approaches to structuring their filesystems, so how do we port our application from one system to another? Do we have a reliable internet connection? Are we not behind a firewall? Do our DNS servers work correctly? Is the port we are trying to listen on available on this particular system?</p>
<p>It is an extra mental load on you because there are so many things you need to consider. Hence, you can treat IO as side effects and an extra mental load.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">But how do we get rid of the side effects?</h1>
                </header>
            
            <article>
                
<p>If you come from a purely imperative background, you may be quite confused at this point. Purely functional programming says that you need to eliminate all the side effects. But can you imagine a program without logging? And what would be the use of a web API that cannot connect to a network? If we cannot throw an exception, how do we specify the erroneous behavior of the program?</p>
<p>The side effects specified previously are essential to most modern applications, and it is usually not possible to imagine a reasonable program without side effects.</p>
<p>Therefore, it would be wrong to say that purely functional programming eliminates side effects from your program completely. Instead, it would be more precise to say that it eliminates side effects from your business logic. It pushes side effects away from the parts of your application that matter. The way it usually works with the purely functional style is that your business logic, which encompasses 90% of the code, is indeed purely functional.</p>
<p>You do not have all of the side effects specified previously. However, whenever the business logic needs to perform a side effect, it does not enact it directly. Instead, it creates a data structure that specifies which side effect needs to be performed, without actually performing them. Functional applications often have an entire domain-specific language to describe side effects. And whenever a piece of logic needs to execute a side effect, it expresses its need in this language. The specification of what needs to be done and the act of executing that specification are separate one from another.</p>
<p>Functional applications usually have a thin layer that takes care of executing the side effects expressed in the effect language of the application. The advantage of this approach is that most of the time you work on the business logic, this 90% of your code. And this code is referentially transparent and pure. Which means all of the side effects that would have typically been present in it are separated away from it. All of the mental load that we were discussing previously is gone. This means that, most of the time, you are working without any extra mental load, locally, without considering the global scope.</p>
<p>It is true that you also need to write the interpreter for your side effects. This is the 10% of code that the side effects expressed in the effect language of your choice. However, it is separate from your business logic. You can test your effect interpreter separately. Once it is written and in place, you can forget about it, and write your business logic in a pure way.</p>
<p>At this point, we are not yet diving into the details of how it is done. The purpose of this section is to give you an idea of how the problem of purity in a side-effecting application is addressed. Later in this book, we'll see precisely how functional programming facilitates this technique and what exactly it provides to write programs in this style.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pure functional paradigm in different languages</h1>
                </header>
            
            <article>
                
<p>It doesn't take any particular infrastructure to program in a purely functional style. All you need is to be able to see side effects in code, to notice when they place an extra mental load on your mind and require you to hold more things in mind at once. And of course, you need to know how to abstract them away, how to make this mental load go away. Most modern programming languages are built for engineers. This is why they provide excellent capabilities for abstraction, including imperative languages such as C or Java. This is why, if you know what to abstract and how, you should be able to abstract that in these languages. And if you know precisely how the imperative style can hurt you, you can shield yourself from the trouble.</p>
<p>Moreover, certain imperative programming languages provide a specific infrastructure that facilitates purely functional style directly. For example, in Java, you have the <kbd>final</kbd> keyword. A variable declared with this keyword is immutable. You're not able to modify a <kbd>final</kbd> variable in Java once it is assigned a value. Also, in Java, you have immutable collections as part of its core infrastructure.</p>
<p>Even though you can apply the functional style in imperative languages, it is much easier to do so in functional languages. You may encounter trouble when applying the style to imperative languages. One thing may be that all the libraries you encounter are imperative. It may be hard to write purely functional code in such conditions because you will be working inside an imperative infrastructure. It will create certain inertia that may be hard to fight. So it may not be practical to work in the functional style in imperative languages. However, it may be used as a last resort, if you are overwhelmed by complexity.</p>
<p>The benefit of pure functional languages, such as Scala or Haskell, is that they provide you with an excellent infrastructure to write functional code. Haskell is a language that enforces functional style. There is just no other choice of style that you can use with that language. Hence, the libraries that you will be using in this language are also purely functional. You can work in a purely functional infrastructure. Scala is a more liberal language in some sense. It is a mix of the object-oriented and functional styles. So, it is convenient to use it to make a transition between purely imperative and purely functional styles. That is because you have a choice of style. If you do not know how to implement something in a purely functional way and deadlines are approaching, you can always resort to a familiar imperative style.</p>
<p>This blending of the imperative and functional styles is pretty standard in modern programming languages. For example, in Python, you can encounter both styles. Some libraries are quite imperative, but there is good support for purely functional style too. Java is more conservative in this sense than Python. It appears to follow the imperative, algorithmic paradigm quite strictly<span>, even though huge efforts have been put into making the functional style more natural to Java during the last decade or so</span>.</p>
<p>All in all, the point of this section is that the functional style is not about the language. The language can provide some momentum, in the sense of its existing infrastructure and the methodology of its community. This momentum can be in either direction—either it will work for you, or against you. However, if you understand the functional approach, you should be fine programming in any language using it. But you should always be aware of where the wind blows—what the moods of its community are, what philosophy its libraries follow. You should be aware of the momentum the language provides you and whether it works for you or against you.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The traditional imperative approach relies heavily upon algorithms that are supposed to produce certain phenomena at runtime—the side effects. The compiler is usually not aware of these phenomena or is not aware of them enough. We can define the side effects for this book as instructions that modify the environment outside their immediate scope. Side effects are usually not desirable, because they put extra mental load on the programmer's mind.</p>
<p>Another problem with the traditional imperative style is the mutation. Mutable data structures are not thread-safe. Also, they<span> cannot be safely passed between pieces of logic even within the same thread.</span></p>
<p>Functional programming aims to resolve these problems and reduce your mental load. This style does so by abstracting away side effects, so that you write your program without explicitly performing them or mutating anything outside your current scope.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the side effects?</li>
<li>What is mutable data?</li>
<li>What problems might side effects and mutable data cause?</li>
<li>What is a pure function?</li>
<li>What is referential transparency?</li>
<li>What are the benefits of using a purely functional style?</li>
<li>What are some generally encountered side effects?</li>
<li>Is it possible to program with a purely functional style in imperative languages such as Java?</li>
<li>What are the benefits of using a functional programming language over an imperative programming language for programming with a purely functional style?</li>
</ol>


            </article>

            
        </section>
    </body></html>