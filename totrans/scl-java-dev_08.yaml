- en: Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Availability and performance are two words that often characterize the requirements
    found behind most commercial software. As the volume of processed information
    continues to grow together with the rise of social networks and added complexity
    of online services, web servers are now increasingly confronted with heavy loads
    and higher numbers of concurrent requests. In this chapter, we will explore different
    ways to deal with better performance and scalability by covering the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Async library, a new way to simplify asynchronous code, including examples
    of web services composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akka, a toolkit and runtime that simplifies the building of concurrent, distributed,
    and fault-tolerant applications based on the actor paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pillars of Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency and asynchrony are the techniques that most programming languages
    use to enhance response time and scalability, and Java is no exception. Asynchronous
    method calls is a technique by which the caller of a potentially time-consuming
    computation does not wait for a response, but rather continues to proceed with
    other code while the computation is ongoing. The caller will be notified once
    running has completed, receiving notification of either a successful result or
    a failure message.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional way to deal with asynchronous code in Java has mostly been through
    the registration of callbacks, that is, placeholders that are called upon completion.
    Complexity tends to increase when working with asynchronous code as the sequence
    of execution is not deterministic, that is, the order of execution is not guaranteed.
    Executing code concurrently is, therefore, more difficult to test since it may
    not produce the same result on successive invocations. Furthermore, as callbacks
    are not composable (which means that they can't be chained and combined in a flexible
    way), it can be cumbersome to mix several asynchronous computations together to
    achieve more advanced scenarios, resulting in the well-known problem of callback
    hell when such projects increase in size (cases where the complexity is at such
    a high level that it is difficult to maintain and guarantee the proper execution
    of a piece of code).
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is also encountered when code is executed on multiple cores. Recent
    hardware architectures are now embedding several cores into the same machine as
    a way to continue achieving better performance when the minimal physical size
    of transistors has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: Another consequence of dealing with concurrent code is that multiple threads
    of execution can get into conflicts when trying to access the same resources.
    Mutable state in a program, which is not protected against shared access, has
    a higher risk of being incorrect. Making sure that the concurrent code executes
    correctly often comes at the cost of increased complexity. Java thread synchronization
    mechanisms, for example, using locks, have led to solutions that are difficult
    to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The functional approach of Scala striving for immutability is a first step towards
    easier concurrency. **Scala Improvement** **Process** (**SIP**), which can be
    seen as the equivalent to the Java JSR process in Scala, has proposed an SIP concerning
    *SIP-14-Futures and Promises*. These notions are not new as they have already
    been used in many other languages when writing concurrent code, but the new proposal
    tries to merge the various Scala implementations of Futures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Futures and Promises are objects through which you can later retrieve the result
    of some asynchronous execution after it finishes. To learn more, visit [http://en.wikipedia.org/wiki/Futures_and_promises](http://en.wikipedia.org/wiki/Futures_and_promises).
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated in *SIP-14-Futures and Promises*:'
  prefs: []
  type: TYPE_NORMAL
- en: Futures provide a nice way to reason about performing many operations in parallel—in
    an efficient and non-blocking way.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From this proposal, an implementation has been created, which is now the basis
    of many Scala libraries that deal with concurrent and asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: The Async library – SIP-22-Async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.html "Chapter 7. Working with Integration and Web Services"),
    *Working with Integration and Web Services*, we have briefly seen how to call
    asynchronous web services that return a `Future` object. The aim of Async is to
    simplify asynchronous code by providing a couple of powerful constructs to deal
    with asynchronous code blocks and, in particular, combining several such blocks.
    It consists of only two constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`async { <expression> }`: In this construct, `<expression>` is the code to
    be executed asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`await { <expression returning a Future> }`: This construct is included in
    an `async` block. It suspends the execution of the enclosing `async` block until
    the argument `Future` is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interesting characteristic of the whole `async`/`await` mechanism is that
    it is totally nonblocking. Although it is not really required to understand how
    `async`/`await` works, the exact signature of the two methods `async[]` and `await[]`
    are given for reference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`T` refers to arbitrary types (such as `Int` or `String`) or container types
    (such as `List` or `Map`), which is how we describe generic types in Scala. Although
    we will not cover too much programming with generic types, which has already been
    extensively described in other books such as *Programming in Scala,* *Artima*
    by *Martin Odersky*, *Lex Spoon* and *Bill Venners*, it is important to understand
    that they exist and they form part of the core of the Scala language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what Async is all about, we will use the examples that
    we can run in the REPL. Create a new `Play` project by running the command `>
    play new ch8samples` and choose, of course, Scala as the language used for the
    project. Once the project is created, add the Async library as a dependency by
    adding one line inside the `build.sbt` file, which now looks like the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the REPL console, as usual, in a terminal window by entering the
    following command from the root directory of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to perform some imports, which are as shown in the following
    command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, for a thread pool, an execution context is needed to handle how and
    when the asynchronous computation should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we can specify an asynchronous computation by enclosing the computation
    into an `async` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see that the type of the result is `Option[scala.util.Try[Int]]`,
    recollect the brief discussion on the `Try` class in [Chapter 2](ch02.html "Chapter 2. Code
    Integration"), *Code Integration*. We learned that it builds upon an `Either`
    class that can take the value `Success` or `Failure` that corresponds respectively
    to the `Left` and `Right` values of the `Either` class.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the computation was quite immediate and resulted in the success
    value of `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us make the computation that takes a longer time (for example, 10 seconds),
    as shown in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, during those 10 seconds, we access its result value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will get the answer `None`, which is what we expect, as the computation is
    not completed yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wait for 10 seconds and perform the same query again, we''ll get our
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that once a Future is completed and given a value, it cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to polling for the result is to be informed or execute some
    code when the Future is completed. We can do that by invoking the `onComplete`
    method, immediately after rerunning our computation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, while the computation is not finished, we can proceed executing
    other statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Eventually, we will see the value `6` on the screen, once the time of 10 seconds
    elapses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So far, we've seen that the `async` method performs the same way as the `future`
    method, which is part of the `scala.concurrent` package; for this reason, we could
    just replace `async` with `future`.
  prefs: []
  type: TYPE_NORMAL
- en: The preferred way is to use `async` in conjunction with `await`. The `await`
    method is taking a `Future` object as an input argument. It wraps the rest of
    the `async,` blocks in a closure and passes it as a callback on completion of
    the `Future` object we're waiting on (the one we passed as argument). Although
    `await` will wait for the invoked `Future` object until it is completed, the whole
    `async`/`await` execution is nonblocking, which means we can compose the `Future`
    objects in a totally nonblocking way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate composing two computations where the input of one depends
    on the output of the other. A typical example is the invocation of two web services
    to query a weather forecast service: one that returns our current geo location
    and the other that needs our position (coordinates or the city name). The following
    lines of command explain the invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a couple of seconds to make sure that the web service `Future` gets
    completed, then press *Enter*; you''ll see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first service returns the XML text where we extracted only the `City` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try a second service from the [http://openweathermap.org](http://openweathermap.org)
    website, a useful resource for testing web service code in general. The following
    web service call returns the weather as a JSON message, given a particular location
    (we will use a hardcoded `Paris` city here to first experiment with this service
    alone without composing the two services):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a couple of seconds to make sure that the web service `Future` gets
    completed, then enter the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Combining web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to combine two services using `async`/`await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy and paste the following lines at once in the REPL. To do this,
    we can use the convenient `:paste` command of the REPL, as shown in the following
    command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What happens in this code is that the `await` construct ensures that the location
    city will be available to the weather service.
  prefs: []
  type: TYPE_NORMAL
- en: Combining services without await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we do not put an `await` method around the `futureLocation` web service
    call while defining the `futureWeather2` variable, we get a different answer.
    This is because, in such a case, the `Future` object that contains the location
    service answer is not yet populated when querying for the weather service. You
    can verify this behavior by copying and pasting the three following statements
    at once into the REPL (assuming the `locationURL` variable is still valid, it
    was created earlier while introducing the location service):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, the output shows that the city was not entered correctly into the
    weather service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Akka** is a toolkit to simplify writing concurrent and distributed applications,
    tasks that can be complex to achieve, as we described at the beginning of this
    chapter. As Akka is largely documented both by a number of books as well as extensive
    online documentation, our goal here is mostly to experiment with the technology.
    We will see how to elegantly write Scala code to solve problems that might otherwise
    be error-prone and hard to understand if written in more conventional ways such
    as thread synchronization and other languages such as Java. Akka is written in
    Scala, but provides to both Java and Scala APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Actor model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Akka relies on the Actor paradigm to create concurrent applications. The Actor
    model has already been introduced decades ago in the original paper of Carl Hewitt,
    Peter Bishop, and Richard Steiger entitled *A Universal Modular Actor Formalism
    for Artificial Intelligence*, *1973*, *IJCAI*. Erlang is an example of language
    that has been made famous using this model of computation and achieved very good
    scalability and reliability figures (the well-known nine nines of availability).
  prefs: []
  type: TYPE_NORMAL
- en: Without going too much into details, we can say that the Actor model is a model
    based on message passing rather than method calls. Each unit of computation, called
    **actor**, encapsulates its own behavior and communicates with other actors through
    asynchronous immutable messages. It is quite straightforward to reason about actor
    systems since they mimic the way humans communicate, exchanging immutable messages
    between each other. Since the footprint of actors is very minimal compared to
    threads, and state is not shared, they are very suited to writing concurrent and
    distributed applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the gold mine of Typesafe activator templates, a number of projects concerning
    Akka are available. Let's dig into a couple of them to better understand how to
    make programs using Akka actors. First, we can take a look at the `hello-akka`
    project to get an idea on how to run a simple actor.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't got the Typesafe activator in place, follow the instructions
    from [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"), *Understanding
    the Scala Ecosystem*, to create the sample project associated with the `hello-akka`
    template. Once imported into Eclipse, we may start looking at the main class `HelloAkkaScala.scala`
    in the default package of the `Scala src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts with the following lines (skipping the imports):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you see, defining an actor consists of extending an `Actor` trait and requires
    only implementing the abstract `receive` method. This method represents the actor's
    behavior when it receives a message. It does not need to handle all types of messages,
    which is why it is a partial function.
  prefs: []
  type: TYPE_NORMAL
- en: The declared mutable variable, `greeting`, shows that you can safely add some
    mutable state to your actor since the processing of the `receive` method is single
    threaded.
  prefs: []
  type: TYPE_NORMAL
- en: It is convenient to model the immutable messages sent between actors as case
    classes, and the `Greeter` actor uses the two messages, `Greet` and `WhoToGreet(who:String)`.
    Whenever the `Greeter` actor receives a `WhoToGreet(who)` message, it simply updates
    its state but does not reply anything. In contrast, when this same actor receives
    a `Greet` message, it uses the saved state to answer the actor that sent the message.
    The `!` method is also called `tell` (which, by the way, is the name used in the
    Akka Java API) and represents the sending of a message to an actor, with the signature
    `actor ! message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note the presence of the `sender` variable that is made implicitly available
    as part of the `Actor` trait, since it is a common pattern that an actor replies
    to the sender. However, we could have added an `ActorRef` argument to the `Greet`
    message containing the address of the receiver instead, that is, declared a `case
    Greet(someone:ActorRef)` class and implemented the processing of `Greet`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HelloAkkaScala` object defines the main routine, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A system running actors needs a runtime environment; this is what the `system`
    variable declares. Creating an actor consists of invoking the `system.actorOf`
    method with a configuration argument as well as an optional name. This method
    gives you back an `ActorRef` (actor reference) object, which is the actor address,
    that is, where messages can be sent. An `ActorRef` object is an immutable and
    serializable handle to an actor, which may or may not reside on the local host
    or within the same `ActorSystem` object. As actors only communicate through messages
    in an asynchronous fashion, each actor has a mailbox where messages can be enqueued
    if the actor cannot handle them as quickly as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the main routine essentially sends orders in the form
    of `Greet` or `WhoToGreet` messages to the `Greeter` actor. These messages are
    sent from an `Inbox` object that also expects answers. This `Inbox` object, also
    referred to as "actor-in-a-box", is a convenient way to write code outside actors
    that will communicate with actors. Finally, the last actor, `greetPrinter`, sends
    `Greet` messages (that are scheduled by the environment) to the `Greeter` actor
    repetitively every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute the example code within the project by running the command
    `> ./activator run` and choosing the `[2] HelloAkkaScala` program. You should
    see something as is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Switching behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actors have the ability to switch their behavior before handling the next message.
    To illustrate this, let''s consider an example of a travel agent actor that needs
    to reserve both a seat in a flight and a hotel room for its customer. The travel
    agent is responsible for making sure the booking is transactional, that is, it
    is only successful if both transport and accommodation are booked, which is illustrated
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching behavior](img/3637OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As it is a recognized best practice to declare the messages concerning an actor
    into its companion object, we will express a `Flight` actor in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `require` assertion found in the `BookSeat` message declaration.
    This method is part of `Predef`, a global object that includes many useful functionalities
    imported by default. It enables to do some *design-by-contract* style specification
    by checking pre- and post-conditions on methods. The `receive` method of the `Flight`
    actor is handling one type of message only, `BookSeat(n:Int)`, which means reserving
    *n* seats as long as there are enough seats left for the flight. The `Flight`
    actor updates its state and replies with a `Done` message to the sender if there
    are enough seats left; it replies `Failed` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `LoggingReceive` class that surrounds the block handling the actor
    messages. It is part of the `akka.event` package and is a convenient way of logging
    information that reaches this block. We will see later on, while executing the
    sample code, what these messages look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, a `Hotel` actor that takes care of reserving a room for
    *n* persons can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The travel agent actor is the one that is going to switch its behavior. Once
    it has sent orders to book plane seats and hotel rooms for a number of people,
    it will successively change state while expecting answers. Since the messages
    sent to both `Flight` and `Hotel` are asynchronous, that is, nonblocking, we do
    not know which answer will come back first. Furthermore, answers might not come
    back at all as there is no guarantee at this point that the messages have been
    delivered or correctly handled. The code for the `TravelAgent` actor is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The invocation `context.become(<new behavior method>)` switches the behavior
    of the actor. In the case of this simple travel agent, the behavior will be switched
    to the expected messages that can be received in any order from the `Flight` and
    `Hotel` actors, respectively. If a successful answer is received from either the
    `Flight` or `Hotel` actors, the `TravelAgent` actor will switch its behavior to
    expect only the remaining answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we only need a main routine to create our initial actors and initiate
    communication with the `TravelAgent` actor, as exhibited in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the four actor classes involved in the use case have been written in Eclipse,
    running the program can be done by running an Eclipse configuration. Navigate
    to **Run** | **Run Configuration…** and edit a new **Java Application configuration**
    window knowing that the main class to run is the `akka.Main` class of the Akka
    runtime, as specified in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching behavior](img/3637OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The actual main routine we want to run is passed as an argument. To do that,
    edit the **Arguments** tab of the same window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching behavior](img/3637OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the debug messages produced by the `LoggingReceive` object to be active,
    you need to add the VM arguments as specified in the previous screenshot. Clicking
    on the **Run** button will execute the `BookingMain` class within the Akka runtime
    environment and display the following flow of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching behavior](img/3637OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to test an alternative scenario, for example, to see the booking
    failed while reserving the hotel, just put a higher number of persons, that is,
    `20` in `travelAgent ! TravelAgent.BookTrip(flight,hotel,20)`, instead of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Supervising actors to handle failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In applications that are running actors concurrently, there might sometimes
    be exceptions that are thrown and those make an actor die eventually. As other
    actors are still running, it might be difficult to notice partial failures. In
    traditional architectures, where an object calls methods on other objects, the
    caller is the one receiving the exception. Since it usually blocks waiting for
    a response, it is also the one responsible to handle the failure. With actors,
    as all messages are being handled asynchronously without knowing the time it will
    take before receiving an answer (if any), the context in regards to the sent messages
    is usually not around anymore to handle the failure; so, it might be more difficult
    to react on an exception. In any case, something must be done about the failing
    actor for the application to function properly as its whole.
  prefs: []
  type: TYPE_NORMAL
- en: This is why Akka embraces the "let it crash" philosophy by providing support
    to monitor and eventually restart an actor or a group of dependent actors. As
    actors are normally created by other actors, they can be organized as hierarchies
    where an actor's parent is also its supervisor. Handling partial failure, therefore,
    consists of defining some strategies to restart part of the actor hierarchy simultaneously,
    depending on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to our small travel booking application, we can refactor the
    `TravelAgent` actor to be the supervisor of the `Flight` and `Hotel` booking actors.
    Therefore, we can declare the following supervisor strategy within the `TravelAgent`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The two possible strategies are `OneForOneStrategy` and `AllForOneStrategy`.
    In the first case, each child of the supervisor will be handled separately, whereas
    in the second case, all children of the given supervisor will be handled simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Flight` companion object now contains an additional message that reflects
    the failure, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To simulate the fact that booking the seats on a flight might fail at times,
    we can introduce the following method call when handling the `receive` method
    of the `Flight` actor, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Relaunching the booking scenario with the `Run` configuration will display
    (since the failure happens only 25 percent of the time) the failing message at
    times, as shown in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For interested readers who want to elaborate more on the topic of supervision,
    there is a complete and consistent sample called `akka-supervision` that is part
    of the activator templates. It demonstrates the computation of arithmetic expressions,
    so that nodes that represent subparts of the total computation may fail and be
    restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Testing actor systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of their nondeterministic nature, concurrent systems require some special
    care when testing them in contrast to traditional single-threaded architectures.
    Actor systems are no exceptions; the messages being sent and received asynchronously,
    there are multiple paths a program flow can follow. Fortunately, Akka provides
    a lot of support defined in the `akka-testkit` module for dealing with tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Testing Tools"), *Testing Tools*, we have
    already covered a number of examples involving the `scalatest` framework by looking
    at the `test-patterns-scala` activator template project. It contains a basic use
    case regarding the testing of Akka actors through the `testkit` module. You can
    reimport this template project into Eclipse or just open it if it is still in
    the IDE. The `Test09.scala` file exhibits the usage of a testing actor by providing
    an `ImplicitSender` trait that fakes the sending of messages to two actors under
    test. The first actor under test is a simple echo actor, whereas the second is
    calling a location service asynchronously that calculates the latitude and longitude
    of a given address. The syntax of the `GeoActor` object, given in the following
    test, should look familiar since it uses the dispatch libraries in the same way
    as we have seen in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"),
    *Understanding the Scala Ecosystem*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main routine of the test case, we mix in the `ImplicitSender` trait
    and then invoke the `expectMsg` method :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `expectMsg()` method has the role of an assertion that takes duration as
    a parameter, so that it does not wait forever for the reply to come back. Instead,
    it will throw an exception if the specified time has passed and it has not yet
    received the answer it was waiting for.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring further with Akka
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the useful functionalities of actor messaging and supervision,
    Akka includes support for many other, more advanced features. Among them are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: It monitors the lifecycle of actors through the `DeathWatch` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It persists actor state for recovery after failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It remotes with actors, that is, communicates with actors in a distributed environment
    and in a transparent way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It clusters to handle failure in a distributed environment. A sample of the
    clustering features is also available as the `akka-clustering` activator template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features are out of the scope of this book, but they are extensively documented
    on the Akka site and available at [http://akka.io/docs/](http://akka.io/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have first studied how to deal with asynchronous Scala code
    using the Async toolkit, which simplifies writing nonblocking code using Futures
    and Promises. We then moved to the concurrency topic by introducing the Akka framework
    based on the actor paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent and distributed systems is such a large topic that we have only introduced
    some basic usage scenarios of actor systems. We have learned that since the behavior
    and state of actors are encapsulated, actor systems are easy to reason about.
    Moreover, the supervision and clustering support in Akka makes the handling of
    failure and distribution very robust. The material covered in this chapter is
    just a glimpse of what the toolkit can achieve; the very extended and well-written
    documentation of the Akka project will guide you through creating scalable and
    distributed applications. Programming asynchronous, concurrent, and distributed
    systems is often a complex task, and the actor model makes it more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Since Akka is also the foundation of the `Play` Framework, we will continue
    to use it through the next chapter. We will build reactive web applications in
    `Play` to illustrate how to create modern applications that need to handle streams
    of data and push information into the browser.
  prefs: []
  type: TYPE_NORMAL
