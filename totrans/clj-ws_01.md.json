["```java\n    $ clj\n    ```", "```java\n    Clojure 1.10.1\n    user=>\n    ```", "```java\n    user=> \"Hello REPL!\"\n    ```", "```java\n    \"Hello REPL!\"\n    ```", "```java\n    user=> \"Hello\" \"Again\"\n    ```", "```java\n    \"Hello\"\n    \"Again\"\n    ```", "```java\n    user=> 1 + 2\n    ```", "```java\n    1\n    #object[clojure.core$_PLUS_ 0xe8df99a \"clojure.core$_PLUS_@e8df99a\"]\n    2\n    ```", "```java\n    user=> (+ 1 2)\n    ```", "```java\n    3\n    ```", "```java\n    user=> (+ 1 2 3)\n    6\n    ```", "```java\n    user=> (- 3 2)\n    1\n    user=> (* 3 4 1)\n    12\n    user=> (/ 9 3)\n    3\n    ```", "```java\n    user=> (println \"Would you like to dance?\")\n    Would you like to dance?\n    nil\n    ```", "```java\n    user=> (println (+ 1 2))\n    3\n    nil\n    ```", "```java\n    user=> (* 2 (+ 1 2))\n    6\n    ```", "```java\n    user=> (System/exit 0)\n    ```", "```java\n    user=> (inc 10)\n    11\n    ```", "```java\n    user=> *1\n    11\n    ```", "```java\n    user=> (inc 10)\n    11\n    user=> *1\n    11\n    user=> (inc *1)\n    12\n    user=> (inc *1)\n    13\n    user=> (inc *2)\n    13\n    user=> (inc *1)\n    14\n    ```", "```java\n    user=> (/ 1 0)\n    Execution error (ArithmeticException) at user/eval71 (REPL:1).\n    Divide by zero\n    ```", "```java\n    user=> *e\n    #error {\n     :cause \"Divide by zero\"\n     :via\n     [{:type java.lang.ArithmeticException\n       :message \"Divide by zero\"\n       :at [clojure.lang.Numbers divide \"Numbers.java\" 188]}]\n     :trace\n     [[clojure.lang.Numbers divide \"Numbers.java\" 188]\n      [clojure.lang.Numbers divide \"Numbers.java\" 3901]\n      [user$eval1 invokeStatic \"NO_SOURCE_FILE\" 1]\n      [user$eval1 invoke \"NO_SOURCE_FILE\" 1]\n      [clojure.lang.Compiler eval \"Compiler.java\" 7177]\n      [clojure.lang.Compiler eval \"Compiler.java\" 7132]\n      [clojure.core$eval invokeStatic \"core.clj\" 3214]\n      [clojure.core$eval invoke \"core.clj\" 3210]\n      [clojure.main$repl$read_eval_print__9086$fn__9089 invoke \"main.clj\" 437]\n      [clojure.main$repl$read_eval_print__9086 invoke \"main.clj\" 437]\n      [clojure.main$repl$fn__9095 invoke \"main.clj\" 458]\n      [clojure.main$repl invokeStatic \"main.clj\" 458]\n      [clojure.main$repl_opt invokeStatic \"main.clj\" 522]\n      [clojure.main$main invokeStatic \"main.clj\" 667]\n      [clojure.main$main doInvoke \"main.clj\" 616]\n      [clojure.lang.RestFn invoke \"RestFn.java\" 397]\n      [clojure.lang.AFn applyToHelper \"AFn.java\" 152]\n      [clojure.lang.RestFn applyTo \"RestFn.java\" 132]\n      [clojure.lang.Var applyTo \"Var.java\" 705]\n      [clojure.main main \"main.java\" 40]]}\n    ```", "```java\n    user=> (doc str)\n    -------------------------\n    clojure.core/str\n    ([] [x] [x & ys])\n      With no args, returns the empty string. With one arg x, returns\n      x.toString().  (str nil) returns the empty string. With more than\n      one arg, returns the concatenation of the str values of the args.\n    nil\n    ```", "```java\n    user=> (str \"I\" \"will\" \"be\" \"concatenated\") (clojure.core/str \"This\" \" works \" \"too\")\n    \"Iwillbeconcatenated\"\n    \"This works too\"\n    ```", "```java\n    user=> (doc doc)\n    -------------------------\n    clojure.repl/doc\n    ([name])\n    Macro\n      Prints documentation for a var or special form given its name,\n       or for a spec if given a keyword\n    nil\n    ```", "```java\n    user=> (doc clojure.repl)\n    -------------------------\n    clojure.repl\n      Utilities meant to be used interactively at the REPL\n    nil\n    ```", "```java\n    user=> (find-doc \"modulus\")\n    nil\n    ```", "```java\n    user=> (find-doc #\"(?i)modulus\")\n    -------------------------\n    clojure.core/mod\n    ([num div])\n      Modulus of num and div. Truncates toward negative infinity.\n    nil\n    ```", "```java\n    user=> (mod 7 3)\n    1\n    ```", "```java\n    user=> (apropos \"case\")\n    (clojure.core/case clojure.string/lower-case clojure.string/upper-case) \n    user=> (clojure.string/upper-case \"Shout, shout, let it all out\")\n    \"SHOUT, SHOUT, LET IT ALL OUT\"\n    ```", "```java\n    42\n    ```", "```java\nuser=> \"Hello\"\n\"Hello\"\nuser=> 1 2 3\n1\n2\n3\n```", "```java\nuser=> (+ 1 2 3)\n6\n```", "```java\nuser=> ; This is a comment\nuser=> ; This line is not evaluated\n```", "```java\n; (operator operand-1 operand-2 operand-3 …)\n; for example:\nuser=> (* 2 3 4)\n24\n```", "```java\nuser=> (1 2 3)\nExecution error (ClassCastException) at user/eval255 (REPL:1).\njava.lang.Long cannot be cast to clojure.lang.IFn\n```", "```java\nuser=> '(1 2 3)\n(1 2 3)\nuser=> '(\"a\" \"b\" \"c\" \"d\")\n(\"a\" \"b\" \"c\" \"d\")\n```", "```java\n    user=> (if true \"Yes\" \"No\")\n    \"Yes\"\n    ```", "```java\n    user=> (if false (+ 3 4) (rand))\n    0.4833142431072903\n    ```", "```java\n    user=> (doc do)\n    -------------------------\n    do\n      (do exprs*)\n    Special Form\n      Evaluates the expressions in order and returns the value of\n      the last. If no expressions are supplied, returns nil.\n      Please see http://clojure.org/special_forms#do\n      Evaluates the expressions in order and returns the value of\n      the last. If no expressions are supplied, returns nil.\n    nil\n    ```", "```java\n    user=> (do (* 3 4) (/ 8 4) (+ 1 1))\n    2\n    ```", "```java\n    user=> (do (println \"A proof that this is executed\") (println \"And this   too\"))\n    A proof that this is executed\n    And this too\n    nil\n    ```", "```java\n    user=> (if true (do (println \"Calculating a random number...\") (rand)) (+ 1   2))\n    Calculating a random number...\n    0.8340057877906916\n    ```", "```java\n    user=> (if true (do (println \"Calculating a random number...\") (rand)))\n    Calculating a random number...\n    0.5451384920081613\n    user=> (if false (println \"Not going to happen\"))\n    nil\n    ```", "```java\n    user=> (when true (println \"First argument\") (println \"Second argument\")   \"And the last is returned\")\n    First argument\n    Second argument\n    \"And the last is returned\"\n    ```", "```java\n    user=> (def x 10)\n    #'user/x\n    ```", "```java\n    user=> x\n    10\n    ```", "```java\n    user=> (def x 20)\n    #'user/x\n    user=> x\n    20\n    ```", "```java\n    user=> (inc x)\n    21\n    user=> x\n    20\n    ```", "```java\n    user=> x\n    20\n    user=> (do (def x 42))\n    #'user/x\n    user=> x\n    42\n    ```", "```java\n    user=> (let [y 3] (println y) (* 10 y))\n    3\n    30\n    ```", "```java\n    user=> y\n    Syntax error compiling at (REPL:0:0).\n    Unable to resolve symbol: y in this context\n    ```", "```java\n    user=> (let [x 3] (println x))\n    3\n    nil\n    user=> x\n    42\n    ```", "```java\n    user=> (let [x 10 y 20]  (str \"x is \" x \" and y is \" y))\n    \"x is 10 and y is 20\"\n    ```", "```java\n    user=> (def message \"Let's add them all!\")\n    #'user/message\n    user=> (let [x (* 10 3)\n                 y 20\n                 z 100]\n                  (println message)\n                  (+ x y z))\n    Let's add them all!\n    150\n    ```", "```java\n    user=> (fn [])\n    #object[user$eval196$fn__197 0x3f0846c6 \"user$eval196$fn__197@3f0846c6\"]\n    ```", "```java\n    user=> (fn [x] (* x x))\n    #object[user$eval227$fn__228 0x68b6f0d6 \"user$eval227$fn__228@68b6f0d6\"]\n    ```", "```java\n    user=> ((fn [x] (* x x)) 2)\n    4\n    ```", "```java\n    user=> (def square (fn [x] (* x x)))\n    #'user/square\n    ```", "```java\n    user=> (square 2)\n    4\n    user=> (square *1)\n    16\n    user=> (square *1)\n    256\n    ```", "```java\n    user=> (defn square [x] (* x x))\n    #'user/square\n    user=> (square 10)\n    100\n    ```", "```java\n    user=>\n    (defn meditate [s calm]\n      (println \"Clojure Meditate v1.0\")\n      (if calm\n        (clojure.string/capitalize s)\n        (str (clojure.string/upper-case s) \"!\")))\n    ```", "```java\n    user=> (meditate \"in calmness lies true pleasure\" true)\n    Clojure Meditate v1.0\n    \"In calmness lies true pleasure\"\n    user=> (meditate \"in calmness lies true pleasure\" false)\n    Clojure Meditate v1.0\n    \"IN CALMNESS LIES TRUE PLEASURE!\"\n    ```", "```java\n    user=> (meditate \"in calmness lies true pleasure\")\n    Execution error (ArityException) at user/eval365 (REPL:1).\n    Wrong number of args (1) passed to: user/meditate\n    ```", "```java\n    user=>\n    (defn square\n      \"Returns the product of the number `x` with itself\"\n      [x]\n      (* x x))\n    #'user/square\n    ```", "```java\n    user=> (doc square)\n    -------------------------\n    user/square\n    ([x])\n      Returns the product of the number `x` with itself\n    nil\n    ```", "```java\nuser=> (doc co2-estimate)\nuser/co2-estimate\n([year])\n  Returns a (conservative) year's estimate of carbon dioxide parts per million in     the atmosphere\nnil\nuser=> (co2-estimate 2006)\n382\nuser=> (co2-estimate 2020)\n410\nuser=> (co2-estimate 2050)\n470\n```", "```java\n    user=> (if nil \"Truthy\" \"Falsey\")\n    \"Falsey\"\n    user=> (if false \"Truthy\" \"Falsey\")\n    \"Falsey\"\n    ```", "```java\n    user=> (if 0 \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    user=> (if -1 \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    user=> (if '() \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    user=> (if [] \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    user=> (if \"false\" \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    user=> (if \"\" \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    user=> (if \"The truth might not be pure but is simple\" \"Truthy\" \"Falsey\")\n    \"Truthy\"\n    ```", "```java\n    user=> (true? 1)\n    false\n    user=> (if (true? 1) \"Yes\" \"No\")\n    \"No\"\n    user=> (true? \"true\")\n    false\n    user=> (true? true)\n    true\n    user=> (false? nil)\n    false\n    user=> (false? false)\n    true\n    ```", "```java\n    user=> (nil? false)\n    false\n    user=> (nil? nil)\n    true\n    user=> (nil? (println \"Hello\"))\n    Hello\n    true\n    ```", "```java\n    user=> (and \"Hello\")\n    \"Hello\"\n    user=> (and \"Hello\" \"Then\" \"Goodbye\")\n    \"Goodbye\"\n    user=> (and false \"Hello\" \"Goodbye\")\n    false\n    ```", "```java\n    user=> (and (println \"Hello\") (println \"Goodbye\"))\n    Hello\n    nil\n    ```", "```java\n    user=> (or \"Hello\")\n    \"Hello\"\n    user=> (or \"Hello\" \"Then\" \"Goodbye\")\n    \"Hello\"\n    user=> (or false \"Then\" \"Goodbye\")\n    \"Then\"\n    ```", "```java\n    user=> (or true (println \"Hello\"))\n    true\n    ```", "```java\n    user=> (= 1 1)\n    true\n    user=> (= 1 2)\n    false\n    ```", "```java\n    user=> (= 1 1 1)\n    true\n    user=> (= 1 1 1 -1)\n    false\n    ```", "```java\n    user=> (= nil nil)\n    true\n    user=> (= false nil)\n    false\n    user=> (= \"hello\" \"hello\" (clojure.string/reverse \"olleh\"))\n    true\n    user=> (= [1 2 3] [1 2 3])\n    true\n    ```", "```java\n    user=> (= '(1 2 3) [1 2 3])\n    true\n    ```", "```java\n    user=> (= 1)\n    true\n    user=> (= \"I will not reason and compare: my business is to create.\")\n    true\n    ```", "```java\n    user=> (< 1 2)\n    true\n    user=> (< 1 10 100 1000)\n    true\n    user=> (< 1 10 10 100)\n    false\n    user=> (< 3 2 3)\n    false\n    user=> (< -1 0 1)\n    true\n    ```", "```java\n    user=> (<= 1 10 10 100)\n    true\n    user=> (<= 1 1 1)\n    true\n    user=> (<= 1 2 3)\n    true\n    ```", "```java\n    user=> (> 3 2 1)\n    true\n    user=> (> 3 2 2)\n    false\n    user=> (>= 3 2 2)\n    true\n    ```", "```java\n    user=> (not true)\n    false\n    user=> (not nil)\n    true\n    user=> (not (< 1 2))\n    false\n    user=> (not (= 1 1))\n    false\n    ```", "```java\n    let x = 50;\n    if (x >= 1 && x <= 100 || x % 100 == 0) {\n      console.log(\"Valid\");\n    } else {\n      console.log(\"Invalid\");\n    }\n    ```", "```java\n    (let [x 50]\n      (if (or (<= 1 x 100) (= 0 (mod x 100)))\n        (println \"Valid\")\n        (println \"Invalid\")))\n    ```", "```java\n    let x = 50;\n    console.log(x >= 0 && x <= 100 || x % 100 == 0 ? \"Valid\" : \"Invalid\");\n    ```", "```java\n    (let [x 50]\n      (println (if (or (<= 1 x 100) (= 0 (mod x 100))) \"Valid\" \"Invalid\")))\n    ```", "```java\n    user=> (meditate \"what we do now echoes in eternity\" 1)\n    Clojure Meditate v2.0\n    \"WHAT WE DO NOW ECHOES IN ETERNITY, I TELL YA!\"\n    user=> (meditate \"what we do now echoes in eternity\" 6)\n    Clojure Meditate v2.0\n    \"What we do now echoes in eternity\"\n    user=> (meditate \"what we do now echoes in eternity\" 10)\n    Clojure Meditate v2.0\n    \"ytinrete ni seohce won od ew tahw\"\n    user=> (meditate \"what we do now echoes in eternity\" 50)\n    Clojure Meditate v2.0\n    nil\n    ```"]