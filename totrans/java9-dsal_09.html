<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Advanced General Purpose Data Structures" id="1IHDQ1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Advanced General Purpose Data Structures</h1></div></div></div><p class="calibre8">In this chapter, we will take a look at some more interesting data structures that are commonly used. We will start with the concept of a priority queue. We will see some efficient implementations of a priority queue. In short, we will cover the following topics in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Priority queue ADT</li><li class="listitem">Heap</li><li class="listitem">Binomial forest</li><li class="listitem">Sorting using a priority queue and heap</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Advanced General Purpose Data Structures" id="1IHDQ1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Priority queue ADT"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec46" class="calibre1"/>Priority queue ADT</h1></div></div></div><p class="calibre8">A priority queue is like a <a id="id421" class="calibre1"/>queue in that you can enqueue and dequeue elements. However, the element that gets dequeued is the one with the minimum value of a feature, called its priority. We will use a comparator to compare elements and learn which one has the lowest priority. We will use the following interface for the priority queue:</p><div class="informalexample"><pre class="programlisting">public interface PriorityQueue&lt;E&gt; {
    E checkMinimum();
    E dequeueMinimum();
    void enqueue(E value);
}</pre></div><p class="calibre8">We require the following set of behaviors from the methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">checkMinimum</code>: This method must return the next value to be dequeued without dequeuing it. If the queue is empty, it must return null.</li><li class="listitem"><code class="email">dequeueMinimum</code>: This must dequeue the element with the minimum priority and return it. It should return null when the queue is empty.</li><li class="listitem"><code class="email">enqueue</code>: This should insert a new element in the priority queue.</li></ul></div><p class="calibre8">We would also like to do these operations as efficiently as possible. We will see two different ways to implement it.</p></div></div>

<div class="book" title="Heap"><div class="book" id="1JFUC2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec47" class="calibre1"/>Heap</h1></div></div></div><p class="calibre8">A heap is a balanced <a id="id422" class="calibre1"/>binary tree that follows just two constraints:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The value in any node is less than the value in either of the children. This property is also called the heap property.</li><li class="listitem">The tree is as balanced as possible—in the sense that any level is completely filled before a single node is inserted in the next level.</li></ul></div><p class="calibre8">The following figure shows a sample heap:</p><div class="mediaobject"><img src="../images/00062.jpeg" alt="Heap" class="calibre9"/><div class="caption"><p class="calibre15">Figure 1. A sample heap</p></div></div><p class="calibre10"> </p><p class="calibre8">It would not be really clear until we actually discuss how to insert elements and remove the least element. So let's jump into it.</p></div>

<div class="book" title="Heap">
<div class="book" title="Insertion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec61" class="calibre1"/>Insertion</h2></div></div></div><p class="calibre8">The first step of insertion <a id="id423" class="calibre1"/>is to insert the element in the next available position. The next available position is either another position in the same level or the first position in the next level; of course, this applies when there is no vacant position in the existing level.</p><p class="calibre8">The second step is to iteratively compare the element with its parent and keep switching until the element is bigger than the parent, thus restoring the constraints. The following figure shows the steps of an insertion:</p><div class="mediaobject"><img src="../images/00063.jpeg" alt="Insertion" class="calibre9"/><div class="caption"><p class="calibre15">Figure 2. Heap insertion</p></div></div><p class="calibre10"> </p><p class="calibre8">The gray box represents the current node, and the yellow box represents the parent node, whose value is larger than the current node. First, the new element is inserted in the next available spot. It must be swapped until the constraint is satisfied. The parent is <span class="strong"><strong class="calibre2">6</strong></span>, which is bigger than <span class="strong"><strong class="calibre2">2</strong></span>, so it is swapped. If the parent is <span class="strong"><strong class="calibre2">3</strong></span>, which is also larger than <span class="strong"><strong class="calibre2">2</strong></span>, it is swapped. If the parent is <span class="strong"><strong class="calibre2">1</strong></span>, which is less than <span class="strong"><strong class="calibre2">2</strong></span>, we stop and the insertion is complete.</p></div></div>

<div class="book" title="Heap">
<div class="book" title="Removal of minimum elements"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec62" class="calibre1"/>Removal of minimum elements</h2></div></div></div><p class="calibre8">The constraint that the <a id="id424" class="calibre1"/>parent is always less than or equal to the children guarantees that the root is the element with the least value. This means the removal of the least element leads only to the removal of the top element. However, the empty space of the root must be filled, and elements can only be deleted from the last level to maintain the constraint <span class="strong"><strong class="calibre2">2</strong></span>. To ensure this, the last element is first copied to the root and then removed. We must now iteratively move the new root element downward until the constraint <span class="strong"><strong class="calibre2">1</strong></span> is satisfied. The following figure shows an example of a delete operation:</p><div class="mediaobject"><img src="../images/00064.jpeg" alt="Removal of minimum elements" class="calibre9"/><div class="caption"><p class="calibre15">Heap deletion</p></div></div><p class="calibre10"> </p><p class="calibre8">There is one question though, since any parent can have two children: which one should we compare and swap with? The answer is simple. We need the parent to be less than both the children; this means we must compare and swap with the minimum value of the children.</p></div></div>

<div class="book" title="Heap">
<div class="book" title="Analysis of complexity"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec63" class="calibre1"/>Analysis of complexity</h2></div></div></div><p class="calibre8">First, let's check out the <a id="id425" class="calibre1"/>height of a heap for a given number of nodes. The first layer contains just the root. The second layer contains a maximum of two nodes. The third layer contains four. Indeed, if any layer contains m elements, the next layer will contain, at the maximum, the children of all these <span class="strong"><em class="calibre12">m</em></span> elements. Since each node can have two children, the maximum number of elements in the next layer will be <span class="strong"><em class="calibre12">2m</em></span>. This shows that the number of elements in layer l is <span class="strong"><em class="calibre12">2</em></span>
<sup class="calibre14">l-1</sup>. So, a full heap of height <span class="strong"><em class="calibre12">h</em></span> will have total <span class="strong"><em class="calibre12">1+2+4+...+ 2</em></span>
<sup class="calibre14">h-1</sup><span class="strong"><em class="calibre12"> = 2</em></span>
<sup class="calibre14">h</sup><span class="strong"><em class="calibre12">-1</em></span> nodes. Therefore, a heap of height <span class="strong"><em class="calibre12">h</em></span> can have maximum <span class="strong"><em class="calibre12">2</em></span>
<span class="strong"><em class="calibre12">h+1</em></span>
<span class="strong"><em class="calibre12">-1</em></span> nodes. What is the minimum number of nodes in a heap of height <span class="strong"><em class="calibre12">h</em></span>. Well, since only the last level can have unfilled positions, the heap must be full, except the last layer. The last layer can have one node minimum. So, the minimum number of nodes in a heap of height <span class="strong"><em class="calibre12">h</em></span> is <span class="strong"><em class="calibre12">(2</em></span>
<sup class="calibre14">h-1</sup><span class="strong"><em class="calibre12"> -1) + 1 = 2</em></span>
<sup class="calibre14">h-1</sup>. Hence, if the number of nodes is <span class="strong"><em class="calibre12">n</em></span>, then we have this:</p><div class="informalexample"><pre class="programlisting">2<sup class="calibre14">h-1</sup> ≤ n ≤ 2<sup class="calibre14">h</sup> –1
=&gt;  h-1 ≤ lg n ≤ lg(2<sup class="calibre14">h</sup> –1) &lt;lg( 2<sup class="calibre14">h</sup>)
=&gt; h-1 ≤ lg n &lt; h</pre></div><p class="calibre8">We also have the following:</p><div class="informalexample"><pre class="programlisting">2<sup class="calibre14">h-1</sup> ≤ n ≤ 2<sup class="calibre14">h</sup> –1
=&gt; 2<sup class="calibre14">h</sup>≤ n ≤ 2<sup class="calibre14">h+1</sup> –1
=&gt;h ≤ lg (2n)&lt; h+1</pre></div><p class="calibre8">Combining the preceding two expressions, we get this:</p><div class="informalexample"><pre class="programlisting">lg n &lt; h ≤ lg (2n)
=&gt; h = θ(lg n)</pre></div><p class="calibre8">Now, let's assume that adding a new element to the end of the heap is a constant time operation or <span class="strong"><em class="calibre12">θ(lg n)</em></span>. We will see that this operation can be made this efficient. Now we deal with the complexity of a trickle up operation. Since in each compare-and-swap operation, we only compare with the parent and never backtrack, the maximum number of swaps that can happen in a trickle up operation equals the height of the heap <span class="strong"><em class="calibre12">h</em></span>. Hence, the insertion is <span class="strong"><em class="calibre12">O(lg n)</em></span>. This means that the insert operation itself is <span class="strong"><em class="calibre12">O(lg n)</em></span>.</p><p class="calibre8">Similarly, for the trickle down operation, we can only do as many swaps as the height of the heap. So trickling down is also <span class="strong"><em class="calibre12">O(lg n)</em></span>. Now if we assume that removing the root node and copying the last element to the root is at the maximum <span class="strong"><em class="calibre12">O(lg n)</em></span>, we can conclude that the delete operation is also <span class="strong"><em class="calibre12">O(lg n)</em></span>.</p></div></div>

<div class="book" title="Heap">
<div class="book" title="Serialized representation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec64" class="calibre1"/>Serialized representation</h2></div></div></div><p class="calibre8">A heap can be <a id="id426" class="calibre1"/>represented as a list of numbers without any blanks in the middle. The trick is to list the elements in order after each level. Positions from 1 through <span class="strong"><em class="calibre12">n</em></span> for an <span class="strong"><em class="calibre12">n</em></span> element heap adopt the following conventions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">For any element at index <span class="strong"><em class="calibre12">j</em></span>, the parent is at index <span class="strong"><em class="calibre12">j/2</em></span>, where '<span class="strong"><em class="calibre12">/</em></span>' represents an integer division. This means divide <span class="strong"><em class="calibre12">j</em></span> by two and ignore the remainder if any.</li><li class="listitem">For any element at index <span class="strong"><em class="calibre12">j</em></span>, the children are <span class="strong"><em class="calibre12">j*2</em></span> and <span class="strong"><em class="calibre12">j*2+1</em></span>. One can verify that this is the same as the first formula written the other way round.</li></ul></div><p class="calibre8">The representation of <a id="id427" class="calibre1"/>our example tree is shown in the following figure. We have just flattened the process of writing a tree one entire level before another. We retained the tree edges, and one can see that the parent-child relationships work as described previously:</p><div class="mediaobject"><img src="../images/00065.jpeg" alt="Serialized representation" class="calibre9"/><div class="caption"><p class="calibre15">Array representation of a heap</p></div></div><p class="calibre10"> </p><p class="calibre8">With the knowledge of the array-based storage function of a heap, we can proceed to implement our heap.</p></div></div>

<div class="book" title="Heap">
<div class="book" title="Array-backed heap"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec65" class="calibre1"/>Array-backed heap</h2></div></div></div><p class="calibre8">An array-backed <a id="id428" class="calibre1"/>heap is a fixed-sized heap implementation. We <a id="id429" class="calibre1"/>start with a partial implementation class:</p><div class="informalexample"><pre class="programlisting">public class ArrayHeap&lt;E&gt; implements PriorityQueue&lt;E&gt;{

    protected E[] store;

    protected Comparator&lt;E&gt; comparator;
    int numElements = 0;
    public ArrayHeap(int size, Comparator&lt;E&gt; comparator){
        store = (E[]) new Object[size];
        this.comparator = comparator;
}</pre></div><p class="calibre8">Given any index of the array (starting from <code class="email">0</code>), find the index of the parent element. It involves converting the index to <code class="email">1</code> based form (so add <code class="email">1</code>), dividing by <code class="email">2</code>, and then converting it back to <code class="email">0</code> (so subtract <code class="email">1</code>):</p><div class="informalexample"><pre class="programlisting">    protected int parentIndex(int nodeIndex){
        return ((nodeIndex+1)/2)-1;
    }</pre></div><p class="calibre8">Find the index of the left child using this:</p><div class="informalexample"><pre class="programlisting">    protected int leftChildIndex(int nodeIndex){
        return (nodeIndex+1)*2 -1;
    }</pre></div><p class="calibre8">Swap the elements in the two indexes provided using this:</p><div class="informalexample"><pre class="programlisting">    protected void swap(int index1, int index2){
        E temp = store[index1];
        store[index1] = store[index2];
        store[index2] = temp;
    }
    …
}</pre></div><p class="calibre8">To implement the insertion, first implement a method that would trickle the value up until constraint <code class="email">1</code> is satisfied. We compare the current node with the parent, and if the value of the parent is larger, then do a swap. We keep moving upwards recursively:</p><div class="informalexample"><pre class="programlisting">    protected void trickleUp(int position){
        int parentIndex = parentIndex(position);

        if(position&gt; 0 &amp;&amp; comparator.compare(store[parentIndex], store[position])&gt;0){
            swap(position, parentIndex);
            trickleUp(parentIndex);
        }
    }</pre></div><p class="calibre8">Now we can implement the insertion. The new element is always added to the end of the current list. A check is done to ensure that when the heap is full, an appropriate exception is thrown:</p><div class="informalexample"><pre class="programlisting">    public void insert(E value){
        if(numElements == store.length){
            throw new NoSpaceException("Insertion in a full heap");
        }
        store[numElements] = value;
        numElements++;
        trickleUp(numElements-1);
    }</pre></div><p class="calibre8">Similarly, for deletion, we <a id="id430" class="calibre1"/>first implement a trickle down method that <a id="id431" class="calibre1"/>compares an element with its children and makes appropriate swaps until constraint 1 is restored. If the right child exists, the left child must also exist. This happens because of the balanced nature of a heap. In this case, we must compare only with a minimum of two children and swap them if it is necessary. When the left child exists but the right child does not, we only need to compare it with one element:</p><div class="informalexample"><pre class="programlisting">    protected void trickleDown(int position){
        int leftChild = leftChildIndex(position);
        int rightChild = leftChild+1;
        if(rightChild&lt;numElements) {
            if (comparator.compare(store[leftChild], store[rightChild]) &lt; 0) {
                if (comparator.compare(store[leftChild], store[position]) &lt; 0) {
                    swap(position, leftChild);
                    trickleDown(leftChild);
                }
            } else {
                if (comparator.compare(store[rightChild], store[position]) &lt; 0) {
                    swap(position, rightChild);
                    trickleDown(rightChild);
                }
            }
        }else if(leftChild&lt;numElements){
            if (comparator.compare(store[leftChild], store[position]) &lt; 0) {
                  swap(position, leftChild);
                  trickleDown(leftChild);
            }
        }
    }</pre></div><p class="calibre8">With the <code class="email">trickleDown</code> method available, removing the minimum element is simple. We first save the current root as the minimum element, then copy the last element to the root position. We then call the <code class="email">trickleDown</code> method to restore constraint 1:</p><div class="informalexample"><pre class="programlisting">    public E removeMin(){
        if(numElements==0){
            return null;
        }else{
            E value  = store[0];
            store[0] = store[numElements-1];
            numElements--;
            trickleDown(0);
            return value;
        }
    }</pre></div><p class="calibre8">Now we only have to <a id="id432" class="calibre1"/>use it as an implementation of the priority queue. So we <a id="id433" class="calibre1"/>implement the relevant methods using our <code class="email">insert</code> and <code class="email">removemin</code>:</p><div class="informalexample"><pre class="programlisting">@Override
public E checkMinimum() {
if(numElements==0){
return null;
}else{
return store[0];
}
}

    @Override
    public E dequeueMinimum() {
        return removeMin();
    }

    @Override
    public void enqueue(E value) {
        insert(value);
    }</pre></div><p class="calibre8">This completes our array-based heap implementation. It has the same problem as our array-based queue implementation, that is, we need to know its maximum size beforehand. Next, we will <a id="id434" class="calibre1"/>have an implementation of a heap that has an <a id="id435" class="calibre1"/>implementation in the form of a linked binary tree.</p></div></div>

<div class="book" title="Linked heap"><div class="book" id="1KEEU2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec48" class="calibre1"/>Linked heap</h1></div></div></div><p class="calibre8">A linked heap is an <a id="id436" class="calibre1"/>actual binary tree where every node holds references to its children. We <a id="id437" class="calibre1"/>first create a skeleton structure for our heap:</p><div class="informalexample"><pre class="programlisting">public class LinkedHeap&lt;E&gt; implements PriorityQueue&lt;E&gt;{

    protected static class Node&lt;E&gt;{
        protected E value;
        protected Node&lt;E&gt; left;
        protected Node&lt;E&gt; right;
        protected Node&lt;E&gt; parent;
        public Node(E value, Node&lt;E&gt; parent){
            this.value = value;
            this.parent = parent;
        }
    }
    …
}</pre></div><p class="calibre8">To keep track of the next position, each position is given a number, just like we did in our array-based representation. We have the same calculation for the index of the parent and children. But, in this case, looking up the value at a particular index requires a traversal from the root to that node. We create a method to do this. Note that since we are not using an array, the position starts from 1. We start by finding the parent node recursively. The parent node is of course the node at the position that is half the value of the children. The remainder, when divided by 2, is the bit that tells us whether the node is to the left or right of the parent. We return the node accordingly:</p><div class="informalexample"><pre class="programlisting">    protected Node&lt;E&gt; findNodeAtPostion(int position){
        if(position == 1){
            return root;
        }else{
            int side = position % 2;
            int parentPosition = position / 2;
            Node&lt;E&gt; parent = findNodeAtPostion(parentPosition);
            switch (side){
                case 0:
                    return parent.left;
                case 1:
                    return parent.right;
            }
        }
        return null;
    }</pre></div><p class="calibre8">Next, we turn to swapping. In the case of an array-based heap, we could swap the values between any two indexes. However, this general implementation would require multiple traversals in this case. We <a id="id438" class="calibre1"/>only need to swap the values between a node and its <a id="id439" class="calibre1"/>parent. The <code class="email">swapWithParent</code> takes the parent node as an argument. Another argument is to know whether the current node is the left or right child of the parent and switch references appropriately:</p><div class="informalexample"><pre class="programlisting">    protected void swapWithParent(Node&lt;E&gt; parent, boolean left){
        Node&lt;E&gt; node = left? parent.left:parent.right;
        Node&lt;E&gt; leftChild = node.left;
        Node&lt;E&gt; rightChild = node.right;
        Node&lt;E&gt; sibling = left? parent.right:parent.left;
        Node&lt;E&gt; grandParent = parent.parent;
        parent.left = leftChild;
        if(leftChild!=null){
            leftChild.parent = parent;
        }
        parent.right = rightChild;
        if(rightChild!=null){
            rightChild.parent = parent;
        }
        parent.parent = node;
        if(left){
            node.right = sibling;
            node.left = parent;
        }else{
            node.left = sibling;
            node.right = parent;
        }
        node.parent = grandParent;
        if(sibling!=null)
            sibling.parent = node;

        if(parent == root){
            root = node;
        }else{
            boolean parentLeft = grandParent.left==parent;
            if(parentLeft){
                grandParent.left = node;
            }else{
                grandParent.right = node;
            }
        }
    }</pre></div></div>

<div class="book" title="Linked heap">
<div class="book" title="Insertion"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec66" class="calibre1"/>Insertion</h2></div></div></div><p class="calibre8">Insertion involves inserting <a id="id440" class="calibre1"/>a new element at the end first and then trickling it in the upward direction. First, we create a trickle up method, similar to the one in the <code class="email">ArrayHeap</code> class:</p><div class="informalexample"><pre class="programlisting">protected void trickleUp(Node&lt;E&gt; node){
    if(node==root){
        return;
    }else if(comparator.compare(node.value, node.parent.value)&lt;0){
        swapWithParent(node.parent, node.parent.left == node);
        trickleUp(node);
    }
}</pre></div><p class="calibre8">Now, we implement the insert method. If the tree is empty, we just have to add a root. Otherwise, the position of the new element is <span class="strong"><em class="calibre12">(numElements+1)</em></span>. In this case, it's parent must be <span class="strong"><em class="calibre12">((numElements+1)/2)</em></span>. Whether it should be the left or right child of its parent is determined by the value of <span class="strong"><em class="calibre12">( (numElements+1)%2)</em></span>. A new node is then created and added to the parent as a child. Finally, <code class="email">numElements</code> is incremented to keep track of the number of elements:</p><div class="informalexample"><pre class="programlisting">    public void insert(E value){
        if(root==null){
            root = new Node&lt;&gt;(value, null);
        }else{
            Node&lt;E&gt; parent = findNodeAtPostion((numElements+1)/2);
            int side = (numElements+1)%2;
            Node&lt;E&gt; newNode = new Node&lt;&gt;(value, parent);
            switch (side){
                case 0:
                    parent.left = newNode;
                    break;
                case 1:
                    parent.right = newNode;
                    break;
            }
            trickleUp(newNode);
        }
        numElements++;
    }</pre></div></div></div>

<div class="book" title="Linked heap">
<div class="book" title="Removal of the minimal elements"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec67" class="calibre1"/>Removal of the minimal elements</h2></div></div></div><p class="calibre8">Similar to the array-based <a id="id441" class="calibre1"/>heap, we need to implement a trickle down method. Since the left child must exist if the right child does, if the left child is null, the node does not have any child. But, if the right child is null and the left child is not, we only need to compare the current node's value with that of the left child. Otherwise, compare and swap with the child that has the minimum value:</p><div class="informalexample"><pre class="programlisting">    protected void trickleDown(Node&lt;E&gt; node){
        if(node==null){
            return;
        }
        if(node.left == null){
            return;
        }else if(node.right == null){
            if(comparator.compare(node.left.value, node.value)&lt;0){
                swapWithParent(node, true);
                trickleDown(node);
            }
        }else{
            if(comparator.compare(node.left.value, node.right.value)&lt;0){
                if(comparator.compare(node.left.value, node.value)&lt;0){
                    swapWithParent(node, true);
                    trickleDown(node);
                }
            }else{
                if(comparator.compare(node.right.value, node.value)&lt;0){
                    swapWithParent(node, false);
                    trickleDown(node);
                }
            }
        }

    }</pre></div><p class="calibre8">Now we can implement the method to remove the minimum element. If the root is null, it means the queue is <a id="id442" class="calibre1"/>empty. If the last element is the root, there is only one element and we just remove and return it. Otherwise, we copy the value of the root to a temporary variable, then copy the value of the last element to the root, and finally, trickle down the root:</p><div class="informalexample"><pre class="programlisting">    public E removeMin(){
        if(root==null){
            return null;
        }
        Node&lt;E&gt; lastElement = findNodeAtPostion(numElements);
        if(lastElement==root){
            root = null;
            numElements--;
            return lastElement.value;
        }
        E value = root.value;
        root.value = lastElement.value;
        Node&lt;E&gt; parent = lastElement.parent;
        if(parent.left==lastElement){
            parent.left = null;
        }else{
            parent.right=null;
        }
        numElements--;
        trickleDown(root);
        return value;
    }</pre></div><p class="calibre8">Finally, we implement the methods required to make it a valid priority queue:</p><div class="informalexample"><pre class="programlisting">    @Override
    public E checkMinimum() {
        return root==null? null : root.value;
    }

    @Override
    public E dequeueMinimum() {
        return removeMin();
    }

    @Override
    public void enqueue(E value) {
        insert(value);
    }</pre></div><p class="calibre8">This completes our <a id="id443" class="calibre1"/>priority queue implementation using heaps. We will now introduce a different way of implementing a priority queue. It is called a binomial forest, which comprises our next section.</p></div></div>

<div class="book" title="Linked heap">
<div class="book" title="Complexity of operations in ArrayHeap and LinkedHeap"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec68" class="calibre1"/>Complexity of operations in ArrayHeap and LinkedHeap</h2></div></div></div><p class="calibre8">We have already <a id="id444" class="calibre1"/>seen that if we can append an element to the end of a heap in at most <span class="strong"><em class="calibre12">O(lg n)</em></span>, where n is the number of elements already in the heap, we can perform both insertion and removal of the minimum element <span class="strong"><em class="calibre12">θ(lg n)</em></span> times. In the case of <code class="email">ArrayHeap</code>, insertion of a new element implies just setting the value of an element in an array at a known index. This is a constant time operation. So, in <code class="email">ArrayHeap</code>, both the insertion and removal of minimum element are <span class="strong"><em class="calibre12">θ(lg n)</em></span>. Checking the minimum element is just the check the value at index zero of the array and hence is constant time.</p><p class="calibre8">In the case of <code class="email">LinkedHeap</code>, insertion of a new element at the end involves traversing the tree to the end position. Since the height of the tree is <span class="strong"><em class="calibre12">θ(lg n)</em></span>, this operation is also <span class="strong"><em class="calibre12">θ(lg n)</em></span>. This means, the insertion and deletion operation in <code class="email">LinkedHeap</code> is also <span class="strong"><em class="calibre12">θ(lg n)</em></span>. Checking the minimum element means just checking the value at the root, and this operation is constant time.</p></div></div>

<div class="book" title="Binomial forest"><div class="book" id="1LCVG2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec49" class="calibre1"/>Binomial forest</h1></div></div></div><p class="calibre8">A binomial forest is a very interesting data structure. But, to discuss it, we need to first start with a binomial tree. A <a id="id445" class="calibre1"/>binomial tree is a tree in which a combination of two smaller binomial trees of the same size are combined in a particular way:</p><div class="mediaobject"><img src="../images/00066.jpeg" alt="Binomial forest" class="calibre9"/><div class="caption"><p class="calibre15">Binomial tree</p></div></div><p class="calibre10"> </p><p class="calibre8">The preceding figure shows how binomial trees combine to create larger binomial trees. In the first row, two binomial <a id="id446" class="calibre1"/>trees of height 1 combine to create a new binomial tree of height 2. In the second row, two binomial trees of height 2 combine to create a new binomial tree of height 3. In the final example, two binomial trees of height 3 combine to create a binomial tree of height 4, and it continues. The two trees that are combined together are not treated symmetrically. Instead, the root of one becomes the parent of the other. The next figure shows one more step in the sequence and then shows a different way to look at a binomial tree. In the last row, I have highlighted the subtrees differently. Notice how:</p><div class="mediaobject"><img src="../images/00067.jpeg" alt="Binomial forest" class="calibre9"/><div class="caption"><p class="calibre15">Figure 6. The other way of thinking about a binomial tree</p></div></div><p class="calibre10"> </p><p class="calibre8">Each subtree is a binomial tree. Not only that, the first subtree is a binomial tree of height 1, the second one of height 2, third one of height 3, and so on. So, another way of thinking about a binomial tree is <a id="id447" class="calibre1"/>that it is a root and a sequence of subtrees that are binomial trees of consecutive heights up to one less than the height of the entire tree. Both these views are required in our discussion. The first view is needed when analyzing the idea and the second when implementing it.</p></div>

<div class="book" title="Binomial forest">
<div class="book" title="Why call it a binomial tree?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec69" class="calibre1"/>Why call it a binomial tree?</h2></div></div></div><p class="calibre8">Remember the choose <a id="id448" class="calibre1"/>function we discussed in <a class="calibre1" title="Chapter 4. Detour – Functional Programming" href="part0028_split_000.html#QMFO2-eeeded97b5e248ac807bb1bec4d7c800">Chapter 4</a>, <span class="strong"><em class="calibre12">Detour - Functional Programming</em></span>? There, I pointed out that it is also called the binomial coefficient. Let's see how it is related to a binomial tree. Suppose we have a binomial tree of height h and we want to find out the number of nodes at level l. Let's assume that for a tree of height h, the number of nodes is <span class="strong"><em class="calibre12">f(t,r)</em></span>, where <span class="strong"><em class="calibre12">t=h-1</em></span> and <span class="strong"><em class="calibre12">r = l-1</em></span>. The reason for taking a variable that is one less than the height and level will become clearer a little later. Basically, <span class="strong"><em class="calibre12">t</em></span> is the height of the tree that starts from <span class="strong"><em class="calibre12">0</em></span> instead of <span class="strong"><em class="calibre12">1</em></span>, and <span class="strong"><em class="calibre12">r</em></span> is the level that starts from zero. Now this tree is obviously a tree of only one element or it is made up of two trees of height <span class="strong"><em class="calibre12">h-1 = t</em></span>: </p><div class="mediaobject"><img src="../images/00068.jpeg" alt="Why call it a binomial tree?" class="calibre9"/><div class="caption"><p class="calibre15">Figure 7. The rationale for naming it a binomial tree</p></div></div><p class="calibre10"> </p><p class="calibre8">We will call these two subtrees this: red subtree and green subtree. This is because they are colored this way in the preceding figure. The levels are highlighted using dashed lines. It is clear from the picture that the nodes at the level <span class="strong"><em class="calibre12">r</em></span> in the complete tree is either at level <span class="strong"><em class="calibre12">r</em></span> in the red tree or at level <span class="strong"><em class="calibre12">r-1</em></span> in the green tree. Both the red and green trees are trees of height <span class="strong"><em class="calibre12">h-1</em></span>. This means the following: <span class="strong"><em class="calibre12">f(t,r) = f(t-1,r) + f(t-1,r-1)</em></span>. This equation is the same as what we have for the choose function we have already discussed. The only thing we have to check is the boundary conditions. The top level (that is <span class="strong"><em class="calibre12">t=0</em></span>) always has only one node, so <span class="strong"><em class="calibre12">f(t,0) = 1</em></span>. We also know that the number of levels in the tree has to be less than or equal to the height of the tree, so we have <span class="strong"><em class="calibre12">f(t,r) = 0</em></span> if <span class="strong"><em class="calibre12">t  &lt;r</em></span>. So, <span class="strong"><em class="calibre12">f(t,t) = f(t-1,t) + f(t-1,t-1) = 0  + f(t-1,t-1) = f(t-1,t-1)</em></span> for any <span class="strong"><em class="calibre12">t</em></span>. In the same way, <span class="strong"><em class="calibre12">f(t-1,t-1) = f(t-2,t-2) = f(t-3,t-3) = … = f(0,0) = 1</em></span> (because <span class="strong"><em class="calibre12">f(t,0) = 1</em></span>). Therefore, all the conditions of the <code class="email">choose</code> function are satisfied; hence we can see <span class="strong"><em class="calibre12">f(t,r) = choose(t,r) = choose(h-1, l-1)</em></span>. Since the <span class="strong"><em class="calibre12">choose</em></span> function is also called <a id="id449" class="calibre1"/>the binomial coefficient, this gives the binomial tree its name.</p></div></div>

<div class="book" title="Binomial forest">
<div class="book" title="Number of nodes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec70" class="calibre1"/>Number of nodes</h2></div></div></div><p class="calibre8">What is the number of <a id="id450" class="calibre1"/>nodes n in a binomial tree of height <span class="strong"><em class="calibre12">h</em></span>? When <span class="strong"><em class="calibre12">h=1,</em></span> we only have one node. A tree of height 2 is made up of two trees of height 1, a tree of height 3 is made up of two trees of height 2, and so on. So, for the increment of 1 in height, the number of nodes must be twice as much as the original number. That is, when <span class="strong"><em class="calibre12">h=1, n=1; h=2, n=2; h=3, n=4,...</em></span> In general, this should be the case: <span class="strong"><em class="calibre12">n = 2</em></span>
<sup class="calibre14">h-1</sup><span class="strong"><em class="calibre12">= 2</em></span>
<sup class="calibre14">t</sup>. Here <span class="strong"><em class="calibre12">t</em></span> is the height starting from zero.</p><p class="calibre8">Notice also that we can say that the number of nodes <span class="strong"><em class="calibre12">n</em></span> in a tree is the sum of the number of nodes in each level, which is <span class="strong"><em class="calibre12">choose(t, r)</em></span>, where <span class="strong"><em class="calibre12">r</em></span> is the level starting from <span class="strong"><em class="calibre12">0</em></span> to <span class="strong"><em class="calibre12">t</em></span>. The two formulas must be equal, so the sum <span class="strong"><em class="calibre12">choose(t, 0) + choose(t, 1) + choose(t, 2) + … + choose(t, t) </em></span>equals<span class="strong"><em class="calibre12"> 2</em></span>
<sup class="calibre14">t</sup>. This is a proof of this relationship. There are other proofs as well, but this is a valid proof too.</p></div></div>

<div class="book" title="Binomial forest">
<div class="book" title="The heap property"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec71" class="calibre1"/>The heap property</h2></div></div></div><p class="calibre8">Of course, with only <a id="id451" class="calibre1"/>this structure, we have no way of making sure of having some easy way of figuring out the minimum element. So, we also enforce the heap property on a binomial tree:</p><div class="mediaobject"><img src="../images/00069.jpeg" alt="The heap property" class="calibre9"/><div class="caption"><p class="calibre15">Figure 8. Preserving heap property while merging.</p></div></div><p class="calibre10"> </p><p class="calibre8">This is the property: the value of any node is smaller than the value of each of its children. When merging <a id="id452" class="calibre1"/>two trees to make one, the only thing we need to do to preserve the heap property is to use the heap with the lesser value at its top node as the top subtree and the one with the higher value at its top node as the subordinate subtree. This is shown in the preceding figure. The red tree happens to have a higher value in the root node than that of the green tree. Hence, the red tree must be the <a id="id453" class="calibre1"/>subordinate tree. The heap property ensures that the root of any binomial tree holds the minimum element.</p></div></div>

<div class="book" title="Binomial forest">
<div class="book" title="Binomial forest"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec72" class="calibre1"/>Binomial forest</h2></div></div></div><p class="calibre8">So how do we make a <a id="id454" class="calibre1"/>queue out of this? Firstly, note that any tree will have nodes with at least the power of 2. But, in a queue, we want an arbitrary number of elements. So we store these elements in more than one tree. Any number can be expressed as the sum of the power of 2 because any number can be expressed in binary form. Suppose we need to store 20 nodes. The number 20 in binary is 10100. So we need two binomial trees: one with height 5 and 16 nodes and one with height 3 and four nodes. A queue is built using a collection of binomial trees to store the nodes. Hence it is called a binomial forest.</p><p class="calibre8">Before we discuss how to insert new elements and remove the minimum element, we need to understand how to merge two binomial forests. We have already seen that the numbers of elements are represented according to binary form. Just write the number in binary form, and if 1 exists, it means there is a tree of height that is equal to one plus its position from right to left. When we merge two forests, the number of elements of the merged forest is the sum of the number of elements in the forests that need to be merged. This means the result will have trees of sizes where the binary representation of the sum will have the number 1. We can find this binary representation by performing a binary addition of the binary representations of the node's source number. For example, let's merge two forests: one with 12 elements and one with 10 elements. Their binary representations will be 1100 and 1010, respectively. If we do a binary addition, we have 1100 + 1010 = 10110. This means the original trees had trees of heights 3, 5 and 4, 5 and the result must have trees of heights 3, 4, and 6. The merge happens the same way we do a binary addition. The trees are stored in sequence, and we have empty places that represent zeros in the binary representation. While merging, each tree represents a bit and it has the number of nodes that the bit represents. We take the corresponding bit from each forest and also consider a carry. All these trees must either be empty or have exactly the same number of nodes. Then, we merge them to create the resulting bits.</p><p class="calibre8">To do any binary addition, we have input of three bits for each bit: one from each of the input and a carry. We need to compute both the output bit and the next carry. Similarly, while merging two trees, we need to compute the output tree and the carry tree from the given input trees (two) and a carry tree. Once the merging is done, inserting and removing <code class="email">min</code> is simple.</p><p class="calibre8">The <code class="email">insert</code> simply merges a forest with a single tree using a single node. Removing the minimum element is a little more complicated operation. The first step is to find out the minimum. We know every tree has the minimum element at its root. So we need to walk through all the trees while comparing the root elements to find the minimum element and the tree that has it. Removing it is simply taking the root off, leaving a list of subtrees that make a forest of consecutive heights of trees. Therefore, we can merge the subtrees in the main forest to complete the removal process.</p><p class="calibre8">Let's see the implementation. First, we create a skeleton class. A binomial tree has a root, which contains a value and a list of subtrees. The list of subtrees is like a dense forest. The list of trees in the <a id="id455" class="calibre1"/>forest is stored in a linked list. We use <code class="email">DoublyLinkedList</code> because we need to remove the last element:</p><div class="informalexample"><pre class="programlisting">public class BinomialForest&lt;E&gt; implements PriorityQueue&lt;E&gt;{

    protected Comparator&lt;E&gt; comparator;
    protected static class BinomialTree&lt;E&gt;{
        E value;
        LinkedList&lt;BinomialTree&lt;E&gt;&gt; subTrees = new LinkedList&lt;&gt;();
        public BinomialTree(E value){
            this.value = value;
        }
    }

    public BinomialForest(Comparator&lt;E&gt; comparator){
        this.comparator = comparator;
    }



    DoublyLinkedList&lt;BinomialTree&lt;E&gt;&gt; allTrees = new DoublyLinkedList&lt;&gt;();
    …
}</pre></div><p class="calibre8">As discussed earlier, we will start with the merge operation now. First we need to merge two trees, which we will use to merge two forests. Merging two trees is a simple constant time operation. Merging with a null tree does not change the tree. The two trees being merged should be of the same size. We need to simply compare the root elements. The tree with the smaller value in its root will get the other as a child:</p><div class="informalexample"><pre class="programlisting">    protected BinomialTree&lt;E&gt; merge(BinomialTree&lt;E&gt; left, 
      BinomialTree&lt;E&gt; right){

        if(left==null){
            return right;
        }else if(right==null){
            return left;
        }
        if(left.subTrees.getLength() != right.subTrees.getLength()){
            throw new IllegalArgumentException(
                  "Trying to merge two unequal trees of sizes " +
                    left.subTrees.getLength() + " and " + right.subTrees.getLength());
        }
        if(comparator.compare(left.value, right.value)&lt;0){
            left.subTrees.appendLast(right);
            return left;
        }else{
            right.subTrees.appendLast(left);
            return right;
        }
    }</pre></div><p class="calibre8">Since we want to check the minimum element in constant time, just like in a heap, we will store the minimum <a id="id456" class="calibre1"/>element in a state variable. We will also store its position in the <code class="email">allTrees</code> list:</p><div class="informalexample"><pre class="programlisting">    BinomialTree&lt;E&gt; minTree = null;
    int minTreeIndex = -1;</pre></div><p class="calibre8">We will define a method to find out and update the variables. Since the smallest element in any tree is the root, we only have to go through the root to find the minimum element:</p><div class="informalexample"><pre class="programlisting">    protected void updateMinTree(){
        if(allTrees.getLength()==0){
            minTree = null;
            minTreeIndex = -1;
        }
        E min = null;
        int index = 0;
        for(BinomialTree&lt;E&gt; tree:allTrees){
            if(tree==null){
                index++;
                continue;
            }
            if(min == null || comparator.compare(min, tree.value)&gt;0){
                min = tree.value;
                minTree = tree;
                minTreeIndex = index;
            }
            index++;
        }
    }</pre></div><p class="calibre8">To implement the merging of two forests, we need to first implement how to compute the output and carry the tree out of the two input trees and a carry tree. These methods are fairly simple. We need to understand that both the input and the carry must be of the same size if they are not null. The height of the output must be the same as the height of the output, and the height <a id="id457" class="calibre1"/>of the carry must be one more than the height of the input:</p><div class="informalexample"><pre class="programlisting">    protected BinomialTree&lt;E&gt; computeOutputWithoutCarry(BinomialTree&lt;E&gt; lhs, BinomialTree&lt;E&gt; rhs, BinomialTree&lt;E&gt; carry){
        if(carry==null){
            if(lhs==null){
                return rhs;
            }else if(rhs==null){
                return lhs;
            }else{
                return null;
            }
        }else{
            if(lhs==null &amp;&amp; rhs==null){
                return carry;
            }else if(lhs == null){
                return null;
            }else if(rhs == null){
                return null;
            }else{
                return carry;
            }
        }
    }
    protected BinomialTree&lt;E&gt;  computeCarry(
      BinomialTree&lt;E&gt; lhs, BinomialTree&lt;E&gt; rhs, BinomialTree&lt;E&gt; carry){
        if(carry==null){
            if(lhs!=null &amp;&amp; rhs!=null){
                return merge(lhs, rhs);
            }else{
                return null;
            }
        }else{
            if(lhs==null &amp;&amp; rhs==null){
                return null;
            }else if(lhs == null){
                return merge(carry, rhs);
            }else if(rhs == null){
                return merge(carry, lhs);
            }else{
                return merge(lhs, rhs);
            }
        }
    }</pre></div><p class="calibre8">We also need to enhance the <code class="email">ListIterator</code> class in our imperative <code class="email">LinkedList</code> implementation so that we can modify the value of any node while iterating through it. We use the following implementation to do this:</p><div class="informalexample"><pre class="programlisting">    public class ListIterator implements Iterator&lt;E&gt; {
        protected Node&lt;E&gt; nextNode = first;
        protected Node&lt;E&gt; currentNode = null;
        protected Node&lt;E&gt; prevNode = null;

        @Override
        public boolean hasNext() {
            return nextNode != null;
        }

        @Override
        public E next() {
            if (!hasNext()) {
                throw new IllegalStateException();
            }
            prevNode = currentNode;
            currentNode = nextNode;
            nextNode = nextNode.next;
            return currentNode.value;
        }

        @Override
        public void remove() {
            if(currentNode==null || currentNode == prevNode){
                throw new IllegalStateException();
            }
            if(currentNode==first){
                first = nextNode;
            }else{
                prevNode.next = nextNode;
            }
            currentNode=prevNode;

        }

        public void setValue(E value){
            currentNode.value = value;
        }

    }</pre></div><p class="calibre8">With these methods <a id="id458" class="calibre1"/>available, we can implement the merging of two forests or two lists of trees:</p><div class="informalexample"><pre class="programlisting">    protected void merge(LinkedList&lt;BinomialTree&lt;E&gt;&gt; rhs){
        LinkedList&lt;BinomialTree&lt;E&gt;&gt;.ListIterator lhsIter
          = (LinkedList&lt;BinomialTree&lt;E&gt;&gt;.ListIterator)allTrees.iterator();
        Iterator&lt;BinomialTree&lt;E&gt;&gt; rhsIter = rhs.iterator();
        BinomialTree&lt;E&gt; carry = null;
        while(lhsIter.hasNext() || rhsIter.hasNext()){
            boolean lhsHasValue = lhsIter.hasNext();
            BinomialTree&lt;E&gt; lhsTree = lhsHasValue? lhsIter.next():null;
            BinomialTree&lt;E&gt; rhsTree = rhsIter.hasNext()? rhsIter.next():null;
            BinomialTree&lt;E&gt; entry = computeOutputWithoutCarry(lhsTree, rhsTree, carry);
            carry = computeCarry(lhsTree, rhsTree, carry);
            if(lhsHasValue) {
                lhsIter.setValue(entry);
            }else{
                this.allTrees.appendLast(entry);
            }
        }
        if(carry!=null){
            this.allTrees.appendLast(carry);
        }
        updateMinTree();
    }</pre></div><p class="calibre8">The <code class="email">Insert</code> method is very simple to implement with the merge available. Just merge a list containing one tree with the value 1:</p><div class="informalexample"><pre class="programlisting">    public void insert(E value){
        BinomialTree&lt;E&gt; newTree = new BinomialTree&lt;E&gt;(value);
        DoublyLinkedList&lt;BinomialTree&lt;E&gt;&gt; newList 
               = new DoublyLinkedList&lt;&gt;();
        newList.appendLast(newTree);
        merge(newList);
    }</pre></div><p class="calibre8">Removal of the minimum element is a little more complex. It involves removing the tree with the minimum value and then considering its root as the minimum element. Once this is done, the subtrees need to be merged with the original forest. If the last tree is being removed, we must actually remove it from the list. This is the same as not writing a leading zero in binary representation. Otherwise, we only set the value to <code class="email">null</code> so that we know it is a zero bit:</p><div class="informalexample"><pre class="programlisting">    public E removeMin(){
        if(allTrees.getLength()==0){
            return null;
        }
        E min = minTree.value;
        if(minTreeIndex==allTrees.getLength()-1){
            allTrees.removeLast();
        }else {
            allTrees.setValueAtIndex(minTreeIndex, null);
        }
        merge(minTree.subTrees);
        return min;
    }</pre></div><p class="calibre8">Finally, we can implement the methods required to use it as a priority queue:</p><div class="informalexample"><pre class="programlisting">    @Override
    public E dequeueMinimum() {
        return removeMin();
    }

    @Override
    public void enqueue(E value) {
        insert(value);
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
        return null;
    }</pre></div><p class="calibre8">This completes our implementation of a binomial queue.</p></div></div>

<div class="book" title="Binomial forest">
<div class="book" title="Complexity of operations in a binomial forest"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec73" class="calibre1"/>Complexity of operations in a binomial forest</h2></div></div></div><p class="calibre8">We already know <a id="id459" class="calibre1"/>that the number of nodes in a binomial tree of height <span class="strong"><em class="calibre12">h</em></span> is <span class="strong"><em class="calibre12">2h-1</em></span>. The question is, if we want to store n elements, what should be the maximum height of the trees in the forest? We have seen that the trees we need are as per the binary expression of the integer <span class="strong"><em class="calibre12">n</em></span>. The most significant bit of the binary representation of <span class="strong"><em class="calibre12">n</em></span> is the floor of (<span class="strong"><em class="calibre12">lg n</em></span>), that is the greatest integer less than or equal to <span class="strong"><em class="calibre12">lg n</em></span>. We will write this as <span class="strong"><em class="calibre12">lg n</em></span>. The height of the tree representing this bit is <span class="strong"><em class="calibre12">1 +  lg n</em></span>. The length of the list holding the trees in the forest is also <span class="strong"><em class="calibre12">1 +  lg n= θ(lg n)</em></span>. Both in the case of an insertion and removal of a new element, a merge operation is involved. The merge operation is constant time for each pair of input trees and one carry. So, the number of operations for a merge operation of two forests is this: <span class="strong"><em class="calibre12">constant times the number of trees in the largest forest = θ(lg n)</em></span>, where <span class="strong"><em class="calibre12">n</em></span> is the number of trees in the largest forest.</p><p class="calibre8">At the time of insertion, we just merge a new forest of only one tree and one element. So this operation is <span class="strong"><em class="calibre12">θ(lg n)</em></span>, where n is the number of elements in the original forest.</p><p class="calibre8">The removal process involves two steps. The first is to remove the minimum element. This involves a constant time operation, which is used to remove the tree with the minimum element, and a merge operation, which is <span class="strong"><em class="calibre12">θ(lg n)</em></span>, as seen already. The second step/operation is to update the tree with the minimum element. This involves scanning the roots of all the trees; therefore, it is <span class="strong"><em class="calibre12">θ(lg n)</em></span>, just like the merge operation. So, as a whole, the removal process is also <span class="strong"><em class="calibre12">θ(lg n)</em></span>.</p><p class="calibre8">Checking the minimum element is of course constant time, as we have it referenced already.</p></div></div>
<div class="book" title="Sorting using a priority queue" id="1MBG21-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec50" class="calibre1"/>Sorting using a priority queue</h1></div></div></div><p class="calibre8">Since a priority queue <a id="id460" class="calibre1"/>always returns the minimum element, if we insert all input elements and then keep dequeuing them, they would be dequeued in sorted order. This can be used to sort a list of elements. In our example, we will add a new method called the <code class="email">LinkedList</code> implementation. This implementation sorts the elements using <code class="email">PriorityQueue</code>. First insert all the elements into the priority queue. Then, dequeue the elements and append them back to the linked list:</p><div class="informalexample"><pre class="programlisting">public void sort(Comparator&lt;E&gt; comparator){
    PriorityQueue&lt;E&gt; priorityQueue = new LinkedHeap&lt;E&gt;(comparator);

    while (first!=null){
        priorityQueue.enqueue(getFirst());
        removeFirst();
    }

    while (priorityQueue.checkMinimum()!=null){
        appendLast(priorityQueue.dequeueMinimum());
    }
}</pre></div><p class="calibre8">Both enqueue and dequeue have <span class="strong"><em class="calibre12">θ(lg n)</em></span> complexity, and we have to enqueue and dequeue each of the elements. We have already seen this: <span class="strong"><em class="calibre12">lg 1 + lg 2 + … + lg n = θ(n lg n)</em></span>. So, the enqueueing <a id="id461" class="calibre1"/>and dequeueing of the elements is <span class="strong"><em class="calibre12">θ(n lg n)</em></span>, which means the sort is <span class="strong"><em class="calibre12">θ(n lg n)</em></span>, which is asymptotically optimal.</p></div>
<div class="book" title="In-place heap sort" id="1NA0K1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec51" class="calibre1"/>In-place heap sort</h1></div></div></div><p class="calibre8">We can use an <a id="id462" class="calibre1"/>array-based heap implementation to do an in-place sort of the elements of an array. The trick is to use the same array for backing the heap. In the beginning, we simply insert the elements in the heap from the beginning of the array. We achieve this by replacing the array in the heap, except the one that is passed. Since the heap also uses the space from the beginning, it does not overwrite the elements we are still to insert. While dequeuing the elements, we start saving them from the end of the array, as this is the part that is being freed up by the heap. This means we want the largest element to be dequeued first. This is achieved by simply using a comparator that is the opposite of the one that is passed. We add this static method to our <code class="email">ArrayHeap</code> class:</p><div class="informalexample"><pre class="programlisting">public static &lt;E&gt; void heapSort(E[] array, Comparator&lt;E&gt; comparator){

    ArrayHeap&lt;E&gt; arrayHeap = new ArrayHeap&lt;E&gt;(0, (a,b) -&gt; comparator.compare(b,a));


    arrayHeap.store = array;

    for(int i=0;i&lt;array.length;i++){
        arrayHeap.insert(array[i]);
    }

    for(int i=array.length-1;i&gt;=0;i--){
        array[i] = arrayHeap.removeMin();
    }
}</pre></div><p class="calibre8">This is actually a sort <a id="id463" class="calibre1"/>using a priority queue as shown before, except that here we are sharing the array with the priority queue. Hence, this sort is also <span class="strong"><em class="calibre12">θ(n lg n)</em></span>, just as before.</p></div>
<div class="book" title="Summary" id="1O8H61-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we discussed priority queues and their implementation. Priority queues are important data structures that are used in a lot of problems. We saw two implementations of a priority queue, a heap, and a binomial forest. We also saw how to use priority queues for sorting, which is asymptotically optimal. A variation of this allowed us to sort an array in place using an array-based heap.</p><p class="calibre8">In the next chapter, we will discuss the concept of graphs, which are very useful, almost ubiquitous ADTs, and data structures that are used in many real-life applications.</p></div></body></html>