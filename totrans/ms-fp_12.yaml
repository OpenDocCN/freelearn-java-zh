- en: The Actor Model in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started to look at the actors model as one of their
    concurrency models available in Scala. In [Chapter 9](6b6045c0-bf4d-4ae9-adc1-fdaf23985329.xhtml), *Libraries
    for Pure Functional Programming*, we saw how challenges of asynchronous and multithreaded
    programming can be solved using IO and the infrastructure it provides. However,
    this kind of technology is still not widely adopted. In practice, when working
    with multithreading, concurrency, and asynchrony in Scala, you will need to deal
    with more robust libraries in real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Akka overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining, creating, and messaging actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with actor systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akka overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka is an implementation of the actor model, which we discussed in the previous
    chapter for its industrial purposes. If the Cats effect focuses on experimentation
    and trials with new technologies, then Akka focuses on providing the industry
    with the tools that can solve large-scale problems. Of course, we can expect cats
    to mature to that level as well, however, if you are going to work with concurrency
    and asynchrony in Scala in a real-world situation, it is likely you will encounter
    Akka.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to make you comfortable with modern technologies
    in functional programming that are in demand in real-world situations. Since concurrent
    and asynchronous programming is ubiquitous, we are going to discuss the tools
    that are most widely used to tackle its challenges. We will start by looking at
    the principles on which Akka is built.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The central abstraction of Akka is an actor. An actor is an entity that can
    receive and send messages to other actors.
  prefs: []
  type: TYPE_NORMAL
- en: Actors are lightweight concurrency primitives. Similarly to how you can have
    millions of Fibres in cats, you can have millions of actors in Akka. This is because
    they utilize asynchrony and provide abstractions on top of standard Java virtual
    machine threads. By utilizing the resources of the JVM, you can have millions
    of actors in parallel on a single machine.
  prefs: []
  type: TYPE_NORMAL
- en: Akka is built with scaling in mind. The library does not stop at providing you
    with the abstractions for actors themselves. Similarly to how cats has an infrastructure
    of libraries for various specific cases of functional programming, Akka has a
    host of libraries for special cases of asynchronous programming. You will encounter
    an HTTP server as part of this library, which is an infrastructure to allow you
    to communicate between actors that reside on different machines.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the actors model is to provide you with a concurrency framework
    that will reduce your mental overhead and allow for robust and scalable software.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the challenges that concurrent programming poses, Akka imposes a
    range of pretty harsh restrictions on a programmer. One can expect to benefit
    from the model only if they follow these restrictions. It is important to remember
    that the rules the actor model imposes are not encoded and enforced by the compiler.
    So it is up to you to follow them. Breaking them at will is easy. It is important
    to remember that if you do so, it is very likely that you are going to end up
    with even more of a headache than you had without the actor model.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with concurrent programming is the shared mutable state. Akka eliminates
    this problem by providing a restriction that it is impossible to access your actors
    as ordinary objects. This means your business logic does not have a single variable
    that would store an actor. Hence, it is impossible to access the values defined
    on the actors by ordinary object-oriented means.
  prefs: []
  type: TYPE_NORMAL
- en: The actors are exposed to the outer world via proxy types—`ActorRef`s. The Akka
    library defines this type, and only safe operations are permitted on an actor.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to do something with an actor, you should do so via this proxy.
    Also, you do not instantiate an actor as an ordinary Java or Scala object. You
    do not call a constructor on it. Instead, you will instruct `ActorSystem` to instantiate
    it. With these constraints, it becomes impossible to accept the data of an actor
    by any means other than messaging it.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every actor has a mailbox, where any other messages can be sent. Akka guarantees
    that the messages are handled by the actor one at a time, and no concurrent handling
    happens. In fact, the actor model provides a guarantee that no more than one thread
    accesses the internal state of an actor at a time. However, keep in mind that
    it is up to the programmer to follow the actor model precisely. It is easy to
    break the model by spawning extra threads (e.g. with a `Future`) in an actor,
    thus breaking the single-threaded access guarantee.
  prefs: []
  type: TYPE_NORMAL
- en: This restriction is essential to enforce in the presence of other convenient
    concurrency libraries, such as Future. Akka works hand-in-hand with Scala Future.
    It is important to remember that futures start and work from other threads. So,
    the moment you start a Future in Akka, you lose the guarantee of single-threaded
    access to the state of an actor. If you follow this road, you will need to specify
    the synchronization and utilize the monitor mechanism provided to you by the JVM.
    This is an anti-pattern, it kills the very purpose of Akka, and is a big no-no
    in actor programming.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the model is going to help you only if you follow its rules, and
    there is nothing to enforce you to do so.
  prefs: []
  type: TYPE_NORMAL
- en: No leaking of mutable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another thing that you must look out for when programming with Akka is leaking
    mutable state of the actors. Remember the previous principle that no more than
    a single thread must access the inner state of an actor? Well, if you send a reference
    to a mutable object that is owned by one actor to another one, this object may
    be accessed from two threads at a time in parallel. If you leak mutable state
    to other actors, you may end up with a worse headache than when starting a Future
    from an actor. In the case of starting a Future, at least you have control over
    that Future and the thread it started from; you can define some monitors and 
    protocols to access the actor's state. Of course, you should not do it, but in
    theory, it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you leak a reference to a mutable state from one actor to another,
    you will have no control whatsoever over how that actor will use it.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this rule is not enforced by Akka. In Akka, you can pass any object as
    a message to another actor. This includes mutable references. So, you should be
    aware of the possibility and actively avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Fault-tolerance and supervision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka is built with resilience and fault-tolerance in mind. This means that if
    an actor fails as a result of an exception, there is a well-defined way it will
    automatically restart and restore its state. Akka organizes actors in hierarchies,
    and parent actors are responsible for the performance of their children. So, if
    a child fails, its parent is supposed to be responsible for restarting it. The
    idea is that the external world should not be affected by the problems of an actor's
    subordinates. If the problem happens, it is the supervisor's responsibility to
    solve it rather than escalating it further. And when the child actor restarts,
    it should be able to restore itself to the state it was at when it failed.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging guarantees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka is built to be deployed in clusters, over the network. This means that
    you have fewer delivery guarantees about the messages than when you are working
    on a single JVM application. If you are sending a message from an actor that resides
    in one computer to an actor on another side of the world, you cannot guarantee
    that this message will get delivered.
  prefs: []
  type: TYPE_NORMAL
- en: So, the actor model as implemented by Akka requires you to build your applications
    with no guarantees whatsoever about delivering the messages. Your application
    must be robust to the situations of the impossibility of message-delivery.
  prefs: []
  type: TYPE_NORMAL
- en: However, Akka provides you with a guarantee about the order in which messages
    from one actor to another get delivered. This means that if from the same actor,
    you send a message before another, you can be sure that message also arrives before
    the second one.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing to do after learning the preceding theory is to have a look at
    how it works in practice. Next, we will be discussing an example that relies on
    the numerous functionalities that Akka exposes. We will be learning these functionalities
    as we encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchrony
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember when we discussed IO, we stressed the importance of asynchrony and
    non-blocking computations? Threads of the underlying operating system are scarce,
    and on a system with high load, you need to utilize them well. Blocking is not
    a wise utilization of the threads.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed that you should not invoke other threads from the current
    actor. The motivation for this is to prevent access to the mutable state of the
    current actor from more than one thread. We have discussed that whenever we need
    to process something, we schedule the processing as a message to the current actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to enforce single-threaded processing, you might be tempted to block
    on a future from a message-handling logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this blocks the underlying thread. Blocking turns an actor that does
    so into a heavyweight concurrency primitive. If you use it in a setting of a high-load
    application, it will eat system-concurrency resources fast. The rationale here
    is the same as when we were discussing IO. Bottom line: do not block your concurrency
    primitives because the threads are scarce. If you need to wait for the result
    of some asynchronous computation to continue the current computation, make sure
    that that the computation will send this actor a message when it finishes, register
    a handler on the current actor saying what to do once the task finishes, and release
    the current thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining, creating, and messaging actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The actors are defined as classes that inherit from the `Actor` class from
    the Akka library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Actor exposes the following abstract API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ccebe72-90ba-46e7-a07d-2ff51a1a18a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The only method that is abstract in `Actor` is the `receive` method. Akka calls
    this method when an actor needs to handle an incoming message. It returns a partial
    function from `Any` to `Unit`. This means that it is capable of handling a message
    from a domain of all objects, and it is supposed to produce some side effects
    while handling this message, which is indicated by the `Unit` return type. That
    function is a partial function, which means that it can handle only a part of
    the input `Any` domain that your actor is interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your define an actor, you override this method to define what the actor
    must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The message is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when an actor receives the ping message, it will output the `hello world` string
    to the log. We can construct the log with the help of the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc14022b-24bb-4ca5-aa76-8a5172aa424e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This function is defined over the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d981b63f-57f1-4421-93f1-8bd8ea6c92e8.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the abstractions Akka relies upon is the event system. Events can be
    used to track the changes in the state of an actor and restore it to the previous state
    in case of failure. Since logging is also an event stream in a sense, Akka provides
    you with an elaborate logging infrastructure that also integrates with its general
    event system. When constructing a logger, you will need to provide the `ActorSystem` you
    are defining it for, as well as the reference to the current actor. You will then
    be able to display the log messages properly while specifying the current actor.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that here, to construct the logger, we are accessing some other API defined
    on the actor. We are calling the context method and its member-system method.
    So, next, let's have a look at the API the actor exposes.
  prefs: []
  type: TYPE_NORMAL
- en: All of the concrete members of the `Actor` class can be divided into several
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following methods belong to the callbacks group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25f95e92-7c78-49ad-8573-5fcc394b2e4a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Akka framework in different situations calls these callbacks. For example, `postStop`
    is called after the actor stops. `preStart` is called before the actor starts. `preRestart`
    is called before, and `afterRestart` is called after, the actor has restarted.
    The restart callbacks take a `reason` as an argument. The `reason` is an exception
    due to which this actor had to restart itself. It is also part of Akka's fault-tolerance
    strategy. When building your actors, you should keep the possibility of such restarting
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `unhandled` method is called whenever a message arrives at an
    actor that it is not capable of handling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2edac43e-39d2-4353-98d2-dcf08e60b1fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that we have discussed that the `receive` method returns a partial
    function. This means it is defined only on a part of its domain type. So, whenever
    a message arrives at an actor that it is not able to handle, the unhandled callback
    is called instead.
  prefs: []
  type: TYPE_NORMAL
- en: Supervision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also, part of the fault-tolerance strategy that Actor provides is the `supervisorStrategy`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/959743bd-0a01-4bcd-80d4-22fdf7ac5aa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can override this method to provide the actor with different ways to supervise
    its children. Supervision is the concept of watching the children''s life cycle
    and taking actions on significant events, such as when an actor fails with an
    exception. In Akka, parent actors are supposed to supervise child actors. The
    supervision strategy is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a2d5019-f626-4dbb-b4d7-8e8452f3cde8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are two subclasses defined for this class, and the documentation
    suggests you shouldn''t implement additional subclasses because an incorrect implementation
    can lead to erroneous behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/567857e7-750d-44b1-ae49-91a467650602.png)'
  prefs: []
  type: TYPE_IMG
- en: '`AllForOneStrategy` will apply a given action to all of the children if one
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb9fa2ed-b0ab-4631-a5cb-91a3b60deb7a.png)'
  prefs: []
  type: TYPE_IMG
- en: '`OneForOneStrategy` will apply an action only to the child that failed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that both strategies are parameterized by various parameters that
    define how it should handle situations with failed children. One of these parameters
    is `Decider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bffb40cc-0a99-4fb7-b544-e37b43f5b96b.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Decider` type is a partial function from a `Throwable` to a `Directive`.
    It takes a `Throwable` (which can be an `Exception` or an `Error`) that has occurred
    in the actor, and the job of `Decider` is to provide information to the actor
    system on how to handle this exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`Directive` defines what to do on a given exception with an actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1761d58a-5690-4282-a2b8-f97dc47c8726.png)'
  prefs: []
  type: TYPE_IMG
- en: There are four subclasses to the `Directive` trait. The `Escalate` directive
    escalates the exception to the parent of the supervising actor. So, when the child
    fails, the parent will also fail and will rely on its own parent to handle the
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6d3f406-a07e-49ab-bdf4-a663bde60bff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Restart` directive will discard the actor that failed and will create
    a new actor in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699d3e4a-9b5c-4502-97b1-ca92edd3a756.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Resume` directive will instruct the actor that had an exception to continue
    processing the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd04c5b5-d99c-4a2f-8d86-08b3f6510817.png)'
  prefs: []
  type: TYPE_IMG
- en: The exception will be ignored, and no action will be taken to handle it. The
    child actor will continue as it did previously.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Stop` directive will stop the current actor without starting another
    one in its place.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/690b5fd8-cbdc-47b2-a035-cf5816285b79.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding infrastructure provides you with the capability to construct hierarchies
    where parents are responsible for the sound operation of the children. This approach
    provides a separation of concerns and enables a degree of local reasoning. This
    means that actor systems handle the failures as early as possible instead of propagating
    them up the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchies also provide you with a measure of abstraction, because you no longer
    care about the children of a given actor, you can treat a given actor as a single
    point of responsibility for the task that it was asked to do. A single point of
    responsibility is similar to how, in organizations, you have a single person responsible
    for a department, and whenever you need the department to do something, you talk
    to the responsible person. You expect them to run the department properly. Akka
    is built the same way. Whenever you have a concern, you have an actor responsible
    for this concern. It may or may not have child actors that help them work on this
    concern, however, as an outside observer, you do not need to be aware of these
    factors. You do not need to care about the errors that happen to these subordinates.
    This is, of course, only if the errors in question can be localized to a given
    department. If the error is more significant than what the department can handle,
    it propagates up the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Context and references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the callbacks that give you control over how an actor reacts to
    various life cycle events, an actor has an API for managing the context of its
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40ddd79e-c87b-4272-ba80-9259143b5b82.png)'
  prefs: []
  type: TYPE_IMG
- en: Actors have references to the `ActorRef` of themselves and the sender actor.
    These references are supposed to be accessed from the `receive` method. Through
    them, you can interact with the sender actor, as well as with this actor as with
    `ActorRefs`. This means that you can send messages to these actors, and do other
    things you would usually do as an external observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from references, an actor has a `context` reference that provides information
    and control over the context of the actor''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc9246f3-5227-497f-93f9-fbc0d272072f.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ActorContext` provides various APIs that may be useful when handling messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the actor hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The central concept for managing actor hierarchies is the `ActorContext` type.
    It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc5a0f1c-4894-4143-a1b2-11a3d1f58994.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ActorContext` allows you to perform various operations on the actor''s hierarchy.
    For example, you can create new actors with the `actorOf` method which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/163211b8-7a6f-4932-8721-1c7d1f255821.png)'
  prefs: []
  type: TYPE_IMG
- en: So, with `ActorContext`, you can create child actors of this actor. We will
    cover the exact procedure of creating a new actor with the `Props` object a bit
    later when we will be discussing actor systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current actor is capable of accessing the child actors it created with
    the `child` and `children` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53a40c8c-2f71-46df-b2c1-4465d9de6d87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, you can access the parent actor of this actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b641a011-3b0a-4f1f-8949-5480b56506b8.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ActorSystem` is a collection of actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e60a61b8-c8a0-4ec9-bbb1-3c1c9917aafc.png)'
  prefs: []
  type: TYPE_IMG
- en: We will cover actor systems later in the *Creating actors* section, but for
    now, you should understand that `ActorSystem` is accessible from `ActorContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Akka context provides you with various methods for the life cycle management
    of an actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c94e188-dc0e-4886-aa96-ec50765e342f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can stop this or another actor from using `ActorContext`. A widespread
    pattern with actor-based programming is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding idiom is often used to terminate actors that have accomplished
    their job and have nothing more to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors can change their behavior. The behavior of an actor is defined by its `receive` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4620ed59-abf7-46e8-a168-2b7283d58050.png)'
  prefs: []
  type: TYPE_IMG
- en: However, as part of handling messages, you may want to change the way messages
    are handled by an actor. For this purpose, you can use the `become` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'An actor remembers past behaviors you have overridden and keeps them in a stack.
    This means that you can call an `unbecome` method to pop the current behavior
    from the stack and use the previous behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c290aa0-49c7-4c81-99fb-6c3ecc692fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Supervision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An actor can watch another actor for its life cycle events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79306989-d400-4770-86ff-ef281efec625.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever you need this actor to be aware of when another actor terminates, you
    can instruct it to watch that other actor with actor context. When that actor
    terminates, the supervising actor will receive a `Terminated` message. You can
    register a handler of a `Terminated` message the same way you handle any other
    message from the received message.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the actors belong to some `ActorSystem`, which is a hierarchy of actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a72921b6-f7eb-47dc-a80e-516cbd03e19f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The most important methods when creating new actors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d90a0218-399b-493a-8722-eae9736f6fbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Every actor is created using an `actorOf` method called over an actor system
    or an actor context. You can create the actor system itself using its companion-object
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a14197d5-79bb-4316-aad0-4da716b6a298.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When calling this method, you can specify the name of this system. You can
    also specify the configuration that defines certain aspects of the behavior of
    the actor system. The configuration is a file that is placed under the path specified
    under the `CLASSPATH` environmental variable. `CLASSPATH` is a standard way to
    let a JVM program know where to look for the classes it uses. For example, in
    an SBT project, you can place the configuration under the following path under
    the project root directory: `src/main/resources/application.conf`. In this configuration
    file, we can, for example, disable logging of so-called dead letters—messages
    intended for nonexistent actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The configuration is quite flexible and grants you a degree of control of how
    your actor system is executed. For more information, please consult the Akka documentation
    on configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You are also able to specify which execution context this `ActorSystem` is going
    to use to run its actors. Just as when we discussed IO, for a concurrency library,
    we need a way to specify what threading strategy the library should use. Finally,
    you can provide a class loader to `ActorSystem`, which will be used for things
    such as resolving configurations. All these parameters are optional. If you do
    not specify one of them, Akka will use reasonable defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at how we run our Hello World example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create `ActorSystem`. We create a `HelloWorld` actor. We do not call
    its constructor. We do so by using a `Props` object. We specify the class that
    we are going to create in the `Props` type parameters. We also specify the name
    of the actor to be created. `Props` is a case class defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31dba49b-53c3-4c23-ae9a-589db0a2530d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Its companion also defines a bunch of convenience methods to create `Props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70dfb8dc-8937-441f-be6e-87915eb3ae7a.png)'
  prefs: []
  type: TYPE_IMG
- en: After we create an actor with the help of `Props`, we can send a message to
    this actor. We do so with the `!` operator that `ActorRef` defines.
  prefs: []
  type: TYPE_NORMAL
- en: Actor parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ordinary classes can have constructors that take arguments that can be used
    to parametrize the resulting instance. In the same way, an alternative version
    of the `Props` factory method can be used to create an actor with constructor
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have an actor whose constructor takes arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding actor specifies the name of a person it is going to greet when
    it does its output. Also, notice how it accepts a string as a message. This is
    to show that you can send any object as a message to an actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have an actor that takes constructor parameters, a standard practice
    is to declare a `Props` factory method as a companion of an actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This method abstracts away the `Props` needed to create this actor. Now, you
    can construct this actor and use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b071d3b3-0f7d-4e40-bc2c-208bf3d3a267.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with actor systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strength of the actor model is that actors are lightweight, which means
    you can use millions of them on a single JVM running on an ordinary computer.
    Most of the time, you are not going to use a single actor but many actors. This
    requires a model to handle multiple actors.
  prefs: []
  type: TYPE_NORMAL
- en: In Akka, actors are organized in hierarchical trees—meaning that every actor
    has a parent and can have multiple children. Next, we will have a look at a slightly
    more complicated example that will showcase how actors work in hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Task specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine we need to have multiple actors that all output a greeting to a given
    name to the log. Imagine also that we need to abstract away the fact that there
    are multiple actors in the system from the end user. We are going to do so by
    creating a single supervising actor that is going to be in charge of the execution
    of all its child actors. The child actors will be the actors that output the greeting
    message to the log, and the parent actor will be a manager that represents them.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol is going to be as follows. First, create a `GreetingsManager` actor.
    Then, you are going to send a `SpawnGreeters` message to spawn a number of greeter
    actors parameterized by the number of greeters required. These spawned greeters
    must override the ones we already had. That overriding is done by stopping the
    previous actors and creating new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the user sends a `SayHello` message to the manager actor, which will instruct
    all of its children to perform output to the log. However, in a situation where
    the manager does not have any child actors spawned, we are going to output an
    error that asks the user to spawn the actors first.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by defining the `Greeter` actor, as it is the simpler one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The actor is going to accept a say hello message that is parameterized by the
    name the actor is supposed to greet. On receiving this message, it is going to
    perform a log output.
  prefs: []
  type: TYPE_NORMAL
- en: The `Greeter` actor has the means for the other actors to stop it. We have already
    discussed that one of the requirements of the task is that the manager actor should
    be able to terminate its existing actress to spawn a new actor. This can be accomplished
    by sending a message to this `Greeter` actor.
  prefs: []
  type: TYPE_NORMAL
- en: That message will use the `context stop self` pattern and will report to the
    sender actor that it is dead with the `Dead` message. Note that `context stop
    self` terminates the `self` actor only once it is done processing its current
    message. So the `sender ! Dead` code will be executed once the actor is still
    alive. The actor will terminate after it finishes processing the `Die` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using case classes as messages to communicate between actors because
    they are convenient for pattern-matching. The entire protocol looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will introduce every message as we encounter it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that Akka has a built-in message that can be used to stop actors. Whenever
    you send `PoisonPill` to an actor, its default behavior is to terminate itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed8d9a2a-d0e7-45a3-acd8-e5908b6203e1.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason we are not using `PoisonPill` here is that it does not play well
    with the pattern that we are going to use down the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s start working on the `GreetingsManager` actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `receive` method is set to `baseReceive`. The reason we are not defining
    the API the actor exposes directly under `receive` is that we are going to leverage
    the `context become` functionality to change the behavior of the actor. `context
    become` can be used to override the functionality of the receive method. Every
    new behavior is going to be implemented as a separate method inside of this actor,
    for easy switching.
  prefs: []
  type: TYPE_NORMAL
- en: The `baseReceive` method enables the actor to handle two API messages: `SpawnGreeters`
    and `SayHello`. They will manage the underlying greeters and instruct them to
    perform output.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both of these methods follows a pattern. First, they optionally
    perform a log output, after that, they call the `resolveGreeters` method, and
    finally, they use the `context become` pattern to change the behavior of the current
    actor.
  prefs: []
  type: TYPE_NORMAL
- en: The reaction to both of these messages depends on whether or not the `Greeter`
    actors are spawned. If they are not, then in the case of the `SpawnGreeters` message,
    we are going to spawn them as usual. In the case of `SayHello`, we are going to
    output an error that we are not able to operate due to the absence of greeters.
  prefs: []
  type: TYPE_NORMAL
- en: If there are child actors, we are going to terminate them all in the case of
    `SpawnGreeter` to create new ones. In case of `SayHello`, we are going to instruct
    the child actors to output the greeting to the log.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, you can track the state of all of your child actors from a mutable
    variable inside this actor. So, whenever you spawn a child actor, you save the
    references to it to a collection inside of this actor. This way, you will be able
    to quickly check for whether or not we have the child actors defined.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this example, we are going to explore how to check for child actors
    using the built-in actor-hierarchy-management API.
  prefs: []
  type: TYPE_NORMAL
- en: The API is asynchronous and messaging-based. We have discussed already that
    it is crucial for the actors to be non-blocking. They are lightweight concurrency
    primitives, and threads are scarce, hence, to keep actors lightweight, we need
    to make sure that they utilize as little of their threading as necessary. Hence,
    we cannot afford to block on a children's query operation. The strategy is to
    request the children, register listeners to the responses as reactions to actor
    messages, and release the thread the actor is using to execute this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is what you see in the `baseReceive` example. The `resolveGreeters`
    method initiates the children resolution, and the results are going to arrive
    at the actor back as a message. We are going to change the `receive` implementation
    of this actor to handle this message.
  prefs: []
  type: TYPE_NORMAL
- en: Once the appropriate response arrives, these new behaviors will perform the
    requested functionality. We have separate behaviors for the `SpawnGreeters` and
    `SayHello` messages. Notice also that we parametrize these behaviors by the original
    sender of the current message and the data they provide. So, we will be able to
    execute the response request when we are ready, as well as notify the requester
    of the successful execution of this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how the `resolveGreeters` function is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `actorSelection` API is documented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8f4b986-83a2-40b3-b4b5-415ff57a0cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Akka, every actor has a name and a chain of parent actors it belongs to.
    Every actor also has a name. This allows you to identify actors by a path to them.
    For example, let''s have a look again at the output of our hello world application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/043dba65-e46f-47c1-b428-3b9701d07526.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The log provides a path to the current actor in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Akka, it is possible to query actors by their path. It is possible to query
    entire slices of actors and send messages to entire collections of actors.
  prefs: []
  type: TYPE_NORMAL
- en: So, the actor selection function is a function that accepts a path to the actor
    that can include wildcards to query lots of actors at the same time, and it will
    return an actor selection under a Future.
  prefs: []
  type: TYPE_NORMAL
- en: Actor-selection provides you with some of the capabilities you would have on
    an ordinary `ActorRef`. However, for the `resolveGreeters` function, our objective
    is to check whether the greeters exist at all. This can be done by calling a `resolveOne`
    function and observing whether it returns a successful Future or a failed Future.
  prefs: []
  type: TYPE_NORMAL
- en: '`resolveOne` takes the timeout as an argument and produces a Future that is
    going to result in a random actor from the collection of actors you are selecting.
    If the selection is empty, it is going to fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we have an Akka pattern for Future interoperability. The pattern
    is called the pipe pattern, and in our example, it follows some transformations
    of the Future we are going to ignore for a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pipeTo` method is available on actor references via a Rich Wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2710b86f-8d7c-422a-8eea-e3535bb87bbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The API it injects is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/762c1a4d-e518-4794-9ca9-a0982c4fbfc6.png)'
  prefs: []
  type: TYPE_IMG
- en: As we have discussed already, it is an anti-pattern to call a Future from an
    actor. Whenever you have an asynchronous computation that this actor depends upon,
    you need to make sure that this computation sends a message to this actor upon
    termination, and defines how to handle the message from the actor. Akka defines
    such a pattern for futures—the pipe pattern. The pattern makes sure that the message
    will be sent to a given actor upon future completion.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we request the `actorSelection` results and schedule a message
    with the results of this resolution to be sent to the current actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transformations we are doing before the pattern are required to make sure
    that the failed future also sends a message to the current actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the map method to wrap the result of this future into a message
    that we want to send to the actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how `actorSelection` works in practice with a small example.
    Consider the following case clause added to the base handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our actor manager is now capable of receiving a `resolve` string as a message,
    upon which it will perform an actor-selection of all the current greeters and
    put the results into the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the resolution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are working under the Future Monadic flow here. This is because, on some
    occasions, we are going to wait on the response of an actor system before we proceed.
    Let's have a look at the example line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have a `resolve` message sent to the current actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `?` operator is injected by the following Rich Wrapper in Akka.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have an ask pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c703fcdb-3913-4a96-8838-881beec0721f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the API it injects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34897b3c-0519-4d02-ab28-482b6f96c686.png)'
  prefs: []
  type: TYPE_IMG
- en: The pattern sends a message to an actor reference, just like the ordinary `!`
    operator. However, it also expects the actor to respond to the current actor.
    The response message is returned under a Future. Under the hood, this ask method
    creates a temporary child actor that actually sends the message to the original
    addressee. If the addressee responds to this temporary actor, the response will
    be available as the Future's result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the ask pattern because we want to suspend the execution of the
    example until the manager reports that the actors were successfully created. The
    first line of this example models a case where the greeting manager had no child
    actors. With the second line, we create the child actors and wait until they are
    created. The next line will test how actor-selection works against a non-empty
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this line, we are sending 10 resolve messages to the greeting manager.
    The result of the execution of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c82a8925-cb91-4fea-9de4-86d3dfc010c5.png)'
  prefs: []
  type: TYPE_IMG
- en: The result is nondeterministic. This means that every time we send a message
    to the actor, we are not sure which actor will be returned. Notice how, at first,
    the greeter with ID `6` is returned, and on subsequent invocations, the greeter
    with ID `1` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at how this pattern plays with the rest of the application.
    Let''s explore the `SayHello` message-handling example first. After calling `resolveGreeters`,
    we use the `context become` pattern to change the way the actor handles messages
    and set a new `receive` function to `sayingHello`. Let''s have a look at how `sayingHello`
    is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`sayingHello` is going to react on the `GreeterResolution` message. This is
    precisely the message we are sending from the result of the `Greeter` functions
    we just discussed. The message has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have two cases of the payload of that message—the success and failure.
    We have a failure in which there are no greeters registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we log an error saying that there are no greeters. We then switch
    the actor''s receive logic back to base and report to the original requester that
    the job is done, so that it is aware that the actor system has finished processing
    its request, in case the requester needs to wait upon such an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the case of a successful resolution of greeters, we select the greeters using
    actor-selection logic and send the message to this selection. Finally, we switch
    back to base-handling logic and report to the requester that the job is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at how the spawning greeters logic works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes a requester actor and the number of greeters to create. Let''s
    have a look at the message handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no children registered, we send a `GreetersCreationAuthorised`
    message to ourselves specifying that it is safe to create greeters. We need this
    authorization because sometimes it is not safe to create new greeters—namely when
    the current actor has old greeters still alive. In this case, we can have naming
    conflicts we want to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In case the resolution was successful, we must kill this actor''s greeters
    first. We output a warning message to that log specifying that we are going to
    kill the existing greeters. After that, we obtain the children from the actor
    context. `children` provides us with an iterator of all the children of this actor.
    We are then going to filter the actors by name with a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Above, `raw` is needed so that `\` is not treated as an escape character, but
    is interpreted literally. `r` turns the string it is called on into a regular
    expression object – this API is a part of Scala Core library. `unapplySeq` attempts
    to match the regex it is called on against the string passed to it as an argument.
    If the match succeeds, the method returns `Some`, otherwise –  `None`. See Scala
    Core API on `scala.util.matching.Regex` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In case we have any other children, only the greeters that follow a specific
    naming convention will get selected. We do not have any other children in this
    example. However, it is still a good idea to identify the target children.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have filtered the actors to kill, we send them a termination message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We are using the ask pattern again in the body of the `traverse` method to produce
    a Future. The greeter actors will respond with a message reporting that they were
    terminated. This allows us to block the execution asynchronously and continue
    once all the greeters are dead. We can achieve this by using the ask pattern to
    track the termination of individual actors, then combine the returned Futures
    into one Future with the `traverse` method. This Future will succeed once all
    of the actors are terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we wrap the Future''s contents into the `GreetersTerminated` message.
    Next, let''s look at the `GreetersTerminated` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We output the report of the termination to the log and send the authorization
    message to `self` to begin the greeters'' creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`GreetersCreationAuthorised` is a branch that will only be executed once it
    is safe to create new greeters. It will create new greeters from a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the second argument to `actorOf` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we notify the requesting actor that the job of creating the greeters
    is completed. Finally, we switch the context back to `baseReceive`. Now, let''s
    write a test program to see how the example works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We first send a hello message to an empty greeter manager. Then, we spawn the
    greeters with a corresponding message. Then we send the `SpawnGreeters` message once
    more, to see how the greeters manager will first kill its existing greeters and
    only then spawn the new ones. Finally, we send the `SayHello` message again.
  prefs: []
  type: TYPE_NORMAL
- en: We have two messages and two possible states of the manager's children greeters.
    This gives us four possible combinations. Every one of the messages in the example
    checks the behavior of each of these cases. Notice, how we are using the ask pattern
    to block the execution flow asynchronously until the actor responds that it has
    completed the operation. This makes sure that we do not send messages too early.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the message looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e79ee941-80c6-459d-9a3e-26d3ece93739.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Akka framework, which is a de-facto standard
    for actor-oriented programming in Scala. We have learnt how to create new actors,
    how to define them, and how to run an actor-based application. We saw how actors
    are organized into actor systems, and how they work together in hierarchies. Also,
    we briefly discussed the patterns that Akka provides for working with actors and
    futures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see the usage of the actors model in practice by
    looking at an example application implemented with this model.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the principles of the Actor model in Akka's implementation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define an actor in Akka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a new actor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you send a message to an actor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ask pattern and how do you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pipe pattern and how do you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
