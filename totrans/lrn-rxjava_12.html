<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using RxJava for Kotlin New</h1>
                </header>
            
            <article>
                
<p>In our final chapter, we will apply RxJava to an exciting new frontier on the <strong>JVM</strong>: the Kotlin language.</p>
<p>Kotlin was developed by JetBrains, the company behind Intellij IDEA, PyCharm, and several other major IDEs and developer tools. For some time, JetBrains used Java to build its products, but after 2010, JetBrains began to question whether it was the best language to meet their needs and modern demands. After investigating existing languages, they decided to build and open source their own. In 2016 (5 years later), Kotlin 1.0 was released. In 2017, Kotlin 1.1 was released to a growing community of users. Shortly afterward, Google announced Kotlin as an officially supported language for Android.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Why Kotlin?</li>
<li>Configuring Kotlin</li>
<li>Kotlin basics</li>
<li>Extension operators</li>
<li>Using RxKotlin</li>
<li>Dealing with SAM ambiguity</li>
<li><kbd>let()</kbd> and <kbd>apply()</kbd></li>
<li>Tuples and data classes</li>
<li>The future of ReactiveX and Kotlin</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why Kotlin?</h1>
                </header>
            
            <article>
                
<p>Kotlin strives to be a pragmatic and industry-focused language, seeking a minimal (but legible) syntax that expresses business logic rather than boilerplate. However, it does not cut corners like many concise languages. It is statically typed and performs robustly in production and yet is speedy enough for prototyping. It also works 100% with Java libraries and source code, making it feasible for a gradual transition.</p>
<p>Android developers, who were stuck on Java 6 until recently, were quick to adopt Kotlin and effectively make it the "Swift of Android". Funnily, Swift and Kotlin have a similar feel and syntax, but Kotlin came into existence first. On top of that, a Kotlin community and ecosystem of libraries continued to grow quickly. In 2017, Google announced Kotlin as an officially supported language to develop Android apps. Due to JetBrains and Google's commitment, it is clear Kotlin has a bright future in the JVM.</p>
<p>But what does Kotlin have to do with RxJava? Kotlin has many useful language features that Java does not, and they can greatly improve the expressibility of RxJava. Also, more Android developers are using Kotlin as well as RxJava, so it makes sense to show how these two platforms can work together.</p>
<p>Kotlin is a language that can quickly be picked up by Java developers within a matter of days. If you want to learn Kotlin in detail, <em>Kotlin in Action</em> (<a href="https://www.manning.com/books/kotlin-in-action">https://www.manning.com/books/kotlin-in-action</a>) by Dmitry Jemerov and Svetlana Isakova is an excellent book. There is also the excellent online reference (<a href="https://kotlinlang.org/docs/reference/">https://kotlinlang.org/docs/reference/</a>) provided by JetBrains. In this chapter, we will quickly go through some basic features of Kotlin to sell its pertinence in expressing RxJava more quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Kotlin</h1>
                </header>
            
            <article>
                
<p>You can use either Gradle or Maven to build your Kotlin project. You can create a new Kotlin project in Intellij IDEA without any build automation, but here is how to set up a Kotlin project for Gradle and Maven.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Kotlin for Gradle</h1>
                </header>
            
            <article>
                
<p>To use the Kotlin language with Gradle, first add the following buildscript <kbd>{ }</kbd> block to your <kbd>build.gradle</kbd> file:</p>
<pre style="padding-left: 60px">buildscript {<br/>     ext.kotlin_version = '&lt;version to use&gt;'<br/><br/>     repositories {<br/>         mavenCentral()<br/>     }<br/><br/>     dependencies {<br/>         classpath "org.jetbrains.kotlin:kotlin-gradle- <br/>         plugin:$kotlin_version"<br/>     }<br/> }</pre>
<p>Then, you will need to apply the plugin, as shown in the following code, as well as the directories that will hold the source code.</p>
<p>Note that <kbd>src/main/kotlin</kbd> is already specified by default, but you would use the <kbd>sourceSets { }</kbd> block to specify a different directory if needed:</p>
<pre style="padding-left: 60px">apply plugin: "kotlin"<br/><br/> sourceSets {<br/>     main.kotlin.srcDirs += 'src/main/kotlin'<br/> }</pre>
<div class="packt_infobox">You can learn more about the Kotlin Gradle configuration in detail on the Kotlin website at <a href="https://kotlinlang.org/docs/reference/using-gradle.html">https://kotlinlang.org/docs/reference/using-gradle.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Kotlin for Maven</h1>
                </header>
            
            <article>
                
<p>For Maven, define a <kbd>kotlin.version</kbd> property and the <kbd>Kotlin-stdlib</kbd> as a dependency in your POM, as shown in the following code. Then, build the project:</p>
<pre style="padding-left: 60px"> &lt;properties&gt;<br/>     &lt;kotlin.version&gt;1.1.2-2&lt;/kotlin.version&gt;<br/> &lt;/properties&gt;<br/><br/> &lt;dependencies&gt;<br/>     &lt;dependency&gt;<br/>         &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br/>         &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;<br/>         &lt;version&gt;${kotlin.version}&lt;/version&gt;<br/>     &lt;/dependency&gt;<br/> &lt;/dependencies&gt;</pre>
<p>You will also need to specify the source code directories and the kotlin-maven-plugin, as demonstrated in the following code:</p>
<pre style="padding-left: 60px">&lt;build&gt;<br/>     &lt;sourceDirectory&gt;${project.basedir}/src/main/kotlin&lt;/sourceDirectory&gt;<br/>     &lt;testSourceDirectory&gt;${project.basedir}/src/test/kotlin&lt;/testSourceDirectory&gt;<br/>     &lt;plugins&gt;<br/>         &lt;plugin&gt;<br/>             &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;<br/>             &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br/>             &lt;version&gt;${kotlin.version}&lt;/version&gt;<br/><br/>             &lt;executions&gt;<br/>                 &lt;execution&gt;<br/>                     &lt;id&gt;compile&lt;/id&gt;<br/>                     &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt;<br/>                 &lt;/execution&gt;<br/><br/>                 &lt;execution&gt;<br/>                     &lt;id&gt;test-compile&lt;/id&gt;<br/>                     &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt;<br/>                 &lt;/execution&gt;<br/>             &lt;/executions&gt;<br/>         &lt;/plugin&gt;<br/>     &lt;/plugins&gt;<br/> &lt;/build&gt;</pre>
<p>You can learn more about the Kotlin Maven configuration in detail on the Kotlin website at <a href="https://kotlinlang.org/docs/reference/using-maven.html">https://kotlinlang.org/docs/reference/using-maven.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring RxJava and RxKotlin</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will also be using RxJava as well as an extension library called <strong>RxKotlin</strong>. For Gradle, add these two libraries as your dependencies like this:</p>
<pre style="padding-left: 60px"> compile 'io.reactivex.rxjava2:rxjava:2.1.0'<br/> compile 'io.reactivex.rxjava2:rxkotlin:2.0.2'</pre>
<p>For Maven, set them up like this:</p>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/>     &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;<br/>     &lt;artifactId&gt;rxjava&lt;/artifactId&gt;<br/>     &lt;version&gt;2.1.0&lt;/version&gt;<br/> &lt;/dependency&gt;<br/> &lt;dependency&gt;<br/>     &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;<br/>     &lt;artifactId&gt;rxkotlin&lt;/artifactId&gt;<br/>     &lt;version&gt;2.0.2&lt;/version&gt;<br/> &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin basics</h1>
                </header>
            
            <article>
                
<p>Although Kotlin has a standalone compiler and can work with Eclipse, we are going to use Intellij IDEA.</p>
<p>A Kotlin project is structured much like a Java project. Following a standard Maven convention, you typically put your Kotlin source code in a <kbd>/src/main/kotlin/</kbd> folder instead of a <kbd>/src/main/java/</kbd> folder. The Kotlin source code is stored in text files with a <kbd>.kt</kbd> extension instead of <kbd>.java</kbd>. However, Kotlin files do not have to contain a class sharing the same name as the file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Kotlin file</h1>
                </header>
            
            <article>
                
<p>In Intellij IDEA, import your Kotlin project, if you haven't already. Right-click on the <kbd>/src/main/kotlin/</kbd> folder and navigate to <span class="packt_screen">New</span> |<span class="packt_screen"> </span><span class="packt_screen">Kotlin File/Class</span>,<span class="packt_screen"> </span>as shown <span>in the following figure:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="351" width="439" class="image-border" src="assets/9deda38b-b7b8-4ab7-825b-4673d98c4a1e.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><strong>Figure 12.1: </strong>Creating a new Kotlin file</div>
<p>In the following dialog, name the file <kbd>Launcher</kbd> and then click on <span class="packt_screen">OK</span>. You should now see the <kbd>Launcher.kt</kbd> file in the <span class="packt_screen">Project</span> pane. Double-click on it to open the editor. Write the following <kbd>"Hello World"</kbd> Kotlin code, as shown here, and then run it by clicking on the <span class="packt_screen">K</span> icon in the gutter:</p>
<div class="CDPAlignCenter CDPAlign"><img height="223" width="393" class="image-border" src="assets/969d45bd-ff75-4855-a40b-46f2c86789b8.png"/></div>
<p>This is our first Kotlin application. Kotlin uses "functions" instead of methods, but it has a <kbd>main()</kbd> function just like Java has a <kbd>main()</kbd> method. Note that we do not have to house our <kbd>main()</kbd> function in a Java class. This is one benefit of Kotlin. Although it does compile to Java bytecode, you are not restricted to only object-oriented conventions and can be procedural or functional as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assigning properties and variables</h1>
                </header>
            
            <article>
                
<p>To declare a variable or property, you must decide whether to make it mutable or not. Preceding a variable declaration with a <kbd>val</kbd> will make it only assignable once, whereas <kbd>var</kbd> is mutable and can be reassigned a value multiple times. The name of the variable then follows with a colon separating it from the type. Then, you can assign a value if you have it on hand. I<span>n the following code</span>, we assign a variable for an <kbd>Int</kbd> and a <kbd>String</kbd> and print them in an interpolated string:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>     val myInt: Int = 5<br/>     val myString: String = "Alpha"<br/><br/>     println("myInt=$myInt and myString=$myString")<br/> }</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">myInt=5 and myString=Alpha</pre>
<p>Kotlin's compiler is pretty smart and does not always have to have the type explicitly declared for variables and properties. If you assign it a value immediately, it will infer the type from that value. Therefore, we can remove the type declarations as follows:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>     val myInt = 5 <em>//infers type as `Int`</em><br/>     val myString = "Alpha" <em>//infers type as `String`</em><br/><br/>     println("myInt=$myInt and myString=$myString")<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extension functions</h1>
                </header>
            
            <article>
                
<p>When you are doing RxJava work in Kotlin, something that is immensely helpful is creating extension functions. We will cover specifically how later, but here is a nonreactive example.</p>
<p>Say we want to add a convenient function to <kbd>LocalDate</kbd> in order to quickly compute the number of days to another <kbd>LocalDate</kbd>. Rather than invoking verbose helper classes to do this task repeatedly, we can quickly add an extension function to <kbd>LocalDate</kbd> called <kbd>numberOfDaysTo()</kbd>, as shown here. This does not extend <kbd>LocalDate</kbd> but rather lets the compiler resolve it as a static method:</p>
<pre style="padding-left: 60px"> import java.time.LocalDate<br/> import java.time.temporal.ChronoUnit<br/><br/> fun main(args: Array&lt;String&gt;) {<br/>     val startDate = LocalDate.of(2017,5,1)<br/>     val endDate = LocalDate.of(2017,5,11)<br/><br/>     val daysBetween = startDate.numberOfDaysTo(endDate)<br/><br/>     println(daysBetween)<br/> }<br/><br/> fun LocalDate.numberOfDaysTo(otherLocalDate: LocalDate): Long {<br/>     return ChronoUnit.DAYS.between(this, otherLocalDate)<br/> }</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">10</pre>
<p>An extension function is just like a normal function in Kotlin, but you immediately declare the type you are adding the function to, followed by a dot, and then the extension function name (for example, fun <kbd>LocalDate.numberOfDaysTo()</kbd>). In the block that follows, it will treat the targeted <kbd>LocalDate</kbd> as <kbd>this</kbd>, just as if it was inside the class. But again, it resolves all this as a static method upon compilation. Kotlin magically abstracts this away for you.</p>
<p>This allows you to create a more fluent DSL (domain-specific language) that is streamlined for your particular business. As an added bonus, Intellij IDEA will show this extension function in the autocompletion as you work with <kbd>LocalDate</kbd>.</p>
<p> </p>
<p>Since the body of this extension function is only one line, you can actually use the equals(=) syntax to declare a function more succinctly and omit the return keyword as well as the explicit type declaration, as shown in the following code:</p>
<p> </p>
<pre style="padding-left: 60px">fun LocalDate.numberOfDaysTo(otherLocalDate: LocalDate) =<br/>         ChronoUnit.DAYS.between(this, otherLocalDate)</pre>
<p>As we will see soon, Kotlin extension functions are a powerful tool to add new operators to Observables and Flowables, and they offer much more flexibility and convenience than <kbd>compose()</kbd> and <kbd>lift()</kbd>. But first, let's look at Kotlin lambdas.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin lambdas</h1>
                </header>
            
            <article>
                
<p>I could spend a lot of time deconstructing lambdas in Kotlin, but in the interest of "getting to the point", I will show how they are expressed in the context of RxJava. You can learn about Kotlin lambdas in depth on the Kotlin reference site (<a href="https://kotlinlang.org/docs/reference/lambdas.html">https://kotlinlang.org/docs/reference/lambdas.html</a>).</p>
<p>Kotlin offers a few more ways to express lambdas than Java 8, and it also uses curly brackets <kbd>{ }</kbd> instead of round brackets <kbd>( )</kbd> to accept lambda arguments into functions. The following is how we express an <kbd>Observable</kbd> chain emitting strings and then map and print their lengths:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gama", "Delta", "Epsilon")<br/>             .map { s: String -&gt; s.length }<br/>             .subscribe { i: Int -&gt; println(i) }<br/> }</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px"> 5<br/> 4<br/> 4<br/> 5<br/> 7</pre>
<p>Note how we express our lambda arguments for <kbd>map()</kbd> and <kbd>subscribe()</kbd>. This feels weird at first, using the curly brackets <kbd>{ }</kbd> to accept lambda arguments, but it does not take long before it feels pretty natural. They help make a distinction between stateful arguments and functional ones. You can put rounded brackets around them if you like, but this is messy and is only needed if you need to pass multiple lambda arguments (for operators such as <kbd>collect()</kbd>):</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gama", "Delta", "Epsilon")<br/>             .map( { s: String -&gt; s.length } )<br/>             .subscribe( { i: Int -&gt; println(i) } )<br/> }</pre>
<p>As said earlier, the Kotlin compiler is smart when it comes to type inference. So most of the time, we do not need to declare our lambda <kbd>s</kbd> or <kbd>i</kbd> parameters as <kbd>String</kbd> and <kbd>Int</kbd>. The compiler can figure that out for us, as shown in the following code:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gama", "Delta", "Epsilon")<br/>             .map { s -&gt; s.length }<br/>             .subscribe { i -&gt; println(i) }<br/> }</pre>
<p>Even better, these are simple one-parameter lambdas, so we do not even have to name these parameters. We can omit them entirely and refer to them using the <kbd>it</kbd> keyword as shown next:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gama", "Delta", "Epsilon")<br/>             .map { it.length }<br/>             .subscribe { println(it) }<br/> }</pre>
<p>Similar to Java 8, we can also use a function-reference syntax. If we are simply passing our arguments exactly in the same manner and order to a function or a constructor, we can use a double-colon <kbd>::</kbd> syntax, as shown here. Note that we <em>do</em> use rounded brackets here:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gama", "Delta", "Epsilon")<br/>             .map(String::length)<br/>             .subscribe(::println)<br/> }</pre>
<p>Something else that is interesting about Kotlin lambda arguments is that when you have multiple arguments where the last one is a lambda, you can put a lambda expression outside the rounded parentheses. In the following code, <kbd>scan()</kbd> emits the rolling total of string lengths and provides a seed value of <kbd>0</kbd>. However, we can put the final lambda argument outside of the rounded parentheses <kbd>( )</kbd>:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable<br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gama", "Delta", "Epsilon")<br/>             .map { s: String -&gt; s.length }<br/>             .scan(0) { total, next -&gt; total + next }<br/>             .subscribe {<br/>                 println("Rolling sum of String lengths is $it")<br/>             }<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extension operators</h1>
                </header>
            
            <article>
                
<p>As covered earlier, Kotlin provides extension functions. These can be an enormously helpful alternative to using just <kbd>compose()</kbd> and <kbd>lift()</kbd>.</p>
<p>For instance, we could not use Transformers and <kbd>compose()</kbd> to turn an <kbd>Observable&lt;T&gt;</kbd> into a <kbd>Single&lt;R&gt;</kbd>. But this is more than doable with Kotlin extension functions. In the following code, we create a <kbd>toSet()</kbd> operator and add it to <kbd>Observable&lt;T&gt;</kbd>:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable<br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>     val source = Observable.just("Alpha", "Beta", "Gama", "Delta",<br/>    "Epsilon")<br/><br/>     val asSet = source.toSet()<br/><br/> }<br/><br/> fun &lt;T&gt; Observable&lt;T&gt;.toSet() =<br/>         collect({ HashSet&lt;T&gt;() }, { set, next -&gt; set.add(next) })<br/>         .map { it as Set&lt;T&gt; }</pre>
<p>The <kbd>toSet()</kbd>returns a <kbd>Single&lt;Set&lt;T&gt;&gt;</kbd>, and it was called on an <kbd>Observable&lt;T&gt;</kbd>. In the extension function, the <kbd>collect()</kbd> operator is called on the invoked <kbd>Observable</kbd>, and then it cast the <kbd>HashSet</kbd> to a <kbd>Set</kbd> so the implementation is hidden. As you can see, it is easy to create new operators and make them easy to discover.</p>
<p>You can also make extension functions target only certain generic types. For example, I can create a <kbd>sum()</kbd> extension function that only targets <kbd>Observable&lt;Int&gt;</kbd> (<kbd>Int</kbd> is the Integer/int abstraction type in Kotlin). It will only be valid when used with an <kbd>Observable</kbd> emitting integers and can only compile or show up in autocomplete for that type:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable<br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>     val source = Observable.just(100, 50, 250, 150)<br/><br/>     val total = source.sum()<br/> }<br/><br/> fun Observable&lt;Int&gt;.sum() =<br/>       reduce(0) { total, next -&gt; total + next }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using RxKotlin</h1>
                </header>
            
            <article>
                
<p>There is a small library called RxKotlin (<a href="https://github.com/ReactiveX/RxKotlin/">https://github.com/ReactiveX/RxKotlin/</a>), which we made a dependency at the beginning of this chapter. At the time of writing this, it is hardly a complex library but rather a small collection of convenient extension functions for common reactive conversions. It also attempts to standardize some conventions when using RxJava with Kotlin.</p>
<p>For instance, there are the <kbd>toObservable()</kbd> and <kbd>toFlowable()</kbd> extension functions that can be invoked on iterables, sequences, and a few other sources. In the following code, instead of using <kbd>Observable.fromIterable()</kbd> to turn a <kbd>List</kbd> into an <kbd>Observable</kbd>, we just call its <kbd>toObservable()</kbd> extension function:</p>
<pre style="padding-left: 60px">import io.reactivex.rxkotlin.toObservable<br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>     val myList = listOf("Alpha", "Beta", "Gamma", "Delta", <br/>     "Epsilon")<br/><br/>     myList.toObservable()<br/>             .map(String::length)<br/>             .subscribe(::println)<br/> }</pre>
<p>There are some other extensions in RxKotlin worth exploring, and you can view it all on the GitHub page. The library is deliberately small and focused since it is easy to clutter an API with every extension function for every task possible. But it holds the functionality for common tasks such as the preceding one.</p>
<p>RxKotlin also has useful helpers to get around the SAM problem that exists between Java and Kotlin (you might have noticed this issue if you have been experimenting already). We will cover this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with SAM ambiguity</h1>
                </header>
            
            <article>
                
<p>At the time of writing this, there is a nuance when Kotlin invokes Java libraries with functional parameters. This problem especially rears its head in RxJava 2.0 when many parameter overloads are introduced. Kotlin does not have this issue when invoking Kotlin libraries but it does with Java libraries. When there are multiple argument overloads for different functional SAM types on a given Java method, Kotlin gets lost in its inference and needs help. Until JetBrains resolves this issue, you will need to work around this either by being explicit or using RxKotlin's helpers.</p>
<p>Here is a notorious example: The <kbd>zip()</kbd> operator. Try to do a simple zip here and you will get a compile error due to failed inference:</p>
<p> </p>
<pre style="padding-left: 60px">import io.reactivex.Observable<br/><br/>fun main(args: Array&lt;String&gt;) {<br/><br/>     val strings = Observable.just("Alpha", "Beta", "Gamma",<br/>     "Delta")<br/>     val numbers = Observable.range(1,4)<br/><br/>     <em>//compile error, can't infer parameters</em><br/>     val zipped = Observable.zip(strings, numbers) { s,n -&gt; "$s $n" }<br/><br/>     zipped.subscribe(::println)<br/> }</pre>
<p>One way to resolve this is to explicitly construct the SAM type with your lambda. In this case, we need to tell the compiler that we are giving it a <kbd>BiFunction&lt;String,Int,String&gt;</kbd>, as shown here:</p>
<p> </p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.functions.BiFunction<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val strings = Observable.just("Alpha", "Beta", "Gamma",<br/>     "Delta")<br/>     val numbers = Observable.range(1,4)<br/><br/>     val zipped = Observable.zip(strings, numbers,<br/>             BiFunction&lt;String,Int,String&gt; { s,n -&gt; "$s $n" }<br/>     )<br/><br/>     zipped.subscribe(::println)<br/> }</pre>
<p>Unfortunately, this is pretty verbose. Many use RxJava and Kotlin to have less code, not more, so this is not ideal. Thankfully, RxKotlin provides some utilities to work around this issue. You can use the Observables, Flowables, Singles, and Maybes utility classes to invoke implementations of the factories affected by the SAM problem. Here is our example using this approach:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.rxkotlin.Observables<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val strings = Observable.just("Alpha", "Beta", "Gamma",<br/>     "Delta")<br/>     val numbers = Observable.range(1,4)<br/><br/>     val zipped = Observables.zip(strings, numbers) { s, n -&gt; "$s $n" }<br/><br/>     zipped.subscribe(::println)<br/> }</pre>
<p>There are also extension functions for non-factory operators affected by the SAM issue. The following is our example using a <kbd>zipWith()</kbd> extension function that successfully performs inference with our Kotlin lambda argument. Note that we have to import this extension function to use it:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.rxkotlin.zipWith<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val strings = Observable.just("Alpha", "Beta", "Gamma",<br/>     "Delta")<br/>     val numbers = Observable.range(1,4)<br/><br/>     val zipped = strings.zipWith(numbers) { s, n -&gt; "$s $n" }<br/><br/>     zipped.subscribe(::println)<br/> }</pre>
<p>It should also be pointed out that <kbd>subscribe()</kbd> on Single and Maybe is affected by the SAM ambiguity issue as well, so there are <kbd>subscribeBy()</kbd> extensions to cope with it, as shown next:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.rxkotlin.subscribeBy<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")<br/>             .count()<br/>             .subscribeBy { println("There are $it items") }<br/> }</pre>
<p>Try not to let the issue of SAM ambiguity deter you from trying Kotlin. It is a nuance when interoperating Kotlin lambdas with Java SAM types. The issue has been acknowledged by JetBrains and should be temporary. Also, there has been a discussion in the Kotlin community to create a ReactiveX implementation in pure Kotlin for other reasons, and we will touch on the future of RxKotlin at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using let() and apply()</h1>
                </header>
            
            <article>
                
<p>In Kotlin, every type has a <kbd>let()</kbd> and <kbd>apply()</kbd> extension function. These are two simple but helpful tools to make your code more fluent and expressive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using let()</h1>
                </header>
            
            <article>
                
<p><kbd>let()</kbd> simply accepts a lambda that maps the invoked object <kbd>T</kbd> to another object <kbd>R</kbd>. It is similar to how RxJava offers the <kbd>to()</kbd> operator, but it applies to any type <kbd>T</kbd> and not just Observables/Flowables. For example, we can call <kbd>let()</kbd> on a string that has been lowercased and then immediately do any arbitrary transformation on it, such as concatenating its <kbd>reversed()</kbd> string to it. Take a look at this operation:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/><br/>     val str = "GAMMA"<br/><br/>     val lowerCaseWithReversed = str.toLowerCase().let { it + " " +<br/>     it.reversed() }<br/><br/>     println(lowerCaseWithReversed)<br/> }</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">gamma ammag</pre>
<p>The <kbd>let()</kbd> comes in handy when you do not want to save a value to a variable just so you can refer to it multiple times. In the preceding code, we did not have to save the result of <kbd>toLowerCase()</kbd> to a variable. Instead, we just immediately called <kbd>let()</kbd> on it to do what we need.</p>
<p>In an RxJava context, the <kbd>let()</kbd> function can be helpful in quickly taking an <kbd>Observable</kbd>, forking it, and then recombining it using a combine operator. In the following code, we multicast an <kbd>Observable</kbd> of numbers to a <kbd>let()</kbd> operator, which creates a sum and a count, and then returns the result of the <kbd>zipWith()</kbd> operator that uses both to find the average:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.rxkotlin.subscribeBy<br/> import io.reactivex.rxkotlin.zipWith<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val numbers =<br/>             Observable.just(180.0, 160.0, 140.0, 100.0, 120.0)<br/><br/>     val average = numbers.publish()<br/>             .autoConnect(2)<br/>             .let {<br/>                 val sum = it.reduce(0.0) { total, next -&gt; total +<br/>                 next}<br/>                 val count = it.count()<br/><br/>                 sum.zipWith(count) { s, c -&gt; s / c }<br/>             }<br/><br/>     average.subscribeBy(::println)<br/> }</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">140.0</pre>
<p>The last line in <kbd>let()</kbd> is what gets returned and does not require a return keyword.</p>
<p>In summary, <kbd>let()</kbd> is a powerful and simple tool to fluently convert an item into another item. Using it to fork an <kbd>Observable</kbd> or <kbd>Flowable</kbd> streams and then joining them again is one helpful application for it in RxJava.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using apply()</h1>
                </header>
            
            <article>
                
<p>A tool similar to <kbd>let()</kbd> is <kbd>apply()</kbd>. Instead of turning a <kbd>T</kbd> item into an <kbd>R</kbd> item,which <kbd>let()</kbd> does, <kbd>apply()</kbd> executes a series of actions against the <kbd>T</kbd> item instead, before returning the same <kbd>T</kbd> item itself. This is helpful in declaring an item <kbd>T</kbd> but doing tangential operations on it without breaking the declaration/assignment flow.</p>
<p>Here is a nonreactive example. We have a simple class, <kbd>MyItem</kbd>, which has a <kbd>startProcess()</kbd> function. We can instantiate <kbd>MyItem</kbd> but use <kbd>apply()</kbd> to call this <kbd>startProcess()</kbd> method before assigning <kbd>MyItem</kbd> to a variable, as shown in the following code:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/><br/>     val myItem = MyItem().apply {<br/>         startProcess()<br/>     }<br/><br/> }<br/><br/> class MyItem {<br/><br/>     fun startProcess() = println("Starting Process!")<br/> }</pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Starting Process!</pre>
<p>In RxJava, <kbd>apply()</kbd> is helpful in adding an Observer or Subscriber in the middle of an <kbd>Observable</kbd>/<kbd>Flowable</kbd> chain but not breaking the flow from the primary task at hand. This can be helpful in emitting status messages to a separate stream.</p>
<p>In the following code, we emit five 1-second intervals and multiply each one. However, we create a <kbd>statusObserver</kbd> and subscribe to it within <kbd>apply()</kbd> right before the multiplication. We multicast before <kbd>apply()</kbd> as well so emissions are pushed to both destinations:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.subjects.PublishSubject<br/> import java.util.concurrent.TimeUnit<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val statusObserver = PublishSubject.create&lt;Long&gt;()<br/>     statusObserver.subscribe { println("Status Observer: $it") }<br/><br/>     Observable.interval(1, TimeUnit.SECONDS)<br/>             .take(5)<br/>             .publish()<br/>             .autoConnect(2)<br/>             .apply {<br/>                 subscribe(statusObserver)<br/>             }<br/>             .map { it * 100 }<br/>             .subscribe {<br/>                 println("Main Observer: $it")<br/>             }<br/><br/>     Thread.sleep(7000)<br/> }</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px"> Status Observer: 0<br/> Main Observer: 0<br/> Status Observer: 1<br/> Main Observer: 100<br/> Status Observer: 2<br/> Main Observer: 200<br/> Status Observer: 3<br/> Main Observer: 300<br/> Status Observer: 4<br/> Main Observer: 400</pre>
<p>So again, <kbd>apply()</kbd> is helpful in taking a multicasted stream of emissions and pushing them to multiple Observers without having any intermediary variables.</p>
<div class="packt_tip">Similiar to <kbd>apply()</kbd> is the extension function <kbd>run()</kbd>, which executes a series of actions but has a void return type (or in Kotlin-speak, Unit). There is also <kbd>with()</kbd>, which is identical to <kbd>run()</kbd> except than it is not an extension function. It accepts the targeted item as an argument.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuples and data classes</h1>
                </header>
            
            <article>
                
<p>Kotlin supports Tuples to a small degree, but it also offers something even better with data classes. We will look at both of these in an RxJava context.</p>
<p>Kotlin supports the quick creation of a Pair containing two items (which can be of differing types). This is a simple two-value, but statically-typed, tuple. You can construct one quickly by putting the <kbd>to</kbd> keyword between two values. This is helpful in doing <kbd>zip()</kbd> operations between two streams, and you just want to pair the two items together.</p>
<p>In the following code, we zip a stream of string items with a stream of <kbd>Int</kbd> items and put each pair into <kbd>Pair&lt;String,Int&gt;</kbd>.</p>
<pre style="padding-left: 60px">import io.reactivex.Observable<br/>import io.reactivex.rxkotlin.Observables<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val strings = Observable.just("Alpha", "Beta", "Gamma",<br/>     "Delta")<br/>     val numbers = Observable.range(1,4)<br/><br/>     <em>//Emits Pair&lt;String,Int&gt;</em><br/>     Observables.zip(strings, numbers) { s, n -&gt; s to n }<br/>             .subscribe {<br/>                 println(it)<br/>             }<br/> }</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px"> (Alpha, 1)<br/> (Beta, 2)<br/> (Gamma, 3)<br/> (Delta, 4)</pre>
<p>An even better approach is to use a data class. A data class is a powerful Kotlin tool that works just like a class, but it automatically implements <kbd>hashcode()</kbd>/<kbd>equals()</kbd>, <kbd>toString()</kbd>, as well as a nifty <kbd>copy()</kbd> function that allows you to clone and modify properties onto a new instance of that class.</p>
<p>But for now, we will just use a data class as a cleaner approach than a <kbd>Pair</kbd> because we actually give each property a name instead of <kbd>first</kbd> and <kbd>second</kbd>. In the following code, we will create a <kbd>StringAndNumber</kbd> data class and use it to zip each pair of values:</p>
<pre style="padding-left: 60px"> import io.reactivex.Observable<br/> import io.reactivex.rxkotlin.Observables<br/><br/> fun main(args: Array&lt;String&gt;) {<br/><br/>     val strings = Observable.just("Alpha", "Beta", "Gamma",<br/>     "Delta")<br/>     val numbers = Observable.range(1,4)<br/><br/>     data class StringAndNumber(val myString: String, val myNumber: Int)<br/><br/>     Observables.zip(strings, numbers) { s, n -&gt; StringAndNumber(s,n) }<br/>             .subscribe {<br/>                 println(it)<br/>             }<br/> }</pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px"> StringAndNumber(myString=Alpha, myNumber=1)<br/> StringAndNumber(myString=Beta, myNumber=2)<br/> StringAndNumber(myString=Gamma, myNumber=3)<br/> StringAndNumber(myString=Delta, myNumber=4)</pre>
<p>Data classes (as well as just plain Kotlin classes) are quick and easy to declare, so you can use them tactically for even small tasks. Use them to make your code clearer and easier to maintain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future of ReactiveX and Kotlin</h1>
                </header>
            
            <article>
                
<p>Kotlin is a powerful and pragmatic language. JetBrains put in a lot of effort not only to make it effective, but also compatible with existing Java code and libraries. Despite a few rough patches such as SAM lambda inference, they did a phenomenal job making Java and Kotlin work together. However, even with this solid compatibility, many developers become eager to migrate entirely to Kotlin to leverage its functionality. Named parameters, optional parameters, nullable types, extension functions, inline functions, delegates, and other language features make Kotlin attractive for exclusive use. Not to mention, JetBrains has successfully made Kotlin compilable to JavaScript and will soon support LLVM native compilation. Libraries built in pure Kotlin can potentially be compiled to all these platforms. To solidify Kotlin's position even further, Google officially established it as the next supported language for Android.</p>
<p>So this begs the question: would there the benefit in creating a ReactiveX implementation in pure Kotlin and not rely on RxJava? After all, the Kotlin language has a powerful set of features that could offer a lot to a ReactiveX implementation and bring it to multiple platforms Kotlin will compile to. It would also create a ReactiveX experience optimized for Kotlin, supporting nullable type emissions, extension operators, and coroutine-based concurrency.</p>
<p>Coroutines provide an interesting and useful abstraction to quickly (and more safely) implement concurrency into a Kotlin application. Because coroutines support task suspension, they provide a natural mechanism to support backpressure. In the event that a ReactiveX implementation in Kotlin is pursued, coroutines can play a huge part in making backpressure simple to implement.</p>
<div class="packt_infobox">If you want to learn about how Kotlin coroutines can be leveraged to create a ReactiveX implementation in Kotlin, read Roman Elizarov's fascinating article at <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md">https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md</a>.</div>
<p>So yes, there could be a lot to gain by making a ReactiveX implementation in pure Kotlin. At the time of writing this, this conversation is getting more traction in the Kotlin community. Keep an eye out as people continue to experiment and proof-of-concepts creep toward prototypes and then the official release.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered how to use RxJava for Kotlin. The Kotlin language is an exciting opportunity to express code on the JVM more pragmatically, and RxJava can leverage many of its useful features. Extension functions, data classes, RxKotlin, and functional operators such as <kbd>let()</kbd>/<kbd>apply()</kbd> allow you to express your reactive domain more easily. Although SAM inference can cause you to hit snags, you can leverage RxKotlin's helper utilities to get around this issue until JetBrains creates a fix. Down the road, it will be interesting to see if a ReactiveX implementation in pure Kotlin appears. Such an implementation would bring in a lot of functionality that Kotlin allows and Java does not.</p>
<p>This is the end! If you have covered this book cover-to-cover, congrats! You should have a strong foundation to leverage RxJava in your workplace and projects. Reactive programming is a radically different approach to problem solving, but it is radically effective too. Reactive programming will continue to grow in pertinence and shape the future of how we model code. Being on this cutting edge will make you not only marketable, but also a leader for the years to come.</p>


            </article>

            
        </section>
    </body></html>