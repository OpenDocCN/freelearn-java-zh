- en: Chapter 9. Building Reactive Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern web applications increasingly require us to move from static web content
    to a more dynamic paradigm where a lot of integration happens in the background
    and the user interaction is more and more sophisticated. At the same time, the
    provided online services need to adapt to the changing business requirements and
    scale to elastic loads, that is, handling peak hour traffic. Finally, in addition
    to the service they provide, web applications now tend to collect extra information
    concerning user interaction to better understand customer behavior. In this chapter,
    we are going to tackle the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what makes applications reactive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the processing of streams in Play Framework with the *Iteratees*
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reactive applications including web sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing reactive applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional pull model adopted by the Web, which is used to browse HTML
    pages now needs to be seconded by two-way communication. This includes a push
    model where users, for example, receive confirmation of asynchronous and long-running
    services or just get notifications of various natures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recently created Reactive Manifesto, which is available at [http://www.reactivemanifesto.org](http://www.reactivemanifesto.org),
    aims to summarize the criteria that characterize reactive applications in a technology-agnostic
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**React to events**: Message-passing architecture, not wasting the time waiting
    for resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React to load**: Focuses on scalability by avoiding contention on shared
    resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React to failure**: Build resilient systems with the ability to recover at
    all levels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React to users**: Honor response time guarantees regardless of load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without going into the details of the manifesto that you are encouraged to read,
    we can directly see that the notion of message-driven architecture, which was
    used by Akka in the previous chapter, fits very well with this reactive model.
    In the following sections, we are going to focus on examples of building such
    web applications on top of the Play Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Handling streams reactively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you need to consume and transform streams of data in web applications,
    such as watching stock updates or monitoring log activities on a service, you
    need mechanisms to manipulate chunks of data that can be pushed from a server
    to a browser, for instance, using Comet ([http://en.wikipedia.org/wiki/Comet_(programming)](http://en.wikipedia.org/wiki/Comet_(programming)))
    or WebSocket ([http://en.wikipedia.org/wiki/WebSocket](http://en.wikipedia.org/wiki/WebSocket))
    technologies. The `Iteratee` pattern available within the Play framework is such
    a mechanism. It was borrowed from the Haskell functional language initially.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Iteratees in Play
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `Iteratee` construct aims at providing a composable and nonblocking way of
    handling streams produced by its counterpart called `Enumerator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s launch a Scala REPL to explore the `Iteratee`/`Enumerator` constructs
    in more detail. To create a new play project as we have done several times before,
    notably in [Chapter 5](ch05.html "Chapter 5. Getting Started with the Play Framework"),
    *Getting Started with the Play Framework*, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will remind ourselves how an iteration is done within an imperative
    language such as Java. The following statements written in Scala describe the
    use of a mutable variable `total` that will be updated at each step of the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As explained in the blog post available at [http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/](http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/),
    we need to take care of the following when iterating:'
  prefs: []
  type: TYPE_NORMAL
- en: The state of the iteration (are there more elements to follow or is it finished)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A context (here the total accumulator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action, updating the context, that is, the total += iterator.next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have seen in [Chapter 1](ch01.html "Chapter 1. Programming Interactively
    within Your Project"), *Programming Interactively within Your Project,* that we
    can implement the same operation in a concise and more functional way by using
    the `foldLeft` Scala construct in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `foldLeft` construct is a powerful construct that is applied to Scala collections
    such as `Lists`. If we want to process other forms of input such as a file, a
    network, a database connection, or a flow produced by an Akka actor for instance,
    then the `Enumerator/Iteratee` comes into play. An `Enumerator` construct can
    be seen as the producer of data (similar to the previous `List` ) and an `Iteratee`
    as the consumer of that data, processing each step of the iteration. The preceding
    example involving the `foldLeft` method on a `List` could just be rewritten using
    an `Enumerator/Iteratee` construct. As the `iteratee` library is already available
    within Play, it can be imported directly by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the *iteratee* library and a global execution context for the
    `iteratee` variables to work with, we can define our first `Enumerator` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iteratee` variable defined as follows indicates the computation step to
    be performed while accepting an input from the `enumerator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the `enumerator` construct with the `iteratee` construct is a matter
    of invoking the `run` method of `enumerator` that takes the `iteratee` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have an asynchronous computation, we get back a `result` as a `Future`
    that we can display once it is completed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enumerator` object mentioned previously was an enumerator of integers.
    We can create producers of data of many different types, such as strings or double
    values. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the creation of an Enumerator from a file, let''s add a little
    text file named `samplefile.txt` in the root of the current project containing,
    for instance, the following three lines of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You may use a separate console window to create this file while leaving the
    REPL running in the original console window. Otherwise, you will have to rerun
    the import statements. Creating an `Enumerator` from a file is shown in the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Enumerator` even comprises some useful methods. For example, a stream of events
    that are generated at regular intervals each time the `Promise` object, which
    contains the current time, times out (every 500 milliseconds).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In a more general way, we can say that `Enumerator[E]` (read enumerator of
    type E) produces three possible kinds of chunks of data of type E:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Input[E]`: It is a chunk of data of type E, for example, `Input[LogData]`
    is a chunk of `LogData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input.Empty`: It means that the enumerator is empty, for instance, an `Enumerator`
    streaming an empty file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input.EOF`: It means that the enumerator has reached its end, for instance,
    an `Enumerator` construct streaming a file and reaching the end of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the `run` method used to run an `Enumerator` over an `Iteratee`,
    you can also invoke the constructor, that is, the `apply` method of the enumerator
    directly. Notice in the following two commands, the different result types you
    get depending on how you combine `enumerator`/`iteratee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This last `Future` result contains an `Iteratee[Int,Int]`, that is, an `Iteratee[<type
    contained in chunk>, <result of the iteration>]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `Iteratee` consumes all the chunks from the `enumerator` stream
    and returns them as a `List` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples of `Iteratee` that we have seen so far use the method `fold` pretty
    much like the `foldLeft` and the `foldRight` methods that are part of the Scala
    collection. Let''s try to build a more sophisticated `Iteratee`: one that, for
    instance, selects words containing the letter `E` out of the enumerator streams.
    This can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `step` recursive function is using a `total` accumulator variable, that
    is, a context to keep some state at each step of the recursion. This is a list
    of strings containing all the results we are interested in. The second argument
    to the `step` function is the new chunk from the `enumerator` stream that comes
    up at each step. This chunk is matched against the possible states; if either
    the stream is empty or we have reached its end, we return the accumulated result
    in a `Done` state. Otherwise, we handle the incoming element. If the element verifies
    the `if` condition, then we add it to the accumulator and invoke the next step
    in our recursion as part of a `Cont` (continue) state. Otherwise, we just invoke
    the next step without saving the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step initiates the recursion by calling the `step` function
    on the first element of the stream with an empty accumulator. Applying this newly-defined
    `Iteratee` on a simple enumerator looks like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Every computation step performed on an incoming string either appends that string
    to the total accumulator or ignores it, depending on whether it matches the `if`
    condition or not. In this example, it simply checks that the word contains at
    least one `E`.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting Enumerator with Enumeratee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might happen that the data consumed by an `Iteratee` does not match the input
    produced by an `Enumerator`. The role of an `Enumeratee` is to be an adapter that
    sits in between the `Enumerator` and `Iteratee` to transform the incoming data
    before feeding the `Iteratee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of simple transformation from an `Enumerator` to another one,
    we could ,for instance, define an `Enumeratee` that converts an input of the type
    `String` to `Int`, as illustrated by the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The transformation provided by the `Enumeratee` can be declared in its `map`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapting the `Enumerator` can also consist of transforming the input data to
    a different format without changing the type. Considering `wordsWithE` that we
    defined previously, we could apply an `Enumeratee` that converts all the input
    data to uppercase so that the consumption of the stream of data by the `Iteratee`
    would produce a different result than the one obtained without `Enumeratee`. The
    following code illustrates that behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, an `Enumerator` is a producer of a data stream, an `Iteratee`
    a consumer of that data, and an `Enumeratee` an adapter between the two. The *iteratee*
    pattern has been integrated together with the Play Framework as a way to handle
    streams of data reactively in a web application. In the next section, we are going
    to build web applications in such a way, by additionally using WebSockets to communicate
    between the client and the server in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with WebSockets and Iteratees in Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the traditional pull model of getting HTML displayed in a browser
    when querying a service, most web browsers now support bidirectional communication
    via WebSockets so that servers can push data without the user having to query
    for it first. Once a socket is established between client and server, the communication
    can stay open for further interaction, unlike the HTTP protocol. Modern web apps
    are using this feature more and more to push data from streams reactively.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, a **WebSocket** is a protocol providing bidirectional communication
    over a single TCP connection, in contrast to the traditional one-way, stateless
    communication of HTTP (either a request or a response). Let's look at the support
    that Play provides in this area and demonstrate in a short example how to establish
    a WebSocket communication between the Play server and a client browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already created a `ch9samples` Play project at the beginning of
    this chapter to experiment with `Iteratees` in the REPL, we can just reuse it.
    We will start by opening the tiny `controllers/Application.scala` server-side
    class that is available by default. We can add a new `connect` method to it to
    create a WebSocket interaction. In a regular Play controller, a method would normally
    use an `Action` class, as we have seen previously. In this example, we use the
    `WebSocket` class instead, illustrated in the controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the server-side controller seen in the preceding code, the `in` variable
    contains the logic to handle messages coming from the client, and it will produce
    an `Enumerator` to assemble some response data that will be pushed through the
    channel to each client.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, the `views/main.scala.html` view is where we are going
    to add the WebSocket support, as a part of a JavaScript script, whose role is
    to open a web socket and react to incoming messages. as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have both ends, the only remaining step is to define a route for
    the controller''s `connect` method. Edit the `conf/routes` file to make it look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to try the demo by starting the play server from the command
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Opening a browser at `http://localhost:9000/` (preferably one that supports
    WebSockets) and clicking on the **Run WebSocket** link should first confirm that
    the browser is indeed supporting WebSockets. Clicking on **OK** a couple of times
    will first show you that a message has been sent, and then show that the roundtrip
    has been achieved by receiving a message from the server. You should also see
    the `Message to send` log message on the play server prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Learning from activator templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a growing list of reactive applications based on *iteratees* that have
    been packaged and deployed as activator templates. At the time of writing this
    book, we have identified more than five templates and you can look at a few of
    them. They often mix technologies such as WebSockets with Akka for communication
    and message processing and, on the client side, JavaScript frameworks such as
    Angular.js, to often provide simple HTML rendering.
  prefs: []
  type: TYPE_NORMAL
- en: As the Typesafe activator templates HTML page lets you select tags to filter
    out projects depending on some keywords, you may check the appropriate projects
    by selecting the reactive checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive stocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This sample is a project based on the Java version of Play. It graphically
    demonstrates the real-time update of stock values (that are randomly generated
    for simplicity). It contains both Java and Scala code. An Akka `StockActor` actor
    is instantiated for every stock symbol, and its role is to maintain a list of
    all users watching this stock. Some additional functionality queries a twitter
    API to retrieve all tweets matching a particular symbol (for example, [http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl](http://twitter-search-proxy.herokuapp.com/search/tweets?q=appl)).
    This knowledge can then be processed to calculate a sentiment index that should
    help to decide whether to buy this stock or not. The following screenshot illustrates
    graphically what the app looks like, once it is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reactive stocks](img/3637_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reactive real-time search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate some integration between ElasticSearch and the reactive features
    of the Typesafe stack through Play iteratees and Akka, this sample exhibits how
    to push log events to a browser. As a reminder, ElasticSearch ([http://www.elasticsearch.org](http://www.elasticsearch.org))
    is a distributed real-time search and an analytics engine based on the well-established
    Apache Lucene ([https://lucene.apache.org](https://lucene.apache.org)) full-text
    search engine.
  prefs: []
  type: TYPE_NORMAL
- en: It notably provides a **percolation** feature, that notifies your application
    when new content matches your search criteria (instead of having to poll the search
    engine to check regularly for new updates).
  prefs: []
  type: TYPE_NORMAL
- en: To emulate content, an Akka `LogEntryProducerActor` actor is responsible for
    generating random log entries each time it receives a `Tick` message. These messages
    are produced at regular intervals by a `MainSearchActor` actor that also acts
    as a coordinator for the search. Finally, an `ElasticSearchActor` actor implements
    the percolation feature by interacting with an embedded ElasticSearch server (`EmbeddedESServer`)
    that is started from the Play `Global` class. Instead of pushing information to
    the browser via WebSockets, the sample uses **Server Side Events** (**SSE**) as
    it only needs one-way communication once the search criteria are known.
  prefs: []
  type: TYPE_NORMAL
- en: Further information on the template and all the code behind it is available
    at [https://github.com/DrewEaster/realtime-search](https://github.com/DrewEaster/realtime-search).
    In particular, the query syntax to be entered for a search is defined as Lucene
    syntax and is specified at [http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description](http://lucene.apache.org/core/4_3_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package_description).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute this sample by installing and running the activator template
    (with the `> activator run` command from the root of the template project), we
    can open a browser at `localhost:9000` and enter `GET` as the search criterion.
    After a few seconds, some browser output should progressively be displayed, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reactive real-time search](img/3637_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Play-Akka-Angular-WebSocket template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As another example of reactively pushing information to the browser, this sample
    updates a clock on the client by scheduling an actor. The role of this actor is
    to send events in the JSON format via a WebSocket connection by using the Play
    `WebSocket.async[JsValue]` method call. The Angular.js JavaScript framework is
    used on the client side and the GUI looks like the following screenshot once it
    starts running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play-Akka-Angular-WebSocket template](img/3637_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The number of activator templates that illustrate reactive applications is growing.
    Also, you can check out from time to time the new templates that are available,
    without upgrading the version of the activator each time.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Actor Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen a number of projects that are using `Enumerators`/`Iteratees`
    to send and receive messages reactively, with various levels of complexity. `Iteratees`
    are powerful, but using them can sometimes lead to code snippets that are not
    easy to understand. The Play Actor Room project, which is available at [https://github.com/mandubian/play-actor-room](https://github.com/mandubian/play-actor-room),
    proposes to reduce some of the complexity of setting up `Iteratees` by abstracting
    away this part and letting the programmer focus only on the domain logic, such
    as processing incoming messages and assembling outgoing messages. This project
    started from the observation that many applications need the same functionality,
    which can be seen as a server `Room` (holding state, for instance, and being the
    middle man between distributed clients). The role of this room is to listen for
    incoming messages from connected clients, and either broadcast received messages
    after processing them or just unicast communication to a single client. It is
    a good illustration of how an application can react to users/events. Typical applications
    such as a multiuser chat are therefore very straightforward to write, and they
    are one of the two samples given as examples. Let's experiment with the most basic
    use of the actor room support, a sample called `simplest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone the project somewhere on your disk, just enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we can look at the application once it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Opening a browser at the default play port (`http://localhost:9000/`) will show
    you a simple **sign-in** widget, as shown in the following screenshot. Enter your
    name to log in, type a message in the provided text area, and then press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with Actor Room](img/3637_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the console window where you started the actor room application, you should
    now see the logging information printed by the actor that received messages from
    the client browser. The information can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: On opening several browser windows and logging in with different names, you
    can see all the messages hitting the server room, that is, at the console. The
    actor room actually broadcasts the received messages back to all connected browsers,
    although for now there is nothing in the view to handle the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, open the console of one browser to see the display of the
    broadcast messages, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with Actor Room](img/3637_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, invoking the `http://localhost:9000/list/` URL from a third window
    will return the list of currently connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the interesting features of this basic application can be observed once
    we import the project into eclipse (entering the `> play eclipse` command) and
    open the controller that includes the implementation of the receiving `Actor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Receiver` actor that acts as the server has been created by a supervisor
    `Actor`. It handles messages in JSON format. All the default logic of the receiving
    `Actor`, which is the only code that we need to care about for processing messages
    from clients, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that broadcasting the response from the server to all the clients is done
    by the supervising actor referenced by `context.parent`. In the previous logic,
    the `Broadcast` message also includes the originator `from` `ActorRef` reference.
  prefs: []
  type: TYPE_NORMAL
- en: As a small modification to the default room behavior to fit new business requirements,
    we can, for instance, reuse the `TravelAgent`, `Flight`, and `Hotel` actors that
    we created in [Chapter 8](ch08.html "Chapter 8. Essential Properties of Modern
    Applications – Asynchrony and Concurrency"), *Essential Properties of Modern Applications
    – Asynchrony and Concurrency*. We want to provide each user with the ability to
    book a flight, and (at any time) monitor how many seats are still available. To
    do this, we can involve a slightly bigger JSON message as the exchange format
    between the server and client.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful enhancement to Scala that came with Version 2.10 is the notion of
    string interpolation. We already used this feature throughout this book and introduced
    it in [Chapter 1](ch01.html "Chapter 1. Programming Interactively within Your
    Project"), *Programming Interactively within Your Project*. Similarly, JSON interpolation
    has been created as an extension to the JSON support in Play. We can reuse JSON
    interpolation, for instance, to do some elegant pattern matching. Just add the
    following extension dependencies to the `Build.scala` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once in place, the JSON pattern matching feature handles the JSON messages coming
    from the browser client to the `Receiver` actor, as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a `Flight` actor to keep the count of seats available. In a new
    package `actors`, which is directly under the `app/` source directory, we can
    add a `Flight.scala` class that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Rather than creating a mutable state variable `var seatsLeft`, as we did in
    [Chapter 8](ch08.html "Chapter 8. Essential Properties of Modern Applications
    – Asynchrony and Concurrency"), *Essential Properties of Modern Applications –
    Asynchrony and Concurrency*, we encapsulated this state change as an argument
    passed while switching context each time we receive a `BookSeat` message. This
    way of proceeding is a recommended best practice to avoid holding mutable variables.
    We have added a `GetSeatsLeft` message to be able to query the value of the current
    state, in which case the state is sent back to the `sender` actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we can modify the `index.scala.html` view to add a couple
    of simple widgets to our application. In particular, we can add a placeholder
    to display the number of available seats left in the flight. This is the information
    that will be pushed to all connected browsers by the server room actor. An example
    of such a view is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to slightly modify the small JavaScript snippet that handles communication
    between the client browser and the server via the WebSocket so that it handles
    the new JSON format. The modified `websocket.scala.js` file is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `Application.scala` file of the server part, we can extend
    the `Receiver` actor to handle incoming JSON messages and contact the `Flight`
    actor to both update and read the current value of its state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the pieces in place, let''s run the example in a couple
    of browsers. Notice that we have added the `LoggingReceive` call to both the `Receiver`
    and `Flight` actors so that we get extensive logging output once we execute the
    server code. On the command prompt, you may enter the following commands to start
    the Play application with the additional flags to activate the logging output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Open two browser windows (possibly using two different browsers) at the URL
    `http://localhost/9000`. Complete the sign-in step; for instance, use **Alice**
    and **Bob** as names to connect to the actor room from the two browsers, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering the seats that you want to book from either window will update the
    global number of seats left in both windows, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with Actor Room](img/3637_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The console output from the server should display the logging information as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Entering a number of seats that is greater than the number of remaining places
    will not update the counter, and it will end up in a `Fail` message from the `Flight`
    actor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have experimented with the *iteratees* pattern supported
    by the Play Framework to handle streams reactively. We have then used it along
    with WebSockets and Akka to write a small, reactive web application.
  prefs: []
  type: TYPE_NORMAL
- en: The samples of reactive web applications that we have addressed and discussed
    in this chapter are just a glimpse of the endless possibilities of making applications
    that react to events and are resilient to failure and load. As web applications
    grow in complexity, such architectures should gain in popularity and adoption
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to asynchronously process streams in real time is, in our opinion,
    a big competitive advantage if this functionality is built in a manageable and
    maintainable way. This is precisely the goal that the Play Framework combined
    with Akka illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and the last chapter of this book, we are going to consider a few
    areas where we think Scala provides additional, convenient help.
  prefs: []
  type: TYPE_NORMAL
