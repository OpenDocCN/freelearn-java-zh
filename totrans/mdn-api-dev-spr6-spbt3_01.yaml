- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful Web Service Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through the fundamentals of RESTful APIs (or REST
    APIs for short) and their design paradigms. We will take a brief look at the history
    of REST, learn how resources are formed, and understand methods and status codes
    before we move on to exploring **Hypermedia As The Engine Of Application State**
    (**HATEOAS**). These basics should provide a solid platform to enable you to develop
    a RESTful web service. You will also learn the best practices for designing **application
    programming** **interfaces** (**APIs**).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also introduce a sample e-commerce app, which will be used
    throughout the book as you learn about the different aspects of API development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling resources and **Uniform Resource** **Identifiers** (**URIs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring **Hypertext Transfer Protocol** (**HTTP**) methods and status codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is HATEOAS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for designing REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of an e-commerce app (our sample app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not require any specific software. However, knowledge of HTTP
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An API is how a piece of code communicates with another piece of code. You might
    have already written and consumed APIs for your programs; for example, Java provides
    APIs through classes wrapped in different modules, such as collection, input/output,
    and streams.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s SDK APIs allow one part of a program to communicate with another part
    of a program. You can write a function and then expose it with public access modifiers
    so that other classes can use it. That function signature is an API for that class.
    However, APIs that are exposed using these classes or libraries only allow internal
    communication inside a single application or an individual service. So, what happens
    when two or more applications (or services) want to communicate with each other,
    or, in other words, you would like to integrate two or more services? This is
    where system-wide APIs help us.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, there were different ways to integrate one application with another
    – RPC, **Simple Object Access Protocol** (**SOAP**)-based services, and more.
    The integration of apps has become an integral part of software architectures,
    especially after the boom of the cloud and mobile phones. You now have social
    logins, such as Facebook, Google, and GitHub, which means you can develop your
    application even without writing an independent login module and get around security
    issues such as storing passwords securely.
  prefs: []
  type: TYPE_NORMAL
- en: These social logins provide APIs using REST and GraphQL. Currently, REST is
    the most popular, and it has become the standard for writing APIs for integration
    and web app consumption. We’ll also discuss GraphQL in detail in the final chapters
    of this book (in [*Chapter 13*](B19349_13.xhtml#_idTextAnchor288), *Getting Started
    with GraphQL*, and [*Chapter 14*](B19349_14.xhtml#_idTextAnchor313), *GraphQL
    API Development* *and Testing*).
  prefs: []
  type: TYPE_NORMAL
- en: '**REST** stands for **REpresentational State Transfer**, which is a style of
    software architecture. Web services that adhere to the REST style are called RESTful
    web services. In the following sections, we will take a quick look at the history
    of REST to understand its fundamentals.'
  prefs: []
  type: TYPE_NORMAL
- en: The history of REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the adoption of REST, when the internet was just starting to become widely
    known and Yahoo and Hotmail were the popular mail and social messaging apps, there
    was no standard software architecture that offered a homogenous way to integrate
    with web applications. People were using SOAP-based web services, which, ironically,
    were not simple at all.
  prefs: []
  type: TYPE_NORMAL
- en: Then came the light. Roy Fielding, in his doctoral research, *Architectural
    Styles and the Design of Network-Based Software Architectures* ([https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)),
    came up with REST in 2000\. REST’s architecture style allowed any server to communicate
    with any other server over the network. It simplified communication and made integration
    easier. REST was made to work on top of HTTP, which enables it to be used all
    over the web and in internal networks.
  prefs: []
  type: TYPE_NORMAL
- en: eBay was the first to exploit REST-based APIs. It introduced the REST API with
    selected partners in November 2000\. Later, Amazon, Delicious (a site-bookmarking
    web app), and Flickr (the photo-sharing app) started providing REST-based APIs.
    Then, **Amazon Web Services** (**AWS**) took advantage of Web 2.0 (with the invention
    of REST) and provided REST APIs to developers for AWS cloud consumption in 2006.
  prefs: []
  type: TYPE_NORMAL
- en: Later, Facebook, Twitter, Google, and other companies started using it. Nowadays
    (in 2023), you will hardly find any web applications that have been developed
    without a REST API. However, the GraphQL-based API for mobile apps is getting
    close in terms of popularity.
  prefs: []
  type: TYPE_NORMAL
- en: REST fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST works on top of the HTTP protocol. Each URI works as an API resource. Therefore,
    we should use nouns as endpoints instead of verbs. RPC-style endpoints use verbs,
    for example, `/api/v1/getPersons`. In comparison, in REST, this endpoint could
    be simply written as `/api/v1/persons`. You must be wondering, then, how we can
    differentiate between the different actions performed on a REST resource. This
    is where HTTP methods help us. We can make our HTTP methods act as verbs, for
    example, `GET`, `DELETE`, `POST` (for creating), `PUT` (for modifying), and `PATCH`
    (for partial updating). We’ll discuss this in more detail later. For now, the
    `getPerson` RPC-style endpoint is translated into `GET /api/v1/persons` in REST.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The REST endpoint is a unique URI that represents a REST resource. For example,
    `https://demo.app/api/v1/persons` is a REST endpoint. Additionally, `/api/v1/persons`
    is the endpoint path and `persons` is the REST resource.
  prefs: []
  type: TYPE_NORMAL
- en: Here, there is client and server communication. Therefore, REST is based on
    the *client-server* concept. The client calls the REST API and the server responds.
    REST allows a client (that is, a program, web service, or UI app) to talk to a
    remotely (or locally) running server (or web service) using HTTP requests and
    responses. The client sends an API command wrapped in an HTTP request to the web
    service. This HTTP request may contain a payload (or input) in the form of query
    parameters, headers, or request bodies. The called web service responds with a
    success/failure indicator and the response data wrapped inside the HTTP response.
    The HTTP status code normally denotes the status, and the response body contains
    the response data. For example, an HTTP status code of `200 OK` normally represents
    success.
  prefs: []
  type: TYPE_NORMAL
- en: From a REST perspective, an HTTP request is self-descriptive and has enough
    context for the server to process it. Therefore, REST calls are *stateless*. States
    are either managed on the client side or on the server side. A REST API does not
    maintain its state. It only transfers states from the server to the client or
    vice versa. This is why it is called *REpresentational State Transfer*, or REST
    for short.
  prefs: []
  type: TYPE_NORMAL
- en: REST also makes use of HTTP cache control, which makes REST APIs *cacheable*.
    Therefore, the client can also cache the representation (that is, the HTTP response)
    because every representation is self-descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST operates using three key components:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources and URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample REST call in plain text looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `/licenses` path denotes the licenses resource. `GET` is an HTTP method.
    `2` at the end of the first line denotes the HTTP protocol version. The second
    line shares the host to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub responds with a JSON object. The status is `200 OK` and the JSON object
    is wrapped in a response body, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you note the third line in this response, it tells you the value of the content
    type. It is good practice to have JSON as the content type for both the request
    and the response.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the fundamentals of REST, we are
    going to dive a bit deeper into REST’s first concept, resources and URIs, and
    learn what they are and how they are generally used.
  prefs: []
  type: TYPE_NORMAL
- en: Handling resources and URIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every document on the **World Wide Web** (**WWW**) is represented as a resource
    in terms of HTTP. This resource is represented as a URI, which is an endpoint
    that represents a unique resource on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Roy Fielding in his doctoral research states that a URI is known by many names
    – a WWW address, a **Universal Document Identifier** (**UDI**), a URI, a **Uniform
    Resource Locator** (**URL**), and a **Uniform Resource** **Name** (**URN**).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is a URI? A URI is a string (that is, a sequence of characters) that
    identifies a resource by its location, name, or both (in the WWW world). There
    are two types of URIs: URLs and URNs.'
  prefs: []
  type: TYPE_NORMAL
- en: URLs are widely used and even known to non-developer users. URLs are not only
    restricted to HTTP but are also used for many other protocols, such as FTP, JDBC,
    and MAILTO. A URL is an identifier that identifies the network location of a resource.
    We will go into more detail in the later sections.
  prefs: []
  type: TYPE_NORMAL
- en: The URI syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The URI syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the syntax, the following is the list of components of a URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:`). `scheme` starts with a letter and is followed by any combination of digits,
    letters, periods (`.`), hyphens (`-`), or plus characters (`+`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheme examples include HTTP, HTTPS, MAILTO, FILE, and FTP. URI schemes must
    be registered with the **Internet Assigned Numbers** **Authority** (**IANA**).
  prefs: []
  type: TYPE_NORMAL
- en: '`//`. It consists of the following optional subfields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`). In the preceding GitHub REST API example, `/licenses` is the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`). The query component contains a query string of non-hierarchical data.
    Each parameter is separated by an ampersand (`&`) in the query component and parameter
    values are assigned using an equals (`=`) operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#`). The fragment component includes a fragment identifier that gives direction
    to a secondary resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list contains examples of URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.packt.com](http://www.packt.com): This doesn’t contain the scheme. It
    just contains the domain name. There is no port either, which means it points
    to the default port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html`: This contains no scheme nor authority. It only contains the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packt.com/index.html](https://www.packt.com/index.html): This
    contains the scheme, authority, and path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of different scheme URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mailto:support@packt.com](mailto:support@packt.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[telnet://192.168.0.1:23/](telnet://192.168.0.1:23/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ldap://[2020:ab9::9]/c=AB?objectClass?obj](ldap://[2020:ab9::9]/c=AB?objectClass?obj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'From a REST perspective, the path component of a URI is very important because
    it represents the resource path and your API endpoint paths are formed based on
    it. For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET https://www.domain.com/api/v1/order/1`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `/api/v1/order/1` represents the path and `GET` represents the HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: What is a URL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look closely, most of the URI examples mentioned earlier can also be
    called URLs. A URI is an identifier; on the other hand, a URL is not only an identifier,
    but it also tells you how to get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Request for Comments (RFC)
  prefs: []
  type: TYPE_NORMAL
- en: As per RFC-3986 on URIs ([https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)),
    the term URL refers to the subset of URIs that, in addition to identifying a resource,
    provide a means of locating the resource by describing its primary access mechanism
    (for example, its network *location*).
  prefs: []
  type: TYPE_NORMAL
- en: A URL represents the full web address of a resource, including the protocol
    name (the scheme), the hostname port (in case the HTTP port is not `80`; for HTTPS,
    the default port is `443`), part of the authority component, the path, and optional
    query and fragment subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: What is a URN?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'URNs are not commonly used. They are also a type of URI that starts with a
    scheme – `urn`. The following URN example is directly taken from RFC-3986 for
    URIs ([https://www.ietf.org/rfc/rfc3986.txt](https://www.ietf.org/rfc/rfc3986.txt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example follows the `"urn:" <NID> ":" <NSS>` syntax, where `<NID>` is the
    namespace identifier, and `<NSS>` is the namespace-specific string. We are not
    going to use URNs in our REST implementation. However, you can read more about
    them at RFC-2141 ([https://tools.ietf.org/html/rfc2141](https://tools.ietf.org/html/rfc2141)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As per RFC-3986 on URIs ([https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)),
    the term URN has been used historically to refer to both URIs under the “*urn”*
    scheme RFC-2141, which are required to remain globally unique and persistent even
    when the resource ceases to exist or becomes unavailable, and to any other URI
    with the properties of a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the difference between a URI and a URN and how they
    make up URIs, let’s learn about the second concept that makes up REST: HTTP methods
    and status codes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring HTTP methods and status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP provides various HTTP methods. However, you are primarily going to use
    only five of them. To begin with, you want to have **Create**, **Read**, **Update**,
    and **Delete** (**CRUD**) operations associated with HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`: Create or search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: Read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Delete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Partial update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some organizations also provide the `HEAD` method for scenarios where you just
    want to retrieve the header responses from the REST endpoints. You can hit any
    GitHub API with the `HEAD` operation to retrieve only headers; for example, `curl
    --``head https://api.github.com/users`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: REST has no requirement that specifies which method should be used for which
    operation. However, widely used industry guidelines and practices suggest following
    certain rules.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss each method in detail.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP `POST` method is normally what you want to associate with creating
    resource operations. However, there are certain exceptions when you might want
    to use the `POST` method for read operations. However, it should be put into practice
    after a well-thought-out process. One such exception is a search operation where
    the filter criteria have too many parameters, which might cross the `GET` call’s
    length limit.
  prefs: []
  type: TYPE_NORMAL
- en: A `GET` query string has a limit of 256 characters. Additionally, the HTTP `GET`
    method is limited to a maximum of 2,048 characters minus the number of characters
    in the actual path. On the other hand, the `POST` method is not limited by the
    size of the URL for submitting name and value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to use the `POST` method with HTTPS for a read call if the
    submitted input parameters contain any private or secure information.
  prefs: []
  type: TYPE_NORMAL
- en: For successful create operations, you can respond with the `201 Created` status,
    and for successful search or read operations, you should use the `200 OK` or `204
    No Content` status codes, although the call is made using the HTTP `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: For failed operations, REST responses may have different error status codes
    based on the error type, which we will look at later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP `GET` method is what you usually want to associate with read resource
    operations. Similarly, you must have observed the GitHub `GET /licenses` call
    that returns the available licenses in the GitHub system. Additionally, successful
    `GET` operations should be associated with the `200 OK` status code if the response
    contains data, or `204 No Content` if the response contains no data.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP `PUT` method is what you usually want to associate with update resource
    operations. Additionally, successful update operations should be associated with
    a `200 OK` status code if the response contains data, or `204 No Content` if the
    response contains no data. Some developers use the `PUT` HTTP method to replace
    existing resources. For example, GitHub API v3 uses `PUT` to replace the existing
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP `DELETE` method is what you want to associate with resource deletion
    operations. GitHub does not provide the `DELETE` operation on the `licenses` resource.
    However, if you assume it exists, it will certainly look very similar to `DELETE
    / licenses/agpl-3.0`. A successful `DELETE` call should delete the resource associated
    with the `agpl-3.0` key. Additionally, successful `DELETE` operations should be
    associated with the `204 No Content` status code.
  prefs: []
  type: TYPE_NORMAL
- en: PATCH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP `PATCH` method is what you want to associate with partial update resource
    operations. Additionally, successful `PATCH` operations should be associated with
    a `200 OK` status code. `PATCH` is relatively new as compared to other HTTP operations.
    In fact, a few years ago, Spring did not have state-of-the-art support for this
    method for REST implementation due to the old Java HTTP library. However, currently,
    Spring provides built-in support for the `PATCH` method in REST implementation.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five categories of HTTP status codes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Informational responses (`100`–`199`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successful responses (`200`–`299`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirects (`300`–`399`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client errors (`400`–`499`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server errors (`500`–`599`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view a complete list of status codes at MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status))
    or RFC-7231 ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)).
    However, you can find the most commonly used REST response status codes in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP** **Status Code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `200 OK` | For successful requests other than those already created. |'
  prefs: []
  type: TYPE_TB
- en: '| `201 Created` | For successful creation requests. |'
  prefs: []
  type: TYPE_TB
- en: '| `202 Accepted` | The request has been received but not yet acted upon. This
    is used when the server accepts the request, but the response cannot be sent immediately,
    for example, in batch processing. |'
  prefs: []
  type: TYPE_TB
- en: '| `204` `No Content` | For successful operations that contain no data in the
    response. |'
  prefs: []
  type: TYPE_TB
- en: '| `304` `Not Modified` | This is used for caching. The server responds to the
    client that the resource is not modified; therefore, the same cache resource can
    be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `400` `Bad Request` | This is for failed operations when input parameters
    either are incorrect or missing or the request itself is incomplete. |'
  prefs: []
  type: TYPE_TB
- en: '| `401 Unauthorized` | This is for operations that have failed due to unauthenticated
    requests. The specification says it’s unauthorized, but semantically, it means
    unauthenticated. |'
  prefs: []
  type: TYPE_TB
- en: '| `403 Forbidden` | This is for failed operations that the invoker is not authorized
    to perform. |'
  prefs: []
  type: TYPE_TB
- en: '| `404` `Not Found` | This is for failed operations when the requested resource
    doesn’t exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `405 Method` `Not Allowed` | This is for failed operations when the method
    is not allowed for the requested resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `409 Conflict` | This is for failed operations when an attempt is made for
    a duplicate create operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `429 Too` `Many Requests` | This is for failed operations when a user sends
    too many requests in a given amount of time (rate limiting). |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Internal` `Server Error` | This is for failed operations due to server
    errors. It’s a generic error. |'
  prefs: []
  type: TYPE_TB
- en: '| `502` `Bad Gateway` | This is for failed operations when upstream server
    calls fail, for example, when an app calls a third-party payment service, but
    the call fails. |'
  prefs: []
  type: TYPE_TB
- en: '| `503` `Service Unavailable` | This is for failed operations when something
    unexpected has happened at the server, for example, an overload or a service fails.
    |'
  prefs: []
  type: TYPE_TB
- en: We have discussed the key components of REST, such as endpoints in the form
    of URIs, methods, and status codes. Let’s explore HATEOAS, the backbone of REST
    concepts that differentiates it from RPC style.
  prefs: []
  type: TYPE_NORMAL
- en: What is HATEOAS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With HATEOAS, RESTful web services provide information dynamically through hypermedia.
    Hypermedia is a part of the content that you receive from a REST call response.
    This hypermedia content contains links to different types of media, such as text,
    images, and videos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hypermedia links can be contained either in HTTP headers or the response body.
    If you look at GitHub APIs, you will find that GitHub APIs provide hypermedia
    links in both headers and the response body. GitHub uses the header named `Link`
    to contain the paging-related links. Additionally, if you look at the responses
    of GitHub APIs, you’ll also find other resource-related links with keys that have
    a postfix of `url`. Let’s look at an example. We’ll hit the `GET` `/users` resource
    and analyze the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command execution provides an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, you’ll find that the `Link` header contains the pagination
    information. Links to the `next` page and the `first` page are given as a part
    of the response. Additionally, you can find many URLs in the response body, such
    as `avatar_url` or `followers_url`, which provide links to other hypermedia.
  prefs: []
  type: TYPE_NORMAL
- en: REST clients should possess a generic understanding of hypermedia so they can
    interact with RESTful web services without having any specific knowledge of how
    to interact with the server. You just call any static REST API endpoint, and you
    will receive the dynamic links as a part of the response to interact further.
    REST allows clients to dynamically navigate to the appropriate resource by traversing
    the links. It empowers machines, as REST clients can navigate to different resources
    in a similar way to how humans look at a web page and click on any link. Put simply,
    the REST client uses these links to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'HATEOAS is a very important concept of REST. It is one of the concepts that
    differentiate REST from RPC. Even Roy Fielding was so concerned with certain REST
    API implementations that he published the following blog on his website in 2008:
    *REST APIs must be* *hypertext-driven* ([https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)).'
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering what the difference between hypertext and hypermedia is.
    Essentially, hypermedia is just an extended version of hypertext.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between hypermedia and hypertext?
  prefs: []
  type: TYPE_NORMAL
- en: 'As Roy Fielding states: *“When I say hypertext, I mean the simultaneous presentation
    of information and controls such that the information becomes the affordance through
    which the user (or automaton) obtains choices and selects actions. Hypermedia
    is just an expansion on what text means to include temporal anchors within a media
    stream; most researchers have dropped the distinction. Hypertext does not need
    to be HTML on a browser. Machines can follow links when they understand the data
    format and* *relationship types.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with REST, let’s explore REST best practices in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for designing REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is too early to talk about the best practices for implementing APIs. APIs
    are designed first and implemented later. Therefore, you’ll find design-related
    best practices mentioned in the next sections. You’ll also find best practices
    for going forward during REST API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Using nouns and not verbs when naming a resource in the endpoint path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously discussed HTTP methods. HTTP methods use verbs. Therefore, it
    would be redundant to use verbs yourself, and it would make your call look like
    an RPC endpoint, for example, `GET /getlicenses`. In REST, we should always use
    the resource name because, according to REST, you transfer the states and not
    the instructions. For example, let’s take another look at the GitHub license API,
    which retrieves licenses. It is `GET /licenses`. That is perfect. Let’s assume
    that if you use verbs for this endpoint, then it will be `GET /getlicenses`. It
    will still work, but semantically, it doesn’t follow REST because it conveys the
    processing instruction rather than state transfer. Therefore, only use resource
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, GitHub’s public API only offers `read` operations on the `licenses`
    resource, out of all the CRUD operations. If we need to design the rest of the
    operations, their paths should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /licenses`: This is for creating a new license.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /licenses/{license_key}`: This is for partial updates. Here, the path
    has a parameter (that is, an identifier) that makes the path dynamic. Here, the
    license key is a unique value in the license collection and is being used as an
    identifier. Each license will have a unique key. This call should make the update
    in the given license. Please remember that GitHub uses `PUT` for the replacement
    of the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /licenses/{license_key}`: This is for retrieving license information.
    You can try this with any licenses that you receive in the response to the `GET
    /licenses` call. One example is `GET /licenses/agpl-3.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how having a noun in the resource path with the HTTP methods sorts
    out any ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Using the plural form for naming the collection resource in the endpoint path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you observe the GitHub license API, you might find that a resource name is
    given in the plural form. It is a good practice to use the plural form if the
    resource represents a collection. Therefore, we can use `/licenses` instead of
    `/license`. A `GET` call returns the collection of licenses. GitHub doesn’t allow
    create, update, or delete public operations on a licensed resource. Hypothetically,
    if it allowed this, then a `POST` call would create a new license in the existing
    license collection. Similarly, for `DELETE` and `PATCH` calls, a license key is
    used to identify the specific license for performing delete and minor update operations
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Using hypermedia (HATEOAS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hypermedia (that is, links to other resources) makes the REST client’s job easier.
    There are two advantages if you provide explicit URL links in a response. First,
    the REST client is not required to construct the REST URLs on their own. Second,
    any upgrade in the endpoint path will be taken care of automatically and this,
    therefore, makes upgrades easier for clients and developers
  prefs: []
  type: TYPE_NORMAL
- en: Versioning your APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The versioning of APIs is key for future upgrades. Over time, APIs keep changing,
    and you may have customers who are still using an older version. Therefore, you
    need to support multiple versions of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways you can version your APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using headers*: The GitHub API uses this approach. You can add an `Accept`
    header that tells you which API version should serve the request; for example,
    consider the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach gives you the advantage of setting the default version. If there
    is no `Accept` header, it should lead to the default version. However, if a REST
    client that uses a versioning header is not changed after a recent upgrade of
    APIs, it may break the functionality. Therefore, it is recommended that you use
    a versioning header.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using an endpoint path*: In this approach, you add a version in the endpoint
    path itself; for example, `https://demo.app/api/v1/persons`. Here, `v1` denotes
    that version `1` is being added to the path itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot set default versioning out of the box. However, you can overcome
    this limitation by using other methods, such as request forwarding. Clients always
    use the intended versions of the APIs in this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Based on your preferences and views, you can choose either of the preceding
    approaches for versioning. However, the important point is that you should always
    use versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this very interesting question: how are you going to construct the
    endpoint for resources that are nested or have a certain relationship? Let’s take
    a look at some examples of customer resources from an e-commerce perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /customers/1/addresses`: This returns the collection of addresses for
    customer `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /customers/1/addresses/2`: This returns the second address of customer
    `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /customers/1/addresses`: This adds a new address to customer `1`’s addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /customers/1/addresses/2`: This replaces the second address of customer
    `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /customers/1/addresses/2`: This partially updates the second address
    of customer `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /customers/1/addresses/2`: This deletes the second address of customer
    `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far so good. Now, can we have an altogether separate address resource endpoint
    (`GET /addresses/2`)? It makes sense, and you can do that if there is a relationship
    that requires it; for example, orders and payments. Instead of `/orders/1/payments/1`,
    you might prefer a separate `/payments/1` endpoint. In the microservice world,
    this makes more sense; for instance, you would have two separate RESTful web services
    for both orders and payments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you combine this approach with hypermedia, it makes things easier. When
    you make a REST API request to customer `1`, it will provide the customer 1 data
    and address links as hypermedia (that is, links). The same applies to orders.
    For orders, the payment link will be available as hypermedia.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, you might wish to have a complete response in a single
    request rather than using the hypermedia-provided URLs to fetch the related resource.
    This reduces your web hits. However, there is no rule of thumb. For a flag operation,
    it makes sense to use the nested endpoint approach; for example, `PUT /gist/2/star`
    (which adds a star) and `DELETE /gist/2/star` (which undoes the star) in the case
    of the GitHub API.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in some scenarios, you might not find a suitable resource name
    when multiple resources are involved, for example, in a search operation. In that
    case, you should use a `direct/search` endpoint. This is an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Securing APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Securing your API is another expectation that requires diligent attention.
    Here are some recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS for encrypted communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always look for OWASP’s top API security threats and vulnerabilities. These
    can be found on their website (`https://owasp.org/www-project-api-security/`)
    or their GitHub repository (`https://github.com/OWASP/API-Security`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure REST APIs should have authentication in place. REST APIs are stateless;
    therefore, REST APIs should not use cookies or sessions. Instead, they should
    be secured using JWT or OAuth 2.0-based tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation should be easily accessible and up to date with the latest implementation
    with their respective versioning. It is always good to provide sample code and
    examples. It makes the developer’s integration job easier.
  prefs: []
  type: TYPE_NORMAL
- en: A change log or a release log should list all the affected libraries, and if
    some APIs are deprecated, then replacement APIs or workarounds should be elaborated
    upon inside the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Complying with recommended status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already learned about status codes in the *Exploring HTTP methods and
    status codes* section. Please follow the same guidelines discussed there.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP already provides a caching mechanism. You just have to provide additional
    headers in the REST API response. Then, the REST client makes use of the validation
    to make sure whether to make a call or use the cached response. There are two
    ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`If-None-Match`, which contains the `ETag` value. When the server receives
    this request and finds that the hash or checksum value of the resource representation
    value is different from `If-None-Match`, only then should it return the response
    with a new representation and this hash value in the `ETag` header. If it finds
    them to be equal, then the server should simply respond with a `304 (Not Modified)`
    status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ETag` way. However, instead of using the hash or checksum, it uses the timestamp
    value in RFC-1123 ([http://www.ietf.org/rfc/rfc1123.txt](http://www.ietf.org/rfc/rfc1123.txt))
    in the format: `Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT`. It is less accurate
    than `ETag` and should only be used as a fallback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Last-Modified` approach, the client sends the `If-Modified-Since` header
    with the value received in the `Last-Modified` response header. The server compares
    the resource-modified timestamp value with the `If-Modified-Since` header value
    and sends a `304` status if there is a match; otherwise, it sends the response
    with a new `Last-Modified` header.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining the rate limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maintaining the rate limit is important if you want to prevent the overuse
    of APIs. The HTTP status code `429 Too Many Requests` is used when the rate limit
    is infringed. Currently, there is no standard to communicate any warning to the
    client before the rate limit goes over. However, there is a popular way to communicate
    about it using response headers. These response headers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X-Ratelimit-Limit`: The number of allowed requests in the current period,
    for example, `X-Ratelimit-Limit: 60`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Ratelimit-Remaining`: The number of remaining requests in the current period,
    for example, `X-Ratelimit-Remaining: 55`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Ratelimit-Reset`: The number of seconds left in the current period, for
    example, `X-Ratelimit-Reset: 1601299930`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Ratelimit-Used`: The number of requests used in the current period, for
    example, `X-Ratelimit-Used: 5`. This information then might be used by the client
    to keep track of the total number of available API calls for the given period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have discussed various concepts related to REST. Next, let me introduce
    you to the app we will be building in this book using these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our e-commerce app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The e-commerce app we will be building will be a simple online shopping application
    with the following features for users:'
  prefs: []
  type: TYPE_NORMAL
- en: Browsing through the products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding/removing/updating the products in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the shipping address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for a single currency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E-commerce is a very popular domain. If we look at the features, we can divide
    the application into the following subdomains using bounded contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`users` RESTful web service, which provides REST APIs for user management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`carts` RESTful web service, which provides REST APIs for cart management.
    Users can perform CRUD operations on cart items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`products` RESTful web service, which provides REST APIs to search and retrieve
    the products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orders` RESTful web service, which provides REST APIs for users to place orders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payments` RESTful web service, which provides REST APIs for payment processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shippings` RESTful web service, which provides REST APIs for order tracking
    and shipping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a visual representation of our app’s architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The e-commerce app architecture](img/Figure_01.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The e-commerce app architecture
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement a RESTful web service for each of the subdomains. We’ll keep
    the implementation simple, and we will focus on learning these concepts throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the basic concepts of the REST architecture
    style and its key concepts – resources, URI, HTTP methods, and HATEOAS. Now, you
    know how REST, which is based on HTTP, simplifies and makes the integration of
    different applications and services easier.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the different HTTP concepts that allow you to write REST APIs
    in a meaningful way. We also learned why HATEOAS is an integral part of REST implementation.
    Additionally, we learned the best practices for designing REST APIs. We also went
    through an overview of our e-commerce app. This sample app will be used throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: The REST concepts you learned in this chapter will provide the foundation for
    REST implementation. Now, you can make use of the best practices you learned in
    this chapter to design and implement state-of-the-art REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the fundamentals of the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why have RESTful web services become so popular and, arguably, the industry
    standard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between RPC and REST?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you explain HATEOAS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What error codes should be used for server-related issues?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should verbs be used to form REST endpoints, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful services became popular because they work on top of HTTP, which is the
    backbone of the internet. You don’t need separate protocol implementations such
    as SOAP. You can use existing web technologies to implement the REST APIs with
    simple application integration compared to other technologies available. REST
    APIs make application integration simpler than other technologies available at
    the time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RESTful services work on REST, which works on web resources. Resources represent
    domain models. Actions are defined using HTTP methods, which are performed on
    web resources. REST also allows clients to perform actions based on links available
    through HATEOAS implementation, like a human who can navigate in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'RPC is more like functions that perform actions. RPC endpoints are directly
    formed based on verbs that lead to separate URLs for each action. Whereas REST
    URLs represent nouns and could be the same for different operations, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With HATEOAS, RESTful web services provide information dynamically through hypermedia.
    Hypermedia is the part of the content you receive from a REST call response. This
    hypermedia content contains links to different types of media such as text, images,
    and videos. Machines, aka REST clients/browsers, can follow links when they understand
    the data format and relationship types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Status code `500` should be used for generic server errors. The `502` status
    code should be used when an upstream server fails. Status code `503` is for unexpected
    server events such as an overload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verbs should not be used to form REST endpoints. Instead, you should use the
    noun that represents the domain model as a resource. HTTP methods are used to
    define the actions performed on resources, such as `POST` for creating and `GET`
    for retrieving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Architectural Styles and the Design of Network-based Software* *Architectures*:
    [https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The URI Generic Syntax (*RFC-3986*): [https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The URN Syntax (*RFC-2141*): [https://tools.ietf.org/html/rfc2141](https://tools.ietf.org/html/rfc2141)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP Response Status Codes – *RFC* *7231*: [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP Response Status Codes – Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*REST APIs* *must* *be* *hypertext-driven*: [https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The RFC for the URI template: [https://tools.ietf.org/html/rfc6570](https://tools.ietf.org/html/rfc6570)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OWASP API security project: [https://owasp.org/www-project-api-security/](https://owasp.org/www-project-api-security/)
    and [https://github.com/OWASP/API-Security](https://github.com/OWASP/API-Security)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
