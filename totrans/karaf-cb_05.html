<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Hosting Web Services with Apache CXF"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Hosting Web Services with Apache CXF</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Apache CXF modules in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Using the CXF list endpoints command</li><li class="listitem" style="list-style-type: disc">Using the CXF stop/start endpoints command</li><li class="listitem" style="list-style-type: disc">Building and deploying a RESTful service in Karaf</li><li class="listitem" style="list-style-type: disc">Building and deploying a Camel CXF web service in Karaf</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Introduction</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Deploying a Message Broker with Apache ActiveMQ">Chapter 3</a>, <span class="emphasis"><em>Deploying a Message Broker with Apache ActiveMQ</em></span>, we discussed how and when to set up JMS systems. Another way to communicate between systems or applications is to provide web service or RESTful endpoints. Apache CXF provides a way to easily set up and publish web service endpoints. Publishing web services in Apache Karaf provides commands to control the endpoint lifecycle and monitor what is deployed.</p></div></div>
<div class="section" title="Installing Apache CXF modules in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Installing Apache CXF modules in Apache Karaf</h1></div></div></div><p>Before<a id="id385" class="indexterm"/> we can deploy any web <a id="id386" class="indexterm"/>service or RESTful services, we need to get CXF installed in the Karaf container. Just like other frameworks, we need to get the features that support the required services installed.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec165"/>How to do it…</h2></div></div></div><p>To install the CXF framework, just install the CXF feature from the default Karaf instance. If no version is specified, it will use the latest version. For this example, we are using <code class="literal">version 3.0.0-milestone2</code>. We can do this using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:repo-add cxf &lt;version&gt;</strong></span>
</pre></div><p>Once<a id="id387" class="indexterm"/> the feature URL is added, we <a id="id388" class="indexterm"/>can see all the CXF features that are provided. This can be done using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:list | grep cxf</strong></span>
</pre></div><p>The list of CXF features is extensive, but for all of our recipes, we can simply install the CXF feature using the following command. This will install all the required features that will be used in this book.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install cxf</strong></span>
</pre></div><p>We can see that a large number of the required features have been installed at this point. The following list is a subset from a <code class="literal">feature:list</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cxf-specs                     | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-jaxb                      | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>wss4j                         | 2.0.0-rc1        | x</strong></span>
<span class="strong"><strong>cxf-core                      | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-wsdl                      | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-ws-policy                 | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-ws-addr                   | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-ws-rm                     | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-ws-mex                    | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-ws-security               | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-http                      | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-http-jetty                | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-bindings-soap             | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-jaxws                     | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-jaxrs                     | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-databinding-aegis         | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-databinding-jaxb          | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-databinding-xmlbeans      | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-features-clustering       | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-bindings-corba            | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-bindings-coloc            | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-bindings-object           | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-transports-local          | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-transports-jms            | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-transports-udp            | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-javascript                | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-frontend-javascript       | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf-xjc-runtime               | 3.0.0-milestone2 | x</strong></span>
<span class="strong"><strong>cxf                           | 3.0.0-milestone2 | x</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec166"/>How it works…</h2></div></div></div><p>If we look at the <code class="literal">features.xml</code> file from the CXF code base, we can see that the <code class="literal">cxf</code> feature<a id="id389" class="indexterm"/> is just a feature that installs <a id="id390" class="indexterm"/>all the required features for CXF deployment in Karaf. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;feature name="cxf" version="${version}" resolver='(obr)'&gt;
  &lt;feature version="[3,4)"&gt;spring&lt;/feature&gt;
  &lt;feature version="[1.2,2)"&gt;spring-dm&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-core&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-jaxws&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-jaxrs&lt;/feature&gt;

  &lt;feature version="${version}"&gt;cxf-databinding-jaxb&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-databinding-aegis&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-databinding-xmlbeans&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-bindings-corba&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-bindings-coloc&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-bindings-object&lt;/feature&gt;

  &lt;feature version="${version}"&gt;cxf-http-jetty&lt;/feature&gt;

  &lt;feature version="${version}"&gt;cxf-transports-local&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-transports-jms&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-transports-udp&lt;/feature&gt;


  &lt;feature version="${version}"&gt;cxf-xjc-runtime&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-ws-security&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-ws-rm&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-ws-mex&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-javascript&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-frontend-javascript&lt;/feature&gt;
  &lt;feature version="${version}"&gt;cxf-features-clustering&lt;/feature&gt;

  &lt;bundle start-level='50'&gt;mvn:org.apache.cxf/cxf-bundle-compatible/${version}&lt;/bundle&gt;
&lt;/feature&gt;</pre></div><p>The <code class="literal">cxf</code> feature <a id="id391" class="indexterm"/>adds a compatibility<a id="id392" class="indexterm"/> bundle for the required bundle, as stated in the <code class="literal">features.xml</code> file.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec167"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the CXF list-endpoints command</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the CXF stop and start commands</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the CXF list-endpoints command"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Using the CXF list-endpoints command</h1></div></div></div><p>In order<a id="id393" class="indexterm"/> to view what is deployed into an instance of CXF, we can use the <code class="literal">list-endpoints</code> command. This will list out all the buses currently deployed in the Karaf runtime.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>This recipe is only to demonstrate the use of the commands; we will cover how to create different CXF bundles in later recipes.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec168"/>Getting ready</h2></div></div></div><p>After completing the <span class="emphasis"><em>Installing Apache CXF modules in Apache Karaf</em></span> recipe, we now need to build and deploy a sample CXF application into Karaf.</p><p>Go to the code bundle of this chapter and run the Maven build using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install</strong></span>
</pre></div><p>This will build and install the sample applications for this chapter in the Maven repository so we can easily install them in the Karaf instance.</p><p>From the command line in the Karaf instance, install this recipe's CXF module using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Install -s mvn:com.packt/chapter5-recipe2/1.0.0-SNAPSHOT</strong></span>
</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec169"/>How to do it…</h2></div></div></div><p>We can run the following command to list CXF endpoints published in this instance of Karaf:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; cxf:list-endpoints</strong></span>
</pre></div><p>This will provide us with a list of CXF buses that have been started from our sample bundle. This is shown in the following command-line output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Name           State      Address   BusID                           </strong></span>
<span class="strong"><strong>[StringRestSe…][Started][/chapter5] [chapter5-recipe2-cxf1752581114 ]</strong></span>
</pre></div><p>We can see from the result that our endpoint is published and available. The name of the implementation class name is <code class="literal">StringRestServiceImpl</code>. Also note that it is in the <code class="literal">Started</code> state and the address where we can locate the REST service.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>Use<a id="id394" class="indexterm"/> the <code class="literal">–f</code> parameter on the <code class="literal">list-endpoints</code> command to get the full address to the endpoint.</p></div></div><p>So let's give <a id="id395" class="indexterm"/>this a try. When you go to <code class="literal">http://localhost:8181/cxf/chapter5/recipeTwo</code>, it will display the message returned from the recipe code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>The type of browser might impact what you see; we are using Chrome in this example.</p></div></div><p>The following screenshot displays what will be seen in the browser:</p><div class="mediaobject"><img src="graphics/5081OS_05_03.jpg" alt="How to do it…"/></div><p>As you can see, we are able to hit the endpoint and see our message from the implementation class.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec170"/>How it works…</h2></div></div></div><p>Just like the <code class="literal">list-busses</code> command, this command uses the CXF controller to get the information needed for display in the console. The code for this is in the <code class="literal">ListEndpointsCommand</code> class. This will get the buses using the CXF controller, and then loop through the list and pull the ServiceRegistry in order to get a list of servers. From the server, we can get the rest of the details of the list, including the name, state, and<a id="id396" class="indexterm"/> address.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec171"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the CXF stop and start commands</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the CXF stop and start commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Using the CXF stop and start commands</h1></div></div></div><p>In some instances, there might be a need to control the state of the endpoint manually. Using<a id="id397" class="indexterm"/> the <code class="literal">stop-endpoint</code> or <code class="literal">start-endpoint</code> commands, we <a id="id398" class="indexterm"/>can shut down and start up a published endpoint from the command line. This is useful when testing client code to make sure that you are handling unavailable endpoints correctly.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec172"/>Getting ready</h2></div></div></div><p>Follow the steps from the <span class="emphasis"><em>Using the CXF list-endpoints command</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec173"/>How to do it…</h2></div></div></div><p>Let's look at how to use the <code class="literal">stop-endpoint</code> and <code class="literal">start-endpoint</code> commands. Both commands require parameters for the bus and endpoint in order to know what to start or stop. The syntax for these commands looks like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cxf:stop-endpoint &lt;bus&gt; &lt;endpoint name&gt;</strong></span>
<span class="strong"><strong>cxf:start-endpoint &lt;bus&gt; &lt;endpoint name&gt;</strong></span>
</pre></div><p>To stop an endpoint, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">list-endpoints</code> command to get the bus ID and the name of our published endpoint. The following will be the output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Name           State      Address      BusID           </strong></span>
<span class="strong"><strong>[StringRestSe…][Started][/chapter5] [chapter5-recipe2-cxf1752581114   ].</strong></span>
</pre></div></li><li class="listitem">The information in the output of the preceding step can now be used to start and stop endpoints published in this instance of Karaf. Consider the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cxf:stop-endpoint chapter5-recipe2-&lt;cxf identifier&gt; StringRestServiceImpl</strong></span>
</pre></div></li><li class="listitem">The preceding command will stop the endpoint we published in the <span class="emphasis"><em>Getting ready</em></span> section. Rerun the <code class="literal">list-endpoints</code> command in order to see the state change as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Name           State      Address   BusID           </strong></span>
<span class="strong"><strong>[StringRestSe…][Stopped][/string] [chapter5-recipe2-&lt;cxf identifier&gt;   ].</strong></span>
</pre></div></li></ol></div><p>Notice <a id="id399" class="indexterm"/>that the state has been changed to <code class="literal">Stopped</code>. This indicates<a id="id400" class="indexterm"/> that our REST service endpoint is no longer available from our browser. Use a browser to hit this endpoint address: <code class="literal">http://localhost:8181/cxf/chapter5/recipeTwo</code>.</p><p>The browser cannot find the address specified, which is exactly what we expect to happen. The following screenshot is what you should see:</p><div class="mediaobject"><img src="graphics/5081OS_05_02.jpg" alt="How to do it…"/></div><p>Now, perform the following steps to start the endpoint again:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the endpoint listed in the <code class="literal">list-endpoints</code> command as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cxf:start-endpoint chapter5-recipe2-&lt;cxf identifier&gt; StringRestServiceImpl</strong></span>
</pre></div></li><li class="listitem">This will start the endpoint we published in the <span class="emphasis"><em>Getting ready</em></span> section. Rerun the <code class="literal">list-endpoints</code> command in order to see the state change as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Name           State      Address      BusID              </strong></span>
<span class="strong"><strong>[StringRestSe…][Started  ][/chapter5] [chapter5-recipe2-&lt;cxf identifier&gt; ].</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec174"/>How it works…</h2></div></div></div><p>The command is made available from the <code class="literal">cxf</code> feature implemented by the <code class="literal">StopEndpointCommand</code> class (the <code class="literal">start-endpoint</code> command is very similar). This is shown in the following code line:</p><div class="informalexample"><pre class="programlisting">@Command(scope = "cxf", name = "stop-endpoint", description = "Stops a CXF Endpoint on a Bus.")</pre></div><p>The command annotation shows you that the CXF defines the subshell and the command name is <code class="literal">stop-endpoint</code>. This command also has several required parameters defined by the <a id="id401" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">@Argument(index = 0, name = "bus", description = "The CXF bus name where to look for the Endpoint", required = true, multiValued = false)
String busName;

@Argument(index = 1, name = "endpoint", description = "The Endpoint name to stop", required = true, multiValued = false)
String endpoint;</pre></div><p>There are <a id="id402" class="indexterm"/>two parameters that are required (as noted by the <code class="literal">required=true</code> parameter in the <code class="literal">Argument</code> annotation).</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec175"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the CXF list-endpoints command</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Building and deploying a RESTful service in Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Building and deploying a RESTful service in Karaf</h1></div></div></div><p>Now, let's look<a id="id403" class="indexterm"/> at how the code is assembled <a id="id404" class="indexterm"/>in order to publish a CXF <a id="id405" class="indexterm"/>endpoint in Karaf using just CXF.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec176"/>Getting ready</h2></div></div></div><p>In this <a id="id406" class="indexterm"/>recipe, we will work with the <code class="literal">chapter5-recipe3</code> example from the code bundle. Uninstall the <code class="literal">recipe2</code> code before going ahead with this recipe</p><p>First, install CXF as shown in the <span class="emphasis"><em>Installing Apache CXF modules in Apache Karaf</em></span> recipe, and then build and deploy a sample CXF application as <code class="literal">recipe3</code> in Karaf.</p><p>Go to the <code class="literal">chapter5-recipe3</code> example from the code bundle and run the Maven build using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install</strong></span>
</pre></div><p>This will build and install the sample applications for the <code class="literal">chapter5-recipe3</code> example into the Maven repository, so we can easily install them in the Karaf instance.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec177"/>How to do it…</h2></div></div></div><p>Once the bundle is deployed, we can look at deploying and starting the CXF endpoint.</p><p>From the command line in the Karaf instance, install the <code class="literal">chapter5-recipe3</code> example's CXF module, start the bundle, and publish the endpoint with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>install -s mvn:com.packt/chapter5-recipe3/1.0.0-SNAPSHOT</strong></span>
</pre></div><p>The <code class="literal">list-endpoints</code> command <a id="id407" class="indexterm"/>will show us that our endpoint has been started and is available, as shown in the following command-line snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; cxf:list-endpoints</strong></span>
<span class="strong"><strong>Name         State    Address    BusID                            </strong></span>
<span class="strong"><strong>[StringRes…][Started][/chapter5][chapter5-recipe3-&lt;cxf identifier&gt;</strong></span>
</pre></div><p>Now <a id="id408" class="indexterm"/>that we have verified that our endpoint<a id="id409" class="indexterm"/> is published, let's test it by<a id="id410" class="indexterm"/> hitting this endpoint address: <code class="literal">http://localhost:8181/cxf/chapter5/recipeThree</code>. The output is as shown in the<a id="id411" class="indexterm"/> following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_05_04.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec178"/>How it works…</h2></div></div></div><p>Let's examine the different pieces of this puzzle to find out how we got the endpoint published.</p><p>First, we need to define the endpoint using an interface. In the sample code, look at the <code class="literal">StringRestService</code> interface class shown as follows:</p><div class="informalexample"><pre class="programlisting">@Path("/")
public interface StringRestService {
    @GET
    @Path("/recipeThree")
    @Produces("application/xml")
    public String getRecipeThree() throws Exception;
}</pre></div><p>The <code class="literal">@Path("/")</code> annotation is set to null. This means that there is no address location that has been defined to access this RESTful endpoint.</p><p>This interface only defines the <code class="literal">@GET</code> value (not the <code class="literal">@POST</code> value) of the RESTful endpoint. In order to access this endpoint, we only need to use the <code class="literal">/recipeThree</code> location after the default in order to access the <code class="literal">getRecipeThree()</code> method.</p><p>The <code class="literal">@Produces</code> annotation defines the type of data that will be returned to the caller. In this<a id="id412" class="indexterm"/> case, we are defining XML via <code class="literal">application/xml</code>.</p><p>Then, we have to implement the interface in order to process the request to the endpoint. In our <a id="id413" class="indexterm"/>simple example, we are just returning a<a id="id414" class="indexterm"/> string value with XML. The implementation<a id="id415" class="indexterm"/> class looks like the<a id="id416" class="indexterm"/> following code:</p><div class="informalexample"><pre class="programlisting">public class StringRestServiceImpl implements StringRestService {
  @Override
  public String getRecipeThree() throws Exception {
    System.out.println("RECIPE 3 :: restful endpoint hit.");
    return "&lt;packt&gt;
      &lt;chapter5&gt;
        &lt;recipe3&gt;THIS IS A COOK BOOK RECIPE THREE....BABY!!!&lt;/recipe3&gt;
      &lt;/chapter5&gt;
    &lt;/packt&gt;";
  }
}</pre></div><p>The implementation class is simple—we are creating the <code class="literal">getRecipeThree</code> method and returning an XML string.</p><p>Now that we have the interface and implementation class defined, we need to configure the endpoint. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;cxf:bus&gt;
  &lt;cxf:features&gt;
    &lt;cxf:logging/&gt;
  &lt;/cxf:features&gt;
&lt;/cxf:bus&gt;

&lt;jaxrs:server id="stringRestService" address="/chapter5"&gt;
  &lt;jaxrs:serviceBeans&gt;
    &lt;ref component-id="stringRestServiceBean"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;

&lt;bean id="stringRestServiceBean" class="com.example.test.cxf.StringRestServiceImpl"/&gt;</pre></div><p>When working in the OSGi environment, it is suggested that you use Blueprint. The preceding XML code is from a Blueprint XML file.</p><p>In this configuration, we are defining the <code class="literal">cxf</code> bus and adding the <code class="literal">logging</code> feature. There is no reason to specify the implementation class for the bus since all of the logging information is embedded in the underlying schema definition.</p><p>Then, we need to instantiate the implementation class as a bean. Here, we give this an ID of <code class="literal">stringRestServiceBean</code>.</p><p>This<a id="id417" class="indexterm"/> bean ID is used in the server configuration<a id="id418" class="indexterm"/> to define ServiceBean. This will use the interface class implemented by the implementation class to <a id="id419" class="indexterm"/>publish the endpoint at the <code class="literal">/chapter5</code> location. Since we did not define a class with a base location, the address will look <a id="id420" class="indexterm"/>like <code class="literal">http://localhost:8181/cxf/chapter5/recipeThree</code> once it is deployed.</p><p>Notice that in the previous URL, the <code class="literal">/chapter5</code> location comes first, which is the address for the JAX-RS server, followed by the path defined in the interface class.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec179"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building and deploying a Camel CXF web service in Karaf</em></span> recipe.</li></ul></div></div></div>
<div class="section" title="Building and deploying a Camel CXF web service in Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Building and deploying a Camel CXF web service in Karaf</h1></div></div></div><p>In the<a id="id421" class="indexterm"/> previous recipe, we saw how <a id="id422" class="indexterm"/>easy it can be to deploy a RESTful service <a id="id423" class="indexterm"/>using CXF<a id="id424" class="indexterm"/> and Karaf. Now, we will explore how to deploy a WSDL first CXF endpoint using Camel. This is a good way to implement integration routes that expose web services. Uninstall the <code class="literal">recipe2</code> code before going ahead with this recipe</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec180"/>Getting ready</h2></div></div></div><p>The example code for this recipe is in the <code class="literal">chapter5-recipe4</code> example of the code bundle. More than likely, you have already built the code, but just in case, go ahead and run the <code class="literal">mvn clean install</code> command against the <code class="literal">chapter5</code> folder. This will build and move the bundle to the Maven repository for deployment in Karaf.</p><p>Notice that there is the following line in the console for the build:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] --- cxf-codegen-plugin:2.7.4:wsdl2java (generate-sources) @ chapter5-recipe4 ---</strong></span>
</pre></div><p>The <a id="id425" class="indexterm"/>preceding line indicates that the <a id="id426" class="indexterm"/>codegen plugin for CXF has been<a id="id427" class="indexterm"/> run and has generated<a id="id428" class="indexterm"/> the code from the WSDL defined in the <code class="literal">pom.xml</code> file. The following is the plugin definition that instructs Maven to build code from the WSDL:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-codegen-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.7.4&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;generate-sources&lt;/id&gt;
      &lt;phase&gt;generate-sources&lt;/phase&gt;
      &lt;configuration&gt;
        &lt;sourceRoot&gt;
          ${basedir}/target/generated/src/main/java
        &lt;/sourceRoot&gt;
        &lt;wsdlOptions&gt;
          &lt;wsdlOption&gt;
            &lt;wsdl&gt;
              ${basedir}/src/main/resources/META-INF/wsdl/report_domain.wsdl
            &lt;/wsdl&gt;
          &lt;/wsdlOption&gt;
        &lt;/wsdlOptions&gt;
      &lt;/configuration&gt;
      &lt;goals&gt;
        &lt;goal&gt;wsdl2java&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</pre></div><p>The WSDL is identified by the <code class="literal">&lt;wsdl&gt;</code> tags, so we can see that the <code class="literal">report_domain.wsdl</code> file is found in the <code class="literal">${basedir}/src/main/resources/META-INF/wsdl/</code> directory.</p><p>The <code class="literal">wsdl2java</code> goal indicates that we want the plugin to generate the necessary files from the WSDL.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec181"/>How to do it…</h2></div></div></div><p>First, we<a id="id429" class="indexterm"/> need to get the environment <a id="id430" class="indexterm"/>set up to run our Camel<a id="id431" class="indexterm"/> CXF endpoint. This can<a id="id432" class="indexterm"/> be done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to get Apache Camel installed using the following Camel feature command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:repo-add camel 2.12.3</strong></span>
</pre></div><p>This will add the feature definitions for Camel into the Karaf instance.</p></li><li class="listitem">Now, we need to actually install the <code class="literal">camel</code> and <code class="literal">camel-cxf</code> features using the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install camel</strong></span>
<span class="strong"><strong>feature:install camel-cxf</strong></span>
</pre></div></li><li class="listitem">Once the <code class="literal">camel</code> and <code class="literal">camel-cxf</code> features are installed, we can install the bundle for this recipe using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>install –s mvn:com.packt/chapter5-recipe4/1.0.0-SNAPSHOT</strong></span>
</pre></div></li></ol></div><p>We can list the bundles in order to make sure that the bundle was successfully installed using the <code class="literal">bundle:list</code> command. The output will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>START LEVEL 100 , List Threshold: 50</strong></span>
<span class="strong"><strong> ID | State  | Lvl | Version  | Name                               </strong></span>
<span class="strong"><strong>---------------------------------------------------------</strong></span>
<span class="strong"><strong> 85 | Active |  50 | 2.12.3   | camel-core                         </strong></span>
<span class="strong"><strong> 86 | Active |  50 | 2.12.3   | camel-karaf-commands               </strong></span>
<span class="strong"><strong>101 | Active |  50 | 1.1.1    | geronimo-jta_1.1_spec              </strong></span>
<span class="strong"><strong>102 | Active |  50 | 2.12.3   | camel-spring                       </strong></span>
<span class="strong"><strong>103 | Active |  50 | 2.12.3   | camel-blueprint                    </strong></span>
<span class="strong"><strong>179 | Active |  50 | 2.7.10   | Apache CXF Compatibility Bundle Jar</strong></span>
<span class="strong"><strong>180 | Active |  50 | 2.12.3   | camel-cxf-transport                </strong></span>
<span class="strong"><strong>181 | Active |  50 | 2.12.3   | camel-cxf                          </strong></span>
<span class="strong"><strong>182 | Active |  80 | 1.0.0.SNA| Chapter 5 :: Recipe 4 ::</strong></span>
</pre></div><p>We can see that the last bundle is our recipe bundle. It has been started and is active, which indicates that the endpoint has been published.</p><p>To verify this, we can use CXF commands. When we use the <code class="literal">karaf@root()&gt; cxf:list-busses</code> command, the output will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Name                             State               </strong></span>
<span class="strong"><strong>[chapter5-recipe4-&lt;id&gt;         ] [RUNNING           ]</strong></span>
</pre></div><p>When we use the <code class="literal">karaf@root()&gt; cxf:list-endpoints -f</code> command, the output will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Name                      State</strong></span>
<span class="strong"><strong>[ReportDomainService    ] [Started ]</strong></span>
<span class="strong"><strong>Address</strong></span>
<span class="strong"><strong>[http://localhost:9080/webservices/domain  ]</strong></span>
<span class="strong"><strong>BusID</strong></span>
<span class="strong"><strong>[chapter5-recipe4-&lt;id&gt;        ]</strong></span>
</pre></div><p>This<a id="id433" class="indexterm"/> indicates that our Camel CXF web <a id="id434" class="indexterm"/>service<a id="id435" class="indexterm"/> is <a id="id436" class="indexterm"/>deployed and available at <code class="literal">http://localhost:9080/webservices/domain</code>.</p><p>You can also look at the WSDL code available from the endpoint at <code class="literal">http://localhost:9080/webservices/domain?wsdl</code>.</p><p>Put the preceding address in your favorite web browser and we will see the WSDL code. This should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_05_07.jpg" alt="How to do it…"/></div><p>We see that the endpoint is published and available through several avenues. Let's go ahead and<a id="id437" class="indexterm"/> test it using SoapUI, which is a free web service testing tool that is available at <a class="ulink" href="http://www.soapui.org/">http://www.soapui.org/</a>. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Load<a id="id438" class="indexterm"/> the WSDL code <a id="id439" class="indexterm"/>as<a id="id440" class="indexterm"/> a <a id="id441" class="indexterm"/>project in SoapUI, and it will automatically set up a request for us based on the WSDL definition. The following screenshot shows us what the request should look like:<div class="mediaobject"><img src="graphics/5081OS_05_05.jpg" alt="How to do it…"/></div><p>This will also autoload the address for the request.</p></li><li class="listitem">We can hit the play button to submit the request to the endpoint. It will respond with a simple <code class="literal">OK</code>, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5081OS_05_06.jpg" alt="How to do it…"/></div></li></ol></div><p>This<a id="id442" class="indexterm"/> shows that we were able to<a id="id443" class="indexterm"/> submit a request to the endpoint <a id="id444" class="indexterm"/>and retrieve the response. The response is a simple hardcoded <code class="literal">OK</code> but demonstrates the availability of the endpoint.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec182"/>How it works…</h2></div></div></div><p>First, let's<a id="id445" class="indexterm"/> look at the endpoint configuration for the Camel component. In the Blueprint file, we define the service endpoint as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;blueprint
       
       
       
       xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
       "&gt;

  &lt;camelcxf:cxfEndpoint id="reportDomain"
          address="http://localhost:9080/webservices/domain"
          wsdlURL="META-INF/wsdl/report_domain.wsdl"
          serviceClass="com.example.test.cxf.reportdomain.ReportDomainEndpoint"/&gt;

  &lt;bean id="domainRoutes" class="com.example.test.cxf.routes.DomainRoutes"/&gt;

  &lt;camelContext id="camel"&gt;
    &lt;routeBuilder ref="domainRoutes"/&gt;
  &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre></div><p>The preceding code is the CXF endpoint configuration; notice that we are specifying the address <a id="id446" class="indexterm"/>and port for our published <a id="id447" class="indexterm"/>web service as well as the <a id="id448" class="indexterm"/>location of the WSDL file.</p><p>The<a id="id449" class="indexterm"/> route is instantiated via a Blueprint with a <code class="literal">domainRoutes</code> bean ID. This will allow us to reference it from the CamelContext configuration.</p><p>The CamelContext defines all the Camel routes to be used in this bundle.</p><p>Now, let's look at the actual code for the route:</p><div class="informalexample"><pre class="programlisting">public class DomainRoutes extends RouteBuilder {
    OutputReportDomain ok = new OutputReportDomain();

    public void configure() throws Exception {
        // webservice response for OK
        ok.setCode("OK");

        from("cxf:bean:reportDomain").id("domainService").choice().when().simple("${in.header.operationName} == 'ReportDomain'").convertBodyTo(InputReportDomain.class).to("log:dummy").process(new Processor() {
                    public void process(Exchange exchange)throws Exception {
                        exchange.getIn().setBody(ok);
                    }
        })
        .end();
    }
}</pre></div><p>The <code class="literal">from("cxf:bean:reportDomain")</code>code line is the start of the route. We need to be able to<a id="id450" class="indexterm"/> configure it so that it can <a id="id451" class="indexterm"/>handle any calls to our web <a id="id452" class="indexterm"/>service. The <code class="literal">reportDomain</code> part<a id="id453" class="indexterm"/> in the URI is a reference to the <code class="literal">cxfEndpoint</code> object configured in the <code class="literal">blueprint.xml</code> file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>Note that no implementation code is needed when using the Camel CXF endpoint, as all requests are intercepted and processed by the route.</p></div></div><p>The rest of the route is just for show. We convert the body to the defined data type in the WSDL. In this case, it is converted to <code class="literal">InputReportDomain.class</code>. Then, we log it to the <code class="literal">karaf.log</code> file using <code class="literal">.to("log:dummy")</code>. Finally, we return <code class="literal">OutputReportDomain.class</code> with an <code class="literal">OK</code> code.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec183"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building and deploying a RESTful service in Karaf</em></span> recipe</li></ul></div></div></div></body></html>