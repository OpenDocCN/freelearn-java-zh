["```java\nlazy val akkaVersion = \"2.5.14\"\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-stream\" % akkaVersion\n```", "```java\nimport akka.stream._\nimport akka.stream.scaladsl._\n```", "```java\npackage ch13\n\nimport akka.actor.ActorSystem\nimport akka.stream._\n\nobject Bakery extends App {\n  implicit val bakery: ActorSystem = ActorSystem(\"Bakery\")\n  implicit val materializer: Materializer = ActorMaterializer()\n\n  // stream processing happens here\n\n  private def afterAll = bakery.terminate()\n}\n```", "```java\nval consumer: Sink[ReadyCookies, Future[Done]] =\n  Sink.foreach(cookie => println(s\"$cookie, yummi...\"))\n```", "```java\nprivate val delay = 1 second\nprivate val interval = 1 second\n\nval manager1: Source[NotUsed, Cancellable] =\n  Source.tick(delay, interval, NotUsed)\n```", "```java\nval manager: Source[ShoppingList, Cancellable] =\n  Source.tick(delay, interval, NotUsed).map { _ =>\n    shoppingList\n  }\n```", "```java\nval manager: Source[ShoppingList, NotUsed] =\n  Source.repeat(NotUsed).map(_ => shoppingList)\n```", "```java\nobject Cook {\n  def formFlow: Flow[Dough, RawCookies, NotUsed] =\n    Flow[Dough].map { dough =>\n      print(s\"Forming $dough - \")\n      val result = RawCookies(makeCookies(dough.weight))\n      println(result)\n      result\n    }\n  private val cookieWeight = 50\n  private def makeCookies(weight: Int): Int = weight / cookieWeight\n}\n```", "```java\ndef lookupSeller(implicit as: ActorSystem): Future[ActorRef] = {\n  val store = \"akka.tcp://Store@127.0.0.1:2553\"\n  val seller = as.actorSelection(s\"$store/user/Seller\")\n  seller.resolveOne()\n}\n```", "```java\ndef goShopping(implicit as: ActorSystem, ec: ExecutionContext):\n  Future[Flow[ShoppingList, Groceries, NotUsed]] =\n  lookupSeller.map { ref => \n    Flow[ShoppingList].ask[Groceries](ref) \n}\n```", "```java\ndef shopFlow(implicit as: ActorSystem, ec: ExecutionContext): Flow[ShoppingList, Groceries, Future[Option[NotUsed]]] =\n  Flow.lazyInitAsync { () => goShopping }\n```", "```java\ndef bakeFlow: Flow[RawCookies, ReadyCookies, NotUsed] =\n  Flow[RawCookies]\n    .delay(bakingTime, DelayOverflowStrategy.backpressure)\n    .addAttributes(Attributes.inputBuffer(1, 1))\n    .map(bake)\n```", "```java\nprivate def bake(c: RawCookies): ReadyCookies = {\n  assert(c.count == ovenSize)\n  ReadyCookies(c.count)\n}\n```", "```java\ndef bakeFlow = BidiFlow.fromFlows(inFlow, outFlow)\n```", "```java\nprivate def outFlow = Flow[ReadyCookies]\n```", "```java\ndef extractFromBox(c: RawCookies) = Source(List.fill(c.count)(RawCookies(1)))\n```", "```java\nval inFlow = Flow[RawCookies]\n  .flatMapConcat(extractFromBox)\n  .grouped(Oven.ovenSize)\n  .map(_.reduce(_ + _))\n```", "```java\nval bakerFlow: Flow[RawCookies, ReadyCookies, NotUsed] = \n  Baker.bakeFlow.join(Oven.bakeFlow)\n```", "```java\ndef mix(g: Groceries) = {\n  Thread.sleep(mixTime.toMillis)\n  import g._\n  Dough(eggs * 50 + flour + sugar + chocolate)\n}\n```", "```java\nmixers-dispatcher {\n  executor = \"thread-pool-executor\"\n  type = PinnedDispatcher\n}\n```", "```java\nprivate def subMixFlow: Flow[Groceries, Dough, NotUsed] =\n  Flow[Groceries].async(\"mixers-dispatcher\", 1).map(mix)\n```", "```java\nimport akka.stream.scaladsl.GraphDSL\nimport GraphDSL.Implicits._\n\ndef createGraph[Out, In](subFlow: Flow[In, Out, Any], count: Int) = {\n  val balanceBlock  = Balance[In](count, waitForAllDownstreams = false)\n  val mergeBlock = Merge[Out](count, eagerComplete = false)\n  GraphDSL.create() { implicit builder ⇒\n    val balancer = builder.add(balanceBlock)\n    val merge = builder.add(mergeBlock)\n\n    for (_ ← 1 to count) balancer ~> subFlow ~> merge\n\n    FlowShape(balancer.in, merge.out)\n  }\n}\n```", "```java\nbalancer ~> subFlow ~> merge\nbalancer ~> subFlow ~> merge\nbalancer ~> subFlow ~> merge\nbalancer ~> subFlow ~> merge\n```", "```java\ndef apply[In, Out](subFlow: Flow[In, Out, Any],\n                   count: Int): Flow[In, Out, NotUsed] =\n  Flow.fromGraph(createGraph(subFlow, count))\n```", "```java\ndef mixFlow: Flow[Groceries, Dough, NotUsed] =\n  Flow[Groceries]\n    .map(splitByMixer)\n    .flatMapConcat(mixInParallel)\n\ndef splitByMixer(g: Groceries) = {\n  import g._\n  val single = Groceries(1, flour / eggs, sugar / eggs, chocolate / eggs)\n  List.fill(g.eggs)(single)\n}\n\ndef mixInParallel(list: List[Groceries]) =\n  Source(list)\n    .via(Balancer(subMixFlow, list.size))\n    .grouped(list.size)\n    .map(_.reduce(_ + _))\n```", "```java\ndef formFlow: Flow[Dough, RawCookies, NotUsed] =\n  Flow[Dough]\n    .log(\"Cook[Before Map]\")\n    .map { dough =>\n      RawCookies(makeCookies(dough.weight))\n    }\n    .log(\"Cook[After Map]\")\n    .withAttributes(\n      Attributes.logLevels(\n        onElement = Logging.InfoLevel,\n        onFinish = Logging.DebugLevel,\n        onFailure = Logging.WarningLevel\n      )\n    )\n```", "```java\nakka {\n  loggers = [\"akka.event.Logging$DefaultLogger\"]\n  # Options: OFF, ERROR, WARNING, INFO, DEBUG\n  loglevel = \"INFO\"\n}\n```", "```java\n[INFO] [Bakery-akka.actor.default-dispatcher-14] [akka.stream.Log(akka://Bakery/system/StreamSupervisor-0)] [Cook[Before Map]] Element: Dough(575)\n ...\n [INFO] [Bakery-akka.actor.default-dispatcher-14] [akka.stream.Log(akka://Bakery/system/StreamSupervisor-0)] [Cook[After Map]] Element: RawCookies(11)\n ...\n [INFO] [Bakery-akka.actor.default-dispatcher-14] [akka.stream.Log(akka://Bakery/system/StreamSupervisor-0)] [Cook[Before Map]] Element: Dough(1380)\n [INFO] [Bakery-akka.actor.default-dispatcher-14] [akka.stream.Log(akka://Bakery/system/StreamSupervisor-0)] [Cook[After Map]] Element: RawCookies(27)\n```", "```java\nval flow = Boy.shopFlow\n  .via(Chef.mixFlow)\n  .via(Cook.formFlow)\n  .via(bakerFlow)\n\nval graph: RunnableGraph[Future[Done]] = manager.via(flow).toMat(consumer)(Keep.right)\n\nimplicit val materializer: Materializer = ActorMaterializer()\n\ngraph.run().onComplete(_ => afterAll)\n```", "```java\nobject MotorOverheatException extends Exception\nobject SlowRotationSpeedException extends Exception\nobject StrongVibrationException extends Exception\n\nval exceptions = Seq(MotorOverheatException,\n                     SlowRotationSpeedException,\n                     StrongVibrationException)\n```", "```java\nprivate def mix(g: Groceries) = {\n  if (Random.nextBoolean()) throw exceptions(Random.nextInt(exceptions.size))\n  Thread.sleep(mixTime.toMillis)\n  import g._\n  Dough(eggs * 50 + flour + sugar + chocolate)\n}\n```", "```java\nprivate def mix(g: Groceries) = try {\n  if (Random.nextBoolean()) throw exceptions(Random.nextInt(exceptions.size))\n  Thread.sleep(mixTime.toMillis)\n  import g._\n  Dough(eggs * 50 + flour + sugar + chocolate)\n} catch {\n  case SlowRotationSpeedException =>\n    Thread.sleep(mixTime.toMillis * 2)\n    import g._\n    Dough(eggs * 50 + flour + sugar + chocolate)\n}\n```", "```java\ndef subMixFlow: Flow[Groceries, Dough, NotUsed] =\n  Flow[Groceries].async(\"mixers-dispatcher\", 1).map(mix).recover {\n    case MotorOverheatException => Dough(0)\n  }\n```", "```java\nval strategy: Supervision.Decider = {\n  case StrongVibrationException   ⇒ Supervision.resume\n  case _ => Supervision.Stop\n}\n```", "```java\nprivate def subMixFlow: Flow[Groceries, Dough, NotUsed] =\n  Flow[Groceries].async(\"mixers-dispatcher\", 1).map(mix).recover {\n    case MotorOverheatException => Dough(0)\n  }.withAttributes(ActorAttributes.supervisionStrategy(strategy))\n```", "```java\n\"manager source\" should {\n  \"emit shopping lists as needed\" in {\n    val future: Future[Seq[ShoppingList]] = Manager.manager.take(100).runWith(Sink.seq)\n    val result: Seq[ShoppingList] = Await.result(future, 1.seconds)\n    assert(result.size == 100)\n  }\n}\n```", "```java\nimplicit val as: ActorSystem = ActorSystem(\"test\")\nimplicit val mat: Materializer = ActorMaterializer()\n```", "```java\n\"cook flow\" should {\n  \"convert flow elements one-to-one\" in {\n    val source = Source.repeat(Dough(100)).take(1000)\n    val sink = Sink.seq[RawCookies]\n    val future: Future[Seq[RawCookies]] = source.via(Cook.formFlow).runWith(sink)\n    val result: Seq[RawCookies] = Await.result(future, 1.seconds)\n    assert(result.size == 1000)\n    assert(result.forall(_.count == 2))\n  }\n}\n```", "```java\nlibraryDependencies += com.typesafe.akka\" %% \"akka-testkit\" % akkaVersion % Test\n```", "```java\n\"the boy flow\" should {\n  \"lookup a remote seller and communicate with it\" in {\n    val probe = TestProbe()\n    val source = Manager.manager.take(1)\n    val sink = Sink.actorRef[Groceries](probe.ref, NotUsed)\n    source.via(Boy.shopFlow).runWith(sink)\n    probe.expectMsgType[Groceries]\n  }\n}\n```", "```java\nlibraryDependencies ++= \"com.typesafe.akka\" %% \"akka-stream-testkit\" % akkaVersion % Test\n```", "```java\n\"the whole flow\" should {\n  \"produce cookies\" in {\n    val testSink = TestSink.probe[ReadyCookies]\n    val source = TestSource.probe[ShoppingList]\n    val (publisher: TestPublisher.Probe[ShoppingList],\n         subscriber: TestSubscriber.Probe[ReadyCookies]) =\n      source.via(Bakery.flow).toMat(testSink)(Keep.both).run()\n    subscriber.request(10)\n    publisher.sendNext(ShoppingList(30, 1000, 100, 100))\n    subscriber.expectNext(40.seconds, ReadyCookies(12))\n subscriber.expectNext(40.seconds, ReadyCookies(12))\n  }\n}\n```"]