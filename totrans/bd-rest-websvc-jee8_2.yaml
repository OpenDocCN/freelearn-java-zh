- en: Building Synchronous Web Services and Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go into the details of building synchronous microservices
    with Java EE 8\. We will learn how to implement server-side REST APIs using basic
    JAX-RS annotations, implement sub-resource locators for nested REST APIs, and
    use HTTP status codes and exception mappers for exception handling. You will also
    learn how to implement the client side using JAX-RS client APIs, and finally,
    we will have a look at different test strategies for Java EE web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following sections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic REST APIs with JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sub-resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling in JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing web service clients with Java EE 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Java EE 8 web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we'll have implemented a small library microservice
    that offers a REST API for books, authors, and loans. We'll implement the library
    client as a standalone application and use the Jersey Test Framework and the Test
    Containers framework to test our REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic REST APIs with JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at how to implement a REST resource
    using basic JAX-RS annotations. I''ll show you how you can inject and use CDI
    beans in your JAX-RS resource implementation and show you how to properly use
    HTTP methods to model CRUD semantics, and of course we''ll be running the web
    service within a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d327924a-14b1-46b9-93c6-fc5c1be9382d.png)'
  prefs: []
  type: TYPE_IMG
- en: Conceptual view of this section
  prefs: []
  type: TYPE_NORMAL
- en: We'll implement a REST API to get a list of books so that we'll be able to create
    new books, get a book by ISBN, update books, and delete a book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a basic project skeleton and prepare a simple class, which is
    called `BookResource`, and we will use this to implement the CRUD REST API for
    our books. So first up, we need to annotate our class using the proper annotations.
    We will use the `@Path` annotation to specify the path for our books API, which
    is `"books"`, and we make a `@RequestScoped` CDI bean. Now, to implement our business
    logic, we want to use another CDI bean, thus we need to get it injected into this
    one. This other CDI bean is called `bookshelf`, and we''ll use the usual CDI `@Inject`
    annotation to get a reference to our `bookshelf`. Next up, we want to implement
    a method to get hold of a list of all books, so let''s do that. What you see here
    is we have a `books` method, which is `@GET` annotated, and it produces `MediaType.APPLICATION_JSON`
    and returns a JAX-RS response. You can see that we construct a response of `ok`,
    which is HTTP 200; as the body, we use `bookshelf.findAll`, which is a collection
    of books, and then we build the response. The `BookResource.java` file should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we want to implement a `GET` message to get a specific book. To do
    that, again we have a `@GET` annotated method, but this time we have the `@Path` annotation
    with the `"/{isbn}"` parameter. To get hold of this parameter, which is called
    the `isbn`, we use the `@PathParam` annotation to pass the value. We use `bookshelf`
    to find our book by ISBN and return the book found using the HTTP status code 200, that
    is, `ok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we want to create books. In order to create something, it''s a convention
    to use HTTP `POST` as a method. We consume the application JSON and we expect
    the JSON structure of a book, we call `bookshelf.create` with the `book` parameter,
    and then we use `UriBuilder` to construct the URI for the just-created `book`;
    this is also a convention. We then return this URI using `Response.created`, which
    matches the HTTP status code `201`, and we''ll call `build()` to build the final
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll implement the update method for an existing book. To update
    things, again it''s a convention to use the HTTP method `PUT`. We update this
    by putting in a specific location. Again, we use the `@Path` parameter with a
    value of `"/{isbn}"`. We give a reference to this `isbn` here in the `update`
    method parameter, and we have the JSON structure of our book ready. We use `bookshelf.update`
    to update the book and in the end we return the status code `ok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re going to implement the delete message, and as you might expect,
    we use the HTTP method `DELETE` on the path of an identified ISBN. Again, we use
    the `@PathParam` annotation here, we call `bookshelf.delete`, and we return `ok` if
    everything went well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our CRUD implementation for our book resource. I told you that we''re
    going to use a Docker container and the Payara Server micro edition to run everything.
    We will copy our WAR file to the `deployments` directory and then we''re up and
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's see if everything's running on our REST client (Postman).
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we get a list of books. As you can see here, this works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/136d39f9-cffc-40cf-aa86-5b211adf0848.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to create a new book, we issue the POST and create new book request,
    and you''ll see a status code of OK 200\. We get the new book by using GET new
    book; this is the book we just created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f746e17-512d-40e8-b2d9-ef155128560e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can update the book by using Update new book, and we''ll get a status code
    of OK 200\. We can get the updated book again by using GET new book; we get the
    updated title, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30531a36-50a6-4e53-9307-1fb7cd51bdfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we can delete the book. When we get the list of books again, our newly
    created book is not part of the list of books anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to have a look at how we can use sub-resources
    and sub-resource locators.
  prefs: []
  type: TYPE_NORMAL
- en: Using sub-resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at how to implement simple sub-resource
    locator methods. We''ll have a look at how you can obtain CDI sub-resource instances
    from the root resource, and we''re going to have a look at how you can pass context
    information from the root to the sub-resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55eb5884-74ac-4817-9914-30374d7d095f.png)'
  prefs: []
  type: TYPE_IMG
- en: Conceptual view of this section
  prefs: []
  type: TYPE_NORMAL
- en: 'Books have authors, and they can be lent out. In this section, what we''ll
    do is provide specific REST endpoints to obtain the author of a book and the loan
    details of the books. We have prepared the skeleton of the project, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/580bceab-1bdd-44cf-a517-6391b6244a7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the authors. In `BookResource.java`, add a resource locator
    method. A resource locator method is a simple method that is only annotated using
    the `@Path` annotation. In this case, we use `@Path("/{isbn}/author")`. The `return`
    type of a resource locator method is another resource. In this case, it''s the
    `AuthorResource` locator method. Thus, we create the `AuthorResource` locator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces `APPLICATION_JSON`. We get a reference to our book in the constructor.
    Next up in this sub-resource, we can add the usual `GET`, `POST`, or `PUT` annotated
    HTTP methods again. In this case, we have one `GET` method annotated, which gets
    the author of our book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is really straightforward for simple resources, but what if we want to
    use CDI injection? If we want to do that, we need to take a different approach.
    First, we need to get a reference to `ResourceContext`; make sure you use the
    right one. By using this `ResourceContext`, we can get hold of a reference that
    is fully CDI injected. Again, we annotated using `@Path`, returned `loanResource`,
    and this time we used `context.getResource` from `LoanResource.class`. This returns
    a fully injected `loanResource` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then populate `LoanResource` using the `@Path("/{isbn}")` parameter. Now,
    the important bit: because we did this, you really need to make sure that this
    instance is `@RequestScoped`. This is because we pass in the `isbn` and here you
    can implement the usual REST resource methods we need for `LoanResource`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, for example, we will get the specific loan, and we can return
    a book, we can lend a book to create a loan.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we switch to a REST client (Postman) and we want to obtain the book author
    by using the GET book author request, and click on Send and only the author is
    returned, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/220852b3-021f-4360-8342-3f978160282b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can obtain a list of loans, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36e2300c-9343-417e-9751-c9b3e3db0c99.png)'
  prefs: []
  type: TYPE_IMG
- en: We can delete a loan, which means that the book has been returned, we can add
    new loans, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to cover how to perform error handling in JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at handling user and server-side
    errors in a RESTful way by using an appropriate HTTP status code, for example,
    HTTP status code 400 Bad Request for invalid and malformed requests, status 404
    Not Found if something could not be found, and HTTP status code 500 Internal Server
    Error if something happens unexpectedly. We''ll also see how to use `WebApplicationException`
    and its subclasses to model error handling, and finally we''ll be implementing
    a custom `ExceptionMappers` to handle runtime exceptions and return custom error
    responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a789dad9-5c0c-415e-928c-f7da91abc4bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Conceptual view of this section
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we''ll do conceptually in this section: we''ll again extend our
    library microservice by several HTTP status codes , for example, HTTP 400 if you
    issue an invalid book update, 409 for creating an already existing book, 404 for
    unknown books and loans, and HTTP status code 500 for general errors with a custom
    response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to our IDE and return to `BookResource` again. Here, we haven''t
    taken much care of proper error handling so far. As you can see in `bookshelf.create(book)`,
    for example, we create the book without checking whether the book already exists.
    The simplest way is to perform the checking before you do any work. To do that,
    we use our `bookshelf` to check whether the book—or to be more precise, the ISBN
    of the book—already exists, and if it does, we return a custom status code and
    we set the status to `CONFLICT`, which is 409, and the error response will be
    returned immediately. This is the most basic form of error handling, by returning
    a response with the appropriate status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for `update`; we should check that the updated ISBN matches the
    ISBN of the book. What we could do here is again set the appropriate status code,
    which in this case is `BAD_REQUEST`, with a status code of 400:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways of doing this as well. A different approach you could choose
    is to throw a `WebApplicationException`, which is part of JAX-RS. You give it
    a reason and you give it a status code which is `BAD_REQUEST` again. For the most
    common types of `WebApplicationException`, there are predefined subclasses; in
    this `WebApplicationException`, you can see there are several subclasses available
    and there's already a `BadRequestException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `BadRequestException` instead, and we''re done. This `BadRequestException` automatically
    sets the status code to 400 for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that's done, of course there are a lot of other exceptions that can happen,
    such as custom runtime exceptions and persistence exceptions, that might throw
    our JPA provider. So, how do we handle those? The most convenient way is to have
    a `PersistenceExceptionMapper` implementation. Create a class and implement `ExceptionMapper`,
    and use the exception you want to be handled as a generic type. In this case,
    it's `PersistenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is annotate it using the `@Provider` annotation.
    Do that, and then you can implement the custom transformation logic that maps
    `PersistenceException` to the actual `Response` and the HTTP status code you''re
    expecting. For example, if the exception is an instance of `EntityNotFoundException`,
    we will return 404, which is `NOT_FOUND`. In case anything else happens, we want
    to return a custom error response structure. In this case, we use a plain `Map`,
    a `HashMap`, and maybe set a `code` and a `type`. We include the `message` and
    as a `Response`, we return to `INTERNAL_SERVER_ERROR`, which is status code 500,
    and we use `type` as `MediaType.APPLICATION_JSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we switch to our REST client, we can see those things in action. In case
    we get an unknown book which should trigger the entity 404 `NOT_FOUND` exception,
    this is what we expect. For example, if we issue a wrong update request for a
    book, we expect HTTP status code 400 Bad Request, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50c97a5d-877b-478a-9929-7c334a311ea0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is it on error handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about implementing web service clients with
    Java EE 8.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing web service clients with Java EE 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at the JAX-RS client APIs and
    how to implement web service clients. I''m going to show you how you can set up
    and configure a JAX-RS client instance. We''ll use `WebTarget` and its builder
    to specify request behavior, resolve URI template parameters, do invocation in
    response handling, and use `GenericType` implementations to get unmarshalled typed
    collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7663c3c8-e806-4b67-b39a-b5770170889c.png)'
  prefs: []
  type: TYPE_IMG
- en: Conceptual view of this section
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've implemented our small library service, which supports books, authors,
    and loans, via a REST API. We'll then implement a library client which is a standalone
    client to get a list of books, unknown books, to create books, to get books with
    the returned URI, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to our IDE. We will create a small class called `LibraryServiceClient`,
    which is our standalone application. The first thing we need to do is activate
    a few dependencies. Most importantly, we want to use the `jersey-client` dependency
    and we''ll also be using the `jersey-media-json-binding` dependency. This is required
    to implement our standalone application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is construct a JAX-RS client instance, and we
    use `ClientBuilder` to do that. Here, when we use `ClientBuilder.newBuilder`,
    we specify parameters such as `connectTimeout` and `readTimeout`, we also register
    `JsonBindingFeature`, and then finally we call the `build()` method on the builder.
    Once we have our `client`, we can use it to construct what is called a `WebTarget`.
    `WebTarget` is basically the endpoint we''re going to talk to. We use `client.target`
    and mention `localhost:8080` because our service is running locally on `localhost:8080`.
    We give `path("/library-service/api")`, which is the root of our REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To obtain a list of books, we can use this `WebTarget` for the invocation by
    importing a few things here. What we do is we use `api.path("/books").request`,
    accept `MediaType.APPLICATION_JSON`, and then we get a list of books. Because
    this is a generically typed list, we need to use the `GenericType` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a `GenericType` subclass and specify `List<Book>` as the `GenericType`
    parameter. What if we want to get a book, maybe an unknown book? If we get an
    unknown book, we expect a status code of 404\. Again, we use `api.path("/books").path("/{isbn}")`;
    which is a `path` parameter. Therefore we resolve the template using a specific
    parameter and value. We use `request`, `accept`, and `get()`. By calling `get()`,
    we only get the actual `response`, and in that `response`, we use `getStatus()`,
    which is `404`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to create books, we can do that in a similar way. Again, we create
    a new book and in here we use `api.path("/books").requestMediaType.APPLICATION_JSON`,
    which specifies the content type of our payload. We use `post(Entity.json(book))`
    and expect a status code of 201\. If you want to get hold of the just-created
    book, what we can do is obtain the `URI` of the `response`. We get the location
    and then we use the client again for the target URI, we `request()`, we accept
    `MediaType.APPLICATION_JSON`, and we get a POJO of the `Book` class. In such a
    case, we automatically get the unmarshalled book back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic workings of the JAX-RS client APIs. Last but not least, you
    should not forget to close the client (`client.close()`) to free up any resources.
    If you want, you can do some cleanup. Maybe we want to delete the book we created
    previously. We need the following code to delete the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is all there is to it for this section. In the next section, we'll talk
    about testing Java EE 8 web services.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Java EE 8 web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at different test strategies for
    Java EE 8 web services. We'll talk about testing simple CDI components with plain
    unit tests and mocks, testing REST resources using the Jersey Test Framework,
    and we'll see how to do black box integration testing using the Test Containers
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've implemented our library service by offering a REST API for books,
    authors, and loans. We also implemented the library client. In this section, we'll
    talk about testing. You can see the test pyramid in the following diagram. At
    the bottom, there are unit tests. The middle layer is the service layer tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top level, you have UI layer tests. Unit testing in Java EE is really
    simple; you can use your standard test frameworks such as JUnit testing, and you
    may use Mojito or other mocking frameworks to mock any dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e984dea2-c791-46b4-9c52-7906f5de1470.png)'
  prefs: []
  type: TYPE_IMG
- en: Conceptual view on this section
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t focus on unit tests here. What''s really nice in Java EE is how we
    can do service level testing. There are two frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: Jersey Test Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test Containers framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's use them both.
  prefs: []
  type: TYPE_NORMAL
- en: Jersey Test Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the **Jersey Test Framework**. We will switch to our IDE
    and in order to use the Jersey Test Framework, you need to add one simple dependency,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Jersey offers several test providers; in this case, we will be using the `grizzly2`
    provider. What do you need to do to use this test framework? First of all, you
    need to implement a test class, say `VersionResourceTest`, and you need to make
    it extend the `JerseyTest` superclass. Next thing you need to do is override the
    `configure` method, and what you do here is construct a `ResourceConfig` and pass
    the resource you want to test. In our case, we want to test `VersionResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing you can do is configure the client that is used to test against
    our resource. The client here is actually the same one we were using in the previous
    section, that is, `JsonBindingFeature`, and once you''ve done that, you can implement
    the actual tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to test the `v1` resource, what we can do is specify the target
    version as `v1`. We use `request` and `target`, and on the `response` returned,
    we can then specify our usual assertions. Then, assert that the response status
    code is 200 and that the entity of type string contains the string `"v1.0"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our test. You can see here that the test is actually firing
    up a small `grizzly` server that is deploying our resource, and then it''s actually
    firing HTTP calls against our resource. These are the proper integration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d97d2b38-fee3-49b2-810c-8ba37e24e5d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Test Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the next test framework, which is called **Test Containers**.
    We need to add the following two dependencies to activate the Test Containers
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea behind Test Containers is really simple. Since we''re going to deploy
    our web service in a Docker container anyway, why not use a Docker container during
    our test as well? All you need to add is a `@ClassRule`. We create `GenericContainer`,
    we pass it to a `Dockerfile`, we pass it to the WAR file (`library-service.war`)
    we want to package, we can specify a `Wait` strategy, a `LogConsumer`, and we
    expose ports. All this code does is fire up a Docker container when this test
    starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `setUp` phase, what we can do is we can set up a JAX-RS client instance
    as we''ve done previously, and once we have the client, we can set up a web target
    against the container URI. We can ask for the container IP address and the map
    port of our service, and once we have the web `target`, we can use the JAX-RS
    client API to interact with our microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command from your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'What this does is basically run unit tests and integration tests. First up,
    the Surefire Plugin tests our version resource, we see everything firing up, it
    runs the other unit tests, packaging the WAR file. The Failsafe Plugin will run
    our container integration tests. It''ll create and start the container; this might
    take quite a long time. You can see that the tests completed successfully in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92f8007a-bdcd-4370-8199-0130dc3e09f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's summarize what we learned in this chapter. We had a look at basic JAX-RS
    annotations in order to implement a REST API with CRUD functionality. We used
    top resource locators to nicely model nested REST APIs. We used HTTP status codes
    and exception mappers for error handling. We implemented web service clients using
    the JAX-RS service client API. Finally, we had a look at testing Java EE 8-based
    web services using several approaches. I hope you enjoyed this chapter. In the
    next chapter, we will talk about content marshaling with JSON-B and JSON-P.
  prefs: []
  type: TYPE_NORMAL
