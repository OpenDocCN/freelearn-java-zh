- en: Building Synchronous Web Services and Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Synchronous Web 服务和客户端
- en: In this chapter, we will go into the details of building synchronous microservices
    with Java EE 8\. We will learn how to implement server-side REST APIs using basic
    JAX-RS annotations, implement sub-resource locators for nested REST APIs, and
    use HTTP status codes and exception mappers for exception handling. You will also
    learn how to implement the client side using JAX-RS client APIs, and finally,
    we will have a look at different test strategies for Java EE web services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解使用 Java EE 8 构建同步微服务的细节。我们将学习如何使用基本的 JAX-RS 注解实现服务器端 REST API，实现嵌套
    REST API 的子资源定位器，并使用 HTTP 状态码和异常映射器进行异常处理。你还将学习如何使用 JAX-RS 客户端 API 实现客户端，最后，我们将探讨
    Java EE 网络服务的不同测试策略。
- en: 'We''ll cover the following sections in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下部分：
- en: Implementing basic REST APIs with JAX-RS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 实现基本 REST API
- en: Using sub-resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子资源
- en: Error handling in JAX-RS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 中的错误处理
- en: Implementing web service clients with Java EE 8
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java EE 8 实现网络服务客户端
- en: Testing Java EE 8 web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Java EE 8 网络服务
- en: By the end of this chapter, we'll have implemented a small library microservice
    that offers a REST API for books, authors, and loans. We'll implement the library
    client as a standalone application and use the Jersey Test Framework and the Test
    Containers framework to test our REST API.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将实现一个小型库微服务，该服务提供书籍、作者和借阅的 REST API。我们将实现库客户端作为一个独立的应用程序，并使用 Jersey
    测试框架和 Test Containers 框架来测试我们的 REST API。
- en: Implementing basic REST APIs with JAX-RS
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 实现基本 REST API
- en: 'In this section, we''re going to take a look at how to implement a REST resource
    using basic JAX-RS annotations. I''ll show you how you can inject and use CDI
    beans in your JAX-RS resource implementation and show you how to properly use
    HTTP methods to model CRUD semantics, and of course we''ll be running the web
    service within a Docker container:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用基本的 JAX-RS 注解实现 REST 资源。我会向你展示如何在 JAX-RS 资源实现中注入和使用 CDI 容器，并展示如何正确使用
    HTTP 方法来模拟 CRUD 语义，当然我们将在 Docker 容器中运行我们的网络服务：
- en: '![](img/d327924a-14b1-46b9-93c6-fc5c1be9382d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d327924a-14b1-46b9-93c6-fc5c1be9382d.png)'
- en: Conceptual view of this section
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的概念视图
- en: We'll implement a REST API to get a list of books so that we'll be able to create
    new books, get a book by ISBN, update books, and delete a book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个 REST API 来获取书籍列表，这样我们就能创建新的书籍，通过 ISBN 获取书籍，更新书籍，以及删除书籍。
- en: 'We will create a basic project skeleton and prepare a simple class, which is
    called `BookResource`, and we will use this to implement the CRUD REST API for
    our books. So first up, we need to annotate our class using the proper annotations.
    We will use the `@Path` annotation to specify the path for our books API, which
    is `"books"`, and we make a `@RequestScoped` CDI bean. Now, to implement our business
    logic, we want to use another CDI bean, thus we need to get it injected into this
    one. This other CDI bean is called `bookshelf`, and we''ll use the usual CDI `@Inject`
    annotation to get a reference to our `bookshelf`. Next up, we want to implement
    a method to get hold of a list of all books, so let''s do that. What you see here
    is we have a `books` method, which is `@GET` annotated, and it produces `MediaType.APPLICATION_JSON`
    and returns a JAX-RS response. You can see that we construct a response of `ok`,
    which is HTTP 200; as the body, we use `bookshelf.findAll`, which is a collection
    of books, and then we build the response. The `BookResource.java` file should
    look as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的项目骨架，并准备一个简单的类，称为 `BookResource`，我们将使用它来实现我们书籍的 CRUD REST API。所以首先，我们需要使用适当的注解来注解我们的类。我们将使用
    `@Path` 注解来指定书籍 API 的路径，即 `"books"`，并创建一个 `@RequestScoped` 的 CDI 容器。现在，为了实现我们的业务逻辑，我们想要使用另一个
    CDI 容器，因此我们需要将其注入到这个容器中。这个其他 CDI 容器被称为 `bookshelf`，我们将使用常规的 CDI `@Inject` 注解来获取对
    `bookshelf` 的引用。接下来，我们想要实现一个方法来获取所有书籍的列表，让我们来做这件事。你在这里看到的是我们有一个 `books` 方法，它被
    `@GET` 注解，并产生 `MediaType.APPLICATION_JSON`，返回一个 JAX-RS 响应。你可以看到我们构建了一个 `ok` 的响应，即
    HTTP 200；作为主体，我们使用 `bookshelf.findAll`，这是一个书籍集合，然后我们构建响应。`BookResource.java` 文件应该如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next up, we want to implement a `GET` message to get a specific book. To do
    that, again we have a `@GET` annotated method, but this time we have the `@Path` annotation
    with the `"/{isbn}"` parameter. To get hold of this parameter, which is called
    the `isbn`, we use the `@PathParam` annotation to pass the value. We use `bookshelf`
    to find our book by ISBN and return the book found using the HTTP status code 200, that
    is, `ok`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要实现一个`GET`消息来获取特定的书籍。为了做到这一点，我们再次有一个`@GET`注解的方法，但这次我们有一个`@Path`注解，带有`"/{isbn}"`参数。为了获取这个参数，即所谓的`isbn`，我们使用`@PathParam`注解来传递值。我们使用`bookshelf`通过ISBN查找我们的书籍，并使用HTTP状态码200，即`ok`返回找到的书籍：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up, we want to create books. In order to create something, it''s a convention
    to use HTTP `POST` as a method. We consume the application JSON and we expect
    the JSON structure of a book, we call `bookshelf.create` with the `book` parameter,
    and then we use `UriBuilder` to construct the URI for the just-created `book`;
    this is also a convention. We then return this URI using `Response.created`, which
    matches the HTTP status code `201`, and we''ll call `build()` to build the final
    response:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建书籍。为了创建某些内容，按照惯例，我们使用HTTP `POST`作为方法。我们消费应用程序JSON，并期望得到书籍的JSON结构，我们使用`bookshelf.create`与`book`参数一起调用，然后我们使用`UriBuilder`来构造新创建的`book`的URI；这也是一个惯例。然后我们使用`Response.created`返回这个URI，这与HTTP状态码`201`相匹配，我们将调用`build()`来构建最终的响应：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next up, we''ll implement the update method for an existing book. To update
    things, again it''s a convention to use the HTTP method `PUT`. We update this
    by putting in a specific location. Again, we use the `@Path` parameter with a
    value of `"/{isbn}"`. We give a reference to this `isbn` here in the `update`
    method parameter, and we have the JSON structure of our book ready. We use `bookshelf.update`
    to update the book and in the end we return the status code `ok`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现现有书籍的更新方法。为了更新内容，再次按照惯例使用HTTP方法`PUT`。我们通过指定位置来更新，再次使用`@Path`参数，其值为`"/{isbn}"`。我们在`update`方法参数中给出这个`isbn`的引用，并准备好我们书籍的JSON结构。我们使用`bookshelf.update`来更新书籍，并在最后返回状态码`ok`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we''re going to implement the delete message, and as you might expect,
    we use the HTTP method `DELETE` on the path of an identified ISBN. Again, we use
    the `@PathParam` annotation here, we call `bookshelf.delete`, and we return `ok` if
    everything went well:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现删除消息，正如你所预期的，我们在已识别的ISBN路径上使用HTTP方法`DELETE`。在这里，我们再次使用`@PathParam`注解，我们调用`bookshelf.delete`，如果一切顺利，我们返回`ok`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is our CRUD implementation for our book resource. I told you that we''re
    going to use a Docker container and the Payara Server micro edition to run everything.
    We will copy our WAR file to the `deployments` directory and then we''re up and
    running:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对书籍资源的CRUD实现。我告诉过你们，我们将使用Docker容器和Payara Server微版来运行一切。我们将把我们的WAR文件复制到`deployments`目录，然后我们就可以启动运行了：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's see if everything's running on our REST client (Postman).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的REST客户端（Postman）上是否一切运行正常。
- en: 'First up, we get a list of books. As you can see here, this works as expected:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取书籍列表。如你所见，这按预期工作：
- en: '![](img/136d39f9-cffc-40cf-aa86-5b211adf0848.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/136d39f9-cffc-40cf-aa86-5b211adf0848.png)'
- en: 'If we want to create a new book, we issue the POST and create new book request,
    and you''ll see a status code of OK 200\. We get the new book by using GET new
    book; this is the book we just created, as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一本新书，我们发出`POST`和创建新书籍请求，你会看到一个状态码OK 200。我们通过使用`GET新书籍`来获取新书籍；这就是我们刚刚创建的书籍，如以下截图所示：
- en: '![](img/6f746e17-512d-40e8-b2d9-ef155128560e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f746e17-512d-40e8-b2d9-ef155128560e.png)'
- en: 'We can update the book by using Update new book, and we''ll get a status code
    of OK 200\. We can get the updated book again by using GET new book; we get the
    updated title, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用“更新新书籍”来更新书籍，我们将得到状态码OK 200。我们可以再次使用`GET新书籍`来获取更新后的书籍；我们得到更新后的标题，如以下截图所示：
- en: '![](img/30531a36-50a6-4e53-9307-1fb7cd51bdfd.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30531a36-50a6-4e53-9307-1fb7cd51bdfd.png)'
- en: Finally, we can delete the book. When we get the list of books again, our newly
    created book is not part of the list of books anymore.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以删除书籍。当我们再次获取书籍列表时，我们新创建的书籍不再包含在书籍列表中。
- en: In the next section, we're going to have a look at how we can use sub-resources
    and sub-resource locators.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用子资源和子资源定位器。
- en: Using sub-resources
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子资源
- en: 'In this section, we''re going to take a look at how to implement simple sub-resource
    locator methods. We''ll have a look at how you can obtain CDI sub-resource instances
    from the root resource, and we''re going to have a look at how you can pass context
    information from the root to the sub-resources:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实现简单的子资源定位器方法。我们将看看如何从根资源获取CDI子资源实例，以及我们将探讨如何从根资源传递上下文信息到子资源：
- en: '![](img/55eb5884-74ac-4817-9914-30374d7d095f.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55eb5884-74ac-4817-9914-30374d7d095f.png)'
- en: Conceptual view of this section
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的概念视图
- en: 'Books have authors, and they can be lent out. In this section, what we''ll
    do is provide specific REST endpoints to obtain the author of a book and the loan
    details of the books. We have prepared the skeleton of the project, as shown in
    the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍有作者，并且可以被借出。在本节中，我们将提供特定的REST端点来获取书籍的作者和书籍的借阅详情。我们已经准备了项目的骨架，如下面的截图所示：
- en: '![](img/580bceab-1bdd-44cf-a517-6391b6244a7c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/580bceab-1bdd-44cf-a517-6391b6244a7c.png)'
- en: 'Let''s start with the authors. In `BookResource.java`, add a resource locator
    method. A resource locator method is a simple method that is only annotated using
    the `@Path` annotation. In this case, we use `@Path("/{isbn}/author")`. The `return`
    type of a resource locator method is another resource. In this case, it''s the
    `AuthorResource` locator method. Thus, we create the `AuthorResource` locator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从作者开始。在`BookResource.java`中添加一个资源定位器方法。资源定位器方法是一个简单的只使用`@Path`注解的方法。在这种情况下，我们使用`@Path("/{isbn}/author")`。资源定位器方法的`return`类型是另一个资源。在这种情况下，它是`AuthorResource`定位器方法。因此，我们创建了`AuthorResource`定位器：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It produces `APPLICATION_JSON`. We get a reference to our book in the constructor.
    Next up in this sub-resource, we can add the usual `GET`, `POST`, or `PUT` annotated
    HTTP methods again. In this case, we have one `GET` method annotated, which gets
    the author of our book:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成`APPLICATION_JSON`。我们在构造函数中获取我们书籍的引用。接下来在这个子资源中，我们可以再次添加常用的`GET`、`POST`或`PUT`注解的HTTP方法。在这种情况下，我们有一个注解的`GET`方法，它获取我们书籍的作者：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is really straightforward for simple resources, but what if we want to
    use CDI injection? If we want to do that, we need to take a different approach.
    First, we need to get a reference to `ResourceContext`; make sure you use the
    right one. By using this `ResourceContext`, we can get hold of a reference that
    is fully CDI injected. Again, we annotated using `@Path`, returned `loanResource`,
    and this time we used `context.getResource` from `LoanResource.class`. This returns
    a fully injected `loanResource` instance:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的资源来说，这非常直接，但如果我们想使用CDI注入呢？如果我们想这么做，我们需要采取不同的方法。首先，我们需要获取`ResourceContext`的引用；确保你使用的是正确的。通过使用这个`ResourceContext`，我们可以获取一个完全CDI注入的引用。再次，我们使用`@Path`注解，返回`loanResource`，这次我们使用了`LoanResource.class`中的`context.getResource`。这返回了一个完全注入的`loanResource`实例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then populate `LoanResource` using the `@Path("/{isbn}")` parameter. Now,
    the important bit: because we did this, you really need to make sure that this
    instance is `@RequestScoped`. This is because we pass in the `isbn` and here you
    can implement the usual REST resource methods we need for `LoanResource`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`@Path("/{isbn}")`参数填充`LoanResource`。现在，重要的一点是：因为我们做了这件事，你真的需要确保这个实例是`@RequestScoped`。这是因为我们传递了`isbn`，在这里你可以实现我们需要的常规REST资源方法`LoanResource`。
- en: In this case, for example, we will get the specific loan, and we can return
    a book, we can lend a book to create a loan.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，例如，我们将获取特定的贷款，我们可以返回一本书，我们可以借出一本书来创建一笔贷款。
- en: 'If we switch to a REST client (Postman) and we want to obtain the book author
    by using the GET book author request, and click on Send and only the author is
    returned, as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到REST客户端（Postman），并想通过使用GET book author请求来获取书籍作者，点击发送后，只返回作者信息，如下面的截图所示：
- en: '![](img/220852b3-021f-4360-8342-3f978160282b.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/220852b3-021f-4360-8342-3f978160282b.png)'
- en: 'We can obtain a list of loans, as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取贷款列表，如下面的截图所示：
- en: '![](img/36e2300c-9343-417e-9751-c9b3e3db0c99.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36e2300c-9343-417e-9751-c9b3e3db0c99.png)'
- en: We can delete a loan, which means that the book has been returned, we can add
    new loans, and so on and so forth.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除一笔贷款，这意味着这本书已经被归还，我们还可以添加新的贷款等等。
- en: In the next section, we're going to cover how to perform error handling in JAX-RS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何在JAX-RS中执行错误处理。
- en: Error handling in JAX-RS
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS中的错误处理
- en: 'In this section, we''re going to take a look at handling user and server-side
    errors in a RESTful way by using an appropriate HTTP status code, for example,
    HTTP status code 400 Bad Request for invalid and malformed requests, status 404
    Not Found if something could not be found, and HTTP status code 500 Internal Server
    Error if something happens unexpectedly. We''ll also see how to use `WebApplicationException`
    and its subclasses to model error handling, and finally we''ll be implementing
    a custom `ExceptionMappers` to handle runtime exceptions and return custom error
    responses:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用适当的HTTP状态码以RESTful方式处理用户和服务器端错误，例如，对于无效和格式错误的请求，使用HTTP状态码400 Bad
    Request，如果找不到某些内容，则使用状态404 Not Found，如果发生意外情况，则使用HTTP状态码500 Internal Server Error。我们还将看到如何使用`WebApplicationException`及其子类来模拟错误处理，最后我们将实现自定义的`ExceptionMappers`来处理运行时异常并返回自定义错误响应：
- en: '![](img/a789dad9-5c0c-415e-928c-f7da91abc4bd.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a789dad9-5c0c-415e-928c-f7da91abc4bd.png)'
- en: Conceptual view of this section
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的概念视图
- en: 'This is what we''ll do conceptually in this section: we''ll again extend our
    library microservice by several HTTP status codes , for example, HTTP 400 if you
    issue an invalid book update, 409 for creating an already existing book, 404 for
    unknown books and loans, and HTTP status code 500 for general errors with a custom
    response.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从概念上做以下事情：我们将通过几个HTTP状态码扩展我们的库微服务，例如，如果你发布了一个无效的书籍更新，则为HTTP 400，对于创建已存在的书籍，为409，对于未知书籍和借阅，为404，对于具有自定义响应的一般错误，为HTTP状态码500。
- en: 'Let''s switch to our IDE and return to `BookResource` again. Here, we haven''t
    taken much care of proper error handling so far. As you can see in `bookshelf.create(book)`,
    for example, we create the book without checking whether the book already exists.
    The simplest way is to perform the checking before you do any work. To do that,
    we use our `bookshelf` to check whether the book—or to be more precise, the ISBN
    of the book—already exists, and if it does, we return a custom status code and
    we set the status to `CONFLICT`, which is 409, and the error response will be
    returned immediately. This is the most basic form of error handling, by returning
    a response with the appropriate status code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到我们的IDE，并再次回到`BookResource`。在这里，我们还没有对适当的错误处理给予太多关注。例如，在`bookshelf.create(book)`中，我们看到我们没有检查书籍是否已经存在。最简单的方法是在做任何工作之前进行检查。为此，我们使用`bookshelf`来检查书籍——更准确地说，是书籍的ISBN——是否已经存在，如果存在，我们返回一个自定义状态码，并将状态设置为`CONFLICT`，即409，错误响应将立即返回。这是最基本的错误处理形式，通过返回带有适当状态码的响应：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same goes for `update`; we should check that the updated ISBN matches the
    ISBN of the book. What we could do here is again set the appropriate status code,
    which in this case is `BAD_REQUEST`, with a status code of 400:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`update`来说，我们也应该检查更新的ISBN是否与书的ISBN相匹配。我们在这里可以再次设置适当的状态码，在这种情况下是`BAD_REQUEST`，状态码为400：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are other ways of doing this as well. A different approach you could choose
    is to throw a `WebApplicationException`, which is part of JAX-RS. You give it
    a reason and you give it a status code which is `BAD_REQUEST` again. For the most
    common types of `WebApplicationException`, there are predefined subclasses; in
    this `WebApplicationException`, you can see there are several subclasses available
    and there's already a `BadRequestException`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以做到这一点。你可以选择的一个不同方法是抛出一个`WebApplicationException`，它是JAX-RS的一部分。你给出一个原因，并给出一个状态码，再次是`BAD_REQUEST`。对于最常见的`WebApplicationException`类型，有预定义的子类；在这个`WebApplicationException`中，你可以看到有几个子类可用，并且已经有一个`BadRequestException`。
- en: 'Let''s use `BadRequestException` instead, and we''re done. This `BadRequestException` automatically
    sets the status code to 400 for us:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`BadRequestException`代替，这样就完成了。这个`BadRequestException`会自动为我们设置状态码为400：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that's done, of course there are a lot of other exceptions that can happen,
    such as custom runtime exceptions and persistence exceptions, that might throw
    our JPA provider. So, how do we handle those? The most convenient way is to have
    a `PersistenceExceptionMapper` implementation. Create a class and implement `ExceptionMapper`,
    and use the exception you want to be handled as a generic type. In this case,
    it's `PersistenceException`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他可能发生的异常，例如自定义运行时异常和持久性异常，可能会抛出我们的JPA提供者。那么我们如何处理这些异常呢？最方便的方法是有一个`PersistenceExceptionMapper`实现。创建一个类并实现`ExceptionMapper`，并使用你想要处理的异常作为泛型类型。在这种情况下，是`PersistenceException`。
- en: 'The first thing you need to do is annotate it using the `@Provider` annotation.
    Do that, and then you can implement the custom transformation logic that maps
    `PersistenceException` to the actual `Response` and the HTTP status code you''re
    expecting. For example, if the exception is an instance of `EntityNotFoundException`,
    we will return 404, which is `NOT_FOUND`. In case anything else happens, we want
    to return a custom error response structure. In this case, we use a plain `Map`,
    a `HashMap`, and maybe set a `code` and a `type`. We include the `message` and
    as a `Response`, we return to `INTERNAL_SERVER_ERROR`, which is status code 500,
    and we use `type` as `MediaType.APPLICATION_JSON`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是使用`@Provider`注解对其进行注释。完成这个步骤后，你可以实现自定义转换逻辑，将`PersistenceException`映射到实际的`Response`和期望的HTTP状态码。例如，如果异常是`EntityNotFoundException`的实例，我们将返回404，即`NOT_FOUND`。在发生其他任何情况时，我们希望返回一个自定义的错误响应结构。在这种情况下，我们使用一个普通的`Map`，一个`HashMap`，并可能设置一个`code`和一个`type`。我们包括`message`，并将`Response`返回为`INTERNAL_SERVER_ERROR`，状态码为500，并使用`type`作为`MediaType.APPLICATION_JSON`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we switch to our REST client, we can see those things in action. In case
    we get an unknown book which should trigger the entity 404 `NOT_FOUND` exception,
    this is what we expect. For example, if we issue a wrong update request for a
    book, we expect HTTP status code 400 Bad Request, as seen in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到我们的REST客户端，我们就可以看到这些功能在实际中的运用。如果我们收到一本未知书籍，这应该会触发实体404 `NOT_FOUND`异常，这是我们期望的结果。例如，如果我们对一个书籍发出错误的更新请求，我们期望HTTP状态码400
    Bad Request，如下截图所示：
- en: '![](img/50c97a5d-877b-478a-9929-7c334a311ea0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50c97a5d-877b-478a-9929-7c334a311ea0.png)'
- en: This is it on error handling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是错误处理的内容。
- en: In the next section, we will talk about implementing web service clients with
    Java EE 8.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论使用Java EE 8实现Web服务客户端。
- en: Implementing web service clients with Java EE 8
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java EE 8实现Web服务客户端
- en: 'In this section, we''re going to take a look at the JAX-RS client APIs and
    how to implement web service clients. I''m going to show you how you can set up
    and configure a JAX-RS client instance. We''ll use `WebTarget` and its builder
    to specify request behavior, resolve URI template parameters, do invocation in
    response handling, and use `GenericType` implementations to get unmarshalled typed
    collections:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨JAX-RS客户端API以及如何实现Web服务客户端。我将向您展示如何设置和配置一个JAX-RS客户端实例。我们将使用`WebTarget`及其构建器来指定请求行为，解析URI模板参数，在响应处理中进行调用，并使用`GenericType`实现来获取未反序列化的类型集合：
- en: '![](img/7663c3c8-e806-4b67-b39a-b5770170889c.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7663c3c8-e806-4b67-b39a-b5770170889c.png)'
- en: Conceptual view of this section
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的概念视图
- en: So far, we've implemented our small library service, which supports books, authors,
    and loans, via a REST API. We'll then implement a library client which is a standalone
    client to get a list of books, unknown books, to create books, to get books with
    the returned URI, and so forth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了我们的小型图书馆服务，它通过REST API支持书籍、作者和借阅。然后我们将实现一个图书馆客户端，这是一个独立客户端，用于获取书籍列表、未知书籍、创建书籍、获取带有返回URI的书籍等等。
- en: 'Let''s switch to our IDE. We will create a small class called `LibraryServiceClient`,
    which is our standalone application. The first thing we need to do is activate
    a few dependencies. Most importantly, we want to use the `jersey-client` dependency
    and we''ll also be using the `jersey-media-json-binding` dependency. This is required
    to implement our standalone application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到我们的IDE。我们将创建一个名为`LibraryServiceClient`的小类，这是我们独立的应用程序。我们首先需要做的是激活一些依赖项。最重要的是，我们希望使用`jersey-client`依赖项，我们还将使用`jersey-media-json-binding`依赖项。这是实现我们的独立应用程序所必需的：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first thing we need to do is construct a JAX-RS client instance, and we
    use `ClientBuilder` to do that. Here, when we use `ClientBuilder.newBuilder`,
    we specify parameters such as `connectTimeout` and `readTimeout`, we also register
    `JsonBindingFeature`, and then finally we call the `build()` method on the builder.
    Once we have our `client`, we can use it to construct what is called a `WebTarget`.
    `WebTarget` is basically the endpoint we''re going to talk to. We use `client.target`
    and mention `localhost:8080` because our service is running locally on `localhost:8080`.
    We give `path("/library-service/api")`, which is the root of our REST API:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是构建一个 JAX-RS 客户端实例，我们使用 `ClientBuilder` 来完成这个任务。在这里，当我们使用 `ClientBuilder.newBuilder`
    时，我们指定了如 `connectTimeout` 和 `readTimeout` 等参数，我们还注册了 `JsonBindingFeature`，然后最后在构建器上调用
    `build()` 方法。一旦我们有了 `client`，我们就可以用它来构建所谓的 `WebTarget`。`WebTarget` 基本上是我们将要与之通信的端点。我们使用
    `client.target` 并提到 `localhost:8080`，因为我们的服务在本地运行在 `localhost:8080`。我们给出 `path("/library-service/api")`，这是我们的
    REST API 的根：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To obtain a list of books, we can use this `WebTarget` for the invocation by
    importing a few things here. What we do is we use `api.path("/books").request`,
    accept `MediaType.APPLICATION_JSON`, and then we get a list of books. Because
    this is a generically typed list, we need to use the `GenericType` construct.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取书籍列表，我们可以使用这个 `WebTarget` 进行调用，在这里导入一些东西。我们做的是使用 `api.path("/books").request`，接受
    `MediaType.APPLICATION_JSON`，然后我们获取一个书籍列表。因为这是一个泛型类型的列表，我们需要使用 `GenericType` 构造。
- en: 'We then create a `GenericType` subclass and specify `List<Book>` as the `GenericType`
    parameter. What if we want to get a book, maybe an unknown book? If we get an
    unknown book, we expect a status code of 404\. Again, we use `api.path("/books").path("/{isbn}")`;
    which is a `path` parameter. Therefore we resolve the template using a specific
    parameter and value. We use `request`, `accept`, and `get()`. By calling `get()`,
    we only get the actual `response`, and in that `response`, we use `getStatus()`,
    which is `404`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `GenericType` 子类，并将 `List<Book>` 指定为 `GenericType` 参数。如果我们想获取一本书，可能是一本未知的书呢？如果我们获取到一本未知的书，我们期望状态码为
    404。同样，我们使用 `api.path("/books").path("/{isbn}")`；这是一个 `path` 参数。因此，我们使用特定的参数和值来解析模板。我们使用
    `request`、`accept` 和 `get()`。通过调用 `get()`，我们只获取实际的 `response`，在 `response` 中，我们使用
    `getStatus()`，它是 `404`：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we want to create books, we can do that in a similar way. Again, we create
    a new book and in here we use `api.path("/books").requestMediaType.APPLICATION_JSON`,
    which specifies the content type of our payload. We use `post(Entity.json(book))`
    and expect a status code of 201\. If you want to get hold of the just-created
    book, what we can do is obtain the `URI` of the `response`. We get the location
    and then we use the client again for the target URI, we `request()`, we accept
    `MediaType.APPLICATION_JSON`, and we get a POJO of the `Book` class. In such a
    case, we automatically get the unmarshalled book back:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建书籍，我们可以以类似的方式完成。同样，我们创建一个新的书籍，在这里我们使用 `api.path("/books").requestMediaType.APPLICATION_JSON`，这指定了我们的有效负载的内容类型。我们使用
    `post(Entity.json(book))` 并期望状态码为 201。如果您想要获取刚刚创建的书籍，我们可以做的是获取 `response` 的 `URI`。我们获取位置，然后再次使用客户端针对目标
    URI，我们 `request()`，我们接受 `MediaType.APPLICATION_JSON`，并获取 `Book` 类的 POJO。在这种情况下，我们自动获取反序列化的书籍：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the basic workings of the JAX-RS client APIs. Last but not least, you
    should not forget to close the client (`client.close()`) to free up any resources.
    If you want, you can do some cleanup. Maybe we want to delete the book we created
    previously. We need the following code to delete the book:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 JAX-RS 客户端 API 的基本工作原理。最后但同样重要的是，您不应该忘记关闭客户端（`client.close()`）以释放任何资源。如果您愿意，可以进行一些清理。也许我们想要删除之前创建的书籍。我们需要以下代码来删除书籍：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is all there is to it for this section. In the next section, we'll talk
    about testing Java EE 8 web services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节的内容就到这里。在下一节，我们将讨论测试 Java EE 8 网络服务。
- en: Testing Java EE 8 web services
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Java EE 8 网络服务
- en: In this section, we're going to take a look at different test strategies for
    Java EE 8 web services. We'll talk about testing simple CDI components with plain
    unit tests and mocks, testing REST resources using the Jersey Test Framework,
    and we'll see how to do black box integration testing using the Test Containers
    framework.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Java EE 8 网络服务的不同测试策略。我们将讨论使用纯单元测试和模拟测试简单的 CDI 组件，使用 Jersey 测试框架测试
    REST 资源，以及我们将看到如何使用 Test Containers 框架进行黑盒集成测试。
- en: So far, we've implemented our library service by offering a REST API for books,
    authors, and loans. We also implemented the library client. In this section, we'll
    talk about testing. You can see the test pyramid in the following diagram. At
    the bottom, there are unit tests. The middle layer is the service layer tests.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过提供书籍、作者和借阅的 REST API 来实现我们的图书馆服务库。我们还实现了图书馆客户端。在本节中，我们将讨论测试。你可以在下面的图中看到测试金字塔。在底部是单元测试。中间层是服务层测试。
- en: 'At the top level, you have UI layer tests. Unit testing in Java EE is really
    simple; you can use your standard test frameworks such as JUnit testing, and you
    may use Mojito or other mocking frameworks to mock any dependencies:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高层，你有 UI 层测试。Java EE 中的单元测试非常简单；你可以使用你的标准测试框架，如 JUnit 测试，并且你可能使用 Mojito 或其他模拟框架来模拟任何依赖项：
- en: '![](img/e984dea2-c791-46b4-9c52-7906f5de1470.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e984dea2-c791-46b4-9c52-7906f5de1470.png)'
- en: Conceptual view on this section
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的概念视图
- en: 'We won''t focus on unit tests here. What''s really nice in Java EE is how we
    can do service level testing. There are two frameworks:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会关注单元测试。Java EE 中真正令人愉快的是我们可以如何进行服务级别测试。有两个框架：
- en: Jersey Test Framework
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jersey Test Framework
- en: Test Containers framework
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Test Containers 框架
- en: Let's use them both.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同时使用它们。
- en: Jersey Test Framework
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jersey Test Framework
- en: 'Let''s start with the **Jersey Test Framework**. We will switch to our IDE
    and in order to use the Jersey Test Framework, you need to add one simple dependency,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**Jersey Test Framework**开始。我们将切换到我们的 IDE，为了使用 Jersey Test Framework，你需要添加一个简单的依赖项，如下所示：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Jersey offers several test providers; in this case, we will be using the `grizzly2`
    provider. What do you need to do to use this test framework? First of all, you
    need to implement a test class, say `VersionResourceTest`, and you need to make
    it extend the `JerseyTest` superclass. Next thing you need to do is override the
    `configure` method, and what you do here is construct a `ResourceConfig` and pass
    the resource you want to test. In our case, we want to test `VersionResource`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Jersey 提供了几个测试提供者；在这种情况下，我们将使用`grizzly2`提供者。要使用这个测试框架，你需要做什么？首先，你需要实现一个测试类，比如`VersionResourceTest`，并且你需要让它继承`JerseyTest`超类。接下来你需要做的是重写`configure`方法，在这里你做的是构建一个`ResourceConfig`，并传递你想要测试的资源。在我们的例子中，我们想要测试`VersionResource`：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next thing you can do is configure the client that is used to test against
    our resource. The client here is actually the same one we were using in the previous
    section, that is, `JsonBindingFeature`, and once you''ve done that, you can implement
    the actual tests:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你可以做的是配置用于测试我们资源的客户端。这里的客户端实际上是我们在上一节中使用过的同一个，即`JsonBindingFeature`，一旦你完成了这个，你就可以实现实际的测试：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we want to test the `v1` resource, what we can do is specify the target
    version as `v1`. We use `request` and `target`, and on the `response` returned,
    we can then specify our usual assertions. Then, assert that the response status
    code is 200 and that the entity of type string contains the string `"v1.0"`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试`v1`资源，我们可以做的是指定目标版本为`v1`。我们使用`request`和`target`，然后在返回的`response`上，我们可以指定我们通常的断言。然后，断言响应状态码为200，并且字符串类型的实体包含字符串`"v1.0"`：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s run our test. You can see here that the test is actually firing
    up a small `grizzly` server that is deploying our resource, and then it''s actually
    firing HTTP calls against our resource. These are the proper integration tests:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的测试。你可以看到这里，测试实际上启动了一个小的`grizzly`服务器，它部署了我们的资源，然后它实际上对资源发起了 HTTP 请求。这些都是适当的集成测试：
- en: '![](img/d97d2b38-fee3-49b2-810c-8ba37e24e5d1.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d97d2b38-fee3-49b2-810c-8ba37e24e5d1.png)'
- en: Test Containers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Test Containers
- en: 'Let''s look at the next test framework, which is called **Test Containers**.
    We need to add the following two dependencies to activate the Test Containers
    framework:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下一个测试框架，它被称为**Test Containers**。我们需要添加以下两个依赖项来激活 Test Containers 框架：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The idea behind Test Containers is really simple. Since we''re going to deploy
    our web service in a Docker container anyway, why not use a Docker container during
    our test as well? All you need to add is a `@ClassRule`. We create `GenericContainer`,
    we pass it to a `Dockerfile`, we pass it to the WAR file (`library-service.war`)
    we want to package, we can specify a `Wait` strategy, a `LogConsumer`, and we
    expose ports. All this code does is fire up a Docker container when this test
    starts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Test Containers背后的理念非常简单。由于我们无论如何都要在Docker容器中部署我们的Web服务，为什么不在测试期间也使用Docker容器呢？您需要添加的只是一个`@ClassRule`。我们创建`GenericContainer`，将其传递给`Dockerfile`，传递给我们要打包的WAR文件（`library-service.war`），我们可以指定一个`Wait`策略，一个`LogConsumer`，并暴露端口。所有这些代码所做的就是在测试开始时启动一个Docker容器：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `setUp` phase, what we can do is we can set up a JAX-RS client instance
    as we''ve done previously, and once we have the client, we can set up a web target
    against the container URI. We can ask for the container IP address and the map
    port of our service, and once we have the web `target`, we can use the JAX-RS
    client API to interact with our microservice:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp`阶段，我们可以做的是像之前做的那样设置一个JAX-RS客户端实例，一旦我们有了客户端，我们就可以针对容器URI设置一个网络目标。我们可以请求我们的服务容器的IP地址和映射端口，一旦我们有了网络`target`，我们就可以使用JAX-RS客户端API与我们的微服务进行交互：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, run the following command from your console:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从您的控制台运行以下命令：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What this does is basically run unit tests and integration tests. First up,
    the Surefire Plugin tests our version resource, we see everything firing up, it
    runs the other unit tests, packaging the WAR file. The Failsafe Plugin will run
    our container integration tests. It''ll create and start the container; this might
    take quite a long time. You can see that the tests completed successfully in the
    following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的基本上是运行单元测试和集成测试。首先，Surefire插件测试我们的版本资源，我们看到一切都在启动，它运行其他单元测试，打包WAR文件。Failsafe插件将运行我们的容器集成测试。它将创建并启动容器；这可能需要相当长的时间。您可以在下面的屏幕截图中看到测试已成功完成：
- en: '![](img/92f8007a-bdcd-4370-8199-0130dc3e09f0.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92f8007a-bdcd-4370-8199-0130dc3e09f0.png)'
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's summarize what we learned in this chapter. We had a look at basic JAX-RS
    annotations in order to implement a REST API with CRUD functionality. We used
    top resource locators to nicely model nested REST APIs. We used HTTP status codes
    and exception mappers for error handling. We implemented web service clients using
    the JAX-RS service client API. Finally, we had a look at testing Java EE 8-based
    web services using several approaches. I hope you enjoyed this chapter. In the
    next chapter, we will talk about content marshaling with JSON-B and JSON-P.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容。我们查看了一些基本的JAX-RS注解，以便实现具有CRUD功能的REST API。我们使用了顶级资源定位器来优雅地建模嵌套REST
    API。我们使用了HTTP状态码和异常映射来进行错误处理。我们使用了JAX-RS服务客户端API来实现Web服务客户端。最后，我们探讨了使用几种方法测试基于Java
    EE 8的Web服务。我希望你喜欢这一章。在下一章中，我们将讨论使用JSON-B和JSON-P进行内容序列化。
