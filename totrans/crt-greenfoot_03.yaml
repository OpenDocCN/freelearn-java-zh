- en: Chapter 3. Collision Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Live as if you were to die tomorrow. Learn as if you were to live forever."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Mahatma Gandhi* |'
  prefs: []
  type: TYPE_TB
- en: 'Often, you will need to determine whether two or more objects are touching
    in Greenfoot. This is known as *collision detection* and it is necessary for most
    simulations and games. Detection algorithms range from simple bounding-box methods
    to very complex pixel color analysis. Greenfoot provides a wide variety of simple
    methods to accomplish collision detection; you were introduced to some of them
    in [Chapter 1](part0014.xhtml "Chapter 1. Let''s Dive Right in…"), *Let''s Dive
    Right in…*, and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*.
    In this chapter, you will learn how to use Greenfoot''s other built-in collision
    detection mechanisms and then learn more accurate methods to use them to do collision
    detection. While pixel-perfect collision detection is beyond the scope of this
    book, the border-based and hidden-sprite methods of collision detection will be
    sufficient for most Greenfoot applications. The topics that will be covered in
    this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Greenfoot built-in methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border-based methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden-sprite methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a break from working on Avoider Game and use a simple zombie invasion
    simulation to illustrate our collision detection methods. Zombies seem apropos
    for this chapter. Judging from his quote above, I think Gandhi wanted you to learn
    as if you were a zombie.
  prefs: []
  type: TYPE_NORMAL
- en: ZombieInvasion interactive simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's Dive
    Right in…* and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*,
    we went step by step in building Avoider Game and ended up with playable versions
    of the game by the end of each chapter. In the zombie simulation, we will watch
    a horde of zombies break through a wall and make their way to the homes on the
    other side. The user will be able to interact with the simulation by placing explosions
    in the simulation, that will destroy both types of zombies and the wall. For our
    zombie simulation, I am going to supply most of the code in the beginning, and
    we will concentrate our efforts on implementing collision detection. All the code
    supplied uses concepts and techniques we covered in the last two chapters, and
    it should look very familiar. We will just provide an overview discussion of the
    code here. *Figure 1* provides a picture of our scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![ZombieInvasion interactive simulation](img/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Here''s a screenshot of ZombieInvasion'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new scenario called `ZombieInvasion` and then incrementally
    add and discuss the `World` subclass and `Actor` subclasses. Alternatively, you
    can download the initial version of **ZombieInvasion** at: [http://www.packtpub.com/support](http://www.packtpub.com/support)'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically creating actors in ZombieInvasionWorld
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class has two main responsibilities: placing all the actors in the world
    and creating an explosion whenever the mouse is clicked. For the most part, the
    user will just observe the scenario and will only be able to interact with it
    by creating explosions. The `ZombieInvasionWorld` class is rather simple because
    we are creating an interactive simulation and not a game. Here''s the code to
    accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you right-click on the scenario screen and choose **Save the World** in
    the pop-up menu, Greenfoot will automatically create the `prepare()` method for
    you and will supply the appropriate code to add each `Actor` on the screen. This
    creates the initial state of your scenario (the one the user sees when they first
    run your scenario). In `ZombieInvasionWorld`, we are manually implementing the
    `prepare()` method and can do so in a more compact way than Greenfoot. We use
    for-loops to add our actors. Via this method, we add `Wall`, `House`, `Zombie1`,
    and `Zombie2`. We will implement these classes later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `act()` method is responsible for listening for mouse-click events. If the
    mouse is clicked, we add a `Boom` object at the current position of the mouse.
    Boom is an actor we create just to display the explosion, and we want it placed
    exactly where the mouse was clicked. We use a delay variable, `boomDelayCounter`,
    to prevent the user from rapidly creating too many explosions. Remember, we explained
    delay variables in detail in the previous chapter, [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*. If you want the user to have the ability
    to rapidly create explosions, then simply remove the delay variable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating obstacles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create two obstacles for our zombie horde: houses and walls. In the
    simulation, the `House` object has no functionality. It is simply an obstacle
    to zombie actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code for the `House` class is extremely simple. Its sole purpose is just
    to add an image (`buildings/house-8.png`) of a house to `Actor`. It has no other
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Walls are more complex than houses. As the zombies beat on the walls, they
    slowly crumble. The majority of the code for the `Wall` class implements this
    animation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the animation of the `Wall` class crumbling is very similar
    to that of the `Avatar` class taking damage that we looked at, in the previous
    chapter, [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*. The
    interesting code is all contained in the `crumble()` method, which is called repeatedly
    from the `act()` method. *Figure 1* shows the walls in various states of decay.
    We will implement and explain in detail the `crumble()` method in the *Detecting
    a collision with multiple objects* section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our main actor framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Zombie` class contains all the code that describes the behavior for zombies
    in our simulation. Zombies continually lumber forward trying to get to the humans
    in the houses. They beat on and eventually destroy any walls in the way, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The two important methods in this class are `shake()` and `canMarch()`. The
    `shake()` method implements the back-and-forth lumbering movement of the zombies.
    It calls `setLocation()` and leaves the *y* coordinate unchanged. It changes the
    *x* coordinate to have sinusoidal motion (back and forth). The distance it moves
    back and forth is defined by the `amplitude` variable. This type of motion was
    also used by one of the power-downs described in [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation* and is shown in *Figure 2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our main actor framework](img/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: This is an illustration of using a sine wave to produce back and
    forth motion in Zombie objects. We start with a standard sine wave (a), rotate
    it 90 degrees (b), and reduce the amount we move in the y direction until the
    desired effect is achieved (not moving in the y-direction). Callouts (c) and (d)
    show the effects of reducing movement in the y direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will fully implement and explain `canMarch()` in the *Detecting a collision
    with multiple objects* section. The method `canMarch()` checks surrounding actors
    (houses, walls, or other zombies) to see whether any are in the way of the zombie
    moving forward. As a temporary measure, we insert the following line at the end
    of `canMarch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to compile and test the code. By always returning `false`, the
    `Zombie` objects will never move forward. This is a simple placeholder, and we
    will implement the real response later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two subclasses of the `Zombie` class: `Zombie1` and `Zombie2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to have two different-looking zombies but only write code for
    zombie behavior once. I chose to have a blue (`people/ppl1.png`) zombie and a
    yellow-orange (`people/ppl3.png`) zombie. If you have any artistic skill, you
    might want to create your own `PNG` images to use. Otherwise, you can continue
    to use the images provided with Greenfoot, as I have done.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an explosion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `Boom` class we discussed previously in the
    description of the `ZombieInvasionWorld` class. The `Boom` class will immediately
    draw an explosion that will wipe out everything contained in the blast and then
    linger for a short time before disappearing. We create an explosion using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the constructor (`Boom()`) and `act()` methods. The `Boom()` method
    creates an image manually using the drawing methods of `GreenfootImage`. We used
    these drawing methods in this way to draw the stars and eyes in `AvoiderGame`,
    which we presented over the last two chapters, [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, and [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation*. The constructor concludes by setting this new image to be the image
    of the actor using `setImage()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `act()` method has an interesting use of a delay variable. Instead of waiting
    for a certain amount of time (in terms of the number of calls to the `act()` method)
    before allowing an event to occur, the `boomCounter` delay variable is used to
    control how long this `Boom` object lives. After a short delay, the object is
    removed from the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the implementation of the `destroyEverything()` method in a
    later section.
  prefs: []
  type: TYPE_NORMAL
- en: Test it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now have a nearly complete zombie invasion simulation. Let's compile
    our scenario and make sure we eliminate any typos or mistakes introduced while
    adding the code. The scenario will not do much. The zombies will lumber back and
    forth but not make any forward progress. You can click anywhere in the running
    scenario and see the `Boom` explosion; however, it won't destroy anything yet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make this scenario a bit more interesting, using Greenfoot's collision
    detection methods.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in collision detection methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to go through all the methods provided by Greenfoot to do collision
    detection. First, we will go over some methods and discuss their intended use.
    Then, we'll discuss the remaining methods in the context of more advanced collision
    detection methods (border-based and hidden-sprite). We have already used a few
    collision detection methods in the implementation of Avoider Game. We will only
    briefly describe those particular methods here. Finally, we will not discuss `getNeighbors()`
    and `intersects()`, as those methods are only useful for Greenfoot scenarios that
    contain worlds that are created with a cell size greater than one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cell size and Greenfoot worlds**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have only created worlds (`AvoiderWorld` and `ZombieInvasionWorld`)
    that have set the `cellSize` parameter of the `World` constructor to `1`. The
    following is an excerpt from Greenfoot''s documentation on the `World` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The simple tutorials provided on Greenfoot's website mainly use large cell sizes.
    This makes game movement, trajectories, and collision detection very simple. We,
    on the other hand, want to create more flexible games that allow for smooth motion
    and more realistic animation. Therefore, we define our game cells to be 1 x 1
    pixels (one pixel) and, correspondingly, will not discuss methods that target
    worlds with large cell sizes, such as `getNeighbors()` and `intersects()`.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through our discussion, remember that we will, at times, add code to
    our `ZombieInvasion` scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a collision with a single object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method `getOneIntersectingObject()` is great for simple collision detection
    and often used to see whether a bullet, or other type of enemy, hit the main protagonist
    of the game in order to subtract health, subtract life, or end the game. This
    is the method we used and explained in [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, to build our first working version of
    Avoider Game. We will not discuss it again here and only mention it in the next
    section as a means to illustrate the use of `isTouching()` and `removeTouching()`.
  prefs: []
  type: TYPE_NORMAL
- en: isTouching() and removeTouching()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a common pattern for using `getOneIntersectingObject()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We used this basic pattern in Avoider Game several times. The `isTouching()`
    and `removeTouching()` methods provide a more compact way to implement the preceding
    pattern. Here is an equivalent function using `isTouching()` and `removeTouching()`
    instead of `getOneIntersectingObject()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If all you're doing is removing an object that the object intersects with, all
    you need is the `isTouching()` and `removeTouching()` methods. However, if you
    want to do something with the object that you're intersecting with, which requires
    calling methods of the object's class, then you need to store the intersected
    object in a named variable, which requires using the `getOneIntersectingObject()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, always use `getOneIntersectingObject()` instead of `isTouching()`
    and `removeTouching()`. It is more flexible and provides code that is easier to
    extend in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a collision with multiple objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collision detection method `getIntersectingObjects()` returns a list of
    all the actors in a given class that the calling actor is touching. This method
    is needed when you need to take an action on every object that is touching a specific
    actor, or you need to change the state of an actor based on the number of objects
    touching it. When using `getOneIntersectingObject()`, you are only concerned about
    being touched by at least one object of a given type. For example, in the game
    *PacMan*, you lose a life anytime you touch a ghost. It wouldn't matter if you
    ran into one, two, or three; the end result would be the same—you'd lose a life.
    However, in our zombie simulation, the `Wall` actors take damage based on how
    many zombies are presently beating on it. This is a perfect use for `getIntersectingObjects()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Wall` code presented above, we left out the implementation of the `crumble()`
    method. Here is that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's quickly go over the things we saw before. In the *Hurting the avatar*
    section of [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*, we
    changed the image of the avatar to look damaged every time it was touched by an
    enemy. We are using the same animation technique here to make it look like walls
    are taking damage. However, in this code, we have given walls a durability property
    that is defined by the `wallStrength` variable. The value of `wallStrength` determines
    how many times a wall can be hit by a zombie before it visibly looks more crumbled
    and cracked.
  prefs: []
  type: TYPE_NORMAL
- en: The `wallStrength` variable is actually just an example of a delay variable
    that we discussed in the previous chapter, [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation*. Instead of this variable delaying a certain amount of time, it is
    delaying a certain number of zombie hits. When `wallStrength` is less than 0,
    we change the image using the method `changeImage()` unless this is the fourth
    time we have crumbled, which will cause us to remove the wall altogether. *Figure
    3* shows the wall images I created and used for this animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting a collision with multiple objects](img/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: These are the four images used to animate the walls crumbling'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss the collision detection method `getIntersectingObjects()`.
    When called, this method will return all objects of a given class that intersect
    with the calling object. You specify the class of objects you are interested in
    by providing it as the argument to this method. In our code, I provided the argument
    `Zombie.class`, so the method would only return all the zombies that are touching
    the wall. Because of inheritance, we will get all of the `Zombie1` objects and
    all of the `Zombie2` objects that intersect. You can access, manipulate, or iterate
    through the objects returned using the methods defined in the `List` interface.
    For our purposes, we only wanted to count how many zombies we collided with. We
    get this number by calling the `size()` method on the `List` object returned from
    `getIntersectingObjects()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Java interfaces and List**'
  prefs: []
  type: TYPE_NORMAL
- en: The collision detection method `getIntersectingObjects()` introduces us for
    the first time to the `List` interface. In Java, interfaces are used to define
    a certain set of methods that two or more classes will have in common. When Java
    classes implement an interface, that class is promising that it implements all
    of the methods defined in that interface. So, the collection of `Actor` objects
    returned by `getIntersectingObjects()` could be stored in an array, linked list,
    queue, tree, or any other data structure. Whatever the data structure used for
    storing these objects, we know that we can access those objects via the methods
    defined in the `List` interface, such as `get()` or `size()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, refer to the following link: [http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html](http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `ZombieInvasion` simulation, we need to use `getIntersectingObjects()`
    one more time. Earlier, we left the implementation of `canMarch()` incomplete
    when we looked at the code for the `Zombie` class. Let''s implement that method
    now using `getIntersectingObjects()`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This method checks whether or not there are any actors in the way of this object
    moving forward. It accomplishes this by first getting all objects of the `Actor`
    class that are touching it and then checking each one to see if it is in front
    of this object. We do not care if `Actor` is touching the calling object at the
    top, bottom, or back as these actors will not prevent this object from moving
    forward. This line of code in `canMarch()` gives us the list of all intersecting
    actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We then iterate through the list of actors using a `for` loop. To access an
    item in a list, you use the `get()` method. The `get()` method has one formal
    parameter that specifies the index of the object in the list that you want. For
    each actor in the list, we check to see if the *x* coordinate is in front of us.
    If it is, we return `false` (we can't move); otherwise, we return `true` (we can
    move).
  prefs: []
  type: TYPE_NORMAL
- en: We have added the implementation of the `crumble()` method to the `Wall` class
    (don't forget to add `changeImage()` too) and the implementation of `canMarch()`
    to the `Zombie` class. Let's compile our scenario and observe what happens. Our
    simulation is almost complete. The only thing missing is the implementation of
    the `destroyEverything()` method in the `Boom` class. We will look at that implementation
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting multiple objects in range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last method we need to implement to complete our simulation is `destroyEverything()`.
    In this method, we will use the Greenfoot collision detection method `getObjectsInRange()`.
    This method takes two parameters. We have seen the second parameter in all of
    the rest of the collision detection methods, and it specifies the class of actors
    we are testing for collision. The first parameter provides the radius of a circle
    drawn around the actor that defines where to search for collision. *Figure 4*
    shows the relationship between the `radius` parameter and the search area. Unlike
    `getIntersectingObjects()`, `getObjectsInRange()` returns a list of actors that
    are within the range specified by the calling object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting multiple objects in range](img/image00283.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: This shows the purpose of the radius parameter of the getObjectsInRange()
    method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know about the method `getObjectsInRange()`, let''s look at the
    implementation of `destroyEverything()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is short, yet powerful. It calls `getObjectsInRange()` with a radius
    `x`, the value that was passed to `destroyEverything()` when called, and `Actor.class`,
    which in Greenfoot terms means everything. All objects within the circle defined
    by the radius will be returned by `getObjectsInRange()` and stored in the `objs`
    variable. Now, we could iterate through all the objects contained in `objs` and
    remove them one at a time. Luckily, Greenfoot provides a function that can remove
    a list of objects with one call. Here''s its definition in Greenfoot''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Time to test it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simulation is complete. Compile and run it and make sure everything works
    as anticipated. Remember, you can click anywhere to blow up buildings, walls,
    and zombies. Reset the scenario and move things around. Add walls and zombies
    and see what happens. Nice work!
  prefs: []
  type: TYPE_NORMAL
- en: Border-based collision detection methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Border-based collision detection involves incrementally searching outward from
    `Actor` until either a collision is detected, or it is determined there are no
    obstacles in the way. The method finds the edge (or border) of the item collided
    with. This method is especially useful when objects need to bounce off each other
    or one object is landing on another and needs to remain on that object for a certain
    amount of time, for example, when a user-controlled `Actor` is jumping on a platform.
    We will introduce this method of collision detection in this chapter, as well
    as use it in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting single-object collisions at an offset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *at offset* versions of Greenfoot''s collision detection methods are well
    suited to border-based collision detection. They allow us to check for a collision
    at a certain distance, or offset, from the center of the calling `Actor`. To demonstrate
    the use of this method, we will change the implementation of the `canMarch()`
    method in the `Zombie` class. Here is our revised version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, when an actor moves, it will change its position by a certain number
    of pixels. In the `Zombie` class, how far zombies will move, if they can, is stored
    in the `step` variable. We need to declare and initialize this instance variable
    by inserting the following line of code at the top of the `Zombie` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using a `step` variable to store the length of movement for an actor is common
    practice. In the implementation of `canMarch()` above, we check each pixel in
    front of a zombie up to and including taking a full step. This is handled by the
    `while` loop. We increment the variable `i` from `0` to `step`, checking for a
    collision each time at the location `i + front`. Since the origin location of
    an object is its center, we set `front` to be half of the width of the image representing
    this actor. *Figure 5* illustrates this search.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting single-object collisions at an offset](img/image00284.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Using border-based detection, an object searches for a collision
    one pixel at a time. It starts from its front and then searches for an object
    starting at front + 0 all the way to front + step.'
  prefs: []
  type: TYPE_NORMAL
- en: If we detect a collision any time in our while loop, we return `false`, indicating
    the actor cannot move forward; otherwise, we return `true`. Test out this new
    version of `canMarch()`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting multiple-object collisions at an offset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collision detection method `getObjectsAtOffset()` is very similar to `getOneObjectAtOffset()`.
    It just, as the name implies, returns all actors that collide at the given offset.
    To demonstrate its use, we are going to re-implement `canMarch()` as we did for
    `getOneObjectAtOffset()`. To take advantage of getting a list of actors that collide,
    we are going to add some additional functionality to `canMarch()`. For each actor
    blocking the forward movement of the zombie, we are going to shove them a little.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation of `canMarch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we use a `while` loop and `step` variable in much the same
    way we did previously for the `getOneObjectAtOffset()` version of `canMarch()`.
    Inside the `while` loop is where we added the new "shoving" functionality. When
    we detect that there is at least one `Actor` in the list, we iterate through the
    list using a `for` loop to slightly push each actor we collided with. The first
    thing we do in the `for` loop is check whether or not the `Actor` class is a `Zombie`
    class using the `instanceof` operator. If it isn't, we skip over it. We don't
    want the ability to shove `Wall` or `House`. For each zombie we collided with,
    we set the `toss` variable to `1` or `-1` with equal probability We then move
    that zombie with `setLocation()`. The effect is interesting and gives the illusion
    that the zombies are trying to push and shove their way to the front. Compile
    and run the scenario with the changes to `canMarch()` and see for yourself. *Figure
    6* shows how the zombies bunch up with the preceding changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The instanceof Operator**'
  prefs: []
  type: TYPE_NORMAL
- en: Java's `instanceof` operator checks whether the left-hand side argument is an
    object created from the class (or any of its subclasses) specified on the right-hand
    side. It will return `true` if it is and `false` otherwise. It will also return
    `true` if the left-hand side object implements the interface specified on the
    right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting multiple-object collisions at an offset](img/image00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Here''s a view of the zombies pushing and shoving to get to the humans
    in the houses first'
  prefs: []
  type: TYPE_NORMAL
- en: Hidden-sprite collision detection methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One flaw with the `getOneObjectAtOffets()` and `getObjectsAtOffset()` methods
    is that they only check the granularity of a single pixel. If an object of interest
    is one pixel above or below the offset provided to these methods, then no collision
    will be detected. In fact, in this implementation, if you allow the simulation
    to run until the zombies reach the houses, you'll notice that some zombies can
    move past the houses. This is because the pixel-only check fails between houses.
    One way to handle this deficiency is to use hidden-sprite collision detection.
    *Figure 7* illustrates this method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hidden-sprite collision detection methods](img/image00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: This shows the use of a hidden sprite to check for collisions.'
  prefs: []
  type: TYPE_NORMAL
- en: In the hidden-sprite method, you use another `Actor` class to test for collisions.
    *Figure 7* shows a `Zombie` object using a smaller, auxiliary `Actor` class to
    determine if a collision occurred with the flower. While the hidden sprite is
    shown as a translucent red rectangle, in practice, we would set the transparency
    (using `setTransparency()`) to `0`, so that it would not be visible. The hidden-sprite
    method is very flexible because you can create any shape or size for your hidden
    sprite, and it does not have the problem of only looking at a single pixel that
    the two previous collision detection methods had. Next, we will once again change
    the `canMarch()` method in the `Zombie` class, this time using hidden-sprite collision
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do, is create a new `Actor` that will serve as the
    hidden sprite. Because we are going to use this hidden sprite for zombies, let''s
    call it `ZombieHitBox`. Create this subclass of `Actor` now and do not associate
    an image with it. We will draw the image in the constructor. Here is the implementation
    of `ZombieHitBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The constructor for `ZombieHitBox` takes six parameters. The reason it takes
    so many parameters is that we need to provide the `Actor` class to which it is
    attached (the `a` parameter), define the size of the rectangle to draw (the `w`
    and `h` parameters), provide the offset of the rectangle from the provided `Actor`
    (the `dx` and `dy` parameters), and check whether the hidden sprite is visible
    (the `visible` parameter). In the constructor, we use `GreenfootImage()`, `setColor()`,
    `setTransparency()`, `fill()`, and `setImage()` to draw the hidden sprite. We
    went over these methods previously in [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation*.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `act()` method to ensure that this hidden sprite moves along with
    the `Actor` class it is attached to (we will call this the `host` actor). To do
    this, we simply call `setLocation()`, provide the current *x* and *y* position
    of the host actor and shift a little according to the offset values provided in
    the constructor. Before doing this, however, we check whether the `host` has not
    been deleted. If it has, we delete the hit box, as it only has meaning in relation
    to `host`. This handles the case where an explosion destroys `host`, but did not
    quite reach the hit box.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provide one public method that the `host` actor will use to get
    all the actors that are colliding with the hidden sprite. We named this method
    as `getHitBoxIntersections()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to augment the `Zombie` class to use this new hidden sprite.
    We need a handle on this hidden sprite, so we need to add a new property to the
    `Zombie` class. Insert this line of code under the declaration of the `step` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to augment the `addedToWorld()` method to create and connect
    `ZombieHitBox` to `Zombie`. Here is the implementation of that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We create a 10 x 25 rectangle for our hidden sprite and initially make it visible,
    so that we can test it in our scenario. Once you are satisfied with the placement
    and size of your hidden sprite, you should change the `visible` parameter of `ZombieHitBox`
    from `true` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created, initialized, and placed `ZombieHitBox`, we can make
    our changes to `canMarch()` to demonstrate the use of the hidden-sprite method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unlike previous implementations of `canMarch()`, we need to first ask the hidden
    sprite for a list of actors colliding with this zombie. Once we get that list,
    we check that it has a size greater than one. The reason why it needs to be greater
    than one, is that `ZombieHitBox` will include the zombie it is attached to. If
    we are not colliding with any other zombies or actors, we return `true`. If we
    are colliding with a number of actors, then we iterate through them all and make
    some decisions based on the type of `Actor`. If `Actor` is this zombie or an instance
    of `ZombieHitBox`, we skip it and don't take any action. The next check is whether
    or not `Actor` is an instance of the `Zombie` class. If it isn't, then it is some
    other object, such as `House` or `Wall`, and we return `false`, so that we will
    not move forward. If it is an instance of the `Zombie` class, we check whether
    or not it is in front of this zombie. If it is, we shove it a little (just as
    we did in the previous implementation of `canMarch()`) and increment the `infront`
    variable. At the end of iterating through the list of actors, we check the `infront`
    variable. If there were any zombies in front of this zombie, we return `false`
    to prevent it from moving forward. Otherwise, we return `true`. The outermost
    `if` statement simply checks that the hitbox (`zbh`) associated with this object
    has not been previously destroyed by a `Boom` object. If it has, then we need
    to remove this object too.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run this version of the scenario. You should observe that the zombies
    bunch up nicely, push and shove each other, yet they are not able to move past
    the houses. Using the hidden-sprite method of collision detection is a bit more
    complex than the rest, but gives us good accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, we have implemented several forms of collision detection in our zombie
    simulation. Which method of collision detection do you prefer for this simulation?
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, create an `Actor` ball that occasionally rolls in from the
    left and knocks zombies out of the way. If the ball hits `Wall`, have it do 1,000
    damage to it. Which form of collision detection will you use to detect collisions
    between the ball and zombies and between the ball and a wall?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collision detection is a crucial component of any game, simulation, or interactive
    application. Greenfoot provides built-in methods of detecting collisions. In this
    chapter, we carefully explained each of these methods and then demonstrated how
    you could use them to do more advanced collision detection. Specifically, we discussed
    border-based and hidden-sprite techniques. Moving forward, we will use collision
    detection often and will choose a method appropriate for our example. In the next
    chapter, we will look at projectiles and will have ample opportunity to put into
    practice what you have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
