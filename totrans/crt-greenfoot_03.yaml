- en: Chapter 3. Collision Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。碰撞检测
- en: '|   | *"Live as if you were to die tomorrow. Learn as if you were to live forever."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"像明天就要死去一样生活。像永远都要活着一样学习。"|    |'
- en: '|   | --*Mahatma Gandhi* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*圣雄甘地* |'
- en: 'Often, you will need to determine whether two or more objects are touching
    in Greenfoot. This is known as *collision detection* and it is necessary for most
    simulations and games. Detection algorithms range from simple bounding-box methods
    to very complex pixel color analysis. Greenfoot provides a wide variety of simple
    methods to accomplish collision detection; you were introduced to some of them
    in [Chapter 1](part0014.xhtml "Chapter 1. Let''s Dive Right in…"), *Let''s Dive
    Right in…*, and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*.
    In this chapter, you will learn how to use Greenfoot''s other built-in collision
    detection mechanisms and then learn more accurate methods to use them to do collision
    detection. While pixel-perfect collision detection is beyond the scope of this
    book, the border-based and hidden-sprite methods of collision detection will be
    sufficient for most Greenfoot applications. The topics that will be covered in
    this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Greenfoot中，你需要确定两个或多个对象是否接触。这被称为*碰撞检测*，对于大多数模拟和游戏都是必要的。检测算法范围从简单的边界框方法到非常复杂的像素颜色分析。Greenfoot提供了一系列简单的方法来实现碰撞检测；在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")，“让我们直接进入…”，和[第2章](part0017.xhtml "第2章。动画")，“动画”中，你已经接触到了其中的一些。在本章中，你将学习如何使用Greenfoot的其他内置碰撞检测机制，然后学习更精确的方法来使用它们进行碰撞检测。虽然像素完美的碰撞检测超出了本书的范围，但基于边界的和隐藏精灵的碰撞检测方法对于大多数Greenfoot应用来说已经足够了。本章将涵盖以下主题：
- en: Greenfoot built-in methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Greenfoot内置方法
- en: Border-based methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于边界的检测方法
- en: Hidden-sprite methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏精灵方法
- en: We will take a break from working on Avoider Game and use a simple zombie invasion
    simulation to illustrate our collision detection methods. Zombies seem apropos
    for this chapter. Judging from his quote above, I think Gandhi wanted you to learn
    as if you were a zombie.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时放下Avoider Game的开发，使用一个简单的僵尸入侵模拟来展示我们的碰撞检测方法。僵尸似乎很适合这一章。从他的引言中判断，我认为甘地希望你像僵尸一样学习。
- en: ZombieInvasion interactive simulation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZombieInvasion交互式模拟
- en: In [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's Dive
    Right in…* and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*,
    we went step by step in building Avoider Game and ended up with playable versions
    of the game by the end of each chapter. In the zombie simulation, we will watch
    a horde of zombies break through a wall and make their way to the homes on the
    other side. The user will be able to interact with the simulation by placing explosions
    in the simulation, that will destroy both types of zombies and the wall. For our
    zombie simulation, I am going to supply most of the code in the beginning, and
    we will concentrate our efforts on implementing collision detection. All the code
    supplied uses concepts and techniques we covered in the last two chapters, and
    it should look very familiar. We will just provide an overview discussion of the
    code here. *Figure 1* provides a picture of our scenario.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0014.xhtml "第1章。让我们直接进入…")，“让我们直接进入…”和[第2章](part0017.xhtml "第2章。动画")，“动画”中，我们一步一步地构建Avoider
    Game，并在每个章节结束时得到可玩的游戏版本。在僵尸模拟中，我们将看到一群僵尸突破墙壁，向另一边的家园前进。用户可以通过在模拟中放置爆炸来与模拟互动，这将摧毁两种类型的僵尸和墙壁。对于我们的僵尸模拟，我将在一开始就提供大部分代码，我们将集中精力实现碰撞检测。所有提供的代码都使用了我们在前两章中介绍的概念和技术，应该看起来非常熟悉。我们在这里将只提供一个代码的概述讨论。*图1*提供了我们场景的图片。
- en: '![ZombieInvasion interactive simulation](img/image00280.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![ZombieInvasion交互式模拟](img/image00280.jpeg)'
- en: 'Figure 1: Here''s a screenshot of ZombieInvasion'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是ZombieInvasion的屏幕截图
- en: 'Let''s create a new scenario called `ZombieInvasion` and then incrementally
    add and discuss the `World` subclass and `Actor` subclasses. Alternatively, you
    can download the initial version of **ZombieInvasion** at: [http://www.packtpub.com/support](http://www.packtpub.com/support)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的场景，称为`ZombieInvasion`，然后逐步添加并讨论`World`子类和`Actor`子类。或者，你也可以在[http://www.packtpub.com/support](http://www.packtpub.com/support)下载**ZombieInvasion**的初始版本。
- en: Dynamically creating actors in ZombieInvasionWorld
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ZombieInvasionWorld中动态创建演员
- en: 'This class has two main responsibilities: placing all the actors in the world
    and creating an explosion whenever the mouse is clicked. For the most part, the
    user will just observe the scenario and will only be able to interact with it
    by creating explosions. The `ZombieInvasionWorld` class is rather simple because
    we are creating an interactive simulation and not a game. Here''s the code to
    accomplish this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个主要职责：将世界中的所有演员放置好，并在鼠标点击时创建爆炸。大部分情况下，用户只能观察场景，并且只能通过创建爆炸与之互动。`ZombieInvasionWorld`
    类相当简单，因为我们正在创建一个交互式模拟而不是游戏。以下是完成此任务的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you right-click on the scenario screen and choose **Save the World** in
    the pop-up menu, Greenfoot will automatically create the `prepare()` method for
    you and will supply the appropriate code to add each `Actor` on the screen. This
    creates the initial state of your scenario (the one the user sees when they first
    run your scenario). In `ZombieInvasionWorld`, we are manually implementing the
    `prepare()` method and can do so in a more compact way than Greenfoot. We use
    for-loops to add our actors. Via this method, we add `Wall`, `House`, `Zombie1`,
    and `Zombie2`. We will implement these classes later in the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景屏幕上右键单击并从弹出菜单中选择 **保存世界** 时，Greenfoot 将自动为你创建 `prepare()` 方法，并供应适当的代码以添加屏幕上的每个
    `Actor`。这创建了你的场景的初始状态（用户首次运行你的场景时看到的那个）。在 `ZombieInvasionWorld` 中，我们手动实现 `prepare()`
    方法，并且可以比 Greenfoot 以更紧凑的方式实现。我们使用循环来添加我们的演员。通过这种方法，我们添加了 `Wall`、`House`、`Zombie1`
    和 `Zombie2`。我们将在本章后面实现这些类。
- en: The `act()` method is responsible for listening for mouse-click events. If the
    mouse is clicked, we add a `Boom` object at the current position of the mouse.
    Boom is an actor we create just to display the explosion, and we want it placed
    exactly where the mouse was clicked. We use a delay variable, `boomDelayCounter`,
    to prevent the user from rapidly creating too many explosions. Remember, we explained
    delay variables in detail in the previous chapter, [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*. If you want the user to have the ability
    to rapidly create explosions, then simply remove the delay variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`act()` 方法负责监听鼠标点击事件。如果鼠标被点击，我们将在鼠标的当前位置添加一个 `Boom` 对象。Boom 是我们创建的用于显示爆炸的演员，我们希望它正好放置在鼠标点击的位置。我们使用延迟变量
    `boomDelayCounter` 来防止用户快速创建过多的爆炸。记住，我们在上一章（[第2章](part0017.xhtml "第2章。动画")，*动画*）中详细解释了延迟变量。如果你想让用户能够快速创建爆炸，那么只需简单地移除延迟变量。'
- en: Creating obstacles
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建障碍物
- en: 'We will create two obstacles for our zombie horde: houses and walls. In the
    simulation, the `House` object has no functionality. It is simply an obstacle
    to zombie actors:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的僵尸群创建两个障碍：房屋和墙壁。在模拟中，`House` 对象没有任何功能。它只是为僵尸演员提供一个障碍：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for the `House` class is extremely simple. Its sole purpose is just
    to add an image (`buildings/house-8.png`) of a house to `Actor`. It has no other
    functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`House` 类的代码非常简单。它的唯一目的是将房屋图像（`buildings/house-8.png`）添加到 `Actor` 中。它没有其他功能。'
- en: 'Walls are more complex than houses. As the zombies beat on the walls, they
    slowly crumble. The majority of the code for the `Wall` class implements this
    animation, as shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 墙壁比房屋更复杂。随着僵尸敲打墙壁，墙壁会慢慢破碎。`Wall` 类的大多数代码都实现了这种动画，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The implementation of the animation of the `Wall` class crumbling is very similar
    to that of the `Avatar` class taking damage that we looked at, in the previous
    chapter, [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*. The
    interesting code is all contained in the `crumble()` method, which is called repeatedly
    from the `act()` method. *Figure 1* shows the walls in various states of decay.
    We will implement and explain in detail the `crumble()` method in the *Detecting
    a collision with multiple objects* section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wall` 类的破碎动画实现与我们在上一章（[第2章](part0017.xhtml "第2章。动画")，*动画*）中看到的 `Avatar` 类受到伤害的实现非常相似。有趣的代码都包含在
    `crumble()` 方法中，该方法从 `act()` 方法中反复调用。*图1* 展示了墙壁在不同程度的衰变状态。我们将在 *检测与多个对象的碰撞* 部分详细实现并解释
    `crumble()` 方法。'
- en: Creating our main actor framework
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的主要演员框架
- en: 'The `Zombie` class contains all the code that describes the behavior for zombies
    in our simulation. Zombies continually lumber forward trying to get to the humans
    in the houses. They beat on and eventually destroy any walls in the way, as shown
    in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zombie`类包含了描述我们模拟中僵尸行为的所有代码。僵尸不断地笨拙地向前移动，试图到达房子里的人类。他们会敲打并最终摧毁任何挡道的墙壁，如下面的代码所示：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The two important methods in this class are `shake()` and `canMarch()`. The
    `shake()` method implements the back-and-forth lumbering movement of the zombies.
    It calls `setLocation()` and leaves the *y* coordinate unchanged. It changes the
    *x* coordinate to have sinusoidal motion (back and forth). The distance it moves
    back and forth is defined by the `amplitude` variable. This type of motion was
    also used by one of the power-downs described in [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation* and is shown in *Figure 2*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的两个重要方法是`shake()`和`canMarch()`。`shake()`方法实现了僵尸的来回笨拙移动。它调用`setLocation()`并保持`y`坐标不变。它将`x`坐标改为正弦运动（来回）。它来回移动的距离由`amplitude`变量定义。这种运动也被用于[第2章](part0017.xhtml
    "第2章。动画")中描述的一种电源关闭，*动画*，并在*图2*中显示。
- en: '![Creating our main actor framework](img/image00281.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的主要演员框架](img/image00281.jpeg)'
- en: 'Figure 2: This is an illustration of using a sine wave to produce back and
    forth motion in Zombie objects. We start with a standard sine wave (a), rotate
    it 90 degrees (b), and reduce the amount we move in the y direction until the
    desired effect is achieved (not moving in the y-direction). Callouts (c) and (d)
    show the effects of reducing movement in the y direction.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这是使用正弦波在僵尸对象中产生来回运动的插图。我们从一个标准的正弦波（a）开始，将其旋转90度（b），并减少在y方向上的移动量，直到达到期望的效果（在y方向上不移动）。呼叫（c）和（d）显示了减少y方向移动的效果。
- en: 'We will fully implement and explain `canMarch()` in the *Detecting a collision
    with multiple objects* section. The method `canMarch()` checks surrounding actors
    (houses, walls, or other zombies) to see whether any are in the way of the zombie
    moving forward. As a temporary measure, we insert the following line at the end
    of `canMarch()`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*检测与多个对象的碰撞*部分中完全实现并解释`canMarch()`。`canMarch()`方法检查周围的演员（房子、墙壁或其他僵尸），以查看是否有任何阻碍僵尸向前移动。作为一个临时措施，我们在`canMarch()`的末尾插入以下行：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This allows us to compile and test the code. By always returning `false`, the
    `Zombie` objects will never move forward. This is a simple placeholder, and we
    will implement the real response later in the chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们编译和测试代码。通过始终返回`false`，`Zombie`对象将永远不会向前移动。这是一个简单的占位符，我们将在本章后面实现真正的响应。
- en: 'We have two subclasses of the `Zombie` class: `Zombie1` and `Zombie2`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个`Zombie`类的子类：`Zombie1`和`Zombie2`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This allows us to have two different-looking zombies but only write code for
    zombie behavior once. I chose to have a blue (`people/ppl1.png`) zombie and a
    yellow-orange (`people/ppl3.png`) zombie. If you have any artistic skill, you
    might want to create your own `PNG` images to use. Otherwise, you can continue
    to use the images provided with Greenfoot, as I have done.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们能够拥有两种不同外观的僵尸，但只需编写一次僵尸行为的代码。我选择了一个蓝色（`people/ppl1.png`）僵尸和一个黄色橙色（`people/ppl3.png`）僵尸。如果你有任何艺术技巧，你可能想创建自己的`PNG`图像来使用。否则，你可以继续使用Greenfoot提供的图像，就像我这样做。
- en: Creating an explosion
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建爆炸
- en: 'Here is the implementation of the `Boom` class we discussed previously in the
    description of the `ZombieInvasionWorld` class. The `Boom` class will immediately
    draw an explosion that will wipe out everything contained in the blast and then
    linger for a short time before disappearing. We create an explosion using the
    following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在`ZombieInvasionWorld`类描述中之前讨论过的`Boom`类的实现。`Boom`类将立即绘制一个爆炸，这将清除爆炸范围内的所有内容，然后短暂停留，之后消失。我们使用以下代码创建爆炸：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's discuss the constructor (`Boom()`) and `act()` methods. The `Boom()` method
    creates an image manually using the drawing methods of `GreenfootImage`. We used
    these drawing methods in this way to draw the stars and eyes in `AvoiderGame`,
    which we presented over the last two chapters, [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, and [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation*. The constructor concludes by setting this new image to be the image
    of the actor using `setImage()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论构造函数（`Boom()`）和`act()`方法。`Boom()`方法使用`GreenfootImage`的绘图方法手动创建一个图像。我们就是这样使用这些绘图方法在上一章中展示的`AvoiderGame`中绘制星星和眼睛，我们在上一章中介绍了它，[第1章](part0014.xhtml
    "第1章。让我们直接进入…"), *让我们直接进入…*，和[第2章](part0017.xhtml "第2章。动画"), *动画*。构造函数通过使用`setImage()`将这个新图像设置为演员的图像来结束。
- en: The `act()` method has an interesting use of a delay variable. Instead of waiting
    for a certain amount of time (in terms of the number of calls to the `act()` method)
    before allowing an event to occur, the `boomCounter` delay variable is used to
    control how long this `Boom` object lives. After a short delay, the object is
    removed from the scenario.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`act()`方法使用了延迟变量的有趣用法。不是等待一定的时间（以`act()`方法的调用次数来衡量）后才允许事件发生，而是使用`boomCounter`延迟变量来控制这个`Boom`对象存活的时间。经过短暂的延迟后，对象将从场景中移除。'
- en: We will discuss the implementation of the `destroyEverything()` method in a
    later section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的部分讨论`destroyEverything()`方法的实现。
- en: Test it out
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一下
- en: You should now have a nearly complete zombie invasion simulation. Let's compile
    our scenario and make sure we eliminate any typos or mistakes introduced while
    adding the code. The scenario will not do much. The zombies will lumber back and
    forth but not make any forward progress. You can click anywhere in the running
    scenario and see the `Boom` explosion; however, it won't destroy anything yet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有一个几乎完整的僵尸入侵模拟。让我们编译我们的场景，确保在添加代码时消除任何引入的错别字或错误。这个场景不会做很多事情。僵尸会来回移动，但不会取得任何进展。你可以在运行中的场景的任何地方点击，看到`Boom`爆炸；然而，它现在还不会摧毁任何东西。
- en: Let's make this scenario a bit more interesting, using Greenfoot's collision
    detection methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Greenfoot的碰撞检测方法使这个场景更有趣。
- en: Built-in collision detection methods
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置的碰撞检测方法
- en: We are going to go through all the methods provided by Greenfoot to do collision
    detection. First, we will go over some methods and discuss their intended use.
    Then, we'll discuss the remaining methods in the context of more advanced collision
    detection methods (border-based and hidden-sprite). We have already used a few
    collision detection methods in the implementation of Avoider Game. We will only
    briefly describe those particular methods here. Finally, we will not discuss `getNeighbors()`
    and `intersects()`, as those methods are only useful for Greenfoot scenarios that
    contain worlds that are created with a cell size greater than one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历Greenfoot提供的所有碰撞检测方法。首先，我们将回顾一些方法并讨论它们的预期用途。然后，我们将基于更高级的碰撞检测方法（基于边界的和隐藏精灵）讨论剩余的方法。我们已经在Avoider
    Game的实现中使用了几个碰撞检测方法。我们在这里将简要描述这些特定方法。最后，我们不会讨论`getNeighbors()`和`intersects()`，因为这些方法仅适用于包含使用大于一个单元格大小创建的世界Greenfoot场景。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Cell size and Greenfoot worlds**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元格大小和Greenfoot世界**'
- en: 'Until now, we have only created worlds (`AvoiderWorld` and `ZombieInvasionWorld`)
    that have set the `cellSize` parameter of the `World` constructor to `1`. The
    following is an excerpt from Greenfoot''s documentation on the `World` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了设置了`World`构造函数的`cellSize`参数为`1`的世界（`AvoiderWorld`和`ZombieInvasionWorld`）。以下是从Greenfoot关于`World`类的文档中摘录的内容：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The simple tutorials provided on Greenfoot's website mainly use large cell sizes.
    This makes game movement, trajectories, and collision detection very simple. We,
    on the other hand, want to create more flexible games that allow for smooth motion
    and more realistic animation. Therefore, we define our game cells to be 1 x 1
    pixels (one pixel) and, correspondingly, will not discuss methods that target
    worlds with large cell sizes, such as `getNeighbors()` and `intersects()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot网站上提供的简单教程主要使用大单元格大小。这使得游戏移动、轨迹和碰撞检测非常简单。另一方面，我们希望创建更灵活的游戏，允许平滑的运动和更逼真的动画。因此，我们将我们的游戏单元格定义为1
    x 1像素（一个像素），相应地，我们将不会讨论针对具有大单元格大小的世界的方法，例如`getNeighbors()`和`intersects()`。
- en: As we go through our discussion, remember that we will, at times, add code to
    our `ZombieInvasion` scenario.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的过程中，请记住，我们有时会向我们的 `ZombieInvasion` 场景添加代码。
- en: Detecting a collision with a single object
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测单个对象的碰撞
- en: The method `getOneIntersectingObject()` is great for simple collision detection
    and often used to see whether a bullet, or other type of enemy, hit the main protagonist
    of the game in order to subtract health, subtract life, or end the game. This
    is the method we used and explained in [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, to build our first working version of
    Avoider Game. We will not discuss it again here and only mention it in the next
    section as a means to illustrate the use of `isTouching()` and `removeTouching()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOneIntersectingObject()` 方法非常适合简单的碰撞检测，通常用于检查子弹或其他类型的敌人是否击中了游戏的主要主角，以便减去健康值、减去生命值或结束游戏。这是我们使用并在
    [第1章](part0014.xhtml "Chapter 1. Let''s Dive Right in…") 中解释的方法，即 *Let''s Dive
    Right in…*，来构建 Avoider Game 的第一个工作版本。我们在此处不再讨论它，只会在下一节中提及它，作为说明 `isTouching()`
    和 `removeTouching()` 的使用方法。'
- en: isTouching() and removeTouching()
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isTouching() 和 removeTouching()
- en: 'The following is a common pattern for using `getOneIntersectingObject()`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `getOneIntersectingObject()` 的常见模式：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We used this basic pattern in Avoider Game several times. The `isTouching()`
    and `removeTouching()` methods provide a more compact way to implement the preceding
    pattern. Here is an equivalent function using `isTouching()` and `removeTouching()`
    instead of `getOneIntersectingObject()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Avoider Game 中多次使用了这个基本模式。`isTouching()` 和 `removeTouching()` 方法提供了一种更紧凑的方式来实现前面的模式。以下是一个使用
    `isTouching()` 和 `removeTouching()` 而不是 `getOneIntersectingObject()` 的等效函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If all you're doing is removing an object that the object intersects with, all
    you need is the `isTouching()` and `removeTouching()` methods. However, if you
    want to do something with the object that you're intersecting with, which requires
    calling methods of the object's class, then you need to store the intersected
    object in a named variable, which requires using the `getOneIntersectingObject()`
    method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是要移除与对象相交的对象，那么你只需要 `isTouching()` 和 `removeTouching()` 方法。然而，如果你想要对相交的对象执行某些操作，这需要调用对象的类方法，那么你需要将相交的对象存储在命名变量中，这需要使用
    `getOneIntersectingObject()` 方法。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In general, always use `getOneIntersectingObject()` instead of `isTouching()`
    and `removeTouching()`. It is more flexible and provides code that is easier to
    extend in the future.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，始终使用 `getOneIntersectingObject()` 而不是 `isTouching()` 和 `removeTouching()`。它更灵活，并且提供的代码更容易在未来扩展。
- en: Detecting a collision with multiple objects
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测多个对象的碰撞
- en: The collision detection method `getIntersectingObjects()` returns a list of
    all the actors in a given class that the calling actor is touching. This method
    is needed when you need to take an action on every object that is touching a specific
    actor, or you need to change the state of an actor based on the number of objects
    touching it. When using `getOneIntersectingObject()`, you are only concerned about
    being touched by at least one object of a given type. For example, in the game
    *PacMan*, you lose a life anytime you touch a ghost. It wouldn't matter if you
    ran into one, two, or three; the end result would be the same—you'd lose a life.
    However, in our zombie simulation, the `Wall` actors take damage based on how
    many zombies are presently beating on it. This is a perfect use for `getIntersectingObjects()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测方法 `getIntersectingObjects()` 返回一个列表，包含所有被调用演员接触到的给定类别的演员。当需要针对接触特定演员的每个对象采取行动，或者需要根据接触该演员的对象数量来改变演员的状态时，需要使用此方法。当使用
    `getOneIntersectingObject()` 时，你只关心至少被一个指定类型的对象接触。例如，在游戏 *PacMan* 中，每次你接触到幽灵时都会失去一条生命。无论你撞到的是一个、两个还是三个，最终结果都会相同——你会失去一条生命。然而，在我们的僵尸模拟中，`Wall`
    演员根据当前敲打它的僵尸数量受到伤害。这是 `getIntersectingObjects()` 的完美应用。
- en: 'In the `Wall` code presented above, we left out the implementation of the `crumble()`
    method. Here is that code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面提供的 `Wall` 代码中，我们省略了 `crumble()` 方法的实现。以下是该代码：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's quickly go over the things we saw before. In the *Hurting the avatar*
    section of [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*, we
    changed the image of the avatar to look damaged every time it was touched by an
    enemy. We are using the same animation technique here to make it look like walls
    are taking damage. However, in this code, we have given walls a durability property
    that is defined by the `wallStrength` variable. The value of `wallStrength` determines
    how many times a wall can be hit by a zombie before it visibly looks more crumbled
    and cracked.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下之前看到的内容。在第二章 [动画](part0017.xhtml "第二章. 动画") 的 *伤害角色* 部分，我们每次角色被敌人触摸时都会改变角色的图像，使其看起来受损。我们在这里使用相同的动画技术来使其看起来像墙壁正在受损。然而，在这段代码中，我们给墙壁赋予了一个由
    `wallStrength` 变量定义的耐久性属性。`wallStrength` 的值决定了墙壁在明显看起来更加破碎和裂缝之前可以承受多少次僵尸的撞击。
- en: The `wallStrength` variable is actually just an example of a delay variable
    that we discussed in the previous chapter, [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation*. Instead of this variable delaying a certain amount of time, it is
    delaying a certain number of zombie hits. When `wallStrength` is less than 0,
    we change the image using the method `changeImage()` unless this is the fourth
    time we have crumbled, which will cause us to remove the wall altogether. *Figure
    3* shows the wall images I created and used for this animation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`wallStrength` 变量实际上是我们在上一章 [第二章. 动画](part0017.xhtml "第二章. 动画") 中讨论的延迟变量的一个例子。这个变量不是延迟一定的时间，而是延迟一定数量的僵尸撞击。当
    `wallStrength` 小于 0 时，我们会使用 `changeImage()` 方法更改图像，除非这是我们第四次破碎，这将导致我们完全移除墙壁。*图
    3* 展示了我为这个动画创建并使用的墙壁图像。'
- en: '![Detecting a collision with multiple objects](img/image00282.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![检测与多个对象的碰撞](img/image00282.jpeg)'
- en: 'Figure 3: These are the four images used to animate the walls crumbling'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：这些是用于动画墙壁破碎的四个图像
- en: Now, let's discuss the collision detection method `getIntersectingObjects()`.
    When called, this method will return all objects of a given class that intersect
    with the calling object. You specify the class of objects you are interested in
    by providing it as the argument to this method. In our code, I provided the argument
    `Zombie.class`, so the method would only return all the zombies that are touching
    the wall. Because of inheritance, we will get all of the `Zombie1` objects and
    all of the `Zombie2` objects that intersect. You can access, manipulate, or iterate
    through the objects returned using the methods defined in the `List` interface.
    For our purposes, we only wanted to count how many zombies we collided with. We
    get this number by calling the `size()` method on the `List` object returned from
    `getIntersectingObjects()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论碰撞检测方法 `getIntersectingObjects()`。当被调用时，此方法将返回所有与调用对象相交的给定类的对象。您可以通过将类作为此方法的参数提供来指定您感兴趣的类。在我们的代码中，我提供了参数
    `Zombie.class`，因此该方法只会返回所有接触墙壁的僵尸。由于继承，我们将得到所有 `Zombie1` 对象和所有 `Zombie2` 对象，它们都与对象相交。您可以使用在
    `List` 接口中定义的方法访问、操作或遍历返回的对象。对于我们来说，我们只想计算我们碰撞了多少个僵尸。我们通过在从 `getIntersectingObjects()`
    返回的 `List` 对象上调用 `size()` 方法来获取这个数字。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Java interfaces and List**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 接口和 List**'
- en: The collision detection method `getIntersectingObjects()` introduces us for
    the first time to the `List` interface. In Java, interfaces are used to define
    a certain set of methods that two or more classes will have in common. When Java
    classes implement an interface, that class is promising that it implements all
    of the methods defined in that interface. So, the collection of `Actor` objects
    returned by `getIntersectingObjects()` could be stored in an array, linked list,
    queue, tree, or any other data structure. Whatever the data structure used for
    storing these objects, we know that we can access those objects via the methods
    defined in the `List` interface, such as `get()` or `size()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测方法 `getIntersectingObjects()` 第一次让我们了解了 `List` 接口。在 Java 中，接口用于定义两个或多个类将共有的方法集。当
    Java 类实现接口时，该类承诺它实现了该接口中定义的所有方法。因此，由 `getIntersectingObjects()` 返回的 `Actor` 对象集合可以存储在数组、链表、队列、树或其他任何数据结构中。无论用于存储这些对象的数据结构是什么，我们知道我们可以通过
    `List` 接口中定义的方法访问这些对象，例如 `get()` 或 `size()`。
- en: 'For more information, refer to the following link: [http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html](http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅以下链接：[http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html](http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)。
- en: 'In our `ZombieInvasion` simulation, we need to use `getIntersectingObjects()`
    one more time. Earlier, we left the implementation of `canMarch()` incomplete
    when we looked at the code for the `Zombie` class. Let''s implement that method
    now using `getIntersectingObjects()`. Here is the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ZombieInvasion`模拟中，我们需要再次使用`getIntersectingObjects()`。在我们查看`Zombie`类的代码时，我们留下了`canMarch()`方法的实现未完成。现在让我们使用`getIntersectingObjects()`来实现该方法。以下是代码：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method checks whether or not there are any actors in the way of this object
    moving forward. It accomplishes this by first getting all objects of the `Actor`
    class that are touching it and then checking each one to see if it is in front
    of this object. We do not care if `Actor` is touching the calling object at the
    top, bottom, or back as these actors will not prevent this object from moving
    forward. This line of code in `canMarch()` gives us the list of all intersecting
    actors:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查是否有任何演员阻碍了该对象向前移动。它通过首先获取所有接触该对象的`Actor`类的对象，然后检查每个对象是否位于该对象的前面来完成此操作。我们不关心`Actor`是否在顶部、底部或后面接触调用对象，因为这些演员不会阻止该对象向前移动。`canMarch()`中的这一行代码为我们提供了所有相交演员的列表：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We then iterate through the list of actors using a `for` loop. To access an
    item in a list, you use the `get()` method. The `get()` method has one formal
    parameter that specifies the index of the object in the list that you want. For
    each actor in the list, we check to see if the *x* coordinate is in front of us.
    If it is, we return `false` (we can't move); otherwise, we return `true` (we can
    move).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`for`循环遍历演员列表。要访问列表中的项目，您使用`get()`方法。`get()`方法有一个形式参数，指定了列表中您想要的对象的索引。对于列表中的每个演员，我们检查其*x*坐标是否在我们前面。如果是，我们返回`false`（我们不能移动）；否则，我们返回`true`（我们可以移动）。
- en: We have added the implementation of the `crumble()` method to the `Wall` class
    (don't forget to add `changeImage()` too) and the implementation of `canMarch()`
    to the `Zombie` class. Let's compile our scenario and observe what happens. Our
    simulation is almost complete. The only thing missing is the implementation of
    the `destroyEverything()` method in the `Boom` class. We will look at that implementation
    next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`crumble()`方法的实现添加到了`Wall`类中（别忘了还要添加`changeImage()`），并将`canMarch()`方法的实现添加到了`Zombie`类中。让我们编译我们的场景并观察发生了什么。我们的模拟几乎完成了。唯一缺少的是`Boom`类中`destroyEverything()`方法的实现。我们将在下一节中查看该实现。
- en: Detecting multiple objects in range
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测范围内的多个对象
- en: The last method we need to implement to complete our simulation is `destroyEverything()`.
    In this method, we will use the Greenfoot collision detection method `getObjectsInRange()`.
    This method takes two parameters. We have seen the second parameter in all of
    the rest of the collision detection methods, and it specifies the class of actors
    we are testing for collision. The first parameter provides the radius of a circle
    drawn around the actor that defines where to search for collision. *Figure 4*
    shows the relationship between the `radius` parameter and the search area. Unlike
    `getIntersectingObjects()`, `getObjectsInRange()` returns a list of actors that
    are within the range specified by the calling object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个方法来完成我们的模拟是`destroyEverything()`。在这个方法中，我们将使用Greenfoot碰撞检测方法`getObjectsInRange()`。此方法接受两个参数。我们在所有其他碰撞检测方法中都已经看到了第二个参数，它指定了我们正在测试碰撞的演员的类。第一个参数提供了一个围绕演员绘制的圆的半径，该半径定义了搜索碰撞的位置。*图4*显示了`radius`参数与搜索区域之间的关系。与`getIntersectingObjects()`不同，`getObjectsInRange()`返回一个列表，其中包含调用对象指定的范围内的演员。
- en: '![Detecting multiple objects in range](img/image00283.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![检测范围内的多个对象](img/image00283.jpeg)'
- en: 'Figure 4: This shows the purpose of the radius parameter of the getObjectsInRange()
    method'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：这显示了`getObjectsInRange()`方法中半径参数的作用
- en: 'Now that we know about the method `getObjectsInRange()`, let''s look at the
    implementation of `destroyEverything()`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`getObjectsInRange()`方法，让我们看看`destroyEverything()`方法的实现：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method is short, yet powerful. It calls `getObjectsInRange()` with a radius
    `x`, the value that was passed to `destroyEverything()` when called, and `Actor.class`,
    which in Greenfoot terms means everything. All objects within the circle defined
    by the radius will be returned by `getObjectsInRange()` and stored in the `objs`
    variable. Now, we could iterate through all the objects contained in `objs` and
    remove them one at a time. Luckily, Greenfoot provides a function that can remove
    a list of objects with one call. Here''s its definition in Greenfoot''s documentation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简短而强大。它调用`getObjectsInRange()`，带有半径`x`，这是在调用`destroyEverything()`时传递给它的值，以及`Actor.class`，在Greenfoot术语中意味着一切。所有在半径定义的圆内的对象都将由`getObjectsInRange()`返回并存储在`objs`变量中。现在，我们可以遍历`objs`中包含的所有对象，并逐个删除它们。幸运的是，Greenfoot提供了一个可以在一次调用中删除一组对象的函数。以下是它在Greenfoot文档中的定义：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Time to test it out
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是时候测试一下了
- en: The simulation is complete. Compile and run it and make sure everything works
    as anticipated. Remember, you can click anywhere to blow up buildings, walls,
    and zombies. Reset the scenario and move things around. Add walls and zombies
    and see what happens. Nice work!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟完成。编译并运行它，确保一切按预期工作。记住，你可以点击任何地方来炸毁建筑、墙壁和僵尸。重置场景并移动事物。添加墙壁和僵尸，看看会发生什么。做得不错！
- en: Border-based collision detection methods
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于边界的碰撞检测方法
- en: Border-based collision detection involves incrementally searching outward from
    `Actor` until either a collision is detected, or it is determined there are no
    obstacles in the way. The method finds the edge (or border) of the item collided
    with. This method is especially useful when objects need to bounce off each other
    or one object is landing on another and needs to remain on that object for a certain
    amount of time, for example, when a user-controlled `Actor` is jumping on a platform.
    We will introduce this method of collision detection in this chapter, as well
    as use it in upcoming chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于边界的碰撞检测涉及从`Actor`开始向外逐步搜索，直到检测到碰撞，或者确定没有障碍物为止。该方法找到与之碰撞的项目的边缘（或边界）。这种方法在物体需要相互弹跳，或者一个物体落在另一个物体上并需要在该物体上停留一段时间时特别有用，例如，当用户控制的`Actor`跳到平台上时。我们将在本章介绍这种碰撞检测方法，并在接下来的章节中使用它。
- en: Detecting single-object collisions at an offset
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测偏移量下的单物体碰撞
- en: 'The *at offset* versions of Greenfoot''s collision detection methods are well
    suited to border-based collision detection. They allow us to check for a collision
    at a certain distance, or offset, from the center of the calling `Actor`. To demonstrate
    the use of this method, we will change the implementation of the `canMarch()`
    method in the `Zombie` class. Here is our revised version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot的碰撞检测方法的*偏移量*版本非常适合基于边界的碰撞检测。它们允许我们在调用`Actor`的中心的某个距离或偏移量处检查碰撞。为了演示这个方法的使用，我们将修改`Zombie`类中`canMarch()`方法的实现。以下是我们的修改版本：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Typically, when an actor moves, it will change its position by a certain number
    of pixels. In the `Zombie` class, how far zombies will move, if they can, is stored
    in the `step` variable. We need to declare and initialize this instance variable
    by inserting the following line of code at the top of the `Zombie` class, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个演员移动时，它将通过一定数量的像素改变其位置。在`Zombie`类中，如果僵尸可以移动，它们将移动多远被存储在`step`变量中。我们需要通过在`Zombie`类的顶部插入以下代码行来声明和初始化这个实例变量，如下所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using a `step` variable to store the length of movement for an actor is common
    practice. In the implementation of `canMarch()` above, we check each pixel in
    front of a zombie up to and including taking a full step. This is handled by the
    `while` loop. We increment the variable `i` from `0` to `step`, checking for a
    collision each time at the location `i + front`. Since the origin location of
    an object is its center, we set `front` to be half of the width of the image representing
    this actor. *Figure 5* illustrates this search.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`step`变量来存储演员的移动长度是一种常见的做法。在上面的`canMarch()`实现中，我们检查僵尸前方直到包括完整一步的每个像素。这由`while`循环处理。我们将变量`i`从`0`增加到`step`，每次在位置`i
    + front`处检查碰撞。由于一个物体的原始位置是其中心，我们将`front`设置为表示该演员的图像宽度的一半。*图5*说明了这个搜索过程。
- en: '![Detecting single-object collisions at an offset](img/image00284.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![检测偏移量下的单物体碰撞](img/image00284.jpeg)'
- en: 'Figure 5: Using border-based detection, an object searches for a collision
    one pixel at a time. It starts from its front and then searches for an object
    starting at front + 0 all the way to front + step.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：使用基于边界的检测，一个对象逐像素搜索碰撞。它从其前端开始，然后从前端+0开始搜索对象，一直到前端+步长。
- en: If we detect a collision any time in our while loop, we return `false`, indicating
    the actor cannot move forward; otherwise, we return `true`. Test out this new
    version of `canMarch()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的`while`循环中的任何时间检测到碰撞，我们返回`false`，表示演员不能向前移动；否则，我们返回`true`。测试这个新的`canMarch()`版本。
- en: Detecting multiple-object collisions at an offset
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在偏移量处检测多对象碰撞
- en: The collision detection method `getObjectsAtOffset()` is very similar to `getOneObjectAtOffset()`.
    It just, as the name implies, returns all actors that collide at the given offset.
    To demonstrate its use, we are going to re-implement `canMarch()` as we did for
    `getOneObjectAtOffset()`. To take advantage of getting a list of actors that collide,
    we are going to add some additional functionality to `canMarch()`. For each actor
    blocking the forward movement of the zombie, we are going to shove them a little.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测方法`getObjectsAtOffset()`与`getOneObjectAtOffset()`非常相似。正如其名所示，它只是返回给定偏移量处所有碰撞的演员。为了演示其用法，我们将像对`getOneObjectAtOffset()`所做的那样重新实现`canMarch()`。为了利用获取碰撞演员列表的优势，我们将在`canMarch()`中添加一些额外的功能。对于每个阻挡僵尸前进运动的演员，我们将稍微推挤他们。
- en: 'Here''s the implementation of `canMarch()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`canMarch()`的实现：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this version, we use a `while` loop and `step` variable in much the same
    way we did previously for the `getOneObjectAtOffset()` version of `canMarch()`.
    Inside the `while` loop is where we added the new "shoving" functionality. When
    we detect that there is at least one `Actor` in the list, we iterate through the
    list using a `for` loop to slightly push each actor we collided with. The first
    thing we do in the `for` loop is check whether or not the `Actor` class is a `Zombie`
    class using the `instanceof` operator. If it isn't, we skip over it. We don't
    want the ability to shove `Wall` or `House`. For each zombie we collided with,
    we set the `toss` variable to `1` or `-1` with equal probability We then move
    that zombie with `setLocation()`. The effect is interesting and gives the illusion
    that the zombies are trying to push and shove their way to the front. Compile
    and run the scenario with the changes to `canMarch()` and see for yourself. *Figure
    6* shows how the zombies bunch up with the preceding changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们使用`while`循环和`step`变量，与之前`canMarch()`的`getOneObjectAtOffset()`版本所做的方式几乎相同。在`while`循环内部，我们添加了新的“推挤”功能。当我们检测到列表中至少有一个`Actor`时，我们使用`for`循环遍历列表，轻微地推动我们与之碰撞的每个演员。在`for`循环中，我们首先使用`instanceof`运算符检查`Actor`类是否是`Zombie`类。如果不是，我们跳过它。我们不希望有推挤`Wall`或`House`的能力。对于每个我们与之碰撞的僵尸，我们以相等的概率将`toss`变量设置为`1`或`-1`。然后我们使用`setLocation()`移动那个僵尸。这种效果很有趣，给人一种僵尸试图推挤和冲到前面的错觉。编译并运行带有`canMarch()`更改的场景，看看结果如何。*图6*展示了僵尸如何在前面的更改下聚集在一起。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The instanceof Operator**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**`instanceof`运算符**'
- en: Java's `instanceof` operator checks whether the left-hand side argument is an
    object created from the class (or any of its subclasses) specified on the right-hand
    side. It will return `true` if it is and `false` otherwise. It will also return
    `true` if the left-hand side object implements the interface specified on the
    right-hand side.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`instanceof`运算符检查左侧参数是否是从右侧指定的类（或其任何子类）创建的对象。如果是，它将返回`true`；否则返回`false`。如果左侧对象实现了右侧指定的接口，它也将返回`true`。
- en: '![Detecting multiple-object collisions at an offset](img/image00285.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![在偏移量处检测多对象碰撞](img/image00285.jpeg)'
- en: 'Figure 6: Here''s a view of the zombies pushing and shoving to get to the humans
    in the houses first'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：这是僵尸推挤和冲向房屋中的人类的一个视图
- en: Hidden-sprite collision detection methods
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏精灵碰撞检测方法
- en: One flaw with the `getOneObjectAtOffets()` and `getObjectsAtOffset()` methods
    is that they only check the granularity of a single pixel. If an object of interest
    is one pixel above or below the offset provided to these methods, then no collision
    will be detected. In fact, in this implementation, if you allow the simulation
    to run until the zombies reach the houses, you'll notice that some zombies can
    move past the houses. This is because the pixel-only check fails between houses.
    One way to handle this deficiency is to use hidden-sprite collision detection.
    *Figure 7* illustrates this method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOneObjectAtOffets()` 和 `getObjectsAtOffset()` 方法的缺点之一是它们只检查单个像素的粒度。如果一个感兴趣的对象位于提供给这些方法的偏移量上方或下方一个像素，那么将不会检测到碰撞。实际上，在这个实现中，如果你允许模拟运行直到僵尸到达房屋，你会注意到一些僵尸可以穿过房屋。这是因为像素检查在房屋之间失败。处理这种不足的一种方法是用隐藏精灵碰撞检测。*图7*展示了这种方法。'
- en: '![Hidden-sprite collision detection methods](img/image00286.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![隐藏精灵碰撞检测方法](img/image00286.jpeg)'
- en: 'Figure 7: This shows the use of a hidden sprite to check for collisions.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这显示了使用隐藏精灵来检查碰撞。
- en: In the hidden-sprite method, you use another `Actor` class to test for collisions.
    *Figure 7* shows a `Zombie` object using a smaller, auxiliary `Actor` class to
    determine if a collision occurred with the flower. While the hidden sprite is
    shown as a translucent red rectangle, in practice, we would set the transparency
    (using `setTransparency()`) to `0`, so that it would not be visible. The hidden-sprite
    method is very flexible because you can create any shape or size for your hidden
    sprite, and it does not have the problem of only looking at a single pixel that
    the two previous collision detection methods had. Next, we will once again change
    the `canMarch()` method in the `Zombie` class, this time using hidden-sprite collision
    detection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐藏精灵方法中，你使用另一个`Actor`类来测试碰撞。*图7*显示了一个`Zombie`对象使用一个较小的、辅助的`Actor`类来确定是否与花朵发生了碰撞。虽然隐藏精灵显示为半透明的红色矩形，但在实际应用中，我们会设置透明度（使用`setTransparency()`）为`0`，使其不可见。隐藏精灵方法非常灵活，因为你可以为你的隐藏精灵创建任何形状或大小，并且它没有像前两种碰撞检测方法那样只关注单个像素的问题。接下来，我们再次修改`Zombie`类中的`canMarch()`方法，这次使用隐藏精灵碰撞检测。
- en: 'The first thing we need to do, is create a new `Actor` that will serve as the
    hidden sprite. Because we are going to use this hidden sprite for zombies, let''s
    call it `ZombieHitBox`. Create this subclass of `Actor` now and do not associate
    an image with it. We will draw the image in the constructor. Here is the implementation
    of `ZombieHitBox`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的`Actor`，它将作为隐藏精灵使用。因为我们打算为僵尸使用这个隐藏精灵，所以让我们称它为`ZombieHitBox`。现在创建这个`Actor`的子类，并且不要将它与任何图像关联。我们将在构造函数中绘制图像。以下是`ZombieHitBox`的实现：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The constructor for `ZombieHitBox` takes six parameters. The reason it takes
    so many parameters is that we need to provide the `Actor` class to which it is
    attached (the `a` parameter), define the size of the rectangle to draw (the `w`
    and `h` parameters), provide the offset of the rectangle from the provided `Actor`
    (the `dx` and `dy` parameters), and check whether the hidden sprite is visible
    (the `visible` parameter). In the constructor, we use `GreenfootImage()`, `setColor()`,
    `setTransparency()`, `fill()`, and `setImage()` to draw the hidden sprite. We
    went over these methods previously in [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZombieHitBox`的构造函数接受六个参数。它之所以需要这么多参数，是因为我们需要提供它附加到的`Actor`类（`a`参数），定义要绘制的矩形的尺寸（`w`和`h`参数），提供矩形相对于提供的`Actor`的偏移量（`dx`和`dy`参数），并检查隐藏精灵是否可见（`visible`参数）。在构造函数中，我们使用`GreenfootImage()`、`setColor()`、`setTransparency()`、`fill()`和`setImage()`来绘制隐藏精灵。我们之前在[第2章](part0017.xhtml
    "第2章。动画") *动画*中讨论了这些方法。'
- en: We use the `act()` method to ensure that this hidden sprite moves along with
    the `Actor` class it is attached to (we will call this the `host` actor). To do
    this, we simply call `setLocation()`, provide the current *x* and *y* position
    of the host actor and shift a little according to the offset values provided in
    the constructor. Before doing this, however, we check whether the `host` has not
    been deleted. If it has, we delete the hit box, as it only has meaning in relation
    to `host`. This handles the case where an explosion destroys `host`, but did not
    quite reach the hit box.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`act()`方法来确保这个隐藏精灵与它附加的`Actor`类（我们将称之为`host`精灵）一起移动。为此，我们只需调用`setLocation()`，提供`host`精灵当前的*x*和*y*位置，并根据构造函数中提供的偏移值进行微调。然而，在这样做之前，我们检查`host`是否已被删除。如果已被删除，我们就删除碰撞框，因为它只与`host`有关。这处理了爆炸摧毁`host`但并未完全达到碰撞框的情况。
- en: Finally, we provide one public method that the `host` actor will use to get
    all the actors that are colliding with the hidden sprite. We named this method
    as `getHitBoxIntersections()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供一个公共方法，`host`精灵将使用它来获取所有与隐藏精灵发生碰撞的精灵。我们把这个方法命名为`getHitBoxIntersections()`。
- en: 'Next, we need to augment the `Zombie` class to use this new hidden sprite.
    We need a handle on this hidden sprite, so we need to add a new property to the
    `Zombie` class. Insert this line of code under the declaration of the `step` variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要增强`Zombie`类以使用这个新的隐藏精灵。我们需要对这个隐藏精灵有一个引用，因此我们需要在`Zombie`类的声明下添加一个新的属性。在`step`变量的声明下插入此行代码：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to augment the `addedToWorld()` method to create and connect
    `ZombieHitBox` to `Zombie`. Here is the implementation of that method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要增强`addedToWorld()`方法来创建并将`ZombieHitBox`连接到`Zombie`。以下是该方法的实现：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We create a 10 x 25 rectangle for our hidden sprite and initially make it visible,
    so that we can test it in our scenario. Once you are satisfied with the placement
    and size of your hidden sprite, you should change the `visible` parameter of `ZombieHitBox`
    from `true` to `false`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的隐藏精灵创建一个10 x 25的矩形，并最初使其可见，这样我们就可以在我们的场景中测试它。一旦你对隐藏精灵的位置和大小满意，你应该将`ZombieHitBox`的`visible`参数从`true`更改为`false`。
- en: 'Now that we have created, initialized, and placed `ZombieHitBox`, we can make
    our changes to `canMarch()` to demonstrate the use of the hidden-sprite method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建、初始化并放置了`ZombieHitBox`，我们可以对`canMarch()`进行修改，以展示隐藏精灵方法的使用：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unlike previous implementations of `canMarch()`, we need to first ask the hidden
    sprite for a list of actors colliding with this zombie. Once we get that list,
    we check that it has a size greater than one. The reason why it needs to be greater
    than one, is that `ZombieHitBox` will include the zombie it is attached to. If
    we are not colliding with any other zombies or actors, we return `true`. If we
    are colliding with a number of actors, then we iterate through them all and make
    some decisions based on the type of `Actor`. If `Actor` is this zombie or an instance
    of `ZombieHitBox`, we skip it and don't take any action. The next check is whether
    or not `Actor` is an instance of the `Zombie` class. If it isn't, then it is some
    other object, such as `House` or `Wall`, and we return `false`, so that we will
    not move forward. If it is an instance of the `Zombie` class, we check whether
    or not it is in front of this zombie. If it is, we shove it a little (just as
    we did in the previous implementation of `canMarch()`) and increment the `infront`
    variable. At the end of iterating through the list of actors, we check the `infront`
    variable. If there were any zombies in front of this zombie, we return `false`
    to prevent it from moving forward. Otherwise, we return `true`. The outermost
    `if` statement simply checks that the hitbox (`zbh`) associated with this object
    has not been previously destroyed by a `Boom` object. If it has, then we need
    to remove this object too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`canMarch()`实现不同，我们首先需要询问隐藏精灵获取与这个僵尸碰撞的演员列表。一旦我们得到这个列表，我们检查它的大小是否大于一个。它需要大于一个的原因是`ZombieHitBox`将包括它所附着的僵尸。如果我们没有与其他僵尸或演员发生碰撞，我们返回`true`。如果我们与多个演员发生碰撞，那么我们将遍历它们所有，并根据`Actor`的类型做出一些决定。如果`Actor`是这个僵尸或`ZombieHitBox`的实例，我们跳过它并且不采取任何行动。下一个检查是`Actor`是否是`Zombie`类的实例。如果不是，那么它是一些其他对象，比如`House`或`Wall`，我们返回`false`，这样我们就不会向前移动。如果是`Zombie`类的实例，我们检查它是否在这个僵尸的前面。如果是，我们稍微推它一下（就像我们在之前的`canMarch()`实现中做的那样）并增加`infront`变量。遍历演员列表结束后，我们检查`infront`变量。如果有僵尸在这个僵尸的前面，我们返回`false`以防止它向前移动。否则，我们返回`true`。最外层的`if`语句简单地检查与这个对象关联的击中框（`zbh`）是否已经被`Boom`对象之前销毁。如果是，那么我们需要移除这个对象。
- en: Compile and run this version of the scenario. You should observe that the zombies
    bunch up nicely, push and shove each other, yet they are not able to move past
    the houses. Using the hidden-sprite method of collision detection is a bit more
    complex than the rest, but gives us good accuracy.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行这个场景版本。你应该观察到僵尸们很好地聚集在一起，互相推搡，但它们无法越过房屋。使用隐藏精灵的碰撞检测方法比其他方法复杂一些，但提供了很好的精度。
- en: Challenge
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Okay, we have implemented several forms of collision detection in our zombie
    simulation. Which method of collision detection do you prefer for this simulation?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在僵尸模拟中实现了多种形式的碰撞检测。你更喜欢哪种碰撞检测方法用于这个模拟？
- en: For a challenge, create an `Actor` ball that occasionally rolls in from the
    left and knocks zombies out of the way. If the ball hits `Wall`, have it do 1,000
    damage to it. Which form of collision detection will you use to detect collisions
    between the ball and zombies and between the ball and a wall?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，创建一个`Actor`球，它偶尔从左侧滚动过来，并将僵尸推开。如果球击中`Wall`，让它对它造成1,000点伤害。你将使用哪种形式的碰撞检测来检测球与僵尸以及球与墙壁之间的碰撞？
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Collision detection is a crucial component of any game, simulation, or interactive
    application. Greenfoot provides built-in methods of detecting collisions. In this
    chapter, we carefully explained each of these methods and then demonstrated how
    you could use them to do more advanced collision detection. Specifically, we discussed
    border-based and hidden-sprite techniques. Moving forward, we will use collision
    detection often and will choose a method appropriate for our example. In the next
    chapter, we will look at projectiles and will have ample opportunity to put into
    practice what you have learned in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测是任何游戏、模拟或交互式应用的关键组成部分。Greenfoot提供了检测碰撞的内置方法。在本章中，我们详细解释了这些方法，并展示了如何使用它们进行更高级的碰撞检测。具体来说，我们讨论了基于边界的和隐藏精灵技术。向前推进，我们将经常使用碰撞检测，并选择适合我们示例的方法。在下一章中，我们将探讨投射物，并将有充足的机会将本章学到的知识付诸实践。
