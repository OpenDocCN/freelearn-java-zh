- en: Chapter 3. Routing and Processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw the core concepts of implementing the messaging
    and routing system provided by Camel.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will cover routing—one of the most important features of
    Camel. Without the routing, Camel would be a simple *connectivity* framework.
    Routing is a key function of Camel, it means we can apply all the transformations
    to a message. It can modify the content of the message itself or the destination
    of the message, all on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use a processor to change an exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete example of a route containing a processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a processor?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A consumer endpoint receives an event from the environment and wraps it as an
    **Exchange**.
  prefs: []
  type: TYPE_NORMAL
- en: The routing engine transports this Exchange from the endpoint to a processor,
    which is possible from one processor to another processor, up to a final endpoint
    via a **Channel**. The route can end at a processor returning the Exchange to
    the consumer endpoint if the MEP is `InOut` (and using the out message), or stop
    with a producer endpoint, sending the message to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a processor acts as an Exchange modifier—it consumes an Exchange,
    and eventually updates it. We can see the processor as a message translator. Actually,
    all Camel **Exchange Integration Patterns** (**EIPs**) are implemented using processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A processor is described by the `org.apache.camel.Processor` interface. This
    interface provides only one method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As the processor directly receives an Exchange, it has access to all the data
    contained in the Exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: The message exchange pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `in` message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `out` message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `exchange` exception
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An example of Camel routes containing processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will illustrate the use of processors in an example. This example will
    create an **OSGi** bundle, which will create two Camel contexts with one route
    in each; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One route using the Camel Java DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One route using the Camel Blueprint DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we create the Maven project `pom.xml` for our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `pom.xml`, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: That we depend on camel-core (in the version of our choice; here it's 2.12.3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also depend to osgi-core as we create an OSGi bundle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the maven-bundle plugin to create the OSGi bundle (especially the MANIFEST
    containing the OSGi headers). Here, we provide a bundle Activator (`com.pack.camel.chapter3.Activator`),
    the details of which we will see later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefixer processor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to create a Prefixer processor. This processor will get the
    incoming Exchange, extract the `in` message body, and prefix this body with *Prefixed.*
  prefs: []
  type: TYPE_NORMAL
- en: The processor is a simple class implementing the Camel processor interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create `PrefixerProcessor` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how the processor acts as a message translator; it transforms
    the `in` message.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a route using Java DSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's now time to create the first route using the Camel Java DSL, using the
    `PrefixerProcessor`. In order to use the Camel Java DSL, we create a class extending
    the Camel `RouteBuilder` class (`org.apache.camel.RouteBuilder`). This class describes
    the route in a `configure()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `MyRouteBuilder` class which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This route starts with a timer. The timer creates an empty Exchange every 5
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We define the body of the `in` message (of this Exchange) using the `.setBody()`
    method, containing the `Hello Chapter3` constant String.
  prefs: []
  type: TYPE_NORMAL
- en: We call `PrefixerProcessor` using the `.process()` method. As expected, the
    `PrefixerProcessor` appends `Prefixed` to the body of the `in` message, resulting
    to `Prefixed Hello Chapter3`. We can see that `PrefixerProcesser` has been correctly
    called using a log endpoint just after (`.to("log:MyRoute")`).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating a dedicated class for a processor, it's also possible to
    create a processor inline. It's what we do using `.process(new Processor(){…})`.
    We implement an inline processor that removes the prefix appended by `PrefixerProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can see that we are back to the original message in the latest log
    endpoint (`.to("log:MyRoute")`).
  prefs: []
  type: TYPE_NORMAL
- en: The `MyRouteBuilder` class is the route builder. A route has to be embedded
    in the `CamelContext`. It's the purpose of our bundle Activator; the Activator
    creates the `CamelContext`, builds the route, and registers the route in this
    `CamelContext`. For convenience, we also register the `CamelContext` as an OSGi
    service (it allows us to see the `CamelContext` and the route using the `camel:*
    Karaf` commands).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Activator` is a class implementing the `BundleActivator` interface (`org.osgi.framework.BundleActivator`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the bundle starts, the `start()` method of the `Activator` is called by
    the OSGi framework.
  prefs: []
  type: TYPE_NORMAL
- en: At startup, we create the `CamelContext` using `new DefaultCamelContext()`.
  prefs: []
  type: TYPE_NORMAL
- en: We create and register our route in this `CamelContext` using `camelContext.addRoutes(new
    MyRouteBuilder())`.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, we register the `CamelContext` as an OSGi service using `bundleContext.registerService(CamelContext.class,
    camelContext, null)`. Thanks to this service registration, our `CamelContext`
    and route will be visible for the Camel:`*` commands that we have in the Apache
    Karaf OSGi container.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we start the Camel Context (and the route) using `camelContext.start()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when we stop the bundle, the OSGi framework will call the
    `stop()` method of the Activator.
  prefs: []
  type: TYPE_NORMAL
- en: In the `stop()` method, we unregister the Camel Context OSGi service (using
    `serviceRegistration.unregister()`) and we stop the Camel Context (using `camelContext.stop()`).
  prefs: []
  type: TYPE_NORMAL
- en: Route using Camel Blueprint DSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same bundle, we can create another Camel Context and design another route,
    but this time using the Camel Blueprint DSL (OSGi specific). When using the Camel
    Blueprint DSL, we don't have to write all the plumbing code as we do for the first
    Camel Context. The Camel Context is implicitly created by Camel, and we declare
    the route in the Camel Context using the XML description.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OSGI-INF/blueprint` folder of our bundle, we create `route.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this Blueprint descriptor, we first create the `prefixerProcessor` bean.
    The Blueprint container will create the processor.
  prefs: []
  type: TYPE_NORMAL
- en: The Camel Blueprint DSL provides the `<camelContext/>` element. Camel will create
    the Camel Context for us and register the route that we describe. The `<route/>`
    element allows us to describe the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, the route is very close to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts with a timer, creating an empty Exchange every 5 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the body to `Hello Chapter3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls the `prefixerProcessor`. In this case, we use the reference to the
    registered bean. The `ref="prefixerProcessor"` corresponds to the `id="prefixerProcessor"`
    of the `PrefixerProcessor` bean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also call a log endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s important to understand that even if we use the same class, we have two
    different instances of `PrefixerProcessor`:'
  prefs: []
  type: TYPE_NORMAL
- en: A first instance is created in the bundle `Activator` and used in the route
    described using the Camel Java DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second instance is created in the `blueprint` container and used in the route
    described using the Camel Blueprint DSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and deploying our bundle, we are now ready to build our bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Maven, we just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our bundle is now available in our local Maven repository (by default, in the
    `.m2/repository` folder of the `home` directory).
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to deploy the bundle in the Karaf OSGi container.
  prefs: []
  type: TYPE_NORMAL
- en: After having started Karaf (using `bin/karaf` for instance, providing the Karaf
    shell console), we first have to install the Camel support. For this, we register
    the camel features repository and install the `camel-blueprint` feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `camel-blueprint` feature provides support for Camel core (so the Camel
    Java DSL, and all core classes such as `CamelContext`, `Processor`, and so on),
    and Camel Blueprint DSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register the Camel features repository, we use the Karaf `feature:repo-add`
    command specifying the Camel version we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We install the `camel-blueprint` feature using the `feature:install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to install and start our bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the installation, we use the `bundle:install` command with the Maven location
    defined in the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the bundle using the `bundle:start` command using the `Bundle ID`
    given by the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The log messages shows that our routes are running (using the `log:display`
    command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Camel features also provide Karaf commands that we can use to see the running
    Camel Contexts and routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `camel:context-list` command shows the available Camel Contexts,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the two Camel Contexts that we create in our bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have details on each Camel Context using the `camel:context-info` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `camel-1` context contains one route named `route1`.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, `camel-1` is the Camel Context that we created in the Activator, and
    `route1` is the route using the Camel Java DSL. Here, we are able to see `CamelContext`,
    thanks to the OSGi service registration that we perform in the Activator.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we have another Camel Context named `87-camel-4`, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this Camel Context (the one created by Camel as declared in the Blueprint
    descriptor), we can see `route2` corresponding to the route described using the
    Camel Blueprint DSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also obtain details about the routes using the `camel:route-info` command
    (the `camel:route-list` command displays the list of all routes for all Camel
    Contexts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take a look at the details for `route1` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the route has been executed 382 times without errors. We can
    also see a dump of the route with the two processors, coming from `MyRouteBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the details of `route2` corresponding to the routing described
    using the Camel Blueprint DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processor is one of the most important components of Camel. It's like a Swiss
    knife. You can use processor to implement message translation and transformation,
    and any kind of EIPs. All Camel EIPs are implemented using processor to implement
    the Camel component using `ProcessorEndpoint`. We will see later that processors
    are also useful for error handling or for unit tests. To make it even easier,
    you can also use existing beans, acting as processors. Camel can directly use
    your existing beans thanks to an extended bean support, as we will see in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
