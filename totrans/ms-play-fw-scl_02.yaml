- en: Chapter 2. Defining Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。定义行动
- en: If you're reading this, you've either survived the first chapter or skipped
    it. Either way, I am assuming you know the structure of a simple Play application.
    A controller in Play generates Action values and, to do so, it uses several objects
    and methods internally. In this chapter, we will see what goes on behind the scenes
    and how we can leverage these actions when we build our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这篇文章，那么你可能已经度过了第一章，或者跳过了它。无论如何，我假设你知道一个简单Play应用程序的结构。在Play中，控制器生成Action值，为此，它内部使用几个对象和方法。在本章中，我们将了解幕后发生了什么，以及我们如何在构建应用程序时利用这些行动。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining Actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义行动
- en: Request body parsers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求体解析器
- en: Action composition and troubleshooting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动组合和故障排除
- en: A dummy Artist model
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个虚拟的艺术家模型
- en: 'In the following sections, we will give make reference to an `artist` model.
    It is a simple `class` with a companion `object`, defined as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将引用一个`artist`模型。它是一个简单的`class`，有一个伴随的`object`，如下定义：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Artist model has a method to fetch all these artists and a few methods to
    filter the artist, based on different parameters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家模型有一个方法来获取所有这些艺术家，以及一些基于不同参数过滤艺术家的方法。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In real applications, the model interacts with the database but to keep things
    simple, we have hardcoded the data as `Seq[Artist]`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序中，模型与数据库交互，但为了使事情简单，我们已经将数据硬编码为`Seq[Artist]`。
- en: 'We also have a view of `home.scala.html`, which displays information about
    the artist in a table:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`home.scala.html`视图，它以表格的形式显示艺术家信息：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a twirl, template which requires a `Seq[Artist]`. It is similar to the
    view of the TaskTracker application we built in the previous chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个twirl模板，它需要一个`Seq[Artist]`。它与我们在上一章中构建的TaskTracker应用程序的视图类似。
- en: Actions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动
- en: 'An **Action** in Play defines how a server should respond to a request. The
    methods, which define an Action, are mapped to a request in the `routes` file.
    For example, let''s define an Action which displays the information of all the
    artists as a response:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Play中的**Action**定义了服务器应该如何响应用户请求。定义Action的方法映射到`routes`文件中的请求。例如，让我们定义一个Action，它将显示所有艺术家的信息作为响应：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, to use this Action, we should map it to a request in the `routes` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用这个Action，我们应该将其映射到`routes`文件中的请求。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we fetch all the artists and send them with the view, as the
    response to the request.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们获取所有艺术家，并将它们与视图一起发送，作为对请求的响应。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term `api` used in the `route` file is just a URL prefix and is not mandatory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`route`文件中使用的`api`术语只是一个URL前缀，不是强制的。
- en: Run the application and access `http://localhost:9000/api/artist` from the browser.
    A table with the available artist is visible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并从浏览器访问`http://localhost:9000/api/artist`。可以看到一个包含可用艺术家的表格。
- en: 'Action takes a request and yields a result. It is an implementation of the
    `EssentialAction` trait. It is defined as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Action接受一个请求并产生一个结果。它是`EssentialAction`特质的实现。它被定义为：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Iteratee** is a concept borrowed from functional languages. It is used to
    process chunks of data in an incremental manner. We will dig deeper into it in
    [Chapter 6](ch06.html "Chapter 6. Reactive Data Streams"), *Reactive Data Streams*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Iteratee**是从函数式语言中借用的一个概念。它用于以增量方式处理数据块。我们将在[第6章](ch06.html "第6章。反应式数据流")*反应式数据流*中更深入地探讨它。'
- en: The apply method accepts a function, which transforms a request into a result.
    The `RequestHeader` and other chunks of data represent the request. In short,
    the `apply` method takes in a request and returns a result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`方法接受一个函数，该函数将请求转换成结果。`RequestHeader`和其他数据块代表请求。简而言之，`apply`方法接受一个请求并返回一个结果。'
- en: Let's see some of the ways in which an action can be defined.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看定义行动的一些方法。
- en: Actions with parameters
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带参数的Action
- en: 'We might come across a situation where we need to define an Action, which takes
    a value from the request path. In this case, we will need to add the parameters
    required for the method signature and pass them in the routes file. An example
    of this would be the method to fetch artists by their selected names. In the controller,
    add the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到需要定义一个从请求路径中获取值的Action的情况。在这种情况下，我们需要添加方法签名所需的参数，并在路由文件中传递它们。这个例子将是获取按所选名称检索艺术家的方法。在控制器中添加以下内容：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The mapping for this in the `routes` file will be:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes`文件中的映射将是：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If it''s not specified explicitly, keep in mind that the type of parameter
    in the path is set to `String` by default. The type can be specified in the method
    call. So, the route defined is equivalent to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确指定，请注意，路径中参数的类型默认设置为`String`。可以在方法调用中指定类型。因此，定义的路由等同于：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Similarly, we could add more parameters if required.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果需要，我们可以添加更多参数。
- en: 'Now, take the use case of a search query. We want the action to accept query
    parameters, such as name and country. The action is defined as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个搜索查询的使用案例。我们希望操作能够接受查询参数，例如名称和国家。操作定义如下：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If there are no artists matching the criteria, the response is empty, and shows
    a status code 204 (no content). If it doesn't, the response status is `200 = (Ok)`,
    and shows the result as the response body.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有艺术家符合标准，则响应为空，并显示状态码204（无内容）。如果不满足，则响应状态为`200 = (Ok)`，并将结果作为响应体显示。
- en: 'The entry corresponding to this Action in the routes file will be the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 路由文件中对应此操作的条目将是以下内容：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We do not use any parameters in the path, but query parameters whose labels
    correspond to the method's parameter names in the `routes` file should be included.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在路径中不使用任何参数，但应该包含与`routes`文件中方法的参数名称对应的查询参数。
- en: 'This will result in a valid URL: `http://localhost:9000/api/search/artist?name=Franz&country=Austria`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个有效的URL：`http://localhost:9000/api/search/artist?name=Franz&country=Austria`
- en: What if we decided to make `country` an optional parameter?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将`country`设置为可选参数怎么办？
- en: 'Let''s modify the route to accommodate this change:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改路由以适应这一变化：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This allows us to make queries by the name as well, so, both the URLs will
    now look like this: `http://localhost:9000/api/search/artist?name=Franz` and `http://localhost:9000/api/search/artist?name=Franz&country=Austria`
    are now supported.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们通过名称进行查询，因此，现在这两个URL将看起来像这样：`http://localhost:9000/api/search/artist?name=Franz`
    和 `http://localhost:9000/api/search/artist?name=Franz&country=Austria` 都已支持。
- en: 'Here, we made the `country` parameter optional by setting a default value for
    it in the route definition. Alternatively, we could define an Action to accept
    a parameter of the `Option` type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在路由定义中为`country`参数设置默认值来使其成为可选参数。或者，我们也可以定义一个接受`Option`类型参数的操作：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, the route will be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，路由将如下所示：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now make requests with or without passing the name of the country:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以带或不带国家名称进行请求：
- en: '`http://localhost:9000/api/search2/artist?country=Austria`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:9000/api/search2/artist?country=Austria`'
- en: '`http://localhost:9000/api/search2/artist?name=Franz&country=Austria`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:9000/api/search2/artist?name=Franz&country=Austria`'
- en: In the examples shown in this section, we didn't need to use the request to
    generate our result but in some cases, we would use the request to generate a
    relevant result. However, to do this, understanding the format of the request
    content is crucial. We'll see how this is done in the following section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中显示的示例中，我们不需要使用请求来生成我们的结果，但在某些情况下，我们会使用请求来生成相关结果。然而，为了做到这一点，理解请求内容的格式至关重要。我们将在下一节中看到这是如何完成的。
- en: Request body parsers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求体解析器
- en: Consider the most common POST request in any application—the request sent for
    logins. Will it be sufficient if the request body has the user's credentials in,
    say, a JSON or XML format? Will the request handler be able to extract this data
    and process it directly? No, since the data in the request has to be understood
    by the application code, it must be translated into a compatible type. For example,
    XML sent in a request must be translated to Scala XML for a Scala application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到任何应用程序中最常见的POST请求——用于登录的请求。如果请求体包含用户的凭据，比如JSON或XML格式，这将是足够的吗？请求处理器能否直接提取这些数据并处理它们？不，因为请求中的数据必须被应用程序代码理解，它必须被转换为兼容的类型。例如，发送到Scala应用程序的XML必须转换为Scala
    XML。
- en: There are several libraries, such as Jackson, XStream, and so on, which can
    be used to achieve this task, but we wouldn't need them as Play supports this
    internally. Play provides request body parsers to transform the request body into
    equivalent Scala objects for some of the frequently used content types. In addition
    to this, we can extend existing parsers or define new ones.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个库，例如Jackson、XStream等，可以用来完成这个任务，但我们不需要它们，因为Play内部支持这个功能。Play提供了请求体解析器，可以将请求体转换为常用内容类型的等效Scala对象。此外，我们还可以扩展现有解析器或定义新的解析器。
- en: 'Every Action has a parser. How do I know this ? Well, the Action object, which
    we used to define how our app should respond, is simply an extension of the Action
    trait, and is defined as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Action都有一个解析器。我如何知道这一点？嗯，我们用来定义应用应该如何响应的Action对象，仅仅是Action特质的扩展，并且定义如下：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `apply` method transforms the value returned by the parser. The value from
    the parser can either be a result or the request body (denoted as `Either[Result,A]`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`方法转换解析器返回的值。解析器返回的值可以是结果或请求体（表示为`Either[Result,A]`）。'
- en: Therefore, the transformation is defined for both possible outcomes. If we pattern-match
    this, we get `Left(r)`, which is a result type and `Right(a)`, which is the request
    body.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，转换被定义为两种可能的结果。如果我们进行模式匹配，我们得到`Left(r)`，这是一个结果类型，以及`Right(a)`，这是请求体。
- en: The `mapM` method functions similarly to the `map` method, the only difference
    being, it does so asynchronously.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapM`方法与`map`方法功能相似，唯一的区别是它是异步执行的。'
- en: However, can Actions be defined even without a parser? Yes and no.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使没有解析器，也可以定义Action吗？是的，也可以不是。
- en: 'Let''s look at an example Action: a POST request, which is required to subscribe
    to updates. This request takes the user''s e-mail ID as a query parameter, which
    means that we will need to access the request body in order to complete the subscription
    for this user. First, we''ll check what the request body looks like when we do
    not specify a parser. Create an Action `subscribe` in a controller, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例Action：一个POST请求，这是订阅更新的必需请求。这个请求接受用户的电子邮件ID作为查询参数，这意味着我们需要访问请求体以完成此用户的订阅。首先，我们将检查在不指定解析器的情况下请求体看起来像什么。在控制器中创建一个名为`subscribe`的Action，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add an entry for this in the routes file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在路由文件中为这个添加一个条目：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After this, run the application. Send a POST request at `http://localhost:9000/subscribe`
    with the `userId@gmail.com` e-mail ID using a REST client or Curl (whichever you
    are more comfortable with).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行应用程序。使用REST客户端或Curl（您更习惯哪个）向`http://localhost:9000/subscribe`发送带有`userId@gmail.com`电子邮件ID的POST请求。
- en: 'For example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The response for this request will be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求的响应将是以下内容：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Did you notice that our `subscribe` method understood that the content was text?
    The request body was translated as `AnyContentAsText(userId@gmail.com)`. How did
    our method determine this? Isn't this the job of a parser mapped to a particular
    Action?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们的`subscribe`方法理解了内容是文本吗？请求体被转换成了`AnyContentAsText(userId@gmail.com)`。我们的方法是如何确定这一点的？这不是映射到特定Action的解析器的职责吗？
- en: 'When a parser is not specified for an Action, the parser returned by the `BodyParsers.parse.anyContent`
    method is set as the parser for this Action. This is handled by the `ActionBuilder`,
    which we will see later in this chapter. The following code snippet shows one
    of the methods to generate an Action when no parser is given:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当为Action未指定解析器时，`BodyParsers.parse.anyContent`方法返回的解析器被设置为该Action的解析器。这是由`ActionBuilder`处理的，我们将在本章后面看到。以下代码片段显示了在没有提供解析器时生成Action的一种方法：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s examine what the `BodyParsers.parse.anyContent` method does:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查一下`BodyParsers.parse.anyContent`方法的作用：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First of all, it checks whether the request type supports sending data along
    with the request. If not, it returns `AnyContentAsEmpty` (you can check this by
    changing the request type to GET in the routes file and sending a GET request),
    else it compares the content type Header of the request with the supported types.
    If a match is found, it transforms the data into the corresponding type and returns
    that, or else it parses it as bytes and returns `play.api.mvc.RawBuffer`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查请求类型是否支持在请求中发送数据。如果不支持，它返回`AnyContentAsEmpty`（你可以通过在路由文件中将请求类型改为GET并发送GET请求来检查这一点），否则它将请求的内容类型Header与支持的类型进行比较。如果找到匹配项，它将数据转换成相应的类型并返回，否则它将解析为字节并返回`play.api.mvc.RawBuffer`。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`AnyContentAsEmpty`, `AnyContentAsText`, `AnyContentAsXml`, `AnyContentAsJson`,
    `AnyContentAsFormUrlEncoded`, `AnyContentAsMultipartFormData`, and `AnyContentAsRaw`
    all extend the trait `AnyContent`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyContentAsEmpty`、`AnyContentAsText`、`AnyContentAsXml`、`AnyContentAsJson`、`AnyContentAsFormUrlEncoded`、`AnyContentAsMultipartFormData`和`AnyContentAsRaw`都扩展了`AnyContent`特质。'
- en: So, when an Action is defined for one of the supported content types or when
    it's a GET/HEAD request, we need not mention the parser.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当为支持的某一种内容类型定义了Action或者当它是GET/HEAD请求时，我们不需要提及解析器。
- en: 'Let''s see how we can access the request body in our Action. We can now updating
    our `subscrib` `e` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的Action中访问请求体。我们现在可以更新我们的`subscrib` `e`方法：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to access the data in the request body, we need to convert it from
    `AnyContent` to `Option[String]` using the `asText` method. This would become
    more concise if we added the parser in the Action definition:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问请求体中的数据，我们需要使用`asText`方法将其从`AnyContent`转换为`Option[String]`。如果我们在Action定义中添加解析器，这将变得更加简洁：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `urlFormEncoded` text XML parsers return standard Scala objects while the
    others return Play objects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlFormEncoded`文本XML解析器返回标准的Scala对象，而其他解析器返回Play对象。'
- en: 'We can assume that the subscription request takes a JSON in this format:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设订阅请求采用以下格式的JSON：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will need to modify our `subscribe` method to `def subscribe = Action(parse.json)
    {`, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的`subscribe`方法为`def subscribe = Action(parse.json) {`，如下所示：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the following request:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下请求：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We get a response as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下响应：
- en: Added `userId@gmail.com` to the subscriber's list and will send updates every
    month
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将`userId@gmail.com`添加到订阅者列表，并将每月发送更新
- en: The `parse.json` transforms the request body to `play.api.libs.json.JsValue`.
    The `\` operator is used to access the value of a particular key. Similarly, there
    is a `\\` operator, which can be for the value of a key, though it may not be
    a direct child of the current node. Play-Json has several methods that simplify
    the handling of data in a JSON format, such as modifying the structure, or converting
    it to Scala models, and so on. Play-Json is also available as a stand-alone library
    to enable its usage in non-Play projects. Its documentation is available at [https://www.playframework.com/documentation/2.3.x/ScalaJson](https://www.playframework.com/documentation/2.3.x/ScalaJson).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse.json`将请求体转换为`play.api.libs.json.JsValue`。`\`运算符用于访问特定键的值。同样，还有一个`\\`运算符，它可以用于键的值，尽管它可能不是当前节点的直接子节点。Play-Json有几个简化JSON格式数据处理的方法，例如修改结构或将其转换为Scala模型等。Play-Json也可以作为一个独立的库使用，以便在非Play项目中使用。其文档可在[https://www.playframework.com/documentation/2.3.x/ScalaJson](https://www.playframework.com/documentation/2.3.x/ScalaJson)找到。'
- en: 'Now, let''s see how to write an Action to add a new user, which takes a request
    of content-type multipart:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何编写一个添加新用户的Action，它接受内容类型为multipart的请求：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The request has three fields: `email`, `name`, and `displayPic`. From the request
    data, we fetch the e-mail of, name, and add a new user. The `User.` `save` method
    adds an entry in the user table and throws an error if a user with the same e-mail
    ID exists. This is why the operations in the file are performed only after adding
    a user. The `displayPic` is optional; therefore, the check for its length to be
    greater than zero is made prior to saving the image.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请求有三个字段：`email`、`name`和`displayPic`。从请求数据中，我们获取电子邮件、姓名并添加新用户。`User.` `save`方法在用户表中添加条目，如果存在具有相同电子邮件ID的用户，则抛出错误。这就是为什么文件中的操作只在添加用户后执行。`displayPic`是可选的；因此，在保存图像之前，会检查其长度是否大于零。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: It is better to complete the data transactions before the file-related ones,
    since they may fail and file-related operations might not be required for the
    incorrect request. The following table shows the supported content-types, parsers,
    and their default conversions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件相关操作之前完成数据事务会更好，因为它们可能会失败，而对于不正确的请求，可能不需要文件相关操作。以下表格显示了支持的内容类型、解析器和它们的默认转换。
- en: '| Content type | Parser | Parsed to Scala type |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 内容类型 | 解析器 | 解析为Scala类型 |'
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `text/plain` | `text` | `String` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `text/plain` | `text` | `String` |'
- en: '| `application/json` or `text/json` | `json` | `play.api.libs.json.JsValue`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `application/json`或`text/json` | `json` | `play.api.libs.json.JsValue` |'
- en: '| `application/xml`, `text/xml`, or `application/XXX+xml` | `xml` | `NodeSeq`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `application/xml`, `text/xml`, or `application/XXX+xml` | `xml` | `NodeSeq`
    |'
- en: '| `application/form-url-encoded` | `urlFormEncoded` | `Map[String, Seq[String]]`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `application/form-url-encoded` | `urlFormEncoded` | `Map[String, Seq[String]]`
    |'
- en: '| `multipart/form-data` | `multipartFormData` | `play.api.mvc.MultipartFormData[TemporaryFile]`
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `multipart/form-data` | `multipartFormData` | `play.api.mvc.MultipartFormData[TemporaryFile]`
    |'
- en: '| `other` | `raw` | `Play.api.mvc.RawBuffer` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `other` | `raw` | `Play.api.mvc.RawBuffer` |'
- en: Extending a parser
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展解析器
- en: 'Let''s extend the JSON parser so that we get a subscription model. We will
    assume that the `Subscription` model is defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展JSON解析器，以便我们得到一个订阅模型。我们将假设`Subscription`模型如下定义：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s write a parser that transforms the request body into a subscription
    object. The following code should be written in a controller:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are also tolerant parsers. By tolerant, we mean that errors in a format
    are not ignored. This simply means that it ignores the content type header in
    the request and parses based on the type specified. For example, let''s update
    the `subscribe` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, a request with the content type as text and a request where the content
    type text/JSON, or any other type for that matter, will give the same result.
    There are tolerant parsers for all the basic parsers supported in Play.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the results
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Play, the response to a request is a **result**. A result has two components:
    the response header and the response body. Let''s look at a simple example of
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that we used an enumerator for the response body. An enumerator is a
    means to provide data to an iteratee. We will discuss these in detail in [Chapter
    6](ch06.html "Chapter 6. Reactive Data Streams"), *Reactive Data Streams*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, a result has additional functions that equips us with better
    means to handle response headers, sessions, cookies, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'A result can send JSON, XML, and images as a response, apart from a String
    content. An easier way of generating a result is to use the result helpers. A
    result helper is used for most of the HTTP response status. As an example, let''s
    see how the `TODO` Action that comes built in with Play is implemented:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this snippet, `NotImplemented` is a helper, which returns a result with a
    status of 501 and `views.html.defaultpages.todo()` returns the default page, which
    is `todo.scala.html`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll consider the Action that sends the user''s profile image
    inline. The Action would now be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we attempt to load the user's profile image using the predefined `getUserImagePath`
    method. If the image file exists and attaches itself to the response, we return
    a response with the `204` status code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We also saw how a result helper can be used to send the page content, both
    static and dynamic, using views:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We could also use the `Status` class to generate the result, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This table shows you the result helpers and their corresponding status codes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '| Result helper | Status code constants | Status code |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| – | `CONTINUE` | 100 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| – | `SWITCHING_PROTOCOLS` | 101 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | `OK` | 200 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `Created` | `CREATED` | 201 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `Accepted` | `ACCEPTED` | 202 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `NonAuthoritativeInformation` | `NON_AUTHORITATIVE_INFORMATION` | 203 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `NoContent` | `NO_CONTENT` | 204 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `ResetContent` | `RESET_CONTENT` | 205 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `PartialContent` | `PARTIAL_CONTENT` | 206 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `MultiStatus` | `MULTI_STATUS` | 207 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| – | `MULTIPLE_CHOICES` | 300 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `MovedPermanently` | `MOVED_PERMANENTLY` | 301 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `Found` | `FOUND` | 302 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `SeeOther` | `SEE_OTHER` | 303 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `NotModified` | `NOT_MODIFIED` | 304 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| – | `USE_PROXY` | 305 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `TemporaryRedirect` | `TEMPORARY_REDIRECT` | 307 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `BadRequest` | `BAD_REQUEST` | 400 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `BadRequest` | `BAD_REQUEST` | 400 |'
- en: '| `Unauthorized` | `UNAUTHORIZED` | 401 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `Unauthorized` | `UNAUTHORIZED` | 401 |'
- en: '| – | `PAYMENT_REQUIRED` | 402 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| – | `PAYMENT_REQUIRED` | 402 |'
- en: '| `Forbidden` | `FORBIDDEN` | 403 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `Forbidden` | `FORBIDDEN` | 403 |'
- en: '| `NotFound` | `NOT_FOUND` | 404 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `NotFound` | `NOT_FOUND` | 404 |'
- en: '| `MethodNotAllowed` | `METHOD_NOT_ALLOWED` | 405 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `MethodNotAllowed` | `METHOD_NOT_ALLOWED` | 405 |'
- en: '| `NotAcceptable` | `NOT_ACCEPTABLE` | 406 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `NotAcceptable` | `NOT_ACCEPTABLE` | 406 |'
- en: '| – | `PROXY_AUTHENTICATION_REQUIRED` | 407 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| – | `PROXY_AUTHENTICATION_REQUIRED` | 407 |'
- en: '| `RequestTimeout` | `REQUEST_TIMEOUT` | 408 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `RequestTimeout` | `REQUEST_TIMEOUT` | 408 |'
- en: '| `Conflict` | `CONFLICT` | 409 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Conflict` | `CONFLICT` | 409 |'
- en: '| `Gone` | `GONE` | 410 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `Gone` | `GONE` | 410 |'
- en: '| – | `LENGTH_REQUIRED` | 411 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| – | `LENGTH_REQUIRED` | 411 |'
- en: '| `PreconditionFailed` | `PRECONDITION_FAILED` | 412 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `PreconditionFailed` | `PRECONDITION_FAILED` | 412 |'
- en: '| `EntityTooLarge` | `REQUEST_ENTITY_TOO_LARGE` | 413 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `EntityTooLarge` | `REQUEST_ENTITY_TOO_LARGE` | 413 |'
- en: '| `UriTooLong` | `REQUEST_URI_TOO_LONG` | 414 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `UriTooLong` | `REQUEST_URI_TOO_LONG` | 414 |'
- en: '| `UnsupportedMediaType` | `UNSUPPORTED_MEDIA_TYPE` | 415 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `UnsupportedMediaType` | `UNSUPPORTED_MEDIA_TYPE` | 415 |'
- en: '| – | `REQUESTED_RANGE_NOT_SATISFIABLE` | 416 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| – | `REQUESTED_RANGE_NOT_SATISFIABLE` | 416 |'
- en: '| `ExpectationFailed` | `EXPECTATION_FAILED` | 417 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `ExpectationFailed` | `EXPECTATION_FAILED` | 417 |'
- en: '| `UnprocessableEntity` | `UNPROCESSABLE_ENTITY` | 422 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `UnprocessableEntity` | `UNPROCESSABLE_ENTITY` | 422 |'
- en: '| `Locked` | `LOCKED` | 423 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `Locked` | `LOCKED` | 423 |'
- en: '| `FailedDependency` | `FAILED_DEPENDENCY` | 424 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `FailedDependency` | `FAILED_DEPENDENCY` | 424 |'
- en: '| `TooManyRequest` | `TOO_MANY_REQUEST` | 429 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `TooManyRequest` | `TOO_MANY_REQUEST` | 429 |'
- en: '| `InternalServerError` | `INTERNAL_SERVER_ERROR` | 500 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `InternalServerError` | `INTERNAL_SERVER_ERROR` | 500 |'
- en: '| `NotImplemented` | `NOT_IMPLEMENTED` | 501 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `NotImplemented` | `NOT_IMPLEMENTED` | 501 |'
- en: '| `BadGateway` | `BAD_GATEWAY` | 502 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `BadGateway` | `BAD_GATEWAY` | 502 |'
- en: '| `ServiceUnavailable` | `SERVICE_UNAVAILABLE` | 503 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceUnavailable` | `SERVICE_UNAVAILABLE` | 503 |'
- en: '| `GatewayTimeout` | `GATEWAY_TIMEOUT` | 504 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `GatewayTimeout` | `GATEWAY_TIMEOUT` | 504 |'
- en: '| `HttpVersionNotSupported` | `HTTP_VERSION_NOT_SUPPORTED` | 505 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `HttpVersionNotSupported` | `HTTP_VERSION_NOT_SUPPORTED` | 505 |'
- en: '| `InsufficientStorage` | `INSUFFICIENT_STORAGE` | 507 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `InsufficientStorage` | `INSUFFICIENT_STORAGE` | 507 |'
- en: Asynchronous Actions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步操作
- en: Suppose that we are at a food court and place an order to eat something at a
    kiosk, we are given a token and a bill. Later, when the order is ready, the kiosk
    flashes the token number, and upon noticing it, we collect the order.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在美食广场，并在一个亭子点餐，我们得到了一个凭证和账单。稍后，当订单准备好时，亭子闪烁凭证号码，当我们注意到它时，我们取走订单。
- en: This is similar to a request with an asynchronous response cycle, where the
    kiosk acts like the server, the order acts similar to a request, and the token
    as a promise, which gets resolved when the order is ready.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于具有异步响应周期的请求，其中亭子充当服务器，订单类似于请求，凭证作为承诺，当订单准备好时得到解决。
- en: Most operations are better handled asynchronously. This is also mostly preferred
    since it does not block server resources until the operation is completed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作最好异步处理。这也通常是首选，因为它不会在操作完成之前阻塞服务器资源。
- en: 'Play Action is a helper object, which extends the `ActionBuilder` trait. The
    apply method of the `ActionBuilder` trait implements the `Action` trait, which
    we saw earlier. Let''s take a look at the relevant code from the `ActionBuilder`
    trait:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Play Action 是一个辅助对象，它扩展了 `ActionBuilder` 特性。`ActionBuilder` 特性的 `apply` 方法实现了我们之前看到的
    `Action` 特性。让我们看看 `ActionBuilder` 特性中的相关代码：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that the `apply` method itself calls the `async` method internally. The
    `async` method expects us to define the Action, which results in `Future[Result]`,
    thereby aiding us to write non-blocking code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`apply` 方法本身在内部调用 `async` 方法。`async` 方法期望我们定义 Action，这会导致 `Future[Result]`，从而帮助我们编写非阻塞代码。
- en: 'We will use the same method to define an asynchronous Action. Assume that we
    need to fetch the requested file from a remote client, consolidate/analyze the
    data, and then send the results. Since we do not know the size of the file and
    the status of network connectivity with a remote client, it is better to handle
    the Action asynchronously. The action will be defined in this way:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的方法来定义一个异步 Action。假设我们需要从远程客户端获取请求的文件，整合/分析数据，然后发送结果。由于我们不知道文件的大小以及与远程客户端的网络连接状态，最好异步处理
    Action。Action 将以这种方式定义：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After fetching the file, if it is empty, we send a response with a status code
    of 204, else we continue with the processing and send the processed data as a
    part of the result.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取文件后，如果它是空的，我们发送一个状态码为 204 的响应，否则我们继续处理并发送处理后的数据作为结果的一部分。
- en: 'We may come across an instance, as we saw in the previous example, get report,
    that we do not wish to wait longer than 10 seconds for the remote client to fetch
    the file. In this case, we''ll need to modify the Action definition in this way:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到一个实例，就像我们在前面的例子中看到的那样，我们不想等待远程客户端获取文件超过 10 秒。在这种情况下，我们需要以这种方式修改操作定义：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, if the remote client doesn't respond with the requested file in 10 seconds,
    we will get a response with status code 500 and the content as the message we
    set for the timeout, `Past max time`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果远程客户端在 10 秒内没有响应请求的文件，我们将收到一个状态码为 500 的响应，内容是我们为超时设置的消息，“超过最大时间”。
- en: Content negotiation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容协商
- en: 'According to HTTP:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 HTTP 协议：
- en: '*Content negotiation is the process of selecting the best representation for
    a given response when there are multiple representations available.*'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*内容协商是在有多种表示形式可供选择时，选择给定响应的最佳表示的过程。*'
- en: It can either be server-driven or agent-driven or a combination of both, which
    is called transparent negotiation. Play provides support for server-driven negotiations.
    This is handled by the rendering trait and is extended by the controller trait.
    The controller trait is the one where the controller objects in a Play app extend.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是服务器驱动的，也可以是代理驱动的，或者两者的组合，这被称为透明协商。Play 提供了对服务器驱动协商的支持。这由渲染特性处理，并由控制器特性扩展。控制器特性是
    Play 应用程序中控制器对象扩展的地方。
- en: 'Let''s look at the `Rendering` trait:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Rendering` 特性：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `_render` method defined in the `apply` method calls the partial `f` function
    on the accept headers in the request. If `f` is not defined for the any of the
    accept headers, a response with status code 406 is forwarded. If it's not, the
    result of `f` for the first accept header for which `f` is defined, is returned.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `apply` 方法中定义的 `_render` 方法会在请求的接受头中调用部分 `f` 函数。如果没有为任何接受头定义 `f`，则转发状态码为 406
    的响应。如果定义了，则返回 `f` 对第一个定义了 `f` 的接受头的第一个结果。
- en: 'Since the controller extends the rendering trait, we can use the render object
    within our Action definition. For example, we might have an Action, which gets
    the configuration in JSON and XML after reading it from a file with an XML format,
    depending on the accept headers in the request. Let''s see how this is done:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于控制器扩展了渲染特性，我们可以在我们的操作定义中使用渲染对象。例如，我们可能有一个操作，在从具有 XML 格式的文件中读取配置后，根据请求的接受头以
    JSON 和 XML 格式获取配置。让我们看看这是如何实现的：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this snippet, `Accepts.Xml()` and `Accepts.Json()` are Play''s helper methods
    that check to see if the request accepts the response of the `application/xml`
    and `applicat` `ion/json` types, respectively. There are currently four predefined
    accepts and these are tabulated here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`Accepts.Xml()` 和 `Accepts.Json()` 是 Play 的辅助方法，用于检查请求是否接受 `application/xml`
    和 `application/json` 类型的响应。目前有四个预定义的接受类型，如下表所示：
- en: '| Request accept helper | Accept header value |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 请求接受辅助 | 接受头值 |'
- en: '| --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| XML | `application/xml` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| XML | `application/xml` |'
- en: '| JSON | `application/json` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| JSON | `application/json` |'
- en: '| HTML | `text/html` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| HTML | `text/html` |'
- en: '| JavaScript | `text/javascript` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | `text/javascript` |'
- en: 'This is facilitated by the `RequestExtractors` trait and the `AcceptExtractors`
    trait. `RequestExtractors` is also extended by the controller trait. Let''s look
    at the extractor traits here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这由 `RequestExtractors` 特性和 `AcceptExtractors` 特性促进。`RequestExtractors` 也由控制器特性扩展。让我们看看这里的提取器特性：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From this code, all that we need to define a custom accepts is the value we
    would expect the request''s accept header to have. For example, to define a helper
    for `image/png`, we use this code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，我们只需要定义一个自定义接受值，这是我们期望请求的接受头将具有的值。例如，为了定义 `image/png` 的辅助程序，我们使用以下代码：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also notice that `RequestExtractors` has an `&` object, and we can use this
    when we wish to send the same response to multiple accept types. So, in the `getConfig`
    method shown in the preceding code, if the same response response is sent for
    `application/json` and `text/javascript`, we will modify it as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到 `RequestExtractors` 有一个 `&` 对象，我们可以在希望向多个接受类型发送相同响应时使用它。因此，在前面代码中显示的
    `getConfig` 方法中，如果为 `application/json` 和 `text/javascript` 发送相同的响应，我们将对其进行如下修改：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `render` object can be used similarly when defining an asynchronous Action.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义异步操作时，`render` 对象可以被类似地使用。
- en: Filters
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: In most applications, we need to perform the same operation for all requests.
    We might be required to add a few fields to all the responses at a later stage,
    after we have already defined all the actions needed for our application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，我们需要对所有请求执行相同的操作。我们可能在定义了所有应用程序所需的动作之后，在稍后阶段需要向所有响应中添加一些字段。
- en: So, in this case, will we have to update all the Actions?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在这种情况下，我们是否需要更新所有的动作？
- en: No. This is where the filter API comes to our rescue. We don't need to modify
    how we define our Actions to solve the problem. All we need to do is define a
    filter and use it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这就是过滤器 API 来拯救我们的地方。我们不需要修改定义我们的动作的方式来解决该问题。我们只需要定义一个过滤器并使用它。
- en: 'Let''s see how we can define our filter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何定义我们的过滤器：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `HeadersFilter.noCache` filter adds all the headers to a response, which
    are required to disable caching in browsers. `PRAGMA`, `CACHE_CONTROL`, and `EXPIRES`
    are constants provided by `play.api.http.HeaderNames`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeadersFilter.noCache` 过滤器将所有需要禁用浏览器缓存的头信息添加到响应中。`PRAGMA`、`CACHE_CONTROL`
    和 `EXPIRES` 是由 `play.api.http.HeaderNames` 提供的常量。'
- en: Now, to use this filter, we would need to update the global settings for the
    application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用这个过滤器，我们需要更新应用程序的全局设置。
- en: The global settings for any Play-based application can be configured using a
    global object. This is an object that's defined with the name `Global` and is
    placed in the app directory. We will find out more about global settings in [Chapter
    7](ch07.html "Chapter 7. Playing with Globals"), *Playing with Globals*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 任何基于 Play 的应用程序的全局设置都可以使用一个全局对象进行配置。这是一个名为 `Global` 的对象，位于应用程序目录中。我们将在 [第 7
    章](ch07.html "第 7 章。玩转全局设置") *玩转全局设置* 中了解更多关于全局设置的信息。
- en: 'There are two ways of defining how the filter should be used. These are:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 定义过滤器应该如何使用有两种方式。这些是：
- en: Extending the `WithFilters` class instead of `GlobalSettings` for the global
    object.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为全局对象扩展 `WithFilters` 类而不是 `GlobalSettings`。
- en: Invoking the filter manually in the global object.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局对象中手动调用过滤器。
- en: 'An example of using `WithFilters` is:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `WithFilters` 的一个例子是：
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s see how this can be done manually:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何手动完成这个操作：
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In Play, a filter is defined similar to Action—there is a filter trait, which
    extends `EssentialFilter` and a helper filter object. The helper filter is defined
    as:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Play 中，过滤器定义的方式类似于动作——有一个过滤器特质，它扩展了 `EssentialFilter`，还有一个辅助过滤器对象。辅助过滤器定义如下：
- en: '[PRE45]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this code snippet, the `apply` method calls a new filter, which is the filter
    trait.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`apply` 方法调用一个新的过滤器，即过滤器特质。
- en: 'Multiple filters can be applied for a single application. If `WithFilters`
    is used, they are applied in the specified order. If they are set manually, we
    can use the filters object used internally by the apply method of the `WithFilters`
    class. The `Filters` object is defined as follows:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以为一个单一的应用程序应用多个过滤器。如果使用 `WithFilters`，它们将按照指定的顺序应用。如果手动设置，我们可以使用 `WithFilters`
    类的 `apply` 方法的内部使用的过滤器对象。`Filters` 对象定义如下：
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`FilterChain` is another helper object used to compose `EssentialAction` from
    a combination of `EssentialAction` and multiple `EssentialFilters`:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FilterChain` 是另一个辅助对象，用于从 `EssentialAction` 和多个 `EssentialFilters` 的组合中组合
    `EssentialAction`：'
- en: '[PRE47]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Filters are recommended when some operation is to be performed indiscriminately
    for all routes. Play provides a filter module, which has a `GzipFilter`, `SecurityHeadersFilter`,
    and `CSRFFilter`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当需要对所有路由进行无差别操作时，推荐使用过滤器。Play 提供了一个过滤器模块，其中包括 `GzipFilter`、`SecurityHeadersFilter`
    和 `CSRFFilter`。
- en: Action composition
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作组合
- en: 'Defining an Action for a request is merely the act of using the Action helper
    object, which is defined as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个请求的动作仅仅是使用定义如下所示的动作辅助对象的行为：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The code which we write within an action block goes on to be the `invokeBlock`
    method. This method is inherited from `ActionBuilder`. This is a trait that provides
    helper methods to generate an Action. All the different ways in which we define
    an Action, such as async, synchronous, with or without specifying a parser, and
    so on are declared in `ActionBuilder`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作块中编写的代码将用于 `invokeBlock` 方法。该方法是从 `ActionBuilder` 继承的。这是一个提供生成动作的辅助方法的特质。我们定义动作的所有不同方式，如异步、同步、指定或不指定解析器等，都在
    `ActionBuilder` 中声明。
- en: We can also define our custom Actions by extending `ActionBuilder` and defining
    a custom invoke block.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过扩展 `ActionBuilder` 并定义一个自定义的 `invoke` 块来定义我们自己的动作。
- en: The need for an Action composition
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作组合的需要
- en: Let's take a case study. A lot of applications these days keep track of requests,
    such as the IP address of the machine it was instigated from, the time it was
    received, or even the whole request as is. It would be a crime to add the same
    code in almost every Action defined for such an application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, assume that we need to persist a request using a `persistReq` method every
    time it is encountered for a specific module: the administrator user, for example.
    Then, in this case, we could define a custom Action to be used only within this
    module. Let''s see how we can define a custom Action to persist a request before
    processing it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Within our application, we could use it similar to the default Action:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Another way to define a custom Action is by extending the Action trait. So,
    we can also define `TrackAction` as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Its usage would be something similar to this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice that we need to wrap the Action definition again within the action object.
    We could remove this additional overhead of wrapping an action object every time
    by defining `ActionBuilder`, which uses the `composeAction` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, the usage will be:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Differentiating between Action composition and filters
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Action composition** is an Action that extends `EssentialAction` and returns
    a result. It is more suitable when we need to perform an operation on a few routes
    or Actions only. Action composition is more powerful than a filter and is more
    apt at handling specific concerns, such as authentication.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: It provides support to read, modify, and even block a request. There is also
    a provision to define Actions for custom request types.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Customized requests
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s see how to define custom requests. We can also define custom
    requests using the `WrappedRequest` class. This is defined as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Suppose we wish to pass the time at which a request was received with every
    request, we could define this as:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s see how we can manipulate the incoming requests and transform them
    into `TimedRequest`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Therefore, the `timedAction` Action can be used within controllers in this
    way:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, suppose we wish to block all the requests from certain browsers; it can
    be done in this way:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the `isCompatibleBrowser` method checks if the browser is supported.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also manipulate the response; let''s add the duration it took to process
    the request in the response headers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, let's see how we define an Action for a custom request. You may wonder
    why we need a custom request. Take the example where our application has a facility
    for the users to use e-mail, chat, block, upload, share, and so on. In this case,
    we could tie these so that we can have a user object as part of the request internally.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The need for a user object
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our REST API only sends `userId`, which is a number. For all these operations,
    we need the user''s `emailId`, `userName`, and profile picture, if any. Let''s
    define `UserRequest` inthe following way:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s define an Action, which uses this request:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: So, in our Action, we find the user corresponding to the given `userId`, else
    we redirect to the login page.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see how to use `UserAction`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The chat client initiates a method and sends a message to the user with `userId.chatWith`
    that a user, whose profile is `request.user`, wants to chat. It returns `true`
    if the other user agrees, else it returns `false`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the scenarios you might come across where you may need to troubleshoot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming across an error during compilation: you cannot find any HTTP request
    header here.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You get this error even after you have defined the Action using a `RequestHeader`.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most of the methods used in Play that deal with requests, expect an implicit
    `RequestHeader`. This convention has been followed in order to keep the code simple.
    For example, let''s look at the controller trait here:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Notice that the `session`, `flash`, and `lang` methods accept an implicit parameter,
    such as a request, which is `RequestHeader`. It is in such cases that we need
    to mark the request header in our Action definition as implicit. Generally, it''s
    safer to mark all the request headers as implicit in a Play application. So, to
    fix this error, we would need to modify our `Action` definition as follows:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The request body for my GET request is not parsed. You may wonder why. The GET
    request is not expected to have a request body. Though the HTTP specification
    is not clear on this, in general practice, browsers do not forward the request
    body. Play body parser checks to see if the request is allowed to have a request
    body, that is, if the request is not a GET request, before parsing it.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is better to avoid a request body in your GET and DELETE requests. If you
    need to add a request body to these requests, maybe you should redesign the REST
    API for your application.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You''re not able to use the Play filters: `GzipFilter`, `SecurityHeadersFilter`,
    or `CSRFFilter`. You get an error: the object `filters` is not a member of package
    play, in line import `play.filters`.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filters is a separate module and needs to be included explicitly. You should
    add it the `build.sbt` file as the `libraryDependencies += filters`, and then
    reload the project.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Coming across a compilation error when using Future: if you cannot find an
    implicit `ExecutionContext`, either require one for yourself or import `ExecutionContext.Implicits.global`.
    Why should this be done, though?'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Future requires an `ExecutionContext`, which defines the thread pool where threads
    will be allotted for an operation. Hence, you might get a compilation error when
    no `ExecutionContext` is available for Future. Refer to the *Scala docs Futures
    (* [http://docs.scala-lang.org/overviews/core/futures.html](http://docs.scala-lang.org/overviews/core/futures.html)
    *)* section for more on this.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Coming across a runtime error while using the JSON parser: `JsResultException`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This generally happens when the field being extracted from JSON is not present
    in the request body. This could be because there is a typo, for example, instead
    of `emailId`, and you might be sending an e-mail. You could use the `asOpt` method
    instead of `as`. For example:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通常发生在从 JSON 中提取的字段不在请求体中时。这可能是由于存在拼写错误，例如，应该是 `emailId`，而你可能发送的是电子邮件。你可以使用
    `asOpt` 方法代替 `as`。例如：
- en: '[PRE67]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Then you could throw an error with a human-friendly message if that or any field
    is missing. Alternatively, you could pass default values using `getOrElse`.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，如果你或任何字段缺失，你可以抛出一个带有友好信息的错误。或者，你可以使用 `getOrElse` 方法传递默认值。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to define and extend the key components of a controller.
    We saw how to define an application-specific Action with default parsers and results,
    as well as with custom parsers and results. In addition to this, we also saw how
    to manage application-specific concerns using filters and `ActionComposition`.
    In the process, we saw how to define a custom request.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何定义和扩展控制器的主要组件。我们看到了如何定义一个具有默认解析器和结果的特定应用程序的动作，以及具有自定义解析器和结果的动作。此外，我们还看到了如何使用过滤器和
    `ActionComposition` 来管理特定应用程序的关注点。在这个过程中，我们看到了如何定义一个自定义请求。
