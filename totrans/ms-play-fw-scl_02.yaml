- en: Chapter 2. Defining Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're reading this, you've either survived the first chapter or skipped
    it. Either way, I am assuming you know the structure of a simple Play application.
    A controller in Play generates Action values and, to do so, it uses several objects
    and methods internally. In this chapter, we will see what goes on behind the scenes
    and how we can leverage these actions when we build our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request body parsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action composition and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dummy Artist model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following sections, we will give make reference to an `artist` model.
    It is a simple `class` with a companion `object`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Artist model has a method to fetch all these artists and a few methods to
    filter the artist, based on different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real applications, the model interacts with the database but to keep things
    simple, we have hardcoded the data as `Seq[Artist]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a view of `home.scala.html`, which displays information about
    the artist in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a twirl, template which requires a `Seq[Artist]`. It is similar to the
    view of the TaskTracker application we built in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **Action** in Play defines how a server should respond to a request. The
    methods, which define an Action, are mapped to a request in the `routes` file.
    For example, let''s define an Action which displays the information of all the
    artists as a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, to use this Action, we should map it to a request in the `routes` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we fetch all the artists and send them with the view, as the
    response to the request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term `api` used in the `route` file is just a URL prefix and is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application and access `http://localhost:9000/api/artist` from the browser.
    A table with the available artist is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action takes a request and yields a result. It is an implementation of the
    `EssentialAction` trait. It is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Iteratee** is a concept borrowed from functional languages. It is used to
    process chunks of data in an incremental manner. We will dig deeper into it in
    [Chapter 6](ch06.html "Chapter 6. Reactive Data Streams"), *Reactive Data Streams*.'
  prefs: []
  type: TYPE_NORMAL
- en: The apply method accepts a function, which transforms a request into a result.
    The `RequestHeader` and other chunks of data represent the request. In short,
    the `apply` method takes in a request and returns a result.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some of the ways in which an action can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Actions with parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might come across a situation where we need to define an Action, which takes
    a value from the request path. In this case, we will need to add the parameters
    required for the method signature and pass them in the routes file. An example
    of this would be the method to fetch artists by their selected names. In the controller,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapping for this in the `routes` file will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If it''s not specified explicitly, keep in mind that the type of parameter
    in the path is set to `String` by default. The type can be specified in the method
    call. So, the route defined is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we could add more parameters if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take the use case of a search query. We want the action to accept query
    parameters, such as name and country. The action is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If there are no artists matching the criteria, the response is empty, and shows
    a status code 204 (no content). If it doesn't, the response status is `200 = (Ok)`,
    and shows the result as the response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry corresponding to this Action in the routes file will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We do not use any parameters in the path, but query parameters whose labels
    correspond to the method's parameter names in the `routes` file should be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will result in a valid URL: `http://localhost:9000/api/search/artist?name=Franz&country=Austria`'
  prefs: []
  type: TYPE_NORMAL
- en: What if we decided to make `country` an optional parameter?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the route to accommodate this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to make queries by the name as well, so, both the URLs will
    now look like this: `http://localhost:9000/api/search/artist?name=Franz` and `http://localhost:9000/api/search/artist?name=Franz&country=Austria`
    are now supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we made the `country` parameter optional by setting a default value for
    it in the route definition. Alternatively, we could define an Action to accept
    a parameter of the `Option` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the route will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make requests with or without passing the name of the country:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:9000/api/search2/artist?country=Austria`'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:9000/api/search2/artist?name=Franz&country=Austria`'
  prefs: []
  type: TYPE_NORMAL
- en: In the examples shown in this section, we didn't need to use the request to
    generate our result but in some cases, we would use the request to generate a
    relevant result. However, to do this, understanding the format of the request
    content is crucial. We'll see how this is done in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Request body parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the most common POST request in any application—the request sent for
    logins. Will it be sufficient if the request body has the user's credentials in,
    say, a JSON or XML format? Will the request handler be able to extract this data
    and process it directly? No, since the data in the request has to be understood
    by the application code, it must be translated into a compatible type. For example,
    XML sent in a request must be translated to Scala XML for a Scala application.
  prefs: []
  type: TYPE_NORMAL
- en: There are several libraries, such as Jackson, XStream, and so on, which can
    be used to achieve this task, but we wouldn't need them as Play supports this
    internally. Play provides request body parsers to transform the request body into
    equivalent Scala objects for some of the frequently used content types. In addition
    to this, we can extend existing parsers or define new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Action has a parser. How do I know this ? Well, the Action object, which
    we used to define how our app should respond, is simply an extension of the Action
    trait, and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `apply` method transforms the value returned by the parser. The value from
    the parser can either be a result or the request body (denoted as `Either[Result,A]`).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the transformation is defined for both possible outcomes. If we pattern-match
    this, we get `Left(r)`, which is a result type and `Right(a)`, which is the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: The `mapM` method functions similarly to the `map` method, the only difference
    being, it does so asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: However, can Actions be defined even without a parser? Yes and no.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example Action: a POST request, which is required to subscribe
    to updates. This request takes the user''s e-mail ID as a query parameter, which
    means that we will need to access the request body in order to complete the subscription
    for this user. First, we''ll check what the request body looks like when we do
    not specify a parser. Create an Action `subscribe` in a controller, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add an entry for this in the routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After this, run the application. Send a POST request at `http://localhost:9000/subscribe`
    with the `userId@gmail.com` e-mail ID using a REST client or Curl (whichever you
    are more comfortable with).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for this request will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice that our `subscribe` method understood that the content was text?
    The request body was translated as `AnyContentAsText(userId@gmail.com)`. How did
    our method determine this? Isn't this the job of a parser mapped to a particular
    Action?
  prefs: []
  type: TYPE_NORMAL
- en: 'When a parser is not specified for an Action, the parser returned by the `BodyParsers.parse.anyContent`
    method is set as the parser for this Action. This is handled by the `ActionBuilder`,
    which we will see later in this chapter. The following code snippet shows one
    of the methods to generate an Action when no parser is given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s examine what the `BodyParsers.parse.anyContent` method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First of all, it checks whether the request type supports sending data along
    with the request. If not, it returns `AnyContentAsEmpty` (you can check this by
    changing the request type to GET in the routes file and sending a GET request),
    else it compares the content type Header of the request with the supported types.
    If a match is found, it transforms the data into the corresponding type and returns
    that, or else it parses it as bytes and returns `play.api.mvc.RawBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AnyContentAsEmpty`, `AnyContentAsText`, `AnyContentAsXml`, `AnyContentAsJson`,
    `AnyContentAsFormUrlEncoded`, `AnyContentAsMultipartFormData`, and `AnyContentAsRaw`
    all extend the trait `AnyContent`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when an Action is defined for one of the supported content types or when
    it's a GET/HEAD request, we need not mention the parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can access the request body in our Action. We can now updating
    our `subscrib` `e` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access the data in the request body, we need to convert it from
    `AnyContent` to `Option[String]` using the `asText` method. This would become
    more concise if we added the parser in the Action definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `urlFormEncoded` text XML parsers return standard Scala objects while the
    others return Play objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assume that the subscription request takes a JSON in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to modify our `subscribe` method to `def subscribe = Action(parse.json)
    {`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Added `userId@gmail.com` to the subscriber's list and will send updates every
    month
  prefs: []
  type: TYPE_NORMAL
- en: The `parse.json` transforms the request body to `play.api.libs.json.JsValue`.
    The `\` operator is used to access the value of a particular key. Similarly, there
    is a `\\` operator, which can be for the value of a key, though it may not be
    a direct child of the current node. Play-Json has several methods that simplify
    the handling of data in a JSON format, such as modifying the structure, or converting
    it to Scala models, and so on. Play-Json is also available as a stand-alone library
    to enable its usage in non-Play projects. Its documentation is available at [https://www.playframework.com/documentation/2.3.x/ScalaJson](https://www.playframework.com/documentation/2.3.x/ScalaJson).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to write an Action to add a new user, which takes a request
    of content-type multipart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The request has three fields: `email`, `name`, and `displayPic`. From the request
    data, we fetch the e-mail of, name, and add a new user. The `User.` `save` method
    adds an entry in the user table and throws an error if a user with the same e-mail
    ID exists. This is why the operations in the file are performed only after adding
    a user. The `displayPic` is optional; therefore, the check for its length to be
    greater than zero is made prior to saving the image.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is better to complete the data transactions before the file-related ones,
    since they may fail and file-related operations might not be required for the
    incorrect request. The following table shows the supported content-types, parsers,
    and their default conversions.
  prefs: []
  type: TYPE_NORMAL
- en: '| Content type | Parser | Parsed to Scala type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text/plain` | `text` | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `application/json` or `text/json` | `json` | `play.api.libs.json.JsValue`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `application/xml`, `text/xml`, or `application/XXX+xml` | `xml` | `NodeSeq`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `application/form-url-encoded` | `urlFormEncoded` | `Map[String, Seq[String]]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `multipart/form-data` | `multipartFormData` | `play.api.mvc.MultipartFormData[TemporaryFile]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `other` | `raw` | `Play.api.mvc.RawBuffer` |'
  prefs: []
  type: TYPE_TB
- en: Extending a parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s extend the JSON parser so that we get a subscription model. We will
    assume that the `Subscription` model is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a parser that transforms the request body into a subscription
    object. The following code should be written in a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also tolerant parsers. By tolerant, we mean that errors in a format
    are not ignored. This simply means that it ignores the content type header in
    the request and parses based on the type specified. For example, let''s update
    the `subscribe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, a request with the content type as text and a request where the content
    type text/JSON, or any other type for that matter, will give the same result.
    There are tolerant parsers for all the basic parsers supported in Play.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Play, the response to a request is a **result**. A result has two components:
    the response header and the response body. Let''s look at a simple example of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used an enumerator for the response body. An enumerator is a
    means to provide data to an iteratee. We will discuss these in detail in [Chapter
    6](ch06.html "Chapter 6. Reactive Data Streams"), *Reactive Data Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, a result has additional functions that equips us with better
    means to handle response headers, sessions, cookies, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A result can send JSON, XML, and images as a response, apart from a String
    content. An easier way of generating a result is to use the result helpers. A
    result helper is used for most of the HTTP response status. As an example, let''s
    see how the `TODO` Action that comes built in with Play is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `NotImplemented` is a helper, which returns a result with a
    status of 501 and `views.html.defaultpages.todo()` returns the default page, which
    is `todo.scala.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll consider the Action that sends the user''s profile image
    inline. The Action would now be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we attempt to load the user's profile image using the predefined `getUserImagePath`
    method. If the image file exists and attaches itself to the response, we return
    a response with the `204` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also saw how a result helper can be used to send the page content, both
    static and dynamic, using views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also use the `Status` class to generate the result, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This table shows you the result helpers and their corresponding status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Result helper | Status code constants | Status code |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| – | `CONTINUE` | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `SWITCHING_PROTOCOLS` | 101 |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | `OK` | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| `Created` | `CREATED` | 201 |'
  prefs: []
  type: TYPE_TB
- en: '| `Accepted` | `ACCEPTED` | 202 |'
  prefs: []
  type: TYPE_TB
- en: '| `NonAuthoritativeInformation` | `NON_AUTHORITATIVE_INFORMATION` | 203 |'
  prefs: []
  type: TYPE_TB
- en: '| `NoContent` | `NO_CONTENT` | 204 |'
  prefs: []
  type: TYPE_TB
- en: '| `ResetContent` | `RESET_CONTENT` | 205 |'
  prefs: []
  type: TYPE_TB
- en: '| `PartialContent` | `PARTIAL_CONTENT` | 206 |'
  prefs: []
  type: TYPE_TB
- en: '| `MultiStatus` | `MULTI_STATUS` | 207 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `MULTIPLE_CHOICES` | 300 |'
  prefs: []
  type: TYPE_TB
- en: '| `MovedPermanently` | `MOVED_PERMANENTLY` | 301 |'
  prefs: []
  type: TYPE_TB
- en: '| `Found` | `FOUND` | 302 |'
  prefs: []
  type: TYPE_TB
- en: '| `SeeOther` | `SEE_OTHER` | 303 |'
  prefs: []
  type: TYPE_TB
- en: '| `NotModified` | `NOT_MODIFIED` | 304 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `USE_PROXY` | 305 |'
  prefs: []
  type: TYPE_TB
- en: '| `TemporaryRedirect` | `TEMPORARY_REDIRECT` | 307 |'
  prefs: []
  type: TYPE_TB
- en: '| `BadRequest` | `BAD_REQUEST` | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| `Unauthorized` | `UNAUTHORIZED` | 401 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `PAYMENT_REQUIRED` | 402 |'
  prefs: []
  type: TYPE_TB
- en: '| `Forbidden` | `FORBIDDEN` | 403 |'
  prefs: []
  type: TYPE_TB
- en: '| `NotFound` | `NOT_FOUND` | 404 |'
  prefs: []
  type: TYPE_TB
- en: '| `MethodNotAllowed` | `METHOD_NOT_ALLOWED` | 405 |'
  prefs: []
  type: TYPE_TB
- en: '| `NotAcceptable` | `NOT_ACCEPTABLE` | 406 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `PROXY_AUTHENTICATION_REQUIRED` | 407 |'
  prefs: []
  type: TYPE_TB
- en: '| `RequestTimeout` | `REQUEST_TIMEOUT` | 408 |'
  prefs: []
  type: TYPE_TB
- en: '| `Conflict` | `CONFLICT` | 409 |'
  prefs: []
  type: TYPE_TB
- en: '| `Gone` | `GONE` | 410 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `LENGTH_REQUIRED` | 411 |'
  prefs: []
  type: TYPE_TB
- en: '| `PreconditionFailed` | `PRECONDITION_FAILED` | 412 |'
  prefs: []
  type: TYPE_TB
- en: '| `EntityTooLarge` | `REQUEST_ENTITY_TOO_LARGE` | 413 |'
  prefs: []
  type: TYPE_TB
- en: '| `UriTooLong` | `REQUEST_URI_TOO_LONG` | 414 |'
  prefs: []
  type: TYPE_TB
- en: '| `UnsupportedMediaType` | `UNSUPPORTED_MEDIA_TYPE` | 415 |'
  prefs: []
  type: TYPE_TB
- en: '| – | `REQUESTED_RANGE_NOT_SATISFIABLE` | 416 |'
  prefs: []
  type: TYPE_TB
- en: '| `ExpectationFailed` | `EXPECTATION_FAILED` | 417 |'
  prefs: []
  type: TYPE_TB
- en: '| `UnprocessableEntity` | `UNPROCESSABLE_ENTITY` | 422 |'
  prefs: []
  type: TYPE_TB
- en: '| `Locked` | `LOCKED` | 423 |'
  prefs: []
  type: TYPE_TB
- en: '| `FailedDependency` | `FAILED_DEPENDENCY` | 424 |'
  prefs: []
  type: TYPE_TB
- en: '| `TooManyRequest` | `TOO_MANY_REQUEST` | 429 |'
  prefs: []
  type: TYPE_TB
- en: '| `InternalServerError` | `INTERNAL_SERVER_ERROR` | 500 |'
  prefs: []
  type: TYPE_TB
- en: '| `NotImplemented` | `NOT_IMPLEMENTED` | 501 |'
  prefs: []
  type: TYPE_TB
- en: '| `BadGateway` | `BAD_GATEWAY` | 502 |'
  prefs: []
  type: TYPE_TB
- en: '| `ServiceUnavailable` | `SERVICE_UNAVAILABLE` | 503 |'
  prefs: []
  type: TYPE_TB
- en: '| `GatewayTimeout` | `GATEWAY_TIMEOUT` | 504 |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpVersionNotSupported` | `HTTP_VERSION_NOT_SUPPORTED` | 505 |'
  prefs: []
  type: TYPE_TB
- en: '| `InsufficientStorage` | `INSUFFICIENT_STORAGE` | 507 |'
  prefs: []
  type: TYPE_TB
- en: Asynchronous Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that we are at a food court and place an order to eat something at a
    kiosk, we are given a token and a bill. Later, when the order is ready, the kiosk
    flashes the token number, and upon noticing it, we collect the order.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to a request with an asynchronous response cycle, where the
    kiosk acts like the server, the order acts similar to a request, and the token
    as a promise, which gets resolved when the order is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Most operations are better handled asynchronously. This is also mostly preferred
    since it does not block server resources until the operation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play Action is a helper object, which extends the `ActionBuilder` trait. The
    apply method of the `ActionBuilder` trait implements the `Action` trait, which
    we saw earlier. Let''s take a look at the relevant code from the `ActionBuilder`
    trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `apply` method itself calls the `async` method internally. The
    `async` method expects us to define the Action, which results in `Future[Result]`,
    thereby aiding us to write non-blocking code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the same method to define an asynchronous Action. Assume that we
    need to fetch the requested file from a remote client, consolidate/analyze the
    data, and then send the results. Since we do not know the size of the file and
    the status of network connectivity with a remote client, it is better to handle
    the Action asynchronously. The action will be defined in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After fetching the file, if it is empty, we send a response with a status code
    of 204, else we continue with the processing and send the processed data as a
    part of the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may come across an instance, as we saw in the previous example, get report,
    that we do not wish to wait longer than 10 seconds for the remote client to fetch
    the file. In this case, we''ll need to modify the Action definition in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, if the remote client doesn't respond with the requested file in 10 seconds,
    we will get a response with status code 500 and the content as the message we
    set for the timeout, `Past max time`.
  prefs: []
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Content negotiation is the process of selecting the best representation for
    a given response when there are multiple representations available.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can either be server-driven or agent-driven or a combination of both, which
    is called transparent negotiation. Play provides support for server-driven negotiations.
    This is handled by the rendering trait and is extended by the controller trait.
    The controller trait is the one where the controller objects in a Play app extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `Rendering` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `_render` method defined in the `apply` method calls the partial `f` function
    on the accept headers in the request. If `f` is not defined for the any of the
    accept headers, a response with status code 406 is forwarded. If it's not, the
    result of `f` for the first accept header for which `f` is defined, is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the controller extends the rendering trait, we can use the render object
    within our Action definition. For example, we might have an Action, which gets
    the configuration in JSON and XML after reading it from a file with an XML format,
    depending on the accept headers in the request. Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, `Accepts.Xml()` and `Accepts.Json()` are Play''s helper methods
    that check to see if the request accepts the response of the `application/xml`
    and `applicat` `ion/json` types, respectively. There are currently four predefined
    accepts and these are tabulated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Request accept helper | Accept header value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| XML | `application/xml` |'
  prefs: []
  type: TYPE_TB
- en: '| JSON | `application/json` |'
  prefs: []
  type: TYPE_TB
- en: '| HTML | `text/html` |'
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | `text/javascript` |'
  prefs: []
  type: TYPE_TB
- en: 'This is facilitated by the `RequestExtractors` trait and the `AcceptExtractors`
    trait. `RequestExtractors` is also extended by the controller trait. Let''s look
    at the extractor traits here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From this code, all that we need to define a custom accepts is the value we
    would expect the request''s accept header to have. For example, to define a helper
    for `image/png`, we use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We also notice that `RequestExtractors` has an `&` object, and we can use this
    when we wish to send the same response to multiple accept types. So, in the `getConfig`
    method shown in the preceding code, if the same response response is sent for
    `application/json` and `text/javascript`, we will modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `render` object can be used similarly when defining an asynchronous Action.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most applications, we need to perform the same operation for all requests.
    We might be required to add a few fields to all the responses at a later stage,
    after we have already defined all the actions needed for our application.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this case, will we have to update all the Actions?
  prefs: []
  type: TYPE_NORMAL
- en: No. This is where the filter API comes to our rescue. We don't need to modify
    how we define our Actions to solve the problem. All we need to do is define a
    filter and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can define our filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `HeadersFilter.noCache` filter adds all the headers to a response, which
    are required to disable caching in browsers. `PRAGMA`, `CACHE_CONTROL`, and `EXPIRES`
    are constants provided by `play.api.http.HeaderNames`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to use this filter, we would need to update the global settings for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The global settings for any Play-based application can be configured using a
    global object. This is an object that's defined with the name `Global` and is
    placed in the app directory. We will find out more about global settings in [Chapter
    7](ch07.html "Chapter 7. Playing with Globals"), *Playing with Globals*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of defining how the filter should be used. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `WithFilters` class instead of `GlobalSettings` for the global
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoking the filter manually in the global object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example of using `WithFilters` is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s see how this can be done manually:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Play, a filter is defined similar to Action—there is a filter trait, which
    extends `EssentialFilter` and a helper filter object. The helper filter is defined
    as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, the `apply` method calls a new filter, which is the filter
    trait.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Multiple filters can be applied for a single application. If `WithFilters`
    is used, they are applied in the specified order. If they are set manually, we
    can use the filters object used internally by the apply method of the `WithFilters`
    class. The `Filters` object is defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FilterChain` is another helper object used to compose `EssentialAction` from
    a combination of `EssentialAction` and multiple `EssentialFilters`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Filters are recommended when some operation is to be performed indiscriminately
    for all routes. Play provides a filter module, which has a `GzipFilter`, `SecurityHeadersFilter`,
    and `CSRFFilter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Action composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining an Action for a request is merely the act of using the Action helper
    object, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code which we write within an action block goes on to be the `invokeBlock`
    method. This method is inherited from `ActionBuilder`. This is a trait that provides
    helper methods to generate an Action. All the different ways in which we define
    an Action, such as async, synchronous, with or without specifying a parser, and
    so on are declared in `ActionBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also define our custom Actions by extending `ActionBuilder` and defining
    a custom invoke block.
  prefs: []
  type: TYPE_NORMAL
- en: The need for an Action composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a case study. A lot of applications these days keep track of requests,
    such as the IP address of the machine it was instigated from, the time it was
    received, or even the whole request as is. It would be a crime to add the same
    code in almost every Action defined for such an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, assume that we need to persist a request using a `persistReq` method every
    time it is encountered for a specific module: the administrator user, for example.
    Then, in this case, we could define a custom Action to be used only within this
    module. Let''s see how we can define a custom Action to persist a request before
    processing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our application, we could use it similar to the default Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to define a custom Action is by extending the Action trait. So,
    we can also define `TrackAction` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Its usage would be something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we need to wrap the Action definition again within the action object.
    We could remove this additional overhead of wrapping an action object every time
    by defining `ActionBuilder`, which uses the `composeAction` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the usage will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Differentiating between Action composition and filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Action composition** is an Action that extends `EssentialAction` and returns
    a result. It is more suitable when we need to perform an operation on a few routes
    or Actions only. Action composition is more powerful than a filter and is more
    apt at handling specific concerns, such as authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: It provides support to read, modify, and even block a request. There is also
    a provision to define Actions for custom request types.
  prefs: []
  type: TYPE_NORMAL
- en: Customized requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s see how to define custom requests. We can also define custom
    requests using the `WrappedRequest` class. This is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wish to pass the time at which a request was received with every
    request, we could define this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how we can manipulate the incoming requests and transform them
    into `TimedRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the `timedAction` Action can be used within controllers in this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we wish to block all the requests from certain browsers; it can
    be done in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `isCompatibleBrowser` method checks if the browser is supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also manipulate the response; let''s add the duration it took to process
    the request in the response headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how we define an Action for a custom request. You may wonder
    why we need a custom request. Take the example where our application has a facility
    for the users to use e-mail, chat, block, upload, share, and so on. In this case,
    we could tie these so that we can have a user object as part of the request internally.
  prefs: []
  type: TYPE_NORMAL
- en: The need for a user object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our REST API only sends `userId`, which is a number. For all these operations,
    we need the user''s `emailId`, `userName`, and profile picture, if any. Let''s
    define `UserRequest` inthe following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define an Action, which uses this request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: So, in our Action, we find the user corresponding to the given `userId`, else
    we redirect to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see how to use `UserAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The chat client initiates a method and sends a message to the user with `userId.chatWith`
    that a user, whose profile is `request.user`, wants to chat. It returns `true`
    if the other user agrees, else it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the scenarios you might come across where you may need to troubleshoot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming across an error during compilation: you cannot find any HTTP request
    header here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You get this error even after you have defined the Action using a `RequestHeader`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most of the methods used in Play that deal with requests, expect an implicit
    `RequestHeader`. This convention has been followed in order to keep the code simple.
    For example, let''s look at the controller trait here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the `session`, `flash`, and `lang` methods accept an implicit parameter,
    such as a request, which is `RequestHeader`. It is in such cases that we need
    to mark the request header in our Action definition as implicit. Generally, it''s
    safer to mark all the request headers as implicit in a Play application. So, to
    fix this error, we would need to modify our `Action` definition as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The request body for my GET request is not parsed. You may wonder why. The GET
    request is not expected to have a request body. Though the HTTP specification
    is not clear on this, in general practice, browsers do not forward the request
    body. Play body parser checks to see if the request is allowed to have a request
    body, that is, if the request is not a GET request, before parsing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is better to avoid a request body in your GET and DELETE requests. If you
    need to add a request body to these requests, maybe you should redesign the REST
    API for your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You''re not able to use the Play filters: `GzipFilter`, `SecurityHeadersFilter`,
    or `CSRFFilter`. You get an error: the object `filters` is not a member of package
    play, in line import `play.filters`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filters is a separate module and needs to be included explicitly. You should
    add it the `build.sbt` file as the `libraryDependencies += filters`, and then
    reload the project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Coming across a compilation error when using Future: if you cannot find an
    implicit `ExecutionContext`, either require one for yourself or import `ExecutionContext.Implicits.global`.
    Why should this be done, though?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Future requires an `ExecutionContext`, which defines the thread pool where threads
    will be allotted for an operation. Hence, you might get a compilation error when
    no `ExecutionContext` is available for Future. Refer to the *Scala docs Futures
    (* [http://docs.scala-lang.org/overviews/core/futures.html](http://docs.scala-lang.org/overviews/core/futures.html)
    *)* section for more on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Coming across a runtime error while using the JSON parser: `JsResultException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This generally happens when the field being extracted from JSON is not present
    in the request body. This could be because there is a typo, for example, instead
    of `emailId`, and you might be sending an e-mail. You could use the `asOpt` method
    instead of `as`. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then you could throw an error with a human-friendly message if that or any field
    is missing. Alternatively, you could pass default values using `getOrElse`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to define and extend the key components of a controller.
    We saw how to define an application-specific Action with default parsers and results,
    as well as with custom parsers and results. In addition to this, we also saw how
    to manage application-specific concerns using filters and `ActionComposition`.
    In the process, we saw how to define a custom request.
  prefs: []
  type: TYPE_NORMAL
