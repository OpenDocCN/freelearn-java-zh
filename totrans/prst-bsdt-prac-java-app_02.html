<html><head></head><body>
		<div id="_idContainer020">
			<h1 class="chapter-number" id="_idParaDest-23"><a id="_idTextAnchor027"/>2</h1>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor028"/>Exploring the Multiple Database Flavors</h1>
			<p>As a system evolves, especially within a microservices architecture, it becomes necessary to implement a polyglot persistence strategy to accommodate the individual needs of decoupled and independent services. This involves examining various options for storing data, including <strong class="bold">Database Management Systems</strong> (<strong class="bold">DBMSs</strong>) such as <a id="_idIndexMarker055"/>relational, NoSQL, and NewSQL databases. It is important to consider the application’s use case scenarios for each type of database in order to avoid overengineering the <span class="No-Break">architectural design.</span></p>
			<p>In this chapter, we will delve into the characteristics and advantages of both traditional relational databases and newer non-relational databases. We will also take a closer look at NewSQL databases and their place in <span class="No-Break">the market.</span></p>
			<p>Before delving into the application details, we’ll start by familiarizing ourselves with the multiple storage solutions that we can adopt as the persistence strategy of our solutions. The following topics will <span class="No-Break">be covered:</span></p>
			<ul>
				<li>A look back at <span class="No-Break">relational databases</span></li>
				<li>A deep dive into <span class="No-Break">non-relational databases</span></li>
				<li>NewSQL databases – trying to get the best out of <span class="No-Break">both worlds</span><a id="_idTextAnchor029"/></li>
			</ul>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor030"/>A look back at relational databases</h1>
			<p>Relational databases <a id="_idIndexMarker056"/>have been a trusted solution for data storage for over 50 years, with widespread adoption amongst worldwide corporations. One <a id="_idIndexMarker057"/>of the best advantages users gain from <a id="_idIndexMarker058"/>using relational databases is being able to use <strong class="bold">Structured Query </strong><span class="No-Break"><strong class="bold">Language</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SQL</strong></span><span class="No-Break">).</span></p>
			<p>The fact that SQL is a standard query language supported by multiple vendors means SQL code is portable, and the same SQL code works with little or no modification on many database systems. This is a way of assuring vendor lock-in. Other than that, SQL also helps to reduce the cognitive load of having to learn a new language or API, such as Java’s JDBC <span class="No-Break">or JPA.</span></p>
			<p>Now, when referring to the DBMS, in addition to a large variety of tools and resources, relational databases also adhere to the <strong class="bold">ACID</strong> principles (<strong class="bold">atomicity, consistency, isolation, and durability</strong>), ensuring the reliability and integrity of data transactions. These features make relational databases a reliable choice for a large number of <a id="_idIndexMarker059"/>use cases. Relational databases have shown extreme maturity, bringing several success cases that cover, beyond the basics, other capabilities such as providing tools for backup, data visualization, and more. It is a fact that when someone who is used to working with SQL databases switches the focus and starts working with NoSQL storage solutions, they do miss all the side-tooling and thousands of instruments available to support them in their <span class="No-Break">daily tasks.</span></p>
			<p>In Java, we have JDBC, <a id="_idIndexMarker060"/>and a language we can learn once and write/apply anywhere. The relational database engine is transparent; thus, JDBC and JPA will be <span class="No-Break">the same.</span></p>
			<p>The essential characteristics of these persistence technologies are the properties associated with data transactions: <strong class="bold">atomicity, consistency, isolation, and durability</strong> (<strong class="bold">ACID</strong>). Transactions that comply with ACID properties have the <span class="No-Break">following aspects:</span></p>
			<ul>
				<li><strong class="bold">Atomicity</strong>: A transaction is an atomic unit. Either all database operations occur as a unit, or <a id="_idIndexMarker061"/>nothing occurs; it is an ‘all or nothing’ operation. This results in the prevention of partial data updates and potential <span class="No-Break">data inconsistency.</span></li>
				<li><strong class="bold">Consistency</strong>: The <a id="_idIndexMarker062"/>database should be in a consistent state when a transaction <em class="italic">begins</em> and <em class="italic">ends</em>. The transaction should follow every database constraint and rule in order to be <span class="No-Break">adequately consistent.</span></li>
				<li><strong class="bold">Isolation</strong>: One transaction should not adversely or unexpectedly impact another operation. For <a id="_idIndexMarker063"/>example, one table insert will generate a table row ID that is used by the second operation. However, we don’t want two operations changing the same <span class="No-Break">row simultaneously.</span></li>
				<li><strong class="bold">Durability</strong>: Upon completion of a transaction, once committed, the changes will remain <a id="_idIndexMarker064"/>permanently. This ensures data consistency even in the case of <span class="No-Break">unexpected failures.</span></li>
			</ul>
			<p>As we will learn in the upcoming chapters, Java applications have multiple different strategies to integrate with a database. There are several design patterns related to data integration that can be used to design the applications, ranging from a lower to higher decoupling from the underlying database. The reason we should worry about the capability of abstracting and having a lower effort when switching to another data storage solution is that even though relational databases are very mature, they are not suitable for <a id="_idIndexMarker065"/>every use case. Characteristics such as flexibility in data schema, scalability when handling large datasets in the face of a high number of read and write operations, performance of queries on large datasets, and handling hierarchical and other complex relationships during data modeling are examples of points that are usually stronger on NoSQL databases than on relational ones. Now, we should get a better understanding of the multiple types of NoSQL databases and <span class="No-Break">their charac<a id="_idTextAnchor031"/>teristics.</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>A deep dive into non-relational databases (NoSQL)</h1>
			<p><strong class="bold">NoSQL</strong> databases provide mechanisms for storing and retrieving unstructured data (non-relational), in<a id="_idIndexMarker066"/> stark contrast to the tabular relations used in relational databases. Compared to relational databases, NoSQL databases have better performance and high scalability. They are becoming more popular in several industries, such as finance and streaming. As a result of this increased usage, the number of users and database vendors <span class="No-Break">is growing.</span></p>
			<p>In contrast to the relational database ACID principles, in the NoSQL world, the key characteristics are <strong class="bold">BASE</strong> (<strong class="bold">basic availability, soft-state, and eventual consistency</strong>). The <a id="_idIndexMarker067"/>details of each are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Basic availability</strong>: A high <a id="_idIndexMarker068"/>degree of replication ensures data availability even if multiple <span class="No-Break">failures occur.</span></li>
				<li><strong class="bold">Soft-state</strong>: There is no requirement to have write consistency and no guarantee that the <a id="_idIndexMarker069"/>replicated data will be consistent across nodes. Unlike in traditional relational databases, changes can occur without direct <span class="No-Break">user input.</span></li>
				<li><strong class="bold">Eventual consistency</strong>: The consistency can be handled lazily when data is retrieved (read time). In <a id="_idIndexMarker070"/>other words, the data will be eventually consistent so that all nodes will have the same data but not necessarily at the <span class="No-Break">same time.</span></li>
			</ul>
			<p>There are many NoSQL database types, each of which is designed to handle a specific set of <a id="_idIndexMarker071"/>workloads and data modeling needs. In order to best define which NoSQL storage type to use, we will now delve into it, getting a clearer view of key-value, document, column-family, and graph <span class="No-Break">database types.</span></p>
			<p>After getting a broad understanding of the multiple flavors of NoSQL, you can refer to <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.5</em>, presented at the end of this section, to see how concepts can be compared between relational databases and some of the NoSQL <span class="No-Break">s<a id="_idTextAnchor033"/>torage flavors.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor034"/>NoSQL database types – key-value</h2>
			<p>These are the simplest storage types in the NoSQL world. The data is stored as a collection of key-value <a id="_idIndexMarker072"/>pairs in a way that is optimized for storing large <a id="_idIndexMarker073"/>amounts of data and efficiently handling data search by its key. This database type has a structure that resembles the <strong class="source-inline">java.util.Map</strong> API where values are mapped <span class="No-Break">to keys.</span></p>
			<p>For example, if using such a paradigm to store information about Greek mythological figures and associate them with their characteristics, the data association would be represented <span class="No-Break">as follows:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 2.1 – Key-value store database representation" src="image/B19375_02_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Key-value store database representation</p>
			<p>Three Greek mythological figures and the associations between them and their characteristics are represented in the <a id="_idIndexMarker074"/>preceding figure. In this example, the value <strong class="bold">Sun</strong> has a key <strong class="bold">Apollo</strong>, whereas the key <strong class="bold">Aphrodite</strong> can be used to refer to both <strong class="bold">Love</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Beauty</strong></span><span class="No-Break">.</span></p>
			<p>Currently on the market, some popular implementations of this approach are <strong class="bold">Amazon</strong> <strong class="bold">DynamoDB</strong>, <strong class="bold">Hazelcast</strong>, and <strong class="bold">Redis</strong> databases, the latter two being open source technologies. Each vendor brings its own unique benefits; DynamoDB can be used as a fully managed <a id="_idIndexMarker075"/>service, meaning that Amazon takes care of all infrastructure and <a id="_idIndexMarker076"/>maintenance required to run the service. Redis is an <a id="_idIndexMarker077"/>in-memory database solution that supports pub/sub messaging and caching <a id="_idIndexMarker078"/>capabilities. Finally, Hazelcast has support for the MapReduce programming model to perform distributed data processing tasks, plus cross-language support including not only Java but also .NET <span class="No-Break">and Python.</span></p>
			<p>In this database type, there are new concepts to be aware of such as bucket and key-value pair. Although not possible for every single aspect, for those who are used to the traditional SQL world, there are correlations between both worlds’ concepts that can facilitate <span class="No-Break">their understanding.</span></p>
			<p>To wrap up, a key-value NoSQL is a database that can store data as a collection of key-value pairs and is optimized for storing large amounts of data and efficiently retrieving it by key. It is <a id="_idIndexMarker079"/>known for being easy to use and understand, plus for its horizontal scalability, which makes it a good choice for applications that require high levels of read and <span class="No-Break">write throughput.</span></p>
			<p>Even though there <a id="_idIndexMarker080"/>are multiple benefits, key-value databases <a id="_idIndexMarker081"/>can be less flexible than other types of NoSQL databases when it comes to data modeling and querying. They do not support complex queries and do not have a rich data model, and can therefore be less suitable for applications that require sophisticated data manipulation. Additionally, key-value databases do not support transactions, which can be a limitation for some <span class="No-Break">use cases.</span></p>
			<p>Now, let’s take a look at the document database type<a id="_idTextAnchor035"/> and <span class="No-Break">its characteristics.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor036"/>NoSQL database types – document</h2>
			<p>The NoSQL document <a id="_idIndexMarker082"/>storage type is designed to store, retrieve, and manage documents with a minimally defined structure, such as the XML and JSON formats. A document without a predefined structure, in other words, is a data model that may be composed of numerous fields with different kinds of data, including documents inside other documents. A data structure would look like JSON, as shown in the following <span class="No-Break">code structure:</span></p>
			<pre class="source-code">
{    "name":"Diana",
    "duty":["Hunt","Moon","Nature"],
    "age":1000,
    "siblings":{
        "Apollo":"brother"
    }
}</pre>
			<p>The preceding JSON structure shows a document that stores data about a mythological persona named Diana. This same structure holds different data types such as strings, numbers, lists, and other complex objects. Like other types, this is a flexible option to store data in a hierarchical format, <em class="italic">with no need to specify a schema upfront</em>. Specifically, the <a id="_idIndexMarker083"/>document NoSQL database option can be easy to use and require minimal setup, which makes it a good choice for rapid prototyping of quickly developing applications. On the other hand, it generally lacks transaction support and doesn’t offer as complex querying capabilities as the complex multi-table join capabilities offered by traditional <span class="No-Break">relational databases.</span></p>
			<p><strong class="bold">Amazon SimpleDB</strong>, <strong class="bold">Apache CouchDB</strong>, and <strong class="bold">MongoDB</strong> are all popular NoSQL document-type <a id="_idIndexMarker084"/>storage solutions. The former is a fully managed <a id="_idIndexMarker085"/>database service <a id="_idIndexMarker086"/>offered by Amazon Web Services, while the latter are both open source solutions. All three options offer APIs for interacting with the database <span class="No-Break">using Java.</span></p>
			<p>Having learned more about key-value and document types, let’s move on to the ne<a id="_idTextAnchor037"/>xt: the <span class="No-Break">wide-column database.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor038"/>NoSQL database types – wide-column/column-family</h2>
			<p>The wide-column (also known as column-family) model became popular with the BigTable paper by Google <a id="_idIndexMarker087"/>for being a distributed storage <a id="_idIndexMarker088"/>system for structured data, and for being projected with the ability to offer high scalability and large storage volume capacity. These databases are optimized for storing large amounts of structured, semi-structured, and unstructured data with a flexible schema, and for supporting high levels <span class="No-Break">of concurrency.</span></p>
			<p>As opposed to other types, data in this type of database is stored in columns rather than in rows, allowing a more flexible and scalable data model. The data stored in a single column family can be of different types and structures, as represented in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 2.2 – NoSQL column-family type representation" src="image/B19375_02_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – NoSQL column-family type representation</p>
			<p>When compared to other NoSQL types, these data can be more difficult to query as they’re not stored in the traditional row-based format. Also, the increased schema flexibility represents an increased complexity of tasks such as data model designing and <span class="No-Break">data management.</span></p>
			<p>In regards to <a id="_idIndexMarker089"/>engine options, <strong class="bold">HBase</strong> and <strong class="bold">Cassandra</strong> are both open source, distributed, wide-column NoSQL databases, designed with a focus on handling large <a id="_idIndexMarker090"/>amounts of data. <strong class="bold">Scylla</strong> is also a distributed wide-column database but is designed <a id="_idIndexMarker091"/>as a drop-in replacement for Cassandra and optimized <span class="No-Break">for performance.</span></p>
			<p>In conclusion, wide-column NoSQL databases are powerful tools for storing and managing large <a id="_idIndexMarker092"/>amounts of data with a flexible schema, and <a id="_idIndexMarker093"/>are very well suited for distributed applications that demand high availability and horizontal scaling storage. However, they can be more difficult to query compared to other <span class="No-Break">NoSQL databases.</span></p>
			<p>Before we move forward to the next section, we will discuss the last type of NoSQL database, which can be particularly useful to complement wide-column databases in ce<a id="_idTextAnchor039"/>rtain scenarios: the <span class="No-Break">graph database.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor040"/>NoSQL database types – graph</h2>
			<p>The graph NoSQL database type is optimized for storing and querying data with complex <a id="_idIndexMarker094"/>relationships. In this approach, data is represented as a graph where <a id="_idIndexMarker095"/>the nodes represent entities and the edges represent the relationships between those entities. Observe in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.3</em> the graph structures being used for semantic queries, and the data representation through nodes, edges, <span class="No-Break">and properties:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 2.3 – NoSQL graph type representation" src="image/B19375_02_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – NoSQL graph type representation</p>
			<p>The key concepts <a id="_idIndexMarker096"/>to be aware of when developing applications <a id="_idIndexMarker097"/>that will work with a graph database are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Vertex</strong>/<strong class="bold">Vertice</strong>: Also known as a <strong class="bold">node</strong> in a graph. It stores the entity or object data like a table does <a id="_idIndexMarker098"/>in traditional relational databases, or like a document <a id="_idIndexMarker099"/>does in a document-type <span class="No-Break">NoSQL database.</span></li>
				<li><strong class="bold">Edge</strong>: An element to <a id="_idIndexMarker100"/>establish the relationship between <span class="No-Break">two vertices.</span></li>
				<li><strong class="bold">Property</strong>: A key-value pair <a id="_idIndexMarker101"/>that holds metadata about an edge or vertex element of <span class="No-Break">a graph.</span></li>
				<li><strong class="bold">Graph</strong>: A collection of <a id="_idIndexMarker102"/>vertices and edges representing the relationships <span class="No-Break">between entities.</span></li>
			</ul>
			<p>In a graph, the edge can be either directed or undirected and a direction on the relationship between nodes can exist and, in fact, is an essential concept in a graph structure. If considering the real world, we could compare it to Hollywood stars, for example, where there are people who know an actor but the actor is not aware of all their fans. This association’s metadata is stored as part of the edge’s direction (relationship) in the graph. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em>, notice the association direction and type are <span class="No-Break">clearly defined:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 2.4 – NoSQL graph type data model direction representation" src="image/B19375_02_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – NoSQL graph type data model direction representation</p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em> shows a directional association <a id="_idIndexMarker103"/>going from the vertex <strong class="bold">Poliana</strong> to the vertex <strong class="bold">Hephaestus</strong>. The association also has its own data, such as <strong class="bold">when</strong> and <strong class="bold">where</strong> in this case. The direction is <a id="_idIndexMarker104"/>especially relevant when querying the graph, as you can’t query from <strong class="bold">Hephaestus</strong> to <strong class="bold">Poliana</strong> – only the other <span class="No-Break">way around.</span></p>
			<p>Graph NoSQL database solutions can fit well in scenarios that require fast querying of highly interconnected data, such as social networks, recommendation engines, and fraud detection systems. Even though they can store and retrieve large amounts of data, that is <a id="_idIndexMarker105"/>not always true in the case of large amounts of <a id="_idIndexMarker106"/>structured and unstructured data with flexible schema, where the column-family type would be a better fit. Also, complex querying may require traversing the graph in order to find a requested piece <span class="No-Break">of data.</span></p>
			<p>There are several graph database engines to <a id="_idIndexMarker107"/>choose from, including <strong class="bold">Neo4j</strong>, <strong class="bold">InfoGrid</strong>, <strong class="bold">Sones</strong>, and <strong class="bold">HyperGraphDB</strong>. Each <a id="_idIndexMarker108"/>of these engines offers its own unique <a id="_idIndexMarker109"/>set of features and capabilities, and the right choice <a id="_idIndexMarker110"/>will depend on the specific needs of <span class="No-Break">the application.</span></p>
			<p>We have explored relational databases and NoSQL databases, the two main database storage paradigms in use today for storing and querying structured data using a fixed schema, and for storing and querying large amounts of structured/semi-structured/unstructured data with flexible <span class="No-Break">schema, respectively.</span></p>
			<p>Before moving <a id="_idIndexMarker111"/>to the next section, here’s a final tip to help you <a id="_idIndexMarker112"/>correlate concepts with which you are already familiar with the ones presented <span class="No-Break">so far:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 2.5 – How concepts can be related between different database flavors for learning purposes" src="image/B19375_02_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – How concepts can be related between different database flavors for learning purposes</p>
			<p>In the next and last section of this chapter, we’ll check through <a id="_idTextAnchor041"/>a newer category of databases: the <span class="No-Break">NewSQL databases.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor042"/>NewSQL databases – trying to get the best out of both worlds</h1>
			<p>NewSQL databases are a hybrid database type that combines the best features of both relational and NoSQL worlds, offering the ability to store and query structured data with a fixed <a id="_idIndexMarker113"/>schema while also providing the scalability and flexibility characteristics of NoSQL databases. NewSQL is seen as a way to address the limitations of both relational and NoSQL paradigms and provide a more flexible and scalable solution for modern applications. NewSQL is a database category that aims to unite the best features of both SQL and NoSQL worlds. We have learned two models of consistency: ACID, provided by relational databases, and BASE, by NoSQL. NewSQL seeks to offer a combination of horizontal scalability while maintaining the guarantees of the ACID (atomicity, consistency, isolation, and durability) principles. In other words, it tries to deliver on the guarantees of SQL with the high scalability, flexibility, and performance of NoSQL. Another positive aspect is the ability to use SQL as the <span class="No-Break">querying language.</span></p>
			<p>NewSQL looks like a promising solution, and we can observe (at the time of writing) several relevant companies offering enterprise-grade solutions to the market. It’s worth mentioning the involvement of companies that hold immense know-how of both developer and <span class="No-Break">operational needs.</span></p>
			<p>Some examples of <a id="_idIndexMarker114"/>NewSQL databases are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">VoltDB</strong></span></li>
				<li><span class="No-Break"><strong class="bold">ClustrixDB</strong></span></li>
				<li><span class="No-Break"><strong class="bold">CockroachDB</strong></span></li>
			</ul>
			<p>Notice that the NewSQL technology landscape is anything but homogenous, and each solution brings its own advantages <span class="No-Break">and drawbacks.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">NewSQL uses SQL but usually does not support 100% <span class="No-Break">of it.</span></p>
			<p>Even though this paradigm gives the impression that it may address and solve once and for all the problem presented <a id="_idIndexMarker115"/>by the CAP theorem, we should warn you, it does not. Also, generally, hybri<a id="_idTextAnchor043"/>d options bring the best and the <em class="italic">worst</em> of <span class="No-Break">both worlds.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor044"/>Summary</h1>
			<p>Database options come in several flavors, and it is crucial to understand the trade-offs with each type. Each data target has specific behaviors, such as SQL having a standard, maturity, several tools, and know-how in its favor. Still, it is pretty hard to work on <span class="No-Break">horizontal scalability.</span></p>
			<p>NoSQL was designed to improve horizontal scalability; however, this came at the cost of less consistency than relational databases are <span class="No-Break">known for.</span></p>
			<p>Finally, NewSQL tries to merge both worlds and bring the benefits of both, but it lacks in <span class="No-Break">both areas.</span></p>
			<p>In the next chapter, we’ll cover more about the architectures and strategies of technologies and how to <span class="No-Break">handle them.</span></p>
		</div>
	</body></html>