<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">DeskDroid - A Desktop Client for Your Android Phone</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We've come at long last to our final project. To close our time together here, we're going to build a very practical application, one that lets us send and receive SMS messages from the comfort of our desktop. There are a number of products on the market that let you do this now, but they typically require a third-party service, meaning your message travels through someone else's servers. For the privacy-minded, that can be a real problem. We'll build a system that is 100% local.</p>
<p class="mce-root">Building the app will cover several different topics, some familiar, some new. That list includes the following:</p>
<ul class="calibre13">
<li class="calibre14">Android applications</li>
<li class="calibre14">Android services</li>
<li class="calibre14">REST servers</li>
<li class="calibre14">Server-sent events for event/data streaming</li>
<li class="calibre14">Data access using Content Providers</li>
</ul>
<p class="mce-root">There will also be a host of other, smaller tidbits along the way as we finish out our time together on a strong, high note.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This project will have two parts:</p>
<ul class="calibre13">
<li class="calibre14">The Android application/server (not to be confused with application server, of course)</li>
<li class="calibre14">The desktop/JavaFX application</li>
</ul>
<p class="mce-root">The desktop piece is somewhat useless without the <strong class="calibre8">server</strong> piece, so we'll start by building the Android side first.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating the Android project</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While we have been using NetBeans for most of our work so far, we will again use Android Studio for this piece of the project. While there is some semblance of Android support for NetBeans, as of this writing, the project seems to have stalled. Android Studio, on the other hand, is very actively developed by Google and is, in fact, the official IDE for Android development. I will leave it as an exercise for the reader, if needed, to install the IDE and the SDK.</p>
<p class="mce-root">To create a new project, we click on <span class="calibre7">File</span> | <span class="calibre7">New Project</span>, and specify <span class="calibre7">Application name</span>, <span class="calibre7">Company domain</span>, and <span class="calibre7">Project location</span>, as shown in the following screenshot:</p>
<div class="mce-root1"><img class="image-border78" src="Images/40d38df6-07a4-40e1-8936-599fc2cc81fc.png" width="1002" height="852"/></div>
<p class="mce-root">Next, we need to specify the API version we want to target. This can be a tricky choice. On the one hand, we'd like to be on the cutting edge and have all of the great new features that Android offers available to us, but on the other hand, we don't want to target such a new API level that we make the application unusable (read uninstallable) for a larger number of Android users than is necessary. In this case, Android 6.0, or Marshmallow, seems like an acceptable trade-off:</p>
<div class="mce-root1"><img class="image-border79" src="Images/3fcfe029-ebb7-40ca-9b03-abb856bc76b2.png" width="1002" height="852"/></div>
<p class="mce-root">Click on <span class="calibre7">Next</span>, select <span class="calibre7">Blank Activity</span>, <span class="calibre7">Next</span>, and <span class="calibre7">Finish</span>, and our project is ready for development.</p>
<p class="mce-root">On the Android side, we are not going to do much in the way of user interface. Once we have finished the project, you will likely have all sorts of ideas of what could be done, which is great, but we won't spend the time here doing any of those. That said, the first thing we really need to do is ask the user for permission to access the text messages on their phone.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Requesting permissions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In earlier versions of Android, permissions were an all or nothing proposition. Starting with Android 6, though, the user is prompted for each permission that the application requests, allowing for the possibility of a user to grant some permissions while denying others. We will need to request some permissions--we need to be able to read and write SMS messages, and we'll need access to the contacts (so we can try to figure out who sent us a given message). Android provides an API for requesting those permissions very easily, which we'll put in our <kbd class="calibre16">onCreate()</kbd> method, as follows:</p>
<pre class="calibre21">    public static final int PERMISSION_REQUEST_CODE = 42; 
    @Override 
    protected void onCreate(Bundle savedInstanceState) { 
      super.onCreate(savedInstanceState); 
     // ... 
     ActivityCompat.requestPermissions(this, 
            new String[]{ 
                    Manifest.permission.SEND_SMS, 
                    Manifest.permission.RECEIVE_SMS, 
                    Manifest.permission.READ_CONTACTS 
            }, 
            PERMISSION_REQUEST_CODE); 
    } </pre>
<p class="mce-root">When this preceding code runs, Android will prompt the user to grant or deny the requested permissions. This is done asynchronously, so, in your applications, you need to make sure you don't attempt any operation that requires any permission that you request until the user has had a chance to grant the permission (and, should the user deny the permission, the application should degrade, or fail, gracefully).</p>
<p class="mce-root">To allow the application to respond to permission grants, Android provides a callback. In our callback, we want to make sure the user grants us both permissions:</p>
<pre class="calibre21">    @Override 
    public void onRequestPermissionsResult(int requestCode, 
     String permissions[], int[] grantResults) { 
      switch (requestCode) { 
        case PERMISSION_REQUEST_CODE: { 
          if (grantResults.length != 3 
           || grantResults[0] !=  
                PackageManager.PERMISSION_GRANTED 
           || grantResults[1] !=  
                PackageManager.PERMISSION_GRANTED 
           || grantResults[2] !=  
                PackageManager.PERMISSION_GRANTED) { 
                  AlertDialog.Builder dialog =  
                    new AlertDialog.Builder(this); 
                  dialog.setCancelable(false); 
                  dialog.setTitle("Error"); 
                  dialog.setMessage("This app requires access<br class="calibre2"/>                   to text messages and contacts. Click OK<br class="calibre2"/>                   to close."); 
                  dialog.setPositiveButton("OK",  
                   new DialogInterface.OnClickListener() { 
                     @Override 
                     public void onClick(DialogInterface dialog,  
                      int id) { 
                        finish(); 
                      } 
                  }); 
 
                  final AlertDialog alert = dialog.create(); 
                  alert.show(); 
                } 
        } 
      } 
    } </pre>
<p class="mce-root">When Android calls back in to our application, we need to make sure that the <kbd class="calibre16">requestCode</kbd> is what we specified-- <kbd class="calibre16">PERMISSION_REQUEST_CODE</kbd>--to make sure that we only respond to our own requests.</p>
<p class="mce-root">Once we've identified an appropriate response, we make sure that <kbd class="calibre16">grantResults</kbd> is the correct length, and that each entry is <kbd class="calibre16">PERMISSION_GRANTED</kbd>. If the array is too short, or if either array element is not the correct type, we display a dialog informing the user that both permissions are required, and then exit the application.</p>
<p class="mce-root">In our example, we are requesting both permissions simultaneously, so we respond to both simultaneously. If you have a complex set of permissions, for example, if your application can work with only some of the requested permissions, you can make multiple calls to <kbd class="calibre16">ActivityCompat.requestPermissions</kbd>, providing a distinct <kbd class="calibre16">requestCode</kbd> for each. You would then need to expand your switch block in <kbd class="calibre16">onRequestPermissionsResult()</kbd> to cover each new <kbd class="calibre16">requestCode</kbd>.</p>
<p class="mce-root">One final word on permissions. Typically, you should always check to make sure that you have the permission needed to perform a given task. You can do that with a method as follows:</p>
<pre class="calibre21">    protected boolean checkPermission(Permissions permission) { 
      return ContextCompat.checkSelfPermission(this,  
        permission.permission) ==  
        PackageManager.PERMISSION_GRANTED; 
   } </pre>
<p class="mce-root">In our case, we just don't allow the application to run if we aren't granted the required permissions, so we need not worry about additional permission checks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating the service</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The heart of the Android portion of the project is our REST endpoints. We would like these endpoints to be available whenever the phone is on, so we can't use an <kbd class="calibre16">Activity</kbd> to host them. What we want is a <kbd class="calibre16">Service</kbd>. The Android documentation defines a <kbd class="calibre16">Service</kbd> as <em class="calibre20">an application component that can perform long-running operations in the background, and it does not provide a user interface</em>. There are three types of Services--<kbd class="calibre16">scheduled</kbd> (which runs on a schedule), <kbd class="calibre16">started</kbd> (which can be started explicitly by another application component), and <kbd class="calibre16">bound</kbd> (which is bound to an application component via the <kbd class="calibre16">bindService()</kbd> call, and runs until all the bound components are destroyed). Since we want this to be available all the time, we want a started service.</p>
<p class="mce-root">To create the service, click on <span class="calibre7">File</span> | <span class="calibre7">New</span> | <span class="calibre7">Service</span> | <span class="calibre7">Service</span>. Enter <kbd class="calibre16">DeskDroidService</kbd> for the service, uncheck <span class="calibre7">Exported</span>, and click on <span class="calibre7">Finish</span>. That will get you the following stubbed code:</p>
<pre class="calibre21">    public class DeskDroidService extends Service { 
      public DeskDroidService() { 
      } 
 
     @Override 
     public IBinder onBind(Intent intent) { 
       throw new UnsupportedOperationException( 
           "Not yet implemented"); 
     } 
    } </pre>
<p class="mce-root">The wizard also updates <kbd class="calibre16">AndroidManifest.xml</kbd> as follows:</p>
<pre class="calibre21">    &lt;service 
      android:name=".DeskDroidService" 
      android:enabled="true" 
      android:exported="false" /&gt; </pre>
<p class="mce-root">The method <kbd class="calibre16">onBind()</kbd> is abstract, so it must be implemented. We are not creating a bound service, so we can leave this unimplemented, although we will change it so that it returns <kbd class="calibre16">null</kbd> rather than throwing an <kbd class="calibre16">Exception</kbd>. We are, though, interested in when the service is started and stopped, so we need to override these two relevant lifecycle methods:</p>
<pre class="calibre21">    public int onStartCommand(Intent intent, int flags, int startId) { 
      super.onStartCommand(intent, flags, startId); 
    }  
    public void onDestroy() { 
    } </pre>
<p class="mce-root">It's in these methods that we'll place our REST service code. We will once again use Jersey, the JAX-RS reference implementation, which provides a nice way of bootstrapping a server in a Java SE environment, such as what we find ourselves in here in our Android application. We'll encapsulate that logic in a new method called <kbd class="calibre16">startServer()</kbd> as follows:</p>
<pre class="calibre21">    protected static Server server; 
    protected void startServer() { 
      WifiManager WifiMgr = (WifiManager) getApplicationContext() 
       .getSystemService(Service.Wifi_SERVICE); 
      if (WifiMgr.isWifiEnabled()) { 
        String ipAddress = Formatter. 
         formatIpAddress(WifiMgr.getConnectionInfo() 
          .getIpAddress()); 
        URI baseUri = UriBuilder.fromUri("http://" + ipAddress) 
         .port(49152) 
         .build(); 
        ResourceConfig config =  
          new ResourceConfig(SseFeature.class) 
           .register(JacksonFeature.class); 
        server = JettyHttpContainerFactory.createServer(baseUri, 
         config); 
      } 
    } </pre>
<p class="mce-root">The first thing we do is check to make sure that we're on Wi-Fi. This isn't strictly necessary, but it seemed to be a prudent precaution to prevent the application from listening for connections, regardless of the network state. If the phone is not on Wi-Fi, there's a good chance the intended laptop is not either. There may be legitimate use cases for allowing the endpoints to listen even on a cellular network, however. Making this restriction configurable is a great candidate for a preferences-driven option.</p>
<p class="mce-root">For this code to work, we need to add this new permission to the manifest:</p>
<pre class="calibre21">    &lt;uses-permission android:name= 
      "android.permission.ACCESS_WIFI_STATE" /&gt; </pre>
<p class="mce-root">Once we're sure that we're on Wi-Fi, we look up our IP address, and bootstrap a Jetty-based Jersey server. With a nod to the Venerable Commodore 64, for those of us old enough to remember that computing pioneer, we listen on port <kbd class="calibre16">49152</kbd> on the Wi-Fi network interface.</p>
<p class="mce-root">Next, we create a <kbd class="calibre16">ResourceConfig</kbd> instance, providing two feature references that we're interested in--<kbd class="calibre16">SseFeature</kbd> and <kbd class="calibre16">JacksonFeature</kbd>. We've already seen <kbd class="calibre16">JacksonFeature</kbd>; that's what lets us work with POJOs, leaving the JSON concerns to Jersey. What is <kbd class="calibre16">SseFeature</kbd>, though?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Server-sent events</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">SSE, or server-sent events, is a means by which we can stream data from the server to the client. Typically, a REST request is very short-lived--make a connection, send the request, get a response, close the connection. Sometimes, though, the REST server may not have all of the data that the client wants at the time of the request (for example, reading data from another data source such as a log file or network socket). So, it would be nice to be able to push that data to the client as it becomes available. That's exactly what SSE allows us to do. We'll look into that in more detail later.</p>
<p class="mce-root">Finally, we start the server instance with a call to <kbd class="calibre16">JettyHttpContainerFactory.createServer()</kbd>. Since we need to be able to stop the server later, we capture the server instance, and store it in an instance variable. We call <kbd class="calibre16">startServer()</kbd> from <kbd class="calibre16">onStartCommand()</kbd> as follows:</p>
<pre class="calibre21">    private static final Object lock = new Object(); 
    public int onStartCommand(Intent intent, int flags, int startId) { 
      super.onStartCommand(intent, flags, startId); 
  
      synchronized (lock) { 
        if (server == null) { 
          startServer(); 
          messageReceiver = new BroadcastReceiver() { 
            @Override 
            public void onReceive(Context context,  
             Intent intent) { 
               String code = intent.getStringExtra("code"); 
               DeskDroidService.this.code = code; 
               Log.d("receiver", "Got code: " + code); 
            } 
          }; 
          LocalBroadcastManager.getInstance(this). 
           registerReceiver( 
             messageReceiver,  
              new IntentFilter(CODE_GENERATED)); 
        } 
      } 
  
      return Service.START_STICKY; 
    } </pre>
<p class="mce-root">Notice that we've wrapped our call to <kbd class="calibre16">startServer()</kbd> in a <kbd class="calibre16">synchronized</kbd> block. For those that might be unaware, <kbd class="calibre16">synchronized</kbd> is one of the more basic approaches to concurrent code available to Java developers. The net effect of this keyword is that multiple threads that try to execute this block of code must do so synchronously, or one a time. We do this here so that if we have two different processes attempting to start the server, we can guarantee that at most one is running. Without this block, the first thread could start the server and store the instance in the variable, while a second thread could do the same thing, but its server instance, which gets stored in the variable, fails to start. We would now have a running server with no valid reference to it, so we would be unable to stop it.</p>
<p class="mce-root">We have also registered a <kbd class="calibre16">BroadcastReceiver</kbd> that listens for <kbd class="calibre16">CODE_GENERATED</kbd>. We'll come back and explain this later in the chapter, so don't worry about this for now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Controlling the service state</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If we run the application now, our service won't run, so we need to make it such that it will run. We'll do that in a couple of different ways. The first way will be from our application. We want to make sure the service is running when we open the application, especially after it is just installed. To do that, we need to add one line to <kbd class="calibre16">MainActivity.onCreate()</kbd> as follows:</p>
<pre class="calibre21">    startService(new Intent(this, DeskDroidService.class)); </pre>
<p class="mce-root">When the application is started now, it will guarantee that the service is running. We don't, though, want to require that the user open the application to run the service. Fortunately, we have a way to start the application when the phone starts. We can do that by installing a <kbd class="calibre16">BroadcastReceiver</kbd> that listens for boot events, as shown here:</p>
<pre class="calibre21">    public class BootReceiver extends BroadcastReceiver { 
      @Override 
      public void onReceive(Context context, Intent intent) { 
        context.startService(new Intent(context,  
         DeskDroidService.class)); 
      } 
    } </pre>
<p class="mce-root">The body of the preceding method is identical to our recent addition to <kbd class="calibre16">MainActivity</kbd>. We do, though, need to register the service, and ask for permission. In <kbd class="calibre16">AndroidManifest.xml</kbd>, we need to add this:</p>
<pre class="calibre21">    &lt;uses-permission android:name= 
      "android.permission.RECEIVE_BOOT_COMPLETED" /&gt; 
    &lt;receiver android:name=".BootReceiver" android:enabled="true"&gt; 
      &lt;intent-filter&gt; 
        &lt;action android:name= 
        "android.intent.action.BOOT_COMPLETED" /&gt; 
      &lt;/intent-filter&gt; 
    &lt;/receiver&gt; </pre>
<p class="mce-root">We now have a service that starts either at device boot or application startup. It does not, however, do anything of interest, so we need to add some endpoints to our server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding endpoints to the server</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As covered in <a href="0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 25</a>, <em class="calibre20">Taking Notes with Monumentum</em>, a JAX-RS resource lives in a POJO with certain annotations. To stub out our endpoint class, we can start with this:</p>
<pre class="calibre21">    @Path("/") 
    @Produces(MediaType.APPLICATION_JSON) 
    protected class DeskDroidResource { 
    } </pre>
<p class="mce-root">We will also need to register this class with JAX-RS, which we do with this line in <kbd class="calibre16">startServer()</kbd>:</p>
<pre class="calibre21">    config.registerInstances(new DeskDroidResource()); </pre>
<p class="mce-root">Ordinarily, we would pass, say, <kbd class="calibre16">DeskDroidResource.class</kbd>, to the <kbd class="calibre16">ResourceConfig</kbd> constructor, like we did with <kbd class="calibre16">JacksonFeature.class</kbd>. We will be accessing Android resources, and to do that, we're going to need the <kbd class="calibre16">Service</kbd>'s <kbd class="calibre16">Context</kbd> instance. There are a number of resources on the internet that will suggest creating a custom <kbd class="calibre16">Application</kbd> class and storing it in a <kbd class="calibre16">public static</kbd>. While that does seem to work, it will also leak memory, so, Android Studio, for example, will complain if you try that. We can, however, avoid that by using nested classes. That approach can get a bit unwieldy, but our classes should be small enough that it remains manageable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting conversations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's start by adding an endpoint to get all of the conversations on the phone, as follows:</p>
<pre class="calibre21">    @GET 
    @Path("conversations") 
    public Response getConversations() { 
      List&lt;Conversation&gt; conversations = new ArrayList&lt;&gt;(); 
      Cursor cur = getApplication().getContentResolver() 
      .query(Telephony.Sms.Conversations.CONTENT_URI,  
      null, null, null, null); 
      while (cur.moveToNext()) { 
        conversations.add(buildConversation(cur)); 
      } 
 
      Collections.sort(conversations, new ConversationComparator()); 
 
      return Response.ok(new GenericEntity&lt;List&lt;Conversation&gt;&gt;( 
      conversations) {}).build(); 
     } </pre>
<p class="mce-root">Here is where we see the Android artifacts start to show up--we are going to use a <kbd class="calibre16">ContentProvider</kbd> to access the SMS data. A <kbd class="calibre16">ContentProvider</kbd> is a way for an application, or, in this case, an Android subsystem, to expose data to outside consumers in a portable, storage-agnostic manner. We don't care how the data is stored. We simply specify what fields we want, what filters or restrictions we want placed on that data, and <kbd class="calibre16">ContentProvider</kbd> does the rest.</p>
<p class="mce-root">Using <kbd class="calibre16">ContentProvider</kbd>s, we specify the type of data not by a table name, like we would with SQL, but with a <kbd class="calibre16">Uri</kbd>. In this case, we specify <kbd class="calibre16">Telephony.Sms.Conversations.CONTENT_URI</kbd>. We pass several null values to <kbd class="calibre16">query()</kbd> as well. These represent the projection (or field list), the selection (or filter), the selection arguments, and the sort order. Since these are all <kbd class="calibre16">null</kbd>, we want every field and every row in the natural sort order for the provider. That gets us a <kbd class="calibre16">Cursor</kbd> object, which we then iterate over, creating <kbd class="calibre16">Conversation</kbd> objects, and add them to our <kbd class="calibre16">List</kbd>.</p>
<p class="mce-root">We create the <kbd class="calibre16">Conversation</kbd> instances with this method:</p>
<pre class="calibre21">    private Conversation buildConversation(Cursor cur) { 
      Conversation conv = new Conversation(); 
      final int threadId =  
        cur.getInt(cur.getColumnIndex("thread_id")); 
      conv.setThreadId(threadId); 
      conv.setMessageCount( 
        cur.getInt(cur.getColumnIndex("msg_count"))); 
      conv.setSnippet(cur.getString(cur.getColumnIndex("snippet"))); 
      final List&lt;Message&gt; messages =  
        getSmsMessages(conv.getThreadId()); 
      Set&lt;String&gt; participants = new HashSet&lt;&gt;(); 
      for (Message message : messages) { 
        if (!message.isMine()) { 
          participants.add(message.getAddress()); 
        } 
      } 
      conv.setParticipants(participants); 
      conv.setMessages(messages); 
      return conv; 
    } </pre>
<p class="mce-root">Each conversation is just a thread ID, message count, and snippet, which is the last message received. To get the actual messages, we call <kbd class="calibre16">getSmsMessages()</kbd> as follows:</p>
<pre class="calibre21">    private List&lt;Message&gt; getSmsMessages(int threadId) { 
      List&lt;Message&gt; messages = new ArrayList&lt;&gt;(); 
      Cursor cur = null; 
      try { 
        cur = getApplicationContext().getContentResolver() 
         .query(Telephony.Sms.CONTENT_URI, 
         null, "thread_id = ?", new String[] 
         {Integer.toString(threadId)}, 
         "date DESC"); 
 
        while (cur.moveToNext()) { 
          Message message = new Message(); 
          message.setId(cur.getInt(cur.getColumnIndex("_id"))); 
          message.setThreadId(cur.getInt( 
            cur.getColumnIndex("thread_id"))); 
          message.setAddress(cur.getString( 
            cur.getColumnIndex("address"))); 
          message.setBody(cur.getString( 
            cur.getColumnIndexOrThrow("body"))); 
          message.setDate(new Date(cur.getLong( 
            cur.getColumnIndexOrThrow("date")))); 
          message.setMine(cur.getInt( 
            cur.getColumnIndex("type")) ==  
              Telephony.Sms.MESSAGE_TYPE_SENT); 
          messages.add(message); 
        } 
      } catch (Exception e) { 
          e.printStackTrace(); 
      } finally { 
          if (cur != null) { 
            cur.close(); 
          } 
      } 
      return messages; 
    } </pre>
<p class="mce-root">This method, and the processing logic, is mostly identical to that for conversations. The <kbd class="calibre16">Uri</kbd> for the <kbd class="calibre16">ContentProvider</kbd>, <kbd class="calibre16">Telephony.Sms.CONTENT_URI</kbd>, is different, of course, and we specify a filter for the query as follows:</p>
<pre class="calibre21">    cur = getApplicationContext().getContentResolver().query( 
      Telephony.Sms.CONTENT_URI, 
       null, "thread_id = ?", new String[] 
       {Integer.toString(threadId)}, 
       "date DESC"); </pre>
<p class="mce-root">We do have a slight bit of data analysis here. We need to know which of the messages are the ones we sent and which are the ones we received so that we can display the thread more meaningfully. On the device, the messages we've sent have the type <kbd class="calibre16">Telephony.Sms.MESSAGE_TYPE_SENT</kbd>. The values for this field translate roughly to folders (sent, received, draft, and so on). Rather than leaking part of the Android API into ours by sharing the value of the constant, we have a <kbd class="calibre16">boolean</kbd> field, <kbd class="calibre16">isMine</kbd>, which is true if the message is of type <kbd class="calibre16">MESSAGE_TYPE_SENT</kbd>. It is, admittedly, a slightly clumsy alternative, but it works and should be clear enough.</p>
<p class="mce-root">Once we return the list of messages, we iterate over the list, getting a list of the unique participants (which should be only one, since we are dealing with SMS messages).</p>
<p class="mce-root">Finally, we return this <kbd class="calibre16">List&lt;Conversation&gt;</kbd> to the client using Jersey's POJO-mapping feature as follows:</p>
<pre class="calibre21">    return Response.ok(new GenericEntity&lt;List&lt;Conversation&gt;&gt;( 
      conversations) {}).build();</pre>
<div class="mce-root1"><img class="image-border80" src="Images/8df486ff-1ee8-4e2d-a573-fa7d55e4e23c.png" width="631" height="155"/></div>
<p class="mce-root">If we click either the run or debug buttons (the large triangle or the triangle-over-a-bug icons in the tool bar), you'll be asked for the deployment target, as seen in this screenshot:</p>
<div class="mce-root1"><img class="image-border81" src="Images/6a7f7e2a-55a8-4da0-a587-5bb8b4550558.png" width="626" height="514"/></div>
<p class="mce-root">Since we require Wi-Fi, I select my physical device. If you want to configure an emulator with Wi-Fi, that would work as well. Click on <span class="calibre7">OK</span>, and after a few moments, the application should start on the device you have selected, and we can make our first REST request as follows:</p>
<pre class="calibre21">    $ curl http://192.168.0.2:49152/conversations | jq . 
    [ 
    { 
      "messageCount": 2, 
      "messages": [ 
        { 
          "address": "5551234567", 
          "body": "Demo message", 
          "date": 1493269498618, 
          "id": 301, 
          "mine": true, 
          "threadId": 89 
        }, 
        { 
          "address": "+15551234567", 
          "body": "Demo message", 
          "date": 1493269498727, 
          "id": 302, 
          "mine": false, 
          "threadId": 89 
        } 
      ], 
      "participants": [ "+15551234567" ], 
      "snippet": "Demo message", 
      "threadId": 89 
    } 
    ] </pre>
<p class="mce-root">This preceding sample code shows a conversation I'm having with myself. Too many late nights, perhaps, but you can see where the first message, the oldest message, is marked as mine, which is the one I sent to myself, and the second is where I received it back. Pretty cool, but how do you send a message? It turns out that that's actually quite simple.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sending an SMS message</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To send a message, we will create a POST endpoint that takes a <kbd class="calibre16">Message</kbd> object, which we'll then pull apart and pass to Android's telephony APIs.</p>
<pre class="calibre21">    @POST 
    @Path("conversations") 
    public Response sendMessage(Message message)  
    throws InterruptedException { 
       final SmsManager sms = SmsManager.getDefault(); 
       final ArrayList&lt;String&gt; parts =  
       sms.divideMessage(message.getBody()); 
       final CountDownLatch sentLatch =  
       new CountDownLatch(parts.size()); 
       final AtomicInteger statusCode = new AtomicInteger( 
       Response.Status.CREATED.getStatusCode()); 
       final BroadcastReceiver receiver = new BroadcastReceiver() { 
       @Override 
       public void onReceive(Context context, Intent intent) { 
            if (getResultCode() != Activity.RESULT_OK) { 
                    statusCode.set( 
                        Response.Status.INTERNAL_SERVER_ERROR 
                            .getStatusCode()); 
            } 
             sentLatch.countDown(); 
          } 
        }; 
      registerReceiver(receiver,  
      new IntentFilter("com.steeplesoft.deskdroid.SMS_SENT")); 
      ArrayList&lt;PendingIntent&gt; sentPIs = new ArrayList&lt;&gt;(); 
      for (int i = 0; i &lt; parts.size(); i++) { 
         sentPIs.add(PendingIntent.getBroadcast( 
            getApplicationContext(), 0, 
            new Intent("com.steeplesoft.deskdroid.SMS_SENT"), 0)); 
      } 
      sms.sendMultipartTextMessage(message.getAddress(), null,  
      parts, sentPIs, null); 
 
      sentLatch.await(5, TimeUnit.SECONDS); 
      unregisterReceiver(receiver); 
      return Response.status(statusCode.get()).build(); 
     } </pre>
<p class="mce-root">There's a lot going on this method. Here is the breakdown:</p>
<ol class="calibre18">
<li class="chapter">We get a reference to the <kbd class="calibre16">SmsManager</kbd> class. This class will do all of the work for us.</li>
<li class="chapter">We ask <kbd class="calibre16">SmsManager</kbd> to divide the message for us. Text messages are, typically, limited to 160 characters, so this will split the message as needed.</li>
<li class="chapter">We create a <kbd class="calibre16">CountDownLatch</kbd> with a count that matches the number of parts in the message.</li>
</ol>
<ol start="4" class="calibre18">
<li class="chapter">We create an <kbd class="calibre16">AtomicInteger</kbd> to store the status code. As we'll see in a moment, we need to change the value of this variable from inside an anonymous class. However, for an anonymous class to access variables from its enclosing scope, those variables must be <kbd class="calibre16">final</kbd>, which means that we can not have a <kbd class="calibre16">final int</kbd>, as then we would not be able to change the value. With <kbd class="calibre16">AtomicInteger</kbd>, though, we can call <kbd class="calibre16">set()</kbd> to change the value while leaving the instance reference, which is what the variable will hold, unchanged.</li>
<li class="chapter">We create a new <kbd class="calibre16">BroadcastReceiver</kbd>, which will handle <kbd class="calibre16">Intent</kbd>s broadcast (as we'll see further) when the message is sent. In <kbd class="calibre16">onReceive()</kbd>, if the result code is not <kbd class="calibre16">ACTIVITY.RESULT_OK</kbd>, we call <kbd class="calibre16">AtomicInteger.set()</kbd> to reflect the failure. We then call <kbd class="calibre16">sentLatch.countDown()</kbd> to indicate that this message part has been processed.</li>
<li class="chapter">With the call to <kbd class="calibre16">registerReceiver()</kbd>, we let the operating system know about our new receiver. We provide an <kbd class="calibre16">IntentFilter</kbd> to restrict which <kbd class="calibre16">Intents</kbd> our receiver has to process.</li>
<li class="chapter">We then create a new <kbd class="calibre16">PendingIntent</kbd> for each part our message has been split into. This will allow us to react to each part's send attempt individually.</li>
<li class="chapter">We call <kbd class="calibre16">sendMultipartTextMessage()</kbd> to send the message part(s). Android handles the details of a multipart message for us, so there's no extra effort required.</li>
<li class="chapter">We need to wait for all of the message parts to be sent, so we call <kbd class="calibre16">sentLatch.await()</kbd> to give the system time to send the message. We don't want to wait forever, though, so we give it a timeout of five seconds, which should be long enough. It is conceivable that some networks may be very slow about sending text messages, so this value may need to be adjusted.</li>
<li class="chapter">Once we pass the latch, we <kbd class="calibre16">unregister</kbd> our receiver, and return the status code.</li>
</ol>
<p class="calibre26">Using curl again, we can now test sending a message (be sure to click on <kbd class="calibre16">Run</kbd> or <kbd class="calibre16">Debug</kbd> again to deploy your updated code):</p>
<pre class="calibre21">        $ curl -v -X POST -H 'Content-type: application/json'<br class="calibre2"/>        http://192.168.0.2:49152/conversations -d <br class="calibre2"/>        '{"address":"++15551234567", "body":"Lorem ipsum dolor sit <br class="calibre2"/>         amet..."}' 
        &gt; POST /conversations HTTP/1.1 
        &gt; Content-type: application/json 
        &gt; Content-Length: 482 
        &lt; HTTP/1.1 201 Created </pre>
<p class="mce-root">In the preceding <kbd class="calibre16">curl</kbd> we send some <kbd class="calibre16">lorem ipsum</kbd> text to our recipient, which gives us a nice, long message (482 total characters for the request payload), which is correctly chunked up and sent to the destination phone number, as indicated by the <kbd class="calibre16">201 Created</kbd> response status.</p>
<p class="mce-root">We now have a working REST service on the phone, which lets us read the existing messages and send new ones. Interacting with the service with <kbd class="calibre16">curl</kbd> has worked well enough, but it's time to build our desktop client, and put a nice face on this project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating the desktop application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To build our application, we'll return to NetBeans and JavaFX. As in the previous chapters, we'll create a new Maven-based JavaFX application by clicking on <span class="calibre7">File</span> | <span class="calibre7">New Project</span>:</p>
<div class="mce-root1"><img class="image-border82" src="Images/095f8c0e-ab8f-4125-9dbe-96ff4dbe62a5.png"/></div>
<p class="mce-root">In the next step, call the project <kbd class="calibre16">deskdroid-desktop</kbd>, verify the package name, and click on <span class="calibre7">Finish</span>. While not strictly necessary, let's clean up the naming a bit, changing the controller to <kbd class="calibre16">DeskDroidController</kbd>, and the FXML file to <kbd class="calibre16">deskdroid.fxml</kbd>. We'll also need to modify the references to the FXML and the CSS in the controller, and the reference to the controller in the FXML. Click on <span class="calibre7">Run</span> | <span class="calibre7">Run Project</span> to make sure everything is wired up correctly. Once the app starts, we can immediately close it so we can start making changes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining the user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's start by building up the user interface. Here's what the application will look like:</p>
<div class="mce-root1"><img class="image-border83" src="Images/4278a3b2-cead-4ecd-ac27-f4a1989c87ef.png"/></div>
<p class="mce-root">In the preceding screen, we'll have our list of conversations on the left, and we will display the selected conversation on the right. We will add a mechanism for auto-refreshing, but the <span class="calibre7">Refresh Conversations</span> will allow for a manual refresh, if needed. <span class="calibre7">New Message</span> should be self-explanatory.</p>
<p class="mce-root">We can use Gluon's Scene Builder to build the user interface, of course, but let's take a look at the FXML. We'll start, as usual, with a <kbd class="calibre16">BorderPane</kbd>, as follows:</p>
<pre class="calibre21">    &lt;BorderPane fx:id="borderPane" minWidth="1024" prefHeight="768"  
      
      
    fx:controller="com.steeplesoft.deskdroid.<br class="calibre2"/>    desktop.DeskDroidController"&gt; </pre>
<p class="mce-root">For the <kbd class="calibre16">top</kbd> section, we're going to add a menu bar as follows:</p>
<pre class="calibre21">    &lt;MenuBar BorderPane.alignment="CENTER"&gt; 
      &lt;menus&gt; 
        &lt;Menu text="_File"&gt; 
            &lt;items&gt; 
                &lt;MenuItem onAction="#connectToPhone"  
                    text="_Connect to Phone" /&gt; 
                &lt;MenuItem onAction="#disconnectFromPhone"  
                    text="_Disconnect from Phone" /&gt; 
                &lt;MenuItem onAction="#closeApplication"  
                    text="E_xit"&gt; 
                    &lt;accelerator&gt; 
                        &lt;KeyCodeCombination alt="ANY" code="F4"  
                            control="UP" meta="UP" shift="UP"  
                            shortcut="UP" /&gt; 
                    &lt;/accelerator&gt; 
                &lt;/MenuItem&gt; 
              &lt;/items&gt; 
          &lt;/Menu&gt; 
       &lt;/menus&gt; 
    &lt;/MenuBar&gt; </pre>
<p class="mce-root">We'll have three <kbd class="calibre16">MenuItem</kbd>s in the <kbd class="calibre16">FileMenu</kbd>: <kbd class="calibre16">connectToPhone</kbd>, <kbd class="calibre16">disconnectFromPhone</kbd>, and <kbd class="calibre16">Exit</kbd>. Each menu item will have a mnemonic, as indicated by the underscores. The <kbd class="calibre16">ExitMenuItem</kbd> has an accelerator key, <kbd class="calibre16">ALT-F4</kbd>.</p>
<p class="mce-root">We'll put the bulk of the user interface in the <kbd class="calibre16">center</kbd> section. The vertical split allows us to resize the two sides of the user interface. For that, we use a <kbd class="calibre16">SplitPane</kbd> as follows:</p>
<pre class="calibre21">    &lt;center&gt; 
      &lt;SplitPane dividerPositions="0.25"  
        BorderPane.alignment="CENTER"&gt; 
      &lt;items&gt; </pre>
<p class="mce-root">With <kbd class="calibre16">dividerPositions</kbd>, we set the default split at the 25% mark along the horizontal rule. The <kbd class="calibre16">SplitPane</kbd> has a nested <kbd class="calibre16">items</kbd> element to hold its children to which we add the left element, <kbd class="calibre16">ListView</kbd>:</p>
<pre class="calibre21">    &lt;VBox&gt; 
      &lt;children&gt; 
        &lt;ListView fx:id="convList" VBox.vgrow="ALWAYS" /&gt; 
      &lt;/children&gt; 
    &lt;/VBox&gt; </pre>
<p class="mce-root">We wrap <kbd class="calibre16">ListView</kbd> in a <kbd class="calibre16">VBox</kbd> to make the <kbd class="calibre16">ListView</kbd> grow and shrink, as needed, more easily.</p>
<p class="mce-root">Finally, let's build the right side of the user interface:</p>
<pre class="calibre21">     &lt;VBox fx:id="convContainer"&gt; 
       &lt;children&gt; 
        &lt;HBox&gt; 
            &lt;children&gt; 
                &lt;Button mnemonicParsing="false"  
                        onAction="#refreshConversations"  
                        text="Refresh Conversations"&gt; 
                    &lt;HBox.margin&gt; 
                        &lt;Insets right="5.0" /&gt; 
                    &lt;/HBox.margin&gt; 
                &lt;/Button&gt; 
                &lt;Button fx:id="newMessageBtn"  
                    text="New Message" /&gt; 
            &lt;/children&gt; 
            &lt;padding&gt; 
                &lt;Insets bottom="5.0" left="5.0"  
                    right="5.0" top="5.0" /&gt; 
            &lt;/padding&gt; 
        &lt;/HBox&gt; 
        &lt;ListView fx:id="messageList" VBox.vgrow="ALWAYS" /&gt; 
      &lt;/children&gt; 
    &lt;/VBox&gt; </pre>
<p class="mce-root">On the right side, we also have a <kbd class="calibre16">VBox</kbd>, which we use to arrange our two user interface elements. The first is <kbd class="calibre16">HBox</kbd>, which holds two buttons: <span class="calibre7">Refresh Conversation</span> and <span class="calibre7">New Message</span>. The second is our <kbd class="calibre16">ListView</kbd> for displaying the selected conversation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining user interface behavior</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While we can define the structure of the user interface in FXML in all but the most trivial applications, the user interface still requires some Java code to finish defining its behavior. We'll do that now in <kbd class="calibre16">DeskDroidController.initialize()</kbd>. We'll start with the left side of the user interface, the conversation list, as follows:</p>
<pre class="calibre21">    @FXML 
    private ListView&lt;Conversation&gt; convList; 
    private final ObservableList&lt;Conversation&gt; conversations =  
    FXCollections.observableArrayList(); 
    private final SimpleObjectProperty&lt;Conversation&gt; conversation =  
    new SimpleObjectProperty&lt;&gt;(); 
    @Override 
    public void initialize(URL url, ResourceBundle rb) { 
      convList.setCellFactory(list -&gt;  
      new ConversationCell(convList)); 
      convList.setItems(conversations); 
       convList.getSelectionModel().selectedItemProperty() 
            .addListener((observable, oldValue, newValue) -&gt; { 
                conversation.set(newValue); 
                messages.setAll(newValue.getMessages()); 
                messageList.scrollTo(messages.size() - 1); 
     }); </pre>
<p class="mce-root">We declare an injectable variable to hold a reference to our <kbd class="calibre16">ListView</kbd>. JavaFX will set that value for us, thanks to the annotation <kbd class="calibre16">@FXML</kbd>. <kbd class="calibre16">ListView</kbd> will need a model to display, which we declare as <kbd class="calibre16">conversations</kbd>, and we declare <kbd class="calibre16">conversation</kbd> to hold the currently selected conversation.</p>
<p class="mce-root">In the <kbd class="calibre16">initialize()</kbd> method, we wire everything together. Since <kbd class="calibre16">ListView</kbd> will be displaying our domain object, we need to declare a <kbd class="calibre16">CellFactory</kbd> for it, which we do with the lambda passed to <kbd class="calibre16">setCellFactory()</kbd>. We'll look at <kbd class="calibre16">ListCell</kbd> in a moment.</p>
<p class="mce-root">Next, we associate <kbd class="calibre16">ListView</kbd> with its model, <kbd class="calibre16">conversations</kbd>, and define what is, in effect, an <kbd class="calibre16">onClick</kbd> listener. We achieve that, though, by adding a listener to <kbd class="calibre16">SelectionModel</kbd> on <kbd class="calibre16">ListView</kbd>. In that listener, we update the currently selected conversation, update the messages <kbd class="calibre16">ListView</kbd> to display the conversation, and scroll that <kbd class="calibre16">ListView</kbd> to the very bottom so that we see the most recent message.</p>
<p class="mce-root">Initializing the message <kbd class="calibre16">ListView</kbd> is much simpler. We need these instance variables:</p>
<pre class="calibre21">    @FXML 
    private ListView&lt;Message&gt; messageList; 
    private final ObservableList&lt;Message&gt; messages =  
    FXCollections.observableArrayList(); </pre>
<p class="mce-root">We also need these lines in <kbd class="calibre16">initialize()</kbd>:</p>
<pre class="calibre21">    messageList.setCellFactory(list -&gt; new MessageCell(messageList)); 
    messageList.setItems(messages); </pre>
<p class="mce-root">And the <span class="calibre7">New Message</span> button needs a handler:</p>
<pre class="calibre21">    newMessageBtn.setOnAction(event -&gt; sendNewMessage()); </pre>
<p class="mce-root"><kbd class="calibre16">ConversationCell</kbd> tells JavaFX how to display a <kbd class="calibre16">Conversation</kbd> instance. To do that, we create a new <kbd class="calibre16">ListCell</kbd> child as follows:</p>
<pre class="calibre21">    public class ConversationCell extends ListCell&lt;Conversation&gt; { </pre>
<p class="mce-root">Then we override <kbd class="calibre16">updateItem()</kbd>:</p>
<pre class="calibre21">    @Override 
    protected void updateItem(Conversation conversation,  
    boolean empty) { 
    super.updateItem(conversation, empty); 
    if (conversation != null) { 
        setWrapText(true); 
        final Participant participant =  
            ConversationService.getInstance() 
                .getParticipant(conversation 
                    .getParticipant()); 
        HBox hbox = createWrapper(participant); 
 
        hbox.getChildren().add( 
            createConversationSnippet(participant,  
                conversation.getSnippet())); 
        setGraphic(hbox); 
     } else { 
        setGraphic(null); 
     } 
    } </pre>
<p class="mce-root">If the cell is given a <kbd class="calibre16">Conversation</kbd>, we process it. If not, we set the cell's graphic to null. If we fail to do that, we'll have unpredictable results when scrolling through the lists.</p>
<p class="mce-root">To build the cell contents, we start by getting the <kbd class="calibre16">Participant</kbd> and creating the wrapper component as follows:</p>
<pre class="calibre21">    protected HBox createWrapper(final Participant participant) { 
      HBox hbox = new HBox(); 
      hbox.setManaged(true); 
      ImageView thumbNail = new ImageView(); 
      thumbNail.prefWidth(65); 
      thumbNail.setPreserveRatio(true); 
      thumbNail.setFitHeight(65); 
      thumbNail.setImage(new Image( 
        ConversationService.getInstance() 
           .getParticipantThumbnail( 
               participant.getPhoneNumber()))); 
      hbox.getChildren().add(thumbNail); 
      return hbox; 
    } </pre>
<p class="mce-root">This is pretty standard JavaFX fare--create an <kbd class="calibre16">HBox</kbd>, and add to it an <kbd class="calibre16">ImageView</kbd>. We are, though, using a class we haven't looked at yet--<kbd class="calibre16">ConversationService</kbd>. We'll look at this later, but for now, it's enough to know that we will encapsulate our REST calls in this class. Here, we're calling an endpoint (that we haven't seen yet) to get the contact information for the phone number at the other end of this conversation.</p>
<p class="mce-root">We also need to create the conversation snippet as follows:</p>
<pre class="calibre21">    protected VBox createConversationSnippet( 
     final Participant participant, String snippet) { 
      VBox vbox = new VBox(); 
      vbox.setPadding(new Insets(0, 0, 0, 5)); 
      Label sender = new Label(participant.getName()); 
      sender.setWrapText(true); 
      Label phoneNumber = new Label(participant.getPhoneNumber()); 
      phoneNumber.setWrapText(true); 
      Label label = new Label(snippet); 
      label.setWrapText(true); 
      vbox.getChildren().addAll(sender, phoneNumber, label); 
      return vbox; 
    } </pre>
<p class="mce-root">Using <kbd class="calibre16">VBox</kbd> to ensure vertical alignment, we create two labels, one with the participants' information, and the other with the snippet of the conversation.</p>
<p class="mce-root">While that finishes the cell definition, if we were to run the application the way it is now, the <kbd class="calibre16">ListCell</kbd>'s contents would likely be cropped by the edge of <kbd class="calibre16">ListView</kbd> itself. For example, see the difference between the top list and the bottom list in the following screenshot:</p>
<div class="mce-root1"><img class="image-border84" src="Images/3c21078d-c23b-4f6a-9700-2d0bf3b12872.png"/></div>
<p class="mce-root">To make our <kbd class="calibre16">ListCell</kbd> behave as we see at the bottom of the last screen, we need to make one more change to our code, which is as follows:</p>
<pre class="calibre21">    public ConversationCell(ListView list) { 
      super(); 
      prefWidthProperty().bind(list.widthProperty().subtract(2)); 
      setMaxWidth(Control.USE_PREF_SIZE); 
    } </pre>
<p class="mce-root">In our preceding <kbd class="calibre16">CellFactory</kbd>, we pass in the reference to the enclosing <kbd class="calibre16">ListView</kbd>.</p>
<pre class="calibre21">    convList.setCellFactory(list -&gt; new ConversationCell(convList)); </pre>
<p class="mce-root">In the constructor, we then bind the preferred width of our cell to the actual width of the list (and subtract a small amount to adjust for the control borders). When rendered now, our cell will wrap just as we expected.</p>
<p class="mce-root">The <kbd class="calibre16">MessageCell</kbd> definition is similar, and goes as follows:</p>
<pre class="calibre21">    public class MessageCell extends ListCell&lt;Message&gt; { 
      public MessageCell(ListView list) { 
          prefWidthProperty() 
            .bind(list.widthProperty().subtract(20)); 
          setMaxWidth(Control.USE_PREF_SIZE); 
      } 
 
    @Override 
    public void updateItem(Message message, boolean empty) { 
        super.updateItem(message, empty); 
        if (message != null &amp;&amp; !empty) { 
            if (message.isMine()) { 
                wrapMyMessage(message); 
            } else { 
                wrapTheirMessage(message); 
            } 
         } else { 
            setGraphic(null); 
        } 
    } </pre>
<p class="mce-root">For <em class="calibre20">my</em> message, we create the contents this way:</p>
<pre class="calibre21">    private static final SimpleDateFormat DATE_FORMAT =  
     new SimpleDateFormat("EEE, MM/dd/yyyy hh:mm aa"); 
    private void wrapMyMessage(Message message) { 
     HBox hbox = new HBox(); 
     hbox.setAlignment(Pos.TOP_RIGHT); 
     createMessageBox(message, hbox, Pos.TOP_RIGHT); 
     setGraphic(hbox); 
    } 
    private void createMessageBox(Message message, Pane parent,  
     Pos alignment) { 
       VBox vbox = new VBox(); 
       vbox.setAlignment(alignment); 
       vbox.setPadding(new Insets(0,0,0,5)); 
       Label body = new Label(); 
       body.setWrapText(true); 
       body.setText(message.getBody()); 
 
       Label date = new Label(); 
       date.setText(DATE_FORMAT.format(message.getDate())); 
 
       vbox.getChildren().addAll(body,date); 
       parent.getChildren().add(vbox); 
    } </pre>
<p class="mce-root">The <strong class="calibre8">message box</strong> is much like the previous conversation snippet--a vertical display of the message, followed by its date and time. This format will be used by <em class="calibre20">my</em> messages and <em class="calibre20">their</em> messages, so we use <kbd class="calibre16">javafx.geometry.Pos</kbd> to align the controls to the right or left, respectively.</p>
<p class="mce-root">The <em class="calibre20">their</em> message is created this way:</p>
<pre class="calibre21">    private void wrapTheirMessage(Message message) { 
      HBox hbox = new HBox(); 
      ImageView thumbNail = new ImageView(); 
      thumbNail.prefWidth(65); 
      thumbNail.setPreserveRatio(true); 
      thumbNail.setFitHeight(65); 
      thumbNail.setImage(new Image( 
            ConversationService.getInstance() 
                .getParticipantThumbnail( 
                    message.getAddress()))); 
      hbox.getChildren().add(thumbNail); 
      createMessageBox(message, hbox, Pos.TOP_LEFT); 
      setGraphic(hbox); 
   } </pre>
<p class="mce-root">This is similar to the <em class="calibre20">my</em> message, with the exception that we display the sender's profile picture, if there is one associated with the contact on the phone, which we retrieve from the phone via the <kbd class="calibre16">ConversationService</kbd> class.</p>
<p class="mce-root">We have a bit more work to do, but this is what the application will look like with data:</p>
<div class="mce-root1"><img class="image-border85" src="Images/2e658425-c23c-4c95-8cf0-843f21db6233.png" width="802" height="639"/></div>
<p class="mce-root">To get the data, we need a REST client, and that is found in <kbd class="calibre16">ConversationService</kbd>:</p>
<pre class="calibre21">    public class ConversationService { 
      public static class LazyHolder { 
        public static final ConversationService INSTANCE =  
            new ConversationService(); 
      } 
     
     public static ConversationService getInstance() { 
        return LazyHolder.INSTANCE; 
      } 
     private ConversationService() { 
        Configuration configuration = new ResourceConfig() 
                .register(JacksonFeature.class) 
                .register(SseFeature.class); 
        client = ClientBuilder.newClient(configuration); 
     } </pre>
<p class="mce-root">Using the so-called <em class="calibre20">Initialize-on-Demand Holder</em> idiom, we create a sort of a poor man's singleton. Since the constructor is private, it can't be called from outside this class. The nested static class, <kbd class="calibre16">LazyHolder</kbd>, is initialized only when it is finally referenced, which happens on the first call to <kbd class="calibre16">getInstance()</kbd>. Once that method is called, <kbd class="calibre16">LazyHolder</kbd> is loaded and initialized, at which point, the constructor is run. The instance created is stored in the static variable, and lives as long as the JVM runs. Every subsequent call will return the same instance. This is important for us, as we have some objects that are expensive to create as well as some simple caching in the class:</p>
<pre class="calibre21">    protected final Client client; 
    protected final Map&lt;String, Participant&gt; participants =  
      new HashMap&lt;&gt;(); </pre>
<p class="mce-root">In the preceding code, we initialize our client instance, registering the <kbd class="calibre16">JacksonFeature</kbd>, which gets us the POJO mapping we've already discussed. We also register <kbd class="calibre16">SseFeature</kbd>, a more advanced feature of Jersey that we'll discuss in detail later.</p>
<p class="mce-root">We've already seen the conversation list. That is generated using data from this method:</p>
<pre class="calibre21">    public List&lt;Conversation&gt; getConversations() { 
      List&lt;Conversation&gt; list; 
      try { 
       list = getWebTarget().path("conversations") 
                .request(MediaType.APPLICATION_JSON) 
                .header(HttpHeaders.AUTHORIZATION,  
                    getAuthorizationHeader()) 
                .get(new GenericType&lt;List&lt;Conversation&gt;&gt;() {}); 
       } catch (Exception ce) { 
        list = new ArrayList&lt;&gt;(); 
      } 
      return list; 
    } 
    public WebTarget getWebTarget() { 
    return client.target("http://" 
            + preferences.getPhoneAddress() + ":49152/"); 
    } </pre>
<p class="mce-root"><kbd class="calibre16">WebTarget</kbd> is a JAX-RS class that represents the <em class="calibre20">resource target identified by the resource URI</em>. We're pulling the address for the phone from preferences, which we'll discuss later. Once we have our <kbd class="calibre16">WebTarget</kbd>, we complete building the URI by appending <kbd class="calibre16">conversations</kbd>, specify the request mime type, and issue the <kbd class="calibre16">GET</kbd> request. Note that our request here is somewhat optimistic, as we don't do any status code checking. Should an <kbd class="calibre16">Exception</kbd> be thrown, we simply return an empty <kbd class="calibre16">List</kbd>.</p>
<p class="mce-root">The other method we've seen is <kbd class="calibre16">getParticipant()</kbd>, which is as follows:</p>
<pre class="calibre21">    public Participant getParticipant(String number) { 
      Participant p = participants.get(number); 
      if (p == null) { 
        Response response = getWebTarget() 
                .path("participants") 
                .path(number) 
                .request(MediaType.APPLICATION_JSON) 
                .header(HttpHeaders.AUTHORIZATION,  
                    getAuthorizationHeader()) 
                .get(Response.class); 
        if (response.getStatus() == 200) { 
            p = response.readEntity(Participant.class); 
            participants.put(number, p); 
            if (p.getThumbnail() != null) { 
                File thumb = new File(number + ".png"); 
                try (OutputStream stream =  
                        new FileOutputStream(thumb)) { 
                    byte[] data = DatatypeConverter 
                        .parseBase64Binary(p.getThumbnail()); 
                    stream.write(data); 
                } catch (IOException e) { 
                    e.printStackTrace(); 
                } 
             } 
          } 
       } 
     return p; 
   } </pre>
<p class="mce-root">In the last method, we see our cache come into play. When a <kbd class="calibre16">Participant</kbd> is requested, we look to see if this information has already been fetched. If so, we return the cached information. If not, we can make a request for it.</p>
<p class="mce-root">Much like <kbd class="calibre16">getConversations(),</kbd> we build a request for the appropriate endpoint, and send the <kbd class="calibre16">GET</kbd> request. This time, though, we do check for the status code. Only if the status is <kbd class="calibre16">200 (OK)</kbd> do we continue processing the response. In this case, we ask JAX-RS for the <kbd class="calibre16">Participant</kbd> instance returned, which <kbd class="calibre16">JacksonFeature</kbd> happily builds for us from the JSON response body, and which we immediately add to our cache.</p>
<p class="mce-root">If the server found a thumbnail for the contact, we need to process that. The server piece, which we will look at immediately after we finish discussing this method, sends the thumbnail as a base 64-encoded string in the body of the JSON object, so we convert it back to the binary representation, and save that to a file. Notice that we are using try-with-resources, so we need not worry about cleaning up after ourselves.</p>
<pre class="calibre21">    try (OutputStream stream = new FileOutputStream(thumb)) </pre>
<p class="mce-root">We haven't seen the server side of this operation, so let's look at that now. In our Android application in Android Studio, we have this method on <kbd class="calibre16">DeskDroidResource</kbd>:</p>
<pre class="calibre21">    @GET 
    @Path("participants/{address}") 
    public Response getParticipant(@PathParam("address")  
    String address) { 
      Participant p = null; 
      try { 
        p = getContactsDetails(address); 
        } catch (IOException e) { 
        return Response.serverError().build(); 
       } 
      if (p == null) { 
        return Response.status(Response.Status.NOT_FOUND).build(); 
       } else { 
        return Response.ok(p).build(); 
       } 
    } </pre>
<p class="mce-root">We attempt to build the <kbd class="calibre16">Participant</kbd> instance. If an Exception is thrown, we return a <kbd class="calibre16">500</kbd> (Server Error). If <kbd class="calibre16">null</kbd> is returned, we return a <kbd class="calibre16">404</kbd> (Not Found). If a participant is found, we return <kbd class="calibre16">200</kbd> (OK) and the participant.</p>
<p class="mce-root">To build the participant, we need to query the phone contacts. This works in much the same way as the SMS queries:</p>
<pre class="calibre21">    protected Participant getContactsDetails(String address) throws <br class="calibre2"/>     IOException { 
      Uri contactUri = Uri.withAppendedPath( 
        ContactsContract.PhoneLookup.CONTENT_FILTER_URI,  
        Uri.encode(address)); 
        Cursor phones = deskDroidService.getApplicationContext() 
        .getContentResolver().query(contactUri, 
        new String[]{ 
          ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME, 
          "number", 
          ContactsContract.CommonDataKinds.Phone 
            .PHOTO_THUMBNAIL_URI}, 
            null, null, null); 
        Participant participant = new Participant(); 
        if (phones.moveToNext()) { 
          participant.setName(phones.getString(phones 
          .getColumnIndex( 
          ContactsContract.CommonDataKinds.Phone 
           .DISPLAY_NAME))); 
          participant.setPhoneNumber(phones.getString( 
            phones.getColumnIndex("number"))); 
          String image_uri = phones.getString( 
            phones.getColumnIndex( 
              ContactsContract.CommonDataKinds.Phone 
               .PHOTO_THUMBNAIL_URI)); 
          if (image_uri != null) { 
            try (InputStream input = deskDroidService 
              .getApplicationContext().getContentResolver() 
              .openInputStream(Uri.parse(image_uri)); 
            ByteArrayOutputStream buffer = 
              new ByteArrayOutputStream()) { 
                int nRead; 
                byte[] data = new byte[16384]; 
 
                while ((nRead = input.read(data, 0,  
                        data.length)) != -1) { 
                    buffer.write(data, 0, nRead); 
                } 
 
                buffer.flush(); 
                participant.setThumbnail(Base64 
                    .encodeToString(buffer.toByteArray(),  
                        Base64.DEFAULT)); 
            } catch (IOException e) { 
                e.printStackTrace(); 
              } 
            } 
        } 
        phones.close(); 
        return participant; 
    } </pre>
<p class="mce-root">The preceding is the same type of query and cursor management that we saw earlier with conversations, but there is one exception. If the contact has a thumbnail, the query returns a <kbd class="calibre16">Uri</kbd> to that image. We can use <kbd class="calibre16">ContentResolver</kbd> to open an <kbd class="calibre16">InputStream</kbd> using that <kbd class="calibre16">Uri</kbd> to read the contents, which we load into <kbd class="calibre16">ByteArrayOutputStream</kbd>. Using Android's <kbd class="calibre16">Base64</kbd> class, we encode this binary image into a <kbd class="calibre16">String</kbd>, and add that to our <kbd class="calibre16">Participant</kbd> model. We saw the decoding half of this operation previously.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sending messages</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that we can see the conversations that we've been having, we need to add the ability to take part in those conversations--to send new text messages. We'll start on the client. We've actually already seen the handler for the <kbd class="calibre16">New Message</kbd> button assigned. It is as follows:</p>
<pre class="calibre21">    newMessageBtn.setOnAction(event -&gt; sendNewMessage()); </pre>
<p class="mce-root">What we need to do now is to look at this <kbd class="calibre16">sendNewMessage()</kbd> method itself:</p>
<pre class="calibre21">    private void sendNewMessage() { 
      Optional&lt;String&gt; result = SendMessageDialogController 
        .showAndWait(conversation.get()); 
      if (result.isPresent()) { 
        Conversation conv = conversation.get(); 
        Message message = new Message(); 
        message.setThreadId(conv.getThreadId()); 
        message.setAddress(conv.getParticipant()); 
        message.setBody(result.get()); 
        message.setMine(true); 
        if (cs.sendMessage(message)) { 
            conv.getMessages().add(message); 
            messages.add(message); 
        } else { 
            Alert alert = new Alert(AlertType.ERROR); 
            alert.setTitle("Error"); 
            alert.setHeaderText( 
                "An error occured while sending the message."); 
            alert.showAndWait(); 
        } 
      } 
    } </pre>
<p class="mce-root">The actual dialog is displayed in another window, so we have a separate FXML file, <kbd class="calibre16">message_dialog.fxml</kbd>, and controller, <kbd class="calibre16">SendMessageDialogController</kbd>. When the dialog closes, we check the return <kbd class="calibre16">Optional</kbd> to see if the user entered a message. If so, process the message as follows:</p>
<ol class="calibre18">
<li class="chapter">Get a reference to the selected <kbd class="calibre16">Conversation</kbd>.</li>
<li class="chapter">Create a new message, setting the conversation ID, recipient, and body.</li>
<li class="chapter">Using <kbd class="calibre16">ConversationService</kbd>, we attempt to send the message:
<ol class="calibre18">
<li class="chapter">If successful, we update the user interface with the new message.</li>
<li class="chapter">If unsuccessful, we display an error message.</li>
</ol>
</li>
</ol>
<p class="mce-root"><kbd class="calibre16">SendMessageController</kbd> works just like the other controllers we've looked at. The most interesting is the method <kbd class="calibre16">showAndWait()</kbd>. We'll use that method to show the dialog, wait for it to close, and return any user response to the caller. The dialog looks as follows:</p>
<div class="mce-root1"><img class="image-border86" src="Images/aa10e162-71fb-425f-9087-69c8e4abe267.png" width="752" height="398"/></div>
<p class="mce-root">The method looks as follows:</p>
<pre class="calibre21">    public static Optional&lt;String&gt; showAndWait( 
      Conversation conversation) { 
      try { 
        FXMLLoader loader =  
            new FXMLLoader(SendMessageDialogController.class 
                .getResource("/fxml/message_dialog.fxml")); 
        Stage stage = new Stage(); 
        stage.setScene(new Scene(loader.load())); 
        stage.setTitle("Send Text Message"); 
        stage.initModality(Modality.APPLICATION_MODAL); 
        final SendMessageDialogController controller =  
            (SendMessageDialogController) loader.getController(); 
        controller.setConversation(conversation); 
        stage.showAndWait(); 
        return controller.getMessage(); 
      } catch (IOException ex) { 
          throw new RuntimeException(ex); 
      } 
    } </pre>
<p class="mce-root">The first few lines in the preceding method are what we've normally seen, which is creating the loader and the <kbd class="calibre16">Stage</kbd>. Before showing the <kbd class="calibre16">Stage</kbd>, we set the modality, and pass in the current <kbd class="calibre16">Conversation</kbd>. Finally, we call <kbd class="calibre16">showAndWait()</kbd>, at which point the method blocks until the user closes the dialog, and then we return the entered message:</p>
<pre class="calibre21">    public Optional&lt;String&gt; getMessage() { 
      return Optional.ofNullable(message); 
    } </pre>
<p class="mce-root">A Java <kbd class="calibre16">Optional</kbd> is a <em class="calibre20">container object which may or may not contain a non-null value</em>. The value of <kbd class="calibre16">message</kbd> may or may not be set depending on which button is clicked in the dialog. Using the <kbd class="calibre16">Optional</kbd>, we can return a, possibly, null value, and handle it more safely in the caller--<kbd class="calibre16">if (result.isPresent())</kbd>.</p>
<p class="mce-root">The sending of the message is a simple POST operation in the <kbd class="calibre16">ConversationService</kbd>, which is as follows:</p>
<pre class="calibre21">    public boolean sendMessage(Message message) { 
      Response r = getWebTarget().path("conversations") 
        .request() 
        .header(HttpHeaders.AUTHORIZATION, 
          getAuthorizationHeader()) 
        .post(Entity.json(message)); 
      return r.getStatus() == Response.Status.CREATED 
        .getStatusCode(); 
    } </pre>
<p class="mce-root">The client side is simple, but what about the server side? Unsurprisingly, that's where the complexity lies:</p>
<pre class="calibre21">    @POST 
    @Path("conversations") 
    public Response sendMessage(Message message) throws<br class="calibre2"/>    InterruptedException { 
      final SmsManager sms = SmsManager.getDefault(); 
      final ArrayList&lt;String&gt; parts =  
        sms.divideMessage(message.getBody()); </pre>
<p class="mce-root">To add the endpoint, we define a new method with the correct annotations. This method will listen on the path <kbd class="calibre16">conversations</kbd> for <kbd class="calibre16">POST</kbd> requests, and expect a <kbd class="calibre16">Message</kbd> as its payload. The actual work of sending a message is handled by <kbd class="calibre16">SmsManager</kbd>, so we acquire a reference to the default manager. The next step calls <kbd class="calibre16">divideMessage()</kbd>, but what's that all about?</p>
<p class="mce-root">Text messages are technically limited to 160 characters. Twitter users are probably somewhat familiar with that already. Twitter limits tweets to 140 characters, leaving 20 characters for the sender's name. While Twitter has stuck hard to that limit, regular SMS users have a better experience. If the message is longer than 160 characters, most modern phones will chunk the message into 153 character segments when sending (with 7 characters for segmentation information used to piece the segments back together), which are merged back into one message on the receiving end if the phone supports it. The <kbd class="calibre16">SmsManager</kbd> API handles this complexity for us with <kbd class="calibre16">divideMessage()</kbd>.</p>
<p class="mce-root">Once the message is <em class="calibre20">chunked</em>, though, our job gets a little more difficult. We would like to be able to return a status code indicating whether or not the message was sent successfully. To do that, we need to check the status of each chunk of the message, be it one or ten. Sending a text message with <kbd class="calibre16">SmsManager</kbd>, Android broadcasts an <kbd class="calibre16">Intent</kbd> with the results. To react to that, we need to register a receiver. Put that all together, and we get this code:</p>
<pre class="calibre21">    final CountDownLatch sentLatch = new CountDownLatch(parts.size()); 
    final AtomicInteger statusCode = 
      new AtomicInteger( 
        Response.Status.CREATED.getStatusCode()); 
    final BroadcastReceiver receiver = new BroadcastReceiver() { 
      @Override 
      public void onReceive(Context context, Intent intent) { 
        if (getResultCode() != Activity.RESULT_OK) { 
          statusCode.set(Response.Status. 
           INTERNAL_SERVER_ERROR.getStatusCode()); 
        } 
        sentLatch.countDown(); 
      } 
    }; 
    deskDroidService.registerReceiver(receiver,  
      new IntentFilter("com.steeplesoft.deskdroid.SMS_SENT")); 
    ArrayList&lt;PendingIntent&gt; sentPIs = new ArrayList&lt;&gt;(); 
    for (int i = 0; i &lt; parts.size(); i++) { 
      sentPIs.add(PendingIntent.getBroadcast( 
        deskDroidService.getApplicationContext(), 0, 
        new Intent("com.steeplesoft.deskdroid.SMS_SENT"), 0)); 
    } 
    sms.sendMultipartTextMessage(message.getAddress(), null,<br class="calibre2"/>    parts, sentPIs, null); 
    sentLatch.await(5, TimeUnit.SECONDS); 
    deskDroidService.unregisterReceiver(receiver); 
    return Response.status(statusCode.get()).build(); </pre>
<p class="mce-root">To make sure that we've received the <kbd class="calibre16">Intent</kbd> for each message chunk, we start by creating a <kbd class="calibre16">CountDownLatch</kbd> with a count matching the number of chunks in the message. We also create an <kbd class="calibre16">AtomicInteger</kbd> to hold the status code. The reason we do this is that we need a final variable which we can access from our <kbd class="calibre16">BroadcastReceiver</kbd>, but we also need to be able to change the value. <kbd class="calibre16">AtomicInteger</kbd> allows us to do that.</p>
<p class="mce-root">We create and register a <kbd class="calibre16">BroadcastReceiver</kbd>, which analyzes the result code on <kbd class="calibre16">Intent</kbd>. If it's not <kbd class="calibre16">Activity.RESULT_OK</kbd>, we set <kbd class="calibre16">statusCode</kbd> to <kbd class="calibre16">INTERNAL_SERVER_ERROR</kbd>. Either way, we count down the latch.</p>
<p class="mce-root">With our receiver ready, we create a <kbd class="calibre16">List</kbd> of <kbd class="calibre16">PendingIntent</kbd>s, one for each chunk, then we pass that, with our list of message chunks, to <kbd class="calibre16">SmsManager.sendMultipartTextMessage()</kbd>. Message sending is asynchronous, so we call <kbd class="calibre16">sentLatch.await()</kbd> to wait for the results to be returned. We limit the wait to five seconds so that we don't wait forever. Once the wait time expires or the latch is cleared, we unregister our receiver and return the status code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting updates</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So far, we can see all of the conversations, view individual messages in a conversation, and send new messages. What we can't do yet is get updates when new messages arrive on the device, so let's implement that now, starting with the server piece this time.</p>
<p class="mce-root">To get a constant stream of events, we'll use a feature called Server-Sent Events, a W3C specification for receiving push notifications from the server. We enabled this feature in Jersey by registering the <kbd class="calibre16">SseFeature</kbd> in both the client and server setup steps. To create an SSE endpoint, we specify that the method returns the media type <kbd class="calibre16">SERVER_SENT_EVENTS</kbd>, and we return an <kbd class="calibre16">EventOutput</kbd> as the payload:</p>
<pre class="calibre21">    @GET 
    @Path("status") 
    @Produces(SseFeature.SERVER_SENT_EVENTS) 
    @Secure 
    public EventOutput streamStatus() { 
      final EventOutput eventOutput = new EventOutput(); 
      // ... 
      return eventOutput; 
    } </pre>
<p class="mce-root">From the Jersey documentation, we learn this:</p>
<div class="packt_quote">After the eventOutput is returned from the method, the Jersey runtime recognizes that this is a ChunkedOutput extension and does not close the client connection immediately. Instead, it writes the HTTP headers to the response stream and waits for more chunks (SSE events) to be sent. At this point the client can read headers and starts listening for individual events.</div>
<p class="mce-root">The server, then, keeps the socket to the client open, and pushes data down it. But where does the data come from? The Server-sent Event endpoints create a <kbd class="calibre16">Thread</kbd> that writes data to the <kbd class="calibre16">EventOutput</kbd> instance we created earlier. When the <kbd class="calibre16">Thread</kbd> is finished, it calls <kbd class="calibre16">eventOutput.close()</kbd>, which signals to the runtime that it is appropriate to close the client connection. To stream updates, our <kbd class="calibre16">Thread</kbd> looks as follows:</p>
<pre class="calibre21">    final Thread thread = new Thread() { 
      @Override 
      public void run() { 
        final LinkedBlockingQueue&lt;SmsMessage&gt; queue =  
          new LinkedBlockingQueue&lt;&gt;(); 
        BroadcastReceiver receiver = null; 
        try { 
          receiver = new BroadcastReceiver() { 
            @Override 
            public void onReceive(Context context,  
             Intent intent) { 
               Bundle intentExtras = intent.getExtras(); 
               if (intentExtras != null) { 
                 Object[] sms = (Object[])  
                  intentExtras.get("pdus"); 
                 for (int i = 0; i &lt; sms.length; ++i) { 
                   SmsMessage smsMessage =  
                     SmsMessage.createFromPdu( 
                       (byte[]) sms[i]); 
                       queue.add(smsMessage); 
                 } 
               } 
            } 
          }; 
          deskDroidService.registerReceiver(receiver, 
           new IntentFilter( 
             "android.provider.Telephony.SMS_RECEIVED")); 
          while (!eventOutput.isClosed()) { 
            SmsMessage message = queue.poll(5,  
             TimeUnit.SECONDS); 
            while (message != null) { 
              JSONObject json = new JSONObject() 
               .put("participant", message. 
                getDisplayOriginatingAddress()) 
               .put("body", message. 
                getDisplayMessageBody()); 
              eventOutput.write(new OutboundEvent.Builder() 
               .name("new-message") 
               .data(json.toString()) 
               .build() 
              ); 
              message = queue.poll(); 
            } 
          } 
        } catch (JSONException | InterruptedException |  
           IOException e) { 
          } finally { 
              try { 
                if (receiver != null) { 
                  deskDroidService.unregisterReceiver(receiver); 
                } 
                eventOutput.close(); 
              } catch (IOException ioClose) { 
                  // ... 
                } 
            } 
      } 
    }; 
    thread.setDaemon(true); 
    thread.start(); </pre>
<p class="mce-root">As we've seen before, we set up a <kbd class="calibre16">BroadcastReceiver</kbd>, which we register here and unregister before the <kbd class="calibre16">Thread</kbd> ends, but this time, we're listening for broadcasts that an SMS message has been received. To make sure our <kbd class="calibre16">Thread</kbd> isn't in a small, tight, fast loop, which would quickly kill the battery on the device, we use <kbd class="calibre16">LinkedBlockingQueue</kbd>. When a message is received, we pull the <kbd class="calibre16">SmsMessage</kbd>(s) from <kbd class="calibre16">Intent</kbd>, and add them to <kbd class="calibre16">queue</kbd>. In our while loop, we attempt to <kbd class="calibre16">take()</kbd> an item from <kbd class="calibre16">queue</kbd>. If we find one, we process it and any more that might either already be in the queue or be added while we are processing. Once <kbd class="calibre16">queue</kbd> is empty, we go back to waiting. We have a timeout on <kbd class="calibre16">take()</kbd> to make sure that the thread can respond to the exit criteria, most notably, the client disconnecting. This will run as long as the client remains connected. Let's look, then, at the client.</p>
<p class="mce-root">We encapsulated the details in <kbd class="calibre16">ConversationService.subscribeToNewMessageEvents()</kbd> as follows:</p>
<pre class="calibre21">    public void subscribeToNewMessageEvents( 
      Consumer&lt;Message&gt; callback) { 
        Thread thread = new Thread() { 
          @Override 
          public void run() { 
            stopListening = false; 
            EventInput eventInput = getWebTarget().path("status") 
             .request() 
             .header(HttpHeaders.AUTHORIZATION,  
              getAuthorizationHeader()) 
               .get(EventInput.class); 
            while (!eventInput.isClosed() &amp;&amp; !stopListening) { 
              final InboundEvent inboundEvent =  
                eventInput.read(); 
              if (inboundEvent == null) { 
                // connection has been closed 
                break; 
              } 
              if ("new-message".equals(inboundEvent.getName())){ 
                Message message =  
                  inboundEvent.readData(Message.class); 
                if (message != null) { 
                  callback.accept(message); 
                } 
              } 
            } 
          } 
        }; 
        thread.setDaemon(true); 
        thread.start(); 
    } </pre>
<p class="mce-root">In the preceding code, we create a <kbd class="calibre16">Thread</kbd>, in which we make the call to the SSE endpoint. The return type on the client is <kbd class="calibre16">EventInput</kbd>. We loop to process each incoming event, which we get as an <kbd class="calibre16">InboundEvent</kbd>. If it is null, then the connection has been closed, so we break out of our processing loop. If it is not null, we make sure that the event name matches what we're waiting for--<kbd class="calibre16">new-message</kbd>. If found, we extract the event payload, a <kbd class="calibre16">Message</kbd>, and call our callback, which we pass in as <kbd class="calibre16">Consumer&lt;Message&gt;</kbd>.</p>
<p class="mce-root">From the application proper, we subscribe to the status stream this way:</p>
<pre class="calibre21">    cs.subscribeToNewMessageEvents(this::handleMessageReceived); </pre>
<p class="mce-root"><kbd class="calibre16">handleMessageReceived()</kbd> looks like this:</p>
<pre class="calibre21">    protected void handleMessageReceived(final Message message) { 
      Platform.runLater(() -&gt; { 
        Optional&lt;Conversation&gt; optional = conversations.stream() 
          .filter(c -&gt; Objects.equal(c.getParticipant(),  
           message.getAddress())) 
          .findFirst(); 
        if (optional.isPresent()) { 
          Conversation c = optional.get(); 
          c.getMessages().add(message); 
          c.setSnippet(message.getBody()); 
          convList.refresh(); 
          if (c == conversation.get()) { 
            messages.setAll(c.getMessages()); 
            messageList.scrollTo(messages.size() - 1); 
          } 
        } else { 
            Conversation newConv = new Conversation(); 
            newConv.setParticipant(message.getAddress()); 
            newConv.setSnippet(message.getBody()); 
            newConv.setMessages(Arrays.asList(message)); 
            conversations.add(0, newConv); 
        } 
        final Taskbar taskbar = Taskbar.getTaskbar(); 
        if (taskbar.isSupported(Taskbar.Feature.USER_ATTENTION)) { 
          taskbar.requestUserAttention(true, false); 
        } 
        Toolkit.getDefaultToolkit().beep(); 
      }); 
    } </pre>
<p class="mce-root">The first step in handling this new message is very important--we pass a <kbd class="calibre16">Runnable</kbd> to <kbd class="calibre16">Platform.runLater()</kbd>. If we don't do this, any attempts to modify the user interface will fail. You have been warned. In our <kbd class="calibre16">Runnable</kbd>, we create a <kbd class="calibre16">Stream</kbd> of <kbd class="calibre16">Conversation</kbd>s, <kbd class="calibre16">filter()</kbd> it, looking for a <kbd class="calibre16">Conversation</kbd> whose participant matches the <kbd class="calibre16">Message</kbd> sender, then grab the first (and only) match.</p>
<p class="mce-root">If we find the <kbd class="calibre16">Conversation</kbd> in the list, we add this new <kbd class="calibre16">Message</kbd> to its list, and update the snippet (which is just the <kbd class="calibre16">Conversation</kbd>'s last message body). We also ask the <kbd class="calibre16">Conversation</kbd> list to <kbd class="calibre16">refresh()</kbd> itself to make sure the user interface reflects these changes. Finally, if the <kbd class="calibre16">Conversation</kbd> is the currently selected one, we update the message list and scroll to the bottom to make sure the new message shows.</p>
<p class="mce-root">If we don't find the <kbd class="calibre16">Conversation</kbd> in the list, we create a new one, and add it to the <kbd class="calibre16">ConversationObservable</kbd>, which results in the <kbd class="calibre16">List</kbd> automatically updating on the screen.</p>
<p class="mce-root">Finally, we attempt a couple of desktop integration tasks. If <kbd class="calibre16">Taskbar</kbd> supports the <kbd class="calibre16">USER_ATTENTION</kbd> feature, we request user attention. From the Javadocs we learn that, <em class="calibre20">depending on the platform, this may be visually indicated by a bouncing or flashing icon in the task area</em>. Regardless, we issue a beep to get the user's attention.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There's one last major piece that we haven't discussed, and that's security. Currently, anybody with the desktop application can, in theory, connect to your phone, see your messages, send others, and so on. Let's fix that now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Securing the endpoints</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To secure the REST server, we will use a filter just like we used in <a href="0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 25</a>, <em class="calibre20">Taking Notes with Monumentum</em>. We'll start by defining the annotation that will specify which endpoints need to be secured, as follows:</p>
<pre class="calibre21">    @NameBinding 
    @Retention(RetentionPolicy.RUNTIME) 
    @Target({ElementType.TYPE, ElementType.METHOD}) 
    public @interface Secure {} </pre>
<p class="mce-root">We will apply this preceding annotation to each secured endpoint (annotations condensed to one line for brevity):</p>
<pre class="calibre21">    @GET @Path("conversations") @Secure 
    public Response getConversations() { 
      ... 
      @POST @Path("conversations") @Secure 
      public Response sendMessage(Message message)  
       throws InterruptedException { 
         ... 
         @GET @Path("status") @Produces(SseFeature.SERVER_SENT_EVENTS)  
         @Secure 
         public EventOutput streamStatus() { 
           ... 
           @GET @Path("participants/{address}") @Secure 
           public Response getParticipant( 
             @PathParam("address") String address) { 
               ... </pre>
<p class="mce-root">We will also need a filter to enforce security, which we add as follows:</p>
<pre class="calibre21">    @Provider 
    @Secure 
    @Priority(Priorities.AUTHENTICATION) 
    public class SecureFilter implements ContainerRequestFilter { 
      private DeskDroidService deskDroidService; 
 
      public SecureFilter(DeskDroidService deskDroidService) { 
        this.deskDroidService = deskDroidService; 
      } 
 
      @Override 
      public void filter(ContainerRequestContext requestContext)  
        throws IOException { 
          try { 
            String authorizationHeader = requestContext. 
             getHeaderString(HttpHeaders.AUTHORIZATION); 
            String token = authorizationHeader. 
             substring("Bearer".length()).trim(); 
            final Key key = KeyGenerator. 
             getKey(deskDroidService.getApplicationContext()); 
            final JwtParser jwtParser =  
              Jwts.parser().setSigningKey(key); 
            jwtParser.parseClaimsJws(token); 
          } catch (Exception e) { 
              requestContext.abortWith(Response.status( 
                Response.Status.UNAUTHORIZED).build()); 
            } 
      } 
    } </pre>
<p class="mce-root">Much like in <a href="0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 25</a>, <em class="calibre20">Taking Notes with Monumentum</em>, we'll be using <strong class="calibre8">JSON Web Tokens</strong> (<strong class="calibre8">JWT</strong>) to help authenticate and authorize clients. In this filter, we extract the JWT from the request headers and validate it through these steps:</p>
<ol class="calibre18">
<li class="chapter">Get the signing key from <kbd class="calibre16">KeyGenerator</kbd>.</li>
<li class="chapter">Create the <kbd class="calibre16">JwtParser</kbd> using the signing key.</li>
<li class="chapter">Parse the claims in the JWT. For our purposes here, this is, basically, just a validation of the token itself.</li>
<li class="chapter">Abort the request with <kbd class="calibre16">UNAUTHORIZED</kbd> (<kbd class="calibre16">401</kbd>) should the token be invalid.</li>
</ol>
<p class="mce-root">The <kbd class="calibre16">KeyGenerator</kbd> itself looks a bit like what we saw in <a href="0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 25</a>, <em class="calibre20">Taking Notes with Monumentum</em>, but has been modified to use Android APIs in this manner:</p>
<pre class="calibre21">    public class KeyGenerator { 
      private static Key key; 
      private static final Object lock = new Object(); 
 
      public static Key getKey(Context context) { 
        synchronized (lock) { 
          if (key == null) { 
            SharedPreferences sharedPref =  
              context.getSharedPreferences( 
                context.getString( 
                  R.string.preference_deskdroid),  
                   Context.MODE_PRIVATE); 
                  String signingKey = sharedPref.getString( 
                    context.getString( 
                      R.string.preference_signing_key), null); 
                  if (signingKey == null) { 
                    signingKey = UUID.randomUUID().toString(); 
                    final SharedPreferences.Editor edit =  
                      sharedPref.edit(); 
                    edit.putString(context.getString( 
                      R.string.preference_signing_key), 
                       signingKey); 
                    edit.commit(); 
                  } 
                  key = new SecretKeySpec(signingKey.getBytes(),<br class="calibre2"/>                   0, signingKey.getBytes().length, "DES"); 
          } 
        } 
 
        return key; 
      } 
    } </pre>
<p class="mce-root">Since we might possibly receive requests from multiple clients at a time, we need to be careful about how the key is generated. To make sure it's done once and only once, we'll use the same type of synchronization/locking we saw in the server startup.</p>
<p class="mce-root">Once we've acquired the lock, we perform a null check to see if the process has already generated (or read) the key. If not, we then read the signing key from <kbd class="calibre16">SharedPreferences</kbd>. If it's null, we create a random string (here, just a UUID), and save it to <kbd class="calibre16">SharedPreferences</kbd> for reuse next time. Note that to save to Android preferences, we have to get an instance of <kbd class="calibre16">SharedPreferences.Editor</kbd>, write the string, then <kbd class="calibre16">commit()</kbd>. Once we have the signing key, we create the actual <kbd class="calibre16">SecretKeySpec</kbd> that we'll use to sign and verify our JWTs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Handling authorization requests</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With our endpoints now secured, we need a way for the clients to request authorization. To do that, we'll expose a new endpoint, unsecured, of course, as follows:</p>
<pre class="calibre21">    @POST 
    @Path("authorize") 
    @Consumes(MediaType.TEXT_PLAIN) 
    public Response getAuthorization(String clientCode) { 
      if (clientCode != null &amp;&amp;  
        clientCode.equals(deskDroidService.code)) { 
          String jwt = Jwts.builder() 
           .setSubject("DeskDroid") 
           .signWith(SignatureAlgorithm.HS512, 
            KeyGenerator.getKey( 
              deskDroidService.getApplicationContext())) 
               .compact(); 
          LocalBroadcastManager.getInstance( 
            deskDroidService.getApplicationContext()) 
           .sendBroadcast(new Intent( 
               DeskDroidService.CODE_ACCEPTED)); 
        return Response.ok(jwt).build(); 
      } 
      return Response.status(Response.Status.UNAUTHORIZED).build(); 
    } </pre>
<p class="mce-root">Rather than require a more complicated authorization system that might require a username and password or an OAuth2 provider, what we'll implement is a simple system that requires only a random number:</p>
<ol class="calibre18">
<li class="chapter">On the phone, the user requests that a new client be added, and is presented with a random number.</li>
<li class="chapter">In the desktop application, the user enters the number, which the desktop application then POSTs to the server.</li>
<li class="chapter">If the numbers match, the client is given a JWT, which it will send with every request.</li>
</ol>
<ol start="3" class="calibre18">
<li class="chapter">The JWT is verified each time to make sure the client is authorized to access the target resource.</li>
</ol>
<p class="mce-root">In this method, we get the number POSTed by the client (which we let JAX-RS extract from the request body), then compare it to the number generated on the phone. If they match, we create the JWT, and return it to the client. Before doing so, we broadcast an intent with the action <kbd class="calibre16">CODE_ACCEPTED</kbd>.</p>
<p class="mce-root">Where does the number come from, and why are we broadcasting this intent? We haven't looked at this in detail yet, but in the main layout, <kbd class="calibre16">activity_main.xml</kbd>, there is a <kbd class="calibre16">FloatingActionButton</kbd>. To this, we attach an <kbd class="calibre16">onClick</kbd> listener as follows:</p>
<pre class="calibre21">    FloatingActionButton fab =  
      (FloatingActionButton) findViewById(R.id.fab); 
    fab.setOnClickListener(new View.OnClickListener() { 
      @Override 
      public void onClick(View view) { 
        startActivityForResult(new Intent( 
          getApplicationContext(),  
          AuthorizeClientActivity.class), 1); 
      } 
    }); </pre>
<p class="mce-root">When the user taps on the button, the following screen will be shown:</p>
<div class="mce-root1"><img class="image-border87" src="Images/6ee9cc7e-5b78-4b88-a9eb-da7ab9851a8e.png" width="381" height="660"/></div>
<p class="mce-root">The client will use this information to connect and gain authorization. The <kbd class="calibre16">Activity</kbd> itself is fairly basic. It needs to present the IP address and code, and then respond to a client connecting. All of this is done in <kbd class="calibre16">onCreate()</kbd> in our new <kbd class="calibre16">AuthorizeClientActivity</kbd> class. We get the IP from <kbd class="calibre16">WifiManager</kbd>:</p>
<pre class="calibre21">    WifiManager wifiMgr = (WifiManager) getApplicationContext(). 
     getSystemService(WIFI_SERVICE); 
    String ipAddress = Formatter.formatIpAddress(wifiMgr. 
     getConnectionInfo().getIpAddress()); </pre>
<p class="mce-root">Remember that we require that the client be on a Wi-Fi network. The code is just a random, 6-digit number:</p>
<pre class="calibre21">    String code = Integer.toString(100000 +  
     new Random().nextInt(900000)); </pre>
<p class="mce-root">To listen for the <kbd class="calibre16">Intent</kbd> we saw earlier, which indicates that a client has been authenticated (which, presumably, will happen shortly after this <kbd class="calibre16">Activity</kbd> has been displayed), we register another receiver as follows:</p>
<pre class="calibre21">    messageReceiver = new BroadcastReceiver() { 
      @Override 
      public void onReceive(Context context, Intent intent) { 
        clientAuthenticated(); 
      } 
    }; 
    LocalBroadcastManager.getInstance(this).registerReceiver( 
      messageReceiver, new IntentFilter( 
        DeskDroidService.CODE_ACCEPTED)); </pre>
<p class="mce-root">We also need to tell the <kbd class="calibre16">Service</kbd> what this new code is so that it can verify it. To do that, we broadcast an <kbd class="calibre16">Intent</kbd> as follows:</p>
<pre class="calibre21">    Intent intent = new Intent(DeskDroidService.CODE_GENERATED); 
    intent.putExtra("code", code); 
    LocalBroadcastManager.getInstance(this).sendBroadcast(intent); </pre>
<p class="mce-root">We've already seen the other half of this broadcast in <kbd class="calibre16">DeskDroidService.onStartCommand()</kbd> earlier, where the code is retrieved from the <kbd class="calibre16">Intent</kbd>, and stored in the service for use by <kbd class="calibre16">DeskDroidResource.getAuthorization()</kbd>.</p>
<p class="mce-root">Finally, this method, which handles the authentication notice, simply cleans up the receiver and closes the <kbd class="calibre16">Activity</kbd>:</p>
<pre class="calibre21">    protected void clientAuthenticated() { 
      LocalBroadcastManager.getInstance(this). 
        unregisterReceiver(messageReceiver); 
      setResult(2, new Intent()); 
      finish(); 
    } </pre>
<p class="mce-root">With this, when a client connects and successfully authenticates, the <kbd class="calibre16">Activity</kbd> closes, and the user is returned to the main <kbd class="calibre16">Activity</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Authorizing the client</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Up until this point, everything has assumed that the desktop is already connected to the phone. We have enough pieces in place now that we can talk about that in a meaningful manner.</p>
<p class="mce-root">In the application's main <kbd class="calibre16">Menu</kbd>, we have two <kbd class="calibre16">MenuItem</kbd>s: <kbd class="calibre16">Connect to Phone</kbd> and <kbd class="calibre16">Disconnect from Phone</kbd>. The <kbd class="calibre16">Connect to Phone</kbd> handler looks as follows:</p>
<pre class="calibre21">    @FXML 
    protected void connectToPhone(ActionEvent event) { 
      ConnectToPhoneController.showAndWait(); 
      if (!preferences.getToken().isEmpty()) { 
        refreshAndListen(); 
      } 
    } </pre>
<p class="mce-root">We're going to use the now-familiar <kbd class="calibre16">showAndWait()</kbd> pattern to display a modal dialog, and to get the response using the new <kbd class="calibre16">ConnectToPhoneController</kbd>. The user interface is very simple, and is shown in this screenshot:</p>
<div class="mce-root1"><img class="image-border88" src="Images/195ad74a-3937-4595-980c-321fd1d35bec.png" width="595" height="198"/></div>
<p class="mce-root">When the user clicks on <span class="calibre7">OK</span>, we save the address and the code in the application's preferences, then attempt to authorize against the server, as follows:</p>
<pre class="calibre21">    @FXML 
    public void connectToPhone(ActionEvent event) { 
      String address = phoneAddress.getText(); 
      String code = securityCode.getText(); 
      preferences.setPhoneAddress(address); 
      final ConversationService conversationService =  
        ConversationService.getInstance(); 
 
      conversationService.setPhoneAddress(address); 
      Optional&lt;String&gt; token = conversationService 
        .getAuthorization(code); 
      if (token.isPresent()) { 
        preferences.setToken(token.get()); 
        closeDialog(event); 
      } 
    } </pre>
<p class="mce-root">Notice the use of <kbd class="calibre16">Optional&lt;String&gt;</kbd> as the return type for <kbd class="calibre16">ConversationService.getAuthorization()</kbd>. Using <kbd class="calibre16">Optional</kbd>, as we've discussed before, makes working with potentially <kbd class="calibre16">null</kbd> values much safer. In this case, if <kbd class="calibre16">Optional</kbd> has a value present, then we've successfully authenticated. So, we save the token to preferences, and close the dialog.</p>
<p class="mce-root">The actual authentication is handled by <kbd class="calibre16">ConversationService</kbd>:</p>
<pre class="calibre21">    public Optional&lt;String&gt; getAuthorization(String code) { 
      Response response = getWebTarget().path("authorize") 
       .request(MediaType.APPLICATION_JSON) 
       .post(Entity.text(code)); 
      Optional&lt;String&gt; result; 
      if(response.getStatus()==Response.Status.OK.getStatusCode()) { 
        token = response.readEntity(String.class); 
        result = Optional.of(token); 
      } else { 
          result = Optional.empty(); 
      } 
      return result; 
    } </pre>
<p class="mce-root">This last method sends the code to the server via a <kbd class="calibre16">POST</kbd>, and if the status code is <kbd class="calibre16">200</kbd>, we create an <kbd class="calibre16">Optional</kbd> with the returned token. Otherwise, we return an empty <kbd class="calibre16">Optional</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we built a different kind of project. We've had applications that run on Android, and some that run on the desktop. This one, though, runs on both platforms simultaneously. One is no good without the other. That requires that we build things a bit differently to make sure the two are synchronized. While there are a variety of ways to go about this, we chose to use a REST server on the phone, with the desktop acting as a REST client.</p>
<p class="mce-root">By the end of the chapter, we built an Android application that provides not only a user interface, but a background process (called <kbd class="calibre16">Service</kbd>), and embedded our REST server in the Android application using Jersey and its Java SE deployment option. You also learned how to interact with text (SMS) messages on Android using the system-provided Content Providers and platform APIs, and streaming those messages to the client using Server-Sent Events. We demonstrated how to send messages between processes/threads in Android using <kbd class="calibre16">Intent</kbd>s, broadcasts, and <kbd class="calibre16">BroadcastReceiver</kbd>s. Finally, on the desktop side, we built a JavaFX client to display and send text messages, which connects to the REST server on the phone via the Jersey REST client, and we consumed the Server-sent Event stream, updating the user interface as appropriate.</p>
<p class="mce-root">With all of the moving parts, this was probably the most complex of our projects. It was certainly a great way to round out our list of projects. In the next chapter, we'll take a look at what's next for Java, as well as some other technologies that might be good to have on your radar.</p>


            </article>

            
        </section>
    </div>



  </body></html>