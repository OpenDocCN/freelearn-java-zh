- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Creational Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent decades, the IT community has experienced a dramatic shift from previously
    isolated systems to distributed or hybrid solutions. These approaches bring to
    light new possibilities for software development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Distribution solutions may appear to meet the migration needs of legacy systems,
    but the reality may prove otherwise. The required refactoring can cause additional
    problems due to the division of responsibilities or refactoring of tightly coupled
    logic and business rules and many unknown, hidden logics that are discovered too
    late to react to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore creational design patterns. These patterns
    play a vital role in the software composition. They are very useful for achieving
    maintainability or readability of the code base. Creational design patterns attempt
    to follow all the previously noted principles or the **don’t repeat yourself**
    (**DRY**) approach. Let’s dive deeper into specific patterns in the following
    order:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Applying the factory method pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating additional factories in encapsulation with the abstract factory
    pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a different configuration of object instances with the builder pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding a repeatedly complex configuration with the prototype pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining only one instance presence with the singleton pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up runtime with prepared objects by using the object pool pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling instances on demand with the lazy initialization pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the object instances with the dependency injection pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have built up a solid understanding of
    how to write maintainable code to create objects that can reside on the JVM’s
    heap or stack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with a class that becomes an object
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, every object must first be described by a class. Let us briefly introduce
    a common theoretical scenario of a software application. Such scenarios are often
    divided into the following parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Common application data process from a big picture](img/B18884_03_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Common application data process from a big picture
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The incoming input data stream (that is, the information flow) has been accepted
    by an application. The application processes the input and creates the result.
    The result is stored and subjected to the required targeting by a system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Such a system has the capability to satisfy several different processes under
    various conditions. The results are stored in several ways, such as a database
    or a file, or possibly embedded into an intended output stream, such as a web
    page, to display information to the user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The system acts as a reservoir of the incoming information flow, processes and
    stores it in the database, and provides the result. Most of the time, everything
    is tightly coupled and interconnected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Coupling has been happening on different levels, without the software designer
    noticing. The tight coherence was between classes, objects, or even packages.
    In many ways, it was possible to correct the application performance weaknesses
    with the more powerful hardware. The system’s evolution progressed more or less
    as a statistical observation of Moore’s law, which was published in 1965.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Moore’s law stated that each year, the number of components per integrated circuit
    doubles. The law was revised in 1975 to state that the number of components doubles
    every *two* years. Although the debate over the law’s validity may turn controversial,
    current trends (and the speed with which hardware upgrades are needed) show that
    the time for another review is coming. It may not be necessary worldwide to speed
    up the hardware upgrade (already so fast) because it may not have any effect on
    the speed of processing information. This observation addresses the feature requirements
    of a software application, focusing more on the quality and complexity of the
    implemented algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: It may not be possible to constantly increase the rate at which an object is
    instantiated due to physical limits, as such information must be physically stored
    in memory. It means that in the coming decades, we can expect an increase in pressure
    to improve the efficiency of software and design. To gain clarity of the application
    logic, it needs to be crystal clear how the application works, and moreover, how
    the application feeds the key JVM areas, namely, the method stack and heap followed
    by the thread utilization through the stack areas (as shown previously in *Figure
    2**.2*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Due to the current software applications’ trends focused on mapping, transforming,
    or managing a large amount of data, creational design patterns are worthwhile
    to study, understand, and learn how to deal with common scenarios. Although the
    time of the **Gang of Four** (**GoF**) book has passed, evolution is inevitable
    and the challenges remain. In many cases, with proper abstraction, the initial
    creational design patterns are applicable. Creating objects and class instances,
    and filling out the intended parts of the JVM, may drastically influence the computation
    and performance costs, as well as enforce business logic clarity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we discuss different possibilities for object creation.
    We will also consider the recently added Java syntactic features and possibilities,
    which should reduce the source code’s verbosity. Let us start with one of the
    most common patterns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects based on input with the factory method pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of this pattern is to centralize the class’s instantiation
    of a specific type. The pattern leaves the decision to create the exact class
    type up to the client at runtime. The factory method design pattern was described
    in the GoF’s book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern enforces the separation of code and its responsibility
    for creating new instances of the class, that is, such a method provides the expected
    result. The factory hides an application class hierarchy based on a generics abstraction
    and introduces a common interface. It transparently separates the instantiation
    logic from the rest of the code. By introducing the common interface, the client
    gains the freedom to decide on a particular class instance at runtime.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is often used in the early stages of an application because it is
    simple to refactor and provides a high level of clarity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Although this can introduce a bit of complexity, the pattern is easy to follow.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern is often utilized in the Java Collection framework
    to construct the desired type. The framework implementations reside in the `java.util`
    package of the `java.base` module. This package contains different implementations
    of `Set`, `List`, and `Map`. Although the `Map` type is a valid member of the
    Java Collection framework, it does not inherit the `Collection` interface as it
    implements `Map.Entry` to store element tuples, keys, and values. Each implementation
    of `Set`, `List`, and `Map` provides overloaded `of` factory method to create
    an instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The `Collections` class is a utility class. It contains several factory methods
    for creating specific collections, such as a list of individual items, a map,
    or a set. Another useful example of the factory method pattern usage is the `Executors`
    utility class, which can be found in the `java.util.concurrent` package of the
    `java.base` module. The `Executors` class defines static methods such as `newFixedThreadPool`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s imagine a simple straightforward example that is easily applicable in
    the real world using a suitable abstraction. The goal is to design an application
    that tracks vehicle production. Most likely, the company offers different types
    of vehicles. Each vehicle can be represented by its own object. To draw the intent,
    we created a **Unified Modeling Language** (**UML**) class diagram to maintain
    clarity (*Figure 3**.2*):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The vehicle production tracking example](img/B18884_03_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The vehicle production tracking example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The intended factory intends to produce two different types of vehicles, and
    the application fulfills the wishes on the fly (*Example 3.1*):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 3.1 – VehicleFactory produces vehicles of the same “family” based on
    input arguments
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of distributing the creation of such vehicle types over multiple places,
    we create a factory. The factory abstraction concentrates the whole vehicle composition
    process and exposes only one entry point that allows the client to create the
    desired vehicle type (as shown in *Example 3.2*). A factory only implements one
    static method, so it makes sense to keep its constructor private because factory
    instances are undesirable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 3.2 – The VehicleFactory class exposes the static factory method to
    produce an instance of the object that implements a Vehicle interface
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented `switch` expression may use the pattern-matching approach to
    simplify code instead of the traditional `switch-label-match` construct. The application
    provides multiple implementations of the vehicle (*Example 3.3*):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 3.3 – Each considered vehicle inherits the method abstractions through
    the Vehicle interface
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to another platform-syntactical improvement, the `records` type, it is
    possible to choose the level of the class encapsulation with the reflection of
    SOLID principles. It depends on how much the software architect intends to allow
    the vehicle instance to change its inner state. Let us first look at the standard
    Java class definition approach (*Example 3.4*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 3.4 – SuvCar allows adding inner fields that could hold a mutable state
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The software architect has the chance to use the `record` class to create immutable
    instances of the desired vehicle along with the `hashCode` and `equals` methods
    followed by the `toString` implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 3.5 – SportCar is considered to be immutable
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The recently introduced `record` feature reduces the potential boilerplate code
    base while still allowing internal functionality to be implemented (as discussed
    in the *Records (Java SE 16, JEP-395)* section of the previous chapter).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A factory method has some limitations. The most important one is that it can
    only be used for a specific family of objects. This means that all classes must
    maintain similar properties or common ground. The deviation from the base class
    of a class can introduce a dramatic strong coupling between the code and the application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The point to consider may be related to the method itself, as it may be static
    or belong to the instances (as covered in the previous chapter under *The* *stack
    area* and *The heap area* sections, respectively). This depends on the software
    designer’s decision.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The object of the one family is created. Let us investigate how to deal with
    factory families that share a common property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects from different families using the abstract factory pattern
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern introduces a factory abstraction without the requirement to define
    specific classes (or classes that should be instantiated). The client requests
    a proper factory that instantiates the object instead of attempting to create
    it. The abstract factory pattern was mentioned in the GoF’s book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modularizing applications can become a challenge. Software designers can avoid
    adding code to classes to preserve encapsulation. The motivation is to separate
    the factory logic from the application code so that it can supply the appropriate
    factory to produce the required objects. An abstract factory provides a standardized
    way to create an instance of the desired factory and deliver that instance to
    the client for use. The client uses the resulting factory to instantiate the object.
    Abstract factory provides an interface for creating both factories and objects
    without specifying their classes. The pattern implicitly supports SOLID principles
    and maintainability by isolating the logic of participants and insiders. The application
    is independent of how its products are created, composed, and represented.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory method pattern can be found in the JDK in the `java.xml`
    package of the `java.xml` module. The abstract factory pattern can be found in
    the representation and implementation of the `DocumentBuilderFactory` abstract
    class and its static `newInstance` method. The factory uses a lookup service to
    find the required builder implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider that although vehicles share some common features, their production
    requires different kinds of processes (*Figure 3**.3*):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Manufacturing different types of vehicles with the Abstract
    Factory pattern](img/B18884_03_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Manufacturing different types of vehicles with the Abstract Factory
    pattern
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, we create multiple factories responsible for specific objects.
    Although these classes belong to different families, they do have properties in
    common. An important feature is that each factory can implement its own initialization
    sequence while sharing generic logic. The example requires the correct `CarFactory`
    instance to create a `SlowCa`r object (*Example 3.6*):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 3.6 – The client decides which Vehicle type is required
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'A key element of the game is the factory provider; this distinguishes which
    factory is created based on incoming arguments (*Example 3.7*). The provider is
    implemented as a utility, so its class is final, and the constructor is private
    because instances are not required. Of course, the implementation may vary depending
    on the requirements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 3.7 – The FactoryProvider class defines how the particular factory of
    the object families is configured and instantiated
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Each factory from the group shares common logic or features to maintain the
    DRY approach in the code base:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 3.8 – The AbstractFactory class provides the common logic or methods
    that may require implementation by a specific factory
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'These individual factories can implement additional logic to distinguish which
    product should be delivered, similar to the `TruckFactory` and `CarFactory` implementations
    in the following example (*Example 3.9*):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 3.9 – The TruckFactory class represents the specific AbstractFactory
    implementation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.9 – TruckFactory类代表特定的抽象工厂实现
- en: Conclusion
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The abstract factory pattern provides consistency across products. Using a super
    factory can cause instability in the client runtime because the requested product
    can throw an exception or error due to incorrect implementation, as such information
    was not known on the fly. The abstract factory pattern, on the other hand, promotes
    testability. An abstract factory is free to represent the many other interfaces
    that came with its implementation. The pattern provides a common way to deal with
    products without depending on their implementation, which can improve the separation
    of concerns of application code. It can use interfaces or abstract classes. The
    client becomes independent of how objects are composed and created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式在产品之间提供一致性。使用超级工厂可能导致客户端运行时出现不稳定，因为请求的产品可能会由于实现不正确而抛出异常或错误，因为这种信息是在运行时才知道的。另一方面，抽象工厂模式促进了可测试性。抽象工厂可以自由地表示与其实现一起出现的许多其他接口。该模式提供了一种处理产品的方法，而不依赖于它们的实现，这可以提高应用程序代码的关注点分离。它可以使用接口或抽象类。客户端变得独立于对象的组合和创建方式。
- en: The benefit of encapsulating factories and code separation can be seen as a
    limitation. An abstract factory must be controlled by one or more parameters to
    properly define a dependency. To improve the code maintainability of the required
    factories, it may be useful to consider the previously discussed *sealed classes*
    enhancements (see the *Sealed classes (Java SE 17, JEP-409)* section in the previous
    chapter). Sealed classes can have a positive impact on code base stability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 封装工厂和代码分离的好处可以被视为一种限制。抽象工厂必须通过一个或多个参数来控制，以正确地定义依赖关系。为了提高所需工厂的代码可维护性，考虑之前讨论的*密封类*增强（参见前一章中的*密封类（Java
    SE 17，JEP-409）*部分）可能是有用的。密封类可以对代码库的稳定性产生积极影响。
- en: Let us examine how to customize an object creation process in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中考察如何自定义对象创建过程。
- en: Instantiating complex objects with the builder pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用建造者模式实例化复杂对象
- en: The builder pattern helps separate the construction of a complex object from
    its code representation so that the same composition process can be reused to
    create different configurations of an object type. The builder design pattern
    was identified early and is the part of GoF’s book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式有助于将复杂对象的构建与其代码表示分离，以便相同的组合过程可以重用来创建不同配置的对象类型。建造者设计模式被早期识别，并成为GoF书籍的一部分。
- en: Motivation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The main motivation behind the builder pattern is to construct complex instances
    without polluting the constructor. It helps to separate or even break down the
    creation process into specific steps. The composition of objects is transparent
    to the client and allows the creation of different configurations of the same
    type. The builder is represented by a separate class. It can help to transparently
    extend the constructor on demand. The pattern helps to encapsulate and enforce
    the clarity of the instantiation process with respect to the previously discussed
    SOLID design principles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式背后的主要动机是在不污染构造函数的情况下构建复杂实例。它有助于将创建过程分解成特定的步骤，甚至可以将其拆分。对象的组合对客户端是透明的，并允许创建同一类型的不同配置。建造者由一个单独的类表示。它可以帮助在需要时透明地扩展构造函数。该模式有助于封装并强制执行与之前讨论的SOLID设计原则相关的实例化过程的清晰度。
- en: Finding it in the JDK
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The builder pattern is a commonly used pattern inside the JDK. A great example
    is creating sequences of characters that represent a string. For example, `StringBuilder`
    and `StringBuffer` are located in the `java.lang` package of the `java.base` module,
    which is visible by default to every Java application. The string builder provides
    multiple overloaded connection methods that accept different types of input. Such
    input is concatenated with an already-created byte array. Another example can
    be found in the `java.net.http` package represented by the `HttpRequest.Builder`
    interface and its implementation or the `Stream.Builder` interface found in the
    `java.util.stream` package. As mentioned earlier, the builder pattern is very
    often used. Worth noting are `Locale.Builder` and `Calendar.Builder`, which use
    the setter methods to store values of the final product. Both can be found in
    the `java.util` package of the `java.based` module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The builder, which is the key element of the pattern, holds required field
    values during a `Vehicle` instance creation, more precisely, references to the
    objects (*Figure 3**.4*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – How to transparently make a new vehicle with the builder pattern](img/B18884_03_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – How to transparently make a new vehicle with the builder pattern
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall responsibility of the builder pattern is to create vehicles (*Example
    3.10*):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 3.10 – The builder pattern can be implemented in several ways, depending
    on the requirements
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The builder pattern may be implemented using different approaches. One approach
    is to encapsulate and hide all builder logic and provide a product directly without
    exposing implementation details:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 3.11 – The VehicleBuilder hides the logic in order to provide a particular
    instance
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Or the builder may become a part of the class for which the instance is intended
    to be created. In such a case, it is possible to decide which element should be
    added to the newly created specific instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 3.12 – The FastVehicle.Builder is represented as a static class and
    needs to be instantiated, and provides the possibility of final result customization
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Both example approaches are implemented according to SOLID principles. The builder
    pattern is a nice example of abstraction, polymorphism, inheritance, and encapsulation
    (APIE) principles and is very open to refactoring, extending, or validating properties.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder pattern helps enforce the single responsibility principle by separating
    complex creation from business logic. It also improves code readability and the
    DRY principle, as the instantiation is extensible and user-understandable. The
    builder pattern is a commonly used design pattern because it reduces “code smell”
    and constructor pollution. It also improves testability. The code base helps avoid
    multiple constructors with different representations, some of which have never
    been used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Another good point to consider while implementing a pattern is to use the JVM’s
    heap or stack – more specifically, to create a statically or dynamically allocated
    representation of the pattern. This decision is commonly answered by the software
    designers themselves.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It is not always necessary to reveal the construction process. The next section
    presents the simplicity of object cloning.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Cloning objects with the prototype pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype pattern solves the difficulty of creating new instances of an
    object with complicated instantiation process, which is too cumbersome and undesirable
    because it can lead to unnecessary subclassing. The prototype is a very common
    design pattern and was described in the GoF’s book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype design pattern becomes very useful when heavy objects need to
    be created and factories are an unwanted approach. The newly created instance
    is cloned from its parent because the parent acts as a prototype. Instances are
    independent of each other and can be customized. Instance logic is not exposed
    to, and cannot be contributed to by, the client.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many examples of using prototype patterns across JDK packages. The
    Collection framework members implement the `clone` method required by the inherited
    `Cloneable` interface. For example, an `ArrayList.clone()` method execution creates
    a shallow `List` copy of entities, field by field. Another prototype implementation
    could be the `Calendar` class from the `java.util` package of the `java.base`
    module. A clone of the overridden method is also used for the `Calendar` implementation
    itself, as it helps to avoid unwanted modification of an already configured one.
    Usage can be found in the `getActualMinimum` and `getActualMaximum` methods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When there are only a few vehicle models in production, there is no need to
    constantly establish new objects by factories or builders, which could actually
    lead to unwieldy code behavior as internal properties may change. Imagine the
    early stage of vehicle production where equality is required with each new iteration
    to track progress (*Figure 3**.5*):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Creating new instances from the prototype](img/B18884_03_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Creating new instances from the prototype
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, it is easier to create an exact copy of an already designed
    vehicle as its prototype:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 3.13 – A new vehicle can be cloned from the available instances
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The instances can be recreated (respectively, cloned) on demand. The `Vehicle`
    abstract class provides a foundation for each new prototype implementation and
    provides cloning details:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 3.14 – The Vehicle abstract class must implement a Cloneable interface
    and introduce the clone method implementation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Each vehicle implementation requires the extension of the parent `Vehicle`
    class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 3.15 – The Vehicle interface-specific implementation provided by the
    SlowCar class and the move method implementation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototype pattern introduces an internal cache that collects available
    `Vehicle` type prototypes (*Example 3.16*). The proposed implementation implements
    a static method to make the cache work as a tool. It makes sense for its constructor
    to be private:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 3.16 – VehicleCache holds the references to the already prepared prototypes
    that may be cloned
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The examples show that the client works each time with an identical copy of
    the base prototype. This copy may be customized based on the requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern is useful for dynamic loading or to avoid increasing the
    complexity of the code base by introducing unnecessary abstractions, known as
    **subclassing**. This does not mean that clones do not need to implement the interface,
    but cloning can reduce exposure requirements or make the instantiation process
    too complicated. A prototype properly encapsulates the complicated logic of an
    instance that is not meant to be touched or modified. Software designers should
    be aware of the possibility that such a code base can easily change to legacy
    code. On the other hand, a pattern can defer and support iterative changes to
    the code base.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Multiple instances of an object are not always desirable and are sometimes even
    undesirable. In the next section, we’ll learn how to guarantee the presence of
    only one unique class instance at runtime.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring only one instance with the singleton pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singleton object provides transparent and global access to its instance and
    ensures that only one instance is present. The singleton pattern was identified
    very early by industry requirements and is mentioned in the GoF’s book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A client or application wants to ensure that only one instance is present at
    runtime. An application may require multiple object instances that all use one
    unique resource. This fact introduces instability because any of these objects
    can access such a resource. A singleton guarantees only one instance that provides
    a global access point to all clients within the desired scope of the running JVM.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best example of using a singleton is a running Java application, or more
    precisely, the runtime. It is found in the `Runtime` class and its method, `getRuntime`,
    resides in the `java.lang` package of the `java.base` module. The method returns
    an object associated with the current Java application. The runtime instance allows
    the client to add, for example, shutdown hooks to the running application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example suggests an application that only runs one car with its
    engine (*Figure 3**.6*):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – How the Singleton pattern represents an engine](img/B18884_03_06.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – How the Singleton pattern represents an engine
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, this means that only one instance of a particular type of engine
    and vehicle must be present in the JVM:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 3.17 – One instance of OnlyEngine and OnlyCar is present at runtime
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of different ways to ensure that the instance of the object
    will be unique. The implementation of the `OnlyEngine` class introduces the possible
    singleton implementation where its instance is lazily created on demand (*Example
    3.18*). The `OnlyEngine` class implements the generic `Engine` interface. Its
    implementation provides a static `getInstance` method as a transparent entry point:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 3.18 – The OnlyEngine class checks the existence of its instance – lazy
    initiation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to implement a singleton is to create a `static` field that belongs
    to the class itself and expose a `getInstance` entry point to the potential client
    (*Example 3.19*). It is fair to note that, in such a case, the constructor becomes
    private:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example 3.19 – The OnlyVehicle class provides its instance as a static field
    that belongs to the class
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The lazily initialized singleton pattern implementation may become a challenge
    in a multithreaded environment where the `getInstance` method must be synchronized
    to obtain a unique instance. One possibility is to create a singleton as an `enum`
    class (*Example 3.20*):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 3.20 – The OnlyEngineEnum singleton enum class approach
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singleton is a relatively trivial design pattern, although it can get complicated
    when used inside a multithreading environment due to its guarantee that there
    will be only one instance of the required object. The pattern can be challenged
    when enforcing the principle of single responsibility since the class is actually
    responsible for instantiating itself. On the other hand, the singleton pattern
    ensures that clients can access allocated resources globally, preventing accidental
    object initialization or destruction. The pattern should be used wisely as it
    creates tightly coupled code in the manner of required class instantiations, which
    can tend to cause testability issues. The pattern also suppresses other subclasses,
    making any extension nearly impossible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Creating instances is not always a good approach. Let us examine how to do this
    on demand.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with the object pool pattern
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object pool pattern instantiates ready-to-use objects and limits their initialization
    time. The required instances can be recreated on demand. A pool of objects can
    represent a base of conditions on which new instances could be created, or limit
    their creation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of constantly creating new object instances over the code base, the
    object pool provides an encapsulated solution for managing application or client
    performance by serving an already initialized object ready for use. The pattern
    separates the build logic from the business code and helps manage the resource
    and performance aspects of the application. It may not only help with an object’s
    life cycle but also with validation when it is created or destroyed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nice example of the object pool pattern is the `ExecutorService` interface
    found in the `java.util.concurrent` package and the implementation provided by
    the `Executors` class of the `util` factory that handles the appropriate executor
    instances, for example, the `newScheduledThreadPool` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current example introduces a scenario where the garage contains a specific
    number of cars that drivers may drive (*Figure 3**.7*):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – A garage following the Object Pool pattern](img/B18884_03_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – A garage following the Object Pool pattern
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'When a car is not available, the garage has implemented a logic to buy a new
    one in order to keep all drivers busy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Example 3.21 – The pooling vehicles in the garage instance help reduce the cost
    of the object
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'A core element of the pattern is pool abstraction, as it contains all the required
    logic for managing entities. One option is to create an abstract garage pool class
    (*Example 3.22*) that contains all the synchronization mechanisms. These mechanisms
    are required to avoid potential code instability and inconsistency:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Example 3.22 – An abstract garage pool provides all the required logic to properly
    administrate elements
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The garage pool limits the possible instance types. A class is bound by the
    `Vehicle` abstraction (*Example 3.23*). The interface provides the common functions
    used by the client. In the following example, the implementation of `AbstractGaragePool`
    represents the client:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example 3.23 – The Vehicle interfaces need to be implemented by PooledVehicle
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to implementing functions, the `PooledVehicle` class provides a
    private counter (*Example 3.24*). A counter belongs to a class, so it is marked
    as `static` and `final`. The counter counts the number of instances purchased
    by the garage pool:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 3.24 – The PooledVehicle class implementation also holds the number
    of instances created
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improving client performance helps reduce the expensive object instantiation
    time (as we saw in *Example 3.21*). Object pools are also quite useful in cases
    where only short-lived objects are required, as they help reduce memory fragmentation
    by uncontrolled instances. It is worth touching upon the implementation of the
    internal cache pattern, as seen in the garage example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Although the pattern is quite efficient, the right choice of collection structure
    can also have a dramatic impact on its performance. It can reduce search and save
    time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Another positive outcome can be considered as the impact on the garbage collection
    process and memory compaction due to the analysis of active objects since there
    may be fewer objects to analyze.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: It is not always necessary to store everything in memory for later reuse. Let
    us examine how to postpone the object initialization process and not polluting
    memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Initiating objects on demand with the lazy initialization pattern
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern’s purpose is to defer an instance of the desired class instance
    until the client actually requests it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although operational memory has grown drastically over the years, we learned
    in the previous chapter that the JVM allocated a defined, specific size of memory
    reserved for the heap. When the heap is exhausted and the JVM is unable to allocate
    any new object, it causes an out of memory error. Lazy handling can have quite
    a positive impact on this heap pollution. It is sometimes also called asynchronous
    loading because of the delayed instance. The pattern has quite a nice use in a
    web application where the web page is generated on demand rather than during the
    application initialization process. It also has its place in an application, where
    the cost of operating the relevant object is high.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy initialization can be demonstrated using the example of dynamic loading
    by `ClassLoader` of classes that were not linked at runtime when the application
    was started. Classes can be loaded eagerly or deferred by the class policy. Certain
    classes, such as `ClassNotFoundException`, are loaded implicitly through the `java.base`
    module. They support the class implementation located in the `java.lang` package
    and its `forName` method. The implementation of the method is provided by an internal
    API. A lazy initiated class may be the reason the application requires a warm-up
    time. For example, `Enum` classes are a special type of static final classes that
    act as constants and are loaded eagerly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`->` refers to loading steps into the class loader and filling out the appropriate
    method area, as we learned in the previous chapter.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic idea of the lazy initialization example is that the created vehicle
    is initialized on demand or, when already created, a reference is provided to
    the client (*Figure 3**.8*):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern](img/B18884_03_08.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Such vehicles are present only if they are really required by the client. In
    such cases, specific vehicle instances are created. When a vehicle is already
    present inside the provider context, then such an instance is reused:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 3.25 – An example implementation of the pooled vehicle
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `VehicleProvider` class considers the fields private.
    Those fields hold the references to the desired vehicle if required. The provider
    encapsulates the decision and instantiation logic. One of the possible implementations
    may use the `switch-label-match` construct (*Example 3.26*), `switch` expressions,
    and so on. It’s good to point out that in this example, the `VehicleProvider`
    class requires an instance in the package scope, so its constructor is a `private`
    package and is not exposed to other packages:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 3.26 – VehicleProvider hides the possible entity instantiation logic
    from the client
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enforce the extendibility to the possible lazily initiated object,
    each entity implements the `Vehicle` abstraction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 3.27 – Vehicle abstraction and possible LazyVehicle implementation using
    record to enforce immutability
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Such an approach enforces continual vehicle evolution without complicated changes
    to the provider logic.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lazy initialization design pattern can help keep application memory small.
    Improper use, on the other hand, can cause unwanted delays, as objects can be
    too complex to create and take a significant amount of time to run.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to inject the logic into the client, represented
    by the newly created vehicle instance.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Reducing class dependencies with the dependency injection pattern
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern separates the initialization of the class (that *acts* as a service)
    from the client (that *uses* the service).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dependency injection pattern is widely used where there is a need to separate
    the implementation of a particular object (service) from the target object (client)
    that uses its exposed services, methods, and the like. Services are available
    when a client instance is to be created. The pattern allows you to eliminate any
    hardcoded dependencies. These services are instantiated outside of the client
    creation process. This means that the two are loosely connected, and SOLID principles
    can be enforced. There are three ways that dependency injection can be implemented:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor dependency injection**: Intended services are made available
    to the client through the initialization of the constructor.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Injection method**: The client exposes the method normally through an interface.
    Such a method supplies dependencies to the client. The supplier object uses a
    method to inject the service(s) into the client.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public` property.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good example of using the dependency injection pattern is the `ServiceLoader`
    utility class. It can be found in the `java.base` module and its `java.util` package.
    The `ServiceLoader` instance tries to find services during the application startup
    at runtime. A service is considered to be represented by a well-specified interface
    that is implemented by the relevant service provider or providers. The application
    code is able to distinguish the desired provider at runtime. It is good to note
    that `ServiceLoader` works with the classic `classpath` configuration or can be
    used seamlessly with the Java Platform Module System (discussed in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for* *Design Patterns*).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: In the past, dependency injection was part of the Java EE scope, not the classic
    JDK. This means that the feature was available on the Java platform. Due to the
    evolution of the JDK, the dependency injection features were moved to the `@Inject`,
    `@Named`, `@Scope`, or `@Qualifier` annotations. These annotations allow the class
    to be turned into a managed object at runtime, where the implementation of the
    desired provider can be distinguished.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example shows a simplified dependency injection pattern in order to receive
    a general experience. It is a very trivial implementation; in fact, it draws a
    picture of how the previously mentioned API works behind the scenes. Let’s imagine
    a scenario where the intended vehicle instance requires an engine (*Figure 3**.9*):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Injecting engine as a service to the vehicle instance](img/B18884_03_09.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Injecting engine as a service to the vehicle instance
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific engine construction logic is detached from vehicle-related code (*Example
    3.28*):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Example 3.28 – Creating an instance of FastEngine separately from the vehicle
    and then adding the engine to the constructed SportVehicle
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FastEngine` instance is used when it is fully ready (initiated, verified,
    and so on). The desired type of vehicle can be constructed independently without
    any dependence on engine logic. An engine instance is provided to `SportVehicle`
    using `EngineServiceProvider` (*Example 3.29*):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Example 3.29 – EngineServiceProvider registers instantiated reusable services
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SportVehicle` class implements the `Vehicle` interface (*Example 3.30*)
    in order to reflect the open-close approach mentioned as part of the SOLID design
    principles:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Example 3.30 – SportVehicle implements the Vehicle interface together with additional
    internal logic for the provided Engine instance
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that although a specific `Engine` type (*Example 3.31*)
    instance (`FastEngine`) is created somewhere else (*Example 3.28*, line `3`),
    its presence is required when the `SportVehicle` object is instantiated (*Example
    3.28*, line `5`):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Example 3.31 – Engine interfaces implemented by the FastEngine class and provided
    by EngineServiceProvider
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The key player object in the described example is `EngineServiceProvider`. It
    provides a reference to already created desired `Engine` instances and distributes
    them across the business code. This means that any client that needs to work on
    `Engine`, similar to the `SportVehicle` instance, will get access to the correct
    instance through the link exposed by `EngineServiceProvider`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented trivial example can be easily turned into another using the `ServiceProvider`
    utility class instance. The changes are very minimal (*Example 3.32*):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Example 3.32 – ServiceLoader provides an available implementation of the Engine
    interface used to instantiate the SportVehicle type
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In the standard classpath utilization, the Java platform requires service providers
    to be registered in the `META-INF` folder and the `services` subfolder. The filename
    is made up of the package and the service interface name, and the file contains
    the available service providers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The Java Platform Module System simplifies the configuration steps. The relevant
    modules provide (and make available service implementations to) the target modules,
    as we touched on in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*, Discovering
    the Java Platform for* *Design Patterns*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dependency injection pattern ensures that the client does not know about
    the instantiation of the used service. The client has access to the service through
    the common interfaces. It makes the code base better testable. It also simplifies
    the code base testability. Dependency injection is a widely used pattern by various
    frameworks, such as Spring and Quarkus. Quarkus uses the Jakarta Dependency Injection
    specification. The dependency injection pattern conforms to the SOLID and APIE
    object-oriented programming principles as it provides the abstraction of interfaces.
    The code does not depend on the implementation but communicates with the services
    through the interfaces. The dependency injection pattern enforces a DRY principle
    as it is not required to continually initiate a service.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns play a very important role in software application
    design. They help in transparently centralizing object instantiation logic with
    respect to basic object-oriented principles. The examples showed that each pattern
    may have multiple implementations. This is because the implementation decision
    may depend on other software architecture factors. Those factors take into account
    JVM heap and stack usage, application runtime, or business logic encapsulation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Using design patterns implicitly for authoring promotes a DRY approach, which
    has a positive impact on application development and reduces code base pollution.
    The application becomes testable and software architects have a framework to confirm
    the presence of expected objects inside the JVM. This becomes particularly important
    when a logic issue is identified, which could be an exception or unexpected results.
    A well-created code base helps to get into the root cause quite fast, maybe even
    without the necessity to debug.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create an object of a particular family
    using the transparent factory method pattern. The abstract factory pattern showed
    the encapsulated way of creating different factories types. Not all the required
    information is always present at one moment, and the builder pattern introduced
    a way to deal with such a challenge of composing complex objects. The prototype
    pattern showed the approach of not exposing the instance logic to the client,
    where the singleton pattern ensured the presence of a single instance at runtime.
    The object pool design pattern revealed how to improve memory usage at runtime,
    while the lazy instantiation pattern showed how to defer an object until it is
    needed. The dependency injection pattern demonstrated the reusability of instances
    when creating new objects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns not only bring clarity to the creation of new instances
    but, in many cases, they can also contribute to the decision about the correct
    structure of the code (a code structure that reflects the required business logic).
    The last three mentioned patterns solve not only the issue of creating objects
    but also their reusability for efficient memory use. The examples we covered showed
    us how creational patterns can be implemented and we learned about the differences
    and purposes of each of them.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss the structure design pattern. This pattern will
    help us organize our code based on the most common scenarios. Let’s move on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What challenges do the creational design patterns solve?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which patterns may be helpful to reduce object initiation costs?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the key reason to utilize the singleton design pattern?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which pattern helps to reduce constructor pollution?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you hide complex instantiation logic from the client?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to reduce the instantiation application memory footprint?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What design pattern is useful for creating objects of a specific family?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cramming more components onto integrated circuits* by Gordon E. Moore, Electronics
    Magazine, 1965-04-19'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Oracle Tutorials:* *Generics*: [https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quarkus* *Framework*: [https://quarkus.io/](https://quarkus.io/)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spring* *Framework*: [https://spring.io/](https://spring.io/)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jakarta Dependency* *Injection*: [https://jakarta.ee/specifications/dependency-injection/](https://jakarta.ee/specifications/dependency-injection/)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Code* by Robert C. Martin, Pearson Education, Inc, 2009'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Java – Third Edition* by Joshua Bloch, Addison-Wesley, 2018'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
