- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Working with Creational Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用创建型设计模式进行工作
- en: In recent decades, the IT community has experienced a dramatic shift from previously
    isolated systems to distributed or hybrid solutions. These approaches bring to
    light new possibilities for software development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，IT社区经历了从之前孤立的系统到分布式或混合解决方案的巨大转变。这些方法为软件开发带来了新的可能性。
- en: Distribution solutions may appear to meet the migration needs of legacy systems,
    but the reality may prove otherwise. The required refactoring can cause additional
    problems due to the division of responsibilities or refactoring of tightly coupled
    logic and business rules and many unknown, hidden logics that are discovered too
    late to react to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式解决方案可能看起来可以满足遗留系统的迁移需求，但现实可能并非如此。所需的重构可能会因为职责划分或紧密耦合的逻辑和业务规则的重构以及许多太晚发现而无法反应的未知隐藏逻辑而引起额外的问题。
- en: 'In this chapter, we will explore creational design patterns. These patterns
    play a vital role in the software composition. They are very useful for achieving
    maintainability or readability of the code base. Creational design patterns attempt
    to follow all the previously noted principles or the **don’t repeat yourself**
    (**DRY**) approach. Let’s dive deeper into specific patterns in the following
    order:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨创建型设计模式。这些模式在软件组成中起着至关重要的作用。它们对于实现代码库的可维护性或可读性非常有用。创建型设计模式试图遵循所有之前提到的原则或**不要重复自己**（**DRY**）的方法。让我们以下列顺序深入了解具体的模式：
- en: Applying the factory method pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用工厂方法模式
- en: Instantiating additional factories in encapsulation with the abstract factory
    pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在封装中实例化额外的工厂，使用抽象工厂模式
- en: Creating a different configuration of object instances with the builder pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用建造者模式创建不同配置的对象实例
- en: Avoiding a repeatedly complex configuration with the prototype pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用原型模式重复复杂的配置
- en: Examining only one instance presence with the singleton pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单例模式检查只有一个实例的存在
- en: Speeding up runtime with prepared objects by using the object pool pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用对象池模式使用预准备的对象来加快运行时
- en: Controlling instances on demand with the lazy initialization pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据按需初始化模式控制实例
- en: Reducing the object instances with the dependency injection pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖注入模式减少对象实例
- en: By the end of this chapter, you will have built up a solid understanding of
    how to write maintainable code to create objects that can reside on the JVM’s
    heap or stack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将建立起如何编写可维护的代码以创建可以驻留在JVM堆或栈上的对象的坚实基础。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03)。
- en: It all starts with a class that becomes an object
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有这一切都始于一个成为对象的类
- en: 'In Java, every object must first be described by a class. Let us briefly introduce
    a common theoretical scenario of a software application. Such scenarios are often
    divided into the following parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个对象都必须首先由一个类来描述。让我们简要介绍一个常见的软件应用理论场景。这些场景通常分为以下几部分：
- en: '![Figure 3.1 – Common application data process from a big picture](img/B18884_03_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 从宏观角度看的常见应用数据处理](img/B18884_03_01.jpg)'
- en: Figure 3.1 – Common application data process from a big picture
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 从宏观角度看的常见应用数据处理
- en: The incoming input data stream (that is, the information flow) has been accepted
    by an application. The application processes the input and creates the result.
    The result is stored and subjected to the required targeting by a system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 进入的输入数据流（即信息流）已被应用程序接受。应用程序处理输入并创建结果。结果被存储并受到系统所需的目标处理。
- en: Such a system has the capability to satisfy several different processes under
    various conditions. The results are stored in several ways, such as a database
    or a file, or possibly embedded into an intended output stream, such as a web
    page, to display information to the user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统具有在多种条件下满足几个不同过程的能力。结果以多种方式存储，例如数据库或文件，或者可能嵌入到预期的输出流中，如网页，以向用户显示信息。
- en: The system acts as a reservoir of the incoming information flow, processes and
    stores it in the database, and provides the result. Most of the time, everything
    is tightly coupled and interconnected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统充当 incoming information flow 的水库，将其处理并存储在数据库中，并提供结果。大多数时候，一切都是紧密耦合和相互关联的。
- en: Coupling has been happening on different levels, without the software designer
    noticing. The tight coherence was between classes, objects, or even packages.
    In many ways, it was possible to correct the application performance weaknesses
    with the more powerful hardware. The system’s evolution progressed more or less
    as a statistical observation of Moore’s law, which was published in 1965.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合在不同的层面上发生，而软件设计师并没有注意到。紧密的连贯性存在于类、对象甚至包之间。在许多方面，可以通过更强大的硬件来纠正应用性能的弱点。系统的演变大致上是一个对1965年发布的摩尔定律的统计观察，该定律于1965年发布。
- en: Moore’s law stated that each year, the number of components per integrated circuit
    doubles. The law was revised in 1975 to state that the number of components doubles
    every *two* years. Although the debate over the law’s validity may turn controversial,
    current trends (and the speed with which hardware upgrades are needed) show that
    the time for another review is coming. It may not be necessary worldwide to speed
    up the hardware upgrade (already so fast) because it may not have any effect on
    the speed of processing information. This observation addresses the feature requirements
    of a software application, focusing more on the quality and complexity of the
    implemented algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔定律指出，每年，每块集成电路的组件数量都会翻倍。该定律在1975年进行了修订，指出组件数量每*两*年翻倍。尽管关于该定律有效性的辩论可能会变得有争议，但当前的趋势（以及硬件升级所需的速度）表明，进行另一次审查的时间即将到来。在全球范围内，可能没有必要加快硬件升级（已经非常快）的速度，因为这可能对信息处理速度没有影响。这一观察结果针对的是软件应用的功能需求，更多地关注实现算法的质量和复杂性。
- en: It may not be possible to constantly increase the rate at which an object is
    instantiated due to physical limits, as such information must be physically stored
    in memory. It means that in the coming decades, we can expect an increase in pressure
    to improve the efficiency of software and design. To gain clarity of the application
    logic, it needs to be crystal clear how the application works, and moreover, how
    the application feeds the key JVM areas, namely, the method stack and heap followed
    by the thread utilization through the stack areas (as shown previously in *Figure
    2**.2*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物理限制，可能无法持续增加对象的实例化速率，因为此类信息必须物理存储在内存中。这意味着在未来的几十年里，我们可以预期提高软件和设计效率的压力会增加。为了使应用逻辑清晰，需要清楚地了解应用的工作方式，以及应用如何向关键
    JVM 区域提供支持，即方法栈和堆，然后是通过栈区域（如图2.2所示）的线程利用率。
- en: Due to the current software applications’ trends focused on mapping, transforming,
    or managing a large amount of data, creational design patterns are worthwhile
    to study, understand, and learn how to deal with common scenarios. Although the
    time of the **Gang of Four** (**GoF**) book has passed, evolution is inevitable
    and the challenges remain. In many cases, with proper abstraction, the initial
    creational design patterns are applicable. Creating objects and class instances,
    and filling out the intended parts of the JVM, may drastically influence the computation
    and performance costs, as well as enforce business logic clarity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前软件应用的趋势集中在映射、转换或管理大量数据上，因此值得研究、理解和学习如何处理常见场景的创建型设计模式。尽管《设计模式：可复用面向对象软件的基础》（**GoF**）一书的时代已经过去，但进化是不可避免的，挑战仍然存在。在许多情况下，通过适当的抽象，初始的创建型设计模式是适用的。创建对象和类实例，以及填充
    JVM 的预期部分，可能会极大地影响计算和性能成本，以及加强业务逻辑的清晰性。
- en: In the next section, we discuss different possibilities for object creation.
    We will also consider the recently added Java syntactic features and possibilities,
    which should reduce the source code’s verbosity. Let us start with one of the
    most common patterns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论对象创建的不同可能性。我们还将考虑最近添加的Java语法特性和可能性，这应该会减少源代码的冗长。让我们从一个最常见的模式开始。
- en: Creating objects based on input with the factory method pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于输入创建对象的工厂方法模式
- en: The primary purpose of this pattern is to centralize the class’s instantiation
    of a specific type. The pattern leaves the decision to create the exact class
    type up to the client at runtime. The factory method design pattern was described
    in the GoF’s book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的主要目的是集中化特定类型的类实例化。该模式将创建确切类类型的决策留给客户端在运行时决定。工厂方法设计模式在 GoF 的书中进行了描述。
- en: Motivation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The factory method pattern enforces the separation of code and its responsibility
    for creating new instances of the class, that is, such a method provides the expected
    result. The factory hides an application class hierarchy based on a generics abstraction
    and introduces a common interface. It transparently separates the instantiation
    logic from the rest of the code. By introducing the common interface, the client
    gains the freedom to decide on a particular class instance at runtime.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式强制将代码与其创建新实例的责任分离，也就是说，该方法提供了预期的结果。工厂隐藏了一个基于泛型抽象的应用程序类层次结构，并引入了一个公共接口。它透明地将实例化逻辑与代码的其他部分分离。通过引入公共接口，客户端在运行时可以自由地决定特定的类实例。
- en: The pattern is often used in the early stages of an application because it is
    simple to refactor and provides a high level of clarity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式通常在应用程序的早期阶段使用，因为它易于重构，并提供高清晰度。
- en: Although this can introduce a bit of complexity, the pattern is easy to follow.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能会引入一点复杂性，但模式很容易遵循。
- en: Finding it in the JDK
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The factory method pattern is often utilized in the Java Collection framework
    to construct the desired type. The framework implementations reside in the `java.util`
    package of the `java.base` module. This package contains different implementations
    of `Set`, `List`, and `Map`. Although the `Map` type is a valid member of the
    Java Collection framework, it does not inherit the `Collection` interface as it
    implements `Map.Entry` to store element tuples, keys, and values. Each implementation
    of `Set`, `List`, and `Map` provides overloaded `of` factory method to create
    an instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式经常在 Java 集合框架中用于构建所需类型。框架实现位于 `java.base` 模块的 `java.util` 包中。此包包含 `Set`、`List`
    和 `Map` 的不同实现。尽管 `Map` 类型是 Java 集合框架的有效成员，但它不继承 `Collection` 接口，因为它实现 `Map.Entry`
    来存储元素元组、键和值。`Set`、`List` 和 `Map` 的每个实现都提供了重载的 `of` 工厂方法来创建实例。
- en: The `Collections` class is a utility class. It contains several factory methods
    for creating specific collections, such as a list of individual items, a map,
    or a set. Another useful example of the factory method pattern usage is the `Executors`
    utility class, which can be found in the `java.util.concurrent` package of the
    `java.base` module. The `Executors` class defines static methods such as `newFixedThreadPool`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections` 类是一个实用工具类。它包含创建特定集合的几个工厂方法，例如单个项目的列表、映射或集合。工厂方法模式使用的另一个有用示例是
    `Executors` 实用工具类，该类位于 `java.base` 模块的 `java.util.concurrent` 包中。`Executors` 类定义了静态方法，如
    `newFixedThreadPool`。'
- en: Sample code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let’s imagine a simple straightforward example that is easily applicable in
    the real world using a suitable abstraction. The goal is to design an application
    that tracks vehicle production. Most likely, the company offers different types
    of vehicles. Each vehicle can be represented by its own object. To draw the intent,
    we created a **Unified Modeling Language** (**UML**) class diagram to maintain
    clarity (*Figure 3**.2*):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个简单直接且易于在现实世界中应用的示例，使用合适的抽象。目标是设计一个跟踪车辆生产的应用程序。公司很可能提供不同类型的车辆。每辆车都可以用其自身的对象来表示。为了绘制意图，我们创建了一个**统一建模语言**（**UML**）类图以保持清晰度（*图
    3**.2*）：
- en: '![Figure 3.2 – The vehicle production tracking example](img/B18884_03_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 车辆生产跟踪示例](img/B18884_03_02.jpg)'
- en: Figure 3.2 – The vehicle production tracking example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 车辆生产跟踪示例
- en: 'The intended factory intends to produce two different types of vehicles, and
    the application fulfills the wishes on the fly (*Example 3.1*):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目标工厂旨在生产两种不同类型的车辆，并且应用程序能够即时满足这些愿望（*示例 3.1*）：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 3.1 – VehicleFactory produces vehicles of the same “family” based on
    input arguments
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.1 – VehicleFactory 根据输入参数生产同一“家族”的车辆
- en: 'Instead of distributing the creation of such vehicle types over multiple places,
    we create a factory. The factory abstraction concentrates the whole vehicle composition
    process and exposes only one entry point that allows the client to create the
    desired vehicle type (as shown in *Example 3.2*). A factory only implements one
    static method, so it makes sense to keep its constructor private because factory
    instances are undesirable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将此类车辆类型的创建分散到多个地方，而是创建一个工厂。工厂抽象集中了整个车辆组合过程，并仅暴露一个入口点，允许客户端创建所需的车辆类型（如*示例
    3.2*所示）。工厂只实现一个静态方法，因此保持其构造函数为私有是有意义的，因为工厂实例是不希望的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 3.2 – The VehicleFactory class exposes the static factory method to
    produce an instance of the object that implements a Vehicle interface
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.2 – VehicleFactory类公开了静态工厂方法来生产实现Vehicle接口的对象实例
- en: 'The presented `switch` expression may use the pattern-matching approach to
    simplify code instead of the traditional `switch-label-match` construct. The application
    provides multiple implementations of the vehicle (*Example 3.3*):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的`switch`表达式可能使用模式匹配方法来简化代码，而不是传统的`switch-label-match`结构。应用程序提供了多种车辆实现（*示例
    3.3*）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 3.3 – Each considered vehicle inherits the method abstractions through
    the Vehicle interface
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.3 – 考虑到的每种车辆都通过Vehicle接口继承方法抽象
- en: 'Due to another platform-syntactical improvement, the `records` type, it is
    possible to choose the level of the class encapsulation with the reflection of
    SOLID principles. It depends on how much the software architect intends to allow
    the vehicle instance to change its inner state. Let us first look at the standard
    Java class definition approach (*Example 3.4*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于另一个平台语法改进，`records`类型，现在可以选择类封装的级别，通过SOLID原则的反射。这取决于软件架构师打算允许车辆实例改变其内部状态的程度。让我们首先看看标准的Java类定义方法（*示例
    3.4*）：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 3.4 – SuvCar allows adding inner fields that could hold a mutable state
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.4 – SuvCar允许添加可能包含可变状态的内部字段
- en: 'The software architect has the chance to use the `record` class to create immutable
    instances of the desired vehicle along with the `hashCode` and `equals` methods
    followed by the `toString` implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师有机会使用`record`类来创建所需车辆的不可变实例，以及随后的`hashCode`和`equals`方法，然后是`toString`实现：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 3.5 – SportCar is considered to be immutable
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.5 – 被认为是不可变的SportCar
- en: The recently introduced `record` feature reduces the potential boilerplate code
    base while still allowing internal functionality to be implemented (as discussed
    in the *Records (Java SE 16, JEP-395)* section of the previous chapter).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最近引入的`record`功能在减少潜在样板代码的同时，仍然允许实现内部功能（如前一章的*Records (Java SE 16, JEP-395)*部分所述）。
- en: Conclusion
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: A factory method has some limitations. The most important one is that it can
    only be used for a specific family of objects. This means that all classes must
    maintain similar properties or common ground. The deviation from the base class
    of a class can introduce a dramatic strong coupling between the code and the application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法有一些限制。其中最重要的一点是它只能用于特定家族的对象。这意味着所有类都必须保持相似的性质或共同的基础。一个类与基类之间的偏差可能会在代码和应用之间引入强烈的耦合。
- en: The point to consider may be related to the method itself, as it may be static
    or belong to the instances (as covered in the previous chapter under *The* *stack
    area* and *The heap area* sections, respectively). This depends on the software
    designer’s decision.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的点可能与方法本身有关，因为它可能是静态的或属于实例（如前一章在*栈区域*和*堆区域*部分所述）。这取决于软件设计师的决定。
- en: The object of the one family is created. Let us investigate how to deal with
    factory families that share a common property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个家族的对象。让我们研究如何处理具有共同属性的工厂家族。
- en: Creating objects from different families using the abstract factory pattern
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象工厂模式从不同的家族创建对象
- en: This pattern introduces a factory abstraction without the requirement to define
    specific classes (or classes that should be instantiated). The client requests
    a proper factory that instantiates the object instead of attempting to create
    it. The abstract factory pattern was mentioned in the GoF’s book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式引入了一个工厂抽象，而不需要定义特定的类（或应该实例化的类）。客户端请求一个适当的工厂来实例化对象，而不是尝试创建它。抽象工厂模式在GoF的书中被提及。
- en: Motivation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Modularizing applications can become a challenge. Software designers can avoid
    adding code to classes to preserve encapsulation. The motivation is to separate
    the factory logic from the application code so that it can supply the appropriate
    factory to produce the required objects. An abstract factory provides a standardized
    way to create an instance of the desired factory and deliver that instance to
    the client for use. The client uses the resulting factory to instantiate the object.
    Abstract factory provides an interface for creating both factories and objects
    without specifying their classes. The pattern implicitly supports SOLID principles
    and maintainability by isolating the logic of participants and insiders. The application
    is independent of how its products are created, composed, and represented.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序模块化可能是一个挑战。软件设计者可以通过避免向类中添加代码来保持封装性。动机是将工厂逻辑与应用程序代码分离，以便它可以提供适当的工厂来生成所需的对象。抽象工厂提供了一种标准化的方式来创建所需工厂的实例，并将该实例提供给客户端使用。客户端使用生成的工厂来实例化对象。抽象工厂提供了一个接口，用于创建工厂和对象，而不指定它们的类。该模式通过隔离参与者和内部人员的逻辑，隐式支持SOLID原则和可维护性。应用程序与其产品的创建、组合和表示方式无关。
- en: Finding it in the JDK
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The abstract factory method pattern can be found in the JDK in the `java.xml`
    package of the `java.xml` module. The abstract factory pattern can be found in
    the representation and implementation of the `DocumentBuilderFactory` abstract
    class and its static `newInstance` method. The factory uses a lookup service to
    find the required builder implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂方法模式可以在JDK的`java.xml`模块的`java.xml`包中找到。抽象工厂模式可以在`DocumentBuilderFactory`抽象类及其静态`newInstance`方法的表示和实现中找到。该工厂使用查找服务来找到所需的构建器实现。
- en: Sample code
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Consider that although vehicles share some common features, their production
    requires different kinds of processes (*Figure 3**.3*):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到虽然车辆有一些共同特性，但它们的制造需要不同类型的流程（*图3**.3*）：
- en: '![Figure 3.3 – Manufacturing different types of vehicles with the Abstract
    Factory pattern](img/B18884_03_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 使用抽象工厂模式制造不同类型的车辆](img/B18884_03_03.jpg)'
- en: Figure 3.3 – Manufacturing different types of vehicles with the Abstract Factory
    pattern
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 使用抽象工厂模式制造不同类型的车辆
- en: 'In such cases, we create multiple factories responsible for specific objects.
    Although these classes belong to different families, they do have properties in
    common. An important feature is that each factory can implement its own initialization
    sequence while sharing generic logic. The example requires the correct `CarFactory`
    instance to create a `SlowCa`r object (*Example 3.6*):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建多个负责特定对象的工厂。尽管这些类属于不同的家族，但它们确实有一些共同属性。一个重要特性是每个工厂都可以实现自己的初始化序列，同时共享通用逻辑。示例需要正确的`CarFactory`实例来创建一个`SlowCar`对象（*示例3.6*）：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 3.6 – The client decides which Vehicle type is required
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.6 – 客户端决定需要哪种车辆类型
- en: 'A key element of the game is the factory provider; this distinguishes which
    factory is created based on incoming arguments (*Example 3.7*). The provider is
    implemented as a utility, so its class is final, and the constructor is private
    because instances are not required. Of course, the implementation may vary depending
    on the requirements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的一个关键元素是工厂提供者；它根据传入的参数区分创建哪个工厂（*示例3.7*）。提供者实现为一个实用工具，因此其类是最终的，构造函数是私有的，因为不需要实例。当然，实现可能根据需求而有所不同：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 3.7 – The FactoryProvider class defines how the particular factory of
    the object families is configured and instantiated
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.7 – 工厂提供者类定义了对象家族的特定工厂的配置和实例化方式
- en: 'Each factory from the group shares common logic or features to maintain the
    DRY approach in the code base:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 组中的每个工厂都共享通用逻辑或特性，以在代码库中保持DRY（不要重复自己）方法：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 3.8 – The AbstractFactory class provides the common logic or methods
    that may require implementation by a specific factory
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.8 – 抽象工厂类提供了可能需要特定工厂实现的通用逻辑或方法
- en: 'These individual factories can implement additional logic to distinguish which
    product should be delivered, similar to the `TruckFactory` and `CarFactory` implementations
    in the following example (*Example 3.9*):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单独的工厂可以实现额外的逻辑来区分应该提供哪种产品，类似于以下示例中的`TruckFactory`和`CarFactory`实现（*示例3.9*）：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 3.9 – The TruckFactory class represents the specific AbstractFactory
    implementation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.9 – TruckFactory类代表特定的抽象工厂实现
- en: Conclusion
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The abstract factory pattern provides consistency across products. Using a super
    factory can cause instability in the client runtime because the requested product
    can throw an exception or error due to incorrect implementation, as such information
    was not known on the fly. The abstract factory pattern, on the other hand, promotes
    testability. An abstract factory is free to represent the many other interfaces
    that came with its implementation. The pattern provides a common way to deal with
    products without depending on their implementation, which can improve the separation
    of concerns of application code. It can use interfaces or abstract classes. The
    client becomes independent of how objects are composed and created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式在产品之间提供一致性。使用超级工厂可能导致客户端运行时出现不稳定，因为请求的产品可能会由于实现不正确而抛出异常或错误，因为这种信息是在运行时才知道的。另一方面，抽象工厂模式促进了可测试性。抽象工厂可以自由地表示与其实现一起出现的许多其他接口。该模式提供了一种处理产品的方法，而不依赖于它们的实现，这可以提高应用程序代码的关注点分离。它可以使用接口或抽象类。客户端变得独立于对象的组合和创建方式。
- en: The benefit of encapsulating factories and code separation can be seen as a
    limitation. An abstract factory must be controlled by one or more parameters to
    properly define a dependency. To improve the code maintainability of the required
    factories, it may be useful to consider the previously discussed *sealed classes*
    enhancements (see the *Sealed classes (Java SE 17, JEP-409)* section in the previous
    chapter). Sealed classes can have a positive impact on code base stability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 封装工厂和代码分离的好处可以被视为一种限制。抽象工厂必须通过一个或多个参数来控制，以正确地定义依赖关系。为了提高所需工厂的代码可维护性，考虑之前讨论的*密封类*增强（参见前一章中的*密封类（Java
    SE 17，JEP-409）*部分）可能是有用的。密封类可以对代码库的稳定性产生积极影响。
- en: Let us examine how to customize an object creation process in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中考察如何自定义对象创建过程。
- en: Instantiating complex objects with the builder pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用建造者模式实例化复杂对象
- en: The builder pattern helps separate the construction of a complex object from
    its code representation so that the same composition process can be reused to
    create different configurations of an object type. The builder design pattern
    was identified early and is the part of GoF’s book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式有助于将复杂对象的构建与其代码表示分离，以便相同的组合过程可以重用来创建不同配置的对象类型。建造者设计模式被早期识别，并成为GoF书籍的一部分。
- en: Motivation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The main motivation behind the builder pattern is to construct complex instances
    without polluting the constructor. It helps to separate or even break down the
    creation process into specific steps. The composition of objects is transparent
    to the client and allows the creation of different configurations of the same
    type. The builder is represented by a separate class. It can help to transparently
    extend the constructor on demand. The pattern helps to encapsulate and enforce
    the clarity of the instantiation process with respect to the previously discussed
    SOLID design principles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式背后的主要动机是在不污染构造函数的情况下构建复杂实例。它有助于将创建过程分解成特定的步骤，甚至可以将其拆分。对象的组合对客户端是透明的，并允许创建同一类型的不同配置。建造者由一个单独的类表示。它可以帮助在需要时透明地扩展构造函数。该模式有助于封装并强制执行与之前讨论的SOLID设计原则相关的实例化过程的清晰度。
- en: Finding it in the JDK
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The builder pattern is a commonly used pattern inside the JDK. A great example
    is creating sequences of characters that represent a string. For example, `StringBuilder`
    and `StringBuffer` are located in the `java.lang` package of the `java.base` module,
    which is visible by default to every Java application. The string builder provides
    multiple overloaded connection methods that accept different types of input. Such
    input is concatenated with an already-created byte array. Another example can
    be found in the `java.net.http` package represented by the `HttpRequest.Builder`
    interface and its implementation or the `Stream.Builder` interface found in the
    `java.util.stream` package. As mentioned earlier, the builder pattern is very
    often used. Worth noting are `Locale.Builder` and `Calendar.Builder`, which use
    the setter methods to store values of the final product. Both can be found in
    the `java.util` package of the `java.based` module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式在JDK内部是一种常用的模式。一个很好的例子是创建表示字符串的字符序列。例如，`StringBuilder`和`StringBuffer`位于`java.base`模块的`java.lang`包中，默认情况下对每个Java应用程序都是可见的。字符串构建器提供了多个重载的连接方法，这些方法接受不同类型的输入。这种输入与已创建的字节序列连接。另一个例子可以在`java.net.http`包中找到，它由`HttpRequest.Builder`接口及其实现或`java.util.stream`包中的`Stream.Builder`接口表示。如前所述，建造者模式非常常用。值得注意的是`Locale.Builder`和`Calendar.Builder`，它们使用setter方法存储最终产品的值。这两个都可以在`java.based`模块的`java.util`包中找到。
- en: Sample code
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The builder, which is the key element of the pattern, holds required field
    values during a `Vehicle` instance creation, more precisely, references to the
    objects (*Figure 3**.4*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者是模式的关键元素，在创建`Vehicle`实例期间持有所需的字段值，更确切地说，是对象的引用（*图 3**.4*）：
- en: '![Figure 3.4 – How to transparently make a new vehicle with the builder pattern](img/B18884_03_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 如何使用建造者模式透明地创建新车辆](img/B18884_03_04.jpg)'
- en: Figure 3.4 – How to transparently make a new vehicle with the builder pattern
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 如何使用建造者模式透明地创建新车辆
- en: 'The overall responsibility of the builder pattern is to create vehicles (*Example
    3.10*):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式的整体责任是创建车辆（*示例 3.10*）：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 3.10 – The builder pattern can be implemented in several ways, depending
    on the requirements
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.10 – 建造者模式可以根据需求以几种方式实现
- en: 'The builder pattern may be implemented using different approaches. One approach
    is to encapsulate and hide all builder logic and provide a product directly without
    exposing implementation details:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式可以通过不同的方法实现。一种方法是将所有建造者逻辑封装并隐藏，直接提供产品而不暴露实现细节：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 3.11 – The VehicleBuilder hides the logic in order to provide a particular
    instance
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.11 – `VehicleBuilder`隐藏逻辑以提供特定实例
- en: 'Or the builder may become a part of the class for which the instance is intended
    to be created. In such a case, it is possible to decide which element should be
    added to the newly created specific instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，建造者可能成为要创建实例的类的组成部分。在这种情况下，可以决定应该将哪个元素添加到新创建的特定实例中：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 3.12 – The FastVehicle.Builder is represented as a static class and
    needs to be instantiated, and provides the possibility of final result customization
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.12 – `FastVehicle.Builder`被表示为一个静态类，需要实例化，并提供最终结果定制的可能性
- en: Both example approaches are implemented according to SOLID principles. The builder
    pattern is a nice example of abstraction, polymorphism, inheritance, and encapsulation
    (APIE) principles and is very open to refactoring, extending, or validating properties.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 两种示例方法都是根据SOLID原则实现的。建造者模式是抽象、多态、继承和封装（APIE）原则的一个很好的例子，并且非常易于重构、扩展或验证属性。
- en: Conclusion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The builder pattern helps enforce the single responsibility principle by separating
    complex creation from business logic. It also improves code readability and the
    DRY principle, as the instantiation is extensible and user-understandable. The
    builder pattern is a commonly used design pattern because it reduces “code smell”
    and constructor pollution. It also improves testability. The code base helps avoid
    multiple constructors with different representations, some of which have never
    been used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式通过将复杂创建与业务逻辑分离，有助于强制执行单一职责原则。它还提高了代码可读性和DRY（Don't Repeat Yourself）原则，因为实例化是可扩展且易于用户理解的。建造者模式是一种常用的设计模式，因为它减少了“代码异味”和构造函数污染。它还提高了可测试性。代码库有助于避免具有不同表示形式的多个构造函数，其中一些从未被使用过。
- en: Another good point to consider while implementing a pattern is to use the JVM’s
    heap or stack – more specifically, to create a statically or dynamically allocated
    representation of the pattern. This decision is commonly answered by the software
    designers themselves.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现模式时，另一个值得考虑的好点是使用JVM的堆或栈——更具体地说，是创建模式的静态或动态分配表示。这个决定通常由软件设计师自己回答。
- en: It is not always necessary to reveal the construction process. The next section
    presents the simplicity of object cloning.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是有必要揭示构建过程。下一节将介绍对象克隆的简单性。
- en: Cloning objects with the prototype pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原型模式克隆对象
- en: The prototype pattern solves the difficulty of creating new instances of an
    object with complicated instantiation process, which is too cumbersome and undesirable
    because it can lead to unnecessary subclassing. The prototype is a very common
    design pattern and was described in the GoF’s book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式解决了创建具有复杂实例化过程的对象新实例的困难，因为其过程过于繁琐且不理想，可能会导致不必要的子类化。原型是一种非常常见的模式，并在GoF的书中进行了描述。
- en: Motivation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The prototype design pattern becomes very useful when heavy objects need to
    be created and factories are an unwanted approach. The newly created instance
    is cloned from its parent because the parent acts as a prototype. Instances are
    independent of each other and can be customized. Instance logic is not exposed
    to, and cannot be contributed to by, the client.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要创建重量级对象且工厂方法不受欢迎时，原型设计模式非常有用。新创建的实例是从其父实例克隆的，因为父实例充当原型。实例之间相互独立，可以定制。实例逻辑不会暴露给客户端，也不能由客户端贡献。
- en: Finding it in the JDK
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中查找
- en: There are many examples of using prototype patterns across JDK packages. The
    Collection framework members implement the `clone` method required by the inherited
    `Cloneable` interface. For example, an `ArrayList.clone()` method execution creates
    a shallow `List` copy of entities, field by field. Another prototype implementation
    could be the `Calendar` class from the `java.util` package of the `java.base`
    module. A clone of the overridden method is also used for the `Calendar` implementation
    itself, as it helps to avoid unwanted modification of an already configured one.
    Usage can be found in the `getActualMinimum` and `getActualMaximum` methods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK的各个包中有很多使用原型模式的例子。集合框架成员实现了继承自`Cloneable`接口所需的`clone`方法。例如，`ArrayList.clone()`方法的执行会逐字段创建实体的浅拷贝。另一个原型实现可以是`java.util`包中的`Calendar`类。对重写方法的克隆也用于`Calendar`实现本身，因为它有助于避免对已配置的实例进行不希望的修改。这种用法可以在`getActualMinimum`和`getActualMaximum`方法中找到。
- en: Sample code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'When there are only a few vehicle models in production, there is no need to
    constantly establish new objects by factories or builders, which could actually
    lead to unwieldy code behavior as internal properties may change. Imagine the
    early stage of vehicle production where equality is required with each new iteration
    to track progress (*Figure 3**.5*):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产中只有少数几种车辆型号时，没有必要通过工厂或构建器不断建立新对象，这实际上可能导致代码行为难以控制，因为内部属性可能会发生变化。想象一下车辆生产的早期阶段，其中每个新迭代都需要进行等量比较以跟踪进度（*图
    3**.5*）：
- en: '![Figure 3.5 – Creating new instances from the prototype](img/B18884_03_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 从原型创建新实例](img/B18884_03_05.jpg)'
- en: Figure 3.5 – Creating new instances from the prototype
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 从原型创建新实例
- en: 'In such cases, it is easier to create an exact copy of an already designed
    vehicle as its prototype:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建一个已经设计好的车辆的精确副本作为其原型更容易：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 3.13 – A new vehicle can be cloned from the available instances
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.13 – 可以从现有实例克隆出新的车辆
- en: 'The instances can be recreated (respectively, cloned) on demand. The `Vehicle`
    abstract class provides a foundation for each new prototype implementation and
    provides cloning details:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实例可以根据需要重新创建（分别，克隆）。`Vehicle`抽象类为每个新的原型实现提供了一个基础，并提供了克隆细节：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 3.14 – The Vehicle abstract class must implement a Cloneable interface
    and introduce the clone method implementation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.14 – 车辆抽象类必须实现`Cloneable`接口并引入克隆方法实现
- en: 'Each vehicle implementation requires the extension of the parent `Vehicle`
    class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个车辆实现都需要扩展父`Vehicle`类：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 3.15 – The Vehicle interface-specific implementation provided by the
    SlowCar class and the move method implementation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.15 – 由SlowCar类提供的车辆接口特定实现和移动方法实现
- en: 'The prototype pattern introduces an internal cache that collects available
    `Vehicle` type prototypes (*Example 3.16*). The proposed implementation implements
    a static method to make the cache work as a tool. It makes sense for its constructor
    to be private:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式引入了一个内部缓存，收集可用的 `Vehicle` 类型原型（*示例 3.16*）。所提出的实现实现了一个静态方法，使缓存作为一个工具工作。将其构造函数设为私有是有意义的：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 3.16 – VehicleCache holds the references to the already prepared prototypes
    that may be cloned
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.16 – VehicleCache 存储了对已准备的原型的引用，这些原型可以被克隆
- en: The examples show that the client works each time with an identical copy of
    the base prototype. This copy may be customized based on the requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例表明，客户端每次都使用基原型的相同副本进行工作。这个副本可以根据需求进行定制。
- en: Conclusion
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The prototype pattern is useful for dynamic loading or to avoid increasing the
    complexity of the code base by introducing unnecessary abstractions, known as
    **subclassing**. This does not mean that clones do not need to implement the interface,
    but cloning can reduce exposure requirements or make the instantiation process
    too complicated. A prototype properly encapsulates the complicated logic of an
    instance that is not meant to be touched or modified. Software designers should
    be aware of the possibility that such a code base can easily change to legacy
    code. On the other hand, a pattern can defer and support iterative changes to
    the code base.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式对于动态加载或避免通过引入不必要的抽象（称为**子类化**）来增加代码库的复杂性是有用的。这并不意味着克隆不需要实现接口，但克隆可以减少暴露需求或使实例化过程过于复杂。原型正确地封装了那些不打算被触摸或修改的实例的复杂逻辑。软件设计者应该意识到这样的代码库很容易变成遗留代码。另一方面，一个模式可以推迟并支持代码库的迭代更改。
- en: Multiple instances of an object are not always desirable and are sometimes even
    undesirable. In the next section, we’ll learn how to guarantee the presence of
    only one unique class instance at runtime.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的多个实例并不总是希望的，有时甚至是不希望的。在下一节中，我们将学习如何确保在运行时只有一个唯一的类实例存在。
- en: Ensuring only one instance with the singleton pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单例模式确保只有一个实例
- en: A singleton object provides transparent and global access to its instance and
    ensures that only one instance is present. The singleton pattern was identified
    very early by industry requirements and is mentioned in the GoF’s book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单例对象为其实例提供透明和全局访问，并确保只有一个实例存在。单例模式在行业需求提出得很早，并在 GoF 的书中被提及。
- en: Motivation
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: A client or application wants to ensure that only one instance is present at
    runtime. An application may require multiple object instances that all use one
    unique resource. This fact introduces instability because any of these objects
    can access such a resource. A singleton guarantees only one instance that provides
    a global access point to all clients within the desired scope of the running JVM.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端或应用程序想要确保在运行时只有一个实例存在。一个应用程序可能需要多个对象实例，这些实例都使用一个独特的资源。这个事实引入了不稳定性，因为任何这些对象都可以访问这样的资源。单例确保只有一个实例，为所有客户端提供全局访问点，在运行
    JVM 的期望范围内。
- en: Finding it in the JDK
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中找到它
- en: The best example of using a singleton is a running Java application, or more
    precisely, the runtime. It is found in the `Runtime` class and its method, `getRuntime`,
    resides in the `java.lang` package of the `java.base` module. The method returns
    an object associated with the current Java application. The runtime instance allows
    the client to add, for example, shutdown hooks to the running application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例的最佳例子是一个正在运行的 Java 应用程序，或者更确切地说，是运行时。它在 `Runtime` 类中，其方法 `getRuntime` 位于
    `java.base` 模块的 `java.lang` 包中。该方法返回与当前 Java 应用程序关联的对象。运行时实例允许客户端向运行中的应用程序添加，例如，关闭钩子。
- en: Sample code
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The following example suggests an application that only runs one car with its
    engine (*Figure 3**.6*):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例建议一个只运行一辆车及其引擎的应用程序（*图 3**.6*）：
- en: '![Figure 3.6 – How the Singleton pattern represents an engine](img/B18884_03_06.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 单例模式如何表示一个引擎](img/B18884_03_06.jpg)'
- en: Figure 3.6 – How the Singleton pattern represents an engine
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 单例模式如何表示一个引擎
- en: 'In other words, this means that only one instance of a particular type of engine
    and vehicle must be present in the JVM:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这意味着在 JVM 中必须存在特定类型的引擎和车辆的一个实例：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 3.17 – One instance of OnlyEngine and OnlyCar is present at runtime
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.17 – OnlyEngine 和 OnlyCar 在运行时只有一个实例
- en: 'There are a couple of different ways to ensure that the instance of the object
    will be unique. The implementation of the `OnlyEngine` class introduces the possible
    singleton implementation where its instance is lazily created on demand (*Example
    3.18*). The `OnlyEngine` class implements the generic `Engine` interface. Its
    implementation provides a static `getInstance` method as a transparent entry point:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对象实例唯一性的方法有多种。`OnlyEngine` 类的实现引入了可能的单例实现，其实例在需要时才会懒加载（*示例 3.18*）。`OnlyEngine`
    类实现了通用的 `Engine` 接口。其实现提供了一个静态的 `getInstance` 方法作为透明的入口点：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 3.18 – The OnlyEngine class checks the existence of its instance – lazy
    initiation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.18 – `OnlyEngine` 类检查其实例的存在 – 懒加载
- en: 'Another way to implement a singleton is to create a `static` field that belongs
    to the class itself and expose a `getInstance` entry point to the potential client
    (*Example 3.19*). It is fair to note that, in such a case, the constructor becomes
    private:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单例的另一种方法是创建一个属于类本身的 `static` 字段，并向潜在客户端公开 `getInstance` 入口点（*示例 3.19*）。值得注意的是，在这种情况下，构造函数变为私有：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example 3.19 – The OnlyVehicle class provides its instance as a static field
    that belongs to the class
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.19 – `OnlyVehicle` 类将其实例作为属于类的静态字段提供
- en: 'The lazily initialized singleton pattern implementation may become a challenge
    in a multithreaded environment where the `getInstance` method must be synchronized
    to obtain a unique instance. One possibility is to create a singleton as an `enum`
    class (*Example 3.20*):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，懒加载的单例模式实现可能会成为一个挑战，因为必须同步 `getInstance` 方法以获取唯一的实例。一种可能性是将单例创建为一个 `enum`
    类（*示例 3.20*）：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 3.20 – The OnlyEngineEnum singleton enum class approach
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.20 – 使用 `OnlyEngineEnum` 单例枚举类方法
- en: Conclusion
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Singleton is a relatively trivial design pattern, although it can get complicated
    when used inside a multithreading environment due to its guarantee that there
    will be only one instance of the required object. The pattern can be challenged
    when enforcing the principle of single responsibility since the class is actually
    responsible for instantiating itself. On the other hand, the singleton pattern
    ensures that clients can access allocated resources globally, preventing accidental
    object initialization or destruction. The pattern should be used wisely as it
    creates tightly coupled code in the manner of required class instantiations, which
    can tend to cause testability issues. The pattern also suppresses other subclasses,
    making any extension nearly impossible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一个相对简单的设计模式，尽管在多线程环境中使用时可能会变得复杂，因为它保证了所需对象只有一个实例。当强制执行单一责任原则时，该模式可能会受到挑战，因为类实际上负责实例化自己。另一方面，单例模式确保客户端可以全局访问分配的资源，防止意外初始化或销毁对象。该模式应谨慎使用，因为它以所需类实例化的方式创建了紧密耦合的代码，这可能导致可测试性问题。该模式还抑制了其他子类，使得任何扩展几乎都不可能。
- en: Creating instances is not always a good approach. Let us examine how to do this
    on demand.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实例并不总是好的方法。让我们看看如何按需进行。
- en: Improving performance with the object pool pattern
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象池模式提高性能
- en: The object pool pattern instantiates ready-to-use objects and limits their initialization
    time. The required instances can be recreated on demand. A pool of objects can
    represent a base of conditions on which new instances could be created, or limit
    their creation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式实例化了可用的对象，并限制了它们的初始化时间。所需的实例可以在需要时重新创建。对象池可以代表一个基础条件集，基于这些条件可以创建新的实例，或者限制它们的创建。
- en: Motivation
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Instead of constantly creating new object instances over the code base, the
    object pool provides an encapsulated solution for managing application or client
    performance by serving an already initialized object ready for use. The pattern
    separates the build logic from the business code and helps manage the resource
    and performance aspects of the application. It may not only help with an object’s
    life cycle but also with validation when it is created or destroyed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与在代码库中不断创建新的对象实例相比，对象池通过提供已初始化并准备好使用的对象，为管理应用程序或客户端性能提供了一个封装的解决方案。该模式将构建逻辑与业务代码分离，并有助于管理应用程序的资源性能方面。它不仅可以帮助管理对象的生命周期，还可以在创建或销毁时进行验证。
- en: Finding it in the JDK
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: A nice example of the object pool pattern is the `ExecutorService` interface
    found in the `java.util.concurrent` package and the implementation provided by
    the `Executors` class of the `util` factory that handles the appropriate executor
    instances, for example, the `newScheduledThreadPool` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式的一个很好的例子是 `java.util.concurrent` 包中找到的 `ExecutorService` 接口，以及 `util` 工厂中
    `Executors` 类提供的实现，该实现处理适当的执行器实例，例如 `newScheduledThreadPool` 方法。
- en: Sample code
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'The current example introduces a scenario where the garage contains a specific
    number of cars that drivers may drive (*Figure 3**.7*):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当前示例介绍了一个场景，其中车库包含一定数量的汽车，司机可以驾驶（*图 3**.7*）：
- en: '![Figure 3.7 – A garage following the Object Pool pattern](img/B18884_03_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 遵循对象池模式的车库](img/B18884_03_07.jpg)'
- en: Figure 3.7 – A garage following the Object Pool pattern
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 遵循对象池模式的车库
- en: 'When a car is not available, the garage has implemented a logic to buy a new
    one in order to keep all drivers busy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有汽车可用时，车库实现了一种逻辑，即购买一辆新车以保持所有司机忙碌：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Example 3.21 – The pooling vehicles in the garage instance help reduce the cost
    of the object
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.21 – 车库实例中的池化车辆有助于降低对象成本
- en: 'A core element of the pattern is pool abstraction, as it contains all the required
    logic for managing entities. One option is to create an abstract garage pool class
    (*Example 3.22*) that contains all the synchronization mechanisms. These mechanisms
    are required to avoid potential code instability and inconsistency:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的一个核心元素是池抽象，因为它包含管理实体所需的所有逻辑。一个选项是创建一个抽象车库池类（*示例 3.22*），其中包含所有同步机制。这些机制是必要的，以避免潜在的代码不稳定和不一致性：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Example 3.22 – An abstract garage pool provides all the required logic to properly
    administrate elements
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.22 – 抽象车库池提供了正确管理元素所需的所有逻辑
- en: 'The garage pool limits the possible instance types. A class is bound by the
    `Vehicle` abstraction (*Example 3.23*). The interface provides the common functions
    used by the client. In the following example, the implementation of `AbstractGaragePool`
    represents the client:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 车库池限制了可能的实例类型。一个类被 `Vehicle` 抽象绑定（*示例 3.23*）。该接口提供了客户端使用的常用函数。在以下示例中，`AbstractGaragePool`
    的实现代表客户端：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example 3.23 – The Vehicle interfaces need to be implemented by PooledVehicle
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.23 – 车辆接口需要由 PooledVehicle 实现
- en: 'In addition to implementing functions, the `PooledVehicle` class provides a
    private counter (*Example 3.24*). A counter belongs to a class, so it is marked
    as `static` and `final`. The counter counts the number of instances purchased
    by the garage pool:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现函数外，`PooledVehicle` 类还提供了一个私有计数器（*示例 3.24*）。计数器属于一个类，因此被标记为 `static` 和 `final`。该计数器统计车库池购买的实例数量：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 3.24 – The PooledVehicle class implementation also holds the number
    of instances created
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.24 – PooledVehicle 类实现还保留了创建的实例数量
- en: Conclusion
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Improving client performance helps reduce the expensive object instantiation
    time (as we saw in *Example 3.21*). Object pools are also quite useful in cases
    where only short-lived objects are required, as they help reduce memory fragmentation
    by uncontrolled instances. It is worth touching upon the implementation of the
    internal cache pattern, as seen in the garage example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 提高客户端性能有助于减少昂贵的对象实例化时间（如我们在 *示例 3.21* 中所见）。对象池在只需要短期对象的情况下也非常有用，因为它们有助于通过无控制的实例减少内存碎片。值得提及的是，车库示例中看到的内部缓存模式的实现。
- en: Although the pattern is quite efficient, the right choice of collection structure
    can also have a dramatic impact on its performance. It can reduce search and save
    time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该模式非常高效，但正确选择集合结构也会对其性能产生重大影响。它可以减少搜索并节省时间。
- en: Another positive outcome can be considered as the impact on the garbage collection
    process and memory compaction due to the analysis of active objects since there
    may be fewer objects to analyze.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个积极的结果可以考虑对垃圾收集过程和内存压缩的影响，因为分析活动对象可能会导致需要分析的对象更少。
- en: It is not always necessary to store everything in memory for later reuse. Let
    us examine how to postpone the object initialization process and not polluting
    memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是有必要将所有内容存储在内存中以供以后重用。让我们看看如何推迟对象初始化过程，并避免内存污染。
- en: Initiating objects on demand with the lazy initialization pattern
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用延迟初始化模式按需初始化对象
- en: This pattern’s purpose is to defer an instance of the desired class instance
    until the client actually requests it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的目的是将所需类实例的创建推迟到客户端实际请求时。
- en: Motivation
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Although operational memory has grown drastically over the years, we learned
    in the previous chapter that the JVM allocated a defined, specific size of memory
    reserved for the heap. When the heap is exhausted and the JVM is unable to allocate
    any new object, it causes an out of memory error. Lazy handling can have quite
    a positive impact on this heap pollution. It is sometimes also called asynchronous
    loading because of the delayed instance. The pattern has quite a nice use in a
    web application where the web page is generated on demand rather than during the
    application initialization process. It also has its place in an application, where
    the cost of operating the relevant object is high.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管近年来操作内存急剧增长，但我们上一章了解到 JVM 为堆分配了定义明确的特定大小的内存。当堆耗尽且 JVM 无法分配任何新对象时，会导致内存溢出错误。懒处理可以对这种堆污染产生相当积极的影响。由于延迟实例，它有时也被称为异步加载。在网页按需生成而不是在应用程序初始化过程中生成的
    Web 应用程序中，此模式非常有用。它也在成本较高的相关对象操作的应用程序中有其位置。
- en: Finding it in the JDK
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: Lazy initialization can be demonstrated using the example of dynamic loading
    by `ClassLoader` of classes that were not linked at runtime when the application
    was started. Classes can be loaded eagerly or deferred by the class policy. Certain
    classes, such as `ClassNotFoundException`, are loaded implicitly through the `java.base`
    module. They support the class implementation located in the `java.lang` package
    and its `forName` method. The implementation of the method is provided by an internal
    API. A lazy initiated class may be the reason the application requires a warm-up
    time. For example, `Enum` classes are a special type of static final classes that
    act as constants and are loaded eagerly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ClassLoader` 加载在应用程序启动时未在运行时链接的类的动态加载示例来演示懒初始化。类可以通过类策略预先加载或延迟加载。某些类，如
    `ClassNotFoundException`，通过 `java.base` 模块隐式加载。它们支持位于 `java.lang` 包及其 `forName`
    方法中的类实现。方法的实现由内部 API 提供。懒初始化的类可能是应用程序需要预热时间的原因。例如，`Enum` 类是一种特殊类型的静态最终类，充当常量，并且会预先加载。
- en: '`->` refers to loading steps into the class loader and filling out the appropriate
    method area, as we learned in the previous chapter.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 指的是将加载步骤放入类加载器并填充适当的方法区域，正如我们在上一章所学。'
- en: Sample code
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The basic idea of the lazy initialization example is that the created vehicle
    is initialized on demand or, when already created, a reference is provided to
    the client (*Figure 3**.8*):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 懒初始化示例的基本思想是创建的车辆按需初始化，或者当已经创建时，向客户端提供一个引用（*图 3**.8*）：
- en: '![Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern](img/B18884_03_08.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 如何使用懒加载模式按需创建车辆](img/B18884_03_08.jpg)'
- en: Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 如何使用懒加载模式按需创建车辆
- en: 'Such vehicles are present only if they are really required by the client. In
    such cases, specific vehicle instances are created. When a vehicle is already
    present inside the provider context, then such an instance is reused:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当客户端真正需要时，这些车辆才存在。在这种情况下，会创建特定的车辆实例。当车辆已经存在于提供者上下文中时，则重用该实例：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 3.25 – An example implementation of the pooled vehicle
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.25 – 池化车辆的示例实现
- en: 'The implementation of the `VehicleProvider` class considers the fields private.
    Those fields hold the references to the desired vehicle if required. The provider
    encapsulates the decision and instantiation logic. One of the possible implementations
    may use the `switch-label-match` construct (*Example 3.26*), `switch` expressions,
    and so on. It’s good to point out that in this example, the `VehicleProvider`
    class requires an instance in the package scope, so its constructor is a `private`
    package and is not exposed to other packages:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleProvider` 类的实现将字段视为私有。如果需要，这些字段持有所需车辆的引用。提供者封装了决策和实例化逻辑。可能的实现之一可能使用
    `switch-label-match` 构造（*示例 3.26*）、`switch` 表达式等。值得注意的是，在此示例中，`VehicleProvider`
    类需要一个包作用域的实例，因此其构造函数是 `private` 包，不对其他包公开：'
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 3.26 – VehicleProvider hides the possible entity instantiation logic
    from the client
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.26 – VehicleProvider隐藏了可能的实体实例化逻辑，使其对客户端不可见
- en: 'In order to enforce the extendibility to the possible lazily initiated object,
    each entity implements the `Vehicle` abstraction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制实现可能延迟初始化的对象的可扩展性，每个实体都实现了`Vehicle`抽象：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 3.27 – Vehicle abstraction and possible LazyVehicle implementation using
    record to enforce immutability
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3.27 – 使用record强制不可变性实现车辆抽象和可能的LazyVehicle实现
- en: Such an approach enforces continual vehicle evolution without complicated changes
    to the provider logic.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法强制执行持续的车辆进化，而不需要对供应商逻辑进行复杂的更改。
- en: Conclusion
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The lazy initialization design pattern can help keep application memory small.
    Improper use, on the other hand, can cause unwanted delays, as objects can be
    too complex to create and take a significant amount of time to run.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 懒初始化设计模式可以帮助保持应用程序内存小。另一方面，不当的使用可能会导致不希望的延迟，因为对象可能过于复杂而难以创建，并且运行时间较长。
- en: The next section shows how to inject the logic into the client, represented
    by the newly created vehicle instance.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分展示了如何将逻辑注入客户端，由新创建的车辆实例表示。
- en: Reducing class dependencies with the dependency injection pattern
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入模式减少类依赖
- en: This pattern separates the initialization of the class (that *acts* as a service)
    from the client (that *uses* the service).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将类（*作为*服务）的初始化与客户端（*使用*服务）的初始化分开。
- en: Motivation
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: 'The dependency injection pattern is widely used where there is a need to separate
    the implementation of a particular object (service) from the target object (client)
    that uses its exposed services, methods, and the like. Services are available
    when a client instance is to be created. The pattern allows you to eliminate any
    hardcoded dependencies. These services are instantiated outside of the client
    creation process. This means that the two are loosely connected, and SOLID principles
    can be enforced. There are three ways that dependency injection can be implemented:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式在需要将特定对象（服务）的实现与使用其公开服务、方法等的目标对象（客户端）分离时被广泛使用。当需要创建客户端实例时，服务可用。该模式允许您消除任何硬编码的依赖。这些服务是在客户端创建过程之外实例化的。这意味着两者之间是松散连接的，可以强制执行SOLID原则。实现依赖注入有三种方式：
- en: '**Constructor dependency injection**: Intended services are made available
    to the client through the initialization of the constructor.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数依赖注入**：通过构造函数的初始化，将预期服务提供给客户端。'
- en: '**Injection method**: The client exposes the method normally through an interface.
    Such a method supplies dependencies to the client. The supplier object uses a
    method to inject the service(s) into the client.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入方法**：客户端通过接口正常暴露方法。该方法向客户端提供依赖。供应商对象使用方法将服务注入客户端。'
- en: '`public` property.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`属性。'
- en: Finding it in the JDK
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中查找
- en: A good example of using the dependency injection pattern is the `ServiceLoader`
    utility class. It can be found in the `java.base` module and its `java.util` package.
    The `ServiceLoader` instance tries to find services during the application startup
    at runtime. A service is considered to be represented by a well-specified interface
    that is implemented by the relevant service provider or providers. The application
    code is able to distinguish the desired provider at runtime. It is good to note
    that `ServiceLoader` works with the classic `classpath` configuration or can be
    used seamlessly with the Java Platform Module System (discussed in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for* *Design Patterns*).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入模式的良好例子是`ServiceLoader`实用类。它位于`java.base`模块和其`java.util`包中。`ServiceLoader`实例在应用启动时尝试在运行时查找服务。一个服务被认为是由相关服务提供者或提供者实现的良好定义的接口表示。应用程序代码能够在运行时区分所需的提供者。值得注意的是，`ServiceLoader`与经典的`classpath`配置一起工作，或者可以无缝地与Java平台模块系统（在第[*第2章*](B18884_02.xhtml#_idTextAnchor037)，*发现Java平台设计模式*中讨论）一起使用。
- en: In the past, dependency injection was part of the Java EE scope, not the classic
    JDK. This means that the feature was available on the Java platform. Due to the
    evolution of the JDK, the dependency injection features were moved to the `@Inject`,
    `@Named`, `@Scope`, or `@Qualifier` annotations. These annotations allow the class
    to be turned into a managed object at runtime, where the implementation of the
    desired provider can be distinguished.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，依赖注入是 Java EE 范围的一部分，而不是经典 JDK。这意味着该功能在 Java 平台上可用。由于 JDK 的发展，依赖注入功能被移动到
    `@Inject`、`@Named`、`@Scope` 或 `@Qualifier` 注解。这些注解允许在运行时将类转换为托管对象，从而可以区分所需提供者的实现。
- en: Sample code
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'An example shows a simplified dependency injection pattern in order to receive
    a general experience. It is a very trivial implementation; in fact, it draws a
    picture of how the previously mentioned API works behind the scenes. Let’s imagine
    a scenario where the intended vehicle instance requires an engine (*Figure 3**.9*):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例展示了简化后的依赖注入模式，以便获得一般经验。这是一个非常简单的实现；实际上，它描绘了之前提到的 API 在幕后是如何工作的。让我们想象一个场景，其中预期的车辆实例需要一个引擎（*图
    3**.9*）：
- en: '![Figure 3.9 – Injecting engine as a service to the vehicle instance](img/B18884_03_09.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 将引擎作为服务注入到车辆实例中](img/B18884_03_09.jpg)'
- en: Figure 3.9 – Injecting engine as a service to the vehicle instance
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 将引擎作为服务注入到车辆实例中
- en: 'Specific engine construction logic is detached from vehicle-related code (*Example
    3.28*):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的引擎构建逻辑与车辆相关代码分离（*示例 3.28*）：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Example 3.28 – Creating an instance of FastEngine separately from the vehicle
    and then adding the engine to the constructed SportVehicle
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.28 – 从车辆之外单独创建 FastEngine 实例，然后将引擎添加到构建的 SportVehicle 中
- en: 'The `FastEngine` instance is used when it is fully ready (initiated, verified,
    and so on). The desired type of vehicle can be constructed independently without
    any dependence on engine logic. An engine instance is provided to `SportVehicle`
    using `EngineServiceProvider` (*Example 3.29*):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当`FastEngine`实例完全就绪（已启动、已验证等）时使用。所需类型的车辆可以独立构建，无需依赖任何引擎逻辑。使用`EngineServiceProvider`（*示例
    3.29*）为`SportVehicle`提供引擎实例：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Example 3.29 – EngineServiceProvider registers instantiated reusable services
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.29 – EngineServiceProvider 注册已实例化的可重用服务
- en: 'The `SportVehicle` class implements the `Vehicle` interface (*Example 3.30*)
    in order to reflect the open-close approach mentioned as part of the SOLID design
    principles:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`SportVehicle` 类实现 `Vehicle` 接口（*示例 3.30*）以反映 SOLID 设计原则中提到的开放-封闭方法：'
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Example 3.30 – SportVehicle implements the Vehicle interface together with additional
    internal logic for the provided Engine instance
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.30 – SportVehicle 类实现 Vehicle 接口，并包含为提供的 Engine 实例提供的附加内部逻辑
- en: 'It is important to note that although a specific `Engine` type (*Example 3.31*)
    instance (`FastEngine`) is created somewhere else (*Example 3.28*, line `3`),
    its presence is required when the `SportVehicle` object is instantiated (*Example
    3.28*, line `5`):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管在某个地方创建了特定的 `Engine` 类型（*示例 3.31*）实例（`FastEngine`），但在实例化 `SportVehicle`
    对象时需要其存在（*示例 3.28*，第 5 行）：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Example 3.31 – Engine interfaces implemented by the FastEngine class and provided
    by EngineServiceProvider
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.31 – FastEngine 类实现的 Engine 接口和由 EngineServiceProvider 提供的接口
- en: The key player object in the described example is `EngineServiceProvider`. It
    provides a reference to already created desired `Engine` instances and distributes
    them across the business code. This means that any client that needs to work on
    `Engine`, similar to the `SportVehicle` instance, will get access to the correct
    instance through the link exposed by `EngineServiceProvider`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在所描述的示例中的关键玩家对象是 `EngineServiceProvider`。它提供对已创建的所需 `Engine` 实例的引用，并将它们分布到业务代码中。这意味着任何需要处理
    `Engine`（类似于 `SportVehicle` 实例）的客户端，将通过 `EngineServiceProvider` 暴露的链接获得正确的实例访问权限。
- en: 'The presented trivial example can be easily turned into another using the `ServiceProvider`
    utility class instance. The changes are very minimal (*Example 3.32*):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的简单示例可以很容易地通过 `ServiceProvider` 工具类实例转换为另一个示例。更改非常微小（*示例 3.32*）：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Example 3.32 – ServiceLoader provides an available implementation of the Engine
    interface used to instantiate the SportVehicle type
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.32 – ServiceLoader 提供了用于实例化 SportVehicle 类型的 Engine 接口的可用实现
- en: In the standard classpath utilization, the Java platform requires service providers
    to be registered in the `META-INF` folder and the `services` subfolder. The filename
    is made up of the package and the service interface name, and the file contains
    the available service providers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的类路径利用中，Java平台要求服务提供者在`META-INF`文件夹和`services`子文件夹中注册。文件名由包和服务的接口名称组成，文件包含可用的服务提供者。
- en: The Java Platform Module System simplifies the configuration steps. The relevant
    modules provide (and make available service implementations to) the target modules,
    as we touched on in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*, Discovering
    the Java Platform for* *Design Patterns*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台模块系统简化了配置步骤。相关模块为（并为目标模块提供和使服务实现可用），正如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)*，发现Java平台设计模式*中提到的。
- en: Conclusion
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The dependency injection pattern ensures that the client does not know about
    the instantiation of the used service. The client has access to the service through
    the common interfaces. It makes the code base better testable. It also simplifies
    the code base testability. Dependency injection is a widely used pattern by various
    frameworks, such as Spring and Quarkus. Quarkus uses the Jakarta Dependency Injection
    specification. The dependency injection pattern conforms to the SOLID and APIE
    object-oriented programming principles as it provides the abstraction of interfaces.
    The code does not depend on the implementation but communicates with the services
    through the interfaces. The dependency injection pattern enforces a DRY principle
    as it is not required to continually initiate a service.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式确保客户端不知道所使用服务的实例化。客户端可以通过通用接口访问服务。这使得代码库更容易测试。它还简化了代码库的可测试性。依赖注入是各种框架（如Spring和Quarkus）广泛使用的模式。Quarkus使用Jakarta依赖注入规范。依赖注入模式符合SOLID和APIE面向对象编程原则，因为它提供了接口的抽象。代码不依赖于实现，而是通过接口与服务进行通信。依赖注入模式强制执行DRY原则，因为它不需要不断启动服务。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Creational design patterns play a very important role in software application
    design. They help in transparently centralizing object instantiation logic with
    respect to basic object-oriented principles. The examples showed that each pattern
    may have multiple implementations. This is because the implementation decision
    may depend on other software architecture factors. Those factors take into account
    JVM heap and stack usage, application runtime, or business logic encapsulation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式在软件应用设计中扮演着非常重要的角色。它们有助于根据基本的面向对象原则，透明地集中管理对象实例化逻辑。示例表明，每种模式可能有多种实现方式。这是因为实现决策可能取决于其他软件架构因素。这些因素考虑了JVM堆和栈的使用、应用程序运行时间或业务逻辑封装。
- en: Using design patterns implicitly for authoring promotes a DRY approach, which
    has a positive impact on application development and reduces code base pollution.
    The application becomes testable and software architects have a framework to confirm
    the presence of expected objects inside the JVM. This becomes particularly important
    when a logic issue is identified, which could be an exception or unexpected results.
    A well-created code base helps to get into the root cause quite fast, maybe even
    without the necessity to debug.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式使用设计模式进行创作，促进了DRY（Don't Repeat Yourself）方法，这对应用开发有积极影响，并减少了代码库的污染。应用程序变得可测试，软件架构师有一个框架来确认JVM内存在预期对象。当识别出逻辑问题时，这一点尤为重要，这可能是异常或意外结果。一个良好的代码库有助于快速找到根本原因，甚至可能不需要调试。
- en: In this chapter, we have learned how to create an object of a particular family
    using the transparent factory method pattern. The abstract factory pattern showed
    the encapsulated way of creating different factories types. Not all the required
    information is always present at one moment, and the builder pattern introduced
    a way to deal with such a challenge of composing complex objects. The prototype
    pattern showed the approach of not exposing the instance logic to the client,
    where the singleton pattern ensured the presence of a single instance at runtime.
    The object pool design pattern revealed how to improve memory usage at runtime,
    while the lazy instantiation pattern showed how to defer an object until it is
    needed. The dependency injection pattern demonstrated the reusability of instances
    when creating new objects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用透明工厂方法模式创建特定家族的对象。抽象工厂模式展示了创建不同工厂类型的封装方式。并非所有所需信息总是同时存在，而建造者模式介绍了一种处理这种复杂对象组合挑战的方法。原型模式展示了不向客户端暴露实例逻辑的方法，而单例模式确保了在运行时只有一个实例。对象池设计模式揭示了如何在运行时提高内存使用效率，而延迟实例化模式展示了如何将对象延迟到需要时再创建。依赖注入模式展示了在创建新对象时实例的可重用性。
- en: Creational design patterns not only bring clarity to the creation of new instances
    but, in many cases, they can also contribute to the decision about the correct
    structure of the code (a code structure that reflects the required business logic).
    The last three mentioned patterns solve not only the issue of creating objects
    but also their reusability for efficient memory use. The examples we covered showed
    us how creational patterns can be implemented and we learned about the differences
    and purposes of each of them.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创造性设计模式不仅使创建新实例的过程更加清晰，而且在许多情况下，它们还可以帮助决定正确的代码结构（反映所需业务逻辑的代码结构）。最后提到的三个模式不仅解决了创建对象的问题，还解决了它们在高效内存使用中的可重用性问题。我们讨论的例子展示了如何实现创造模式，并了解了每个模式的差异和目的。
- en: The next chapter will discuss the structure design pattern. This pattern will
    help us organize our code based on the most common scenarios. Let’s move on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论结构设计模式。这个模式将帮助我们根据最常见的场景来组织我们的代码。让我们继续前进。
- en: Questions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What challenges do the creational design patterns solve?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创造性设计模式解决了哪些挑战？
- en: Which patterns may be helpful to reduce object initiation costs?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些模式可能有助于减少对象初始化成本？
- en: What is the key reason to utilize the singleton design pattern?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用单例设计模式的关键原因是什么？
- en: Which pattern helps to reduce constructor pollution?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模式有助于减少构造函数污染？
- en: How do you hide complex instantiation logic from the client?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何隐藏复杂的实例化逻辑，使其对客户端不可见？
- en: Is it possible to reduce the instantiation application memory footprint?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有可能减少实例化应用程序的内存占用？
- en: What design pattern is useful for creating objects of a specific family?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个设计模式适用于创建特定家族的对象？
- en: Further reading
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计模式：可复用面向对象软件元素》* by Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides, Addison-Wesley, 1995'
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计原则与设计模式》* by Robert C. Martin, Object Mentor, 2000'
- en: '*Cramming more components onto integrated circuits* by Gordon E. Moore, Electronics
    Magazine, 1965-04-19'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《集成电路上的更多组件》* by Gordon E. Moore, Electronics Magazine, 1965-04-19'
- en: '*Oracle Tutorials:* *Generics*: [https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Oracle 教程：泛型*：[https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
- en: '*Quarkus* *Framework*: [https://quarkus.io/](https://quarkus.io/)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quarkus 框架*：[https://quarkus.io/](https://quarkus.io/)'
- en: '*Spring* *Framework*: [https://spring.io/](https://spring.io/)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring 框架*：[https://spring.io/](https://spring.io/)'
- en: '*Jakarta Dependency* *Injection*: [https://jakarta.ee/specifications/dependency-injection/](https://jakarta.ee/specifications/dependency-injection/)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jakarta 依赖注入*：[https://jakarta.ee/specifications/dependency-injection/](https://jakarta.ee/specifications/dependency-injection/)'
- en: '*Clean Code* by Robert C. Martin, Pearson Education, Inc, 2009'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码整洁之道》* by Robert C. Martin, Pearson Education, Inc, 2009'
- en: '*Effective Java – Third Edition* by Joshua Bloch, Addison-Wesley, 2018'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《有效Java – 第三版》* by Joshua Bloch, Addison-Wesley, 2018'
