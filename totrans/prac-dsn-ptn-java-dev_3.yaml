- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent decades, the IT community has experienced a dramatic shift from previously
    isolated systems to distributed or hybrid solutions. These approaches bring to
    light new possibilities for software development.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution solutions may appear to meet the migration needs of legacy systems,
    but the reality may prove otherwise. The required refactoring can cause additional
    problems due to the division of responsibilities or refactoring of tightly coupled
    logic and business rules and many unknown, hidden logics that are discovered too
    late to react to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore creational design patterns. These patterns
    play a vital role in the software composition. They are very useful for achieving
    maintainability or readability of the code base. Creational design patterns attempt
    to follow all the previously noted principles or the **don’t repeat yourself**
    (**DRY**) approach. Let’s dive deeper into specific patterns in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the factory method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating additional factories in encapsulation with the abstract factory
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a different configuration of object instances with the builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding a repeatedly complex configuration with the prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining only one instance presence with the singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up runtime with prepared objects by using the object pool pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling instances on demand with the lazy initialization pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the object instances with the dependency injection pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have built up a solid understanding of
    how to write maintainable code to create objects that can reside on the JVM’s
    heap or stack.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with a class that becomes an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, every object must first be described by a class. Let us briefly introduce
    a common theoretical scenario of a software application. Such scenarios are often
    divided into the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Common application data process from a big picture](img/B18884_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Common application data process from a big picture
  prefs: []
  type: TYPE_NORMAL
- en: The incoming input data stream (that is, the information flow) has been accepted
    by an application. The application processes the input and creates the result.
    The result is stored and subjected to the required targeting by a system.
  prefs: []
  type: TYPE_NORMAL
- en: Such a system has the capability to satisfy several different processes under
    various conditions. The results are stored in several ways, such as a database
    or a file, or possibly embedded into an intended output stream, such as a web
    page, to display information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The system acts as a reservoir of the incoming information flow, processes and
    stores it in the database, and provides the result. Most of the time, everything
    is tightly coupled and interconnected.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling has been happening on different levels, without the software designer
    noticing. The tight coherence was between classes, objects, or even packages.
    In many ways, it was possible to correct the application performance weaknesses
    with the more powerful hardware. The system’s evolution progressed more or less
    as a statistical observation of Moore’s law, which was published in 1965.
  prefs: []
  type: TYPE_NORMAL
- en: Moore’s law stated that each year, the number of components per integrated circuit
    doubles. The law was revised in 1975 to state that the number of components doubles
    every *two* years. Although the debate over the law’s validity may turn controversial,
    current trends (and the speed with which hardware upgrades are needed) show that
    the time for another review is coming. It may not be necessary worldwide to speed
    up the hardware upgrade (already so fast) because it may not have any effect on
    the speed of processing information. This observation addresses the feature requirements
    of a software application, focusing more on the quality and complexity of the
    implemented algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be possible to constantly increase the rate at which an object is
    instantiated due to physical limits, as such information must be physically stored
    in memory. It means that in the coming decades, we can expect an increase in pressure
    to improve the efficiency of software and design. To gain clarity of the application
    logic, it needs to be crystal clear how the application works, and moreover, how
    the application feeds the key JVM areas, namely, the method stack and heap followed
    by the thread utilization through the stack areas (as shown previously in *Figure
    2**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: Due to the current software applications’ trends focused on mapping, transforming,
    or managing a large amount of data, creational design patterns are worthwhile
    to study, understand, and learn how to deal with common scenarios. Although the
    time of the **Gang of Four** (**GoF**) book has passed, evolution is inevitable
    and the challenges remain. In many cases, with proper abstraction, the initial
    creational design patterns are applicable. Creating objects and class instances,
    and filling out the intended parts of the JVM, may drastically influence the computation
    and performance costs, as well as enforce business logic clarity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we discuss different possibilities for object creation.
    We will also consider the recently added Java syntactic features and possibilities,
    which should reduce the source code’s verbosity. Let us start with one of the
    most common patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects based on input with the factory method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of this pattern is to centralize the class’s instantiation
    of a specific type. The pattern leaves the decision to create the exact class
    type up to the client at runtime. The factory method design pattern was described
    in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern enforces the separation of code and its responsibility
    for creating new instances of the class, that is, such a method provides the expected
    result. The factory hides an application class hierarchy based on a generics abstraction
    and introduces a common interface. It transparently separates the instantiation
    logic from the rest of the code. By introducing the common interface, the client
    gains the freedom to decide on a particular class instance at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is often used in the early stages of an application because it is
    simple to refactor and provides a high level of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Although this can introduce a bit of complexity, the pattern is easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern is often utilized in the Java Collection framework
    to construct the desired type. The framework implementations reside in the `java.util`
    package of the `java.base` module. This package contains different implementations
    of `Set`, `List`, and `Map`. Although the `Map` type is a valid member of the
    Java Collection framework, it does not inherit the `Collection` interface as it
    implements `Map.Entry` to store element tuples, keys, and values. Each implementation
    of `Set`, `List`, and `Map` provides overloaded `of` factory method to create
    an instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `Collections` class is a utility class. It contains several factory methods
    for creating specific collections, such as a list of individual items, a map,
    or a set. Another useful example of the factory method pattern usage is the `Executors`
    utility class, which can be found in the `java.util.concurrent` package of the
    `java.base` module. The `Executors` class defines static methods such as `newFixedThreadPool`.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s imagine a simple straightforward example that is easily applicable in
    the real world using a suitable abstraction. The goal is to design an application
    that tracks vehicle production. Most likely, the company offers different types
    of vehicles. Each vehicle can be represented by its own object. To draw the intent,
    we created a **Unified Modeling Language** (**UML**) class diagram to maintain
    clarity (*Figure 3**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The vehicle production tracking example](img/B18884_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The vehicle production tracking example
  prefs: []
  type: TYPE_NORMAL
- en: 'The intended factory intends to produce two different types of vehicles, and
    the application fulfills the wishes on the fly (*Example 3.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.1 – VehicleFactory produces vehicles of the same “family” based on
    input arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of distributing the creation of such vehicle types over multiple places,
    we create a factory. The factory abstraction concentrates the whole vehicle composition
    process and exposes only one entry point that allows the client to create the
    desired vehicle type (as shown in *Example 3.2*). A factory only implements one
    static method, so it makes sense to keep its constructor private because factory
    instances are undesirable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.2 – The VehicleFactory class exposes the static factory method to
    produce an instance of the object that implements a Vehicle interface
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented `switch` expression may use the pattern-matching approach to
    simplify code instead of the traditional `switch-label-match` construct. The application
    provides multiple implementations of the vehicle (*Example 3.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.3 – Each considered vehicle inherits the method abstractions through
    the Vehicle interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to another platform-syntactical improvement, the `records` type, it is
    possible to choose the level of the class encapsulation with the reflection of
    SOLID principles. It depends on how much the software architect intends to allow
    the vehicle instance to change its inner state. Let us first look at the standard
    Java class definition approach (*Example 3.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.4 – SuvCar allows adding inner fields that could hold a mutable state
  prefs: []
  type: TYPE_NORMAL
- en: 'The software architect has the chance to use the `record` class to create immutable
    instances of the desired vehicle along with the `hashCode` and `equals` methods
    followed by the `toString` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.5 – SportCar is considered to be immutable
  prefs: []
  type: TYPE_NORMAL
- en: The recently introduced `record` feature reduces the potential boilerplate code
    base while still allowing internal functionality to be implemented (as discussed
    in the *Records (Java SE 16, JEP-395)* section of the previous chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A factory method has some limitations. The most important one is that it can
    only be used for a specific family of objects. This means that all classes must
    maintain similar properties or common ground. The deviation from the base class
    of a class can introduce a dramatic strong coupling between the code and the application.
  prefs: []
  type: TYPE_NORMAL
- en: The point to consider may be related to the method itself, as it may be static
    or belong to the instances (as covered in the previous chapter under *The* *stack
    area* and *The heap area* sections, respectively). This depends on the software
    designer’s decision.
  prefs: []
  type: TYPE_NORMAL
- en: The object of the one family is created. Let us investigate how to deal with
    factory families that share a common property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects from different families using the abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern introduces a factory abstraction without the requirement to define
    specific classes (or classes that should be instantiated). The client requests
    a proper factory that instantiates the object instead of attempting to create
    it. The abstract factory pattern was mentioned in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modularizing applications can become a challenge. Software designers can avoid
    adding code to classes to preserve encapsulation. The motivation is to separate
    the factory logic from the application code so that it can supply the appropriate
    factory to produce the required objects. An abstract factory provides a standardized
    way to create an instance of the desired factory and deliver that instance to
    the client for use. The client uses the resulting factory to instantiate the object.
    Abstract factory provides an interface for creating both factories and objects
    without specifying their classes. The pattern implicitly supports SOLID principles
    and maintainability by isolating the logic of participants and insiders. The application
    is independent of how its products are created, composed, and represented.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory method pattern can be found in the JDK in the `java.xml`
    package of the `java.xml` module. The abstract factory pattern can be found in
    the representation and implementation of the `DocumentBuilderFactory` abstract
    class and its static `newInstance` method. The factory uses a lookup service to
    find the required builder implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider that although vehicles share some common features, their production
    requires different kinds of processes (*Figure 3**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Manufacturing different types of vehicles with the Abstract
    Factory pattern](img/B18884_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Manufacturing different types of vehicles with the Abstract Factory
    pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, we create multiple factories responsible for specific objects.
    Although these classes belong to different families, they do have properties in
    common. An important feature is that each factory can implement its own initialization
    sequence while sharing generic logic. The example requires the correct `CarFactory`
    instance to create a `SlowCa`r object (*Example 3.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.6 – The client decides which Vehicle type is required
  prefs: []
  type: TYPE_NORMAL
- en: 'A key element of the game is the factory provider; this distinguishes which
    factory is created based on incoming arguments (*Example 3.7*). The provider is
    implemented as a utility, so its class is final, and the constructor is private
    because instances are not required. Of course, the implementation may vary depending
    on the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.7 – The FactoryProvider class defines how the particular factory of
    the object families is configured and instantiated
  prefs: []
  type: TYPE_NORMAL
- en: 'Each factory from the group shares common logic or features to maintain the
    DRY approach in the code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.8 – The AbstractFactory class provides the common logic or methods
    that may require implementation by a specific factory
  prefs: []
  type: TYPE_NORMAL
- en: 'These individual factories can implement additional logic to distinguish which
    product should be delivered, similar to the `TruckFactory` and `CarFactory` implementations
    in the following example (*Example 3.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.9 – The TruckFactory class represents the specific AbstractFactory
    implementation
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory pattern provides consistency across products. Using a super
    factory can cause instability in the client runtime because the requested product
    can throw an exception or error due to incorrect implementation, as such information
    was not known on the fly. The abstract factory pattern, on the other hand, promotes
    testability. An abstract factory is free to represent the many other interfaces
    that came with its implementation. The pattern provides a common way to deal with
    products without depending on their implementation, which can improve the separation
    of concerns of application code. It can use interfaces or abstract classes. The
    client becomes independent of how objects are composed and created.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of encapsulating factories and code separation can be seen as a
    limitation. An abstract factory must be controlled by one or more parameters to
    properly define a dependency. To improve the code maintainability of the required
    factories, it may be useful to consider the previously discussed *sealed classes*
    enhancements (see the *Sealed classes (Java SE 17, JEP-409)* section in the previous
    chapter). Sealed classes can have a positive impact on code base stability.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine how to customize an object creation process in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating complex objects with the builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The builder pattern helps separate the construction of a complex object from
    its code representation so that the same composition process can be reused to
    create different configurations of an object type. The builder design pattern
    was identified early and is the part of GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main motivation behind the builder pattern is to construct complex instances
    without polluting the constructor. It helps to separate or even break down the
    creation process into specific steps. The composition of objects is transparent
    to the client and allows the creation of different configurations of the same
    type. The builder is represented by a separate class. It can help to transparently
    extend the constructor on demand. The pattern helps to encapsulate and enforce
    the clarity of the instantiation process with respect to the previously discussed
    SOLID design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder pattern is a commonly used pattern inside the JDK. A great example
    is creating sequences of characters that represent a string. For example, `StringBuilder`
    and `StringBuffer` are located in the `java.lang` package of the `java.base` module,
    which is visible by default to every Java application. The string builder provides
    multiple overloaded connection methods that accept different types of input. Such
    input is concatenated with an already-created byte array. Another example can
    be found in the `java.net.http` package represented by the `HttpRequest.Builder`
    interface and its implementation or the `Stream.Builder` interface found in the
    `java.util.stream` package. As mentioned earlier, the builder pattern is very
    often used. Worth noting are `Locale.Builder` and `Calendar.Builder`, which use
    the setter methods to store values of the final product. Both can be found in
    the `java.util` package of the `java.based` module.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The builder, which is the key element of the pattern, holds required field
    values during a `Vehicle` instance creation, more precisely, references to the
    objects (*Figure 3**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – How to transparently make a new vehicle with the builder pattern](img/B18884_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – How to transparently make a new vehicle with the builder pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall responsibility of the builder pattern is to create vehicles (*Example
    3.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.10 – The builder pattern can be implemented in several ways, depending
    on the requirements
  prefs: []
  type: TYPE_NORMAL
- en: 'The builder pattern may be implemented using different approaches. One approach
    is to encapsulate and hide all builder logic and provide a product directly without
    exposing implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.11 – The VehicleBuilder hides the logic in order to provide a particular
    instance
  prefs: []
  type: TYPE_NORMAL
- en: 'Or the builder may become a part of the class for which the instance is intended
    to be created. In such a case, it is possible to decide which element should be
    added to the newly created specific instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.12 – The FastVehicle.Builder is represented as a static class and
    needs to be instantiated, and provides the possibility of final result customization
  prefs: []
  type: TYPE_NORMAL
- en: Both example approaches are implemented according to SOLID principles. The builder
    pattern is a nice example of abstraction, polymorphism, inheritance, and encapsulation
    (APIE) principles and is very open to refactoring, extending, or validating properties.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder pattern helps enforce the single responsibility principle by separating
    complex creation from business logic. It also improves code readability and the
    DRY principle, as the instantiation is extensible and user-understandable. The
    builder pattern is a commonly used design pattern because it reduces “code smell”
    and constructor pollution. It also improves testability. The code base helps avoid
    multiple constructors with different representations, some of which have never
    been used.
  prefs: []
  type: TYPE_NORMAL
- en: Another good point to consider while implementing a pattern is to use the JVM’s
    heap or stack – more specifically, to create a statically or dynamically allocated
    representation of the pattern. This decision is commonly answered by the software
    designers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: It is not always necessary to reveal the construction process. The next section
    presents the simplicity of object cloning.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning objects with the prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype pattern solves the difficulty of creating new instances of an
    object with complicated instantiation process, which is too cumbersome and undesirable
    because it can lead to unnecessary subclassing. The prototype is a very common
    design pattern and was described in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype design pattern becomes very useful when heavy objects need to
    be created and factories are an unwanted approach. The newly created instance
    is cloned from its parent because the parent acts as a prototype. Instances are
    independent of each other and can be customized. Instance logic is not exposed
    to, and cannot be contributed to by, the client.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many examples of using prototype patterns across JDK packages. The
    Collection framework members implement the `clone` method required by the inherited
    `Cloneable` interface. For example, an `ArrayList.clone()` method execution creates
    a shallow `List` copy of entities, field by field. Another prototype implementation
    could be the `Calendar` class from the `java.util` package of the `java.base`
    module. A clone of the overridden method is also used for the `Calendar` implementation
    itself, as it helps to avoid unwanted modification of an already configured one.
    Usage can be found in the `getActualMinimum` and `getActualMaximum` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When there are only a few vehicle models in production, there is no need to
    constantly establish new objects by factories or builders, which could actually
    lead to unwieldy code behavior as internal properties may change. Imagine the
    early stage of vehicle production where equality is required with each new iteration
    to track progress (*Figure 3**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Creating new instances from the prototype](img/B18884_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Creating new instances from the prototype
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, it is easier to create an exact copy of an already designed
    vehicle as its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.13 – A new vehicle can be cloned from the available instances
  prefs: []
  type: TYPE_NORMAL
- en: 'The instances can be recreated (respectively, cloned) on demand. The `Vehicle`
    abstract class provides a foundation for each new prototype implementation and
    provides cloning details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.14 – The Vehicle abstract class must implement a Cloneable interface
    and introduce the clone method implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'Each vehicle implementation requires the extension of the parent `Vehicle`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.15 – The Vehicle interface-specific implementation provided by the
    SlowCar class and the move method implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototype pattern introduces an internal cache that collects available
    `Vehicle` type prototypes (*Example 3.16*). The proposed implementation implements
    a static method to make the cache work as a tool. It makes sense for its constructor
    to be private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.16 – VehicleCache holds the references to the already prepared prototypes
    that may be cloned
  prefs: []
  type: TYPE_NORMAL
- en: The examples show that the client works each time with an identical copy of
    the base prototype. This copy may be customized based on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern is useful for dynamic loading or to avoid increasing the
    complexity of the code base by introducing unnecessary abstractions, known as
    **subclassing**. This does not mean that clones do not need to implement the interface,
    but cloning can reduce exposure requirements or make the instantiation process
    too complicated. A prototype properly encapsulates the complicated logic of an
    instance that is not meant to be touched or modified. Software designers should
    be aware of the possibility that such a code base can easily change to legacy
    code. On the other hand, a pattern can defer and support iterative changes to
    the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple instances of an object are not always desirable and are sometimes even
    undesirable. In the next section, we’ll learn how to guarantee the presence of
    only one unique class instance at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring only one instance with the singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singleton object provides transparent and global access to its instance and
    ensures that only one instance is present. The singleton pattern was identified
    very early by industry requirements and is mentioned in the GoF’s book.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A client or application wants to ensure that only one instance is present at
    runtime. An application may require multiple object instances that all use one
    unique resource. This fact introduces instability because any of these objects
    can access such a resource. A singleton guarantees only one instance that provides
    a global access point to all clients within the desired scope of the running JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best example of using a singleton is a running Java application, or more
    precisely, the runtime. It is found in the `Runtime` class and its method, `getRuntime`,
    resides in the `java.lang` package of the `java.base` module. The method returns
    an object associated with the current Java application. The runtime instance allows
    the client to add, for example, shutdown hooks to the running application.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example suggests an application that only runs one car with its
    engine (*Figure 3**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – How the Singleton pattern represents an engine](img/B18884_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – How the Singleton pattern represents an engine
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, this means that only one instance of a particular type of engine
    and vehicle must be present in the JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.17 – One instance of OnlyEngine and OnlyCar is present at runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of different ways to ensure that the instance of the object
    will be unique. The implementation of the `OnlyEngine` class introduces the possible
    singleton implementation where its instance is lazily created on demand (*Example
    3.18*). The `OnlyEngine` class implements the generic `Engine` interface. Its
    implementation provides a static `getInstance` method as a transparent entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.18 – The OnlyEngine class checks the existence of its instance – lazy
    initiation
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to implement a singleton is to create a `static` field that belongs
    to the class itself and expose a `getInstance` entry point to the potential client
    (*Example 3.19*). It is fair to note that, in such a case, the constructor becomes
    private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.19 – The OnlyVehicle class provides its instance as a static field
    that belongs to the class
  prefs: []
  type: TYPE_NORMAL
- en: 'The lazily initialized singleton pattern implementation may become a challenge
    in a multithreaded environment where the `getInstance` method must be synchronized
    to obtain a unique instance. One possibility is to create a singleton as an `enum`
    class (*Example 3.20*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.20 – The OnlyEngineEnum singleton enum class approach
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singleton is a relatively trivial design pattern, although it can get complicated
    when used inside a multithreading environment due to its guarantee that there
    will be only one instance of the required object. The pattern can be challenged
    when enforcing the principle of single responsibility since the class is actually
    responsible for instantiating itself. On the other hand, the singleton pattern
    ensures that clients can access allocated resources globally, preventing accidental
    object initialization or destruction. The pattern should be used wisely as it
    creates tightly coupled code in the manner of required class instantiations, which
    can tend to cause testability issues. The pattern also suppresses other subclasses,
    making any extension nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating instances is not always a good approach. Let us examine how to do this
    on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with the object pool pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object pool pattern instantiates ready-to-use objects and limits their initialization
    time. The required instances can be recreated on demand. A pool of objects can
    represent a base of conditions on which new instances could be created, or limit
    their creation.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of constantly creating new object instances over the code base, the
    object pool provides an encapsulated solution for managing application or client
    performance by serving an already initialized object ready for use. The pattern
    separates the build logic from the business code and helps manage the resource
    and performance aspects of the application. It may not only help with an object’s
    life cycle but also with validation when it is created or destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nice example of the object pool pattern is the `ExecutorService` interface
    found in the `java.util.concurrent` package and the implementation provided by
    the `Executors` class of the `util` factory that handles the appropriate executor
    instances, for example, the `newScheduledThreadPool` method.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current example introduces a scenario where the garage contains a specific
    number of cars that drivers may drive (*Figure 3**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – A garage following the Object Pool pattern](img/B18884_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – A garage following the Object Pool pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'When a car is not available, the garage has implemented a logic to buy a new
    one in order to keep all drivers busy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.21 – The pooling vehicles in the garage instance help reduce the cost
    of the object
  prefs: []
  type: TYPE_NORMAL
- en: 'A core element of the pattern is pool abstraction, as it contains all the required
    logic for managing entities. One option is to create an abstract garage pool class
    (*Example 3.22*) that contains all the synchronization mechanisms. These mechanisms
    are required to avoid potential code instability and inconsistency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.22 – An abstract garage pool provides all the required logic to properly
    administrate elements
  prefs: []
  type: TYPE_NORMAL
- en: 'The garage pool limits the possible instance types. A class is bound by the
    `Vehicle` abstraction (*Example 3.23*). The interface provides the common functions
    used by the client. In the following example, the implementation of `AbstractGaragePool`
    represents the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.23 – The Vehicle interfaces need to be implemented by PooledVehicle
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to implementing functions, the `PooledVehicle` class provides a
    private counter (*Example 3.24*). A counter belongs to a class, so it is marked
    as `static` and `final`. The counter counts the number of instances purchased
    by the garage pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.24 – The PooledVehicle class implementation also holds the number
    of instances created
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improving client performance helps reduce the expensive object instantiation
    time (as we saw in *Example 3.21*). Object pools are also quite useful in cases
    where only short-lived objects are required, as they help reduce memory fragmentation
    by uncontrolled instances. It is worth touching upon the implementation of the
    internal cache pattern, as seen in the garage example.
  prefs: []
  type: TYPE_NORMAL
- en: Although the pattern is quite efficient, the right choice of collection structure
    can also have a dramatic impact on its performance. It can reduce search and save
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Another positive outcome can be considered as the impact on the garbage collection
    process and memory compaction due to the analysis of active objects since there
    may be fewer objects to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: It is not always necessary to store everything in memory for later reuse. Let
    us examine how to postpone the object initialization process and not polluting
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating objects on demand with the lazy initialization pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern’s purpose is to defer an instance of the desired class instance
    until the client actually requests it.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although operational memory has grown drastically over the years, we learned
    in the previous chapter that the JVM allocated a defined, specific size of memory
    reserved for the heap. When the heap is exhausted and the JVM is unable to allocate
    any new object, it causes an out of memory error. Lazy handling can have quite
    a positive impact on this heap pollution. It is sometimes also called asynchronous
    loading because of the delayed instance. The pattern has quite a nice use in a
    web application where the web page is generated on demand rather than during the
    application initialization process. It also has its place in an application, where
    the cost of operating the relevant object is high.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy initialization can be demonstrated using the example of dynamic loading
    by `ClassLoader` of classes that were not linked at runtime when the application
    was started. Classes can be loaded eagerly or deferred by the class policy. Certain
    classes, such as `ClassNotFoundException`, are loaded implicitly through the `java.base`
    module. They support the class implementation located in the `java.lang` package
    and its `forName` method. The implementation of the method is provided by an internal
    API. A lazy initiated class may be the reason the application requires a warm-up
    time. For example, `Enum` classes are a special type of static final classes that
    act as constants and are loaded eagerly.
  prefs: []
  type: TYPE_NORMAL
- en: '`->` refers to loading steps into the class loader and filling out the appropriate
    method area, as we learned in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic idea of the lazy initialization example is that the created vehicle
    is initialized on demand or, when already created, a reference is provided to
    the client (*Figure 3**.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern](img/B18884_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Such vehicles are present only if they are really required by the client. In
    such cases, specific vehicle instances are created. When a vehicle is already
    present inside the provider context, then such an instance is reused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.25 – An example implementation of the pooled vehicle
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `VehicleProvider` class considers the fields private.
    Those fields hold the references to the desired vehicle if required. The provider
    encapsulates the decision and instantiation logic. One of the possible implementations
    may use the `switch-label-match` construct (*Example 3.26*), `switch` expressions,
    and so on. It’s good to point out that in this example, the `VehicleProvider`
    class requires an instance in the package scope, so its constructor is a `private`
    package and is not exposed to other packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.26 – VehicleProvider hides the possible entity instantiation logic
    from the client
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enforce the extendibility to the possible lazily initiated object,
    each entity implements the `Vehicle` abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.27 – Vehicle abstraction and possible LazyVehicle implementation using
    record to enforce immutability
  prefs: []
  type: TYPE_NORMAL
- en: Such an approach enforces continual vehicle evolution without complicated changes
    to the provider logic.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lazy initialization design pattern can help keep application memory small.
    Improper use, on the other hand, can cause unwanted delays, as objects can be
    too complex to create and take a significant amount of time to run.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to inject the logic into the client, represented
    by the newly created vehicle instance.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing class dependencies with the dependency injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern separates the initialization of the class (that *acts* as a service)
    from the client (that *uses* the service).
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dependency injection pattern is widely used where there is a need to separate
    the implementation of a particular object (service) from the target object (client)
    that uses its exposed services, methods, and the like. Services are available
    when a client instance is to be created. The pattern allows you to eliminate any
    hardcoded dependencies. These services are instantiated outside of the client
    creation process. This means that the two are loosely connected, and SOLID principles
    can be enforced. There are three ways that dependency injection can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor dependency injection**: Intended services are made available
    to the client through the initialization of the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Injection method**: The client exposes the method normally through an interface.
    Such a method supplies dependencies to the client. The supplier object uses a
    method to inject the service(s) into the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good example of using the dependency injection pattern is the `ServiceLoader`
    utility class. It can be found in the `java.base` module and its `java.util` package.
    The `ServiceLoader` instance tries to find services during the application startup
    at runtime. A service is considered to be represented by a well-specified interface
    that is implemented by the relevant service provider or providers. The application
    code is able to distinguish the desired provider at runtime. It is good to note
    that `ServiceLoader` works with the classic `classpath` configuration or can be
    used seamlessly with the Java Platform Module System (discussed in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for* *Design Patterns*).
  prefs: []
  type: TYPE_NORMAL
- en: In the past, dependency injection was part of the Java EE scope, not the classic
    JDK. This means that the feature was available on the Java platform. Due to the
    evolution of the JDK, the dependency injection features were moved to the `@Inject`,
    `@Named`, `@Scope`, or `@Qualifier` annotations. These annotations allow the class
    to be turned into a managed object at runtime, where the implementation of the
    desired provider can be distinguished.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example shows a simplified dependency injection pattern in order to receive
    a general experience. It is a very trivial implementation; in fact, it draws a
    picture of how the previously mentioned API works behind the scenes. Let’s imagine
    a scenario where the intended vehicle instance requires an engine (*Figure 3**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Injecting engine as a service to the vehicle instance](img/B18884_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Injecting engine as a service to the vehicle instance
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific engine construction logic is detached from vehicle-related code (*Example
    3.28*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.28 – Creating an instance of FastEngine separately from the vehicle
    and then adding the engine to the constructed SportVehicle
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FastEngine` instance is used when it is fully ready (initiated, verified,
    and so on). The desired type of vehicle can be constructed independently without
    any dependence on engine logic. An engine instance is provided to `SportVehicle`
    using `EngineServiceProvider` (*Example 3.29*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.29 – EngineServiceProvider registers instantiated reusable services
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SportVehicle` class implements the `Vehicle` interface (*Example 3.30*)
    in order to reflect the open-close approach mentioned as part of the SOLID design
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.30 – SportVehicle implements the Vehicle interface together with additional
    internal logic for the provided Engine instance
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that although a specific `Engine` type (*Example 3.31*)
    instance (`FastEngine`) is created somewhere else (*Example 3.28*, line `3`),
    its presence is required when the `SportVehicle` object is instantiated (*Example
    3.28*, line `5`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.31 – Engine interfaces implemented by the FastEngine class and provided
    by EngineServiceProvider
  prefs: []
  type: TYPE_NORMAL
- en: The key player object in the described example is `EngineServiceProvider`. It
    provides a reference to already created desired `Engine` instances and distributes
    them across the business code. This means that any client that needs to work on
    `Engine`, similar to the `SportVehicle` instance, will get access to the correct
    instance through the link exposed by `EngineServiceProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented trivial example can be easily turned into another using the `ServiceProvider`
    utility class instance. The changes are very minimal (*Example 3.32*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Example 3.32 – ServiceLoader provides an available implementation of the Engine
    interface used to instantiate the SportVehicle type
  prefs: []
  type: TYPE_NORMAL
- en: In the standard classpath utilization, the Java platform requires service providers
    to be registered in the `META-INF` folder and the `services` subfolder. The filename
    is made up of the package and the service interface name, and the file contains
    the available service providers.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Platform Module System simplifies the configuration steps. The relevant
    modules provide (and make available service implementations to) the target modules,
    as we touched on in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*, Discovering
    the Java Platform for* *Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dependency injection pattern ensures that the client does not know about
    the instantiation of the used service. The client has access to the service through
    the common interfaces. It makes the code base better testable. It also simplifies
    the code base testability. Dependency injection is a widely used pattern by various
    frameworks, such as Spring and Quarkus. Quarkus uses the Jakarta Dependency Injection
    specification. The dependency injection pattern conforms to the SOLID and APIE
    object-oriented programming principles as it provides the abstraction of interfaces.
    The code does not depend on the implementation but communicates with the services
    through the interfaces. The dependency injection pattern enforces a DRY principle
    as it is not required to continually initiate a service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns play a very important role in software application
    design. They help in transparently centralizing object instantiation logic with
    respect to basic object-oriented principles. The examples showed that each pattern
    may have multiple implementations. This is because the implementation decision
    may depend on other software architecture factors. Those factors take into account
    JVM heap and stack usage, application runtime, or business logic encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Using design patterns implicitly for authoring promotes a DRY approach, which
    has a positive impact on application development and reduces code base pollution.
    The application becomes testable and software architects have a framework to confirm
    the presence of expected objects inside the JVM. This becomes particularly important
    when a logic issue is identified, which could be an exception or unexpected results.
    A well-created code base helps to get into the root cause quite fast, maybe even
    without the necessity to debug.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create an object of a particular family
    using the transparent factory method pattern. The abstract factory pattern showed
    the encapsulated way of creating different factories types. Not all the required
    information is always present at one moment, and the builder pattern introduced
    a way to deal with such a challenge of composing complex objects. The prototype
    pattern showed the approach of not exposing the instance logic to the client,
    where the singleton pattern ensured the presence of a single instance at runtime.
    The object pool design pattern revealed how to improve memory usage at runtime,
    while the lazy instantiation pattern showed how to defer an object until it is
    needed. The dependency injection pattern demonstrated the reusability of instances
    when creating new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns not only bring clarity to the creation of new instances
    but, in many cases, they can also contribute to the decision about the correct
    structure of the code (a code structure that reflects the required business logic).
    The last three mentioned patterns solve not only the issue of creating objects
    but also their reusability for efficient memory use. The examples we covered showed
    us how creational patterns can be implemented and we learned about the differences
    and purposes of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss the structure design pattern. This pattern will
    help us organize our code based on the most common scenarios. Let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What challenges do the creational design patterns solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which patterns may be helpful to reduce object initiation costs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the key reason to utilize the singleton design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which pattern helps to reduce constructor pollution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you hide complex instantiation logic from the client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to reduce the instantiation application memory footprint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What design pattern is useful for creating objects of a specific family?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cramming more components onto integrated circuits* by Gordon E. Moore, Electronics
    Magazine, 1965-04-19'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Oracle Tutorials:* *Generics*: [https://docs.oracle.com/javase/tutorial/java/generics/index.html](https://docs.oracle.com/javase/tutorial/java/generics/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quarkus* *Framework*: [https://quarkus.io/](https://quarkus.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spring* *Framework*: [https://spring.io/](https://spring.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jakarta Dependency* *Injection*: [https://jakarta.ee/specifications/dependency-injection/](https://jakarta.ee/specifications/dependency-injection/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Code* by Robert C. Martin, Pearson Education, Inc, 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Java – Third Edition* by Joshua Bloch, Addison-Wesley, 2018'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
