<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Integrating Legacy APIs with the Proxy Pattern</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integrating Legacy APIs with the Proxy Pattern</h1>
                </header>
            
            <article>
                
<p>Developing a new API is very often a pleasant experience for developers. Without any legacy code, we engineers can choose our tooling, think through the design process to ensure an enjoyable end user experience, build on top of a serverless platform, and all of the other best practices learned thr<span>ough the ages. However, companies and bosses task many engineers with taking a legacy API and supporting, maintaining, or porting it to a new architecture. Given an already deployed production API that sees constant usage, porting to a serverless system can be akin to changing the engine of a race car while in the middle of a race.</span></p>
<p>Fortunately, this complicated task can be made much simpler nowadays using the proxy pattern, the idea of which has been around for many years as a software pattern. If the name isn't clear enough, the main ideas are that a layer sits in between the client and backend system, which acts as a proxy, shuffling data to and from the backend service on behalf of the client. Inserting this proxy in between the two actors (client and server) makes it possible to transform request data from the client before it's sent to the server, as well as transform the payload from the server before it's delivered to the client. In this manner, one may mimic the exact behavior of a legacy API without any changes needed on the client side. This design allows for a graceful transition from a legacy API backend to a newer backend system without the fear of breaking existing clients or requiring them to update their application.</p>
<p><span>By the end of this chapter, you can expect to learn the following:</span></p>
<ul>
<li>Introduction to the proxy pattern and how it works for migrating API backends or updating the request/response payloads for existing APIs</li>
<li>Options for implementing the proxy pattern, including AWS API Gateway and custom serverless functions</li>
<li>Transforming requests/responses to an existing API</li>
<li>Migrating existing APIs to a serverless backend</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">AWS API Gateway introduction</h1>
                </header>
            
            <article>
                
<p>API Gateway from Amazon Web Services is a fantastic tool with a slew of features that significantly simplifies&#160;implementation of an API proxy pattern. Later on in the chapter, we'll discuss strategies when building on a different cloud provider; however, if you're like me and use AWS consistently, API Gateway can make your life much more comfortable. Personally, I feel that it's an underrated tool, which can do a lot more than HTTP requests to Lambda functions as we saw in <a href="svrls-dsnptn-bstprac_ch02.html">Chapter 2</a>, <span><em>Three-Tier Web Application Using REST</em>&#160;</span>and <a href="svrls-dsnptn-bstprac_ch03.html">Chapter 3</a>, <em>Three-Tier Web Application Pattern with GraphQL</em>.</p>
<p>The first question may be, <em>What is API Gateway and what does it do?</em> Rather than answer this myself, I'll defer to the technical documentation at <a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html">http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html</a>, which does a good job of describing&#160;Gateway at a high level:</p>
<div class="packt_quote"><span>"Amazon API Gateway is an AWS service that enables developers to create, publish, maintain, monitor, and secure APIs at any scale. You can create APIs that access AWS or other web services, as well as data stored in the AWS Cloud."<br/></span></div>
<p>API Gateway provides you with a publicly accessible HTTPS URL. Requests that hit this endpoint may do a variety of things including, but not limited to, the following:</p>
<ul>
<li>Call a Lambda function</li>
<li>Return a mock endpoint build with templates</li>
<li>Proxy requests to a different HTTP endpoint</li>
</ul>
<p>In <a href="svrls-dsnptn-bstprac_ch02.html">Chapter 2</a><span>, <em>A</em>&#160;</span><span><em>Three-Tier Web Application Using REST</em>&#160;</span><span>and&#160;</span><a href="svrls-dsnptn-bstprac_ch03.html">Chapter 3</a><span>, <em>A</em>&#160;</span><em>Three-Tier Web Application Pattern with GraphQL</em>, we used API Gateway to expose an HTTPS endpoint that would invoke our Lambda functions containing application logic. HTTP payload data, including headers and query parameters, would be pulled in from the HTTPS request and sent to Lambda. Our Lambda functions also control the response payload by returning a JSON-encodable data structure as well as appropriate HTTP status codes and headers. Managing the actual HTTP response from Lambda is known as a <strong>proxy integration</strong>, not to be confused with the proxy pattern we will work on in this chapter. I bring this up to add clarity to what we've done and what we'll be doing for this pattern with API Gateway.</p>
<p>In most of the subsequent examples, we will not be using the Lambda proxy integration. While this means more configuration will work on our behalf, it also means we will be able to control the request/response payloads to our liking. When building a brand new Serverless API with API Gateway and AWS Lambda,&#160;Lambda proxy integration should be precisely what you need since it's easy to control requests and responses from your API definition and application code, respectively. However, when setting up the proxy pattern for an existing HTTP backend, it's common to need more control over transforming response data before it's sent back to the client.</p>
<p>In addition to being the ingestion point for web requests and sending those requests somewhere else, API Gateway provides quite a bit more functionality, including:</p>
<ul>
<li>Authentication and authorization hooks</li>
<li>Automatic API documentation generation</li>
<li>Rate limiting/throttling</li>
<li>Logging</li>
<li>Defining multiple stages or environments with their variables that can be passed to downstream systems</li>
</ul>
<p>Personally speaking, the more I learn about the capabilities of API Gateway, the more ideas I come up with for possible applications and use cases.</p>
<div class="packt_tip">There are other services that provide similar functionality. If you prefer to build on something other than AWS, have a look at <strong>Apigee</strong> (<a href="https://apigee.com/api-management/">https://apigee.com/api-management/</a>) or <strong>Kong</strong> (<a href="https://getkong.org/">https://getkong.org/</a>).</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Simple proxy to a legacy API</h1>
                </header>
            
            <article>
                
<p>In this first example, we'll go through the steps to set up a simple integration with an existing API. What is neat about API Gateway is that it's possible to go a very long way on the path to replacing current application code without writing any code ourselves.&#160;</p>
<div class="packt_infobox">In these examples, we'll use a publicly available fake API called <kbd>JsonPlaceholder</kbd>, pretending for our purposes that it's a legacy API that we'd like to replace:&#160;<a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>.</div>
<p>Of course, this type of replacement warrants plenty of thought and careful planning. Authentication, rate limiting, DNS entries, and the like are all factors that much be thought through carefully before embarking on such a project. Still, with all of the issues that one should consider, there are many tools and options to make this pattern a real possibility for many applications.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a pass-through proxy</h1>
                </header>
            
            <article>
                
<p>Step one on our journey will be to work through the steps of setting up a new API in API Gateway that will pass requests and responses to and from <kbd>JsonPlaceholder</kbd>.</p>
<p>First, in the AWS console, create a new API, shown as follows. I'll call this one <kbd>JsonProxy</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5040d3c5-6ded-4cc7-94d2-085f11ccfc3c.png"/></div>
<p>Once we have our API, we can start filling it in and adding endpoints and behavior. In my experience, most&#160;AWS services have&#160;essential concepts that one should understand well before building something of significance. API Gateway is no different in this regard. The good news is that it's not incredibly difficult to understand these concepts in API Gateway.</p>
<p>The two concepts we'll be working with when using API Gateway are resources and methods. The mental model is situation simple:</p>
<ul>
<li><strong>Resource</strong>: API endpoint</li>
<li><strong>Method</strong>:<span>&#160;</span>HTTP method that lives under a resource</li>
</ul>
<p><kbd>JSONPlaceholder</kbd> provides API endpoints for a few different API resources, posts, comments, albums, and so on. To begin, we'll create a new API Gateway resource for <kbd>/posts</kbd>. This endpoint, on our unique URL, will proxy to <a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>. It should be noted that we could set up an endpoint on our API Gateway deployment named something other than <kbd>/posts</kbd>. That is, it's possible to create a resource named <kbd>/all_posts</kbd>, which would then proxy to&#160;<a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>.</p>
<p>In the console, we set this up in the following way:</p>
<ol>
<li>Select the <span class="packt_screen">Actions</span> button&#160;<span>→ <span class="packt_screen">Create Resource</span></span>:
<ol>
<li>Set <span class="packt_screen">Resource Name</span>&#160;to be <span class="packt_screen">posts</span></li>
<li>Ensure <span class="packt_screen">Configure as proxy resource</span>&#160;is not checked</li>
<li>Click the <span class="packt_screen">Create Resource</span>&#160;button</li>
</ol>
</li>
<li>Ensure the newly created <kbd>/posts</kbd> resource is selected/highlighted in the list of resources</li>
</ol>
<ol start="3">
<li><span>Select the <span class="packt_screen">Actions</span> button&#160;</span><span>→ <span class="packt_screen">Create Method</span></span>:
<ol>
<li>Select <span class="packt_screen">GET</span> and click the confirmation checkbox button</li>
<li><span>On the next screen, set the options as shown in the following screenshot</span></li>
<li>Ensure the <span class="packt_screen">Endpoint URL</span>&#160;is pointing to&#160;<a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a></li>
<li>Click the <span class="packt_screen">Save</span>&#160;button; take a look at the following screenshot:</li>
</ol>
</li>
</ol>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/d95aed31-20f8-4855-ba1b-71efb41ed4ef.png"/></div>
<p style="color: black">The preceding screenshot may look quite confusing. I'll admit, I didn't understand many details of this part of API Gateway for quite a long time until I went through this exercise that we're going through now. We'll go through the details of the <span class="packt_screen">Method Execution</span> screen in detail, but first, let's deploy our new API and test it out:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/2136a688-883c-42d5-ab37-2b1bf7b52e89.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying a pass-through proxy</h1>
                </header>
            
            <article>
                
<p style="color: black">At this point, we've merely defined our API's skeleton and straightforward structure, with a single endpoint of <kbd>/posts</kbd>. There is no URL for us to query to test. For that, we'll need to deploy our API:</p>
<ol>
<li>Select the Actions button&#160;→ <span class="packt_screen">Deploy API</span></li>
<li>From the <span class="packt_screen">Deploy API</span> screen:
<ol>
<li>Select <span class="packt_screen">New stage</span></li>
<li>Enter&#160;<kbd>dev</kbd> for the stage name</li>
</ol>
</li>
<li>Click the <span class="packt_screen">Deploy</span> button</li>
</ol>
<p style="color: black">After deployment, the console will take you to the <span class="packt_screen">dev</span>&#160;<span class="packt_screen">Stage Editor</span>&#160;screen. Here, you'll notice many other types of features that you can update. For example, it's possible to turn on/off API throttling, set stage variables, and so on. For our purposes, we're all done:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/89145268-abb3-45e4-b1e6-72355575afef.png"/></div>
<p style="color: black">You'll notice a URL highlighted at the top of this screen. This&#160;custom URL is unique to this deployment and may be used to hit our API. Expanding the <span class="packt_screen">dev</span> stage on the left-hand side will show you the single URL endpoint we defined in the prior <span class="packt_screen">Resources</span> section.</p>
<p style="color: black">Now, if we load up our custom URL in the browser or hit that URL with cURL, we can see the data pulled from the&#160;<kbd>JSONPlaceholder</kbd>&#160;endpoint of&#160;<kbd>/posts</kbd>:</p>
<pre style="color: black"><strong>$ curl https://kwl4kd93i1.execute-api.us-west-2.amazonaws.com/dev/posts</strong><br/><strong>[</strong><br/><strong>  {</strong><br/><strong>    "userId": 1,</strong><br/><strong>    "id": 1,</strong><br/><strong>    "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",</strong><br/><strong>    "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"</strong><br/><strong>  },</strong><br/><strong>  {</strong><br/><strong>    "userId": 1,</strong><br/><strong>    "id": 2,</strong><br/><strong>    "title": "qui est esse",</strong><br/><strong>    "body": "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla"</strong><br/><strong>  }...</strong><br/><strong>]</strong></pre>
<p style="color: black">What we have now is our very own HTTPS URL, which doesn't do much, but it's still quite remarkable. We have not written a single line of application code in any sort of programming language, and have set up a proxy to return results from an existing legacy API. You may think this isn't very useful right now. You wouldn't be wrong, necessarily. However, even with a simple integration like this, we can already begin to take advantage of some API Gateway features such as:</p>
<ul>
<li>Automated API documentation generation</li>
<li>Throttling</li>
<li>Automated SDK generation in multiple languages</li>
</ul>
<p style="color: black">This is merely the first step. In the next section, we will dive into the details of starting to transform our API Gateway API to turn it into something completely different using the same data source.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Transforming responses from a modern API</h1>
                </header>
            
            <article>
                
<p style="color: black">Next, we'll walk through a scenario where we have an existing API interface that we need to support, but would like to change the backend implementation entirely. This&#160;scenario is common and one I've dealt with personally. Existing clients point to a particular set of API endpoints. Breaking a public API that many developers depend on isn't something anyone wants to do. But, when that API is built on top of hard-to-maintain or poorly performing code, how does one iterate without requiring hundreds or thousands of developers to update their mobile, web, or GUI applications?</p>
<p style="color: black">In this example, I will walk through the steps necessary to take a pretend legacy API and reimplement it using our modern API. <kbd>JSONPlaceholder</kbd> will play the part of our new, modern, scalable, and performant RESTful API. The single URL we will reimplement with the proxy pattern is&#160;<kbd>https://$HOSTNAME/get_comments_by_post_id</kbd>.</p>
<p style="color: black">You can imagine the type of data this endpoint returns. Thinking back to our discussion on REST APIs, it's evident that this legacy pattern is not RESTful for a variety of reasons. With an API structure such as this, you can bet that the rest of the API design will need some work and may not be the easiest to work with as an end user. Our shiny new RESTful API (<kbd>JSONPlaceholder</kbd>) is much more to our liking and one that we'd like to advertise and have developers adopt rather than the previous old structure. How can we support existing clients with the same input and output payloads by using our new RESTful API?</p>
<p style="color: black">API Gateway can help us out in this scenario.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Method execution flow</h1>
                </header>
            
            <article>
                
<p style="color: black">The <span class="packt_screen">Method Execution</span> screenshot shown in the <em>Setting up a pass-through proxy</em>&#160;section will come into play now. You may refer back to that screenshot as we walk through the four different parts. It also may be easier to look at the following diagram, which represents the same request/response flow but is&#160;a bit simpler to digest:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/b8c521b0-35db-4e38-a981-2ee660098568.png" style="width:49.75em;height:13.67em;"/></div>
<p style="color: black">For every API Gateway resource/method combination, there are four steps that we may configure. It all starts with the client on the far left of this diagram. This&#160;<strong>client</strong>&#160;icon represents the user who is calling our API. After a series of steps, an HTTP response is created, and the client receives some payload. Working with API Gateway means configuring some or all of these stages to control the HTTP request and the HTTP response. Sitting right in the middle of this flow is the <strong>Integration Type</strong>, which, as mentioned earlier, may be a variety of things, including an AWS Lambda function or existing HTTP endpoint. The two steps that precede the execution of the integration (<strong>Method Request</strong> and <strong>Integration Request</strong>) are responsible for working with the HTTP request. The work that these two stages perform may include:</p>
<ul>
<li>Transforming query parameters</li>
<li>Transforming input data (that is, POST payload)</li>
<li>Extracting and transforming headers</li>
<li>Performing authentication</li>
</ul>
<p style="color: black">Once this work is done, the <span class="packt_screen">Integration Request</span> will pass data (which may or may not be transformed from the original input payload) to the <span class="packt_screen">Integration Type</span>. The <span class="packt_screen">Integration Type</span> returns some data, hands it off to the <span class="packt_screen">Integration Response</span>, and finally <span class="packt_screen">Method Response</span>. As the other two sections worked on the request payload, these two sections (<span class="packt_screen">Integration Response</span> and <span class="packt_screen">Method Response</span>) operate on the response payload. Actions we may perform here include:</p>
<ul>
<li>Transforming the HTTP body/payload</li>
<li>Transforming/adding HTTP headers</li>
<li>Controlling HTTP status codes</li>
</ul>
<p style="color: black">In the AWS console screenshot&#160;in the <em>Setting up a pass-through proxy</em>&#160;section, the client is represented on the far left as a vertically oriented rectangle.&#160;On the far right of the same screenshot is the endpoint that we configured this API to talk with,&#160;<a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>. Again, in other cases, that integration endpoint may be a Lambda function, mock integration, or any of the other supported backend systems for API Gateway. In our example for this chapter, it will always be our existing <kbd>JSONPlaceholder</kbd> API. Following the arrows in the <span class="packt_screen">Method Execution</span> screen on the AWS console you can see how a request from clients flows in the order described previously:</p>
<ul>
<li>Method Request</li>
<li>Integration Request</li>
<li>Our configured integration endpoint</li>
<li>Integration Response</li>
<li>Method Response</li>
</ul>
<p style="color: black">There are many options and a huge number of permutations with this flow of data. We can't go through every one obviously, but we'll work primarily with Integration Request and Integration Response for this example. Our tasks will involve:</p>
<ul>
<li>Creating new resources for the three separate legacy API endpoints</li>
<li>Creating <kbd>GET</kbd> methods on those three resources</li>
<li>For each resource/method combination, map query parameters from the request to our new API</li>
<li>For each resource/method combination, set up an Integration Response Body Mapping Template to transform the JSON payload from our new API to the structure expected of the legacy API</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up example</h1>
                </header>
            
            <article>
                
<p style="color: black">The API to integrate with has the URL structure of&#160;<a href="https://jsonplaceholder.typicode.com/comments?postId=1">https://jsonplaceholder.typicode.com/comments?postId=1</a>. As a reminder, this is the endpoint URL for our HTTP Integration Type. With a URL structure like that, it's clear what is going on and what the return data should be. This request fetches comments for a given <kbd>postId</kbd>, which are passed along as a <kbd>GET</kbd> argument.&#160;Additionally, this modern API returns an array of comment resources with the following format:</p>
<pre style="color: black;padding-left: 30px">{
  "postId": 1,
  "id": 1,
  "name": "id labore ex et quam laborum",
  "email": "Eliseo@gardner.biz",
  "body": "laudantium enim quasi est quidem magnam voluptate ipsam eos\ntempora quo necessitatibus\ndolor quam autem quasi\nreiciendis et nam sapiente accusantium"
}</pre>
<p style="color: black">Assume for the sake of this example that our legacy system has an analogous API but with a different URL structure, <kbd>GET</kbd> argument to filter the comments and representation of the comment resource:</p>
<p style="color: black"><kbd>https://$HOSTNAME/get_comments_by_post_id?post_id=1</kbd></p>
<pre style="color: black;padding-left: 30px">{
  "comment_id": 1,
  "name": "id labore ex et quam laborum",
  "user": {<br/>    email": "Eliseo@gardner.biz"<br/>  },
  "text": "laudantium enim quasi est quidem magnam voluptate ipsam eos\ntempora quo necessitatibus\ndolor quam autem quasi\nreiciendis et nam sapiente accusantium"
}</pre>
<p style="color: black">Our job here is to support this legacy URL pattern and payload using the modern-day RESTful API (<kbd>JSONPlaceholder</kbd>) as the data source. Fortunately, all of the data we need to support we have in our new API, so our job will be to have API Gateway perform the translation of the payload before it's sent out to the client.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a new resource and method</h1>
                </header>
            
            <article>
                
<p style="color: black">First, we need to create a new API Gateway resource and method for the&#160;<kbd>get_comments_by_post_id</kbd> endpoint. The steps are the same as the prior section. The only differences will be:</p>
<ul>
<li>The endpoint we'll talk to will be&#160;<a href="https://jsonplaceholder.typicode.com/comments">https://jsonplaceholder.typicode.com/comments</a> rather than the <kbd>/posts</kbd> endpoint</li>
<li>We'll need to map query parameters from the initial client request to the desired query parameters to the backend API that provides the data</li>
</ul>
<p style="color: black">After setting up this new resource and method, it should look like the following:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/f9b798d0-bedc-4c27-b3e4-c1587caef4ec.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up Integration Request</h1>
                </header>
            
            <article>
                
<p style="color: black">First, we need to set up API Gateway so that it passes the expected <kbd>GET</kbd> arguments from the request to our backend. API Gateway allows for controlling the query parameter mapping in the <em>Method Request</em> and <em>Integration Request</em> sections. In the <span class="packt_screen">Method Execution</span> screen:</p>
<ol>
<li>Click on Method Request:&#160;
<ol>
<li>Click on <span class="packt_screen">URL Query String Parameters</span></li>
<li>Click <span class="packt_screen">Add query string parameter</span></li>
<li>Put in&#160;<kbd>post_id</kbd></li>
<li>Leave <span class="packt_screen">required</span>&#160;and <span class="packt_screen">caching</span>&#160;unchecked</li>
</ol>
</li>
<li>Back on the <span class="packt_screen">Method Execution</span>&#160;screen, click on <span class="packt_screen">Integration Request</span>:
<ol>
<li>Expand <span class="packt_screen">URL Query String Parameters</span></li>
<li>Click on <span class="packt_screen">Add query string</span></li>
<li>Put in <kbd>postId</kbd> for <span class="packt_screen">Name</span>&#160;and&#160;<kbd>method.request.querystring.post_id</kbd> for <span class="packt_screen">Mapped from</span></li>
</ol>
</li>
</ol>
<p style="color: black">What we've done here is tell API Gateway to expect a <kbd>GET</kbd> argument named <kbd>post_id</kbd>, which is the old parameter we need to support. From there, Gateway will extract this <kbd>post_id</kbd> attribute and inject it into the Integration Request. The value for <kbd>post_id</kbd> is accessible in&#160;<kbd>method.request.querystring.post_id</kbd>.</p>
<p style="color: black">By adding a new query string named <kbd>postId</kbd> and with a value of&#160;<kbd>method.request.querystring.post_id</kbd>, we're simply passing that value along to the new RESTful API, but using the new parameter name of <kbd>postId</kbd>:</p>
<div style="color: black;font-size: 1em" class="mce-root CDPAlignCenter CDPAlign"><img src="images/d51b0241-b5e5-408a-86d4-56eafdfdf868.png" style="width:51.67em;height:28.25em;"/></div>
<p style="color: black">To test these changes, we need to deploy the API. In the console, in the <span class="packt_screen">Resources</span> section, select the <span class="packt_screen">Actions</span> button and click <span class="packt_screen">Deploy API</span>. Deploy this to our single <kbd>dev</kbd> stage:</p>
<div style="color: black;font-size: 1em" class="mce-root CDPAlignCenter CDPAlign"><img src="images/4543ff55-21af-4f56-ab43-71608b098ba9.png" style="width:20.58em;height:20.58em;"/></div>
<p style="color: black">We can hit our new API and see the results using <kbd>curl</kbd>:</p>
<pre style="color: black"><strong>$ curl https://kwl4kd93i1.execute-api.us-west-2.amazonaws.com/dev/get_comments_by_post_id?post_id=10</strong><br/><strong>[</strong><br/><strong>  {</strong><br/><strong>    "postId": 10,</strong><br/><strong>    "id": 46,</strong><br/><strong>    "name": "dignissimos et deleniti voluptate et quod",</strong><br/><strong>    "email": "Jeremy.Harann@waino.me",</strong><br/><strong>    "body": "exercitationem et id quae cum omnis\nvoluptatibus accusantium et quidem\nut ipsam sint\ndoloremque illo ex atque necessitatibus sed"</strong><br/><strong>  },</strong><br/><strong>  {</strong><br/><strong>    "postId": 10,</strong><br/><strong>    "id": 47,</strong><br/><strong>    "name": "rerum commodi est non dolor nesciunt ut",</strong><br/><strong>    "email": "Pearlie.Kling@sandy.com",</strong><br/><strong>    "body": "occaecati laudantium ratione non cumque\nearum quod non enim soluta nisi velit similique voluptatibus\nesse laudantium consequatur voluptatem rem eaque voluptatem aut ut\net sit quam"</strong><br/><strong>  },</strong><br/><strong>  ...</strong><br/><strong>]</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up Integration Response</h1>
                </header>
            
            <article>
                
<p style="color: black">Now that we have the URL and query parameter mapping working, it's time to begin transforming the response generated from our new API. Since the old JSON structure is different, we'll use Gateway's Body Mapping Templates to take the output from the JSON response and rewrite it. API Gateway uses the Velocity Template language and system to perform this work. If you've ever done web programming with a modern-day web framework, you've undoubtedly worked with a templating library. There are many. Velocity isn't magic; it serves the same purpose as any other templating system: taking some marked up template in a particular syntax along with some contextual data and rendering an output string.</p>
<p style="color: black">In the <span class="packt_screen">Method Execution</span> screen, click on&#160;<span class="packt_screen">Integration Response</span>. Where we are at this point in the request/response cycle is after the backend integration has generated a response, just before the system starts sending the data back to the client. At this stage, we'll configure the Integration Response to rewrite the output to the client using two things:</p>
<ul>
<li>The JSON response from our backend (<kbd>JSONPlaceholder</kbd>)</li>
<li>A body mapping template, which is written&#160;using the Velocity Template language</li>
</ul>
<p style="color: black">In this section, it's possible to set up different body mapping templates based on HTTP response codes and content/type. For simplicity, we'll just be dealing with HTTP 200 and a single <span class="packt_screen">Integration Response</span>, response code, and content/type.</p>
<p style="color: black">In the <span class="packt_screen">Integration Response</span> section:</p>
<ol>
<li>Expand the single row in the table, which is the <span class="packt_screen">Default mapping</span></li>
<li>Expand the <span class="packt_screen">Body Mapping Templates</span> section</li>
<li>Click on the <span class="packt_screen">application/json</span>&#160;in the <span class="packt_screen">Content-Type</span> table</li>
<li>Add the following template code in the text area and click <span class="packt_screen">Save</span></li>
<li>Deploy the API to the <kbd>dev</kbd> stage</li>
</ol>
<p style="color: black">The code block as follows refers to step #4. This is the Velocity Template language syntax:</p>
<pre style="color: black">#set($inputRoot = $input.path('$'))<br/>#foreach ($comment in $inputRoot)<br/>{<br/>  "comment_id": $comment.id,<br/>  "name": "$comment.name",<br/>  "user": {<br/>    "email": "$comment.email"<br/>  },<br/>  "text": "$comment.body"<br/>}<br/>#end</pre>
<p style="color: black">The template code in the preceding code block should be placed in the template section for the <span class="packt_screen">application/json</span>, <span class="packt_screen">Content-Type</span>, as shown in the screenshot as follows:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/1a1bf104-df97-4c44-8afa-cea7f0a2789f.png"/></div>
<p style="color: black">With that out of the way, calling our API will result in a completely different structure of the return payload:</p>
<pre style="color: black"><strong>$ curl https://kwl4kd93i1.execute-api.us-west-2.amazonaws.com/dev/get_comments_by_post_id?post_id=10</strong><br/><strong>{</strong><br/><strong>  "comment_id": 1,</strong><br/><strong>  "name": "id labore ex et quam laborum",</strong><br/><strong>  "user": {</strong><br/><strong>    "email": "Eliseo@gardner.biz"</strong><br/><strong>  },</strong><br/><strong>  "text": "laudantium enim quasi est quidem magnam voluptate ipsam eos</strong><br/><strong>tempora quo necessitatibus</strong><br/><strong>dolor quam autem quasi</strong><br/><strong>reiciendis et nam sapiente accusantium"</strong><br/><strong>}</strong><br/><strong>{</strong><br/><strong>  "comment_id": 2,</strong><br/><strong>  "name": "quo vero reiciendis velit similique earum",</strong><br/><strong>  "user": {</strong><br/><strong>    "email": "Jayne_Kuhic@sydney.com"</strong><br/><strong>  },</strong><br/><strong>  "text": "est natus enim nihil est dolore omnis voluptatem numquam</strong><br/><strong>et omnis occaecati quod ullam at</strong><br/><strong>voluptatem error expedita pariatur</strong><br/><strong>nihil sint nostrum voluptatem reiciendis et"</strong><br/><strong>}</strong></pre>
<p style="color: black">Provided the backend system contains the necessary data, it's possible to implement a complete API with an entirely different structure, writing nothing more than some API Gateway configuration and Velocity Templates. As mentioned earlier, there are many other advantages to API Gateway that you can leverage, which may be extremely useful when replacing a legacy API.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Complex integration using a Lambda function</h1>
                </header>
            
            <article>
                
<p style="color: black">Our prior example is a best-case scenario. Because our new backend system included all of the data we needed to support our legacy API, our jobs were pretty easy. However, what happens in cases where the legacy API you need to support does not have a one-to-one mapping with a newer API? Of course, if you control the new API it's possible to implement any missing functionality. While that may be possible, it may not be a good idea since you may be reimplementing imperfect design in your new and clean RESTful API in order to support a legacy system.</p>
<p style="color: black">In this case, rather than dirtying the new API, it's possible to use a Lambda function as the Integration Type, rather than an HTTP endpoint. With this pattern, the Lambda function may act with some intelligence and perform any type of task that is needed. For example, imagine another legacy endpoint of <kbd>https://$HOSTNAME/get_posts_with_users</kbd> that returns a list of <kbd>posts</kbd> with the <kbd>user</kbd> records embedded in each post record. The new API returns <kbd>posts</kbd> with a structure as follows:</p>
<pre style="color: black">  {<br/>    "userId": 1,<br/>    "id": 5,<br/>    "title": "nesciunt quas odio",<br/>    "body": "repudiandae veniam quaerat..."<br/>  },</pre>
<p style="color: black">However, our legacy API needs that payload to be returned in the form of the following:</p>
<pre style="color: black">{<br/>   "title" : "nesciunt quas odio",<br/>   "id" : 5,<br/>   "user" : {<br/>      "id" : 1,<br/>      "name" : "Leanne Graham",<br/>      "phone" : "1-770-736-8031 x56442",<br/>      "email" : "Sincere@april.biz",<br/>      "username" : "Bret",<br/>      "address" : {<br/>         "suite" : "Apt. 556",<br/>         "street" : "Kulas Light",<br/>         "city" : "Gwenborough",<br/>         "zipcode" : "92998-3874"<br/>      }<br/>   },<br/>   "body" : "repudiandae veniam quaerat..."<br/>}</pre>
<p style="color: black">The new API has the user data available at the <kbd>/users</kbd> endpoint. Using a Lambda function, we can make two separate API calls and mash up the results ourselves.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the application code</h1>
                </header>
            
            <article>
                
<p style="color: black">First, we need to implement our application logic. The code will be very straightforward and I won't cover the details. Everything can be implemented in a mere 42 lines of Python code:</p>
<pre style="color: black;padding-left: 30px">import json<br/><br/>import sys<br/>from pathlib import Path<br/><br/># Munge our sys path so libs can be found<br/>CWD = Path(__file__).resolve().cwd() / 'lib'<br/>sys.path.insert(0, str(CWD))<br/><br/>import requests<br/><br/><br/>def get_users(event, context):<br/>    user_response = requests.get('https://jsonplaceholder.typicode.com/users')<br/>    users = {}<br/>    for user in user_response.json():<br/>        users[user['id']] = user<br/><br/>    post_response = requests.get('https://jsonplaceholder.typicode.com/posts')<br/>    posts = []<br/>    for post in post_response.json():<br/>        user = users[post['userId']]<br/>        posts.append({<br/>            "id" : post['id'],<br/>            "body" : post['body'],<br/>            "title" : post['title'],<br/>            "user" : {<br/>                "id" : user['id'],<br/>                "name" : user['name'],<br/>                "phone" : user['phone'],<br/>                "email" : user['email'],<br/>                "username" : user['username'],<br/>                "address" : user['address'],<br/>                }<br/>        })<br/><br/>    response = {<br/>        "statusCode": 200,<br/>        "body": json.dumps(posts)<br/>    }<br/><br/>    return response</pre>
<p style="color: black">Now that our application logic is making the two HTTP requests to our backend and mashing up the results, we finally have our desired output format, where <kbd>user</kbd> records are embedded in the <kbd>post</kbd> records.</p>
<p style="color: black">Deploying this consists of setting up a serverless <em>service</em> with a single endpoint. Interestingly, we'll define our function in <kbd>serverless.yml</kbd> but will not use any event to trigger this function. The reason for this is that we will manually set up this function to be triggered by our existing API Gateway deployment:</p>
<pre style="color: black;padding-left: 30px">service: api-proxy<br/><br/>provider:<br/>  name: aws<br/>  runtime: python3.6<br/>  region: ${env:AWS_DEFAULT_REGION}<br/><br/>functions:<br/>  GetUsers:<br/>    handler: handler.get_users</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a new resource and method</h1>
                </header>
            
            <article>
                
<p style="color: black">Now, it's time to set up a new resource and <kbd>GET</kbd> method in API Gateway. This time, we'll select <span class="packt_screen">Lambda Function</span>&#160;as the <span class="packt_screen">Integration type</span>. Also, we will want to check <span class="packt_screen">Use Lambda Proxy integration</span>. The reason for choosing this now is that we can control details of the response from our application code run by Lambda. If there is a need to update headers or otherwise transform the response, we simply update our application code and redeploy the Lambda function:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/81b312da-7b79-41bf-add0-46b1b8c346ea.png"/></div>
<p style="color: black">Select the already deployed Lambda function, click <span class="packt_screen">Save</span>, and we're all done. There is no need to update the <span class="packt_screen">Method Request</span> or <span class="packt_screen">Integration</span> since we may perform any transformations from the application code.</p>
<p style="color: black">Finally, deploy the API, hit the new API endpoint, and see the results:</p>
<pre style="color: black;padding-left: 30px">[<br/>   {<br/>      "title" : "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",<br/>      "id" : 1,<br/>      "body" : "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto",<br/>      "user" : {<br/>         "name" : "Leanne Graham",<br/>         "email" : "Sincere@april.biz",<br/>         "username" : "Bret",<br/>         "id" : 1,<br/>         "address" : {<br/>            "geo" : {<br/>               "lng" : "81.1496",<br/>               "lat" : "-37.3159"<br/>            },<br/>            "suite" : "Apt. 556",<br/>            "city" : "Gwenborough",<br/>            "street" : "Kulas Light",<br/>            "zipcode" : "92998-3874"<br/>         },<br/>         "phone" : "1-770-736-8031 x56442"<br/>      }<br/>   },<br/>   ...<br/>}</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Migration techniques</h1>
                </header>
            
            <article>
                
<p style="color: black">In these examples, we've taken a look at a few strategies for implementing a new API using existing API backends. Another common scenario is migrating an <em>existing</em> API to a serverless architecture, <em>without</em> changing any of its functionality. In this scenario, we can still use the proxy pattern and API Gateway. With all of the work in place ready to go, how does one actually deploy a new proxy layer without affecting existing traffic or breaking these clients? The following are a few techniques and deployment strategies that you may consider when faced with this problem.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Staged migration</h1>
                </header>
            
            <article>
                
<p style="color: black">To replace an existing API with a serverless-based system, it makes sense to first implement the proxy pattern and define the complete API in API Gateway. Each endpoint would simply proxy requests and responses to and from their corresponding APIs on the system to be replaced.</p>
<p style="color: black">It's even possible to start initial testing with what is called a <strong>proxy resource</strong>. With this model, one creates a resource in API Gateway named <kbd>{proxy+}</kbd>. This is a greedy resource and will match any URL path that doesn't already exist, be it <kbd>/cats</kbd>, <kbd>/users/10/comments</kbd>, and so on. It will also match on any HTTP verb. In short, it's a catch-all that will send any request that doesn't match an existing resource on to the configure Integration backend:</p>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="images/34bf8d80-a3ee-4b06-b5eb-aa8ff4c583f2.png"/></div>
<p style="color: black">Doing this first is a good way to start testing the interaction between Gateway and your backend system since you can build out a full test suite without the fear of misconfiguring anything. Slowly, you may begin implementing and replacing different APIs one by one. In this fashion, you can work at your own pace without the fear of flipping a switch to move <em>all</em> APIs to some new system at once. If a single deployment of a new serverless API doesn't go well, rolling back takes mere seconds by deleting the resource and redeploying the API. Since the proxy resource will catch any non-matching URL paths, deleting a problematic resource simply points that URL path back to the original HTTP integration endpoint. This is as simple of a rollback procedure as you'll find.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Migrating URLs</h1>
                </header>
            
            <article>
                
<p style="color: black">You may have noticed that the URLs provided by API Gateway are quite obscure and not easy to remember, for example, <a href="https://eocmzivub6.execute-api.us-west-2.amazonaws.com">https://eocmzivub6.execute-api.us-west-2.amazonaws.com</a>. In the example of replacing a legacy API from under existing users, the ideal scenario is to merely update DNS records.</p>
<p style="color: black">For example, presume the API you're migrating is located at&#160;<kbd>&#160;https://api.mysite.io</kbd>&#160;and that this URL is embedded across thousands of devices in a mobile application. Forcing users to update their code isn't feasible with thousands of clients. You know that there will be traffic to that subdomain for a long time.</p>
<p style="color: black">API Gateway provides the ability to apply a custom domain to an API and provides free SSL/TLS certificates. With those two features, a migration would be fairly straightforward. Assuming you've implemented and thoroughly tested the new API Gateway version of your API, the migration would consist of:</p>
<ul>
<li>Setting up <kbd>api.mysite.io</kbd>&#160;as a custom domain in API Gateway</li>
<li>Creating a TLS certificate for <kbd>api.mysite.io</kbd> from API Gateway (using Amazon Certificate Manager, ACM)</li>
<li>Updating DNS to point to the API Gateway URL</li>
</ul>
<p style="color: black">In cases where the URL is not running on a subdomain, life becomes more complex. For example, if you have an existing web application running at <kbd>https://mysite.io</kbd> and the API is found at <kbd>https://mysite.io/api</kbd>, changing DNS would not work since it would break it for the users of your web application. In this case, there are two viable options:</p>
<ul>
<li>Use or set up some type of router or load balancer that supports path-based routing</li>
<li>Update application code to call the API Gateway endpoints for any request to <kbd>/api</kbd></li>
</ul>
<p style="color: black">A load balancer such as HAProxy would work out well here since it provides path-based routing and is extremely fast. If it's not feasible to set up a system such as that, a final solution would be to manually proxy requests from your own application code to the API Gateway endpoint. That method isn't elegant, but technically it would work provided headers and query parameters are forwarded along to API Gateway.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p style="color: black">In this chapter, we introduced the proxy pattern using API Gateway from AWS. We walked through multiple examples of mimicking a legacy API using an existing RESTful URL as an HTTP integration. You learned the four stages of API Gateway method execution and some of the details surrounding each of those integration points. We also discussed the proxy pattern when integrating with an AWS Lambda function, which provides a bit more control at the expense of more maintenance.</p>
<p style="color: black">Readers should understand the proxy pattern and have a rough idea of how to implement this themselves using API Gateway after this chapter.</p>
<p style="color: black">In the next chapter, we'll move our focus from web application patterns to those for data processing.</p>


            </article>

            
        </section>
    </div>
</body>
</html>