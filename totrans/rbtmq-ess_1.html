<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    A Rabbit Springs to Life
                </header>
            
            <article>
                
<p><strong><span>Messaging</span></strong><span> or </span><strong><span>message queuing</span></strong><span> is a method of communication between applications or components. Thanks to message queues, these applications can remain completely separate as they process their individual tasks. Messages are typically small requests, replies, status updates, or even just information. A message queue provides a temporary place for these messages to stay, allowing applications to send and receive them as necessary.</span></p>
<p><span>RabbitMQ is an open source message broker that acts as the intermediary or middleman for independent applications, giving them a common platform to communicate. RabbitMQ mainly uses an Erlang-based implementation of the </span><strong><span>Advanced Message Queuing Protocol </span></strong><span>(</span><strong><span>AMQP</span></strong><span>)</span><span>, which supports advanced features such as clustering and the complex routing of messages.</span></p>
<p>This chapter includes information about how to get started with RabbitMQ, and why it would benefit an architecture. This book follows a fictitious taxi agency, <strong>Complete Car</strong> (<strong>CC</strong>), to demonstrate how they have implemented RabbitMQ into the architecture. This chapter shows how to install and configure RabbitMQ so that it's easy to get everything up and running.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li><span>Explaining message queues</span></li>
<li>Discovering AMQP and RabbitMQ</li>
<li><span>Using RabbitMQ in real life</span></li>
<li><span>Exploring the benefits of message queuing</span></li>
<li>A RabbitMQ scenario</li>
<li><span>Getting ready for RabbitMQ</span></li>
</ul>
<p>Let's get started!</p>
<h1 id="uuid-e69eb855-02fe-4d2a-98bb-3350dc9fd714"><span class="fontstyle0">Technical requirements</span></h1>
<p class="mce-root">The code files of this chapter can be found on GitHub at<span> <a href="https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01">h ttps://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01</a></span>.</p>
<h1 id="uuid-15c58c8b-9d50-4e6a-a224-6bba61c94ac5"><span>Explaining message queues</span></h1>
<p>Smoke signals, couriers, carrier pigeons, and semaphores: if this was a riddle, the word <strong>messages </strong>would immediately spring to mind. Humanity has always had the need to connect, finding new ways to defy challenges posed by the distance between the different groups of people needing to communicate. Humankind has come a long way with modern technologies, but essentially, the basics remain. Senders, recipients, and messages are at the core of all our communication infrastructures.</p>
<p>Software applications have the same needs; systems need to communicate and send messages between each other. They sometimes need to be sure that the message that's been sent has reached its destination, and sometimes they need to receive an immediate response. In some cases, they may even need to receive more than one response. Based on these different needs, different styles of communication between systems have emerged.</p>
<p><span class="st">AMQP, RabbitMQ's default protocol, is explained in the next section.</span></p>
<h1 id="uuid-c97a39f1-17a9-40b4-9fbb-c9e2d2a809e4">Discovering AMQP and RabbitMQ</h1>
<p>Message queuing is a one-way communication style that provides asynchronous interaction between systems. As this chapter continues to describe how message queues work, the benefits will become clear. Some background on the request-response message exchange pattern will shed light on how RabbitMQ works.</p>
<h2 id="uuid-3cdbfdc2-213c-44ad-b956-04c88a61e491">The request-response message exchange pattern</h2>
<p>There are many types of message exchange patterns, but the request-response style is the most common. A system, acting as a client, interacts with another remote system, which is acting as a server. The client sends a request for data, and the server responds to the request, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-615 image-border" src="assets/55761e1c-afc1-4fe2-8ffa-338ca2cfc21b.png" style="width:28.17em;height:13.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.1: The request-response interaction between the client and the server</div>
<p>The request-response style is used when the client must have an immediate response or wants the service to complete a task without delay, such as being placed on hold when calling a restaurant to reserve a table:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-616 image-border" src="assets/71dd3f7d-9555-4fe8-a6fd-a21aca382a9d.png" style="width:30.50em;height:13.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.2: Request-response between a client and a restaurant</div>
<p>Whether it takes the form of a remote procedure call, a web service invocation, or consumption of a resource, the model is the same: one system sends a message to another and waits for the remote party to respond. Systems communicate with each other in a point-to-point manner, where events and processes occur simultaneously or have dependencies or events related to time; the interaction between the client and server is <strong>synchronous</strong>.</p>
<p>One on hand, this request-response style gives developers a simple programming model as everything happens procedurally. On the other hand, the tight coupling between both parties has a deep impact on the architecture of the whole system as it is hard to evolve, hard to scale, and hard to ship in independent releases.</p>
<h2 id="uuid-a2a2028c-a4bc-440a-bafa-fd8bd22aea84">Message queuing exchange pattern</h2>
<p class="mce-root"><span>Message queuing is a one-way style of interaction where one system asynchronously interacts with another system via messages, generally through a message broker. </span><span>A requesting system in asynchronous communication mode does not wait for an answer or require return information; it continues processing no matter what.</span> <span>The most common example of such an interaction is an email. The point is, asynchronous communication does not involve waiting for a response in order to continue processing. In fact, there may be no response or it may take some time for a response to be sent. Whatever the case, the system does not rely on a response to continue the process.</span></p>
<p>Messages flow in one direction, from the publisher to the broker and finally to the consumer:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-617 image-border" src="assets/e10308b6-e487-4927-8405-bcfbf5587839.png" style="width:68.00em;height:14.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 1.3: Basic components of a one-way interaction with message queuing</div>
<p>Systems and applications play both the role of message publishers (producers) and message consumers (subscribers). A publisher publishes a message to a broker that they rely on to deliver the data to the intended consumer. If a response is required, it will arrive at some point in time through the same mechanism, but reversed (the consumer and producer roles will be swapped).</p>
<h2 id="uuid-5a8fda62-b9a9-4042-8964-c9b196291edb">A loosely coupled architecture</h2>
<p>One big advantage of the messaging queuing approach is that systems become loosely coupled with each other. They do not need to know the location of other nodes on the network; a mere name is enough to reach them. Systems can, therefore, be evolved in an independent manner with no impact on each other as the reliability of message delivery is entrusted to a broker.</p>
<p>The following diagram illustrates a loose coupling between the publisher and the consumer:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-618 image-border" src="assets/09a9fe21-6b50-4db2-8496-81930a935750.png" style="width:48.33em;height:23.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 1.4: Message queuing enabling a loosely coupled architecture</div>
<p>If one system is down for any reason, the other part of the system can still operate, and messages that are supposed to be sent between them wait in the queue.</p>
<p>The architecture represented via message queuing allows for the following:</p>
<ul>
<li>The publishers or consumers can be updated one by one, without them impacting each other.</li>
<li>The performance of each side leaves the other side unaffected.</li>
<li>The publishers or consumers are allowed to fail without impacting each other.</li>
<li>The number of instances of publishers and consumers to scale and to accommodate their workload in complete independence.</li>
<li>Technology mixing between consumer and publishers.</li>
</ul>
<p>The main downside of this approach is that programmers cannot rely on the mental model of procedural programming where events occur one after another. In messaging, things happen over time. Systems must be programmed to deal with this.</p>
<p>If all this is a little blurry, use the example of a well-known protocol, <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>). In this protocol, emails are published (sent) to an SMTP server. This initial server then stores and forwards the email to the next SMTP server, and so on until the recipient email server is reached. At this point, the message is queued in an inbox, waiting to be picked up by the consumer (typically, via POP3 or IMAP). With SMTP, the publisher has no idea when the email will be delivered or whether it will eventually be delivered at all. In the case of a delivery failure, the publisher is notified of issues later down the line.</p>
<p>The only sure fact is that the broker has successfully accepted the message that was initially sent. This entire process can be seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1022 image-border" src="assets/3bd7cc21-3873-4dd2-9881-85803726d75f.png" style="width:141.00em;height:28.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 1.5: The email infrastructure as an analogy for message queuing</div>
<p class="mce-root"><span>Furthermore, if a response is needed, it will arrive asynchronously using the same delivery mechanism but with the publisher and consumer roles reversed.</span></p>
<p class="mce-root">With these fundamental notions established, it is the perfect time to delve into the messaging protocol that will be used in this book, which is AMQP.</p>
<h2 id="uuid-abbc4c3c-20aa-4e24-b0dd-d6ba173e23e5">Meet AMQP</h2>
<p><span><span class="ILfuVd NA6bn"><span class="e24Kjd"><span class="st"><strong>AMQP</strong> is an open standard protocol that defines how a system can exchange messages. The protocol defines a set of rules that needs to be followed by the systems that are going to communicate with each other.</span></span></span></span> <span>In addition to defining the interaction that happens between a consumer/producer and a broker, it also defines the representation of the messages and commands being exchanged. AMQP is truly interoperable as it specifies the wire format for messages, leaving nothing open to interpretation by a particular vendor or hosting platform. Since it is open source, the AMQP community is prolific and has broker and client implementations in a wide range of languages.</span></p>
<p>RabbitMQ is built upon the AMQP 0-9-1 specification, but plugins are available that support AMQP 1.0.</p>
<div class="packt_infobox">
<p>The AMQP 0-9-1 specification can be downloaded at <a href="http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf">http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf</a>.</p>
</div>
<p>The following is a list of the core concepts of AMQP, which will be explained in detail in upcoming chapters:</p>
<ul>
<li><strong>Broker or message broker</strong>: <span>A broker is a piece of software that receives messages from one application or service, and delivers them to another application, servi</span>ce, or broker.</li>
<li><strong>Virtual host, vhost</strong>: <span>A vhost exists within the broker. It's a way to separate applications that are using the same RabbitMQ instance, similar to a logical container inside a broker; for example, separating working environments into development on one vhost and staging on another, keeping them within the same broker instead of setting up multiple brokers. Users, exchanges, queues, and so on are isolated on one specific vhost. A user connected to a particular vhost cannot access any resources (queue, exchange, and so on) from another vhost. Users can have different access privileges to different vhosts.</span></li>
<li><strong>Connection</strong>: Physical network (TCP) connection between the application (publisher/consumer) and a broker. When the client disconnects or a system failure occurs, the connection is closed.</li>
<li><strong>Channel</strong>: A channel is a <strong>virtual connection</strong> inside a <strong>connection</strong><em>.</em> It reuses a connection, forgoing the need to reauthorize and open a new TCP stream. When messages are published or consumed, it is done over a channel. Many channels can be established within a single connection.</li>
<li><strong>Exchange</strong><span>:</span> <span>The exchange entity is in charge of applying routing rules for messages, making sure that messages are reaching their final destination. In other words, the exchange ensures that the received message ends up in the correct queues. Which queue the message ends up in depends on the rules defined by the exchange type. A queue needs to be bound to at least one exchange to be able to receive messages. Routing rules include direct (point-to-point), topic (publish-subscribe), fanout (multicast), and header exchanges.</span></li>
<li><strong>Queue</strong><span>: A</span> queue <span>is a sequence of items; in this case, messages. The queue exists within the broker.</span></li>
<li><strong>Binding</strong><span>: A binding is a virtual link between an exchange and a</span> queue <span>within the broker. It enables messages to flow from an exchange to a queue.</span></li>
</ul>
<p>The following diagram illustrates an overview of some of the concepts in AMQP:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-620 image-border" src="assets/eb85d456-ba34-460a-ba06-4a916b6296f3.png" style="width:58.75em;height:18.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.6: Overview of some of the concepts defined by the AMQP specification</div>
<p>The open source broker shown in detailin this book has been built from the ground up to support AMQP, but many other protocols are also supported by RabbitMQ, such as MQTT, HTTP, and STOMP.</p>
<p>Now, it's time to turn the focus to RabbitMQ.</p>
<h2 id="uuid-c2fda0d1-c48a-4aef-a38f-605a12effba8">The RabbitMQ broker</h2>
<p>RabbitMQ is an Erlang implementation of an AMQP broker. It implements Version 0-9-1 of AMQP with custom extensions, as allowed by the protocol. Erlang has been chosen because of its intrinsic support for building highly reliable and distributed applications. Indeed, Erlang is used to run telecommunication switches in several large telecommunication systems, and a total system's availability of nine nines has been reported (that's only 32 milliseconds of downtime per year). Erlang is able to run on any operating system.</p>
<p><span>For data persistence, RabbitMQ relies on Mnesia, the in-memory/file-persisted embedded database of Erlang. Mnesia stores information about users, exchanges, queues, bindings, and so on. The queue index stores message positions and information on whether a message has been delivered or not. Messages are stored either in the queue index or in the message store, a key-value store shared among all queues.</span></p>
<p>For clustering, it mainly relies on Erlang's ingrained clustering abilities. RabbitMQ can easily be extended with the addition of plugins. For example, a web-based administration console can be deployed on RabbitMQ thanks to this mechanism.</p>
<div class="packt_tip">Plugins can be used to extend the core broker functionality. There are many plugins available for RabbitMQ, and it's also possible to develop plugins, if needed: <a href="https://www.rabbitmq.com/plugins.html">https://www.rabbitmq.com/plugins.html</a>.</div>
<p>RabbitMQ can be set up on a single, standalone instance, or as a cluster on multiple servers:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-621 image-border" src="assets/af1f86a8-0764-4632-afdd-1b618669a3e2.png" style="width:27.83em;height:12.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.7: Standalone instance, or as a cluster on multiple servers</div>
<p>RabbitMQ brokers can be connected together using different techniques, such as federation and shovels, in order to form messaging topologies with smart message routing across brokers and the capacity to span multiple data centers.</p>
<p>The following screenshot shows federation between RabbitMQ brokers located in different places around the world:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-622 image-border" src="assets/d81c5d31-c38f-43fd-884c-797e97efe07e.png" style="width:35.00em;height:15.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.8: The RabbitMQ broker engaging in various topologies</div>
<div class="packt_infobox"><strong><span>RabbitMQ supports AMQP 1.0 through plugins.</span></strong> <br/>
<br/>
AMQP 1.0 was published at the end of 2011 after the development and maintenance of AMQP was transferred to OASIS. AMQP has been drastically revised between 0-9-1 and 1.0. This was so drastic that some core concepts, such as the exchange, no longer exist. Thus, AMQP 1.0 is a different protocol than 0-9-1, but there is no truly compelling reason to adopt it. It is not more capable than 0-9-1, and some would also argue that it has lost some of the key aspects that made it attractive in the first place.</div>
<p>So, when or where is RabbitMQ used? The next section describes some common use cases for RabbitMQ.</p>
<h1 id="uuid-0d130308-c2e3-40fb-b068-cbdae395f1ea"><span>Using RabbitMQ in real life</span></h1>
<p>The most common use case for RabbitMQ is a single producer, single consumer queue. Think of it as a pipe where one application puts messages into one end of the pipe and another application reads the messages that come out the other end. Messages are delivered in first in, first out order. These messages may be commands or contain important data. This sounds easy, but where could this type of architecture be applied? It's time to understand when and why message queuing shines!</p>
<h2 id="uuid-ac99ab4e-a61e-4bb8-9a47-cdfb559e285b">Message queues between microservices</h2>
<p>Message queues are often used in between microservices, but what does that mean?</p>
<p>Microservice architectural style divides the application into small services, with the finished application being the sum of its microservices. The services are not strictly connected to each other. Instead, they use, for example, message queues to keep in touch. One service asynchronously pushes messages to a queue and those messages are delivered to the correct destination when the consumer is ready.</p>
<p>The microservice architecture is often compared and contrasted with the monolith architecture, where the entire system is bundled together into one piece of software. One application is not only responsible for a particular task; it actually performs every step needed to complete a particular function. Monoliths communicate within the system since all the parts are running in the same process. This system is highly coupled since every function is reliant on the others.</p>
<p>In an example of a webshop built on a monolith architecture style, one system handles all of the functions, including inventory, payments, reviews, and ratings and so on, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-623 image-border" src="assets/2b1c0208-cfbf-47aa-ae97-71be171caf27.png" style="width:22.75em;height:14.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.9: A webshop built in a monolith architecture style</div>
<p>A webshop built on the microservice architecture, on the other hand, means that each part of the system is an individual activity. One microservice handles reviews and ratings. Then, there's another inventory, and then yet another for payments, and so on, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-624 image-border" src="assets/f23a3835-2ccf-4bfe-836a-69137a57861f.png" style="width:36.50em;height:11.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.10: A microservice architecture style where each part is focused on a single business capability</div>
<p>Each pair of requests and responses communicates independently. This is known as stateless communication. While many microservices are involved, they are not directly dependent on each other.</p>
<p>Another typical use case for RabbitMQ is as a task queue, which we'll cover in the next section.</p>
<h2 id="uuid-cb41ff4e-dc11-4c05-b57a-f32bf46e503c">Event and tasks</h2>
<p>Events are notifications that tell applications when something has happened. One application can subscribe to events from another application and respond by creating and handling tasks for themselves. A typical use case is when RabbitMQ acts as a task queue that handles <strong>slow</strong> operations.</p>
<p>Let's take a look at two examples of this:</p>
<ul>
<li>Imagine a social media application such as Instagram. Every time someone publishes a new post, the network (followers) needs to be informed about the new post. This could be a very time-consuming operation. Millions of people could be trying to perform the same task at the same time. The application can, with the use of message queues, enqueue a task onto the queue for each post as it arrives. When the worker receives the request, it retrieves a list of followers for the sender, and updates each of them.</li>
<li><span>As another example, think of an email newsletter campaign </span>tool that is sending out thousands of emails to thousands of users. With a possible scenario where many users trigger bulk messages at the same time. The email newsletter campaign tool needs to be able to handle this volume of messages. All these emails can be added to a push queue with instructions to the worker regarding what to send and to whom. Every single email is handled, one by one, until all the emails have been sent.</li>
</ul>
<p>The following diagram shows a task queue, where messages are first entering the queue, and then handled. New tasks are then added to another queue:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-625 image-border" src="assets/768cecf3-08a9-46c0-a5b5-d41491b3b207.png" style="width:35.33em;height:12.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.11: Event and task queue</div>
<p>With that, we've looked at and reviewed two typical use cases. The benefits of RabbitMQ have been apparent in each. We'll make this even more evident by exploring the benefits of message queuing in the next section.</p>
<h1 id="uuid-3bca0034-0fde-4481-abee-1fc6a625849a"><span>Exploring the benefits of message queuing</span></h1>
<p>Communication between various applications plays an important role in distributed systems. There are many examples of when a message queue can be used, so let's highlight some features and benefits of message queuing in microservice architectures:</p>
<ul>
<li><strong>Development and maintenance made easier</strong>: Dividing an application across multiple services allows separate responsibilities and gives developers the freedom to write code for a specific service in any chosen language. It will be easier to maintain written code and make changes to the system; when updating a single authentication scheme, only the authentication module must have code added for testing, without it disrupting any other functions.</li>
<li><strong>Fault isolation</strong>: A fault can be isolated to a single module and will thereby not affect other services. For example, an application with a reporting service temporarily out of function will not affect the authenticate or payment services. As another example, making changes to the reporting service still allows customers to perform essential transactions, even when they aren't able to view reports.</li>
<li><strong>Enhanced levels of speed and productivity</strong>:<strong> </strong>Different developers are able to work on different modules at the same time. In addition to speeding up the development cycle, the testing phase is also impacted by the use of microservices and message queues. This is because each service can be tested on its own to determine the readiness of the overall system.</li>
<li><strong>Improved scalability</strong>: Microservices also allow for effortless scale-out at will. It's possible to add more consumers if the message queue is growing. Adding new components to just one service is easy to do without changing any other service.</li>
<li><strong>Easy to understand</strong>: Since each module in a microservice architecture represents a single functionality, getting to know the relevant details for a task is easy. For example, hiring a consultant for a single service does not require them to understand the entire system.</li>
</ul>
<p>Now that is enough knowledge to be dangerous, so it is a good time to dive into the RabbitMQ scenario company that sets the scene for the rest of this book.</p>
<h1 id="uuid-a80f92af-28a4-4533-a148-3c5178cb8af4">A RabbitMQ scenario</h1>
<p class="mce-root">CC is a new taxi agency with huge potential. Today, the company has just two taxi drivers and two developers, but they want to expand a lot in the upcoming year. CC has already built a website in Ruby and started out with a backend, also written in Ruby, that stores CC trips in a database. CC also has some scripts, written in Python, that generate route reports.</p>
<p>So far, CC's system runs as follows:</p>
<ul>
<li>The company's website and blog runs on Ruby.</li>
<li>The Rich Internet Application that stores route data, such as the starting point and the endpoint of the trip, is written in Ruby.</li>
<li>There's a back-office that sends route updates to drivers and is written in Ruby.</li>
<li>Multiple ad hoc Python scripts are used to extract and message data to generate route reports.</li>
<li>Taxi applications are written in Python.</li>
</ul>
<p>The old architecture is illustrated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-626 image-border" src="assets/31b397de-241d-45ae-af51-4b191c803e71.png" style="width:56.50em;height:20.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Fig 1.12: C</span><span>C</span> software landscape</div>
<p class="CDPAlignLeft CDPAlign"><span>Why is CC looking at adding RabbitMQ to an already busy environment? The main reason is because of a new feature CC wants to offer to their customers – they want to build a taxi application that handles reservations on the go. CC also wants to be able to scale painlessly. The plan is to build an app where users can book a car via a smartphone, receive booking confirmation, and view the car approaching the starting point of the trip.</span></p>
<p>Since CC already has some services in different languages, and since CC wants to be able to scale easily, they decided to use a ready-made message-oriented middleware such as RabbitMQ for asynchronous communication between the app, the client, and the backend.</p>
<p>As CC's knowledge and usage of RabbitMQ increases, they will discover new opportunities to leverage it in the environment. For now, let's follow CC as it gets started with its very first step into working with RabbitMQ.</p>
<h1 id="uuid-39cdad8a-4670-44ea-9563-ad860eaa7036"><span>Getting ready for RabbitMQ</span></h1>
<p>To get started, the following three installation and configuration steps need to be completed:</p>
<ul>
<li>Installing the RabbitMQ broker</li>
<li>Installing the management plugin (Web UI)</li>
<li>Configuring the vhost and user</li>
</ul>
<p>Let's start by installing the broker!</p>
<h2 id="uuid-cbdbd704-10bd-4384-b8ca-06ecccc11b18">Installing the broker</h2>
<p>CC runs its production servers on Ubuntu Linux. One developer has macOS and Linux, while the other one is all Windows. This heterogeneity is not a concern for RabbitMQ, which can run natively on all these operating systems.</p>
<p>RabbitMQ provides complete online installation guides for all the supported operating systems, and they can be found here: <a href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a>. This book contains instructions for Debian/Ubuntu, where RabbitMQ is installed from the <kbd>apt</kbd> repository. It also contains instructions for Docker further down in this chapter.</p>
<h3 id="uuid-b1a9f4da-4122-4ab2-a335-924df606d159">RabbitMQ installation on Ubuntu</h3>
<p>There are relatively few steps required to install RabbitMQ. They are as follows:</p>
<ol>
<li>Update Ubuntu.</li>
<li>Download and install the repository key.</li>
<li>Ensure the key is in the repository.</li>
<li>Install RabbitMQ from the package repository.</li>
</ol>
<p>Ensure that Ubuntu is up to date before starting the download process. Make sure that the operating system is using the latest versions of all software since outdated dependencies create security vulnerabilities.</p>
<p>Run the <kbd>apt update</kbd> command to download the latest releases of the installed software:</p>
<pre>apt upgrade</pre>
<p>RabbitMQ requires several software packages. Verify that <kbd>curl</kbd>, <kbd>apt-transport-https</kbd>, and <kbd>GnuPG</kbd> are on the system by running the following command:</p>
<pre>sudo apt install curl gnupg -y<br/>sudo apt install apt-transport-https</pre>
<p>The <kbd>-y</kbd> option accepts any licenses for these dependencies. Ubuntu installs all required sub-packages.</p>
<p>Discover the name of the operating system by running any of the following commands:</p>
<ul>
<li><kbd>cat /etc/os-release</kbd></li>
<li><kbd>lsb_release -a</kbd></li>
<li><kbd>hostnamectl</kbd></li>
</ul>
<p>The release name is non-technical. Previous names include <kbd>focal</kbd> and <kbd>bionic</kbd>. Ubuntu does not include RabbitMQ by default, so it must be added to the repository key before you proceed. Execute the following set of commands in a Terminal:</p>
<pre>curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc <br/>sudo apt-key add -<br/>sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list &lt;&lt;EOF<br/>deb https://dl.bintray.com/rabbitmq-erlang/debian [os release name] erlang<br/>deb https://dl.bintray.com/rabbitmq/debian [os release name] main<br/>EOF</pre>
<p>These commands download the key and add it to the repository list before adding the appropriate operating system packages for the broker and Erlang.</p>
<p>RabbitMQ is written in Erlang, a functional language that has robust built-in support for creating distributed networks. The developers maintain a list of minimum versions (<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a>) of the language for the latest supported releases of the broker. At the time of writing, RabbitMQ 3.8 supports Erlang 21.3 through 23.</p>
<p>RabbitMQ can now be installed correctly.</p>
<div class="packt_tip">Though not absolutely required for using RabbitMQ, it is encouraged to discover this powerful language and platform. You can learn more about Erlang at <a href="http://www.erlang.org/">http://www.erlang.org/</a>. Alternatively, you can consider Elixir as an optional language for the Erlang <strong>virtual machine</strong> (<strong>VM</strong>). You can find out more about this at <a href="http://elixir-lang.org">http://elixir-lang.org</a>.</div>
<p>Run the following commands to install RabbitMQ:</p>
<pre>sudo apt install -y rabbitmq-server<br/>sudo apt install librabbitmq-dev </pre>
<p>The <kbd>librabbitmq-dev</kbd> library includes a client for interacting with the broker. However, the server may be the only requirement.</p>
<h3 id="uuid-69eac2c9-eca6-4c16-aee8-0bb6de83e752">RabbitMQ installation on Docker</h3>
<p>Docker containers allow the separation and control of resources without risking corrupting the operating system. Instructions for installing Docker are available from the official website: <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>. With Docker installed, pull the RabbitMQ image:</p>
<pre>docker pull rabbitmq</pre>
<p>Run the broker with reasonable defaults:</p>
<pre>docker run -d --hostname my-rabbit --name my-rabbit -p 5672:5672 -p 15672:15672 -e RABBITMQ_ERLANG_COOKIE='cookie_for_clustering' -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password  --name some-rabbit rabbitmq:3-management</pre>
<p>A Docker container needs to be created so that it's accessible from the <kbd>localhost</kbd> with the management console enabled. This will be discovered shortly.</p>
<h3 id="uuid-b25c7fcd-65a3-49c0-8a72-6e6570171d1b">Starting RabbitMQ</h3>
<p>Installing the RabbitMQ server from the repository also installs a suite of command-line tools used to start the server for the first time. This is done by executing the following command:</p>
<pre>rabbitmq-server start </pre>
<p>The server starts in the foreground. To run the broker as a service, use the following commands:</p>
<pre>sudo systemctl enable rabbitmq-server<br/>sudo systemctl start rabbitmq-server<br/>sudo systemctl status rabbitmq-server </pre>
<p>The <kbd>systemctl</kbd> command can also be used to manage services in Ubuntu. The output of the final command should show that the broker is running. Consult the RabbitMQ documentation (<a href="https://www.rabbitmq.com/troubleshooting.html">https://www.rabbitmq.com/troubleshooting.html</a>) if not.</p>
<h3 id="uuid-2c0f29b0-7924-4e31-b73f-0fe3a39dcfad">Downloading the example code</h3>
<p>Download all the example code files for this book. They can be purchased from <a href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files emailed to you directly.</p>
<h3 id="uuid-c8c02bae-c285-4cd1-ae24-3c016b8ca629">Verifying that the RabbitMQ broker is running</h3>
<p>Now, verify that the RabbitMQ broker is actually working by using the <kbd>status service</kbd> command.</p>
<p>Write the following line in the Terminal:</p>
<pre class="mce-root">$ sudo service rabbitmq-server status<br/>  rabbitmq-server.service - RabbitMQ broker<br/>   Loaded: loaded (/lib/systemd/system/rabbitmq-server.service; enabled; vendor preset: enabled)<br/>  Drop-In: /etc/systemd/system/rabbitmq-server.service.d<br/>           └─10-limits.conf, 90-env.conf<br/>   Active: active (running) since Mon 2019-04-29 13:28:43 UTC; 1h 43min ago<br/>  Process: 27474 ExecStop=/usr/lib/rabbitmq/bin/rabbitmqctl shutdown (code=exited, status=0/SUCCESS)<br/> Main PID: 27583 (beam.smp)<br/>   Status: "Initialized"<br/>    Tasks: 87 (limit: 1121)<br/>   CGroup: /system.slice/rabbitmq-server.service<br/>           ├─27583 /usr/lib/erlang/erts-10.2.2/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 <br/>           ├─27698 /usr/lib/erlang/erts-10.2.2/bin/epmd -daemon<br/>           ├─27854 erl_child_setup 1000000<br/>           ├─27882 inet_gethost 4<br/>           └─27883 inet_gethost 4<br/><br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:   ##  ##<br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:   ##  ##      RabbitMQ 3.7.14. Copyright (C) 2007-2019 Pivotal Software, Inc.<br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:   ##########  Licensed under the MPL.  See https://www.rabbitmq.com/<br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:   ######  ##<br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:   ##########  Logs: /var/log/rabbitmq/rabbit@test-young-mouse-01.log<br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:                     /var/log/rabbitmq/rabbit@test-young-mouse-01_upgrade.log<br/>Apr 29 13:28:42 test-young-mouse-01 rabbitmq-server[27583]:               Starting broker...<br/>Apr 29 13:28:43 test-young-mouse-01 rabbitmq-server[27583]: systemd unit for activation check: "rabbitmq-server.service"<br/>Apr 29 13:28:43 test-young-mouse-01 systemd[1]: Started RabbitMQ broker.<br/>Apr 29 13:28:43 test-young-mouse-01 rabbitmq-server[27583]:  completed with 9 plugins.</pre>
<div class="packt_tip">The default folders where the package has installed files are <kbd>/etc/rabbitmq</kbd> for configuration files, <kbd>/usr/lib/rabbitmq</kbd> for application files, and <kbd>/var/lib/rabbitmq</kbd> for data files (<kbd>mnesia</kbd>).</div>
<p>Look at the running processes for RabbitMQ and find both the service wrapper and the Erlang VM<span> (also known as BEAM) that's running, as follows:</span></p>
<pre><strong>$ pgrep -fl rabbitmq</strong><br/>27583 beam.smp<br/><br/><strong>$ ps aux | grep rabbitmq</strong><br/>ubuntu   10260  0.0  0.1  14856  1004 pts/0    S+   15:13   0:00 grep --color=auto rabbitmq<br/>rabbitmq 27583  0.5  8.5 2186988 83484 ?       Ssl  13:28   0:36 /usr/lib/erlang/erts-10.2.2/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K true -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/librabbitmq/lib/rabbitmq_server-3.7.14/ebin  -noshell -noinput -s rabbit boot -sname rabbit@test-young-mouse-01 -boot start_sasl -config /etc/rabbitmq/rabbitmq -kernel inet_default_connect_options [{nodelay,true}] -sasl errlog_type error -sasl sasl_error_logger false -rabbit lager_log_root "/var/log/rabbitmq" -rabbit lager_default_file "/var/log/rabbitmq/rabbit@test-young-mouse-01.log" -rabbit lager_upgrade_file "/var/log/rabbitmq/rabbit@test-young-mouse-01_upgrade.log" -rabbit enabled_plugins_file "/etc/rabbitmq/enabled_plugins" -rabbit plugins_dir "/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.7.14/plugins" -rabbit plugins_expand_dir "/var/lib/rabbitmq/mnesia/rabbit@test-young-mouse-01-plugins-expand" -os_mon start_cpu_sup false -os_mon start_disksup false -os_mon start_memsup false -mnesia dir "/var/lib/rabbitmq/mnesia/rabbit@test-young-mouse-01" -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672<br/>rabbitmq 27698  0.0  0.1   8532  1528 ?        S    13:28   0:00 /usr/lib/erlang/erts-10.2.2/bin/epmd -daemon<br/>rabbitmq 27854  0.0  0.1   4520  1576 ?        Ss   13:28   0:00 erl_child_setup 1000000<br/>rabbitmq 27882  0.0  0.1   8264  1076 ?        Ss   13:28   0:00 inet_gethost 4<br/>rabbitmq 27883  0.0  0.1  14616  1808 ?        S    13:28   0:00 inet_gethost 4<br/></pre>
<div>
<p>It is possible that, when RabbitMQ runs, a process named <kbd>epmd</kbd> is also running. This is the Erlang port mapper daemon, which is in charge of coordinating Erlang nodes in a cluster. It is expected to start even if the clustered RabbitMQ application is not running.</p>
</div>
<p>Note that by default, the broker service is configured to auto-start when the Linux host starts.</p>
<div class="packt_tip">
<p>Skip the hassle of the installation and configuration of RabbitMQ and use a hosted RabbitMQ solution. CloudAMQP is the largest provider of hosted RabbitMQ clusters: <a href="https://www.cloudamqp.com/">www.cloudamqp.com</a>.</p>
</div>
<h2 id="uuid-e05720c7-52a1-4732-8e90-0895d4106dc6">Installing the management plugin (Web UI)</h2>
<p>RabbitMQ does not install a management console by default, but the optional web-based plugin used in this example makes it easy <span>to peek into a running RabbitMQ instance</span>.</p>
<p>The Debian package installs several scripts. One of them is <kbd>rabbitmq-plugins</kbd>. Its purpose is to allow us to install and remove plugins. Use it to install the management plugin, as follows:</p>
<pre>$ sudo rabbitmq-plugins enable rabbitmq_management <br/>Enabling plugins on node rabbit@host:<br/>rabbitmq_management<br/>The following plugins have been configured:<br/> rabbitmq_consistent_hash_exchange<br/> rabbitmq_event_exchange<br/> rabbitmq_federation<br/> rabbitmq_management<br/> rabbitmq_management_agent<br/> rabbitmq_shovel<br/> rabbitmq_web_dispatch<br/>Applying plugin configuration to rabbit@host...<br/>The following plugins have been enabled:<br/>  rabbitmq_management<br/>  rabbitmq_management_agent<br/>  rabbitmq_web_dispatch<br/></pre>
<p>Yes, it is that easy!</p>
<p>Use a web browser to reach the home page of the management console by navigating to <kbd>http://&lt;hostname&gt;:15672</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-627 image-border" src="assets/280d4407-ed0a-4bf6-9167-f1215438efe7.png" style="width:36.08em;height:18.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 1.13: The login screen of the management console</div>
<p>Stay tuned for the next episode <span>–</span> creating and configuring users!<br/></p>
<h2 id="uuid-89bec3f9-fdaa-41a0-a36c-9d3e4bcecda6">Configuring users</h2>
<p>One of the scripts that's installed by the Debian package is <kbd>rabbitmqctl</kbd>, which is a tool for managing RabbitMQ nodes and used to configure all aspects of the broker. Use it to configure an administration user in the broker, as follows:</p>
<pre><strong>$ sudo rabbitmqctl add_user cc-admin taxi123</strong><br/>Adding user "cc-admin" ...

<strong>$ sudo rabbitmqctl set_user_tags cc-admin administrator</strong><br/>Setting tags for user "cc-admin" to [administrator] ...</pre>
<p>By default, RabbitMQ comes with a guest user that's authenticated with the guest password. Change this password to something else, as follows:</p>
<pre>$ sudo rabbitmqctl change_password guest guest123</pre>
<p>Navigating back to the management console login screen allows us to log in with the username <kbd>cc-admin</kbd> and the password <kbd>taxi123</kbd>.</p>
<p>The welcome screen provides an overview of the broker's internals, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-628 image-border" src="assets/ee346036-1498-4c86-83e8-dbb9b3627f28.png" style="width:60.08em;height:46.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 1.14: The main dashboard of the management console</div>
<p>Note that at this point, the <kbd>cc-admin</kbd> user is not able to examine any exchange or queue in any vhost. For now, another user must be created for development purposes so that applications can connect to RabbitMQ.</p>
<p>Create the <kbd>cc-dev</kbd> user, as follows:</p>
<pre><strong>$ sudo rabbitmqctl add_user cc-dev taxi123</strong><br/>Adding user "cc-dev" ...</pre>
<p>As discussed earlier in this chapter, RabbitMQ supports the notion of vhosts, which is where different users can have different access privileges. The CC development environment will have a vhost, also known as vhost. Anything that happens in the vhost happens in isolation from any other environment created in the future (such as a QA environment). It is possible to set per-vhost limits on a number of queues and concurrent client connections in later versions of RabbitMQ (3.7+).</p>
<p>Create a vhost called <kbd>cc-dev-vhost</kbd>, as follows:</p>
<pre><strong>$ sudo rabbitmqctl add_vhost cc-dev-vhost</strong><br/>Adding vhost "cc-dev-vhost" ...</pre>
<p><span>This creates a user and a vhost for development.</span></p>
<h3 id="uuid-7cf9f8e0-7bfd-4573-a569-e5b4dd577252">Configuring dedicated vhosts</h3>
<p>RabbitMQ comes with a default vhost called <kbd>/</kbd> that the guest user has full permissions for. Though this is convenient for quick tests, it is recommended that a dedicated vhost is created to keep concerns separated so that it is possible to completely drop a vhost and restart from scratch without unexpected impacts.</p>
<p>As it stands, neither the <kbd>cc-admin</kbd> nor <kbd>cc-dev</kbd> users have permission to do anything on <kbd>cc-dev-vhost</kbd>. You can fix this by giving the vhost full rights, as follows:</p>
<pre><strong>$ sudo rabbitmqctl set_permissions -p cc-dev-vhost cc-admin ".*" ".*" ".*"</strong><br/>Setting permissions for user "cc-admin" in vhost "cc-dev-vhost" ... <strong>$ sudo rabbitmqctl set_permissions -p cc-dev-vhost cc-dev ".*" ".*" ".*"</strong><br/>Setting permissions for user "cc-dev" in vhost "cc-dev-vhost" ...</pre>
<p>To recap what was just done, most of the command is straightforward but the <kbd>".*" ".*" ".*"</kbd> part looks a tad mysterious, so let's analyze it.</p>
<p>It is a triplet of permissions for the considered vhost, which grants <strong>configure</strong>, <strong>write</strong>, and <strong>read</strong> permissions on the designated resources for the considered user and vhost. Resources, which consist of exchanges and queues, are designated by regular expressions that match their names. In this case, any resource that's requested via the <kbd>.*</kbd> regular expression is allowed.</p>
<p>The actual commands that are granted depend on the resource type and the granted permissions. For a complete list of the access control policies supported by RabbitMQ, see <a href="http://www.rabbitmq.com/access-control.html">http://www.rabbitmq.com/access-control.html</a>.</p>
<p class="CDPAlignLeft CDPAlign">As an alternative to all command lines, turn to the user management features of the management console. Click on the <span class="packt_screen">Admin</span> tab of the console and then on the <kbd>cc-dev</kbd> user listed in the <span class="packt_screen">Users</span> tab to view information similar to what's shown in the following screenshot. The entire user configuration that was set from the command line is visible and can be edited in the management console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-629 image-border" src="assets/d898f837-ce12-420c-9644-f4af2a4d27e7.png" style="width:65.75em;height:30.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 1.15: User management from the RabbitMQ management console</div>
<p>The details of an individual user can be found by clicking on a given user's name in the management console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-630 image-border" src="assets/75629c10-48d3-4fc3-b069-7cabe27614fa.png" style="width:40.50em;height:29.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fig 1.16: Details of an individual user in the management console</div>
<p><span>The RabbitMQ broker and the management plugin (Web UI) have been installed and the vhost and the users have been configured.</span></p>
<h1 id="uuid-28372cbc-2c5c-4ce9-9902-ac26746b74cf">Summary</h1>
<p>This chapter explored the architectural and design promises of messaging, including how AMQP and RabbitMQ deliver on these promises. In addition, the reason why the taxi agency Complete Car decided to introduce RabbitMQ in its software landscape was discovered. Finally, a RabbitMQ broker was installed and a user and various vhosts were configured for it. Armed with a basic understanding of message queues and RabbitMQ, the next chapter builds on these concepts and explores the architecture behind the Complete Car taxi application.</p>
<p>It's time to hit the ground running and write some code. Turn to the next chapter to start building a RabbitMQ-powered application!</p>


            </article>

            
        </section>
    </body></html>