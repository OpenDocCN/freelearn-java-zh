- en: Chapter 9. JSF State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commonly, the JSF applications' performance is directly related to CPU memory,
    serialization/deserialization tasks, and network bandwidth. When these variables
    start to become the source of headache, or errors of type `ViewExpiredException`
    or `NotSerializableException` occur, it is time to find out about JSF's managing
    view state feature and how it can be finely tuned to increase the performance.
    Therefore, in this chapter, we will discuss about JSF saving the view state (JSF's
    partial saving view state feature, JSF saving the view state on server/client,
    logical and physical views, and so on) and JSF 2.2 stateless views.
  prefs: []
  type: TYPE_NORMAL
- en: JSF saving the view state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you have to know that JSF saves and restores the view state between requests
    using the `ViewHandler`/`StateManager` API. JSF does this during its lifecycle,
    the view state is saved in the session (or on the client machine) at the end of
    a request and is restored at the beginning of a request.
  prefs: []
  type: TYPE_NORMAL
- en: JSF uses this technique because it needs to preserve the views state over the
    HTTP protocol, which is a stateless protocol. Since JSF is stateful, it needs
    to save the state of views in order to perform the JSF lifecycle over multiple
    requests from the same user. Each page has a view state that acts as a ping-pong
    ball between the client and the server. A view is basically a component tree that
    may be dynamically changed (altered) during HTTP GET and POST requests. Each request
    will successfully go through the JSF lifecycle only if the component tree was
    previously saved and is fully capable to provide the needed information, that
    is, Faces Servlet succeeds to call the needed view handler implementations to
    restore or build the view. So, when the component tree is programmatically changed
    (for example, from backing beans or static components) it can't be successfully
    recreated from scratch (or rebuilt). The only solution is to use the existing
    state saved at the *Render Response* phase. Trying to recreate it from scratch
    will make the programmatic changes useless, since they would no longer be available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the component tree is just a hand of UI components hierarchically
    and logically related. The view state maintains the tree structure and the components
    state (selected/deselected, enabled/disabled, and so on). Therefore, the component
    tree contains only references to backing beans properties/actions through EL expressions,
    and does not store the model values.
  prefs: []
  type: TYPE_NORMAL
- en: JSF partial saving view state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.0, the performance of managing the state was seriously
    increased by adding the partial state saving feature. Basically, JSF will not
    save the entire component tree, only a piece of it. Obviously this will require
    less memory. In other words, this means that instead of saving the entire component
    tree (the whole view, `<html>`), now, for every request during restore view, JSF
    will recreate the entire component tree from scratch and initialize the components
    from their tag attributes. In this way, JSF will save only the things that are
    deserved to be saved. These are the things that are susceptible to changes (for
    example, `<h:form>`) that cannot be recreated from scratch and/or represent inland
    details of components. These details are: dynamic (programmatic) changes that
    alter the component tree, different kinds of values that were determined for some
    components (usually at first postback), and values that were changed for components
    but have not been submitted (for example, moving a slider or checking a checkbox).
    On the other hand, the things that cannot be changed by the client will not be
    saved.'
  prefs: []
  type: TYPE_NORMAL
- en: Partial state saving and tree visiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JSF 2.0, the JSF partial state saving feature raised a question similar
    to how a JSF implementation should visit all the components in the component tree
    and ask them for their state (partial)? The answer in JSF 2.1 (and earlier versions)
    was specific to this implementation: Mojarra used a tree visiting algorithm, while
    MyFaces used a so-called "facets + children" traversal. But, technically speaking,
    these two approaches are pretty different, because Mojarra provides a pluggable
    algorithm, while MyFaces doesn''t. Moreover, the Mojarra approach is in context
    (before children are visited, the parent component can choose to use a context/scope),
    while the MyFaces approach follows a pointer design. Furthermore, the Mojarra
    algorithm can visit virtual components. (These kinds of components are obtained
    by looping components such as `UIData`.) On the other hand, from the saving state
    perspective, using a context/scope and looping virtual components is not desirable,
    even if affecting the visiting process can be major and useful.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this problem, JSF 2.1 offers some hints, which can be considered
    deprecated starting with JSF 2.2\. Starting with JSF 2.2, tree visiting is fully
    capable of partial state saving; thanks to the `StateManagementStrategy.saveView`
    and `StateManagementStrategy.restoreView` methods. These two methods are meant
    to replace their counterparts from the `StateManager` class, and their implementations
    are now mandatory to use the visit API. (A good point to start studying may be
    the `UIComponent.visitTree` method.) As a JSF developer, you will probably never
    interact with this feature, but for the sake of completeness, it may be good to
    be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: JSF saving view state on the server or client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Saving the view state can be accomplished on the server that hosts the application,
    or on the client machine. We can easily choose between the client and the server
    by adding the context parameter named `javax.faces.STATE_SAVING_METHOD` to the
    `web.xml` file. The value of this method can be `server` or `client` as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Starting with JSF 2.2, the values of this context parameter are case insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving the state on the server means to save it in a session with a special
    ID known as the view state ID that refers to the state stored in the server memory.
    This is sent to the client as the value of a hidden input field named, `javax.faces.ViewState`.
    This can be easily tested by running the `ch9_1_1` application, which produces
    the HTML code that contains this field, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF saving view state on the server or client](img/6466EN_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the state is saved on the client, JSF stores it as the value of the same
    hidden input field. This value is a base64 encrypted string representing the serialization
    of the state. Running the `ch9_1_2` application will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF saving view state on the server or client](img/6466EN_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Specifying where the view state will be saved is a piece of cake, but choosing
    between saving the view state on a client or on a server can be a difficult choice,
    because each has its own advantages and disadvantages. Both have a cost, and everybody
    wants to pay a lower price. Choosing the client will increase network traffic
    because the serialized state will generate a larger value for the `javax.faces.ViewState`
    input field. Moreover, encoding/decoding the view state and possible trespasser
    attacks are also important drawbacks of this approach. On the other hand, the
    server uses less memory because nothing is stored in the session. Moreover, storing
    the view state on the client will also be a good solution to prevent losing it
    when the server is down, and to prevent `ViewExpiredException` that occurs when
    the session has expired, or when the maximum number of opened views was reached.
    Saving the state on the server has an opposite effect: the network traffic is
    lower, the usage of memory by the server increases, and the server failures will
    result in loss of the state and possible `ViewExpiredException` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, developers prefer to have a lower network traffic and use more memory
    on the server, because memory is easy to provide to an application server. But
    this is not a rule; you just have to think what's cheaper for you. Some heavy
    benchmarks can also provide compelling indications about storing the state on
    the client or on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the right choice, do not forget that JSF 2.0 comes, by default,
    with partial state saving, which will be reflected in a smaller size of the `javax.faces.ViewState`
    input field (the state saved on the client) or in less memory needed (the state
    saved on the server). You can disable partial state saving by adding the following
    `context` parameter in `web.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For a simple visual test, you can choose to save the state on the client and
    run the same application twice (you can use the application named, `ch9_1_2`):
    first time, enable partial state saving, and second time, disable it—the result
    shown in the following screenshot speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF saving view state on the server or client](img/6466EN_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, in the same application, you can use partial state saving for
    some views and full state saving for other views. Skip the `javax.faces.PARTIAL_STATE_SAVING`
    context parameter and use the `javax.faces.FULL_STATE_SAVING_VIEW_IDS` context
    parameter. The value of this context parameter contains a list of view IDs for
    which the partial state saving will be disabled. The IDs should be comma separated,
    as shown in the following code (suppose you have three pages: `index.xhtml`, `done.xhtml`,
    and `error.xhtml`, partial state saving is used only for `index.xhtml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically, you can check if the state is saved on the client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In view/page the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In backing bean, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: JSF logical and physical views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, so good! We know that JSF can store a full or partial view state on
    server or on client with some advantages and disadvantages. Further, you have
    to know that JSF differentiates views in logical views (specific to the GET requests)
    and physical views (specific to the POST requests). Each GET request generates
    a new logical view. By default, JSF Mojarra (the reference implementation of JSF)
    manages 15 logical views, but this number can be adjusted through the context
    parameter, `com.sun.faces.numberOfLogicalViews`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily perform a test of this setting by starting the browser and opening
    the `ch9_2` application three times, in three different browser tabs. Afterwards,
    come back to the first tab and try to submit the form. You will see a `ViewExpiredException`
    because the first logical view was removed from the logical views map, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF logical and physical views](img/6466EN_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you open the application in one or two tabs, this error will not occur.
  prefs: []
  type: TYPE_NORMAL
- en: There is another story with the POST requests (non-AJAX), because, in this case,
    JSF (Mojarra implementation) will store every single form in the session until
    the maximum size is reached. A `POST` request creates a new physical view (except
    AJAX requests which use the same physical view repeatedly) and JSF Mojarra can
    store 15 physical views per logical view (`Map<LogicalView`, `Map<PhysicalView`,
    and `ViewState>>`). Obviously, a physical view can contain multiple forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can control the number of physical views through the context parameter
    named `com.sun.faces.numberOfViewsInSession`. For example, you can decrease its
    value to `4` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This small value allows you to perform a quick test. Open the application named
    `ch9_3` in the browser and submit that form four times. Afterwards, press the
    browser's back button four times, to return to the first form and try to submit
    it again. You will see an exception, because this physical view was removed from
    the physical view's map. This will not happen if you submit the form less than
    four times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you need more than 15 logical/physical views, then you can increase
    their number or choose to save the state on the client. Saving the state on the
    client is recommended since it will totally eliminate this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In case of navigation between pages, JSF doesn't store anything in the session
    for the GET requests, but will save the state of forms for the POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the state in a database – an experimental application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combining the client saving state and complex views can really stress up the
    network bandwidth. The root of this drawback is represented by the size of the
    serialized state that should be passed between the client and the server at each
    request-response cycle. Usually, this string increases the server's response size
    significantly. An interesting idea is to save the view state in a database and
    send to the client only an identifier to the corresponding record. In this section,
    you will see how to accomplish this task using a MongoDB database and a custom
    implementation of saving the client view state. The implementation is tight coupled
    to JSF Mojarra (there are `com.sun.faces.*` specific dependencies requiring Mojarra).
    So, since it is not utilizing the standard API methods, this approach won't work
    in MyFaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not familiar with MongoDB (or NoSQL database systems), you can use
    SQL RDBMSs (for example, MySQL) and plain JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: In order to pass the client view state into a database, you have to be aware
    of how JSF deals with it by default, and perform the corresponding adjustments.
    The magic of saving the state begins in the `ViewHandler`/`StateManager` pair
    of classes, which guides the tasks of saving/restoring the views between requests.
    Both of them use a helper class, named `ResponseStateManager`, which knows how
    to determine where the state should be saved (based on the default settings or
    on `web.xml` explicit settings) and delegates the saving/restoring task to one
    of the two helper classes, named `ClientSideStateHelper` and `ServerSideStateHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting more in details, when the view state should be saved, the `StateManager.writeState`
    method is called from the `ViewHandler.renderView` method. In the `StateManager.writeState`
    method, JSF will obtain an instance of `ResponseStateManager`. This object can
    inspect each rendering-technology-specific request, because it knows the rendering
    technology used. The instance of `ResponseStateManager` comes from the `RenderKit`
    class (by calling the `RenderKit` method, named `getResponseStateManager`) and
    delegates the writing task to the `ResponseStateManager.writeState` method. In
    the `ResponseStateManager` constructor, JSF will determine where the view state
    should be saved (on the client or the server), and indicates that the writing
    task should happen in one of the two helper classes, which are responsible for
    effectively writing the view state.
  prefs: []
  type: TYPE_NORMAL
- en: On the way back, during restore view, the `ViewHandler` uses the `ResponseStateManager`
    class to test if the request is an initial request or a postback request. In case
    of a postback request, JSF will call the `ViewHandler.restoreView` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are interested in saving view state on the client, we will focus on
    the `ClientSideStateHelper` class, which defines the following important methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`writeState`: This method generates the hidden input field and populates its
    value with the encrypted version of the serialization view state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getState`: This method inspects the incoming request parameters for the standardized
    state parameter name and decrypts the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we need to write our helper class, named `CustomClientSideStateHelper`.
    The `writeState` method is a convenient point to start. The idea is to modify
    the default method for sending the encrypted state into a MongoDB database, instead
    of sending it to the client. The client will receive the primary key used for
    storing the state in the database. The modifications are highlighted in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, a subsequent client request will pass the primary key to the default
    `getState` method. Therefore, you need to write a custom `getState` method that
    will extract the corresponding state from the database by its ID (primary key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing the custom ResponseStateManager class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we can save/restore the client view state using a MongoDB database.
    Looking forward, we need to tell JSF to use our `CustomClientSideStateHelper`
    class instead of the default `ClientSideStateHelper` class. This task can be easily
    accomplished if we write a custom implementation of the `ResponseStateManager`
    class. This will be almost the same as the Mojarra implementation, but with a
    small adjustment in the constructor (notice how we slipped the `CustomClientSideStateHelper`
    class here) as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same reasoning, we need to tell JSF to use our custom `ResponseStateManager`
    class. Remember that JSF obtains an instance of this class through the default
    `RenderKit` class; therefore, we can easily write our custom `RenderKit` class
    and override the `getResponseStateManager` method, which is responsible for creating
    an instance of the `ResponseStateManager` class. In order to write a custom `RenderKit`
    class, we will extend the wrapper class, `RenderKitWrapper`, which represents
    a simple implementation of the `RenderKit` abstract class and spares us the implementation
    of all the methods as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom `RenderKit` class must be appropriately configured in the `faces-config.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, the default `StateManager` class will require a `ResponseStateManager`
    instance from our `RenderKit` class, which will provide an instance of the `CustomResponseStateManager`
    class. Further, the `CustomResponseStateManager` class will use `CustomClientSideStateHelper`
    for saving/restoring the client state.
  prefs: []
  type: TYPE_NORMAL
- en: Adding MongoDB in equation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The missing part of the preceding section is the `WriteStateInDB` class. This
    is a class capable of writing/reading data from a MongoDB (Version 2.2.2 or later)
    database using the MongoDB Java Driver (Version 2.8.0 or later), and is listed
    in the following code (for those who are familiar with the MongoDB Java Driver,
    this is a very simple code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, this class exploits a great facility of MongoDB, named TTL ([http://docs.mongodb.org/manual/tutorial/expire-data/](http://docs.mongodb.org/manual/tutorial/expire-data/)),
    which is capable of automatically removing the data after a specified number of
    seconds or at a specific clock time. This is useful for cleaning up the database
    for the expired sessions (orphans). In this demo, each state will be deleted after
    60 seconds from the insertion of data into the database, but setting the time
    to 30 minutes can be more realistic. Of course, even so, you are under the risk
    of deleting the states that are currently active; therefore, supplementary checks
    or an alternative solution is needed. Unfortunately, we can''t provide more details
    regarding MongoDB, since this is beyond the scope of this book. Therefore you
    have to go for a research ([http://www.mongodb.org/](http://www.mongodb.org/)).
    In the following screenshots, you can see a simple test that reveals the page
    size difference between the default client view state saving (1.3 KB) and the
    customized client view state. The default approach is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding MongoDB in equation](img/6466EN_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The custom approach is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding MongoDB in equation](img/6466EN_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, this approach brings into discussion the main drawback represented
    by the need of hitting the database for each save/restore state (caching can solve
    this).
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch9_9`. In order for it to work, you need
    to install MongoDB 2.2.2 (or later). The application comes with the MongoDB Java
    Driver Version 2.8.0, but you can provide a more recent one.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note to this section, keep in mind that a custom `StateManager`
    class can be written by extending the wrapper class, `StateManagerWrapper`, as
    shown in the following code (starting with JSF 2.0, we can use this wrapper class
    to easily decorate the `StateManager` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom state manager should be configured in the `faces-config.xml` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Handling ViewExpiredException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user session expires (for any reason) `ViewExpiredException` occurs.
    The scenario behind this exception is based on the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The user view state is saved on the server (the `javax.faces.STATE_SAVING_METHOD`
    context parameter's value is server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user receives the view state ID as the value of the hidden input field,
    `javax.faces.ViewState`. This points out the view state saved on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user session expires (for example, timeout session) and the view state is
    removed from the server session, but the user still has the view state ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user sends a POST request, but the view state ID indicates an unavailable
    view state; therefore, `ViewExpiredException` occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to deal with this exception, you have two choices: to avoid it or
    to treat it. Suppose that you are in view **A** and you click on the **Logout**
    button that invalidates the session and redirects control to view **B** (when
    the session is invalidated the state is automatically removed from the session).
    Since this is a POST non-AJAX request, the user can press the browser back button,
    which will load the view **A** again. Now, he can click on the **Logout** button
    again, but this time, instead of view **B**, he/she will see `ViewExpiredException`,
    because, most probably, view **A** is not requested to the server again, and is
    loaded from the browser cache. Since it is loaded from the cache, the `javax.faces.ViewState`
    view state ID is the same as it was at first logout; therefore, the associated
    state is not available anymore. The flow is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling ViewExpiredException](img/6466EN_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Obviously, this is not the desired behavior. You have to tell the browser to
    make a new request to the server instead of loading the view **A** from the cache.
    This can be accomplished by a filter that sets the right headers in order to disable
    browser caching. The filter will be applied to the `Faces Servlet` class as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, repeat the scenario and note that instead of `ViewExpiredException`, view
    **A** receives a new view state ID in `javax.faces.ViewState`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see two examples in the code bundle of this chapter. One is named `ch9_4_1`,
    and the other one is named `ch9_4_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding solution may be a little bit confusing to the user, since it
    doesn''t provide any explicit information about what is happening. Moreover, a
    session may expire for many other reasons; therefore it would be a better idea
    to display an error page to the user instead of using a filter to prevent browser
    cache. The error page can be the login page or just an intermediary page containing
    a link to the login page. This can be accomplished by adding in the `web.xml`
    file as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple `expired.xhtml` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch9_5` and is available in the code bundle of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is at least one more approach that comes from JSF 1.2 that works in JSF
    2.2 also. You can try to set the following `context` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this can be interpreted as: when the current view expires, generate a
    brand new one and do not throw `ViewExpiredException`.'
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is named `ch9_6` and is available in the code bundle of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: More details about this exception (including how you can deal with it in AJAX
    environments) are available in the *Configuring the view handler* and *Configuring
    the global exception handler* sections in [Chapter 5](ch05.html "Chapter 5. JSF
    Configurations Using XML Files and Annotations – Part 2"), *JSF Configurations
    Using XML Files and Annotations – Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Server-state serialization in a session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the server side, the state can be stored as a shallow copy or as a deep copy.
    In a shallow copy, the state is not serialized in the session (JSF stores only
    pointers to the state in a session and only the container deals with serialization
    stuff), which requires less memory and allows you to inject EJBs in the view scoped
    beans (use this technique carefully, since the changes that affect objects in
    one copy will be reflected in the rest of the copies). The deep copy represents
    a full serialization of the state in a session, which requires more memory and
    doesn't allow injecting EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, JSF Mojarra uses shallow copy, while JSF MyFaces uses deep copy.
    Anyway, perform a quick test to be sure which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily alter the default behavior by explicitly setting the `javax.faces.SERIALIZE_SERVER_STATE`
    context parameter in `web.xml`. This context parameter was introduced starting
    with JSF 2.2 and represents the standard context parameter for setting the server
    state serialization in Mojarra and MyFaces. You can indicate that the shallow
    copy should be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to avoid exceptions of type, `java.io.NotSerializableException` (and
    warnings of type `Setting non-serializable attribute value ...`), keep in mind
    that serializing the state in a session implies serializable backing beans. (They
    import `java.io.Serializable` and their properties are serializable. Special attention
    to nested beans, EJBs, streams, JPA entities, connections, and so on.) This is
    also true when you are storing the view state in the client since the entire state
    should be serializable. When a bean property should not (or cannot) be serialized,
    just declare it `transient` and do not forget that it will be `null` at deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the preceding note, a common case implies `java.io.NotSerializableException`,
    when the state is saved on the client. But when switching the state on the server,
    this exception miraculously disappears on Mojarra, while it is still present in
    MyFaces. This can be confusing, but is perfectly normal if you are using Mojarra
    implementation, the state should be fully serializable while saving it on the
    client (and it is not, since this exception occurred), while this is not true
    on the server, where Mojarra by default doesn't serialize the state in a session.
    On the other hand, MyFaces defaults to serialize the state; therefore, the exception
    persists.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you may optimize memory usage and save server resources by redesigning
    the application state, which contains view or session or application backing beans
    (don't cache the data that can be queried from a database and try to reduce the
    number of such beans). Besides managing the view state, this is also an important
    aspect that reflects directly in performance. When more memory is needed, the
    container may choose to serialize the parts of the application state, which means
    that you have to pay the price of deserialization also. While the price of saving
    in the session is represented by memory, the price of serialization/deserialization
    is represented by the time and insignificant disk space (at least it should be
    insignificant).
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 is stateless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notion of being stateless is pretty confusing, because every application
    must maintain some kind of state (for example, for runtime variables). Generically
    speaking, a stateless application will follow the rule of a state per request,
    which means that a state's lifecycle is the same as the request-response lifecycle.
    This is an important issue in web applications, where we need to use session/application
    scope that, obviously, breaks down the notion of stateless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even so, one of the most popular features of JSF 2.2 consists of stateless
    views (and is actually available starting with Version 2.1.19). The idea behind
    this concept assumes that JSF will not save/restore the view state between requests
    and will prefer to recreate the view state from the XHTML tags on every request.
    The goal is to seriously increase performances: the gain time used for the save/restore
    view state, more efficient usage of server memory, more support for clustered
    environments, and the prevention of `ViewExpiredException`s. So, JSF developers
    have certain requirements of the stateless feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, it seems that the stateless feature doesn't affect too much of
    the time used for saving/restoring the view state (this is not expensive, especially
    when the state is saved on a server session and is not going to be serialized)
    and memory performances. On the other hand, when an application is deployed on
    several computers (in clustered environments), the stateless feature can be a
    real help because we don't need session replication (refers to replicating the
    data stored in a session across different instances) and/or sticky sessions (refers
    to the mechanism used by the load balancer to improve efficiency of persistent
    sessions in a clustered configuration) anymore. For stateless applications, the
    nodes do not need to share states, and client postback requests can be resolved
    by different nodes. This is a big achievement, because in order to resolve many
    requests, we can add new nodes without worrying about sharing the state. In addition,
    preventing `ViewExpiredException` is also a big advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stateless views can be used to postpone session creation or dealing with big
    (complex) component trees that implies an uncomfortable state.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, the developers can choose between saving the view state
    and creating stateless views in the same application, which means that the application
    can use dynamic forms in some views (stateful) and create/recreate them for every
    request in other views (stateless). For a stateless view, the component tree cannot
    be dynamically generated/changed (for example, JSTL and bindings are not available
    in the stateless mode) and resubmitting forms will probably not work as expected.
    Moreover, some of the JSF components are stateful, which will lead to serious
    issues in a stateless view. But, it is not so easy to nominate those components
    and the issues, since their behavior is dependent on the environment (context).
    Some specific tests may be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: In order to write a JSF stateless application, you have to design everything
    to work only with the request scoped bean. In some cases, we can use different
    tricks to accomplish this task, like using hidden fields and special request parameters
    for emulating a session. While session and application beans will break down the
    idea of stateless (even if it is possible to use), the view bean will act as request
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically speaking, defining a view as stateless is a piece of cake:
    just add the attribute named, `transient` to the `<f:view>` tag and set its value
    to `true`. Note that in order to have a stateless view, the presence of `<f:view>`
    tag is mandatory, even if it doesn''t have any other use. Each stateless view
    of an application needs this setting because there isn''t a global setting for
    indicating that the stateless effect should be applied at the application level.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When a view is stateless, the `javax.faces.ViewState` value will be `stateless`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF 2.2 is stateless](img/6466EN_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The view scoped beans and the stateless feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a stateless environment, the view scoped beans act as request scoped beans.
    Besides the fact that you can''t create/manipulate views dynamically, this is
    one of the big disadvantages that comes with the stateless feature, because it
    will affect AJAX-based applications that usually use view scoped beans. You can
    easily test this behavior with a set of beans with different scopes (the complete
    application is named `ch9_7`). The view scoped bean can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Just change the scope to request, session, and application to obtain the other
    three beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will write a simple stateless view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, just submit this form several times (click on the **Generate Timestamp**
    button) and notice that the timestamp generated by the view scoped bean changes
    at every request as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The view scoped beans and the stateless feature](img/6466EN_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The request, session, and application scopes work as expected!
  prefs: []
  type: TYPE_NORMAL
- en: Detecting stateless views programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programmatically speaking, you can detect if a view is stateless by using the
    following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In view or page, enter the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In view or page, enter the following code. This works only for the `postback`
    requests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In backing bean, enter the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the `isStateless` method can be used only on the `postback` requests.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch9_8`.
  prefs: []
  type: TYPE_NORMAL
- en: JSF security notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dissertations about JSF saving state also imply some aspects regarding JSF security.
    It appears that saving the JSF state on the client is less secure than saving
    the JSF state on the server. For the most common security concerns (for example,
    XSS, CSRF, SQL injection, and phishing), JSF provides implicit protection.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site request forgery (CSRF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSRF and phishing attacks can be prevented by saving state on the server. JSF
    2.0 comes with implicit protection against CSRF attacks based on the value of
    the `javax.faces.ViewState` hidden field. Starting with JSF 2.2, this protection
    was seriously fortified by creating a powerful and robust value for this field.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting (XSS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XSS attacks are implicitly prevented by JSF through the `escape` attribute,
    which is set to `true` by default (`<h:outputText/>, <h:outputLabel/>`). The following
    are the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples are XSS protected because they are both escaped.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, if you write the following example, then an XSS attack is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In order to allow HTML tags, you have to focus on a specialized tool, which
    will be able to parse the HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the stateless mode, the `escape` attribute should always be set to `true`,
    because an XSS gap can facilitate an easy way for CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL injection is usually an attack that speculates SQL queries that are created
    based on user inputs/selections. JSF itself cannot prevent these kinds of attacks,
    because it is not implicated in generating and executing SQL transactions. On
    the other hand, you can use JSF to filter/validate user inputs or selections,
    which may prevent such attacks. Outside JSF, it is a good technique to prevent
    these attacks consisting of writing parameterized queries instead of embedding
    user inputs in the statements and be extra careful at filtering escape characters
    and type handling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you found this as an interesting dissertation about the JSF state. This
    was a controversial subject for a long time, and starting with JSF 2.2, the stateless
    views pour more gas on the fire of this controversy. Nevertheless, choosing the
    right way of managing states is a serious decision that affects the applications'
    performance; therefore, choose wisely and try to be documented about the existing
    benchmarks and workarounds regarding the JSF state.
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will discuss about custom and composite
    components in JSF.
  prefs: []
  type: TYPE_NORMAL
