<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Developing Distributed Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Developing Distributed Applications</h1></div></div></div><p>In the previous chapters, we have all concentrated on building a stateless cluster. That means we don't need to maintain a session for each user request, and a load balancer can freely choose a worker node to serve the user requests.</p><p>A stateless cluster is more flexible and can scale well, so it's always the first choice when we are building a cluster. In essence, HTTP is a stateless protocol, so it lacks the ability to maintain a session for user requests. To solve this problem, web servers usually pass a session ID to the users' web browsers to maintain a long conversation.</p><p>For example, if we are building an online shopping system, we have to maintain a shopping cart for each user. When a user is checking out his/her cart, the total price of the goods in the shopping cart will be calculated. All this data needs to be stored either on the server side or in the cookies of users' web browsers and the data needs to be held across multiple pages, so the session ID is the key to refer to this data of a user. For JBoss EAP, the session ID is called JSESSIONID.</p><p>In a clustering environment, the situation becomes more complex, because there are multiple servers instead of just one, so their statuses need to be replicated. For example, if a worker node <code class="literal">A</code> is serving one user's request, then the data of the shopping cart may be saved on the worker node <code class="literal">A</code>. If the load balancer now redirects the user request to the worker node <code class="literal">B</code>, then the user will find that his/her shopping cart becomes empty. Even if the JSESSIONID is passed to worker <code class="literal">B</code>, the data related with the JSESSIONID is stored in worker <code class="literal">A</code>. So the data of the user still gets lost.</p><p>There are two ways that are commonly used to solve this problem. The first option is named <span class="strong"><strong>sticky sessions</strong></span>
<a id="id327" class="indexterm"/>. This is a straightforward way to solve the problem. It means the load balancer will stick a user session to a specific worker node. For example, if one user visits our website and the load balancer chooses worker node <code class="literal">A</code> to serve the request, then this worker node will be used forever to serve the following requests from this user until he or she quits the web browser or the session ends.</p><p>This solution is easy to apply, and it fits many situations in practice. However, it only partly solves the problem, because a worker node may fail, and the load balancer would like to failover the user requests to another worker node. In this situation, all the sessions on the crashed worker node will still get lost. </p><p>So here is the second solution to avoid the preceding problem, it is better for the worker nodes to replicate the session data among one another. Thus when one worker crashes, its session can be restored from other workers.</p><p>In this chapter, we will learn how to configure session replications between EAP6 servers, and then we'll see how to configure sticky sessions in httpd.</p><div class="section" title="Web session replication"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Web session replication</h1></div></div></div><p>EAP6 provides <a id="id328" class="indexterm"/>web session replication <a id="id329" class="indexterm"/>out of the box when it's running in the domain mode (or in the standalone mode with the <code class="literal">*-ha</code> profile enabled). The session replication is supported by the Infinispan subsystem, and the session container is defined in <code class="literal">domain.xml </code>(and <code class="literal">standalone-*-ha.xml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;cache-container name="web" aliases="standard-session-cache" default-cache="repl" module="org.jboss.as.clustering.web.infinispan"&gt;
  ...
&lt;/cache-container&gt;</pre></div><p>In this section, we'll use a sample project to demonstrate the usage of web session replication. The project is named as <code class="literal">clusterbench</code>. It has been developed by my colleagues <span class="emphasis"><em>Radoslav Husar</em></span> and <span class="emphasis"><em>Michal Babacek</em></span> at Red Hat.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The project is located at <a class="ulink" href="https://github.com/clusterbench/clusterbench">https://github.com/clusterbench/clusterbench</a>.</p></div></div><p>This project has some excellent demonstration codes for us to use. So we'll directly deploy it into our EAP6 servers for testing.</p><p>In the demo project, there is a submodule called <code class="literal">clusterbench-ee6-web</code>. In this module, we can see how the session is enabled in <code class="literal">web.xml</code>. It uses a single line of configuration to enable web session replication as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432_08_01.jpg" alt="Web session replication"/></div><p>With <code class="literal">distributable</code> enabled in <code class="literal">web.xml</code>, the web sessions will be replicated across the EAP6 servers. This is a JavaEE standard requirement. As JBoss EAP6 conforms to the JavaEE standard, it supports this feature. This web project has also provided us a servlet for testing:</p><div class="informalexample"><pre class="programlisting">@WebServlet(name = "HttpSessionServlet", urlPatterns = {"/session"})
public class HttpSessionServlet extends CommonHttpSessionServlet {
}</pre></div><p>The preceding class <code class="literal">HttpSessionServlet</code> extends the <code class="literal">CommonHttpSessionServlet</code>. The <code class="literal">CommonHttpSessionServlet</code> is defined in <code class="literal">clusterbench-common</code>. Here is an abstract of the <code class="literal">CommonHttpSessionServlet</code>:</p><div class="informalexample"><pre class="programlisting">public class CommonHttpSessionServlet extends HttpServlet {

@Override
protected void doGet(HttpServletRequestreq,
HttpServletResponseresp) 
throws ServletException, IOException {
HttpSession session = req.getSession(true);
if (session.isNew()) {
log.log(Level.INFO, "New session created: {0}",
session.getId());
session.setAttribute(KEY, new SerialBean());
        }

SerialBean bean = (SerialBean) session.getAttribute(KEY);

int serial = bean.getSerial();
bean.setSerial(serial + 1);

        // Now store bean in the session
session.setAttribute(KEY, bean);
System.out.println("***serial: " + serial);
resp.getWriter().print(serial);
    }
}</pre></div><p>The main purpose of this servlet is to put a counter into the web session, and each time a user sends a request, the counter will increase by 1. Please note I've added a line of code in the preceeding class:</p><div class="informalexample"><pre class="programlisting">System.out.println("***serial: " + serial);</pre></div><p>So we can see the output from the server console later. Now we can deploy this project into our cluster, and then we can access the servlet to use the counter. We can see the server output to determine which node is actually serving this request. Then we shutdown the working node and access the cluster again. We should expect another EAP6 server to serve the request. If the sessions are replicated successfully, we should see the counter is not reset, and it goes on increasing. In conclusion, this is an example that demonstrates the session replication among EAP6 servers.</p><p>To do the testing, we could use the cluster we've set in the previous chapters, using either <code class="literal">JK</code> or <code class="literal">mod_cluster</code> as the load balancer, and then deploy the project <code class="literal">clusterbench-ee6.ear</code> into the EAP6 domain.</p><p>After the preceding preparations are done and both the load balancer and EAP6 servers are running, let's access the cluster by <span class="strong"><strong>cURL</strong></span>
<a id="id330" class="indexterm"/> for the first time:</p><div class="informalexample"><pre class="programlisting">$ curl -cmysession.txt http://172.16.123.1/clusterbench/session
0</pre></div><p>We see that the counter value is set to <code class="literal">0</code>. The <code class="literal">-cmysession.txt </code>option tells cURL to store the session cookie in a file named <code class="literal">mysession.txt</code>. We will check this file later. Now we can check the server side. From the EAP6 server console output, you can see the master is serving the user request:</p><div class="informalexample"><pre class="programlisting">[Server:master-server] 20:10:57,810 INFO  [org.jboss.test.clusterbench.common.session.CommonHttpSessionServlet] (ajp-/10.0.1.13:8259-1) New session created: 5LQpRPxdSCupM5eHYd93S2wR
[Server:master-server] 20:10:57,813 INFO  [stdout] (ajp-/10.0.1.13:8259-1) ***serial: 0</pre></div><p>In the preceding console output of the master server, we can see a new session was created for the counter, and the session ID is <code class="literal">5LQpRPxdSCupM5eHYd93S2wR</code>. In addition, we see the counter is initialized to <code class="literal">0</code>, which matches the result from the client side.</p><p>Now let's go back to client side and check <code class="literal">mysession.txt</code>. Here are the contents of the file:</p><div class="informalexample"><pre class="programlisting">$ cat mysession.txt
# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This file was generated by libcurl! Edit at your own risk.
172.16.123.1	FALSE	/clusterbench	FALSE	0	JSESSIONID	5LQpRPxdSCupM5eHYd93S2wR</pre></div><p>We can see that the JSESSIONID is stored in cookies. Now let's use this cookie file to access the cluster again:</p><div class="informalexample"><pre class="programlisting">$ curl -bmysession.txt http://172.16.123.1/clusterbench/session
1</pre></div><p>The <code class="literal">-b</code> option will let cURL read an existing cookie file and send the cookies to the server, which means the previous session is continued. Because the counter increments by 1, it means our session is held by JSESSIONID<a id="id331" class="indexterm"/>. We can check the output of the EAP6 server again:</p><div class="informalexample"><pre class="programlisting">[Server:master-server] 20:26:12,496 INFO  [stdout] (ajp-/10.0.1.13:8259-1) ***serial: 1</pre></div><p>So the counter on the master is not reset, and it keeps increasing in one session. Now let's shutdown the master server:</p><div class="informalexample"><pre class="programlisting">20:31:04,851 INFO  [org.jboss.as.process] (Shutdown thread) JBAS012015: All processes finished; exiting</pre></div><p>Then we access the cluster again:</p><div class="informalexample"><pre class="programlisting">$ curl -bmysession.txt http://172.16.123.1/clusterbench/session
2</pre></div><p>Because the master server is down, this time it's the slave server serving the request:</p><div class="informalexample"><pre class="programlisting">[Server:slave-server] 21:07:46,266 INFO  [stdout] (ajp-/10.0.1.40:8259-2) ***serial: 2</pre></div><p>Though the request was redirected to the slave server, the session is held, and the counter increased from 1 to 2. This verified that the session replication works properly between two servers.</p><div class="section" title="CDI-session-scoped bean replication"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>CDI-session-scoped bean replication</h2></div></div></div><p>The usage of a<a id="id332" class="indexterm"/> CDI-session-scoped bean <a id="id333" class="indexterm"/>is similar to a web session bean. In the demo project, it provides a <code class="literal">CdiServlet</code> for testing:</p><div class="informalexample"><pre class="programlisting">@WebServlet(name = "CdiServlet", urlPatterns = {"/cdi"})
public class CdiServlet extends HttpServlet {

@Inject
privateSessionScopedCdiSerialBean bean;

@Override
protected void doGet(HttpServletRequestreq,
HttpServletResponseresp) 
throws ServletException, IOException {
resp.setContentType("text/plain");

int serial = bean.getSerial();
bean.setSerial(serial + 1);

System.out.println("***bean: " + serial);

resp.getWriter().print(serial);
    }
}</pre></div><p>This servlet is also a counter, and it uses a session scoped CDI bean named <code class="literal">SessionScopedCdiSerialBean</code>. Here is the definition of this bean:</p><div class="informalexample"><pre class="programlisting">@SessionScoped
public class SessionScopedCdiSerialBean extends SerialBean implements Serializable</pre></div><p>The bean is declared as <code class="literal">SessionScoped</code>, so it will be replicated across the cluster. The <code class="literal">SerialBean</code> is a POJO that holds the counter. Now we can test it in our cluster. First we need to access the servlet:</p><div class="informalexample"><pre class="programlisting">$ curl -cmysession.txt http://172.16.123.1/clusterbench/cdi
0</pre></div><p>And then we need to check which EAP server is serving the user request. In my environment, the master server is serving the request:</p><div class="informalexample"><pre class="programlisting">[Server:master-server] 21:28:58,440 INFO  [stdout] (ajp-/10.0.1.13:8259-4) ***bean: 0</pre></div><p>In <code class="literal">mysession.txt</code>, we can see the JESSIONID is stored:</p><div class="informalexample"><pre class="programlisting">172.16.123.1	FALSE	/clusterbench	FALSE	0	JSESSIONID	+3EWwwlqUniCic9mtm6c18w2</pre></div><p>Now I disconnect the master server by shutting it down, and access the cluster with the session cookie again:</p><div class="informalexample"><pre class="programlisting">$ curl -bmysession.txt  http://172.16.123.1/clusterbench/cdi
1</pre></div><p>Now we can see that the slave server is serving the request:</p><div class="informalexample"><pre class="programlisting">[Server:slave-server] 21:29:58,032 INFO  [stdout] (ajp-/10.0.1.13:8259-1) ***bean: 1</pre></div><p>As shown in <a id="id334" class="indexterm"/>the preceding code snippet, we can see that the session was replicated from master to slave.</p></div><div class="section" title="Configuring sticky sessions with JK"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Configuring sticky sessions with JK</h2></div></div></div><p>In the previous sections, <a id="id335" class="indexterm"/>we <a id="id336" class="indexterm"/>have looked at how to configure and use session replication in EAP6. In this section, let's move to the load balancer side and see how we can configure a sticky session. With sticky session enabled, the load balancer will use one worker node to serve all the requests from one user. Let's start from the JK configuration. The sticky session is automatically enabled with JK. We can check this in its management console as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432_08_06.jpg" alt="Configuring sticky sessions with JK"/></div><p>From the preceding diagram, we can see the <span class="strong"><strong>Sticky Sessions</strong></span> option is enabled by default. Now we need to consider how a load balancer implements session stickiness: if there are thousands of user requests coming to a cluster, and if sticky session is enabled, then the requests of each user is stuck to a specific worker node. So the load balancer needs some way to record this relationship.</p><p>Storing the <a id="id337" class="indexterm"/>relationship<a id="id338" class="indexterm"/> in the load balancer is not a good idea. The relationships data will increase linearly by the number of users. The situation becomes worse if there are multiple load balancers, and then the stickiness relationship has to be replicated across the load balancers. The load balancer cannot afford to maintain this huge data and its performance will be throttled by querying the stickiness relationship.</p><p>To solve this problem, both <code class="literal">JK</code> and <code class="literal">mod_clusteruse</code> offer a simpler solution: it will put a server ID called <code class="literal">jvmRoute</code> in the JSESSIONID. The <code class="literal">jvmRoute</code> value is UUID, so it can be used to identify each worker node. As the <code class="literal">jvmRoute </code>becomes part of the session ID, the load balancer will directly extract it from the JSESSIONID and knows which server this session is bound to.</p><p>To enable sticky session, we need to edit the configuration of EAP6 to set this server ID. What we should do is open <code class="literal">domain.xml</code> and add an <code class="literal">instance-id</code> element in the web subsystem:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem  ... instance-id="${jboss.server.name}"&gt;
...
&lt;/subsystem&gt;</pre></div><p>The element <code class="literal">instance-id</code> is the value of <code class="literal">jvmRoute</code>. We've used <code class="literal">${jboss.server.name}</code> to be its value. This is a variable provided by EAP6, its value is the server name set in <code class="literal">host.xml</code>. So we know the value of <code class="literal">instance-id</code> for our two EAP6 servers are <code class="literal">master-server</code> and <code class="literal">slave-server</code>.</p><p>To reflect the configuration in EAP6, we need to put these two names into <code class="literal">worker.properties</code> in the httpd side, so that JK will know the name of its workers. Here are the complete contents of <code class="literal">worker.properties</code>:</p><div class="informalexample"><pre class="programlisting">worker.list=lb,jk-status

worker.master-server.type=ajp13
worker.master-server.host=10.0.1.13
worker.master-server.port=8259

worker.slave-server.type=ajp13
worker.slave-server.host=10.0.1.19
worker.slave-server.port=8259

worker.lb.type=lb
worker.lb.balance_workers=master-server,slave-server
worker.lb.sticky_session=1

worker.jk-status.type=status</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>We must ensure that the worker name corresponds to the <code class="literal">instance-id</code> settings in the domain controller, so JK can find the correct servers that the session sticks to.</p></div></div><p>Now we <a id="id339" class="indexterm"/>can test our cluster with the <code class="literal">clusterbench</code> project deployed in the previous sections. We can still use the cURL command to access the cluster:</p><div class="informalexample"><pre class="programlisting">curl -cmysession.txt http://172.16.123.1/clusterbench/session</pre></div><p>From <code class="literal">mysession.txt</code>, the JSESSIONID is:</p><div class="informalexample"><pre class="programlisting">JSESSIONID	8az1BX6Q+TQI+P4wids6BPMV.master-server</pre></div><p>We can see the session is divided into two parts separated by a dot now. The first part is still the session ID and the second part is the <code class="literal">jvmRoute</code> carried in session, and its value is <code class="literal">master-server</code>. In the server output, you can also notice that the session has been created and the session ID displayed on <code class="literal">stdout</code>:</p><div class="informalexample"><pre class="programlisting">[Server:master-server] 22:34:42,700 INFO  [org.jboss.test.clusterbench.common.session.CommonHttpSessionServlet] (ajp-/10.0.1.13:8259-1) New session created: 8az1BX6Q+TQI+P4wids6BPMV.master-server
[Server:master-server] 22:34:42,701 INFO  [stdout] (ajp-/10.0.1.13:8259-1) ***serial: 0</pre></div><p>With the information in <code class="literal">jvmRoute</code>, load balancer will stick the following requests from the user to <code class="literal">mast</code>
<code class="literal">er-server</code>.</p></div><div class="section" title="Configuring sticky sessions with mod_cluster"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>Configuring sticky sessions with mod_cluster</h2></div></div></div><p>To enable <a id="id340" class="indexterm"/>sticky sessions<a id="id341" class="indexterm"/> in <code class="literal">mod_cluster</code>, we need to add some configuration in the <code class="literal">mod_cluster</code> subsystem of EAP6. For the standalone mode, we can configure the <code class="literal">*-ha.xml</code> profiles that contain the <code class="literal">mod_cluster</code> subsystem; for the domain mode, we can edit <code class="literal">domain.xml</code> of the domain controller.</p><p>The sticky session is enabled by default by the <code class="literal">mod_cluster</code> subsystem. Meanwhile, <code class="literal">mod_cluster</code> uses the same scheme like JK to handle session stickiness, so we should also add the <code class="literal">instance-id</code> configuration in the web subsystem:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem  ... instance-id="${jboss.server.name}"&gt;
...
&lt;/subsystem&gt;</pre></div><p>That's all we need to configure. We don't need to do any configuration on the httpd side, because <code class="literal">mod_cluster</code> will <a id="id342" class="indexterm"/>discover the worker node dynamically. Now we can start our cluster and check the management console of <code class="literal">mod_cluster</code>:</p><div class="mediaobject"><img src="graphics/2432_08_11.jpg" alt="Configuring sticky sessions with mod_cluster"/></div><p>From the previous <a id="id343" class="indexterm"/>screenshot, we can see two EAP6 server names become <code class="literal">master-server</code> and <code class="literal">slave-server</code>, which means the setting of <code class="literal">instance-id</code> is enabled. Now we access our cluster:</p><div class="informalexample"><pre class="programlisting">curl -cmysession.txt http://172.16.123.1/clusterbench/session</pre></div><p>And then we check the contents of <code class="literal">mysession.txt</code>:</p><div class="informalexample"><pre class="programlisting">JSESSIONID	AcJIPZwHmlauwxi82s45VWWw.master-server</pre></div><p>We can see the JSESSIONID carries the <code class="literal">jvmRoute</code> information now. So httpd will send the following requests from the user to the master server.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we discussed two solutions that handle the stateful applications in clusters. One is sticky sessions and the other is session replication. These two solutions are usually used together to provide high availability in a Stateful cluster. </p><p>When we are building a cluster, we should always consider building a stateless one at first because a stateless cluster is very easy to scale, and it doesn't have performance bottleneck on session replication.</p></div></body></html>