<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building Asynchronous Web Services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, we'll talk about the motivations and reasons for asynchronous processing. Then, we'll see the basic implementation of asynchronous web services with JAX-RS. Then, we will have a look at improving our implementation using <kbd class="calibre17"><span class="calibre4">ManagedExecutorService</span></kbd> and server-side callbacks. Finally, we will use the asynchronous JAX-RS API client to make REST calls, and explore the benefits and usage scenarios of asynchronous processing.</p>
<p class="calibre6">This chapter includes the following sections:</p>
<ul class="calibre14">
<li class="calibre15">Benefits and usage scenarios of asynchronous processing</li>
<li class="calibre15">Implementing asynchronous web services</li>
<li class="calibre15">Using ManagedExecutorService and server-side callbacks</li>
<li class="calibre15">Implementing asynchronous web service clients</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Benefits and usage scenarios of asynchronous processing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at the motivations and reasons for asynchronous request processing and why this matters to you. One thing I need to tell you is that <em class="calibre18">the free lunch is over! concurrency counts</em>.</p>
<p class="calibre6"/>
<p class="calibre6">Let's take a look at the following diagram:</p>
<p class="cdpaligncenter"><img src="Images/a1e8bd82-c2a7-4114-a74c-22c12256f700.png" class="calibre53"/></p>
<p class="calibre6"><span class="calibre10">We can see that the number of transistors on a processor is constantly rising; however, the clock speed pretty much stayed constant since 2004. </span><span class="calibre10">This means you need to be more concurrent in order to get more speed, and we usually do this by using threads. </span></p>
<p class="calibre6">By default, the request processing on the server usually works in a synchronous mode, which means that each request is processed in a single HTTP thread. This is what we are used to; we had one thread and we performed request responses in it. Unfortunately, threads are very expensive, so under a high load with a lot of concurrent connections, there is a lot of wasted resources and the server does not scale that well. Fortunately, we have asynchronous processing options.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Basic idea</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The basic idea of asynchronous processing is to separate our request I/O threads and the request processing threads by using different thread pools. This basically frees up our I/O threads to receive new connections while we do the processing on different threads.</p>
<p class="calibre6"/>
<p class="calibre6"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Goal</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The ultimate goal is to save memory and improve the performance of our applications by using or reducing context-switching, and we can also improve the throughput by basically separating the request I/O from the request-processing.</p>
<p class="calibre6">These are the main motivations and reasons. In the next section, we will talk about implementing asynchronous web services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing asynchronous web services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at implementing asynchronous REST resources. We'll see the basic usage of the <kbd class="calibre17">@Suspended</kbd> annotation and the <kbd class="calibre17">AsyncResponse</kbd> class. We'll have a look at processing and resuming on an <kbd class="calibre17"><span class="calibre4">AsyncResponse</span></kbd> instance in a different thread, and we will also talk about the basic timeout-handling for asynchronous responses.</p>
<p class="calibre6">Let's get started and switch to code. As usual, we prepare a few templates for us to get started. First up, I want to show you the basic structure of an asynchronous resource—have a look at the signature. All you need to do is implement a <kbd class="calibre17">public void</kbd> method that has at least one parameter that uses the <kbd class="calibre17">@Suspended</kbd> annotation. As a type, it uses the <kbd class="calibre17"><span class="calibre4">AsyncResponse</span></kbd> class that's provided by the JAX-RS API:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    public void calculate(@Suspended final AsyncResponse <br class="calibre2"/>      asyncResponse) {</pre>
<p class="calibre6">Let's start with the implementation.</p>
<p class="calibre6">We want to do some heavy processing in a separate thread. First up, we'll start a new thread and do the calculation within the thread. To simulate some heavy processing, we'll have it sleep for three seconds, then we'll produce some output. To do that, we return the request thread (<kbd class="calibre17">requestThreadName</kbd>). We also need the name of the current thread, and we get that using <kbd class="calibre17">getCurrentThreadName</kbd>:</p>
<pre class="calibre22">        asyncResponse.setTimeout(5, TimeUnit.SECONDS);<br class="calibre2"/><br class="calibre2"/>        final String requestThreadName = getCurrentThreadName();<br class="calibre2"/><br class="calibre2"/>        new Thread(() -&gt; {<br class="calibre2"/>            try {<br class="calibre2"/>                // simulate heavy processing here<br class="calibre2"/>                TimeUnit.SECONDS.sleep(3);<br class="calibre2"/>            } catch (InterruptedException e) {<br class="calibre2"/>                LOGGER.log(Level.WARNING, "Could not wait for 3s.", e);<br class="calibre2"/>            }<br class="calibre2"/>            final String responseThreadName = getCurrentThreadName();</pre>
<p class="calibre6">Finally, we construct a <kbd class="calibre17">response</kbd> from <kbd class="calibre17">requestThread</kbd> and <kbd class="calibre17">responseThread</kbd>:</p>
<pre class="calibre22">            Map&lt;String, String&gt; response = new HashMap&lt;&gt;();<br class="calibre2"/>            response.put("requestThread", requestThreadName);<br class="calibre2"/>            response.put("responseThread", responseThreadName);<br class="calibre2"/><br class="calibre2"/>            asyncResponse.resume(Response.ok(response)<br class="calibre2"/>              .build());<br class="calibre2"/>        }).start();<br class="calibre2"/>    }</pre>
<p class="calibre6">This is the basic structure of an asynchronous REST resource. We spawn a new thread, process it, construct a <kbd class="calibre17">response</kbd>, and finally, we call the <kbd class="calibre17">resume</kbd> method on the <kbd class="calibre17">response</kbd>.</p>
<p class="calibre6">To be slightly more sophisticated, we can use <kbd class="calibre17">BlockingQueue</kbd> and we have a method called <kbd class="calibre17">lock</kbd>, which takes the <kbd class="calibre17">@Suspended</kbd> asynchronous response. We want to save the asynchronous response to the queue:</p>
<pre class="calibre22">    private LinkedBlockingQueue&lt;AsyncResponse&gt; responses = <br class="calibre2"/>      new LinkedBlockingQueue&lt;&gt;();<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void lock(@Suspended final AsyncResponse asyncResponse) <br class="calibre2"/>      throws InterruptedException {<br class="calibre2"/>        String currentThreadName = getCurrentThreadName();<br class="calibre2"/>        LOGGER.log(Level.INFO, "Locking {0} with thread {1}.", <br class="calibre2"/>          new Object[]{asyncResponse, currentThreadName});<br class="calibre2"/><br class="calibre2"/>        responses.put(asyncResponse);</pre>
<p class="calibre6">Down here in the <kbd class="calibre17">AsyncResource</kbd> class, we have an <kbd class="calibre17">unlock</kbd> method where we want to resume the processing on this currently-locked response. We take <kbd class="calibre17">asyncResponse</kbd> from the queue—this pulls the asynchronous response from the queue—and then we call the <kbd class="calibre17">resume</kbd> method on <kbd class="calibre17">response</kbd>. This will basically resume the previously locked request:</p>
<pre class="calibre22">    @DELETE<br class="calibre2"/>    public Response unlock() {<br class="calibre2"/>        String currentThreadName = getCurrentThreadName();<br class="calibre2"/>        AsyncResponse asyncResponse = responses.poll();<br class="calibre2"/><br class="calibre2"/></pre>
<p class="calibre6"/>
<p class="calibre6"/>
<pre class="calibre22">        if (asyncResponse != null) {<br class="calibre2"/>            LOGGER.log(Level.INFO, "Unlocking {0} with thread {1}.", <br class="calibre2"/>              new Object[]{asyncResponse, currentThreadName});<br class="calibre2"/>            asyncResponse.resume(Response.ok(Collections.singletonMap(<br class="calibre2"/>              "currentThread", currentThreadName)).build());<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        return Response.noContent().build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Finally, we want to add some timeout behavior and we can set a specific timeout on <kbd class="calibre17">asyncResponse</kbd>. If the timeout is exceeded, an HTTP 403 status code is returned:</p>
<pre class="calibre22">        asyncResponse.setTimeout(5, TimeUnit.SECONDS);<br class="calibre2"/>        asyncResponse.setTimeoutHandler((response) -&gt; {<br class="calibre2"/>            responses.remove(response);<br class="calibre2"/>            response.resume(Response.status(Response.Status<br class="calibre2"/>              .SERVICE_UNAVAILABLE).build());<br class="calibre2"/>        });</pre>
<p class="calibre6">If you want to test this, switch to your REST client. First, we send a <kbd class="calibre17">GET</kbd> request for the API thread, then we implement it. As we can see here, <kbd class="calibre17">"requestThread"</kbd> is <kbd class="calibre17">http-listener(3)</kbd> and <kbd class="calibre17">"responseThread"</kbd> is a completely different thread:</p>
<p class="cdpaligncenter"><img src="Images/6d39e0ec-460b-4640-868d-4f02f6e1f784.png" width="779" height="260" class="calibre54"/></p>
<p class="calibre6"/>
<p class="calibre6">We do the same thing for the asynchronous <kbd class="calibre17">GET</kbd> request; we issue a <kbd class="calibre17">GET</kbd> request, which will be blocked. We call the unlock (<kbd class="calibre17">DELETE</kbd>) method and get our <span class="calibre10">204 No Content</span>, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/0d8db691-aace-40e1-b0a5-c291b8d49d3e.png" width="872" height="287" class="calibre55"/></p>
<p class="calibre6">If we switch to the already issued <kbd class="calibre17">GET</kbd> request, <span class="calibre10">we get </span><span class="calibre10">503 Service Unavailable</span>, as in this case we waited for too long, <span class="calibre10">as shown in the following screenshot:</span></p>
<p class="cdpaligncenter"><img src="Images/611dc3d2-ee32-4685-bcc5-41f5c09b12ee.png" width="798" height="336" class="calibre56"/></p>
<p class="calibre6"/>
<p class="calibre6">Now, if we call the <kbd class="calibre17">DELETE</kbd> method and the <kbd class="calibre17">GET</kbd> method, we see that the <kbd class="calibre17">"currentThread"</kbd> is <kbd class="calibre17">http-listener(6)</kbd>, <span class="calibre10">as shown in the following screenshot</span>:</p>
<p class="cdpaligncenter"><img src="Images/caa80767-9038-4b6c-9499-b0de0104b69d.png" width="805" height="196" class="calibre57"/></p>
<p class="calibre6">That's it for this section.</p>
<p class="calibre6">In the next section, we'll see how you can use <kbd class="calibre17">ManagedExecutorService</kbd> and server-side callbacks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using ManagedExecutorService and server-side callbacks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at using a <kbd class="calibre17"><span class="calibre4">ManagedExecutorService</span></kbd> instance for asynchronous request processing. I'm going to show you how to use <kbd class="calibre17">CompletableFuture</kbd> to run and resume asynchronous requests. We will talk about using a <kbd class="calibre17">TimeoutHandler</kbd> instance for fine-grained timer control, and we'll be using <kbd class="calibre17">CompletionCallback</kbd> and <kbd class="calibre17">ConnectionCallback</kbd> instances for even further control of the request processing.</p>
<p class="calibre6">Let's get started and switch to code. As usual, we prepare a template project to get started. The first thing we want to do is use a <kbd class="calibre17"><span class="calibre4">ManagedExecutorService</span></kbd> instance. Thus, we will inject this instance into our REST resource:</p>
<pre class="calibre22">@Resource<br class="calibre2"/>private ManagedEcecutorService executorService;</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">Then, we want to use this <kbd class="calibre17"><span class="calibre4">ManagedExecutorService</span></kbd> instance to do some heavy processing, such as processing Fibonacci numbers. We will use the <kbd class="calibre17"><span class="calibre4">ManagedExecutorService</span></kbd> instance and call the <kbd class="calibre17">execute</kbd> method on it. In this <kbd class="calibre17">execute</kbd> method, we then call <kbd class="calibre17">asyncResponse.resume</kbd> to resume the asynchronous response and we provide <kbd class="calibre17">Response</kbd>, which in our case is the requested Fibonacci number:</p>
<pre class="calibre22">        executorService.execute(() -&gt; {<br class="calibre2"/>            asyncResponse.resume(Response.ok(fibonacci(i)).build());<br class="calibre2"/>            LOGGER.log(Level.INFO, "Calculated Fibonacci for {0}.", <br class="calibre2"/>              asyncResponse);<br class="calibre2"/>        });</pre>
<p class="calibre6">What else can we do? We should provide and specify the timeout to use, as we saw in <a href="b73054eb-e78a-4e76-8a06-8d24aff44801.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 3</a>, <em class="calibre18">Content Marshalling with JSON-B and JSON-P</em>. For this case, we specify a timeout of 10 seconds. We also want to specify a specific timeout behavior, since maybe we do not want to answer with an HTTP status code of 503 in this case. Since we want to specify something different, we can use a <kbd class="calibre17">setTimeoutHandler</kbd> instance. We will register <kbd class="calibre17">setTimeoutHandler</kbd> on the asynchronous response, and in case the timeout fires, we resume the response with HTTP status code 202, which is accepted and we just send back a random <kbd class="calibre17">UUID</kbd>:</p>
<pre class="calibre22">        asyncResponse.setTimeout(10, TimeUnit.SECONDS);<br class="calibre2"/>        asyncResponse.setTimeoutHandler((r) -&gt; {<br class="calibre2"/>            r.resume(Response.accepted(UUID.randomUUID()<br class="calibre2"/>              .toString()).build()); //sending HTTP 202 (Accepted)<br class="calibre2"/>        });</pre>
<p class="calibre6">We can also register additional callbacks. There are two types of callbacks: </p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre17">CompletionCallback</kbd></li>
<li class="calibre15"><kbd class="calibre17">ConnectionCallback</kbd></li>
</ul>
<p class="calibre6">We will look at both of them in detail.</p>
<p class="calibre6"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">CompletionCallback</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6"> <kbd class="calibre17">CompletionCallback</kbd> <span class="calibre10">is the first callback.</span> It is called by the JAX-RS runtime once the request is completed. The only method you need to implement is <kbd class="calibre17">onComplete</kbd>. In case of an error, you will be passed the <kbd class="calibre17">throwable</kbd> error and the <kbd class="calibre17">"Completed processing."</kbd> parameter, and we can do the required logic in here:</p>
<pre class="calibre22">    static class LoggingCompletionCallback implements <br class="calibre2"/>      CompletionCallback {<br class="calibre2"/><br class="calibre2"/>        @Override<br class="calibre2"/>        public void onComplete(Throwable throwable) {<br class="calibre2"/>            LOGGER.log(Level.INFO, "Completed processing.", throwable);<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">ConnectionCallback</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The second type of callback that is optionally supported is <kbd class="calibre17">ConnectionCallback</kbd>. Here, you can specify a custom implementation. Currently, the only method you need to implement is the <kbd class="calibre17">onDisconnect</kbd> method, which is passed the actual <kbd class="calibre17">AsyncResponse</kbd>. This method is called if the client is connected prematurely. According to JSR 339, the support for <kbd class="calibre17"><span class="calibre4">C</span><span class="calibre4">onnectionCallback</span></kbd> is optional:</p>
<pre class="calibre22">    static class LoggingConnectionCallback implements <br class="calibre2"/>      ConnectionCallback {<br class="calibre2"/><br class="calibre2"/>        @Override<br class="calibre2"/>        public void onDisconnect(AsyncResponse disconnected) {<br class="calibre2"/>            LOGGER.log(Level.INFO, "Client disconnected on {0}.", <br class="calibre2"/>              disconnected);<br class="calibre2"/>        }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Registering callbacks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Once we've implemented the two callbacks, you can register them with the asynchronous response. You can call <kbd class="calibre17">asyncResponse.register</kbd> and pass it the class of those callbacks:</p>
<pre class="calibre22">        asyncResponse.register(LoggingCompletionCallback.class);<br class="calibre2"/>        asyncResponse.register(LoggingConnectionCallback.class);</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">CompletableFuture</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Finally, we can use <kbd class="calibre17">CompletableFuture</kbd> as an alternative syntactic sugar way of using those asynchronous REST APIs. Again, we use a <kbd class="calibre17"><span class="calibre4">ManagedExecutorService</span></kbd> instance here. The next thing we want to do is use <kbd class="calibre17"><span class="calibre4">C</span><span class="calibre4">ompletableFuture</span></kbd> to run the Fibonacci calculation asynchronously and then apply the <kbd class="calibre17">asyncResponse::resume</kbd> method. The code will look as follows. Using <kbd class="calibre17">CompletableFuture</kbd>, we call the <kbd class="calibre17">runAsync</kbd> method, run our Fibonacci calculation using the supplied <kbd class="calibre17">executorService</kbd>, and then apply the <kbd class="calibre17"><span class="calibre4">asyncResponse::resume</span></kbd> method:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/{i}")<br class="calibre2"/>    public void completable(@Suspended final AsyncResponse <br class="calibre2"/>      asyncResponse, @PathParam("i") final int i) {<br class="calibre2"/>        CompletableFuture<br class="calibre2"/>                .runAsync(() -&gt; fibonacci(i), executorService)<br class="calibre2"/>                .thenApply(asyncResponse::resume);<br class="calibre2"/>    }</pre>
<p class="calibre6">Let's see what this looks like in action. Let's switch to our REST client. First, we call a Fibonacci of 9, which is <span class="calibre10">34</span>, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/a9a9d6d7-90eb-4e51-8557-dc697ea107c1.png" width="511" height="283" class="calibre58"/></p>
<p class="calibre6"/>
<p class="calibre6">The same goes for Fibonacci at 17, which is 1,597, and so on and so forth. The Fibonacci of 42 takes slightly longer as it is a really long number. We can see what happens if we call the Fibonacci of 49; this is a really big number and it should trigger the timeout of 10 seconds—we expect an HTTP status code of <span class="calibre10">202 Accepted</span>, which you can see here, and we get sent back a random UUID response:</p>
<p class="cdpaligncenter"><img src="Images/6adeaf3e-6f9f-4246-a6e1-f3c82095d2a2.png" width="799" height="360" class="calibre59"/></p>
<p class="calibre6">In the next section, we will talk about implementing asynchronous web service clients.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing asynchronous web service clients</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at the basic usage of asynchronous JAX-RS client APIs. We're using <kbd class="calibre17">InvocationCallback</kbd> instances to react to completed and failed calls. We'll also see how to do invocation-chaining of asynchronous client requests with <kbd class="calibre17">CompletableFuture</kbd>.</p>
<p class="calibre6">Let's get started and switch to code. As usual, we prepared a small template project to get started. We'll be using a JUnit test to showcase the JAX-RS client APIs. We're going to set up the JAX-RS <kbd class="calibre17">client</kbd> instance and the JAX-RS <kbd class="calibre17">webTarget</kbd> instance for the previously implemented asynchronous service API. As you might remember, in the previous section, we used Fibonacci number calculations asynchronously. We'll rewrite the test using the asynchronous JAX-RS client APIs against our REST API.</p>
<p class="calibre6">Let's open the <kbd class="calibre17">AsyncWebServiceClientIntegrationTest</kbd> class and start our tests; the first test should be pretty easy. We want to construct an asynchronous request and we do this the way we did it before. We use <kbd class="calibre17">webTarget.path</kbd> and we request <kbd class="calibre17">TEXT_PLAIN_TYPE</kbd>. Now comes the real difference: we call the <kbd class="calibre17">.async()</kbd> method and then call <kbd class="calibre17">.get(Long.class)</kbd>. As you can see, the return type of this call is <kbd class="calibre17">Future&lt;long&gt;</kbd>. Let's rename it from <kbd class="calibre17">longFuture</kbd> to <kbd class="calibre17">fibonacci</kbd> and call the <kbd class="calibre17">assertEquals</kbd> method on that one:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void fibonacci17() throws Exception {<br class="calibre2"/>        Future&lt;Long&gt; fibonacci = webTarget.path("/fibonacci/17")<br class="calibre2"/>          .request(MediaType.TEXT_PLAIN_TYPE).async()<br class="calibre2"/>          .get(Long.class);<br class="calibre2"/>        assertEquals(1597, (long) fibonacci.get());<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="calibre6">This is pretty much all there is to using asynchronous APIs, though there is slightly more. You can register an invocation callback with <kbd class="calibre17">get</kbd> to be notified on completed and failed events. Then, we'll see how we implement those callbacks. As you can see, instead of calling <kbd class="calibre17">get</kbd> for the actual <kbd class="calibre17">(Long.class)</kbd> type, as we did previously, we call the <kbd class="calibre17">get</kbd> of <kbd class="calibre17">InvocationCallback&lt;Long&gt;</kbd>. We can implement the <kbd class="calibre17">completed</kbd> method for a successful execution and the <kbd class="calibre17">failed</kbd> method for a failure. Again, we'll return <kbd class="calibre17">Future&lt;Long&gt;</kbd> for a Fibonacci number and we can then call the <kbd class="calibre17">get</kbd> method on this <kbd class="calibre17">Future</kbd>:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void fibonacci17WithCallback() throws Exception {<br class="calibre2"/>        Future&lt;Long&gt; fibonacci = webTarget.path("/fibonacci/17")<br class="calibre2"/>          .request(MediaType.TEXT_PLAIN_TYPE).async()<br class="calibre2"/>          .get(new InvocationCallback&lt;Long&gt;() {<br class="calibre2"/>            @Override<br class="calibre2"/>            public void completed(Long aLong) {<br class="calibre2"/>                LOGGER.log(Level.INFO, <br class="calibre2"/>                  "Completed Fibonacci 17 with {0}.", aLong);<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            @Override<br class="calibre2"/>            public void failed(Throwable throwable) {<br class="calibre2"/>                LOGGER.log(Level.WARNING, <br class="calibre2"/>                  "Completed Fibonacci 17 with error.", throwable);<br class="calibre2"/>            }<br class="calibre2"/>        });<br class="calibre2"/>        assertEquals(1597, (long) fibonacci.get());<br class="calibre2"/>    }</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">Finally, we'll see how to do invocation-chaining using <kbd class="calibre17">CompletableFuture</kbd>. This is quite interesting because we can chain several JAX-RS client calls using a <kbd class="calibre17"><span class="calibre4">CompletableFuture</span></kbd> fluent API. Imagine we want to calculate the Fibonacci numbers 3, 4, 5, 6, 8, and 21 and do all that in one chain call. This is what it could look like:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void fibonacci3_4_5_6_8_21() throws Exception {<br class="calibre2"/><br class="calibre2"/>        CompletableFuture&lt;Long&gt; fibonacci =<br class="calibre2"/>                Futures.toCompletable(webTarget.path("/fibonacci/{i}")<br class="calibre2"/>                  .resolveTemplate("i", 3)<br class="calibre2"/>                        .request(MediaType.TEXT_PLAIN_TYPE)<br class="calibre2"/>                           .async().get(Long.class))<br class="calibre2"/>                        .thenApply(i -&gt; webTarget<br class="calibre2"/>                           .path("/fibonacci/{i}")<br class="calibre2"/>                           .resolveTemplate("i", i + 2)<br class="calibre2"/>                                .request(MediaType.TEXT_PLAIN_TYPE)<br class="calibre2"/>                                  .get(Long.class))<br class="calibre2"/>                        .thenApply(i -&gt; webTarget<br class="calibre2"/>                          .path("/fibonacci/{i}")<br class="calibre2"/>        ...<br class="calibre2"/>        ...<br class="calibre2"/>        ...<br class="calibre2"/>        assertEquals(10946, (long) fibonacci.get());<br class="calibre2"/>    }</pre>
<p class="calibre6">As you can see, we do the first call and we use the <kbd class="calibre17">.async()</kbd> method, which returns <kbd class="calibre17">Future</kbd>. We'll convert this <kbd class="calibre17">Future</kbd> to a <kbd class="calibre17">CompletableFuture</kbd>, and then for the next calls, we use <kbd class="calibre17">thenApply</kbd> and we'll do that for the next one and so on and so forth. This will ultimately make seven calls.</p>
<p class="calibre6">Let's run this test to make sure everything's ready and it'll compile our tests. We can see that the first three are already successful; the <kbd class="calibre17">Fibonacci49WithCallback</kbd> should result in a 202, and then we're done.</p>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">That's all the magic behind the JAX-RS asynchronous line API, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/0207a312-af5c-476e-b2a0-9a213190db2e.png" class="calibre60"/></p>
<div class="mce-root">Output showing asynchronous tests running successfully</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, we talked about the motivation and benefits of luminous web services, and how they ultimately save memory and improve the performance and throughput of our REST API. We then talked about the basic usage of the <kbd class="calibre17">@Suspended</kbd> annotation and the <kbd class="calibre17">AsyncResponse</kbd> class. We learned how to use <kbd class="calibre17">TimeoutHandler</kbd> and server-side callback instances for fine-grained control. We then used <kbd class="calibre17">ManagedExecutorService</kbd> and <kbd class="calibre17">CompletableFuture</kbd> for some more syntactic sugar. Finally, we talked about the usage of asynchronous JAX-RS client APIs.</p>
<p class="calibre6">In the next chapter, we'll talk about using server-sent events.</p>


            </article>

            
        </section>
    </div>



  </body></html>