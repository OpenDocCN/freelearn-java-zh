- en: '*Chapter 10*: Microservices Architecture with GraalVM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：使用 GraalVM 的微服务架构'
- en: In previous chapters, we looked at how GraalVM builds on top of Java VM and
    provides a high-performance polyglot runtime. In this chapter, we will explore
    how GraalVM can be the core runtime for running microservices. A lot of microservices
    frameworks already run on GraalVM. We will explore some of the popular frameworks
    and build a sample application with them. We will also explore a serverless framework.
    We will take a case study and look at how we can architect the solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了 GraalVM 是如何建立在 Java 虚拟机之上，并提供高性能的多语言运行时。在本章中，我们将探讨 GraalVM 如何成为运行微服务的核心运行时。许多微服务框架已经在
    GraalVM 上运行。我们将探讨一些流行的框架，并使用它们构建一个示例应用程序。我们还将探讨一个无服务器框架。我们将进行案例研究，看看我们如何设计解决方案。
- en: By the end of this chapter, you will have acquired a good understanding of how
    to package applications as containers, running GraalVM, and how to build microservices
    applications using Micronaut, Quarkus, and Spring Boot. This chapter expects you
    to have a fair understanding of the Java programming language and some exposure
    to building Java microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将深入了解如何将应用程序打包为容器，运行 GraalVM，以及如何使用 Micronaut、Quarkus 和 Spring Boot
    构建微服务应用程序。本章假设您对 Java 编程语言有良好的理解，并对构建 Java 微服务有一些了解。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An overview of GraalVM microservices architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 微服务架构概述
- en: An understanding of how GraalVM helps to build microservices architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 GraalVM 如何帮助构建微服务架构
- en: Building microservices applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建微服务应用程序
- en: A case study to help understand how to go about solutioning a microservices
    application built on GraalVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个案例研究，帮助理解如何解决基于 GraalVM 构建的微服务应用程序
- en: Implementing a microservice with Spring Boot, Micronaut, Quarkus, and the Fn
    Project serverless framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot、Micronaut、Quarkus 和 Fn Project 无服务器框架实现微服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter provides a hands-on guide for building Java microservices. This
    requires some of the software to be installed and set up. The following is a list
    of prerequisites:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了构建 Java 微服务的实战指南。这需要安装和设置一些软件。以下是一个先决条件列表：
- en: '**Source code**: All the source code referred to in this chapter can be downloaded
    from the Git repository at [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码**: 本章中提到的所有源代码都可以从 Git 仓库[https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10)下载。'
- en: '**GraalVM**: GraalVM needs to be installed. For detailed instructions on installing
    and setting up GraalVM, refer to [https://www.graalvm.org/docs/getting-started/#install-graalvm](https://www.graalvm.org/docs/getting-started/#install-graalvm).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraalVM**: 需要安装 GraalVM。有关安装和设置 GraalVM 的详细说明，请参阅[https://www.graalvm.org/docs/getting-started/#install-graalvm](https://www.graalvm.org/docs/getting-started/#install-graalvm)。'
- en: '**Spring Boot**: Refer to [https://spring.io/guides/gs/spring-boot/](https://spring.io/guides/gs/spring-boot/)
    for more details on how to set up and use Spring Boot.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot**: 请参阅[https://spring.io/guides/gs/spring-boot/](https://spring.io/guides/gs/spring-boot/)获取有关如何设置和使用
    Spring Boot 的更多详细信息。'
- en: '**Micronaut**: We will be building code using the Micronaut framework. Please
    refer to [https://micronaut.io/download/](https://micronaut.io/download/) for
    more details on how to download and set up Micronaut.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Micronaut**: 我们将使用 Micronaut 框架来构建代码。请参阅[https://micronaut.io/download/](https://micronaut.io/download/)获取有关如何下载和设置
    Micronaut 的更多详细信息。'
- en: '**Quarkus**: We will be building microservices using the Quarkus framework.
    Please refer to [https://quarkus.io/](https://quarkus.io/) for more details on
    how to set up and use Quarkus.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quarkus**: 我们将使用 Quarkus 框架来构建微服务。请参阅[https://quarkus.io/](https://quarkus.io/)获取有关如何设置和使用
    Quarkus 的更多详细信息。'
- en: '**fn project**: We will be building a serverless application/function using
    fn project. Please refer to [https://fnproject.io/](https://fnproject.io/) for
    more details on how to download, install, and set up fn project.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fn project**: 我们将使用 fn project 构建无服务器应用程序/函数。请参阅[https://fnproject.io/](https://fnproject.io/)获取有关如何下载、安装和设置
    fn project 的更多详细信息。'
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3f7iT1T](https://bit.ly/3f7iT1T).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可以在[https://bit.ly/3f7iT1T](https://bit.ly/3f7iT1T)找到。
- en: So, let's begin!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Overview of microservices architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构概述
- en: 'Microservices are one of the most popular architectural patterns and have been
    proven to be the best architectural pattern for cloud-native application development.
    Microservices patterns help to decompose and structure applications into smaller,
    manageable, and self-contained components that expose functionality through a
    standard service interface. The following are some of the advantages of microservices
    architectural patterns:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是最受欢迎的架构模式之一，并且已被证明是云原生应用程序开发的最佳架构模式。微服务模式有助于将应用程序分解和结构化为更小、更易于管理和自包含的组件，这些组件通过标准服务接口公开功能。以下是一些微服务架构模式的优点：
- en: '**Loose coupling**: Since the application is decomposed into services that
    provide a standard interface, the application component can be independently managed,
    upgraded, and fixed without affecting the other dependent components. This helps
    in easily changing the application logic based on growing business needs and changes.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：由于应用程序被分解为提供标准接口的服务，因此应用程序组件可以独立管理、升级和修复，而不会影响其他依赖组件。这有助于根据不断增长的业务需求和变化轻松更改应用程序逻辑。'
- en: '**Manageability**: Since the components are self-contained, it is very easy
    to manage these applications. The components can be owned by smaller squads for
    development and can be deployed independently without deploying the whole application.
    This assists with rapid development and deployments using DevOps.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理性**：由于组件是自包含的，因此管理这些应用程序非常容易。组件可以由较小的团队负责开发，并且可以独立部署，而无需部署整个应用程序。这有助于使用DevOps进行快速开发和部署。'
- en: '**Scalable**: Scalability is one of the key requirements of cloud-native applications.
    Scalability in monoliths is an issue, as we have to scale the whole application,
    even though we just need to scale some part of the functionality. For example,
    during high demands, we might want to scale the ordering, shopping cart, and catalog
    services more than any other functionality of a retail portal. That is not possible
    in monoliths, but if these components are decomposed into independent microservices,
    it''s easy to scale them individually and set autoscale parameters so that they
    scale based on demand. This helps in utilizing cloud resources more effectively,
    at a lower cost.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：可扩展性是云原生应用程序的关键要求之一。在单体应用中，可扩展性是一个问题，因为即使我们只需要扩展功能的一部分，我们也必须扩展整个应用程序。例如，在需求高峰期间，我们可能希望比零售门户的其他任何功能更多地扩展订单、购物车和目录服务。在单体应用中这是不可能的，但如果将这些组件分解为独立的微服务，则可以轻松地单独扩展它们并设置自动扩展参数，以便根据需求进行扩展。这有助于更有效地利用云资源，同时降低成本。'
- en: Let's now explore how GraalVM helps to build high-performance microservices
    architectures.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在探讨GraalVM如何帮助构建高性能的微服务架构。
- en: Building microservices architecture with GraalVM
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraalVM构建微服务架构
- en: GraalVM is ideal for microservices architecture as it helps to build high-performance
    Java applications with a smaller footprint. One of the most important requirements
    for microservices architecture is a smaller footprint and faster startup. GraalVM
    is an ideal runtime for running polyglot workloads in the cloud. There are some
    cloud-native frameworks already available on the market that can build applications
    to run optimally on GraalVM, including Quarkus, Micronaut, Helidon, and Spring.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM非常适合微服务架构，因为它有助于构建具有较小内存占用和更快启动速度的高性能Java应用程序。微服务架构最重要的要求之一是较小的内存占用和更快的启动速度。GraalVM是云中运行多语言工作负载的理想运行时。市场上已经有一些云原生框架，可以构建在GraalVM上运行优化的应用程序，包括Quarkus、Micronaut、Helidon和Spring。
- en: Understanding GraalVM containers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解GraalVM容器
- en: Traditionally, applications are deployed on infrastructure that was pre-configured
    and set up for the applications to run. The infrastructure consisted of both hardware
    and a software platform that runs the applications. For example, if we have to
    run a web application, we will have to set up the operating system (such as Linux
    or Windows, for example) first. The web application server (Tomcat, WebSphere)
    and database (such as MySQL, Oracle, or DB2) are set up on a pre-defined hardware
    infrastructure, and then the applications are deployed on top of these web application
    servers. This takes a lot of time, and we may have to repeat this approach every
    time we have to set up the applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序部署在预先配置和设置好的基础设施上，以便应用程序运行。该基础设施包括硬件和运行应用程序的软件平台。例如，如果我们需要运行一个Web应用程序，我们首先需要设置操作系统（例如Linux或Windows）。Web应用程序服务器（如Tomcat、WebSphere）和数据库（如MySQL、Oracle或DB2）设置在预定义的硬件基础设施上，然后应用程序部署在这些Web应用程序服务器之上。这需要花费很多时间，而且每次我们需要设置应用程序时，可能都要重复这种方法。
- en: To reduce the setup time and to make the configurations much easier to manage,
    we moved to virtualizing the infrastructure by pre-packaging the application,
    along with various platform components (application servers, databases, and suchlike)
    and the operating system, into self-contained **Virtual Machines** (**VMs**).
    (These VMs are not to be confused with **Java Virtual Machine** (**JVM**). JVM
    is more of a platform for running Java applications. VMs in this context are much
    more than just an application platform.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少设置时间和使配置更容易管理，我们转向通过预包装应用程序、各种平台组件（如应用程序服务器、数据库等）和操作系统，将基础设施虚拟化，形成自包含的**虚拟机**（**VMs**）。（这些虚拟机不要与**Java虚拟机**（**JVM**）混淆。JVM更像是运行Java应用程序的平台。在此上下文中，虚拟机远不止是一个应用程序平台。）
- en: Virtualization helped to solve a lot of configuration and deployment issues.
    It also allowed us to optimize the usage of hardware resources by running multiple
    VMs on the same machine and utilizing resources better. VMs are bulky as they
    come with their own operating system and are tough to rapidly deploy, update,
    and manage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化帮助解决了许多配置和部署问题。它还允许我们通过在同一台机器上运行多个虚拟机并更好地利用资源来优化硬件资源的利用率。虚拟机体积庞大，因为它们自带操作系统，难以快速部署、更新和管理。
- en: 'Containerization solved this issue by bringing in another layer of virtualization.
    Most modern architectures are built on containers. Containers are units of software
    that package code and all the dependencies and environment configurations. Containers
    are lightweight, standalone executable packages that be deployed on container
    runtimes. The following diagram shows the difference between VMs and containers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化通过引入另一层虚拟化解决了这个问题。大多数现代架构都是基于容器的。容器是软件单元，它打包代码以及所有依赖和环境配置。容器是轻量级的独立可执行包，可以在容器运行时上部署。以下图表显示了虚拟机和容器之间的区别：
- en: '![Figure 10.1 – VMs versus containers'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.1 – 虚拟机与容器'
- en: '](img/Figure_10.1_B16878.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.1_B16878.jpg](img/Figure_10.1_B16878.jpg)'
- en: Figure 10.1 – VMs versus containers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 虚拟机与容器
- en: GraalVM is a perfect application platform (especially when it is compiled as
    native code) to be packaged along with the application in the same container.
    GraalVM provides the smallest footprint and faster startups and execution to rapidly
    deploy and scale up the application components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM是一个完美的应用程序平台（尤其是当它编译为原生代码时），可以与应用程序一起打包到同一个容器中。GraalVM提供了最小的占用空间和更快的启动和执行速度，以便快速部署和扩展应用程序组件。
- en: The preceding diagram shows how the application can be containerized with GraalVM.
    In the previous model, each of the containers has its own VM, which has logic
    for memory management, profiling, optimization (**JIT**), and so on. What GraalVM
    provides is a common runtime along with the container runtime, and just the application
    logic is containerized. Since GraalVM also supports multiple languages and interoperability
    between these languages, the containers can be running application code that is
    written in multiple languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了如何使用GraalVM对应用程序进行容器化。在先前的模型中，每个容器都有自己的虚拟机，该虚拟机具有内存管理、分析、优化（**JIT**）等逻辑。GraalVM提供的是与容器运行时一起的通用运行时，仅将应用程序逻辑容器化。由于GraalVM还支持多种语言以及这些语言之间的互操作性，因此容器可以运行用多种语言编写的应用程序代码。
- en: 'The following diagram shows the various scenarios of how containers can be
    deployed with GraalVM:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了容器与GraalVM一起部署的各种场景：
- en: '![Figure 10.2 – GraalVM container patterns'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.2 – GraalVM container patterns]'
- en: '](img/Figure_10.2_B16878.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.2_B16878.jpg]'
- en: Figure 10.2 – GraalVM container patterns
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – GraalVM容器模式
- en: 'In the preceding diagram, we can see various configurations/scenarios. Let''s
    go through the details:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到各种配置/场景。让我们详细了解：
- en: '**Container 1**: In this container, we can see a native image running. This
    is by far the most optimal configuration with the smallest footprint and a faster
    load.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器1**：在这个容器中，我们可以看到一个原生镜像正在运行。这是迄今为止最优化配置，具有最小的占用空间和更快的加载速度。'
- en: '**Container 2**: In this container, we have a Java application and a JavaScript
    application running on Truffle with interoperability.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器2**：在这个容器中，我们有一个Java应用和一个在Truffle上运行的JavaScript应用，它们具有互操作性。'
- en: '**Container 3**: Similar to container 2, we also can see a C/C++ application.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器3**：与容器2类似，我们也可以看到一个C/C++应用。'
- en: Container 1 is the most optimal configuration for running cloud-native unless
    we have application code written in a different programming language that needs
    to interoperate. Another approach is to compile native images and split them into
    separate containers and use standard protocols such as REST to interact.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 容器1是运行云原生应用的最优配置，除非我们编写了需要互操作的不同编程语言的应用代码。另一种方法是编译原生镜像并将它们拆分为单独的容器，然后使用标准协议如REST进行交互。
- en: These containers can be deployed in the cloud using various orchestrators, such
    as Docker Swarm, Kubernetes (including Azure Kubernetes Service, AWS Elastic Kubernetes
    Service, and Google Kubernetes Engine), AWS Fargate, and Red Hat OpenShift.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器可以使用各种编排器在云中部署，例如Docker Swarm、Kubernetes（包括Azure Kubernetes Service、AWS
    Elastic Kubernetes Service和Google Kubernetes Engine）、AWS Fargate以及Red Hat OpenShift。
- en: Let's explore how GraalVM can be used as a common runtime in microservices architecture
    with the help of a case study.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过案例研究来探讨如何使用GraalVM作为微服务架构中的通用运行时。
- en: Case study – online book library
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – 在线图书库
- en: To understand how to implement microservices on GraalVM using various modern
    microservices frameworks, let's go through a very simple case study. Later in
    the chapter, we will pick one of the services from this architecture and build
    it using different frameworks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用各种现代微服务框架在GraalVM上实现微服务，让我们通过一个非常简单的案例研究来探讨。在本章的后面部分，我们将从这个架构中选择一个服务并使用不同的框架来构建它。
- en: This case study involves building a simple website that shows a catalog of books.
    The catalog lists all the books. You can search and browse the books by specific
    keywords and should be able to select and obtain more details relating to the
    book. The user can then select and save it as a wishlist in a library of books.
    In the future, this can be extended to place an order for this book. But to keep
    it simple, let's assume that we're searching, browsing, and creating personal
    libraries in **MVP** (**Minimum Viable Product**) scope. Let's also have a section
    in the catalog where the user can see a book prediction based on what is in their
    library. This will help us to do a polyglot with some machine learning code, too.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究涉及构建一个简单的网站，展示图书目录。目录列出了所有图书。您可以通过特定的关键词搜索和浏览图书，并且应该能够选择并获取与图书相关的更多详细信息。用户可以选择并保存它作为图书馆中的愿望清单。在未来，这可以扩展为订购此书。但为了保持简单，让我们假设我们是在**MVP（最小可行产品**）范围内进行搜索、浏览和创建个人图书馆。我们还在目录中添加了一个部分，用户可以查看基于其图书馆内容的图书预测。这也有助于我们使用一些机器学习代码进行多语言处理。
- en: Functional architecture
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能架构
- en: 'Let''s go through the thought process of building this application. We will
    first start by decomposing the functionality. For this, we will require the following
    services:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建此应用程序的思维过程。我们首先将开始分解功能。为此，我们需要以下服务：
- en: '**Catalogue UI Service**: This web page is the home page where the user lands
    after successfully logging in (we will not be implementing the login, authentication,
    and authorization in MVP). This web page presents a way to search and view the
    books. This will be implemented as a micro-frontend (refer to [https://micro-frontends.org/](https://micro-frontends.org/)
    for more details on micro-frontends). We will have three UI components as follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录UI服务**：这是用户成功登录后到达的首页（在MVP中，我们不会实现登录、认证和授权）。这个网页提供了一个搜索和查看图书的方式。这将作为一个微前端实现（有关微前端的更多详细信息，请参阅[https://micro-frontends.org/](https://micro-frontends.org/)）。我们将有三个UI组件如下：'
- en: 'i. **Book List UI component**: This component shows a list of all the books.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: i. **书籍列表UI组件**：此组件显示所有书籍的列表。
- en: 'ii. **Book Details UI component**: This component shows all the details pertaining
    to the selected book.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ii. **书籍详情UI组件**：此组件显示与所选书籍相关的所有详细信息。
- en: 'iii. **Predicted Books UI component**: This component shows the books that
    are predicted, based on the books in the library.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iii. **预测书籍UI组件**：此组件显示基于图书馆中的书籍预测的书籍。
- en: '**Library UI Service**: This lists the books in your personal library and allows
    the user to add or delete books from this library.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆UI服务**：此服务列出您个人图书馆中的书籍，并允许用户添加或删除此图书馆中的书籍。'
- en: 'Now, to support these UI services, we will require microservices that store,
    fetch, and search the books. The following are the services that we will need:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了支持这些UI服务，我们需要存储、检索和搜索书籍的微服务。以下是我们需要的以下服务：
- en: '**Catalogue Service**: These services provide the RESTful APIs to browse, search,
    and view the book details.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录服务**：这些服务提供RESTful API以浏览、搜索和查看书籍详情。'
- en: '**Prediction Service**: To demonstrate the polyglot feature of GraalVM, let''s
    assume that we already have machine learning code that we have developed using
    Python, and that can predict the book, based on the books that are available in
    the library. We will embed this Python code in this Java microservice to demonstrate
    how GraalVM can help us to build optimized embedding polyglot applications.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测服务**：为了展示GraalVM的多语言特性，让我们假设我们已经有使用Python开发的机器学习代码，并且可以根据图书馆中可用的书籍预测书籍。我们将在此Java微服务中嵌入此Python代码，以展示GraalVM如何帮助我们构建优化的多语言嵌入应用程序。'
- en: '**Library Service**: This service will provide all the restful APIs for accessing
    books in the library, as well as for adding and deleting them from the library.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆服务**：此服务将提供所有用于访问图书馆书籍以及添加和删除书籍的RESTful API。'
- en: '**Book Info Service**: Let''s decide to use the Google Books API ([https://developers.google.com/books](https://developers.google.com/books))
    to get all the details about the books. We will need a service that proxies the
    Google Books API. This will help us to manage the data that is coming from the
    Google Books API. This also provides a proxy layer, so that we can always switch
    to a different Book API service without changing the whole application.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**书籍信息服务**：让我们决定使用Google Books API ([https://developers.google.com/books](https://developers.google.com/books))来获取所有关于书籍的详细信息。我们需要一个代理Google
    Books API的服务。这将帮助我们管理来自Google Books API的数据。这还提供了一个代理层，这样我们就可以随时切换到不同的书籍API服务，而无需更改整个应用程序。'
- en: 'Now we will need storage to store the information about the books that have
    been added to the personal libraries and to cache the data about the books, for
    faster fetching (instead of calling the Google Books API every time). To do so,
    we will require the following data services:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要存储来存储已添加到个人图书馆的书籍信息以及缓存书籍数据，以便更快地获取（而不是每次都调用Google Books API）。为此，我们需要以下数据服务：
- en: '**User Profile Data**: This stores the user profiles.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户资料数据**：此部分存储用户资料。'
- en: '**User Library Data**: This stores the books that the particular user has selected
    for their library.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户图书馆数据**：此部分存储特定用户为其图书馆选择的书籍。'
- en: '**Book Cache Data**: We will need to cache the book information so that we
    don''t have to call the Google Books API for information that we have already
    fetched. This will not only improve performance; it will also reduce costs as
    the Google Books API may charge you for the number of calls made.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**书籍缓存数据**：我们需要缓存书籍信息，这样我们就不必为已经获取的信息调用Google Books API。这不仅会提高性能；还会降低成本，因为Google
    Books API可能会根据调用次数向您收费。'
- en: 'The following diagram illustrates how these components work together:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这些组件是如何协同工作的：
- en: '![Figure 10.3 – Book library application – functional architecture'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 书籍图书馆应用程序 – 功能架构'
- en: '](img/Figure_10.3_B16878.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.3_B16878.jpg]'
- en: Figure 10.3 – Book library application – functional architecture
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 书籍图书馆应用程序 – 功能架构
- en: 'We have taken various architectural decisions while building the final architecture.
    Let''s quickly review them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建最终架构时，我们做出了各种架构决策。让我们快速回顾一下：
- en: '**Micro-frontends**: We decided to make the UI components micro-frontends so
    that it''s easier for us to manage and reuse the UI code. As we can see, both
    the catalog UI and library UI reuse the same components to render the list of
    books and show the book details. We are choosing ReactJS as this provides a very
    sound framework for micro-frontend implementation.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微前端**: 我们决定将UI组件做成微前端，这样我们更容易管理和复用UI代码。正如我们所见，目录UI和图书馆UI都复用了相同的组件来渲染书籍列表并显示书籍详情。我们选择ReactJS作为微前端实现，因为它提供了一个非常稳定的框架。'
- en: '**Embedding Python**: We decided to reuse the Python code already built for
    prediction. We decided to embed that as part of our catalog service to provide
    an endpoint that will provide a list of predicted books. This will also help us
    to demonstrate the capabilities of polyglot. We will use the pure Java implementation
    of microservices, as most modern microservices frameworks do not support polyglot.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入Python**: 我们决定复用已经为预测构建的Python代码。我们决定将其嵌入到我们的目录服务中，以提供一个提供预测书籍列表的端点。这也有助于我们展示多语言的能力。我们将使用纯Java实现的微服务，因为大多数现代微服务框架都不支持多语言。'
- en: '**Serverless**: We decided to render the book info service *serverless* as
    it does not need to keep the state; it just calls the Google Books API and passes
    the information.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器**: 我们决定将书籍信息服务以*无服务器*的形式渲染，因为它不需要保持状态；它只需调用Google Books API并传递信息。'
- en: '**Book information cache**: We decided to use Redis to store the book information
    cache so that we don''t have to go back to the Google Books API each time, thereby
    improving performance and reducing the cost of calling Google APIs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**书籍信息缓存**: 我们决定使用Redis来存储书籍信息缓存，这样我们就不必每次都回到Google Books API，从而提高性能并减少调用Google
    API的成本。'
- en: Let's now look at what the deployment architecture will look like on Kubernetes.
    Please refer to [https://kubernetes.io/](https://kubernetes.io/) for more details
    on how Kubernetes orchestrates the containers and provides a scalable and highly
    available solution. The following section assumes that you have a good understanding
    of Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看在Kubernetes上的部署架构将是什么样子。有关Kubernetes如何编排容器以及提供可扩展和高度可用解决方案的更多详细信息，请参阅[https://kubernetes.io/](https://kubernetes.io/)。以下部分假设您对Kubernetes有很好的理解。
- en: Deployment architecture
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署架构
- en: 'The containers are deployed on the Kubernetes cluster. The following diagram
    shows the deployment architecture of these containers in Kubernetes. This can
    be similar in any cloud:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 容器部署在Kubernetes集群上。以下图表显示了这些容器在Kubernetes中的部署架构。这可以与任何云相似：
- en: '![Figure 10.4 – Kubernetes deployment architecture for the book library application'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 书库应用在Kubernetes上的部署架构'
- en: '](img/Figure_10.4_B16878.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B16878.jpg)'
- en: Figure 10.4 – Kubernetes deployment architecture for the book library application
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 书库应用在Kubernetes上的部署架构
- en: 'Let''s understand the terms used in the preceding diagram in more detail:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解前面图表中使用的术语：
- en: '`8080`, and the target port pointing to the cluster IP of the Catalogue UI
    page, which is the home page.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8080`，目标端口指向目录UI页面的集群IP，即主页。'
- en: '`reactjs` implementation of the home page and the library page, which internally
    use the same set of `reactjs` components. This calls Library Service to get the
    information regarding the books stored in the personal library. This service also
    calls Catalog Service, which has all the REST endpoints to search and  browse
    the book''s details.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactjs` 实现的主页和图书馆页，它们内部使用相同的`reactjs`组件集。这调用图书馆服务以获取有关个人图书馆中存储的书籍的信息。此服务还调用目录服务，该服务具有所有REST端点以搜索和浏览书籍详情。'
- en: '**LibraryService deployment**: Library Service is implemented in Quarkus as
    a native image and provides the endpoints for accessing personal library information.
    This uses Library Data Service.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆服务部署**: 图书馆服务是用Quarkus作为原生图像实现的，并提供访问个人图书馆信息的端点。这使用图书馆数据服务。'
- en: '**LibraryDataService deployment**: Library Data Service is a PostgreSQL container
    that stores all the user profile and personal library information. It also uses
    a persistent volume so that when a node goes down, the information is stored.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆数据服务部署**: 图书馆数据服务是一个PostgreSQL容器，存储所有用户资料和个人图书馆信息。它还使用持久卷，以便在节点故障时存储信息。'
- en: '`CatalogueInfoService` in Quarkus native mode. This service provides the endpoints
    to search, browse, and get various details relating to the book. `BookInfoService`
    is used to get all the information pertaining to the book. `CatalogueInfoService`
    also uses the `BookInfoCache` service to fetch data that is already in cache.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Quarkus 原生模式下，`CatalogueInfoService`。该服务提供了搜索、浏览和获取与书籍相关的各种详细信息的端点。`BookInfoService`
    用于获取有关书籍的所有信息。`CatalogueInfoService` 还使用 `BookInfoCache` 服务来获取已缓存的现有数据。
- en: '**BookInfoService deployment**: This deployment has a serverless implementation
    service that fetches various book information from the Google Books API. This
    will be implemented using the fn project serverless framework running on GraalVM.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BookInfoService 部署**：这个部署有一个无服务器实现服务，从 Google Books API 获取各种书籍信息。这将使用在 GraalVM
    上运行的 fn 项目无服务器框架来实现。'
- en: '**BookInfoCacheService deployment**: This deployment is a Redis cache that
    caches all the book information, so as to avoid redundant calls to the Google
    Books API.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BookInfoCacheService 部署**：这个部署是一个 Redis 缓存，用于缓存所有书籍信息，以避免对 Google Books API
    的重复调用。'
- en: The final finished source code can be found in the Git repository. We will not
    be discussing the source code, but simply to gain a good understanding of how
    to build these microservices, we will pick `BookInfoService` and implement it
    with various microservices frameworks in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的源代码可以在 Git 仓库中找到。我们不会讨论源代码，但为了更好地理解如何构建这些微服务，我们将在下一节中选取 `BookInfoService`
    并使用各种微服务框架实现它。
- en: Exploring modern microservices frameworks
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索现代微服务框架
- en: There are modern frameworks that are built around creating microservices rapidly.
    These frameworks are built on the basis of the **Container-First** and **Cloud-First**
    design principles. They are built from the ground up, with a fast boot time and
    a low memory footprint. Helidon, Micronaut, and Quarkus are three of the most
    widely used modern Java frameworks. All three frameworks run natively on GraalVM.
    Each of these frameworks promises faster startup and a low memory footprint, and
    they achieve this by means of different methods. Let's explore these frameworks
    in this section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些现代框架是围绕快速创建微服务而构建的。这些框架基于 **容器优先** 和 **云优先** 的设计原则。它们从头开始构建，具有快速的启动时间和低内存占用。Helidon、Micronaut
    和 Quarkus 是最广泛使用的三个现代 Java 框架。所有这三个框架都在 GraalVM 上原生运行。每个框架都承诺更快的启动时间和低内存占用，并且它们通过不同的方法实现这一点。在本节中，我们将探讨这些框架。
- en: To understand these frameworks, let's now get hands-on in building a simple
    book information service. It is a simple service that accepts a keyword, uses
    the Google Books API to retrieve the book information, and returns detailed information
    relating to all the books that match the keyword. The response is returned as
    **JSON** (**JavaScript Object Notation** – refer to [https://www.json.org/json-en.html](https://www.json.org/json-en.html)
    for more details).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些框架，现在让我们动手构建一个简单的书籍信息服务。这是一个简单的服务，它接受一个关键字，使用 Google Books API 获取书籍信息，并返回与关键字匹配的所有书籍的详细信息。响应以
    **JSON**（**JavaScript 对象表示法**）返回（有关更多详细信息，请参阅 [https://www.json.org/json-en.html](https://www.json.org/json-en.html)）。
- en: Let's first start with a traditional microservice that we build using Spring
    Boot without GraalVM
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从使用 Spring Boot 构建，但不使用 GraalVM 的传统微服务开始。
- en: Building BookInfoService using Spring without GraalVM
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spring 构建 BookInfoService 而不使用 GraalVM
- en: Spring is one of the most widely used Java microservices frameworks. It comes
    with a lot of great features and is one of the popular frameworks used to build
    cloud-native applications. In this section, we will build in the traditional way
    without GraalVM, so as to understand the shortcomings of the traditional approach.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 是最广泛使用的 Java 微服务框架之一。它提供了许多出色的功能，并且是构建云原生应用程序时使用的流行框架之一。在本节中，我们将以传统方式构建，不使用
    GraalVM，以便理解传统方法的不足之处。
- en: Creating Spring boilerplate code
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Spring 模板代码
- en: 'To create the Spring boilerplate code, let''s go to [https://start.spring.io/](https://start.spring.io/)
    on a browser. This website helps us to specify some configurations and generate
    the boilerplate code. Let''s generate the boilerplate code for our `BookInfoService`.
    The following screenshot shows the Spring initializer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Spring 模板代码，请访问浏览器中的 [https://start.spring.io/](https://start.spring.io/)。该网站帮助我们指定一些配置并生成模板代码。让我们为我们的
    `BookInfoService` 生成模板代码。以下截图显示了 Spring 初始化器：
- en: '![Figure 10.5 – Spring Initializr screenshot that generates boilerplate code'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – 生成模板代码的Spring Initializr截图]'
- en: '](img/Figure_10.5_B16878.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.5_B16878.jpg)'
- en: Figure 10.5 – Spring Initializr screenshot that generates boilerplate code
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 生成模板代码的Spring Initializr截图
- en: The preceding screenshot shows the configurations selected to generate the boilerplate.
    To keep it simple and focused, we are selecting `HttpClient` to call the Google
    APIs so as to keep it simple for ou, instead of the recommended way of using jsonb
    and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了用于生成模板代码的配置。为了保持简单和专注，我们选择使用`HttpClient`调用Google API，以便简化操作，而不是推荐使用jsonb等方法。
- en: 'We need to extract the ZIP file that is generated and then implement the service.
    The following is the core logic code snippet. The full code is available in the
    Git repository at [https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM](https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提取生成的ZIP文件，然后实现服务。以下是一个核心逻辑代码片段。完整代码可在Git仓库[https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM](https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM)中找到：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we are setting the path as `/book-info` in order to
    call `BookInfoService`. In the following code, we will call the Google API to
    get the book information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将路径设置为`/book-info`以调用`BookInfoService`。在以下代码中，我们将调用Google API以获取图书信息：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we are calling the Google Books API using our Google
    API key. You have to get your own key and include it in the URL. Refer to [https://cloud.google.com/apis/docs/overview](https://cloud.google.com/apis/docs/overview)
    for more details on how to get your own Google API. We are calling the Google
    Books API using `HttpClient` and passing the response to the requester.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用我们的Google API密钥调用Google图书API。您必须获取自己的密钥并将其包含在URL中。有关如何获取自己的Google
    API的更多详细信息，请参阅[https://cloud.google.com/apis/docs/overview](https://cloud.google.com/apis/docs/overview)。我们使用`HttpClient`调用Google图书API并将响应传递给请求者。
- en: 'Let''s now build this code and run it. We will be using Maven to build it.
    The following command will build the code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建这段代码并运行它。我们将使用Maven来构建。以下命令将构建代码：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will download all the dependencies, build the application, and generate
    a JAR file. You will find the JAR file under the target folder. We should be able
    to run the JAR file using the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载所有依赖项，构建应用程序，并生成一个JAR文件。您将在target文件夹下找到JAR文件。我们可以使用以下命令运行JAR文件：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will start the Spring Boot application. The following screenshot shows
    the output of running the application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Spring Boot应用程序。以下截图显示了应用程序运行的输出：
- en: '![Figure 10.6 – Output screenshot of the Spring BookInfoService application'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 – Spring BookInfoService应用程序的输出截图]'
- en: '](img/Figure_10.6_B16878.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.6_B16878.jpg)'
- en: Figure 10.6 – Output screenshot of the Spring BookInfoService application
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Spring BookInfoService应用程序的输出截图
- en: 'Now, let''s access this application using a REST client. In this case, we are
    using `CocoaRestClient` ([https://mmattozzi.github.io/cocoa-rest-client/](https://mmattozzi.github.io/cocoa-rest-client/)).
    You can use any REST client or even use the browser to invoke the service. Let''s
    invoke http://localhost:8080/book-info?query=graalvm. The following screenshot
    shows the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用REST客户端访问这个应用程序。在这种情况下，我们使用`CocoaRestClient`([https://mmattozzi.github.io/cocoa-rest-client/](https://mmattozzi.github.io/cocoa-rest-client/))。您可以使用任何REST客户端，甚至可以使用浏览器来调用服务。让我们调用http://localhost:8080/book-info?query=graalvm。以下截图显示了输出：
- en: '![Figure 10.7 – Output of invoking the BookInformationService Spring application'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – 调用BookInformationService Spring应用程序的输出]'
- en: '](img/Figure_10.7_B16878.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.7_B16878.jpg)'
- en: Figure 10.7 – Output of invoking the BookInformationService Spring application
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 调用BookInformationService Spring应用程序的输出
- en: 'Now that we know that the application is running, let''s package this application
    into a Docker container and build the image. The following is the Dockerfile code
    for building the image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道应用程序正在运行，让我们将这个应用程序打包成一个Docker容器并构建镜像。以下是为构建镜像的Dockerfile代码：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a very simple Dockerfile. We are building the image using `openjdk11`
    as the base. We are then copying the jar file that we generated and specifying
    the entry point to run the jar file when we start the container. Let''s now build
    the Docker image using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Dockerfile。我们使用`openjdk11`作为基础来构建镜像。然后，我们复制生成的jar文件并指定在启动容器时运行jar文件的入口点。现在，让我们使用以下命令构建Docker镜像：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please feel free to use your name tag for the Docker image. These Docker images
    are also available on the author''s Docker Hub at [https://hub.docker.com/u/abvijaykumar](https://hub.docker.com/u/abvijaykumar).
    This will build an image. We should be able to see whether the image has been
    created by using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意使用您的名字标签构建Docker镜像。这些Docker镜像也可在作者的Docker Hub上找到，网址为[https://hub.docker.com/u/abvijaykumar](https://hub.docker.com/u/abvijaykumar)。这将构建一个镜像。我们应该能够使用以下命令查看镜像是否已创建：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s run this image using the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行此镜像：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows the output of running the previous command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行上一条命令的输出：
- en: '![Figure 10.8 – Console output of running the BookInformationService Spring
    application'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 – 运行BookInformationService Spring应用程序的控制台输出'
- en: '](img/Figure_10.8_B16878.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B16878.jpg)'
- en: Figure 10.8 – Console output of running the BookInformationService Spring application
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 运行BookInformationService Spring应用程序的控制台输出
- en: 'We can see that it booted up in 2.107 seconds. We should be able to call the
    service. The following screenshot shows the output after calling `http://localhost:8080/book-info?query=graalvm`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它启动用了2.107秒。我们应该能够调用该服务。以下截图显示了调用`http://localhost:8080/book-info?query=graalvm`后的输出：
- en: '![Figure 10.9 – Result of invoking the BookInformationService Spring application
    in a container'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 – 在容器中调用BookInformationService Spring应用程序的结果'
- en: '](img/Figure_10.9_B16878.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B16878.jpg)'
- en: Figure 10.9 – Result of invoking the BookInformationService Spring application
    in a container
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 在容器中调用BookInformationService Spring应用程序的结果
- en: Let's now use the modern frameworks to build the same service to understand
    and compare how these modern frameworks perform better with GraalVM.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用现代框架构建相同的服务，以了解和比较这些现代框架如何与GraalVM表现更好。
- en: Building BookInfoService with Micronaut
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Micronaut构建BookInfoService
- en: Micronaut is a full-stack microservices framework introduced by the developers
    of the Grails framework. It has an integration with all the ecosystem and tools
    and relies on compile-time integration, rather than runtime integration. This
    makes the final applications run faster, as they are compiled with all the dependencies
    during build time. It achieves this with annotation and aspect-oriented programming
    concepts of code injection at build time. This was introduced in 2018\. For more
    details on Micronaut, please refer to [https://micronaut.io/](https://micronaut.io/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut是由Grails框架的开发者引入的全栈微服务框架。它与所有生态系统和工具集成，并依赖于编译时集成，而不是运行时集成。这使得最终应用程序运行更快，因为它们在构建时编译了所有依赖项。它通过在构建时使用注解和面向切面的编程概念来实现这一点。这于2018年引入。有关Micronaut的更多详细信息，请参阅[https://micronaut.io/](https://micronaut.io/)。
- en: 'Let''s build `BookInfoService` with Micronaut. To get started, we need to install
    the Micronaut command line. Refer to [https://micronaut.io/download/](https://micronaut.io/download/)
    for detailed instructions on installing the Micronaut CLI. Once installed, we
    should be able to call the `mn` command. Let''s now create our `BookInfoService`
    Micronaut boilerplate code with `mn`. The following command creates the boilerplate
    code. We are passing the `-b=maven` flag to create the Maven build:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Micronaut构建`BookInfoService`。要开始，我们需要安装Micronaut命令行。有关安装Micronaut CLI的详细说明，请参阅[https://micronaut.io/download/](https://micronaut.io/download/)。安装后，我们应该能够调用`mn`命令。现在，让我们使用`mn`创建我们的`BookInfoService`
    Micronaut样板代码。以下命令创建样板代码。我们传递`-b=maven`标志来创建Maven构建：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should see a directory created called `bookinfoservice` where all the generated
    boilerplate code is created. Let''s now set the environment to point to GraalVM.
    To validate whether we are using the right version of GraalVM, we can check by
    running `java-version`. The following output shows the version of GraalVM:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个名为`bookinfoservice`的目录被创建，其中包含所有生成的样板代码。现在，让我们设置环境以指向GraalVM。为了验证我们是否使用了正确的GraalVM版本，我们可以通过运行`java-version`来检查。以下输出显示了GraalVM的版本：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now update the Micronaut code to implement our logic. The following
    code snippet shows the code for `Controller`, which exposes the REST endpoint:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新Micronaut代码以实现我们的逻辑。以下代码片段显示了`Controller`的代码，它暴露了REST端点：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `BookInfoService` class has the exact same code as what we implemented
    in Spring Boot in the preceding code. Let''s now compile the Micronaut project
    by executing the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookInfoService`类与我们在前面的Spring Boot代码中实现的确切相同。现在，让我们通过执行以下命令来编译Micronaut项目：'
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then run the Micronaut application by executing the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过执行以下命令来运行Micronaut应用：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the output when we run the Micronaut application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行Micronaut应用的输出：
- en: '![Figure 10.10 – Console output of running the Micronaut BookInformationService
    Spring application'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 – 运行Micronaut BookInformationService Spring应用的控制台输出'
- en: '](img/Figure_10.10_B16878.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B16878.jpg)'
- en: Figure 10.10 – Console output of running the Micronaut BookInformationService
    Spring application
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 运行Micronaut BookInformationService Spring应用的控制台输出
- en: 'We can see that it took just 500 milliseconds to load the Micronaut application,
    as compared to Spring Boot in the *Building BookInfoService using Spring without
    GraalVM* section, which took around 2 seconds. This is significantly fast, considering
    how simple and small our application is. Let''s now build a Docker image of this
    application. Micronaut provides a direct way to build a Docker image with Maven
    by passing the `-Dpackaging=docker` argument. The following command will generate
    the Docker image directly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，与*使用Spring构建BookInfoService而不使用GraalVM*部分相比，它只用了500毫秒来加载Micronaut应用，而后者大约需要2秒。考虑到我们的应用既简单又小，这已经非常快了。现在让我们构建这个应用的Docker镜像。Micronaut通过传递`-Dpackaging=docker`参数提供了一种直接使用Maven构建Docker镜像的方法。以下命令将直接生成Docker镜像：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Micronaut can also generate the Dockerfile so that we can customize and execute
    separately. The Dockerfiles are created under the target directory when we pass
    the `-mn:dockerfile` argument to the command. The following is the Dockerfile
    that is created:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut还可以生成Dockerfile，以便我们可以自定义并单独执行。当我们将`-mn:dockerfile`参数传递给命令时，Dockerfiles会在目标目录下创建。以下是我们创建的Dockerfile：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see that the Docker image is built on `openjdk`. We are still not using
    the GraalVM native image feature. Let''s build this image by calling the following
    command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个Docker镜像是基于`openjdk`构建的。我们仍然没有使用GraalVM原生镜像功能。让我们通过调用以下命令来构建这个镜像：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's now run this Docker image by calling the following command:=
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过调用以下命令来运行这个Docker镜像:=
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following shows the output of running the preceding command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了运行前面命令的输出：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see that the application started in 1.5 seconds, which is still faster
    than the Spring image. We are still not using the GraalVM native image feature.
    Let''s now build the same application as a GraalVM native image. To build a native
    image, Micronaut supports a Maven profile, which can be invoked by passing the
    `-Dpackaging=native-image` argument to the command. The following command creates
    the native image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，应用在1.5秒内启动，这仍然比Spring镜像快。我们仍然没有使用GraalVM原生镜像功能。现在让我们将相同的应用作为GraalVM原生镜像来构建。要构建原生镜像，Micronaut支持一个Maven配置文件，可以通过将`-Dpackaging=native-image`参数传递给命令来调用。以下命令创建原生镜像：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s now generate the Dockerfile to understand how this image is created.
    To generate the Dockerfile, we need to execute the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们生成Dockerfile来了解这个镜像是如何创建的。要生成Dockerfile，我们需要执行以下命令：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will generate the Dockerfile under the target directory. The following
    code shows the Dockerfile:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在目标目录下生成Dockerfile。以下代码显示了Dockerfile：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see that this is a multi-phase Dockerfile. In the first phase, we are
    installing the native image, copying all the required application files into the
    image, and finally running the `native-image` command to create the native image.
    In the second phase, we are copying the native image and providing an entry point.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是一个多阶段的Dockerfile。在第一阶段，我们正在安装原生镜像，将所有必需的应用程序文件复制到镜像中，并最终运行`native-image`命令来创建原生镜像。在第二阶段，我们正在复制原生镜像并提供一个入口点。
- en: 'Let''s run this image and see how fast it loads. Let''s execute the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个镜像并看看它加载有多快。让我们执行以下命令：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following output shows that it took just 551 milliseconds for the image
    to load, which is almost half the time it took for the non-GraalVM Micronaut application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示，加载镜像仅用了 551 毫秒，这几乎是非 GraalVM Micronaut 应用程序所需时间的一半：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see how easy it is to create a microservice with Micronaut, and how it
    seamlessly integrates with the GraalVM toolchain to generate Docker images with
    a very small footprint and fast loading.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到创建微服务有多容易，以及它如何无缝地与 GraalVM 工具链集成，以生成具有非常小体积和快速加载的 Docker 镜像。
- en: Quarkus is another very popular microservices framework. Let's now explore Quarkus
    and build the same service using Quarkus.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 是另一个非常流行的微服务框架。现在让我们来探索 Quarkus 并使用它构建相同的服务。
- en: Building BookInfoService with Quarkus
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Quarkus 构建 BookInfoService
- en: Quarkus was developed by Red Hat and provides the most sophisticated list of
    integration with the Java ecosystem of frameworks. It is built on top of the MicroProfile,
    Vert.x, Netty, and Hibernate standards. It is built as a fully Kubernetes-native
    framework. This was introduced in 2019.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 由 Red Hat 开发，提供了与 Java 生态系统框架最复杂的集成列表。它是建立在 MicroProfile、Vert.x、Netty
    和 Hibernate 标准之上的。它被构建为一个完全 Kubernetes 原生的框架。这于 2019 年推出。
- en: 'Let''s now build `BookInfoService` using Quarkus. Quarkus provides a starter
    code generator at [http://code.quarkus.io](http://code.quarkus.io). Let''s go
    to that website and generate our code. The following screenshot shows the configurations
    that are selected to generate our `BookInfoService` boilerplate code. We are also
    including RESTEasy JAX-RS to create our endpoint:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 Quarkus 构建 `BookInfoService`。Quarkus 在 [http://code.quarkus.io](http://code.quarkus.io)
    提供了一个启动代码生成器。让我们访问该网站并生成我们的代码。以下截图显示了用于生成我们的 `BookInfoService` 样板代码的配置。我们还包括 RESTEasy
    JAX-RS 来创建我们的端点：
- en: '![Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11 – code.quarkus.io 网站的截图，用于生成样板代码'
- en: '](img/Figure_10.11_B16878.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.11_B16878.jpg)'
- en: Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – code.quarkus.io 网站的截图，用于生成样板代码
- en: 'This will generate code in a zip file (we can also provide a Git repository,
    where Quarkus will automatically push the code). Let''s now download the zip file
    and then extract and compile it with the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 zip 文件中生成代码（我们也可以提供一个 Git 仓库，Quarkus 将自动推送代码）。现在让我们下载 zip 文件，然后使用以下命令提取和编译它：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The best part about Quarkus is that when we execute this command, it provides
    a way for us to edit the code and test it without restarting the server. This
    helps in building the application rapidly. Now, let's update the Quarkus code
    to our `BookInfoService` endpoint.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 最好的部分是，当我们执行此命令时，它为我们提供了一个编辑代码和测试代码而不需要重新启动服务器的方法。这有助于快速构建应用程序。现在，让我们更新
    Quarkus 代码到我们的 `BookInfoService` 端点。
- en: 'The following code shows implementation of the endpoint:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了端点的实现：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While we update the code and save it, Quarkus automatically updates the runtime.
    We don''t have to restart the server. The following screenshot shows the output
    of calling our `bookservice` that is running with Quarkus:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新代码并保存时，Quarkus 会自动更新运行时。我们不需要重新启动服务器。以下截图显示了运行在 Quarkus 上的 `bookservice`
    的输出：
- en: '![Figure 10.12 – Result of invoking the Quarkus implementation of the'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.12 – 调用 Quarkus 实现的 BookInformationService 应用程序的结果](img/Figure_10.12_B16878.jpg)'
- en: BookInformationService application
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: BookInformationService 应用程序
- en: '](img/Figure_10.12_B16878.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.11_B16878.jpg)'
- en: Figure 10.12 – Result of invoking the Quarkus implementation of the BookInformationService
    application
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 调用 Quarkus 实现的 BookInformationService 应用程序的结果
- en: 'Let''s now build a GraalVM native image using Quarkus. To do that, we need
    to edit the `pom.xml` file and make sure we have the following profile:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 Quarkus 构建 GraalVM 原生镜像。为此，我们需要编辑 `pom.xml` 文件并确保我们有以下配置文件：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Quarkus uses Mandrel, which is a downstream distribution of GraalVM. You can
    read more about Mandrel at [https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/](https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 使用 Mandrel，它是 GraalVM 的下游发行版。您可以在 [https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/](https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/)
    上了解更多关于 Mandrel 的信息。
- en: 'Let''s now build the native image. Quarkus provides a direct Maven profile
    to build native images. We can create a native image by executing the following
    command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建原生镜像。Quarkus提供了一个直接的Maven配置文件来构建原生镜像。我们可以通过执行以下命令来创建一个原生镜像：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will create the native build under the target folder. Let''s run the native
    build directly. The following shows the output after running the native image:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在目标文件夹下创建原生构建。让我们直接运行原生构建。以下是在运行原生镜像后的输出：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see that it took just `0.015s` to start the application. This is significantly
    faster than the traditional implementations, which took around 2 seconds to start
    up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，启动应用程序仅用了`0.015s`。这比传统的实现快得多，后者启动需要大约2秒钟。
- en: 'Quarkus also created various Dockerfile versions, and we can find these under
    the Docker folder. The following screenshot shows the list of Dockerfiles that
    Quarkus automatically creates:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus还创建了各种Dockerfile版本，我们可以在Docker文件夹下找到这些版本。以下截图显示了Quarkus自动创建的Dockerfile列表：
- en: '![Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus
    creates'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.13 – Quarkus创建的各种版本Dockerfile的截图'
- en: '](img/Figure_10.13_B16878.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.13_B16878.jpg)'
- en: Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus creates
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – Quarkus创建的各种版本Dockerfile的截图
- en: 'Let''s quickly explore these various types of Dockerfiles:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速探索这些各种类型的Dockerfile：
- en: '**Dockerfile.legacy-jar** and **Dockerfile.jvm**: This Dockerfile has the commands
    to build a Docker image with a normal Quarkus application, JAR, and OpenJDK headless.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile.legacy-jar** 和 **Dockerfile.jvm**：这个Dockerfile包含了构建带有正常Quarkus应用程序、JAR和OpenJDK无头服务的Docker镜像的命令。'
- en: '**Dockerfile.native**: This Dockerfile builds the native image.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile.native**：这个Dockerfile构建原生镜像。'
- en: '**Dockerfile.native-distroless**: This Docker file also generates an image
    with a native image, but uses the new technique introduced by Google to build
    the image that contains just the application, language runtime, and no operating
    system distribution. This helps in creating a small image, and has fewer vulnerabilities.
    Refer to [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)
    for more details on distroless containers.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile.native-distroless**：这个Dockerfile也生成一个带有原生镜像的镜像，但使用Google引入的新技术来构建只包含应用程序、语言运行时而没有操作系统分发的镜像。这有助于创建一个小的镜像，并且具有更少的安全漏洞。有关distroless容器的更多详细信息，请参阅[https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)。'
- en: 'We can create Docker images of these various Docker versions by executing the
    following commands:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来创建这些各种Docker版本的Docker镜像：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To compare the sizes of these images, lets run the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较这些镜像的大小，让我们运行以下命令：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following chart compares the sizes of each of these images:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表比较了这些镜像的大小：
- en: '![Figure 10.14 – Chart comparing the size of Docker images'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.14 – 比较Docker镜像大小的图表'
- en: '](img/Figure_10.14_B16878.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.14_B16878.jpg)'
- en: Figure 10.14 – Chart comparing the size of Docker images
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 比较Docker镜像大小的图表
- en: At the time of writing this book, the smallest footprint and the fastest executing
    GraalVM microservice image is built using a Quarkus native distroless image. Spring
    has also launched Spring Native ([https://spring.io/blog/2021/03/11/announcing-spring-native-beta](https://spring.io/blog/2021/03/11/announcing-spring-native-beta))
    and Oracle has Helidon ([https://helidon.io/#/](https://helidon.io/#/)), which
    provide similar frameworks to run on GraalVM.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，使用Quarkus原生distroless镜像构建的最小足迹和执行速度最快的GraalVM微服务镜像。Spring也推出了Spring Native
    ([https://spring.io/blog/2021/03/11/announcing-spring-native-beta](https://spring.io/blog/2021/03/11/announcing-spring-native-beta))，Oracle有Helidon
    ([https://helidon.io/#/](https://helidon.io/#/))，它们提供了在GraalVM上运行的类似框架。
- en: Building a serverless BookInfoService using fn project
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fn项目构建无服务器BookInfoService
- en: Function-as-a-Service, or serverless, is another architectural pattern for running
    code on demand and utilizes cloud resources. The serverless approach runs the
    code when a request is received. The code boots up, executes, handles the requests,
    and then shuts down, thereby utilizing cloud resources to the optimum. This provides
    a highly available, scalable architecture at optimum cost. However, serverless
    architecture demands a faster boot, quicker execution, and shutdown.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数即服务（Function-as-a-Service，简称 FaaS），或无服务器，是另一种按需运行代码的架构模式，并利用云资源。无服务器方法在接收到请求时运行代码。代码启动、执行、处理请求，然后关闭，从而最优地利用云资源。这提供了一个高度可用、可扩展且成本最优的架构。然而，无服务器架构要求更快的启动、更快的执行和关闭。
- en: GraalVM native images (ahead of time) is the best option for serverless, as
    native images start up and run faster than traditional Java applications. GraalVM
    native images have a very small footprint, they are fast to boot, and they come
    with embedded VM (Substrate VM).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 原生镜像（预编译）是 FaaS 的最佳选择，因为原生镜像启动和运行速度比传统的 Java 应用程序快。GraalVM 原生镜像具有非常小的体积，它们启动速度快，并内置了虚拟机（Substrate
    VM）。
- en: fn project is also a great environment for building serverless applications.
    Fn supports the building of serverless applications in Go, Java, JavaScript, Python,
    Ruby, and C#. It is a very simple and rapid application development environment
    that comes with an fn daemon and a CLI that provides most of the scaffolding to
    build serverless applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: fn project 也是构建无服务器应用的优秀环境。Fn 支持 Go、Java、JavaScript、Python、Ruby 和 C# 的无服务器应用构建。它是一个非常简单且快速的应用开发环境，包含
    fn 守护进程和 CLI，提供了构建无服务器应用的大部分脚手架。
- en: In this section, let's focus on building the `BookInfoService` function using
    fn project. Please refer to [https://fnproject.io/](https://fnproject.io/) for
    detailed instructions on installing the `fn` command-line interface. We first
    have to start the fn daemon server using `fn start`. The fn server runs in Docker,
    and you can check that by running `docker ps`. The Fn daemon server runs at port
    `8080`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们专注于使用 fn project 构建函数 `BookInfoService`。请参考[https://fnproject.io/](https://fnproject.io/)获取安装
    `fn` 命令行界面的详细说明。我们首先必须使用 `fn start` 启动 fn 守护进程服务器。fn 服务器在 Docker 中运行，你可以通过运行 `docker
    ps` 来检查。Fn 守护进程服务器运行在端口 `8080`。
- en: 'The `fn` command line also provides a way to generate boilerplate code. Let''s
    now generate the project by executing the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn` 命令行还提供了一种生成样板代码的方法。现在让我们通过执行以下命令来生成项目：'
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This creates a `book-info-service-function` directory with all the boilerplate
    code. Let's inspect what is inside that directory. We will find `func.yaml`, `pom.xml`,
    and `src` directories.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含所有样板代码的 `book-info-service-function` 目录。让我们检查该目录中有什么。我们将找到 `func.yaml`、`pom.xml`
    和 `src` 目录。
- en: '`func.yml` is the main manifest `yaml` file that has the key information about
    the class that implements the function and the entry point. Let''s inspect the
    configuration file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`func.yml` 是主要的 `yaml` 清单文件，其中包含实现函数的类和入口点的关键信息。让我们检查配置文件：'
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s now understand the preceding configuration file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来理解前面的配置文件：
- en: '`name`: The name of the function. We can see the name of the function that
    we specified in our `fn init` command line.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：函数的名称。我们可以看到我们在 `fn init` 命令行中指定的函数名称。'
- en: '`version`: The version of this function.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：此函数的版本。'
- en: '`runtime`: JVM as the runtime.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime`：作为运行时的 JVM。'
- en: '`build_image`: The Docker image that should be used to build the Java code;
    in this case, we see that it''s JDK 11.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_image`：用于构建 Java 代码的 Docker 镜像；在这种情况下，我们看到它是 JDK 11。'
- en: '`run_image`: The Docker image that should be used as a runtime; in this case,
    it is JRE11.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_image`：用作运行时的 Docker 镜像；在这种情况下，它是 JRE11。'
- en: '`cmd`: This is the entry point, which is `ClassName:MethodName`. We will change
    `cmd` to point to our class and method: `cmd: com.abvijay.chapter9.fn.BookInfoService::getBookInfo`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：这是入口点，形式为 `ClassName:MethodName`。我们将更改 `cmd` 以指向我们的类和方法：`cmd: com.abvijay.chapter9.fn.BookInfoService::getBookInfo`。'
- en: In the `src` folder, we will create `com.abvijay.chapter9.fn.BookInfoService`
    with the `getBookInfo()` method. The implementation of `getBookInfo()` is the
    same as other implementations we performed previously in the section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹中，我们将创建 `com.abvijay.chapter9.fn.BookInfoService` 并包含 `getBookInfo()`
    方法。`getBookInfo()` 的实现与我们在本节中之前执行的其他实现相同。
- en: 'The following code shows the implementation of the function that calls the
    Google API to get the books:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了调用 Google API 获取书籍的函数实现：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s now build and deploy this serverless container to the local Docker.
    Functions are grouped into applications. An application can have multiple functions.
    This helps in grouping and managing them. So we need to create a book info service
    app using the `fn create app` command. The following shows the output after executing
    the command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建和部署这个无服务器容器到本地 Docker。函数被分组为应用程序。一个应用程序可以有多个函数。这有助于对它们进行分组和管理。因此，我们需要使用
    `fn create app` 命令创建一个图书信息服务应用程序。以下是在执行命令后的输出：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the app has been created, we can deploy it using the `fn deploy` command.
    This command has to be executed at the root folder of the function app that we
    created. The following shows the output after executing the command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了应用程序，我们就可以使用 `fn deploy` 命令来部署它。这个命令必须在创建的函数应用程序的根目录下执行。以下是在执行命令后的输出：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `fn deploy` command will build the code using Maven, package it as a Docker
    image, and deploy it to the local Docker runtime. fn can also be used to deploy
    to the cloud or k8s cluster directly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn deploy` 命令将使用 Maven 构建代码，将其打包为 Docker 镜像，并将其部署到本地 Docker 运行时。fn 还可以直接用于部署到云或
    k8s 集群。'
- en: 'Let''s now use the `docker images` command to check whether our image has been
    built:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `docker images` 命令来检查我们的镜像是否已构建：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also use `fn inspect` to get all the details about the function. This
    helps in discovering the services. The following shows the output of executing
    the command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `fn inspect` 来获取有关函数的所有详细信息。这有助于发现服务。以下是在执行命令后的输出：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s invoke the service. Since our function expects an input argument
    in the number, we can pass it using an echo command and pipe the output to `fn
    invoke` to invoke our function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用这个服务。由于我们的函数期望一个数字类型的输入参数，我们可以使用 echo 命令传递它，并将输出通过管道传递给 `fn invoke` 来调用我们的函数：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can see the function executing and the output of the Google API (the preceding
    output is partial, to save space). Now let's run the same logic on GraalVM.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到函数的执行过程和 Google API 的输出（前面的输出是部分内容，以节省空间）。现在让我们在 GraalVM 上运行相同的逻辑。
- en: 'The base image for GraalVM is different. We use `fnproject/fn-java-native-init`
    as the base, and initialize our fn project with that. The following is the output
    of generating a Graal native image-based fn project:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 的基础镜像不同。我们使用 `fnproject/fn-java-native-init` 作为基础，并使用它初始化我们的 fn 项目。以下是生成基于
    Graal 本地图像的 fn 项目的输出：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This generates a Dockerfile. This is followed by the Dockerfile code, which
    you can find under the project directory (`book-info-service-function-graal`).
    This `fn` configuration works differently. It also generates a Dockerfile, with
    all the necessary Docker build commands. This is a multi-stage Docker build file.
    Let''s inspect this Dockerfile:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 Dockerfile。接下来是 Dockerfile 代码，您可以在项目目录（`book-info-service-function-graal`）下找到它。这个
    `fn` 配置工作方式不同。它也生成一个 Dockerfile，包含所有必要的 Docker 构建命令。这是一个多阶段 Docker 构建文件。让我们检查这个
    Dockerfile：
- en: '![Figure 10.15 – Dockerfile generated by fn'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.15 – Dockerfile generated by fn'
- en: '](img/Figure_10.15_B16878.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.15_B16878.jpg](img/Figure_10.15_B16878.jpg)'
- en: Figure 10.15 – Dockerfile generated by fn
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 由 fn 生成的 Dockerfile
- en: 'Let''s understand this Dockerfile:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解这个 Dockerfile：
- en: '`fnproject/fn-java-fdk-build`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fnproject/fn-java-fdk-build`。'
- en: '`/function`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/function`。'
- en: '**Lines 19–23**: Then, the Maven environment is configured.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 19–23 行**：然后，配置 Maven 环境。'
- en: '`fnproject/fn-java-native` as the base image, the GraalVM is configured and
    the fn runtime is compiled. This is a very important step as this is what makes
    our serverless runtime faster and with a smaller footprint.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fnproject/fn-java-native` 作为基础镜像，配置 GraalVM 并编译 fn 运行时。这是一个非常重要的步骤，因为这使我们的无服务器运行时更快，并且占用更小的空间。
- en: '`busybox:glibc` (which is the minimal version of Linux+glibc) base image.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `busybox:glibc`（这是 Linux+glibc 的最小版本）为基础镜像。
- en: '`func.yml`, in this way of building the serverless image, has no information.
    fn will use the Dockerfile to perform the build (along with Maven) and deploy
    the image to the repository.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func.yml`，在这种构建无服务器镜像的方式中，没有任何信息。fn 将使用 Dockerfile 来执行构建（以及 Maven）并将镜像部署到仓库。'
- en: 'We need to change `line` `48` to point to our class. Let''s replace that with
    the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将第 `48` 行更改为指向我们的类。让我们用以下内容替换它：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another important configuration file that we need to change is `reflection.json`  under `src/main/conf`. This
    JSON file has the manifest information about the class name and the method. It
    is used by the native image builder to resolve the reflection we do by calling
    our function dynamically. Refer to the *Building native images* section in [*Chapter
    5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097), *Graal Ahead-of-Time Compiler
    and Native Image*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改另一个重要的配置文件，即位于`src/main/conf`下的`reflection.json`。此JSON文件包含有关类名和方法的信息的清单。它被原生镜像构建器用于解决我们通过动态调用我们的函数所进行的反射。请参阅[*第5章*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097)中的[*构建原生镜像*]部分，*Graal
    Ahead-of-Time Compiler和Native Image*。
- en: 'Now, let''s create an fn app and deploy this app using the `fn create app`
    command. The following is the output after executing the command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个fn应用，并使用`fn create app`命令部署此应用。以下是执行命令后的输出：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can build the native image and deploy it using the `fn deploy –app book-info-service-app-graal`
    command and we can execute the method by calling `echo -n 'java' | fn invoke book-info-service-app-graal
    book-info-service-function`. Checking the Docker images, we will see that the
    size of the Java image is 238 MB, and that of the GraalVM image is just 41 MB.
    That is a 10-times-smaller footprint than traditional Java applications. We can
    time the function calls, and we can see that the native images are much faster
    (up to 30%).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fn deploy –app book-info-service-app-graal`命令构建原生镜像并部署它，并且我们可以通过调用`echo
    -n 'java' | fn invoke book-info-service-app-graal book-info-service-function`来执行方法。检查Docker镜像，我们会看到Java镜像的大小为238
    MB，而GraalVM镜像的大小仅为41 MB。这比传统的Java应用程序小10倍。我们可以计时函数调用，并且我们可以看到原生镜像运行得更快（高达30%）。
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Serverless is the best solution, for quicker and stateless services, as it does
    not take any resources and we don't have to keep it running all the time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器是最佳解决方案，因为它适用于快速且无状态的服务，它不占用任何资源，我们也不需要一直保持其运行。
- en: In this section, we have looked at various framework implementations and ways
    to optimize the image.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了各种框架实现和优化图像的方法。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on reaching this point! In this chapter, we looked at how microservices
    architectures are built. To understand the architectural thought process, we picked
    a simple case study and explored how it can be deployed on Kubernetes as a collection
    of microservices. We then explored various microservices frameworks, and built
    a service on each of these frameworks, to appreciate the benefits that GraalVM
    brings to cloud-native architectures.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您达到这一阶段！在本章中，我们探讨了微服务架构的构建方式。为了理解架构思考过程，我们选择了一个简单的案例研究，并探讨了它如何作为微服务集合部署在Kubernetes上。然后，我们探讨了各种微服务框架，并在每个框架上构建了一个服务，以欣赏GraalVM为云原生架构带来的好处。
- en: After reading this chapter, you should have acquired a good understanding of
    how to go about building microservices-based, cloud-native applications using
    GraalVM as the runtime. This chapter gives a good head start for Java developers
    to quickly start building applications on one of the microservices frameworks
    (Quarkus, Spring, Micronaut). The source code that is provided along with this
    chapter (in Git) will also provide a good reference implementation of microservices
    on GraalVM.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，您应该已经对如何使用GraalVM作为运行时构建基于微服务的云原生应用程序有了很好的理解。本章为Java开发者快速开始在微服务框架（Quarkus、Spring、Micronaut）之一上构建应用程序提供了一个良好的起点。本章提供的源代码（在Git中）也将提供微服务在GraalVM上的良好参考实现。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a microservice?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: What are the advantages of a microservices architecture?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构的优势是什么？
- en: Why is GraalVM an ideal application runtime for microservices?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么GraalVM是微服务的理想应用程序运行时？
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Microservices architecture ([https://microservices.io/](https://microservices.io/))
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构 ([https://microservices.io/](https://microservices.io/))
- en: Micronaut ([http://microprofile.io/](http://microprofile.io/))
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micronaut ([http://microprofile.io/](http://microprofile.io/))
- en: Quarkus ([https://quarkus.io/](https://quarkus.io/))
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus ([https://quarkus.io/](https://quarkus.io/))
- en: Spring Boot ([https://spring.io/](https://spring.io/))
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot ([https://spring.io/](https://spring.io/))
- en: Spring Native ([https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/))
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Native ([https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/))
