- en: '*Chapter 10*: Microservices Architecture with GraalVM'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we looked at how GraalVM builds on top of Java VM and
    provides a high-performance polyglot runtime. In this chapter, we will explore
    how GraalVM can be the core runtime for running microservices. A lot of microservices
    frameworks already run on GraalVM. We will explore some of the popular frameworks
    and build a sample application with them. We will also explore a serverless framework.
    We will take a case study and look at how we can architect the solution.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have acquired a good understanding of how
    to package applications as containers, running GraalVM, and how to build microservices
    applications using Micronaut, Quarkus, and Spring Boot. This chapter expects you
    to have a fair understanding of the Java programming language and some exposure
    to building Java microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of GraalVM microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of how GraalVM helps to build microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building microservices applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A case study to help understand how to go about solutioning a microservices
    application built on GraalVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a microservice with Spring Boot, Micronaut, Quarkus, and the Fn
    Project serverless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provides a hands-on guide for building Java microservices. This
    requires some of the software to be installed and set up. The following is a list
    of prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code**: All the source code referred to in this chapter can be downloaded
    from the Git repository at [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraalVM**: GraalVM needs to be installed. For detailed instructions on installing
    and setting up GraalVM, refer to [https://www.graalvm.org/docs/getting-started/#install-graalvm](https://www.graalvm.org/docs/getting-started/#install-graalvm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Boot**: Refer to [https://spring.io/guides/gs/spring-boot/](https://spring.io/guides/gs/spring-boot/)
    for more details on how to set up and use Spring Boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micronaut**: We will be building code using the Micronaut framework. Please
    refer to [https://micronaut.io/download/](https://micronaut.io/download/) for
    more details on how to download and set up Micronaut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quarkus**: We will be building microservices using the Quarkus framework.
    Please refer to [https://quarkus.io/](https://quarkus.io/) for more details on
    how to set up and use Quarkus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fn project**: We will be building a serverless application/function using
    fn project. Please refer to [https://fnproject.io/](https://fnproject.io/) for
    more details on how to download, install, and set up fn project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3f7iT1T](https://bit.ly/3f7iT1T).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Overview of microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices are one of the most popular architectural patterns and have been
    proven to be the best architectural pattern for cloud-native application development.
    Microservices patterns help to decompose and structure applications into smaller,
    manageable, and self-contained components that expose functionality through a
    standard service interface. The following are some of the advantages of microservices
    architectural patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loose coupling**: Since the application is decomposed into services that
    provide a standard interface, the application component can be independently managed,
    upgraded, and fixed without affecting the other dependent components. This helps
    in easily changing the application logic based on growing business needs and changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manageability**: Since the components are self-contained, it is very easy
    to manage these applications. The components can be owned by smaller squads for
    development and can be deployed independently without deploying the whole application.
    This assists with rapid development and deployments using DevOps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: Scalability is one of the key requirements of cloud-native applications.
    Scalability in monoliths is an issue, as we have to scale the whole application,
    even though we just need to scale some part of the functionality. For example,
    during high demands, we might want to scale the ordering, shopping cart, and catalog
    services more than any other functionality of a retail portal. That is not possible
    in monoliths, but if these components are decomposed into independent microservices,
    it''s easy to scale them individually and set autoscale parameters so that they
    scale based on demand. This helps in utilizing cloud resources more effectively,
    at a lower cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now explore how GraalVM helps to build high-performance microservices
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Building microservices architecture with GraalVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM is ideal for microservices architecture as it helps to build high-performance
    Java applications with a smaller footprint. One of the most important requirements
    for microservices architecture is a smaller footprint and faster startup. GraalVM
    is an ideal runtime for running polyglot workloads in the cloud. There are some
    cloud-native frameworks already available on the market that can build applications
    to run optimally on GraalVM, including Quarkus, Micronaut, Helidon, and Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraalVM containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, applications are deployed on infrastructure that was pre-configured
    and set up for the applications to run. The infrastructure consisted of both hardware
    and a software platform that runs the applications. For example, if we have to
    run a web application, we will have to set up the operating system (such as Linux
    or Windows, for example) first. The web application server (Tomcat, WebSphere)
    and database (such as MySQL, Oracle, or DB2) are set up on a pre-defined hardware
    infrastructure, and then the applications are deployed on top of these web application
    servers. This takes a lot of time, and we may have to repeat this approach every
    time we have to set up the applications.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the setup time and to make the configurations much easier to manage,
    we moved to virtualizing the infrastructure by pre-packaging the application,
    along with various platform components (application servers, databases, and suchlike)
    and the operating system, into self-contained **Virtual Machines** (**VMs**).
    (These VMs are not to be confused with **Java Virtual Machine** (**JVM**). JVM
    is more of a platform for running Java applications. VMs in this context are much
    more than just an application platform.)
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization helped to solve a lot of configuration and deployment issues.
    It also allowed us to optimize the usage of hardware resources by running multiple
    VMs on the same machine and utilizing resources better. VMs are bulky as they
    come with their own operating system and are tough to rapidly deploy, update,
    and manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containerization solved this issue by bringing in another layer of virtualization.
    Most modern architectures are built on containers. Containers are units of software
    that package code and all the dependencies and environment configurations. Containers
    are lightweight, standalone executable packages that be deployed on container
    runtimes. The following diagram shows the difference between VMs and containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – VMs versus containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – VMs versus containers
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM is a perfect application platform (especially when it is compiled as
    native code) to be packaged along with the application in the same container.
    GraalVM provides the smallest footprint and faster startups and execution to rapidly
    deploy and scale up the application components.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows how the application can be containerized with GraalVM.
    In the previous model, each of the containers has its own VM, which has logic
    for memory management, profiling, optimization (**JIT**), and so on. What GraalVM
    provides is a common runtime along with the container runtime, and just the application
    logic is containerized. Since GraalVM also supports multiple languages and interoperability
    between these languages, the containers can be running application code that is
    written in multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the various scenarios of how containers can be
    deployed with GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – GraalVM container patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – GraalVM container patterns
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see various configurations/scenarios. Let''s
    go through the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container 1**: In this container, we can see a native image running. This
    is by far the most optimal configuration with the smallest footprint and a faster
    load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container 2**: In this container, we have a Java application and a JavaScript
    application running on Truffle with interoperability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container 3**: Similar to container 2, we also can see a C/C++ application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container 1 is the most optimal configuration for running cloud-native unless
    we have application code written in a different programming language that needs
    to interoperate. Another approach is to compile native images and split them into
    separate containers and use standard protocols such as REST to interact.
  prefs: []
  type: TYPE_NORMAL
- en: These containers can be deployed in the cloud using various orchestrators, such
    as Docker Swarm, Kubernetes (including Azure Kubernetes Service, AWS Elastic Kubernetes
    Service, and Google Kubernetes Engine), AWS Fargate, and Red Hat OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how GraalVM can be used as a common runtime in microservices architecture
    with the help of a case study.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – online book library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how to implement microservices on GraalVM using various modern
    microservices frameworks, let's go through a very simple case study. Later in
    the chapter, we will pick one of the services from this architecture and build
    it using different frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: This case study involves building a simple website that shows a catalog of books.
    The catalog lists all the books. You can search and browse the books by specific
    keywords and should be able to select and obtain more details relating to the
    book. The user can then select and save it as a wishlist in a library of books.
    In the future, this can be extended to place an order for this book. But to keep
    it simple, let's assume that we're searching, browsing, and creating personal
    libraries in **MVP** (**Minimum Viable Product**) scope. Let's also have a section
    in the catalog where the user can see a book prediction based on what is in their
    library. This will help us to do a polyglot with some machine learning code, too.
  prefs: []
  type: TYPE_NORMAL
- en: Functional architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the thought process of building this application. We will
    first start by decomposing the functionality. For this, we will require the following
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Catalogue UI Service**: This web page is the home page where the user lands
    after successfully logging in (we will not be implementing the login, authentication,
    and authorization in MVP). This web page presents a way to search and view the
    books. This will be implemented as a micro-frontend (refer to [https://micro-frontends.org/](https://micro-frontends.org/)
    for more details on micro-frontends). We will have three UI components as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'i. **Book List UI component**: This component shows a list of all the books.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ii. **Book Details UI component**: This component shows all the details pertaining
    to the selected book.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'iii. **Predicted Books UI component**: This component shows the books that
    are predicted, based on the books in the library.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Library UI Service**: This lists the books in your personal library and allows
    the user to add or delete books from this library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to support these UI services, we will require microservices that store,
    fetch, and search the books. The following are the services that we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Catalogue Service**: These services provide the RESTful APIs to browse, search,
    and view the book details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prediction Service**: To demonstrate the polyglot feature of GraalVM, let''s
    assume that we already have machine learning code that we have developed using
    Python, and that can predict the book, based on the books that are available in
    the library. We will embed this Python code in this Java microservice to demonstrate
    how GraalVM can help us to build optimized embedding polyglot applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library Service**: This service will provide all the restful APIs for accessing
    books in the library, as well as for adding and deleting them from the library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Book Info Service**: Let''s decide to use the Google Books API ([https://developers.google.com/books](https://developers.google.com/books))
    to get all the details about the books. We will need a service that proxies the
    Google Books API. This will help us to manage the data that is coming from the
    Google Books API. This also provides a proxy layer, so that we can always switch
    to a different Book API service without changing the whole application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will need storage to store the information about the books that have
    been added to the personal libraries and to cache the data about the books, for
    faster fetching (instead of calling the Google Books API every time). To do so,
    we will require the following data services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Profile Data**: This stores the user profiles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Library Data**: This stores the books that the particular user has selected
    for their library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Book Cache Data**: We will need to cache the book information so that we
    don''t have to call the Google Books API for information that we have already
    fetched. This will not only improve performance; it will also reduce costs as
    the Google Books API may charge you for the number of calls made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how these components work together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Book library application – functional architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Book library application – functional architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'We have taken various architectural decisions while building the final architecture.
    Let''s quickly review them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro-frontends**: We decided to make the UI components micro-frontends so
    that it''s easier for us to manage and reuse the UI code. As we can see, both
    the catalog UI and library UI reuse the same components to render the list of
    books and show the book details. We are choosing ReactJS as this provides a very
    sound framework for micro-frontend implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedding Python**: We decided to reuse the Python code already built for
    prediction. We decided to embed that as part of our catalog service to provide
    an endpoint that will provide a list of predicted books. This will also help us
    to demonstrate the capabilities of polyglot. We will use the pure Java implementation
    of microservices, as most modern microservices frameworks do not support polyglot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless**: We decided to render the book info service *serverless* as
    it does not need to keep the state; it just calls the Google Books API and passes
    the information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Book information cache**: We decided to use Redis to store the book information
    cache so that we don''t have to go back to the Google Books API each time, thereby
    improving performance and reducing the cost of calling Google APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look at what the deployment architecture will look like on Kubernetes.
    Please refer to [https://kubernetes.io/](https://kubernetes.io/) for more details
    on how Kubernetes orchestrates the containers and provides a scalable and highly
    available solution. The following section assumes that you have a good understanding
    of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The containers are deployed on the Kubernetes cluster. The following diagram
    shows the deployment architecture of these containers in Kubernetes. This can
    be similar in any cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Kubernetes deployment architecture for the book library application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Kubernetes deployment architecture for the book library application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the terms used in the preceding diagram in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`8080`, and the target port pointing to the cluster IP of the Catalogue UI
    page, which is the home page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reactjs` implementation of the home page and the library page, which internally
    use the same set of `reactjs` components. This calls Library Service to get the
    information regarding the books stored in the personal library. This service also
    calls Catalog Service, which has all the REST endpoints to search and  browse
    the book''s details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LibraryService deployment**: Library Service is implemented in Quarkus as
    a native image and provides the endpoints for accessing personal library information.
    This uses Library Data Service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LibraryDataService deployment**: Library Data Service is a PostgreSQL container
    that stores all the user profile and personal library information. It also uses
    a persistent volume so that when a node goes down, the information is stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogueInfoService` in Quarkus native mode. This service provides the endpoints
    to search, browse, and get various details relating to the book. `BookInfoService`
    is used to get all the information pertaining to the book. `CatalogueInfoService`
    also uses the `BookInfoCache` service to fetch data that is already in cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BookInfoService deployment**: This deployment has a serverless implementation
    service that fetches various book information from the Google Books API. This
    will be implemented using the fn project serverless framework running on GraalVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BookInfoCacheService deployment**: This deployment is a Redis cache that
    caches all the book information, so as to avoid redundant calls to the Google
    Books API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final finished source code can be found in the Git repository. We will not
    be discussing the source code, but simply to gain a good understanding of how
    to build these microservices, we will pick `BookInfoService` and implement it
    with various microservices frameworks in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring modern microservices frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are modern frameworks that are built around creating microservices rapidly.
    These frameworks are built on the basis of the **Container-First** and **Cloud-First**
    design principles. They are built from the ground up, with a fast boot time and
    a low memory footprint. Helidon, Micronaut, and Quarkus are three of the most
    widely used modern Java frameworks. All three frameworks run natively on GraalVM.
    Each of these frameworks promises faster startup and a low memory footprint, and
    they achieve this by means of different methods. Let's explore these frameworks
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To understand these frameworks, let's now get hands-on in building a simple
    book information service. It is a simple service that accepts a keyword, uses
    the Google Books API to retrieve the book information, and returns detailed information
    relating to all the books that match the keyword. The response is returned as
    **JSON** (**JavaScript Object Notation** – refer to [https://www.json.org/json-en.html](https://www.json.org/json-en.html)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: Let's first start with a traditional microservice that we build using Spring
    Boot without GraalVM
  prefs: []
  type: TYPE_NORMAL
- en: Building BookInfoService using Spring without GraalVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring is one of the most widely used Java microservices frameworks. It comes
    with a lot of great features and is one of the popular frameworks used to build
    cloud-native applications. In this section, we will build in the traditional way
    without GraalVM, so as to understand the shortcomings of the traditional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Spring boilerplate code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the Spring boilerplate code, let''s go to [https://start.spring.io/](https://start.spring.io/)
    on a browser. This website helps us to specify some configurations and generate
    the boilerplate code. Let''s generate the boilerplate code for our `BookInfoService`.
    The following screenshot shows the Spring initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Spring Initializr screenshot that generates boilerplate code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Spring Initializr screenshot that generates boilerplate code
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the configurations selected to generate the boilerplate.
    To keep it simple and focused, we are selecting `HttpClient` to call the Google
    APIs so as to keep it simple for ou, instead of the recommended way of using jsonb
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to extract the ZIP file that is generated and then implement the service.
    The following is the core logic code snippet. The full code is available in the
    Git repository at [https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM](https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are setting the path as `/book-info` in order to
    call `BookInfoService`. In the following code, we will call the Google API to
    get the book information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are calling the Google Books API using our Google
    API key. You have to get your own key and include it in the URL. Refer to [https://cloud.google.com/apis/docs/overview](https://cloud.google.com/apis/docs/overview)
    for more details on how to get your own Google API. We are calling the Google
    Books API using `HttpClient` and passing the response to the requester.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build this code and run it. We will be using Maven to build it.
    The following command will build the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download all the dependencies, build the application, and generate
    a JAR file. You will find the JAR file under the target folder. We should be able
    to run the JAR file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the Spring Boot application. The following screenshot shows
    the output of running the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Output screenshot of the Spring BookInfoService application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Output screenshot of the Spring BookInfoService application
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s access this application using a REST client. In this case, we are
    using `CocoaRestClient` ([https://mmattozzi.github.io/cocoa-rest-client/](https://mmattozzi.github.io/cocoa-rest-client/)).
    You can use any REST client or even use the browser to invoke the service. Let''s
    invoke http://localhost:8080/book-info?query=graalvm. The following screenshot
    shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Output of invoking the BookInformationService Spring application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Output of invoking the BookInformationService Spring application
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know that the application is running, let''s package this application
    into a Docker container and build the image. The following is the Dockerfile code
    for building the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple Dockerfile. We are building the image using `openjdk11`
    as the base. We are then copying the jar file that we generated and specifying
    the entry point to run the jar file when we start the container. Let''s now build
    the Docker image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Please feel free to use your name tag for the Docker image. These Docker images
    are also available on the author''s Docker Hub at [https://hub.docker.com/u/abvijaykumar](https://hub.docker.com/u/abvijaykumar).
    This will build an image. We should be able to see whether the image has been
    created by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Console output of running the BookInformationService Spring
    application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Console output of running the BookInformationService Spring application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that it booted up in 2.107 seconds. We should be able to call the
    service. The following screenshot shows the output after calling `http://localhost:8080/book-info?query=graalvm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Result of invoking the BookInformationService Spring application
    in a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Result of invoking the BookInformationService Spring application
    in a container
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use the modern frameworks to build the same service to understand
    and compare how these modern frameworks perform better with GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Building BookInfoService with Micronaut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micronaut is a full-stack microservices framework introduced by the developers
    of the Grails framework. It has an integration with all the ecosystem and tools
    and relies on compile-time integration, rather than runtime integration. This
    makes the final applications run faster, as they are compiled with all the dependencies
    during build time. It achieves this with annotation and aspect-oriented programming
    concepts of code injection at build time. This was introduced in 2018\. For more
    details on Micronaut, please refer to [https://micronaut.io/](https://micronaut.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build `BookInfoService` with Micronaut. To get started, we need to install
    the Micronaut command line. Refer to [https://micronaut.io/download/](https://micronaut.io/download/)
    for detailed instructions on installing the Micronaut CLI. Once installed, we
    should be able to call the `mn` command. Let''s now create our `BookInfoService`
    Micronaut boilerplate code with `mn`. The following command creates the boilerplate
    code. We are passing the `-b=maven` flag to create the Maven build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see a directory created called `bookinfoservice` where all the generated
    boilerplate code is created. Let''s now set the environment to point to GraalVM.
    To validate whether we are using the right version of GraalVM, we can check by
    running `java-version`. The following output shows the version of GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now update the Micronaut code to implement our logic. The following
    code snippet shows the code for `Controller`, which exposes the REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BookInfoService` class has the exact same code as what we implemented
    in Spring Boot in the preceding code. Let''s now compile the Micronaut project
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the Micronaut application by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output when we run the Micronaut application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Console output of running the Micronaut BookInformationService
    Spring application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Console output of running the Micronaut BookInformationService
    Spring application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that it took just 500 milliseconds to load the Micronaut application,
    as compared to Spring Boot in the *Building BookInfoService using Spring without
    GraalVM* section, which took around 2 seconds. This is significantly fast, considering
    how simple and small our application is. Let''s now build a Docker image of this
    application. Micronaut provides a direct way to build a Docker image with Maven
    by passing the `-Dpackaging=docker` argument. The following command will generate
    the Docker image directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Micronaut can also generate the Dockerfile so that we can customize and execute
    separately. The Dockerfiles are created under the target directory when we pass
    the `-mn:dockerfile` argument to the command. The following is the Dockerfile
    that is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the Docker image is built on `openjdk`. We are still not using
    the GraalVM native image feature. Let''s build this image by calling the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's now run this Docker image by calling the following command:=
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the output of running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the application started in 1.5 seconds, which is still faster
    than the Spring image. We are still not using the GraalVM native image feature.
    Let''s now build the same application as a GraalVM native image. To build a native
    image, Micronaut supports a Maven profile, which can be invoked by passing the
    `-Dpackaging=native-image` argument to the command. The following command creates
    the native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now generate the Dockerfile to understand how this image is created.
    To generate the Dockerfile, we need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the Dockerfile under the target directory. The following
    code shows the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this is a multi-phase Dockerfile. In the first phase, we are
    installing the native image, copying all the required application files into the
    image, and finally running the `native-image` command to create the native image.
    In the second phase, we are copying the native image and providing an entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this image and see how fast it loads. Let''s execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that it took just 551 milliseconds for the image
    to load, which is almost half the time it took for the non-GraalVM Micronaut application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see how easy it is to create a microservice with Micronaut, and how it
    seamlessly integrates with the GraalVM toolchain to generate Docker images with
    a very small footprint and fast loading.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is another very popular microservices framework. Let's now explore Quarkus
    and build the same service using Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: Building BookInfoService with Quarkus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus was developed by Red Hat and provides the most sophisticated list of
    integration with the Java ecosystem of frameworks. It is built on top of the MicroProfile,
    Vert.x, Netty, and Hibernate standards. It is built as a fully Kubernetes-native
    framework. This was introduced in 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build `BookInfoService` using Quarkus. Quarkus provides a starter
    code generator at [http://code.quarkus.io](http://code.quarkus.io). Let''s go
    to that website and generate our code. The following screenshot shows the configurations
    that are selected to generate our `BookInfoService` boilerplate code. We are also
    including RESTEasy JAX-RS to create our endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate code in a zip file (we can also provide a Git repository,
    where Quarkus will automatically push the code). Let''s now download the zip file
    and then extract and compile it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The best part about Quarkus is that when we execute this command, it provides
    a way for us to edit the code and test it without restarting the server. This
    helps in building the application rapidly. Now, let's update the Quarkus code
    to our `BookInfoService` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows implementation of the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'While we update the code and save it, Quarkus automatically updates the runtime.
    We don''t have to restart the server. The following screenshot shows the output
    of calling our `bookservice` that is running with Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Result of invoking the Quarkus implementation of the'
  prefs: []
  type: TYPE_NORMAL
- en: BookInformationService application
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Result of invoking the Quarkus implementation of the BookInformationService
    application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build a GraalVM native image using Quarkus. To do that, we need
    to edit the `pom.xml` file and make sure we have the following profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Quarkus uses Mandrel, which is a downstream distribution of GraalVM. You can
    read more about Mandrel at [https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/](https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build the native image. Quarkus provides a direct Maven profile
    to build native images. We can create a native image by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the native build under the target folder. Let''s run the native
    build directly. The following shows the output after running the native image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can see that it took just `0.015s` to start the application. This is significantly
    faster than the traditional implementations, which took around 2 seconds to start
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus also created various Dockerfile versions, and we can find these under
    the Docker folder. The following screenshot shows the list of Dockerfiles that
    Quarkus automatically creates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus
    creates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus creates
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly explore these various types of Dockerfiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile.legacy-jar** and **Dockerfile.jvm**: This Dockerfile has the commands
    to build a Docker image with a normal Quarkus application, JAR, and OpenJDK headless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile.native**: This Dockerfile builds the native image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile.native-distroless**: This Docker file also generates an image
    with a native image, but uses the new technique introduced by Google to build
    the image that contains just the application, language runtime, and no operating
    system distribution. This helps in creating a small image, and has fewer vulnerabilities.
    Refer to [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)
    for more details on distroless containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create Docker images of these various Docker versions by executing the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare the sizes of these images, lets run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following chart compares the sizes of each of these images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Chart comparing the size of Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.14_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – Chart comparing the size of Docker images
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the smallest footprint and the fastest executing
    GraalVM microservice image is built using a Quarkus native distroless image. Spring
    has also launched Spring Native ([https://spring.io/blog/2021/03/11/announcing-spring-native-beta](https://spring.io/blog/2021/03/11/announcing-spring-native-beta))
    and Oracle has Helidon ([https://helidon.io/#/](https://helidon.io/#/)), which
    provide similar frameworks to run on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Building a serverless BookInfoService using fn project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function-as-a-Service, or serverless, is another architectural pattern for running
    code on demand and utilizes cloud resources. The serverless approach runs the
    code when a request is received. The code boots up, executes, handles the requests,
    and then shuts down, thereby utilizing cloud resources to the optimum. This provides
    a highly available, scalable architecture at optimum cost. However, serverless
    architecture demands a faster boot, quicker execution, and shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM native images (ahead of time) is the best option for serverless, as
    native images start up and run faster than traditional Java applications. GraalVM
    native images have a very small footprint, they are fast to boot, and they come
    with embedded VM (Substrate VM).
  prefs: []
  type: TYPE_NORMAL
- en: fn project is also a great environment for building serverless applications.
    Fn supports the building of serverless applications in Go, Java, JavaScript, Python,
    Ruby, and C#. It is a very simple and rapid application development environment
    that comes with an fn daemon and a CLI that provides most of the scaffolding to
    build serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let's focus on building the `BookInfoService` function using
    fn project. Please refer to [https://fnproject.io/](https://fnproject.io/) for
    detailed instructions on installing the `fn` command-line interface. We first
    have to start the fn daemon server using `fn start`. The fn server runs in Docker,
    and you can check that by running `docker ps`. The Fn daemon server runs at port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fn` command line also provides a way to generate boilerplate code. Let''s
    now generate the project by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This creates a `book-info-service-function` directory with all the boilerplate
    code. Let's inspect what is inside that directory. We will find `func.yaml`, `pom.xml`,
    and `src` directories.
  prefs: []
  type: TYPE_NORMAL
- en: '`func.yml` is the main manifest `yaml` file that has the key information about
    the class that implements the function and the entry point. Let''s inspect the
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now understand the preceding configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The name of the function. We can see the name of the function that
    we specified in our `fn init` command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: The version of this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: JVM as the runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_image`: The Docker image that should be used to build the Java code;
    in this case, we see that it''s JDK 11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run_image`: The Docker image that should be used as a runtime; in this case,
    it is JRE11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd`: This is the entry point, which is `ClassName:MethodName`. We will change
    `cmd` to point to our class and method: `cmd: com.abvijay.chapter9.fn.BookInfoService::getBookInfo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `src` folder, we will create `com.abvijay.chapter9.fn.BookInfoService`
    with the `getBookInfo()` method. The implementation of `getBookInfo()` is the
    same as other implementations we performed previously in the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the function that calls the
    Google API to get the books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now build and deploy this serverless container to the local Docker.
    Functions are grouped into applications. An application can have multiple functions.
    This helps in grouping and managing them. So we need to create a book info service
    app using the `fn create app` command. The following shows the output after executing
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the app has been created, we can deploy it using the `fn deploy` command.
    This command has to be executed at the root folder of the function app that we
    created. The following shows the output after executing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `fn deploy` command will build the code using Maven, package it as a Docker
    image, and deploy it to the local Docker runtime. fn can also be used to deploy
    to the cloud or k8s cluster directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `docker images` command to check whether our image has been
    built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `fn inspect` to get all the details about the function. This
    helps in discovering the services. The following shows the output of executing
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s invoke the service. Since our function expects an input argument
    in the number, we can pass it using an echo command and pipe the output to `fn
    invoke` to invoke our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can see the function executing and the output of the Google API (the preceding
    output is partial, to save space). Now let's run the same logic on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base image for GraalVM is different. We use `fnproject/fn-java-native-init`
    as the base, and initialize our fn project with that. The following is the output
    of generating a Graal native image-based fn project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates a Dockerfile. This is followed by the Dockerfile code, which
    you can find under the project directory (`book-info-service-function-graal`).
    This `fn` configuration works differently. It also generates a Dockerfile, with
    all the necessary Docker build commands. This is a multi-stage Docker build file.
    Let''s inspect this Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Dockerfile generated by fn'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.15_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Dockerfile generated by fn
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fnproject/fn-java-fdk-build`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/function`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 19–23**: Then, the Maven environment is configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fnproject/fn-java-native` as the base image, the GraalVM is configured and
    the fn runtime is compiled. This is a very important step as this is what makes
    our serverless runtime faster and with a smaller footprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`busybox:glibc` (which is the minimal version of Linux+glibc) base image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func.yml`, in this way of building the serverless image, has no information.
    fn will use the Dockerfile to perform the build (along with Maven) and deploy
    the image to the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to change `line` `48` to point to our class. Let''s replace that with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Another important configuration file that we need to change is `reflection.json`  under `src/main/conf`. This
    JSON file has the manifest information about the class name and the method. It
    is used by the native image builder to resolve the reflection we do by calling
    our function dynamically. Refer to the *Building native images* section in [*Chapter
    5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097), *Graal Ahead-of-Time Compiler
    and Native Image*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create an fn app and deploy this app using the `fn create app`
    command. The following is the output after executing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can build the native image and deploy it using the `fn deploy –app book-info-service-app-graal`
    command and we can execute the method by calling `echo -n 'java' | fn invoke book-info-service-app-graal
    book-info-service-function`. Checking the Docker images, we will see that the
    size of the Java image is 238 MB, and that of the GraalVM image is just 41 MB.
    That is a 10-times-smaller footprint than traditional Java applications. We can
    time the function calls, and we can see that the native images are much faster
    (up to 30%).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Serverless is the best solution, for quicker and stateless services, as it does
    not take any resources and we don't have to keep it running all the time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at various framework implementations and ways
    to optimize the image.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on reaching this point! In this chapter, we looked at how microservices
    architectures are built. To understand the architectural thought process, we picked
    a simple case study and explored how it can be deployed on Kubernetes as a collection
    of microservices. We then explored various microservices frameworks, and built
    a service on each of these frameworks, to appreciate the benefits that GraalVM
    brings to cloud-native architectures.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should have acquired a good understanding of
    how to go about building microservices-based, cloud-native applications using
    GraalVM as the runtime. This chapter gives a good head start for Java developers
    to quickly start building applications on one of the microservices frameworks
    (Quarkus, Spring, Micronaut). The source code that is provided along with this
    chapter (in Git) will also provide a good reference implementation of microservices
    on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a microservice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of a microservices architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is GraalVM an ideal application runtime for microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices architecture ([https://microservices.io/](https://microservices.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micronaut ([http://microprofile.io/](http://microprofile.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarkus ([https://quarkus.io/](https://quarkus.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot ([https://spring.io/](https://spring.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Native ([https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
