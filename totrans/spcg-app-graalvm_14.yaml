- en: '*Chapter 10*: Microservices Architecture with GraalVM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we looked at how GraalVM builds on top of Java VM and
    provides a high-performance polyglot runtime. In this chapter, we will explore
    how GraalVM can be the core runtime for running microservices. A lot of microservices
    frameworks already run on GraalVM. We will explore some of the popular frameworks
    and build a sample application with them. We will also explore a serverless framework.
    We will take a case study and look at how we can architect the solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have acquired a good understanding of how
    to package applications as containers, running GraalVM, and how to build microservices
    applications using Micronaut, Quarkus, and Spring Boot. This chapter expects you
    to have a fair understanding of the Java programming language and some exposure
    to building Java microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: An overview of GraalVM microservices architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of how GraalVM helps to build microservices architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building microservices applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A case study to help understand how to go about solutioning a microservices
    application built on GraalVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a microservice with Spring Boot, Micronaut, Quarkus, and the Fn
    Project serverless framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provides a hands-on guide for building Java microservices. This
    requires some of the software to be installed and set up. The following is a list
    of prerequisites:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code**: All the source code referred to in this chapter can be downloaded
    from the Git repository at [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter10).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraalVM**: GraalVM needs to be installed. For detailed instructions on installing
    and setting up GraalVM, refer to [https://www.graalvm.org/docs/getting-started/#install-graalvm](https://www.graalvm.org/docs/getting-started/#install-graalvm).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Boot**: Refer to [https://spring.io/guides/gs/spring-boot/](https://spring.io/guides/gs/spring-boot/)
    for more details on how to set up and use Spring Boot.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micronaut**: We will be building code using the Micronaut framework. Please
    refer to [https://micronaut.io/download/](https://micronaut.io/download/) for
    more details on how to download and set up Micronaut.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quarkus**: We will be building microservices using the Quarkus framework.
    Please refer to [https://quarkus.io/](https://quarkus.io/) for more details on
    how to set up and use Quarkus.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fn project**: We will be building a serverless application/function using
    fn project. Please refer to [https://fnproject.io/](https://fnproject.io/) for
    more details on how to download, install, and set up fn project.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3f7iT1T](https://bit.ly/3f7iT1T).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's begin!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Overview of microservices architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构概述
- en: 'Microservices are one of the most popular architectural patterns and have been
    proven to be the best architectural pattern for cloud-native application development.
    Microservices patterns help to decompose and structure applications into smaller,
    manageable, and self-contained components that expose functionality through a
    standard service interface. The following are some of the advantages of microservices
    architectural patterns:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是最受欢迎的架构模式之一，并且已被证明是云原生应用程序开发的最佳架构模式。微服务模式有助于将应用程序分解和结构化为更小、更易于管理和自包含的组件，这些组件通过标准服务接口公开功能。以下是一些微服务架构模式的优点：
- en: '**Loose coupling**: Since the application is decomposed into services that
    provide a standard interface, the application component can be independently managed,
    upgraded, and fixed without affecting the other dependent components. This helps
    in easily changing the application logic based on growing business needs and changes.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：由于应用程序被分解为提供标准接口的服务，因此应用程序组件可以独立管理、升级和修复，而不会影响其他依赖组件。这有助于根据不断增长的业务需求和变化轻松更改应用程序逻辑。'
- en: '**Manageability**: Since the components are self-contained, it is very easy
    to manage these applications. The components can be owned by smaller squads for
    development and can be deployed independently without deploying the whole application.
    This assists with rapid development and deployments using DevOps.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理性**：由于组件是自包含的，因此管理这些应用程序非常容易。组件可以由较小的团队负责开发，并且可以独立部署，而无需部署整个应用程序。这有助于使用DevOps进行快速开发和部署。'
- en: '**Scalable**: Scalability is one of the key requirements of cloud-native applications.
    Scalability in monoliths is an issue, as we have to scale the whole application,
    even though we just need to scale some part of the functionality. For example,
    during high demands, we might want to scale the ordering, shopping cart, and catalog
    services more than any other functionality of a retail portal. That is not possible
    in monoliths, but if these components are decomposed into independent microservices,
    it''s easy to scale them individually and set autoscale parameters so that they
    scale based on demand. This helps in utilizing cloud resources more effectively,
    at a lower cost.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：可扩展性是云原生应用程序的关键要求之一。在单体应用中，可扩展性是一个问题，因为即使我们只需要扩展功能的一部分，我们也必须扩展整个应用程序。例如，在需求高峰期间，我们可能希望比零售门户的其他任何功能更多地扩展订单、购物车和目录服务。在单体应用中这是不可能的，但如果将这些组件分解为独立的微服务，则可以轻松地单独扩展它们并设置自动扩展参数，以便根据需求进行扩展。这有助于更有效地利用云资源，同时降低成本。'
- en: Let's now explore how GraalVM helps to build high-performance microservices
    architectures.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在探讨GraalVM如何帮助构建高性能的微服务架构。
- en: Building microservices architecture with GraalVM
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraalVM构建微服务架构
- en: GraalVM is ideal for microservices architecture as it helps to build high-performance
    Java applications with a smaller footprint. One of the most important requirements
    for microservices architecture is a smaller footprint and faster startup. GraalVM
    is an ideal runtime for running polyglot workloads in the cloud. There are some
    cloud-native frameworks already available on the market that can build applications
    to run optimally on GraalVM, including Quarkus, Micronaut, Helidon, and Spring.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM非常适合微服务架构，因为它有助于构建具有较小内存占用和更快启动速度的高性能Java应用程序。微服务架构最重要的要求之一是较小的内存占用和更快的启动速度。GraalVM是云中运行多语言工作负载的理想运行时。市场上已经有一些云原生框架，可以构建在GraalVM上运行优化的应用程序，包括Quarkus、Micronaut、Helidon和Spring。
- en: Understanding GraalVM containers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解GraalVM容器
- en: Traditionally, applications are deployed on infrastructure that was pre-configured
    and set up for the applications to run. The infrastructure consisted of both hardware
    and a software platform that runs the applications. For example, if we have to
    run a web application, we will have to set up the operating system (such as Linux
    or Windows, for example) first. The web application server (Tomcat, WebSphere)
    and database (such as MySQL, Oracle, or DB2) are set up on a pre-defined hardware
    infrastructure, and then the applications are deployed on top of these web application
    servers. This takes a lot of time, and we may have to repeat this approach every
    time we have to set up the applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the setup time and to make the configurations much easier to manage,
    we moved to virtualizing the infrastructure by pre-packaging the application,
    along with various platform components (application servers, databases, and suchlike)
    and the operating system, into self-contained **Virtual Machines** (**VMs**).
    (These VMs are not to be confused with **Java Virtual Machine** (**JVM**). JVM
    is more of a platform for running Java applications. VMs in this context are much
    more than just an application platform.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization helped to solve a lot of configuration and deployment issues.
    It also allowed us to optimize the usage of hardware resources by running multiple
    VMs on the same machine and utilizing resources better. VMs are bulky as they
    come with their own operating system and are tough to rapidly deploy, update,
    and manage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Containerization solved this issue by bringing in another layer of virtualization.
    Most modern architectures are built on containers. Containers are units of software
    that package code and all the dependencies and environment configurations. Containers
    are lightweight, standalone executable packages that be deployed on container
    runtimes. The following diagram shows the difference between VMs and containers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – VMs versus containers'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B16878.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – VMs versus containers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM is a perfect application platform (especially when it is compiled as
    native code) to be packaged along with the application in the same container.
    GraalVM provides the smallest footprint and faster startups and execution to rapidly
    deploy and scale up the application components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows how the application can be containerized with GraalVM.
    In the previous model, each of the containers has its own VM, which has logic
    for memory management, profiling, optimization (**JIT**), and so on. What GraalVM
    provides is a common runtime along with the container runtime, and just the application
    logic is containerized. Since GraalVM also supports multiple languages and interoperability
    between these languages, the containers can be running application code that is
    written in multiple languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the various scenarios of how containers can be
    deployed with GraalVM:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – GraalVM container patterns'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B16878.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – GraalVM container patterns
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see various configurations/scenarios. Let''s
    go through the details:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Container 1**: In this container, we can see a native image running. This
    is by far the most optimal configuration with the smallest footprint and a faster
    load.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container 2**: In this container, we have a Java application and a JavaScript
    application running on Truffle with interoperability.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container 3**: Similar to container 2, we also can see a C/C++ application.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container 1 is the most optimal configuration for running cloud-native unless
    we have application code written in a different programming language that needs
    to interoperate. Another approach is to compile native images and split them into
    separate containers and use standard protocols such as REST to interact.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: These containers can be deployed in the cloud using various orchestrators, such
    as Docker Swarm, Kubernetes (including Azure Kubernetes Service, AWS Elastic Kubernetes
    Service, and Google Kubernetes Engine), AWS Fargate, and Red Hat OpenShift.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how GraalVM can be used as a common runtime in microservices architecture
    with the help of a case study.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Case study – online book library
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how to implement microservices on GraalVM using various modern
    microservices frameworks, let's go through a very simple case study. Later in
    the chapter, we will pick one of the services from this architecture and build
    it using different frameworks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: This case study involves building a simple website that shows a catalog of books.
    The catalog lists all the books. You can search and browse the books by specific
    keywords and should be able to select and obtain more details relating to the
    book. The user can then select and save it as a wishlist in a library of books.
    In the future, this can be extended to place an order for this book. But to keep
    it simple, let's assume that we're searching, browsing, and creating personal
    libraries in **MVP** (**Minimum Viable Product**) scope. Let's also have a section
    in the catalog where the user can see a book prediction based on what is in their
    library. This will help us to do a polyglot with some machine learning code, too.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Functional architecture
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the thought process of building this application. We will
    first start by decomposing the functionality. For this, we will require the following
    services:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Catalogue UI Service**: This web page is the home page where the user lands
    after successfully logging in (we will not be implementing the login, authentication,
    and authorization in MVP). This web page presents a way to search and view the
    books. This will be implemented as a micro-frontend (refer to [https://micro-frontends.org/](https://micro-frontends.org/)
    for more details on micro-frontends). We will have three UI components as follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'i. **Book List UI component**: This component shows a list of all the books.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ii. **Book Details UI component**: This component shows all the details pertaining
    to the selected book.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'iii. **Predicted Books UI component**: This component shows the books that
    are predicted, based on the books in the library.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Library UI Service**: This lists the books in your personal library and allows
    the user to add or delete books from this library.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to support these UI services, we will require microservices that store,
    fetch, and search the books. The following are the services that we will need:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Catalogue Service**: These services provide the RESTful APIs to browse, search,
    and view the book details.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prediction Service**: To demonstrate the polyglot feature of GraalVM, let''s
    assume that we already have machine learning code that we have developed using
    Python, and that can predict the book, based on the books that are available in
    the library. We will embed this Python code in this Java microservice to demonstrate
    how GraalVM can help us to build optimized embedding polyglot applications.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library Service**: This service will provide all the restful APIs for accessing
    books in the library, as well as for adding and deleting them from the library.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Book Info Service**: Let''s decide to use the Google Books API ([https://developers.google.com/books](https://developers.google.com/books))
    to get all the details about the books. We will need a service that proxies the
    Google Books API. This will help us to manage the data that is coming from the
    Google Books API. This also provides a proxy layer, so that we can always switch
    to a different Book API service without changing the whole application.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will need storage to store the information about the books that have
    been added to the personal libraries and to cache the data about the books, for
    faster fetching (instead of calling the Google Books API every time). To do so,
    we will require the following data services:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**User Profile Data**: This stores the user profiles.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Library Data**: This stores the books that the particular user has selected
    for their library.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Book Cache Data**: We will need to cache the book information so that we
    don''t have to call the Google Books API for information that we have already
    fetched. This will not only improve performance; it will also reduce costs as
    the Google Books API may charge you for the number of calls made.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how these components work together:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Book library application – functional architecture'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B16878.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Book library application – functional architecture
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We have taken various architectural decisions while building the final architecture.
    Let''s quickly review them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro-frontends**: We decided to make the UI components micro-frontends so
    that it''s easier for us to manage and reuse the UI code. As we can see, both
    the catalog UI and library UI reuse the same components to render the list of
    books and show the book details. We are choosing ReactJS as this provides a very
    sound framework for micro-frontend implementation.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedding Python**: We decided to reuse the Python code already built for
    prediction. We decided to embed that as part of our catalog service to provide
    an endpoint that will provide a list of predicted books. This will also help us
    to demonstrate the capabilities of polyglot. We will use the pure Java implementation
    of microservices, as most modern microservices frameworks do not support polyglot.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless**: We decided to render the book info service *serverless* as
    it does not need to keep the state; it just calls the Google Books API and passes
    the information.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Book information cache**: We decided to use Redis to store the book information
    cache so that we don''t have to go back to the Google Books API each time, thereby
    improving performance and reducing the cost of calling Google APIs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look at what the deployment architecture will look like on Kubernetes.
    Please refer to [https://kubernetes.io/](https://kubernetes.io/) for more details
    on how Kubernetes orchestrates the containers and provides a scalable and highly
    available solution. The following section assumes that you have a good understanding
    of Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Deployment architecture
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The containers are deployed on the Kubernetes cluster. The following diagram
    shows the deployment architecture of these containers in Kubernetes. This can
    be similar in any cloud:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Kubernetes deployment architecture for the book library application'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B16878.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Kubernetes deployment architecture for the book library application
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the terms used in the preceding diagram in more detail:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`8080`, and the target port pointing to the cluster IP of the Catalogue UI
    page, which is the home page.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reactjs` implementation of the home page and the library page, which internally
    use the same set of `reactjs` components. This calls Library Service to get the
    information regarding the books stored in the personal library. This service also
    calls Catalog Service, which has all the REST endpoints to search and  browse
    the book''s details.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LibraryService deployment**: Library Service is implemented in Quarkus as
    a native image and provides the endpoints for accessing personal library information.
    This uses Library Data Service.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LibraryDataService deployment**: Library Data Service is a PostgreSQL container
    that stores all the user profile and personal library information. It also uses
    a persistent volume so that when a node goes down, the information is stored.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogueInfoService` in Quarkus native mode. This service provides the endpoints
    to search, browse, and get various details relating to the book. `BookInfoService`
    is used to get all the information pertaining to the book. `CatalogueInfoService`
    also uses the `BookInfoCache` service to fetch data that is already in cache.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BookInfoService deployment**: This deployment has a serverless implementation
    service that fetches various book information from the Google Books API. This
    will be implemented using the fn project serverless framework running on GraalVM.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BookInfoCacheService deployment**: This deployment is a Redis cache that
    caches all the book information, so as to avoid redundant calls to the Google
    Books API.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final finished source code can be found in the Git repository. We will not
    be discussing the source code, but simply to gain a good understanding of how
    to build these microservices, we will pick `BookInfoService` and implement it
    with various microservices frameworks in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Exploring modern microservices frameworks
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are modern frameworks that are built around creating microservices rapidly.
    These frameworks are built on the basis of the **Container-First** and **Cloud-First**
    design principles. They are built from the ground up, with a fast boot time and
    a low memory footprint. Helidon, Micronaut, and Quarkus are three of the most
    widely used modern Java frameworks. All three frameworks run natively on GraalVM.
    Each of these frameworks promises faster startup and a low memory footprint, and
    they achieve this by means of different methods. Let's explore these frameworks
    in this section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To understand these frameworks, let's now get hands-on in building a simple
    book information service. It is a simple service that accepts a keyword, uses
    the Google Books API to retrieve the book information, and returns detailed information
    relating to all the books that match the keyword. The response is returned as
    **JSON** (**JavaScript Object Notation** – refer to [https://www.json.org/json-en.html](https://www.json.org/json-en.html)
    for more details).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Let's first start with a traditional microservice that we build using Spring
    Boot without GraalVM
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Building BookInfoService using Spring without GraalVM
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring is one of the most widely used Java microservices frameworks. It comes
    with a lot of great features and is one of the popular frameworks used to build
    cloud-native applications. In this section, we will build in the traditional way
    without GraalVM, so as to understand the shortcomings of the traditional approach.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Creating Spring boilerplate code
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the Spring boilerplate code, let''s go to [https://start.spring.io/](https://start.spring.io/)
    on a browser. This website helps us to specify some configurations and generate
    the boilerplate code. Let''s generate the boilerplate code for our `BookInfoService`.
    The following screenshot shows the Spring initializer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Spring Initializr screenshot that generates boilerplate code'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B16878.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Spring Initializr screenshot that generates boilerplate code
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the configurations selected to generate the boilerplate.
    To keep it simple and focused, we are selecting `HttpClient` to call the Google
    APIs so as to keep it simple for ou, instead of the recommended way of using jsonb
    and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to extract the ZIP file that is generated and then implement the service.
    The following is the core logic code snippet. The full code is available in the
    Git repository at [https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM](https://github.com/PacktPublishing/Optimizing-Application-Performance-with-GraalVM):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we are setting the path as `/book-info` in order to
    call `BookInfoService`. In the following code, we will call the Google API to
    get the book information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we are calling the Google Books API using our Google
    API key. You have to get your own key and include it in the URL. Refer to [https://cloud.google.com/apis/docs/overview](https://cloud.google.com/apis/docs/overview)
    for more details on how to get your own Google API. We are calling the Google
    Books API using `HttpClient` and passing the response to the requester.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build this code and run it. We will be using Maven to build it.
    The following command will build the code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will download all the dependencies, build the application, and generate
    a JAR file. You will find the JAR file under the target folder. We should be able
    to run the JAR file using the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will start the Spring Boot application. The following screenshot shows
    the output of running the application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Output screenshot of the Spring BookInfoService application'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B16878.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Output screenshot of the Spring BookInfoService application
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s access this application using a REST client. In this case, we are
    using `CocoaRestClient` ([https://mmattozzi.github.io/cocoa-rest-client/](https://mmattozzi.github.io/cocoa-rest-client/)).
    You can use any REST client or even use the browser to invoke the service. Let''s
    invoke http://localhost:8080/book-info?query=graalvm. The following screenshot
    shows the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Output of invoking the BookInformationService Spring application'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B16878.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Output of invoking the BookInformationService Spring application
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know that the application is running, let''s package this application
    into a Docker container and build the image. The following is the Dockerfile code
    for building the image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a very simple Dockerfile. We are building the image using `openjdk11`
    as the base. We are then copying the jar file that we generated and specifying
    the entry point to run the jar file when we start the container. Let''s now build
    the Docker image using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please feel free to use your name tag for the Docker image. These Docker images
    are also available on the author''s Docker Hub at [https://hub.docker.com/u/abvijaykumar](https://hub.docker.com/u/abvijaykumar).
    This will build an image. We should be able to see whether the image has been
    created by using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s run this image using the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows the output of running the previous command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Console output of running the BookInformationService Spring
    application'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B16878.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Console output of running the BookInformationService Spring application
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that it booted up in 2.107 seconds. We should be able to call the
    service. The following screenshot shows the output after calling `http://localhost:8080/book-info?query=graalvm`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Result of invoking the BookInformationService Spring application
    in a container'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B16878.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Result of invoking the BookInformationService Spring application
    in a container
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use the modern frameworks to build the same service to understand
    and compare how these modern frameworks perform better with GraalVM.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Building BookInfoService with Micronaut
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micronaut is a full-stack microservices framework introduced by the developers
    of the Grails framework. It has an integration with all the ecosystem and tools
    and relies on compile-time integration, rather than runtime integration. This
    makes the final applications run faster, as they are compiled with all the dependencies
    during build time. It achieves this with annotation and aspect-oriented programming
    concepts of code injection at build time. This was introduced in 2018\. For more
    details on Micronaut, please refer to [https://micronaut.io/](https://micronaut.io/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build `BookInfoService` with Micronaut. To get started, we need to install
    the Micronaut command line. Refer to [https://micronaut.io/download/](https://micronaut.io/download/)
    for detailed instructions on installing the Micronaut CLI. Once installed, we
    should be able to call the `mn` command. Let''s now create our `BookInfoService`
    Micronaut boilerplate code with `mn`. The following command creates the boilerplate
    code. We are passing the `-b=maven` flag to create the Maven build:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should see a directory created called `bookinfoservice` where all the generated
    boilerplate code is created. Let''s now set the environment to point to GraalVM.
    To validate whether we are using the right version of GraalVM, we can check by
    running `java-version`. The following output shows the version of GraalVM:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now update the Micronaut code to implement our logic. The following
    code snippet shows the code for `Controller`, which exposes the REST endpoint:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `BookInfoService` class has the exact same code as what we implemented
    in Spring Boot in the preceding code. Let''s now compile the Micronaut project
    by executing the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then run the Micronaut application by executing the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the output when we run the Micronaut application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Console output of running the Micronaut BookInformationService
    Spring application'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B16878.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Console output of running the Micronaut BookInformationService
    Spring application
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that it took just 500 milliseconds to load the Micronaut application,
    as compared to Spring Boot in the *Building BookInfoService using Spring without
    GraalVM* section, which took around 2 seconds. This is significantly fast, considering
    how simple and small our application is. Let''s now build a Docker image of this
    application. Micronaut provides a direct way to build a Docker image with Maven
    by passing the `-Dpackaging=docker` argument. The following command will generate
    the Docker image directly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Micronaut can also generate the Dockerfile so that we can customize and execute
    separately. The Dockerfiles are created under the target directory when we pass
    the `-mn:dockerfile` argument to the command. The following is the Dockerfile
    that is created:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see that the Docker image is built on `openjdk`. We are still not using
    the GraalVM native image feature. Let''s build this image by calling the following
    command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's now run this Docker image by calling the following command:=
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following shows the output of running the preceding command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see that the application started in 1.5 seconds, which is still faster
    than the Spring image. We are still not using the GraalVM native image feature.
    Let''s now build the same application as a GraalVM native image. To build a native
    image, Micronaut supports a Maven profile, which can be invoked by passing the
    `-Dpackaging=native-image` argument to the command. The following command creates
    the native image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s now generate the Dockerfile to understand how this image is created.
    To generate the Dockerfile, we need to execute the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will generate the Dockerfile under the target directory. The following
    code shows the Dockerfile:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see that this is a multi-phase Dockerfile. In the first phase, we are
    installing the native image, copying all the required application files into the
    image, and finally running the `native-image` command to create the native image.
    In the second phase, we are copying the native image and providing an entry point.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this image and see how fast it loads. Let''s execute the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following output shows that it took just 551 milliseconds for the image
    to load, which is almost half the time it took for the non-GraalVM Micronaut application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see how easy it is to create a microservice with Micronaut, and how it
    seamlessly integrates with the GraalVM toolchain to generate Docker images with
    a very small footprint and fast loading.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is another very popular microservices framework. Let's now explore Quarkus
    and build the same service using Quarkus.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Building BookInfoService with Quarkus
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus was developed by Red Hat and provides the most sophisticated list of
    integration with the Java ecosystem of frameworks. It is built on top of the MicroProfile,
    Vert.x, Netty, and Hibernate standards. It is built as a fully Kubernetes-native
    framework. This was introduced in 2019.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build `BookInfoService` using Quarkus. Quarkus provides a starter
    code generator at [http://code.quarkus.io](http://code.quarkus.io). Let''s go
    to that website and generate our code. The following screenshot shows the configurations
    that are selected to generate our `BookInfoService` boilerplate code. We are also
    including RESTEasy JAX-RS to create our endpoint:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B16878.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Screenshot of code.quarkus.io to generate boilerplate code
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate code in a zip file (we can also provide a Git repository,
    where Quarkus will automatically push the code). Let''s now download the zip file
    and then extract and compile it with the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The best part about Quarkus is that when we execute this command, it provides
    a way for us to edit the code and test it without restarting the server. This
    helps in building the application rapidly. Now, let's update the Quarkus code
    to our `BookInfoService` endpoint.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows implementation of the endpoint:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While we update the code and save it, Quarkus automatically updates the runtime.
    We don''t have to restart the server. The following screenshot shows the output
    of calling our `bookservice` that is running with Quarkus:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Result of invoking the Quarkus implementation of the'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: BookInformationService application
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B16878.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Result of invoking the Quarkus implementation of the BookInformationService
    application
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build a GraalVM native image using Quarkus. To do that, we need
    to edit the `pom.xml` file and make sure we have the following profile:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Quarkus uses Mandrel, which is a downstream distribution of GraalVM. You can
    read more about Mandrel at [https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/](https://developers.redhat.com/blog/2020/06/05/mandrel-a-community-distribution-of-graalvm-for-the-red-hat-build-of-quarkus/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build the native image. Quarkus provides a direct Maven profile
    to build native images. We can create a native image by executing the following
    command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will create the native build under the target folder. Let''s run the native
    build directly. The following shows the output after running the native image:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see that it took just `0.015s` to start the application. This is significantly
    faster than the traditional implementations, which took around 2 seconds to start
    up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus also created various Dockerfile versions, and we can find these under
    the Docker folder. The following screenshot shows the list of Dockerfiles that
    Quarkus automatically creates:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus
    creates'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B16878.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Screenshot of various versions of Dockerfiles that Quarkus creates
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly explore these various types of Dockerfiles:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile.legacy-jar** and **Dockerfile.jvm**: This Dockerfile has the commands
    to build a Docker image with a normal Quarkus application, JAR, and OpenJDK headless.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile.native**: This Dockerfile builds the native image.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile.native-distroless**: This Docker file also generates an image
    with a native image, but uses the new technique introduced by Google to build
    the image that contains just the application, language runtime, and no operating
    system distribution. This helps in creating a small image, and has fewer vulnerabilities.
    Refer to [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)
    for more details on distroless containers.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create Docker images of these various Docker versions by executing the
    following commands:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To compare the sizes of these images, lets run the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following chart compares the sizes of each of these images:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Chart comparing the size of Docker images'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.14_B16878.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – Chart comparing the size of Docker images
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the smallest footprint and the fastest executing
    GraalVM microservice image is built using a Quarkus native distroless image. Spring
    has also launched Spring Native ([https://spring.io/blog/2021/03/11/announcing-spring-native-beta](https://spring.io/blog/2021/03/11/announcing-spring-native-beta))
    and Oracle has Helidon ([https://helidon.io/#/](https://helidon.io/#/)), which
    provide similar frameworks to run on GraalVM.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Building a serverless BookInfoService using fn project
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function-as-a-Service, or serverless, is another architectural pattern for running
    code on demand and utilizes cloud resources. The serverless approach runs the
    code when a request is received. The code boots up, executes, handles the requests,
    and then shuts down, thereby utilizing cloud resources to the optimum. This provides
    a highly available, scalable architecture at optimum cost. However, serverless
    architecture demands a faster boot, quicker execution, and shutdown.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM native images (ahead of time) is the best option for serverless, as
    native images start up and run faster than traditional Java applications. GraalVM
    native images have a very small footprint, they are fast to boot, and they come
    with embedded VM (Substrate VM).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: fn project is also a great environment for building serverless applications.
    Fn supports the building of serverless applications in Go, Java, JavaScript, Python,
    Ruby, and C#. It is a very simple and rapid application development environment
    that comes with an fn daemon and a CLI that provides most of the scaffolding to
    build serverless applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let's focus on building the `BookInfoService` function using
    fn project. Please refer to [https://fnproject.io/](https://fnproject.io/) for
    detailed instructions on installing the `fn` command-line interface. We first
    have to start the fn daemon server using `fn start`. The fn server runs in Docker,
    and you can check that by running `docker ps`. The Fn daemon server runs at port
    `8080`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fn` command line also provides a way to generate boilerplate code. Let''s
    now generate the project by executing the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This creates a `book-info-service-function` directory with all the boilerplate
    code. Let's inspect what is inside that directory. We will find `func.yaml`, `pom.xml`,
    and `src` directories.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`func.yml` is the main manifest `yaml` file that has the key information about
    the class that implements the function and the entry point. Let''s inspect the
    configuration file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s now understand the preceding configuration file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The name of the function. We can see the name of the function that
    we specified in our `fn init` command line.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: The version of this function.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: JVM as the runtime.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_image`: The Docker image that should be used to build the Java code;
    in this case, we see that it''s JDK 11.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run_image`: The Docker image that should be used as a runtime; in this case,
    it is JRE11.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd`: This is the entry point, which is `ClassName:MethodName`. We will change
    `cmd` to point to our class and method: `cmd: com.abvijay.chapter9.fn.BookInfoService::getBookInfo`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `src` folder, we will create `com.abvijay.chapter9.fn.BookInfoService`
    with the `getBookInfo()` method. The implementation of `getBookInfo()` is the
    same as other implementations we performed previously in the section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the function that calls the
    Google API to get the books:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s now build and deploy this serverless container to the local Docker.
    Functions are grouped into applications. An application can have multiple functions.
    This helps in grouping and managing them. So we need to create a book info service
    app using the `fn create app` command. The following shows the output after executing
    the command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the app has been created, we can deploy it using the `fn deploy` command.
    This command has to be executed at the root folder of the function app that we
    created. The following shows the output after executing the command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `fn deploy` command will build the code using Maven, package it as a Docker
    image, and deploy it to the local Docker runtime. fn can also be used to deploy
    to the cloud or k8s cluster directly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `docker images` command to check whether our image has been
    built:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also use `fn inspect` to get all the details about the function. This
    helps in discovering the services. The following shows the output of executing
    the command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s invoke the service. Since our function expects an input argument
    in the number, we can pass it using an echo command and pipe the output to `fn
    invoke` to invoke our function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can see the function executing and the output of the Google API (the preceding
    output is partial, to save space). Now let's run the same logic on GraalVM.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The base image for GraalVM is different. We use `fnproject/fn-java-native-init`
    as the base, and initialize our fn project with that. The following is the output
    of generating a Graal native image-based fn project:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This generates a Dockerfile. This is followed by the Dockerfile code, which
    you can find under the project directory (`book-info-service-function-graal`).
    This `fn` configuration works differently. It also generates a Dockerfile, with
    all the necessary Docker build commands. This is a multi-stage Docker build file.
    Let''s inspect this Dockerfile:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Dockerfile generated by fn'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.15_B16878.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Dockerfile generated by fn
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this Dockerfile:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`fnproject/fn-java-fdk-build`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/function`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 19–23**: Then, the Maven environment is configured.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fnproject/fn-java-native` as the base image, the GraalVM is configured and
    the fn runtime is compiled. This is a very important step as this is what makes
    our serverless runtime faster and with a smaller footprint.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`busybox:glibc` (which is the minimal version of Linux+glibc) base image.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func.yml`, in this way of building the serverless image, has no information.
    fn will use the Dockerfile to perform the build (along with Maven) and deploy
    the image to the repository.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to change `line` `48` to point to our class. Let''s replace that with
    the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another important configuration file that we need to change is `reflection.json`  under `src/main/conf`. This
    JSON file has the manifest information about the class name and the method. It
    is used by the native image builder to resolve the reflection we do by calling
    our function dynamically. Refer to the *Building native images* section in [*Chapter
    5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097), *Graal Ahead-of-Time Compiler
    and Native Image*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create an fn app and deploy this app using the `fn create app`
    command. The following is the output after executing the command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can build the native image and deploy it using the `fn deploy –app book-info-service-app-graal`
    command and we can execute the method by calling `echo -n 'java' | fn invoke book-info-service-app-graal
    book-info-service-function`. Checking the Docker images, we will see that the
    size of the Java image is 238 MB, and that of the GraalVM image is just 41 MB.
    That is a 10-times-smaller footprint than traditional Java applications. We can
    time the function calls, and we can see that the native images are much faster
    (up to 30%).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Serverless is the best solution, for quicker and stateless services, as it does
    not take any resources and we don't have to keep it running all the time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at various framework implementations and ways
    to optimize the image.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on reaching this point! In this chapter, we looked at how microservices
    architectures are built. To understand the architectural thought process, we picked
    a simple case study and explored how it can be deployed on Kubernetes as a collection
    of microservices. We then explored various microservices frameworks, and built
    a service on each of these frameworks, to appreciate the benefits that GraalVM
    brings to cloud-native architectures.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should have acquired a good understanding of
    how to go about building microservices-based, cloud-native applications using
    GraalVM as the runtime. This chapter gives a good head start for Java developers
    to quickly start building applications on one of the microservices frameworks
    (Quarkus, Spring, Micronaut). The source code that is provided along with this
    chapter (in Git) will also provide a good reference implementation of microservices
    on GraalVM.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a microservice?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of a microservices architecture?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is GraalVM an ideal application runtime for microservices?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices architecture ([https://microservices.io/](https://microservices.io/))
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micronaut ([http://microprofile.io/](http://microprofile.io/))
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarkus ([https://quarkus.io/](https://quarkus.io/))
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot ([https://spring.io/](https://spring.io/))
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Native ([https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/))
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
