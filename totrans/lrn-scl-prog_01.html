<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An Introduction to Scala 2.13</h1>
                </header>
            
            <article>
                
<p class="p1">At the moment of this writing, Scala 2.13 has reached its five-year milestone and approaches the first release candidate. At this point, its feature set is unlikely to change and it is safe to take a look at the new features of the update.</p>
<p class="p1">In this chapter, we will talk about the scope of the release, placing the main focus of the conversation on its centerpiece—the new collection library.</p>
<p>The following topics will be discussed in this chapter:</p>
<ul>
<li>Introduction to Scala 2.13</li>
<li>New features of Scala 2.13</li>
<li>The Scala 2.13 collection library</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>JDK 1.8+</li>
<li>SBT 1.2+</li>
</ul>
<p>The source code for this chapter is available under<span> <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter01">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter01</a>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to Scala 2.13</h1>
                </header>
            
            <article>
                
<p>Scala 2.13 is the latest minor update of the Scala programming language. Despite looking like a minor bump in the version number, this release is much more important than it might appear. </p>
<p>The reason for this is that its main focus is the reworked collection library, which is going to replace the current version introduced in version 2.8 and slightly redesigned in version 2.9.</p>
<p>The new collection framework is here to stay in Scala 2 and also will become a part of Scala 3.</p>
<p class="p1">As it is mostly a library release, the language itself is not changing a lot as compared to the previous version. Apart from the collections, the new version improves on three aspects:</p>
<ul>
<li>Minimizes the core library</li>
<li>Speeds up the compiler</li>
<li>Improves user-friendliness</li>
</ul>
<p>These details are outside of the scope of this book and we will not discuss them further. </p>
<p>Besides that, there is an addition of <span>literal and singleton types, which we will discuss in detail in <a href="c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml"/></span><span><a href="c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml">Chapter 2</a>, <em>Understanding Types in Scala</em></span>, <span>and a </span>few minor changes to the standard library which we'll look at next, before diving into the sea of maps and lists.</p>
<p>Eager to look into the future? We'll take you there!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">New features of Scala 2.13</h1>
                </header>
            
            <article>
                
<p>In this section, we will discuss a few small improvements in the new version, which are not related to the collections topic and don't really belong to some bigger topic, such as optional parsing for string literals, adding names-reporting functions to case classes, methods for chaining operations, and automatic resource-management.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Optional parsing for string literals</h1>
                </header>
            
            <article>
                
<p>In Scala 2.13, <kbd>StringOps</kbd> has been extended with methods that return <kbd>Option</kbd> for string-literals parsing. Supported types include all numeric types and <kbd>Boolean</kbd>.</p>
<p>The new methods can greatly simplify the processing of user-provided data without the need to wrap the calls with the exception-handling, as shown in the following example:</p>
<pre>scala&gt; "10".toIntOption<br/>res3: Option[Int] = Some(10)<br/>scala&gt; "TrUe".toBooleanOption<br/>res4: Option[Boolean] = Some(true)<br/>scala&gt; val bool = "Not True"<br/>bool: String = Not True<br/>scala&gt; bool.toBooleanOption<br/>res5: Option[Boolean] = None</pre>
<p>The optional <kbd>Boolean</kbd> parsing ignores the case of the argument the same way the exception-throwing <kbd>toBoolean</kbd> method does.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Products can report the names of their element</h1>
                </header>
            
            <article>
                
<p>This feature <span>probably </span>will be mostly useful for the case classes as it makes possible some generic programming without the need to resort to reflection or macros. </p>
<p>The following examples demonstrate how the new <kbd>productElementName(idx)</kbd> method can be used to build a naive JSON serializer for simple case classes:</p>
<pre><span>case class </span>User(name: <span>String</span><span>, </span>surname: <span>String</span><span>, </span>email: <span>String</span>)<br/><br/>def naiveToJsonString(p: Product): String =<br/>  (for { i &lt;- 0 until p.productArity } yield<br/>    s""""${p.productElementName(i)}": "${p.productElement(i)}"""")<br/>    .mkString("{ ", ", ", " }")</pre>
<p>Obviously, this simple iteration does not take nesting and escaping into account, but it already can produce valid results in elementary cases:</p>
<pre>scala&gt; val user = User("John", "Doe", "jd@mail.me")<br/>user: User = User(John,Doe,jd@mail.me)<br/>scala&gt; naiveToJsonString(user)<br/>res1: String = { "name": "John", "surname": "Doe", "email": "jd@mail.me" }</pre>
<p>Unfortunately, the method taking an index of the element throws an exception in the case that the index is invalid:</p>
<pre>scala&gt; user.productElementName(3)<br/>java.lang.IndexOutOfBoundsException: 3<br/> at User.productElementName(&lt;console&gt;:1)<br/> ... 38 elided</pre>
<p>We will discuss why throwing exceptions is not the best approach, as well as viable alternatives, in <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a>, <em>Exploring Built-In Effects.</em></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Added methods for chaining operations</h1>
                </header>
            
            <article>
                
<p><span>Via <kbd>import scala.util.chaining._</kbd>, it is now possible to add <kbd>tap</kbd> and <kbd>pipe</kbd> methods to instances of any type. The functionality is provided by an implicit conversion to <kbd>ChainingOps</kbd>. We will look at implicits in detail in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml">Chapter 4</a>, <em>Getting to Know Implicits and Type Classes</em>.</span></p>
<p><span>The <kbd>pipe</kbd> method applies a given function to the value and returns the result. It might be helpful in situations where it is desirable to convert nested function calls into the fluid-interface-like code. The following snippet shows an example of an imaginary user database with nested function calls chained via <kbd>pipe</kbd>.</span></p>
<p><span>Consider the following the database interface:<br/></span></p>
<pre><span>object </span>UserDb {<br/>  <span>def </span><span>getById</span>(id: <span>Long</span>): User = <span>???<br/></span><span>  </span><span>def </span><span>update</span>(u: User): User = <span>???<br/></span><span>  </span><span>def </span><span>save</span>(u: User): <span>Boolean </span>= <span>???<br/></span>}</pre>
<p>We could apply all three actions to the user at once:</p>
<pre><span>import </span>UserDb._<br/><span>val </span><span>userId </span>= <span>1L<br/></span><span>save</span>(<span>update</span>(<span>getById</span>(<span>userId</span>)))</pre>
<p><kbd>pipe</kbd> allows us to represent this in a more readable format:</p>
<pre><span>getById</span>(<span>userId</span>).pipe(<span>update</span>).pipe(<span>save</span>)</pre>
<p>Arguably the same (or an even clearer) result could be achieved by combining functions before applying them:</p>
<pre><span>val </span><span>doEverything </span>= (<span>getById </span>_).andThen(<span>update</span>).andThen(<span>save</span>)<br/>doEverything(userId)</pre>
<p>We will look at functions in general, and <span>function composition in particular, </span>in <a href="9f67be8e-4fee-4050-ab96-8444bb795138.xhtml">Chapter 3</a>, <em>Deep Dive into Functions</em>.</p>
<p><kbd>tap</kbd> applies a function given as an argument solely for the side-effects it produces and returns the original value. It might be useful, for example, for logging purposes and the simplest kind of performance measurements.</p>
<p>The next snippet demonstrates an elementary side-effect-causing performance-tracking implementation that utilizes a global variable:</p>
<pre>scala&gt; import scala.util.chaining._<br/>import scala.util.chaining._<br/>scala&gt; val lastTick = new java.util.concurrent.atomic.AtomicLong(0)<br/>lastTick: java.util.concurrent.atomic.AtomicLong = 0<br/>scala&gt; def measure[A](a: A): Unit = {<br/>     | val now = System.currentTimeMillis()<br/>     | val before = lastTick.getAndSet(now)<br/>     | println(s"$a: ${now-before} ms elapsed")<br/>     | }<br/>measure: [A](a: A)Unit<br/>scala&gt; def start(): Unit = lastTick.set(System.currentTimeMillis())<br/>start: ()Unit<br/>scala&gt; start()<br/>scala&gt; val result = scala.io.StdIn.readLine().pipe(_.toIntOption).tap(measure)<br/>None: 291 ms elapsed<br/>result: Option[Int] = None<br/>scala&gt; val anotherResult = scala.io.StdIn.readLine().pipe(_.toIntOption).tap(measure)<br/>Some(3456): 11356 ms elapsed<br/>anotherResult: Option[Int] = Some(3456)</pre>
<p>Here, we defined a global value of the <kbd>AtomicLong</kbd> type to store the last<span> measured </span>timestamp. Then we define a polymorphic <kbd>measure</kbd> method that captures the time between the moment of <span>the last measurement</span> and now, and a <kbd>start</kbd> method to reset the clock. After that, we can use the <kbd>tap</kbd> method to track the execution times of our actions.</p>
<p>We will talk about types and polymorphism in <a href="c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml">Chapter 2</a>, <em>Understanding Types in Scala</em>, side-effects and more general concept of effects in <a href="d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml">Chapter 8</a>, <em>Dealing with Effects</em>, and show drawbacks of having global variables and a global state in <a href="e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml">Chapter 9</a><span>, </span><em>Familiarizing Yourself with Basic Monads</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Automatic Resource Management</h1>
                </header>
            
            <article>
                
<p>Scala 2.13 adds a practical way to automatically manage resources. We will discuss other ways to manage resources and implement dependency-injection in <a href="e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml">Chapter 9</a><span>, </span><em>Familiarizing Yourself with Basic Monads</em> and 10. <span><kbd>scala.util.Using</kbd> allows us to do this in a familiar side-effecting way. All operations on the resource are wrapped in a <kbd>Try</kbd>, which we'll talk about in <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a>, <em>Exploring Built-In Effects</em>. If <kbd>Exceptions</kbd> is thrown, the first one is returned within a <kbd>Try</kbd>. The exception-handling is quite sophisticated in some corner cases and we invite the reader to consult ScalaDoc for a detailed description of it. </span></p>
<p><kbd>Using</kbd> is a class that takes some resources as a by-name parameter. The resource can be anything that has a type class instance for <kbd>scala.util.Resource</kbd> available. Such an instance for <kbd>java.lang.AutoCloseable</kbd> is provided in the standard library. We will study type classes in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml">Chapter 4</a>, <em>Getting to Know Implicits and Type Classes</em>. <kbd>Using</kbd> also has a monadic interface, which allows us to combine multiple resources in for-comprehensions. We'll discuss monads in <a href="e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml">Chapter 9</a>, <em>Familiarizing Yourself with Basic Monads</em>.</p>
<p>Here is an example of the practical application of <kbd>Using</kbd>. We will define a resource that implements <kbd>AutoCloseable</kbd> and a few of these resources in for-comprehension as a source of the data:</p>
<pre>scala&gt; import scala.util.{Try, Using}<br/>import scala.util.{Try, Using}<br/>scala&gt; final case class Resource(name: String) extends AutoCloseable {<br/> | override def close(): Unit = println(s"Closing $name")<br/> | def lines = List(s"$name line 1", s"$name line 2")<br/> | }<br/>defined class Resource<br/>scala&gt; val List(r1, r2, r3) = List("first", "2", "3").map(Resource)<br/>r1: Resource = Resource(first)<br/>r2: Resource = Resource(2)<br/>r3: Resource = Resource(3)<br/><br/>scala&gt; val lines: Try[Seq[String]] = for {<br/>     | u1 &lt;- Using(r1)<br/>     | u2 &lt;- Using(r2)<br/>     | u3 &lt;- Using(r3)<br/>     | } yield {<br/>     | u1.lines ++ u2.lines ++ u3.lines<br/>     | }<br/>Closing 3<br/>Closing 2<br/>Closing first<br/>lines: scala.util.Try[Seq[String]] = Success(List(first line 1, first line 2, 2 line 1, 2 line 2, 3 line 1, 3 line 2))</pre>
<p>The output in the console demonstrates that the result contains lines from all of the resources, and the resources themselves are automatically closed in the reverse order.</p>
<p>Now, after this small warm-up, we are ready to dive into the foundation of version 2.13<span>—</span>the new collection library.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Scala 2.13 Collection Library</h1>
                </header>
            
            <article>
                
<p>Scala 2.13 delivers a new collection library, <span>for historical reasons it is </span>also known as "collection - strawman". The refactoring of the library pursued a few main goals, such as fixing common gotchas of the previous version, simplifying its implementation and internal structure, as well as usage and backward-compatibility, achieving better integration with lazy collections and java streams and cleaner API separation between mutable and immutable collections, improving performance, and, last but not least, minimizing the migration effort from Scala 2.12's collections. </p>
<p>As a result, we have a library that is mostly source-compatible with the previous version, has many old methods and types (such as <kbd>Traversable</kbd>, <kbd>TraversableOnce</kbd>, and <kbd>Stream</kbd>) deprecated, and has a simpler internal hierarchy.</p>
<p>This book assumes that the reader has <span><span>a rudimentary</span></span> understanding of Scala collections. With this assumption, the next section will take a holistic approach and focus on giving a consistent overview of the new collection framework. </p>
<p class="CDPAlignLeft CDPAlign">The next diagram represents the top-level hierarchy of the collection library:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/47a0c9a1-6d31-418b-821d-9e270f3764fb.png" style="width:27.25em;height:17.08em;" width="392" height="246"/> </p>
<p>Here and further, we will pretend to always have <kbd>import scala.collections._</kbd> in the scope and use the following colour encoding in our diagrams:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/556be524-da3b-4ac4-b942-26d184f88e16.png" width="774" height="81"/></p>
<p>Each of the traits describes the structure, the <em>essence</em> of the collection. As the name suggests, <kbd>IterableOnce</kbd> can be iterated over only one time. <kbd>Iterable</kbd> softens this constraint so that it is possible to iterate over the collection multiple times. <kbd>Seq</kbd> adds a notion of succession to the elements of the collection, <kbd>Set</kbd> adds a constraint of the uniqueness of its elements, and <kbd>Map</kbd> changes the type of the collection from a single element, <kbd>A</kbd>, to a pair of key, <kbd>K</kbd>, and value, <kbd>V</kbd>. </p>
<p>As mentioned, in the spirit of the separation of concerns, these traits cover only the structural characteristics. The operations defined for the specific type are placed in the helper traits carrying the <kbd>Ops</kbd> suffix in the name. These traits form a hierarchical structure similar to the previous one, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1d47f2cb-69cf-454c-ba06-d4ac95462481.png" width="1209" height="221"/></p>
<p>Where the "normal" traits had only one type parameter, the type of the element, the <kbd>Ops</kbd> have three of them. In addition to the type of the element, <kbd>A</kbd>, the <kbd>C</kbd> type describes the specific <em>representation </em>type of the collection this trait is mixed into and thus to the return type of the first-order methods defined on this collection. The <kbd>CC</kbd> type refers to the representation type that can be returned by the higher-order methods, or the type constructor. We will see later in this chapter how this works in practice.</p>
<p>Because the inheritance tree is structured as it is, <kbd>IterableOps</kbd> and <kbd>IterableOnceOps</kbd> are effectively mixed into every collection implementation in the library. Three traits on the bottom just add some more methods, unique to the <span>specific collection type, and override some of the definitions for efficiency. Both <kbd>Iterable*Ops</kbd> traits define more than a hundred of methods and they are the reason the Scala collection library is very consistent and homogenous.</span></p>
<p>Because of the importance of <span><kbd>IterableOnceOps</kbd> and </span><kbd>IterableOps</kbd>, we will take a detailed look at them in the next section. After that, we will explore the unique features of the specialized collections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IterableOnceOps</h1>
                </header>
            
            <article>
                
<p><kbd>IterableOnceOps</kbd> represents a blueprint for the collections that can be traversed one or multiple times. It defines a few <span>abstract </span>methods that must be implemented by every collection and a number of concrete methods implemented in terms of an iterator available from <kbd>IterableOnce</kbd>. The concrete methods provide default, if possible, lazy, implementations and fall into one of the following categories:</p>
<ul>
<li><strong>Size operations:</strong> <kbd>isEmpty</kbd>, <kbd>nonEmpty</kbd>, <kbd>size</kbd>, <kbd>knownSize</kbd>, and <kbd><span>isTraversableAgain</span></kbd> check the collection for (non) emptiness or return its size. <span><kbd>knownSize</kbd> is an optimization that returns <kbd>-1</kbd> if the size cannot be determined without iterating over the collection. <kbd>isTraversableAgain</kbd> returns <kbd>false</kbd> for <kbd>IterableOnce</kbd></span>.</li>
<li><strong>Element tests:</strong> <kbd>forall</kbd>, <kbd>exists</kbd>, and <kbd>count</kbd> check whether all, at least one, or some number of elements satisfy the given predicate.</li>
<li><strong>String operations:</strong> <span><kbd>mkString</kbd> and <kbd>addString</kbd>. These methods with different argument sets provide a possibility to build alternative string representation.</span></li>
<li><strong>Conversions to another collections:</strong> <span><kbd>copyToArray</kbd></span>, <span><kbd>toList</kbd></span>, <span><kbd>toMap</kbd></span>, <span><kbd>to</kbd></span>, <span><kbd>toSet</kbd></span>, <span><kbd>toSeq</kbd></span>, <span><kbd>toIndexedSeq</kbd></span>, <span><kbd>toBuffer</kbd></span>, and <span><kbd>toArray</kbd>. These methods copy or convert an <kbd>Iterable</kbd> into another collection. The <kbd>to</kbd> method is special in this list because it allows us to return any type of the collection that has a <kbd>Factory</kbd> available. We will look at it in more detail soon.</span></li>
<li><strong>Fold and reduce:</strong> <kbd>foldLeft</kbd>, <kbd>foldRight</kbd>, <kbd>reduce</kbd>, <kbd>reduceLeft</kbd>, <kbd>reduceRight</kbd>, <kbd><span>reduceOption</span></kbd>, <kbd>reduceLeftOption</kbd>, and <kbd>reduceRightOption</kbd> apply a binary operation to the elements of the collection. The <kbd>reduce*Option</kbd> methods handle the case of an empty collection gracefully by returning <kbd>None</kbd>.</li>
<li><strong>Numeric combinations:</strong> <kbd>sum</kbd> and <kbd>product</kbd> calculate the sum or product of the elements if there is an implicit <span><kbd>Numeric[B]</kbd> such that <kbd>B &gt;: A</kbd> is available.</span></li>
<li><strong>Ordering combinations:</strong>  <kbd>min</kbd>, <kbd>minOption</kbd>, <kbd>max</kbd>, <kbd>maxOption</kbd>, <kbd>maxBy</kbd>, <kbd>maxByOption</kbd>, <kbd>minBy</kbd>, and <kbd>minByOption</kbd> find an element of the collection that satisfies giving predicate if there is an implicit <kbd>Ordering[B]</kbd> with <span><span><kbd>B &gt;: A</kbd> available. The <kbd>*Option</kbd> methods return <kbd>None</kbd> for an empty collection instead of throwing an exception.</span></span></li>
<li><strong>Element retrieval:</strong> <kbd>collectFirst</kbd> and <kbd>find</kbd>. Choose an element that satisfies a given condition.</li>
<li><strong>Equality:</strong> <kbd>corresponds</kbd> is an alternative way to compare collections. Satisfied if every element of this collection relates to matching element of another collection by given predicate.</li>
</ul>
<p>Abstract methods fall into one of the following categories:</p>
<ul>
<li><strong>Subcollection retrieval:</strong> <kbd>filter</kbd>, <kbd>filterNot</kbd>, <kbd>take</kbd>, <kbd>takeWhile</kbd>, <kbd>drop</kbd>, <kbd>dropWhile</kbd>, <kbd>slice</kbd>, and <kbd>span</kbd>. Take or discard elements that satisfy the given predicate or range, from the whole collection or beginning of it. </li>
<li><strong>Mapping:</strong> <kbd>map</kbd>, <kbd>flatMap</kbd>, <kbd><span>collect</span></kbd>, and <kbd><span>scanLeft</span></kbd><span>. Transforms elements of the collection by applying some function and possibly filtering the results.</span></li>
<li><strong>Zippers:</strong> <span><kbd>zipWithIndex</kbd> adds an index to all elements of the collection.</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IterableOps</h1>
                </header>
            
            <article>
                
<p><span><kbd>IterableOps</kbd> extends <kbd>IterableOnceOps</kbd> and contains methods that is impossible to implement without a possibility to iterate over the collection multiple times.</span></p>
<p><span>They fall into the following categories:</span></p>
<ul>
<li><strong>Element retrieval:</strong> <kbd>head</kbd>, <kbd>headOption</kbd>, <kbd>last</kbd>, and <kbd>lastOption</kbd> return the first or last element of the collection throwing <kbd>NoSuchElementException</kbd> or returning <kbd>None</kbd> for an empty collection.</li>
<li><strong>Size:</strong> <kbd>sizeCompare</kbd> is an optimization that allows us to efficiently compare the size of the collection with given value.</li>
<li><strong>Subcollection retrieval:</strong> <kbd>partition</kbd>, <kbd><span>partitionWith</span></kbd>, <kbd>splitAt</kbd>, <kbd>takeRight</kbd>, <kbd>dropRight</kbd>, <kbd>grouped</kbd>, <kbd>sliding</kbd>, <kbd>tail</kbd>, <kbd>init</kbd>, <kbd>groupBy</kbd>, <kbd><span>groupMap</span></kbd>, <kbd><span>groupMapReduce</span></kbd>, <kbd>tails</kbd>, and <kbd>inits</kbd>. These split the collection as defined by some predicate or index, take or drop elements from the end, group elements by some criteria or predicate possibly applying transformative function, and discard first or last elements.</li>
<li><strong>Mapping:</strong> <kbd>scanRight</kbd> produces a collection containing the cumulative results of applying the giving function starting from the end of the collection.</li>
<li><strong>Addition:</strong> <kbd>concat, ++</kbd> returns another collection containing all elements of this collection and a collection provided as an argument.</li>
<li><strong>Zippers:</strong> <kbd>zip</kbd>, <kbd>zipAll</kbd>, <kbd>unzip</kbd>, and <kbd>unzip3</kbd> combine the elements of the collection with the elements of another collection into a product, or split them into separate collections.</li>
<li><strong>Transformation:</strong> <span><kbd>transpose</kbd> transforms the collection of collections by turning rows into columns and vice versa.</span></li>
</ul>
<p>The following methods that defined the abstract in <kbd>IterableOnceOps</kbd> <span>got a concrete default implementation in</span> <kbd>IterableOps</kbd><span>:</span> <kbd>filter</kbd>, <kbd>filterNot</kbd>, <kbd>take</kbd>, <kbd>takeWhile</kbd>, <kbd>span</kbd>, <kbd>drop</kbd>, <kbd>dropWile</kbd>, <kbd>slice</kbd>, <kbd>scanLeft</kbd>, <kbd>map</kbd>, <kbd>flatMap</kbd>, <kbd>flatten</kbd>, <kbd>collect</kbd>, and <kbd>zipWithIndex</kbd><span>. </span><span><kbd>isTraversableAgain</kbd> is overriden to return <kbd>true</kbd>.</span></p>
<p>It's worth noting that <kbd>Iterable</kbd> and <kbd>IterableOnce</kbd> do not support a general-equality operation, it is defined on specific collection subtypes. Because of this, it is impossible to compare these types directly using the equality operation, as the following example suggests:</p>
<pre>scala&gt; Set(1,2,3) == Seq(1,2,3)<br/>res4: Boolean = false</pre>
<p>Also there are three special methods that deserve our additional attention because they introduce types we haven't met yet:</p>
<ul>
<li><kbd><span>def withFilter(p: A =&gt; Boolean): collection.WithFilter[A, CC]</span></kbd></li>
<li><kbd><span>def iterableFactory: IterableFactory[CC]</span></kbd></li>
<li><kbd><span>def view: View[A]</span></kbd></li>
</ul>
<p>Let's discuss them quickly before moving on to more specific collection types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">WithFilter</h1>
                </header>
            
            <article>
                
<p><kbd>WithFilter</kbd> is a <span>template class that contains the <kbd>map</kbd></span>, <span><kbd>flatMap</kbd></span>, <span><kbd>foreach</kbd></span>, and <span><kbd>withFilter</kbd> methods of <kbd>Iterable</kbd>. It allows us to specialize mapping and filtering operations for distinguished collections.</span></p>
<p>Because of its technical nature, we won't go into further details here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IterableFactory</h1>
                </header>
            
            <article>
                
<p><kbd>trait IterableFactory[+CC[_]]</kbd> is a base trait for companion objects for specific collections which provides a number of operations to create a specific collection with the type specified by the <kbd>CC</kbd> type constructor; this is sometimes called <em>target-type driven building</em> because the type of the source collection is ignored. Most of the companion objects in the collection library extend this trait, which makes it possible to use them in places where <kbd>IterableFactory</kbd> is expected. </p>
<p>As this is the main abstraction that allows to build a collection from scratch, it is useful to know which methods it supplies. All of them return <span><kbd>CC[A]</kbd>.</span> The following table contains a short summary:</p>
<table style="border-collapse: collapse;width: 100%;border-color: #a3a3a3" border="1">
<tbody>
<tr>
<td style="width: 38.0579%"><kbd>def from[A](source: IterableOnce[A])</kbd></td>
<td style="width: 46.9421%">Creates a target collection from existing <kbd>IterableOnce</kbd>.</td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def empty[A]: CC[A]</kbd></td>
<td style="width: 46.9421%">An empty collection, often defined as an object.</td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def apply[A](elems: A*): CC[A]</kbd></td>
<td style="width: 46.9421%">Creates a collection from the <kbd>elems</kbd> given as var-arg.</td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def iterate[A](start: A, len: Int)(f: A =&gt; A): CC[A]</kbd></td>
<td style="width: 46.9421%">Fills the collection with values taken from the result of the application of <kbd>f</kbd> on <kbd>start</kbd>, then on produced values and so on, <kbd>len</kbd> number of times.</td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def range[A : Integral](start: A, end: A, step: A): CC[A]</kbd></td>
<td style="width: 46.9421%"><span>Collection containing increasing integers [<kbd>start</kbd>, <kbd>end</kbd>-1] with difference between successive numbers of <kbd>step</kbd>. There is also a version of this method with default value of <kbd>step = 1</kbd>.</span></td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def fill[A](n: Int)(elem: =&gt; A): CC[A]</kbd></td>
<td style="width: 46.9421%">Fills the collection with <kbd>n</kbd> evaluations of <kbd>elem</kbd>. There are variations of this function that go up to five dimensions.</td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def tabulate[A](n: Int)(f: Int =&gt; A): CC[A]</kbd></td>
<td style="width: 46.9421%"><span>The same as <kbd>fill</kbd>, but using index as an argument for the evaluation. Similarly, there are variations of this function that go up to five dimensions.</span></td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd>def concat[A](xss: Iterable[A]*): CC[A]</kbd></td>
<td style="width: 46.9421%">Concatenates all argument collections into a single collection.</td>
</tr>
<tr>
<td style="width: 38.0579%"><kbd><span>def unfold[A, S](init: S)(f: S =&gt; Option[(A, S)]): CC[A]</span></kbd></td>
<td style="width: 46.9421%">Calls <kbd>f</kbd> to produce the element of the collection using and modifying the internal state starting with the <kbd>init</kbd> state.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Arguably, <kbd>IterableFactory</kbd> provides a lot of different possibilities to create a collection of a desired type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">View</h1>
                </header>
            
            <article>
                
<p><kbd>View</kbd> has been reimplemented in the new version of the library. Now it represents a reified <kbd>Iterator</kbd> operations.</p>
<div class="packt_infobox"><span>Reification is the process by which an abstract idea about a computer program is turned into an explicit data model or other object created in a programming language (<a href="https://en.wikipedia.org/wiki/Reification_(computer_science)">https://en.wikipedia.org/wiki/Reification_(computer_science)</a><a href="https://en.wikipedia.org/wiki/Reification_(computer_science)">).</a></span></div>
<p>This means that the <kbd>Iterator</kbd> methods are represented as a subclasses of <kbd>View</kbd> and encapsulate transformations to apply. The evaluation happens at the moment the view is converted to the strict collection type, or traversed, for example using the <kbd>foreach</kbd> method. Views don't <em>remember</em> the type of the source collection. This can be demonstrated by the following example. First, we define a generic transformation that might be strict or lazy, depending on the type of the collection given as an argument:</p>
<pre><span>def </span><span>transform</span>[<span>C </span>&lt;: <span>Iterable</span>[<span>Char</span>]](i: <span>C</span>): <span>Iterable</span>[<span>Char</span>] = i <br/>map { c =&gt; <span>print</span>(<span>s"-</span><span>$</span>c<span>-"</span>); c.toUpper } <br/>take { <span>println</span>(<span>"</span><span>\n</span><span>take"</span>);  <span>6 </span>}</pre>
<p>Next, for each transformation step, we print out its result in the console at the moment the step happens. Now we can compare lazy and strict collection behaviors:</p>
<pre><span>val </span><span>str </span>= <span>"Scala 2.13"<br/></span><span>val </span><span>view</span>: StringView = <span>StringView</span>(<span>str</span>)<br/><span>val </span><span>transformed </span>= <span>transform</span>(<span>view</span>)    // A<br/><span>val </span><span>strict </span>= <span>transform</span>(<span>str</span>.toList)   // B<br/><span>print</span>(<span>"Lazy view constructed: "</span>) <br/><span>transformed</span>.foreach(<span>print</span>) <span>// C</span><span><br/></span><span>print</span>(<span>"</span><span>\n</span><span>Lazy view forced: "</span>)<br/><span>println</span>(<span>transformed</span>.to(<span>List</span>)) <span>// D</span><span><br/></span><span>println</span>(<span>s"Strict: </span><span>$</span><span>strict</span><span>"</span>) // E</pre>
<p>This snippet produces the following output in the REPL:</p>
<pre>take<br/>-S--c--a--l--a-- --2--.--1--3-<br/>take<br/>Lazy view constructed: -S-S-c-C-a-A-l-L-a-A- - <br/>Lazy view forced: -S--c--a--l--a-- -List(S, C, A, L, A, )<br/>Strict: List(S, C, A, L, A, )</pre>
<p>In the first line, we can see that the <kbd>take</kbd> method is always evaluated strictly regardless of the underlying collection type<span>—</span>this is commented as <kbd>A</kbd> in the preceding code. The second and third lines show the strict evaluation for <kbd>List[Char]</kbd>, line <kbd>B</kbd> in the code. Lines 4 and 5 demonstrate that <kbd>View[Char]</kbd> is then evaluated twice, each time at the moment it is forced, once by calling <kbd>foreach</kbd> (line <kbd>C</kbd>) and once by converting it to the <kbd>List</kbd> (line <kbd>D</kbd>). Also interesting is that <kbd>map</kbd> is only applied to the results of the <kbd>take</kbd> method even given the fact that <kbd>map</kbd> is the first transformation step in the chain.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Set</h1>
                </header>
            
            <article>
                
<p><kbd>Set</kbd> is a base trait for collections that have a notion of uniques of the elements. It is defined as <kbd>trait Set[A] extends Iterable[A] with SetOps[A, Set, Set[A]] with Equals</kbd>. We can see that it is effectively an <kbd>Iterable</kbd> that has some additional operations defined in <kbd>SetOps</kbd> and adds a notion of equality among sets. The sub-hierarchy of <kbd>Set</kbd> is represented in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5bf8e356-9aa9-488b-8758-6a084cda8847.png" style="width:34.42em;height:16.17em;" width="530" height="249"/></p>
<p>The previously mentioned <kbd>SetOps</kbd> adds a few methods on top of <kbd>IterableOps</kbd>. These methods are shown here:</p>
<ul>
<li><strong>Element retrieval:</strong> <kbd>contains</kbd> and <kbd>apply</kbd> return <kbd>true</kbd> if this set contains a given element.</li>
<li><strong>Equality:</strong> <kbd>subsetOf</kbd> and <kbd><span>subsets</span></kbd> check whether this set is a subset of another set, or return <span>all subsets of this set, possibly with a given size.</span></li>
<li><strong>Combinations with another set:</strong> <kbd>intersect</kbd>, <kbd>&amp;</kbd>, <kbd>diff</kbd>, <kbd>&amp;~</kbd>, <kbd>concat</kbd>, <kbd>++</kbd>, <kbd>union</kbd>, and <kbd>|</kbd>. These methods compute the intersection, difference, or union of this and another set.</li>
</ul>
<p>There are few classes in the hierarchy that augment <kbd>Set</kbd> with further properties:</p>
<ul>
<li><span><strong>SortedSet</strong> extends <kbd>Set</kbd> with <kbd>SortedOps[A, +C]</kbd> and has two immutable and two mutable implementations—two <kbd>TreeSets</kbd> and two <kbd>BitSets</kbd>. <kbd>SortedOps</kbd> embodies following methods that depend on the notion of <kbd>Ordering</kbd>:</span></li>
<li><strong>Key retrieval:</strong> <kbd>firstKey</kbd> and <kbd>lastKey</kbd> return the first or last element of this <span>collection.</span></li>
<li><strong>Subcollection retrieval:</strong> <span><kbd>range</kbd></span>, <span><kbd>rangeFrom</kbd></span>, <span><kbd>rangeUntil</kbd></span>, and <span><kbd>rangeTo</kbd> create a ranged projection of this collection, satisfying given criteria.</span></li>
</ul>
<p>Because of the overloading, <kbd>SortedSet</kbd> has many overloaded methods defined twice, with and without ordering. If an operation is intended to be applied to the underlying unsorted <kbd>Set</kbd>, the type has to be coerced:</p>
<pre>scala&gt; import scala.collection.SortedSet<br/>import scala.collection.SortedSet<br/>scala&gt; val set = SortedSet(1,2,3)<br/>set: scala.collection.SortedSet[Int] = TreeSet(1, 2, 3)<br/>scala&gt; val ordered = set.map(math.abs)<br/>ordered: scala.collection.SortedSet[Int] = TreeSet(1, 2, 3)<br/>scala&gt; val unordered = set.to(Set).map(math.abs)<br/>unordered: scala.collection.immutable.Set[Int] = Set(1, 2, 3)</pre>
<p><span>Please note that direct type-ascription will not work in the case of <kbd>Set</kbd> because its definition is invariant:</span></p>
<pre>scala&gt; val set1: Set[Int] = SortedSet(1,2,3)<br/>                                     ^<br/>       error: type mismatch;<br/>        found : scala.collection.SortedSet[Int]<br/>        required: Set[Int]</pre>
<p>The invariance of <kbd>Set</kbd> is related to the fact that <kbd>Set[A]</kbd> extends a function, <kbd>A =&gt; Boolean</kbd>, that returns <kbd>true</kbd> if the set contains a given element. Thus, sets can be used in places where such one argument function is expected:</p>
<pre>scala&gt; ordered.forall(set)<br/>res3: Boolean = true</pre>
<p>There are four more specific set implementations in addition to <kbd>TreeSet</kbd> and <kbd>BitSet</kbd>:</p>
<ul>
<li><kbd>ListSet</kbd> implements immutable sets using a list-based data structure.</li>
<li>The immutable HashSet realizes immutable sets using a Compressed Hash-Array Mapped Prefix-tree (CHAMP)</li>
<li>The mutable <kbd>HashSet</kbd> and <kbd>LinkedHashSet</kbd> implement mutable sets using a hash table, storing the data unordered and ordered, respectively.</li>
</ul>
<p><span>The sets are closely related to <kbd>Map</kbd>, which represents a collection with elements represented as a pair of keys and values.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Map</h1>
                </header>
            
            <article>
                
<p><kbd>Map</kbd> is defined as <kbd>trait Map[K, +V] extends Iterable[(K, V)] with MapOps[K, V, Map, Map[K, V]] with Equals</kbd> which makes it an <kbd>Iterable</kbd> over pairs of key, <kbd>K</kbd>, and value, <kbd>V</kbd>. It also defines a notion of equality among maps. The class hierarchy for <kbd>Map</kbd> is represented on the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0fda9483-e5d1-41c5-9896-324d26c4f805.png" style="width:39.75em;height:18.25em;" width="540" height="247"/></p>
<p>There are three different <kbd>MapOps</kbd>, one general for both mutable and immutable, and one specific for each of these forms.</p>
<p><kbd>MapOps</kbd> extends <kbd>IterableOps</kbd> with the following specific operations:</p>
<ul>
<li><strong>Element retrieval:</strong> <kbd>get</kbd>, <kbd>getOrElse</kbd>, <kbd>apply</kbd>, <kbd>applyOrElse</kbd>, <kbd>default</kbd>, <kbd>contains</kbd>, and <kbd>isDefinedAt</kbd>. These methods allow us to retrieve a value or check whether a value is present by a given key, optionally returning a default value or throwing an exception if the key can't be found.</li>
<li><strong>Subcollection retrieval:</strong> <kbd>keySet</kbd>, <kbd>keys</kbd>, <kbd>values</kbd>, <kbd>keysIterator</kbd>, and <kbd>valuesIterator</kbd> allow us to get a keys or values in different forms.</li>
<li><strong>Mapping:</strong> <kbd>map</kbd>, <kbd>flatMap</kbd>, and <kbd>collect</kbd> are transforming and optionally filtering the pairs of keys and values.</li>
<li><strong>Addition:</strong> <kbd>concat</kbd> returns a new collection with elements of both maps combined.</li>
</ul>
<p><kbd>immutable.MapOps</kbd> adds the following methods on top of <kbd>MapOps</kbd>:</p>
<ul>
<li><strong>Element removal</strong>: <kbd>remove</kbd>, <kbd>removeAll</kbd>, <kbd>--</kbd> removes one or all given elements from the map returning new map.</li>
<li><strong>Element updates</strong>: <kbd>updated</kbd> and <kbd>+</kbd> update an element with the given key returning new map.</li>
<li><strong>Mapping:</strong> <kbd>transform</kbd> applies a given function to all elements, producing a new map with the returned results as values. </li>
</ul>
<p><kbd>mutable.MapOps</kbd> has a different set of methods as compared to the mutable one:</p>
<ul>
<li><strong>Element addition:</strong> <kbd>put</kbd> adds a new value or <span>updates existing one</span>.</li>
<li><span><strong>Element update:</strong> <kbd>updated</kbd></span>, <span><kbd>+</kbd></span>, and <span><kbd>getOrElseUpdate</kbd> updates a value in place.</span></li>
<li><strong>Element removal:</strong> <kbd>remove</kbd> and <kbd>clear</kbd> remove one or all elements of the map.</li>
<li><strong>Filtering:</strong> <kbd>filterInPlace</kbd> retains only mappings that satisfy the predicate.</li>
<li><strong>Mapping:</strong> <kbd>mapValuesInPlace</kbd> applies a transformation to the values of the map, storing returned results as values.</li>
</ul>
<p>The general <kbd>Map</kbd> definition has quite a few specialized subtypes, as shown in the preceding diagram. We will take a quick look at them now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SortedMap</h1>
                </header>
            
            <article>
                
<p><kbd>SortedMap</kbd> is similar to <kbd>SortedSet</kbd>. It has a two implementations, a mutable and immutable <kbd>TreeMap</kbd>, and provides a few methods defined in terms of <kbd>SortedOps</kbd> such as:</p>
<ul>
<li><strong>Subcollection retrieval:</strong> <kbd>iteratorFrom</kbd>, <kbd>keysIteratorFrom</kbd>, <kbd>valuesIteratorFrom</kbd>, and <kbd>rangeTo</kbd> give us a way to get elements of the map as an iterator.</li>
<li><strong>Element retrieval:</strong> <kbd>firstKey</kbd>, <kbd>lastKey</kbd>, <kbd>minAfter</kbd>, and <kbd>maxBefore</kbd> allow us to retrieve an element that satisfies some ordering condition.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HashMap</h1>
                </header>
            
            <article>
                
<p><kbd>HashMap</kbd> is also available in two flavors—immutable and mutable.</p>
<p>The immutable <kbd>HashMap</kbd> is implemented using a CHAMP tree. </p>
<p>The mutable <kbd>HashMap</kbd> implements mutable maps using a hashtable. A hash table stores its elements in an array. The hash code of the item is used to calculate the position in the array.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">MultiMap</h1>
                </header>
            
            <article>
                
<p><kbd>MultiMap</kbd> is a trait for mutable maps that have multiple values assigned to a key.</p>
<p>It d<span>efines the <kbd>addBinding</kbd>, <kbd>removeBinding</kbd> and <kbd>entryExists</kbd> methods, which can be used to query or manipulate entries for a key.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SeqMap</h1>
                </header>
            
            <article>
                
<p><kbd>SeqMap</kbd> is a generic abstraction for ordered immutable maps. <kbd>SeqMap</kbd> itself exists in mutable and immutable forms. These forms have few different implementations:</p>
<ul>
<li>The immutable <strong>ListMap</strong> implements immutable maps using a list-based data structure. The methods traversing <kbd>ListMap</kbd> visit its elements in the order they were inserted.</li>
<li>The mutable <strong>ListMap</strong> is a simple mutable map backed by a list. It preserves insertion order as its immutable sibling does.</li>
<li><strong>VectorMap</strong> exists only in immutable form. It is implemented using a vector/map-based data structure and preserves insertion order. It has constant lookup but slower other operations.</li>
<li><strong>LinkedHashMap</strong> is a mutable map whose implementation is based on a hashtable and preserves the insertion order if iterated over.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Seq</h1>
                </header>
            
            <article>
                
<p><kbd>Seq</kbd> is probably the most ubiquitous collection in the library. Like <kbd>Map</kbd>, it has a notion of succession of elements and the elements have indices. It is defined as <kbd>trait Seq[+A] extends Iterable[A] with PartialFunction[Int, A] with SeqOps[A, Seq, Seq[A]] with Equals</kbd>. Also similar to map, <kbd>Seq</kbd> s<span>pecifies support for the equality relation and also </span>extends <kbd>PartialFunction</kbd>, which accepts an<span> index of the </span>element as a parameter. As there are a lots of classes implementing <kbd>Seq</kbd>, we will take a gradual approach and look at them level by level. The direct children of <kbd>Seq</kbd> are shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4e4bd4e9-fc44-4f3e-85e4-a72b74f64192.png" style="width:23.42em;height:10.00em;" width="383" height="164"/></p>
<p><kbd>scala.Seq</kbd>, known from previous Scala versions, is now replaced by <kbd>scala.collection.immutable.Seq</kbd>. </p>
<p>As with other collections, <kbd>SeqOps</kbd> extend <kbd>IterableOps</kbd> by adding quite a few methods:</p>
<ul>
<li><strong>Element retrieval:</strong> <kbd>apply</kbd> retrieves an element with a given index.</li>
<li><strong>Indexing and search:</strong> <kbd>segmentLength</kbd>, <kbd>isDefinedAt</kbd>, <kbd>indexWhere</kbd>, <kbd>indexOf</kbd>, <kbd>lastIndexOf</kbd>, <kbd>lastIndexWhere</kbd>, <kbd>indexOfSlice</kbd>, <kbd>lastIndexOfSlice</kbd>, <kbd>containsSlice</kbd>, <kbd>contains</kbd>, <kbd><span>startsWith</span></kbd>, <kbd><span>endsWith</span></kbd>, <kbd>indices</kbd>, and <kbd><span>search</span></kbd>. These methods allow us to retrieve information about the presence or indexes of elements or subsequences given some predicate or element value.</li>
<li><strong>Size:</strong> <kbd>length</kbd> and <kbd>lengthCompare</kbd> provide efficient operations to retrieve the length of the collection.</li>
<li><strong>Addition:</strong> <kbd>prepend</kbd>, <kbd>+</kbd>, <kbd>appended</kbd>, <kbd>:+</kbd>, <kbd>prependAll</kbd>, <kbd>++</kbd>, <kbd>appendedAll</kbd>, <kbd>:++</kbd>, <kbd>concat</kbd>, and <kbd>union</kbd>. Can be used to append or prepend one or multiple elements to the collection.</li>
<li><strong>Filtering:</strong> <kbd>distinct</kbd> and <kbd>distinctBy</kbd> remove duplicates, possibly given some predicate.</li>
<li><strong>Reversal:</strong> <kbd>reverse</kbd> and <kbd>reverseIterator</kbd> return a new collection with elements in the reversed order.</li>
<li><strong>Sorting:</strong> <kbd>sorted</kbd>, <kbd>sortWith</kbd>, and <kbd>sortBy</kbd> sort this collection by some implicit <kbd>Ordering</kbd>, or by a given function, or both.</li>
<li><strong>Equality:</strong> <kbd>sameElements</kbd> and <kbd>corresponds</kbd> check whether this collection contains the same elements in the same order as given, using equality-checking or the provided comparison function.</li>
<li><span><strong>Subcollection retrieval:</strong> <kbd>permutations</kbd></span> and <span><kbd>combinations</kbd>. </span>These methods allow us to retrieve a subcollection(s) that satisfies given conditions.</li>
<li><strong>Updates:</strong> <kbd>diff</kbd>, <kbd>intersect</kbd>, <kbd>patch</kbd>, <kbd>updated</kbd>, and <kbd>update</kbd> <span>(mutable). Modify elements of this collection using another collection or element and returning another collection (except the last method defined on <kbd>mutable.Seq</kbd>, which update elements in place).</span></li>
</ul>
<p>Each of the <kbd>Seq</kbd> direct descendants has its own specific properties and a subtree of implementations. We'll breeze through them now. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IndexedSeq</h1>
                </header>
            
            <article>
                
<p><kbd>IndexedSeq</kbd> does not introduce new operations, at least not in its immutable incarnation, but overrides a lots of methods defined in <kbd>SeqOps</kbd> to provide more efficient implementations. There are four classes implementing it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/314b6c54-94c0-4556-ac2a-4f976b9e1c99.png" width="642" height="206"/></p>
<p>The <kbd>mutable.</kbd><strong> IndexedSeq</strong> adds the following <strong>mutation options</strong>: <kbd>mapInPlace</kbd>, <kbd>sortInPlace</kbd>, <kbd>sortInPlaceWith</kbd>, and <kbd>sortInPlaceBy</kbd>.</p>
<p>The <kbd>mutable.</kbd><strong> ArraySeq</strong> is a collection representing an <kbd>Array</kbd>. It defines an <kbd>array</kbd> method returning an underlying array, and an <span><kbd>elemTag</kbd> method that returns the tag of the element type needed to properly support different kinds of arrays as required by the JVM. Because of this requirement, it has separate implementations for all primitive types including numeric types (in addition to <kbd>ofByte</kbd>, there are implementations for all other numeric primitives, not shown on the diagram) and <kbd>Boolean</kbd>, <kbd>AnyRef</kbd> and <kbd>Unit</kbd>.</span></p>
<p>The <kbd>immutable.</kbd><strong> ArraySeq</strong> was added in the version 2.13. It is an effectively an immutable sequence that wraps an array and<span> is used to pass varargs parameters. It has the same descendants as its mutable cousin.</span></p>
<p><strong>Range</strong> is an immutable structure that contains integer values. It is defined by <kbd>start</kbd>, <kbd>end</kbd>, and a <kbd>step</kbd>. There are two additional methods available: <kbd>isInclusive</kbd>, which is <kbd>true</kbd> for <kbd>Range.Inclusive</kbd> and <kbd>false</kbd> for <kbd>Range.Exclusive</kbd>, and <kbd>by</kbd>, which creates the new range with a different <kbd>step</kbd> but the same <kbd>start</kbd> and <kbd>end</kbd>.</p>
<p><strong>Vector</strong> is an immutable structure that provides constant-time access and updates and fast append and prepend. Because of this, <kbd>Vector</kbd> is the default implementation for <kbd>IndexedSeq</kbd>, as demonstrated in the following snippet:</p>
<pre>scala&gt; IndexedSeq.fill(2)("A")<br/>res6: IndexedSeq[String] = Vector(A, A)</pre>
<p><kbd>WrappedString</kbd> is an immutable wrapper over some <kbd>String</kbd>. It extends strings with all of the operations defined in <kbd>IndexedSeqOps</kbd>. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">LinearSeq</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Linear sequences have the notion of a head and a tail. The definition looks like <kbd>trait LinearSeq[+A] extends Seq[A] with LinearSeqOps[A, LinearSeq, LinearSeq[A]]</kbd> and the class diagram is shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b71e25fd-af3f-408d-a9a1-8e115321176c.png" style="width:27.08em;height:10.33em;" width="386" height="147"/></p>
<p>There are three representatives of <kbd>LinearSeq</kbd>, all are immutable:</p>
<ul>
<li><strong>List</strong> defines three symbolic methods which provide a nice syntax for pattern-matching and building lists. <kbd>::</kbd> prepends element to the list, <kbd>:::</kbd> prepends all elements of a given list, and <kbd>reverse_:::</kbd> prepends all elements of a given list but in the reverse order.</li>
<li><strong>LazyList</strong> is a new immutable collection available since Scala 2.13. It implements a list with a <kbd>head</kbd> and a <kbd>tail</kbd>, which are not evaluated until needed. As it is superior to <kbd>Stream</kbd>, which is only lazy in the tail, <kbd>Stream</kbd> is now deprecated. <kbd>LazyList</kbd> has two additional methods, <kbd>force</kbd> which evaluates it, and <kbd>lazyAppendAll</kbd> which lazily appends a given collection to this list.</li>
<li><span><strong>Queue</strong> in this hierarchy is also immutable. It allows a first-in-first-out (FIFO) insertion and retrieval of the elements. For this functionality, it defines the <kbd>enqueue</kbd></span>, <span><kbd>enqueueAll</kbd></span>, <span><kbd>dequeue</kbd></span>, <span><kbd>dequeueOption</kbd></span>, and <span><kbd>front</kbd></span> methods.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Buffers</h1>
                </header>
            
            <article>
                
<p><kbd>Buffers</kbd> conclude our rush through the collection library. In essence, <kbd>Buffer</kbd> is just a <kbd>Seq</kbd> that can grow and shrink. This sub-hierarchy exists only in immutable form, though <kbd>IndexedBuffer</kbd> inherits from both Buffer and <kbd>IndexedSeq</kbd>, as shown by the next diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2abfd717-cfc0-4baa-bd63-0acf4e4f3cde.png" style="width:31.92em;height:21.75em;" width="463" height="316"/><br/></p>
<p>Let's take a look at the methods that these collections define, in addition to the definitions inherited from <kbd>SeqOps</kbd>:</p>
<ul>
<li><strong>Buffer</strong> defines methods to add or remove one or more elements <span>in place or </span>returning new buffer: <kbd>prepend</kbd>, <kbd>append</kbd>, <kbd>appendAll</kbd>, <kbd>+=:</kbd>, <kbd>prependAll</kbd>, <kbd>++=:</kbd>, <kbd>insert</kbd>, <kbd>insertAll</kbd>, <kbd>remove</kbd>, <kbd>subtractOne</kbd>, <kbd>trimStart</kbd>, <kbd>trimEnd</kbd>, <kbd>patchInPlace</kbd>, <kbd>dropInPlace</kbd>, <kbd>dropRightInPlace</kbd>, <kbd>takeRightInPlace</kbd>, <kbd>sliceInPlace</kbd>, <kbd>dropWhileInPlace</kbd>, <kbd>takeWhileInPlace</kbd>, and <kbd>padToInPlace</kbd>.</li>
<li><span><strong>ListBuffer</strong> is a concrete buffer implementation baked by a <kbd>List</kbd>. In addition to other discussed methods, it provides <kbd>prependToList</kbd>, which allows us to prepend this collection to another list and a triple of <kbd>mapInPlace</kbd></span>, <span><kbd>flatMapInPlace</kbd></span>, and <span><kbd>filterInPlace</kbd>, giving us a possibility to modify elements in place.</span></li>
<li>Take a <kbd>Buffer</kbd>, add an <kbd>IndexedSeq</kbd>, and you'll get an <strong>IndexedBuffer</strong>. Similar to <kbd>ListBuffer</kbd>, it provides the <kbd>flatMapInPlace</kbd> and <kbd>filterInPlace</kbd> methods.</li>
<li><strong>ArrayBuffer</strong> is a concrete implementation of <kbd>IndexedBuffer</kbd> that uses an array to store its elements and has a constant time for append, update, and random access. It has a <kbd>sizeHint</kbd> method, which can be used to enlarge the underlying array. It is a default implementation instantiated if <kbd>mutable.Seq</kbd> is created.</li>
<li><strong>ArrayDeque</strong> is another efficient collection that emerged in the 2.13 version. It implements a double-ended queue that internally uses a resizable circular buffer. This allows to have a constant time for append, prepend, remove first, remove last, and random-access operations. There are lots of additional methods available on this collection, mostly because of the notion of the second-end: <kbd>removeHeadOption</kbd>, <kbd>removeHead</kbd>, <kbd>removeLastOption</kbd>, <kbd>removeLast</kbd>, <kbd>removeAll</kbd>, <kbd>removeAllReverse</kbd>, <kbd>removeHeadWhile</kbd>, <kbd>removeLastWhile</kbd>, <kbd>removeFirst</kbd>, <kbd>removeAll</kbd>, <kbd>clearAndShrink</kbd>, <kbd>copySliceToArray</kbd>, and <kbd>trimToSize</kbd>.</li>
<li>The <strong>Queue</strong> <span>in this hierarchy </span>is mutable. It is based on <kbd>ArrayDeque</kbd> and allows us to insert and retrieve elements in the FIFO manner. The following methods are available for that: <kbd>enqueue</kbd>, <kbd>enqueueAll</kbd>, <kbd>dequeue</kbd>, <kbd>dequeueFirst</kbd>, <kbd>dequeueAll</kbd>, and <kbd>dequeueWhile.</kbd></li>
<li>The <strong>Stack</strong> is similar to <kbd>Queue</kbd>, but it implements in last-in-first-out (LIFO) order instead of FIFO. The methods it defines are formulated in the corresponding terms: <kbd>push</kbd>, <kbd>pushAll</kbd>, <kbd>pop</kbd>, <kbd>popAll</kbd>, <kbd>popWhile</kbd>, and <kbd>top</kbd>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala Collection Contrib library</h1>
                </header>
            
            <article>
                
<p>Needless to say, the standard Scala collection library is very rich and provides collections for most of the common use cases. But of course, there are some other structures that might be useful in a number of specific situations. The Scala Collection <kbd>Contrib</kbd> module is Scala's way of having both a stable standard library and some extra features. In a sense, this module is an incubator for the new collection types; types that prove to be useful for a broad audience will presumably be incorporated into the standard library in further Scala versions.</p>
<p>Currently, there are four collection types available in the module, each both mutable and immutable:</p>
<ul>
<li><kbd>MultiDict</kbd></li>
<li><kbd>SortedMultiDict</kbd></li>
<li><kbd>MultiSet</kbd></li>
<li><kbd>SortedMultiSet</kbd></li>
</ul>
<p>Also this library provides a possibility to define additional operations on existing collections via an implicit enrichment. The following import is required to make it available: </p>
<pre>import scala.collection.decorators._</pre>
<p>And it delivers these methods:</p>
<ul>
<li>On Seq: <kbd>intersperse</kbd> and <kbd>replaced</kbd></li>
<li>On Map: <kbd>zipByKey</kbd>, <kbd>join</kbd>, <kbd>zipByKeyWith</kbd>, <kbd>mergeByKey</kbd>, <kbd><span>mergeByKeyWith</span></kbd>, <kbd>fullOuterJoin</kbd>, <kbd>leftOuterJoin</kbd>, and <kbd>rightOUterJoing</kbd></li>
</ul>
<p>Please consult the module documentation at <a href="https://github.com/scala/scala-collection-contrib">https://github.com/scala/scala-collection-contrib</a> for further details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">Scala 2.13 is a minor update of Scala with the main focus on the redesigned collection library. The few small additions to the standard library, such as automatic resource management, just accentuate this fact.</p>
<p class="p1">The new collection library mainly consists of two intermixed inheritance hierarchies with a similar shape. Members of the first hierarchy describe the structure of the collection and members of the second hierarchy—operations available on this collection type. Because of the inheritance relations, the collections situated lower in the tree define additional methods for more specific collections and override methods defined by the parent traits to provide more efficient implementation as required.</p>
<p class="p1">The three main <span>collection </span>types are <kbd>Seq</kbd>, <kbd>Set</kbd>, and <kbd>Map</kbd>. Each of these types has multiple implementations that are useful in specific situations. Set is also a function of one argument; <kbd>Seq</kbd> and <kbd>Map</kbd> are <kbd>PartialFunctions</kbd>.</p>
<p class="p1">Most of the collections are available in mutable and immutable forms.</p>
<p class="p1">In addition to the collection hierarchies, there is a concept of View, which is a reified definition of iterators’ operations and can be used to <span>lazily </span>apply transformations to the collection. Another related abstraction is <kbd>IterableFactory</kbd>, which implements some general ways to create collection instances and to perform conversions between collection representations.</p>
<p class="p1">In the next chapter, we will shift our focus from the new features of version 2.13 to a general exploration of Scala, starting with its type system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Describe two ways to make it possible for some resource, <kbd>R</kbd>, to use it together with <kbd>scala.util.Using</kbd> resource management utility. </li>
<li>How can an instance of a <kbd>Set</kbd> and an instance of a <kbd>List</kbd> be compared to each other?</li>
<li><span>Name the default concrete implementation for an immutable <kbd>Seq</kbd>.</span></li>
<li><span>Name the default concrete implementation for an immutable indexed <kbd>Seq</kbd>.</span></li>
<li><span>Name the default concrete implementation for a mutable <kbd>Seq</kbd>.</span></li>
<li><span>Name the default concrete implementation for a mutable indexed <kbd>Seq</kbd>.</span></li>
<li>It is sometimes said that <kbd>List.flatMap</kbd> is more powerful than it was expected to be. Can you explain why?</li>
<li>Describe a way to map over a collection multiple times using different functions but without producing intermediate collections.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li class="book-top-block-info-authors left">Mads Hartmann, Ruslan Shevchenko, Professional Scala:<span> Write concise and expressive, type-safe code in an environment that lets you build for the JVM, browser, and more.</span></li>
</ul>
<ul>
<li><span>Vikash Sharma, </span><em>Learning Scala Programming<span>: </span></em><span><em>Learn how to write scalable and concurrent programs in Scala, a language that grows with you</em>.</span></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>