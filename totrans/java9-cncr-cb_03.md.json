["```java\n        public class PrintQueue {\n\n```", "```java\n        private final Semaphore semaphore; \n        private final boolean freePrinters[]; \n        private final Lock lockPrinters;\n\n```", "```java\n        public PrintQueue(){ \n          semaphore=new Semaphore(3); \n          freePrinters=new boolean[3]; \n          for (int i=0; i<3; i++){ \n            freePrinters[i]=true; \n          } \n          lockPrinters=new ReentrantLock(); \n        }\n\n```", "```java\n        public void printJob (Object document){\n\n```", "```java\n        try { \n          semaphore.acquire();\n\n```", "```java\n        int assignedPrinter=getPrinter();\n\n```", "```java\n        long duration=(long)(Math.random()*10); \n        System.out.printf(\"%s - %s: PrintQueue: Printing a Job in\n                           Printer %d during %d seconds\\n\",\n                          new Date(), Thread.currentThread().getName(),\n                          assignedPrinter,duration);\n        TimeUnit.SECONDS.sleep(duration);\n\n```", "```java\n          freePrinters[assignedPrinter]=true; \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } finally { \n          semaphore.release();       \n        }\n\n```", "```java\n        private int getPrinter() {\n\n```", "```java\n        int ret=-1;\n\n```", "```java\n        try { \n          lockPrinters.lock();\n\n```", "```java\n        for (int i=0; i<freePrinters.length; i++) { \n          if (freePrinters[i]){ \n            ret=i; \n            freePrinters[i]=false; \n            break; \n          } \n        }\n\n```", "```java\n        } catch (Exception e) { \n          e.printStackTrace(); \n        } finally { \n          lockPrinters.unlock(); \n        } \n        return ret;\n\n```", "```java\n        public class Job implements Runnable {\n\n```", "```java\n        private PrintQueue printQueue;\n\n```", "```java\n        public Job(PrintQueue printQueue){ \n          this.printQueue=printQueue; \n        }\n\n```", "```java\n        @Override \n          public void run() {\n\n```", "```java\n        System.out.printf(\"%s: Going to print a job\\n\",\n                          Thread.currentThread().getName());\n\n```", "```java\n        printQueue.printJob(new Object());\n\n```", "```java\n          System.out.printf(\"%s: The document has been printed\\n\",\n                            Thread.currentThread().getName());         \n        }\n\n```", "```java\n        public class Main { \n          public static void main (String args[]){\n\n```", "```java\n        PrintQueue printQueue=new PrintQueue();\n\n```", "```java\n        Thread[] threads=new Thread[12]; \n        for (int i=0; I < threads.length i++){ \n          thread[i]=new Thread(new Job(printQueue),\"Thread\"+i); \n        }\n\n```", "```java\n        for (int i=0; I < threads.length; i++){ \n          thread[i].start(); \n        }\n\n```", "```java\n        public class Videoconference implements Runnable{\n\n```", "```java\n        private final CountDownLatch controller;\n\n```", "```java\n        public Videoconference(int number) { \n          controller=new CountDownLatch(number); \n        }\n\n```", "```java\n        public void arrive(String name){\n\n```", "```java\n        System.out.printf(\"%s has arrived.\",name);\n\n```", "```java\n        controller.countDown();\n\n```", "```java\n        System.out.printf(\"VideoConference: Waiting for %d\n                           participants.\\n\",controller.getCount());\n\n```", "```java\n        @Override \n        public void run() {\n\n```", "```java\n        System.out.printf(\"VideoConference: Initialization: %d\n                           participants.\\n\",controller.getCount());\n\n```", "```java\n        try { \n          controller.await();\n\n```", "```java\n          System.out.printf(\"VideoConference: All the participants have\n                             come\\n\"); \n          System.out.printf(\"VideoConference: Let's start...\\n\"); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        public class Participant implements Runnable {\n\n```", "```java\n        private Videoconference conference;\n\n```", "```java\n        private String name;\n\n```", "```java\n        public Participant(Videoconference conference, String name) { \n          this.conference=conference; \n          this.name=name; \n        }\n\n```", "```java\n        @Override \n        public void run() {\n\n```", "```java\n        long duration=(long)(Math.random()*10); \n        try { \n          TimeUnit.SECONDS.sleep(duration); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        conference.arrive(name);\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        Videoconference conference=new Videoconference(10);\n\n```", "```java\n        Thread threadConference=new Thread(conference); \n        threadConference.start();\n\n```", "```java\n        for (int i=0; i<10; i++){ \n          Participant p=new Participant(conference, \"Participant \"+i); \n          Thread t=new Thread(p); \n          t.start(); \n        }\n\n```", "```java\n        public class MatrixMock {\n\n```", "```java\n        private final int data[][];\n\n```", "```java\n        public MatrixMock(int size, int length, int number){\n\n```", "```java\n        int counter=0; \n        data=new int[size][length]; \n        Random random=new Random();\n\n```", "```java\n        for (int i=0; i<size; i++) { \n          for (int j=0; j<length; j++){ \n            data[i][j]=random.nextInt(10); \n            if (data[i][j]==number){ \n              counter++; \n            } \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Mock: There are %d ocurrences of number in\n                           generated data.\\n\",counter,number);\n\n```", "```java\n        public int[] getRow(int row){ \n          if ((row>=0)&&(row<data.length)){ \n            return data[row]; \n          } \n          return null; \n        }\n\n```", "```java\n        public class Results {\n\n```", "```java\n        private final int data[];\n\n```", "```java\n        public Results(int size){ \n          data=new int[size]; \n        }\n\n```", "```java\n        public void  setData(int position, int value){ \n          data[position]=value; \n        }\n\n```", "```java\n        public int[] getData(){ \n          return data; \n        }\n\n```", "```java\n        public class Searcher implements Runnable {\n\n```", "```java\n        private final int firstRow; \n        private final int lastRow;\n\n```", "```java\n        private final MatrixMock mock;\n\n```", "```java\n        private final Results results;\n\n```", "```java\n        private final int number;\n\n```", "```java\n        private final CyclicBarrier barrier;\n\n```", "```java\n        public Searcher(int firstRow, int lastRow, MatrixMock mock,\n                   Results results, int number, CyclicBarrier barrier){ \n          this.firstRow=firstRow; \n          this.lastRow=lastRow; \n          this.mock=mock; \n          this.results=results; \n          this.number=number; \n          this.barrier=barrier; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          int counter;\n\n```", "```java\n        System.out.printf(\"%s: Processing lines from %d to %d.\\n\",\n                          Thread.currentThread().getName(),\n                          firstRow,lastRow);\n\n```", "```java\n        for (int i=firstRow; i<lastRow; i++){ \n          int row[]=mock.getRow(i); \n          counter=0; \n          for (int j=0; j<row.length; j++){ \n            if (row[j]==number){ \n              counter++; \n            } \n          } \n          results.setData(i, counter); \n        }\n\n```", "```java\n        System.out.printf(\"%s: Lines processed.\\n\",\n                          Thread.currentThread().getName());\n\n```", "```java\n        try { \n          barrier.await(); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } catch (BrokenBarrierException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        public class Grouper implements Runnable {\n\n```", "```java\n        private final Results results;\n\n```", "```java\n        public Grouper(Results results){ \n          this.results=results; \n        }\n\n```", "```java\n        @Override \n        public void run() {\n\n```", "```java\n        int finalResult=0; \n        System.out.printf(\"Grouper: Processing results...\\n\");\n\n```", "```java\n        int data[]=results.getData(); \n        for (int number:data){ \n          finalResult+=number; \n        }\n\n```", "```java\n        System.out.printf(\"Grouper: Total result: %d.\\n\", finalResult);\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        final int ROWS=10000; \n        final int NUMBERS=1000; \n        final int SEARCH=5;  \n        final int PARTICIPANTS=5; \n        final int LINES_PARTICIPANT=2000;\n\n```", "```java\n        MatrixMock mock=new MatrixMock(ROWS, NUMBERS,SEARCH);\n\n```", "```java\n        Results results=new Results(ROWS);\n\n```", "```java\n        Grouper grouper=new Grouper(results);\n\n```", "```java\n        CyclicBarrier barrier=new CyclicBarrier(PARTICIPANTS,grouper);\n\n```", "```java\n        Searcher searchers[]=new Searcher[PARTICIPANTS]; \n        for (int i=0; i<PARTICIPANTS; i++){ \n          searchers[i]=new Searcher(i*LINES_PARTICIPANT,\n                               (i*LINES_PARTICIPANT)+LINES_PARTICIPANT,\n                               mock, results, 5,barrier); \n          Thread thread=new Thread(searchers[i]); \n          thread.start(); \n        } \n        System.out.printf(\"Main: The main thread has finished.\\n\");\n\n```", "```java\n        public class FileSearch implements Runnable {\n\n```", "```java\n        private final String initPath;\n\n```", "```java\n        private final String fileExtension\n\n```", "```java\n        private List<String> results;\n\n```", "```java\n        private Phaser phaser;\n\n```", "```java\n        public FileSearch(String initPath, String fileExtension,\n                          Phaser phaser) { \n          this.initPath = initPath; \n          this.fileExtension = fileExtension; \n          this.phaser=phaser; \n          results=new ArrayList<>(); \n        }\n\n```", "```java\n        private void directoryProcess(File file) { \n\n          File list[] = file.listFiles(); \n          if (list != null) { \n            for (int i = 0; i < list.length; i++) { \n              if (list[i].isDirectory()) { \n                directoryProcess(list[i]); \n              } else { \n                fileProcess(list[i]); \n              } \n            } \n          } \n        }\n\n```", "```java\n        private void fileProcess(File file) { \n          if (file.getName().endsWith(fileExtension)) { \n            results.add(file.getAbsolutePath()); \n          } \n        }\n\n```", "```java\n        private void filterResults() { \n          List<String> newResults=new ArrayList<>(); \n          long actualDate=new Date().getTime();\n\n```", "```java\n        for (int i=0; i<results.size(); i++){ \n          File file=new File(results.get(i)); \n          long fileDate=file.lastModified();\n\n```", "```java\n          if (actualDate-fileDate< TimeUnit.MILLISECONDS\n                                        .convert(1,TimeUnit.DAYS)){ \n            newResults.add(results.get(i)); \n          } \n        }\n\n```", "```java\n          results=newResults; \n        }\n\n```", "```java\n        private boolean checkResults() {\n\n```", "```java\n        if (results.isEmpty()) { \n          System.out.printf(\"%s: Phase %d: 0 results.\\n\",\n                            Thread.currentThread().getName(),\n                            phaser.getPhase()); \n          System.out.printf(\"%s: Phase %d: End.\\n\",\n                            Thread.currentThread().getName(),\n                            phaser.getPhase()); \n          phaser.arriveAndDeregister(); \n          return false;\n\n```", "```java\n          } else { \n            System.out.printf(\"%s: Phase %d: %d results.\\n\",\n                              Thread.currentThread().getName(),\n                              phaser.getPhase(),results.size()); \n            phaser.arriveAndAwaitAdvance(); \n            return true; \n          }\n        }\n\n```", "```java\n        private void showInfo() { \n          for (int i=0; i<results.size(); i++){ \n            File file=new File(results.get(i)); \n            System.out.printf(\"%s: %s\\n\",\n                               Thread.currentThread().getName(),\n                               file.getAbsolutePath()); \n          } \n          phaser.arriveAndAwaitAdvance(); \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          phaser.arriveAndAwaitAdvance();\n\n```", "```java\n        System.out.printf(\"%s: Starting.\\n\",\n                          Thread.currentThread().getName());\n\n```", "```java\n        File file = new File(initPath); \n        if (file.isDirectory()) { \n          directoryProcess(file); \n        }\n\n```", "```java\n        if (!checkResults()){ \n          return; \n        }\n\n```", "```java\n        filterResults();\n\n```", "```java\n        if (!checkResults()){ \n          return; \n        }\n\n```", "```java\n        showInfo(); \n        phaser.arriveAndDeregister(); \n        System.out.printf(\"%s: Work completed.\\n\",\n                          Thread.currentThread().getName());\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        Phaser phaser=new Phaser(3);\n\n```", "```java\n        FileSearch system=new FileSearch(\"C:\\\\Windows\", \"log\", phaser); \n        FileSearch apps= new FileSearch(\"C:\\\\Program Files\",\n                                        \"log\",phaser); \n        FileSearch documents= new FileSearch(\"C:\\\\Documents And Settings\",\n                                             \"log\",phaser);\n\n```", "```java\n        Thread systemThread=new Thread(system,\"System\"); \n        systemThread.start();\n\n```", "```java\n        Thread appsThread=new Thread(apps,\"Apps\"); \n        appsThread.start();\n\n```", "```java\n        Thread documentsThread=new Thread(documents, \"Documents\"); \n        documentsThread.start();\n\n```", "```java\n        try { \n          systemThread.join(); \n          appsThread.join(); \n          documentsThread.join(); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        System.out.println(\"Terminated: \"+ phaser.isTerminated());\n\n```", "```java\n        public class MyPhaser extends Phaser {\n\n```", "```java\n        @Override \n        protected boolean onAdvance(int phase, int registeredParties) { \n          switch (phase) { \n            case 0: \n              return studentsArrived(); \n            case 1: \n              return finishFirstExercise(); \n            case 2: \n              return finishSecondExercise(); \n            case 3: \n              return finishExam(); \n            default: \n              return true; \n          } \n        }\n\n```", "```java\n        private boolean studentsArrived() { \n          System.out.printf(\"Phaser: The exam are going to start.\n                             The students are ready.\\n\"); \n          System.out.printf(\"Phaser: We have %d students.\\n\",\n                            getRegisteredParties()); \n          return false; \n        }\n\n```", "```java\n        private boolean finishFirstExercise() { \n          System.out.printf(\"Phaser: All the students have finished the\n                             first exercise.\\n\"); \n          System.out.printf(\"Phaser: It's time for the second one.\\n\"); \n          return false; \n        }\n\n```", "```java\n        private boolean finishSecondExercise() { \n          System.out.printf(\"Phaser: All the students have finished the\n                             second exercise.\\n\"); \n          System.out.printf(\"Phaser: It's time for the third one.\\n\"); \n          return false; \n        }\n\n```", "```java\n        private boolean finishExam() { \n          System.out.printf(\"Phaser: All the students have finished\n                             the exam.\\n\"); \n          System.out.printf(\"Phaser: Thank you for your time.\\n\"); \n          return true; \n        }\n\n```", "```java\n        public class Student implements Runnable {\n\n```", "```java\n        private Phaser phaser;\n\n```", "```java\n        public Student(Phaser phaser) { \n          this.phaser=phaser; \n        }\n\n```", "```java\n        @Override \n        public void run() {\n\n```", "```java\n        System.out.printf(\"%s: Has arrived to do the exam. %s\\n\",\n                          Thread.currentThread().getName(),new Date()); \n        phaser.arriveAndAwaitAdvance();\n\n```", "```java\n        System.out.printf(\"%s: Is going to do the first exercise.%s\\n\",\n                          Thread.currentThread().getName(),new Date()); \n        doExercise1(); \n        System.out.printf(\"%s: Has done the first exercise.%s\\n\",\n                          Thread.currentThread().getName(),new Date()); \n        phaser.arriveAndAwaitAdvance();\n\n```", "```java\n        System.out.printf(\"%s: Is going to do the second exercise. \n                          %s\\n\",Thread.currentThread().getName(),\n                          new Date()); \n        doExercise2(); \n        System.out.printf(\"%s: Has done the second exercise.%s\\n\",\n                          Thread.currentThread().getName(),new Date()); \n        phaser.arriveAndAwaitAdvance(); \n        System.out.printf(\"%s: Is going to do the third exercise.%s\\n\",\n                          Thread.currentThread().getName(),new Date()); \n        doExercise3(); \n        System.out.printf(\"%s: Has finished the exam.%s\\n\",\n                          Thread.currentThread().getName(),new Date()); \n        phaser.arriveAndAwaitAdvance();\n\n```", "```java\n        private void doExercise1() { \n          try { \n            long duration=(long)(Math.random()*10); \n            TimeUnit.SECONDS.sleep(duration); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        private void doExercise2() { \n          try { \n            long duration=(long)(Math.random()*10); \n            TimeUnit.SECONDS.sleep(duration); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        private void doExercise3() { \n          try { \n            long duration=(long)(Math.random()*10); \n            TimeUnit.SECONDS.sleep(duration); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        MyPhaser phaser=new MyPhaser();\n\n```", "```java\n        Student students[]=new Student[5]; \n        for (int i=0; i<students.length; i++){ \n          students[i]=new Student(phaser); \n          phaser.register(); \n        }\n\n```", "```java\n        Thread threads[]=new Thread[students.length]; \n        for (int i=0; i<students.length; i++){ \n          threads[i]=new Thread(students[i],\"Student \"+i); \n          threads[i].start(); \n        }\n\n```", "```java\n        for (int i=0; i<threads.length; i++){ \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        System.out.printf(\"Main: The phaser has finished: %s.\\n\",\n                          phaser.isTerminated());\n\n```", "```java\n        public class Producer implements Runnable {\n\n```", "```java\n        private List<String> buffer;\n\n```", "```java\n        private final Exchanger<List<String>> exchanger;\n\n```", "```java\n        public Producer (List<String> buffer, Exchanger<List<String>>\n                         exchanger){ \n          this.buffer=buffer; \n          this.exchanger=exchanger; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int cycle = 1; cycle <= 10; cycle++){ \n            System.out.printf(\"Producer: Cycle %d\\n\",cycle);\n\n```", "```java\n        for (int j=0; j<10; j++){ \n          String message=\"Event \"+(((cycle-1)*10)+j); \n          System.out.printf(\"Producer: %s\\n\",message); \n          buffer.add(message); \n        }\n\n```", "```java\n        try { \n          buffer=exchanger.exchange(buffer); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n          System.out.println(\"Producer: \"+buffer.size()); \n        }\n\n```", "```java\n        public class Consumer implements Runnable {\n\n```", "```java\n        private List<String> buffer;\n\n```", "```java\n        private final Exchanger<List<String>> exchanger;\n\n```", "```java\n        public Consumer(List<String> buffer, Exchanger<List<String>>\n                        exchanger){ \n          this.buffer=buffer; \n          this.exchanger=exchanger; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int cycle=1; cycle <= 10; cycle++){ \n            System.out.printf(\"Consumer: Cycle %d\\n\",cycle);\n\n```", "```java\n        try { \n          buffer=exchanger.exchange(buffer); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n          System.out.println(\"Consumer: \"+buffer.size()); \n          for (int j=0; j<10; j++){ \n            String message=buffer.get(0); \n            System.out.println(\"Consumer: \"+message); \n            buffer.remove(0); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        List<String> buffer1=new ArrayList<>(); \n        List<String> buffer2=new ArrayList<>();\n\n```", "```java\n        Exchanger<List<String>> exchanger=new Exchanger<>();\n\n```", "```java\n        Producer producer=new Producer(buffer1, exchanger); \n        Consumer consumer=new Consumer(buffer2, exchanger);\n\n```", "```java\n        Thread threadProducer=new Thread(producer); \n        Thread threadConsumer=new Thread(consumer); \n\n        threadProducer.start(); \n        threadConsumer.start();\n\n```", "```java\n        public class SeedGenerator implements Runnable { \n\n          private CompletableFuture<Integer> resultCommunicator; \n\n          public SeedGenerator (CompletableFuture<Integer> completable) { \n            this.resultCommunicator=completable; \n          }\n\n```", "```java\n        @Override \n        public void run() { \n\n          System.out.printf(\"SeedGenerator: Generating seed...\\n\"); \n          // Wait 5 seconds \n          try { \n            TimeUnit.SECONDS.sleep(5); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n            int seed=(int) Math.rint(Math.random() * 10); \n\n            System.out.printf(\"SeedGenerator: Seed generated: %d\\n\",\n                              seed); \n\n            resultCommunicator.complete(seed); \n          }\n\n```", "```java\n        public class NumberListGenerator implements Supplier<List<Long>> { \n\n          private final int size; \n\n          public NumberListGenerator (int size) { \n            this.size=size; \n          }\n\n```", "```java\n          @Override \n          public List<Long> get() { \n            List<Long> ret = new ArrayList<>(); \n            System.out.printf(\"%s : NumberListGenerator : Start\\n\",\n                              Thread.currentThread().getName()); \n\n            for (int i=0; i< size*1000000; i++) { \n              long number=Math.round(Math.random()*Long.MAX_VALUE); \n              ret.add(number); \n            } \n            System.out.printf(\"%s : NumberListGenerator : End\\n\",\n                              Thread.currentThread().getName()); \n\n            return ret; \n          }\n\n```", "```java\n        public class NumberSelector implements Function<List<Long>, Long> { \n\n          @Override \n          public Long apply(List<Long> list) { \n\n            System.out.printf(\"%s: Step 3: Start\\n\",\n                              Thread.currentThread().getName()); \n            long max=list.stream().max(Long::compare).get(); \n            long min=list.stream().min(Long::compare).get(); \n            long result=(max+min)/2; \n            System.out.printf(\"%s: Step 3: Result - %d\\n\",\n                              Thread.currentThread().getName(), result); \n            return result; \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        System.out.printf(\"Main: Start\\n\"); \n        CompletableFuture<Integer> seedFuture = new CompletableFuture<>(); \n        Thread seedThread = new Thread(new SeedGenerator(seedFuture)); \n        seedThread.start();\n\n```", "```java\n        System.out.printf(\"Main: Getting the seed\\n\"); \n        int seed = 0; \n        try { \n          seed = seedFuture.get(); \n        } catch (InterruptedException | ExecutionException e) { \n          e.printStackTrace(); \n        } \n        System.out.printf(\"Main: The seed is: %d\\n\", seed);\n\n```", "```java\n        System.out.printf(\"Main: Launching the list of numbers\n                           generator\\n\"); \n        NumberListGenerator task = new NumberListGenerator(seed); \n        CompletableFuture<List<Long>> startFuture = CompletableFuture\n                                                    .supplyAsync(task);\n\n```", "```java\n        System.out.printf(\"Main: Launching step 1\\n\"); \n        CompletableFuture<Long> step1Future = startFuture\n                                              .thenApplyAsync(list -> { \n          System.out.printf(\"%s: Step 1: Start\\n\",\n                            Thread.currentThread().getName()); \n          long selected = 0; \n          long selectedDistance = Long.MAX_VALUE; \n          long distance; \n          for (Long number : list) { \n            distance = Math.abs(number - 1000); \n            if (distance < selectedDistance) { \n              selected = number; \n              selectedDistance = distance; \n            } \n          } \n          System.out.printf(\"%s: Step 1: Result - %d\\n\",\n                            Thread.currentThread().getName(), selected); \n          return selected; \n        }); \n\n        System.out.printf(\"Main: Launching step 2\\n\"); \n        CompletableFuture<Long> step2Future = startFuture \n        .thenApplyAsync(list -> list.stream().max(Long::compare).get()); \n\n        CompletableFuture<Void> write2Future = step2Future\n                                              .thenAccept(selected -> { \n          System.out.printf(\"%s: Step 2: Result - %d\\n\",\n                            Thread.currentThread().getName(), selected); \n        }); \n\n        System.out.printf(\"Main: Launching step 3\\n\"); \n        NumberSelector numberSelector = new NumberSelector(); \n        CompletableFuture<Long> step3Future = startFuture\n                                        .thenApplyAsync(numberSelector);\n\n```", "```java\n        System.out.printf(\"Main: Waiting for the end of the three\n                           steps\\n\"); \n        CompletableFuture<Void> waitFuture = CompletableFuture\n                                      .allOf(step1Future, write2Future,\n                                             step3Future);\n\n```", "```java\n        CompletableFuture<Void> finalFuture = waitFuture\n                                           .thenAcceptAsync((param) -> { \n          System.out.printf(\"Main: The CompletableFuture example has\n                             been completed.\"); \n        }); \n        finalFuture.join();\n\n```"]