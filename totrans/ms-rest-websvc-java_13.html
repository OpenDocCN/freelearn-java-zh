<html><head></head><body>
  <div id="_idContainer094">
   <h1 class="chapterNumber">
    <a id="_idTextAnchor284">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     10
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-266">
    <a id="_idTextAnchor285">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Scaling and Performance Optimization Techniques
    </span>
   </h1>
   <p class="normal">
    <a href="B21843_09.xhtml#_idTextAnchor240">
     <em class="italic">
      <span class="koboSpan" id="kobo.3.1">
       Chapter 9
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.4.1">
     introduced skills such as quantitative measurements to observe how a system connected via APIs behaves at runtime.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     That chapter
    </span>
    <a id="_idIndexMarker808">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     provides a good basis for this chapter on
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.7.1">
      performance
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.9.1">
      scalability
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     , two non-functional
    </span>
    <a id="_idIndexMarker809">
    </a>
    <span class="koboSpan" id="kobo.11.1">
     requirements that are strongly concerned with time, size, and other quantitative aspects of software systems and the data they process.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.12.1">
     We will start by explaining what developers need to know about performance and scalability in general.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     Then, we will dive into specifics, describing the most common strategies and techniques for improving performance and scalability.
    </span>
    <span class="koboSpan" id="kobo.12.3">
     We will demonstrate some of these techniques using our Product and Order Management APIs.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.13.1">
     We highlight the
    </span>
    <a id="_idIndexMarker810">
    </a>
    <span class="koboSpan" id="kobo.14.1">
     potential of Java
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.15.1">
      virtual threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.16.1">
     for increasing application throughput by improving CPU usage efficiency in the context of API development.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.17.1">
     We also show that to support performance and scalability, your API should be prepared to work with specialized infrastructure components.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.18.1">
     Lastly, we will show how load testing helps you avoid unpleasant surprises once your application starts to receive the production load.
    </span>
    <span class="koboSpan" id="kobo.18.2">
     Using performance testing, developers can get information that is vital to target their optimization efforts.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.19.1">
     By the end of this chapter, you will know how to prevent performance and scalability issues starting from the analysis phase, through appropriate API design, to subsequent optimizations triggered by the findings from load tests.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.20.1">
     The following topics are covered in this chapter:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.21.1">
      Understanding performance and scalability in API development
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.22.1">
      Applying performance optimization strategies
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.23.1">
      Increasing the throughput with virtual threads
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.24.1">
      Using infrastructure support
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.25.1">
      Designing and executing effective load tests
     </span>
    </li>
   </ul>
   <h1 class="heading-1" id="_idParaDest-267">
    <a id="_idTextAnchor286">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     Technical requirements
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.27.1">
     To demonstrate some of the techniques described in this chapter, we will use the example code of the Product and Order Management APIs that were developed in previous chapters.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     The changes that we will make to the code for this chapter can be found in the repository at
    </span>
    <a href="https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter10">
     <span class="url">
      <span class="koboSpan" id="kobo.28.1">
       https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter10
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.29.1">
     .
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-268">
    <a id="_idTextAnchor287">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     Understanding performance and scalability in API development
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.31.1">
     Performance
    </span>
    <a id="_idIndexMarker811">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     in computing refers to how efficiently a system or application executes tasks under a given workload.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     Efficiency has two aspects:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.33.1">
       Speed of processing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.34.1">
      : This is measured mostly in terms of response time (latency) and throughput (how many operations or how much data the system can handle per unit of time).
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.35.1">
       Consumption of resources
      </span>
     </strong>
     <span class="koboSpan" id="kobo.36.1">
      : This refers to the amount of resources required, such as CPU, memory, and network bandwidth utilization, to do the work.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.37.1">
     Statistics are an integral part of performance measurement because it makes sense to measure performance when the system processes a large number of different requests involving different amounts of data.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     Therefore, the time and other resources required to fulfill a request inevitably fluctuate and depend on a number of factors, making the actual measured values of the performance characteristics virtually random in nature.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.38.1">
     It is usually sufficient to use average values to calculate throughput.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     For response times, the average value is less useful because it does not capture well how the speed of response is perceived by users.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     The maximum value is often of particular interest because it can indicate potential issues, such as the occurrence of timeout errors.
    </span>
    <span class="koboSpan" id="kobo.38.4">
     Moreover, response times exceeding a reasonable limit discourage human users from continuing to use the application.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.39.1">
     Even more useful than the extreme values that occur very rarely are the percentile values.
    </span>
    <span class="koboSpan" id="kobo.39.2">
     If we rank all response times from shortest to longest, then, for example, the 95th percentile is the time at which 95% of the measured times are shorter.
    </span>
    <span class="koboSpan" id="kobo.39.3">
     In other words, there is only a 5% probability that a randomly selected request will take longer.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.40.1">
     Scalability refers to the ability of a system to handle an increasing load (increased number of users, higher data volumes, or additional transactions) while maintaining the performance within the limits expected by users.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     You can see that we cannot speak about scalability without considering performance.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.41.1">
     Scalability is one of the main motivating factors behind moving from monoliths to distributed (microservices) architectures.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     We can assume that our example Product API will need to handle significantly more requests than the Order Management API because not every product being
    </span>
    <a id="_idIndexMarker812">
    </a>
    <span class="koboSpan" id="kobo.42.1">
     browsed will be bought.
    </span>
    <span class="koboSpan" id="kobo.42.2">
     We can scale the deployment of the Product API to use more instances of the service than the Order Management API.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.43.1">
     With RESTful APIs, the tasks whose response time and throughput we are interested in are the HTTP requests.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     The time and computing resources needed to execute an HTTP request are composed of two parts:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.44.1">
      The processing needed by the API technology itself, such as serialization and deserialization of the data, network transmission, and protocol overhead
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.45.1">
      The processing inside the service providing the API (such as executing algorithms, accessing databases, and downstream API calls), which is often influenced by the API request and response payload design, such as the amount of data processed in one request, the possibility of performing concurrent processing and data streaming, and the cacheability of the responses.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.46.1">
     When designing APIs, you usually focus on the functional requirements because what the application should do is at the front of the users’ minds.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     How the application is expected to perform and cope with increasing traffic is often considered obvious or implied.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.47.1">
     It is also hard to predict the actual load, the load progression over time, and which parts of the system will be the most impacted.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     Donald Knuth’s famous saying “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.48.1">
      Premature optimization is the root of all evil
     </span>
    </em>
    <span class="koboSpan" id="kobo.49.1">
     ” warns us that we should not try to optimize everything.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.50.1">
     On the other hand, performance and scalability considerations should be part of the design process, and you often can prevent a lot of problems with just a few simple adjustments to the APIs.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     Ideally, you should design the APIs to be as simple as possible to fulfill the functional requirements, while keeping the options open for future extensions and optimizations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.51.1">
     When in doubt, let the REST principles guide you towards a more flexible and standard solution that will likely support the performance and scalability requirements:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.52.1">
      Using URLs based on a resource structure reflecting the business domain
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.53.1">
      Using correct HTTP methods and providing respective idempotency support for
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.54.1">
       GET
      </span>
     </code>
     <span class="koboSpan" id="kobo.55.1">
      ,
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.56.1">
       PUT
      </span>
     </code>
     <span class="koboSpan" id="kobo.57.1">
      , and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.58.1">
       DELETE
      </span>
     </code>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.59.1">
      Using correct HTTP headers and status codes
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.60.1">
      Using clearly defined parameters to let the client choose what data and operations are really needed
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.61.1">
      Using appropriate
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.62.1">
       Content-Type
      </span>
     </code>
     <span class="koboSpan" id="kobo.63.1">
      and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.64.1">
       Content-Encoding
      </span>
     </code>
     <span class="koboSpan" id="kobo.65.1">
      for the data (especially with large binary documents)
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.66.1">
     Having explained
    </span>
    <a id="_idIndexMarker813">
    </a>
    <span class="koboSpan" id="kobo.67.1">
     what performance and scalability mean for API development in general, we can move on to describe the strategies that, when applied appropriately, can have the greatest impact on the performance and scalability of your applications integrated using APIs.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-269">
    <a id="_idTextAnchor288">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     Applying performance optimization and scalability improvement strategies
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.69.1">
     If you detect an existing or imminent performance or scalability problem with your API, you should
    </span>
    <a id="_idIndexMarker814">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     be armed with the tools to solve it.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     Let’s take a closer look at some of the strategies and techniques for optimizing performance in the following sections.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-270">
    <a id="_idTextAnchor289">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     Knowing the performance requirements
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.72.1">
     As mentioned in the previous section, the performance requirements are often implied and not
    </span>
    <a id="_idIndexMarker815">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     clearly specified by users and customers.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.74.1">
     For some applications, performance may not be critical, but if we take the example of most e-commerce sites, an application with a response time reaching a few seconds is equivalent to an application that does not work at all because it immediately discourages potential customers from buying.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.75.1">
     It is therefore necessary to include at least some rough performance expectations for the system to
    </span>
    <a id="_idIndexMarker816">
    </a>
    <span class="koboSpan" id="kobo.76.1">
     be developed.
    </span>
    <span class="koboSpan" id="kobo.76.2">
     If you can be more rigorous, you should ask the customer to define
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.77.1">
      service-level agreements
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.79.1">
      SLAs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     ) specifying maximum response times or the number of requests processed for each operation.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     The SLAs may vary for peak and off-peak times.
    </span>
    <span class="koboSpan" id="kobo.80.3">
     Remember to capture size limits for large data objects, large numbers of concurrent users, and their geographical distribution.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.81.1">
     The collected performance requirements can be used to design load tests.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     The load tests will show whether the system can handle the expected load and, if not, which parts are the bottlenecks.
    </span>
    <span class="koboSpan" id="kobo.81.3">
     Information about the geographical distribution of users and the quality of their network connections should be used to add simulated network latencies in the load test environment.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.82.1">
     To design the system correctly, it is important to know whether the system should be optimized for response time (systems with human interaction) or throughput (batch processing).
    </span>
    <span class="koboSpan" id="kobo.82.2">
     To achieve better (perceived) response times, it may make sense to split the API requests so that a request performs the essential operation only, delivering the essential data only.
    </span>
    <span class="koboSpan" id="kobo.82.3">
     This
    </span>
    <a id="_idIndexMarker817">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     way the user experience is improved, while the non-essential request(s) can start later and/or take longer.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.84.1">
     In contrast to that, grouping multiple operations or data items in one request may improve the throughput by reducing the API overhead.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     However, you must ensure that a request does not become so big that it fails due to a timeout.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.85.1">
     In many cases, you cannot estimate or simulate the load and environment attributes precisely enough, so you must react to performance problems that start occurring in production.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     To support that, your APIs should be ready to evolve without breaking the existing clients, which is the topic of
    </span>
    <a href="B21843_05.xhtml#_idTextAnchor116">
     <em class="italic">
      <span class="koboSpan" id="kobo.86.1">
       Chapter 5
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.87.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-271">
    <a id="_idTextAnchor290">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     Providing only what is really needed
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.89.1">
     Security, another non-functional requirement, is often regarded as going against performance, but in many instances, their solutions can in fact overlap.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     Limiting the data that we
    </span>
    <a id="_idIndexMarker818">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     transfer in APIs is good for security and can be good for performance, too, because time and resources are not wasted on items that the API client does not need.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.91.1">
     You should identify expensive items that are large or take a long time to get.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     If an expensive item is not used by all requests, you can do either of the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.92.1">
      Add a parameter to the API endpoint to only return the expensive item when the client asks for it
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.93.1">
      Create a separate endpoint (resource) for the expensive item
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.94.1">
     For example, if our Product API stored photos of the product, we would not have to return the photos in every request for a product.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     Instead, we can return a list of image IDs and define a sub-resource of the product resource, returning an image by its image ID.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.95.1">
     A common mistake is to design API resources to be a copy of the database entities.
    </span>
    <span class="koboSpan" id="kobo.95.2">
     Some developers might even be tempted to use the clear antipattern of using the JPA entity classes in APIs directly without defining separate API DTOs.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.96.1">
     Special attention should be paid to fields that define relationships between JPA entities.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     Exposing the whole graphs of objects resulting from following the relationships without due justification often leads to bloated APIs, creating a ticking time bomb with performance (besides security and maintainability) problems.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.97.1">
     For example, suppose that at some point we extend the database schema of our Product API service with additional database tables and JPA entities containing information about stock availability, location, historical prices, and so on.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     These additional database tables could be linked to
    </span>
    <a id="_idIndexMarker819">
    </a>
    <span class="koboSpan" id="kobo.98.1">
     the product table using foreign keys, and the JPA model could include relationships that would map to the respective SQL joins.
    </span>
    <span class="koboSpan" id="kobo.98.2">
     It would be a mistake to include all the additional information automatically in the Product API resource JSON representation, except in the unlikely scenario where business analysis confirms that all possible use cases for reading a product will always need the full set of detailed data.
    </span>
    <span class="koboSpan" id="kobo.98.3">
     Instead, to support the use cases that require access to the related entities, the API could send the extra data only when a parameter is set or via a separate endpoint.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-272">
    <a id="_idTextAnchor291">
    </a>
    <span class="koboSpan" id="kobo.99.1">
     Maintaining statelessness
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.100.1">
     Statelessness (as explained in
    </span>
    <a href="B21843_01.xhtml#_idTextAnchor015">
     <em class="italic">
      <span class="koboSpan" id="kobo.101.1">
       Chapter 1
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.102.1">
     ) is one of the key principles of REST architecture.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     All the
    </span>
    <a id="_idIndexMarker820">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     input data needed to perform an operation should be in the URL path and the request body.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     The request processing must not depend on some implicit session data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.104.1">
     Statelessness is important for performance and scalability because it allows horizontal scaling of the service providing the API.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     A load balancer (briefly explained in the upcoming section on infrastructure components) can route any request to be processed by any of the service instances because the instance does not have to remember the session state (history of the previous requests belonging to the same user journey).
    </span>
    <span class="koboSpan" id="kobo.104.3">
     Avoiding the session state can also help in reducing memory consumption.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.105.1">
     Of course, the application may need to support a session-like user experience.
    </span>
    <span class="koboSpan" id="kobo.105.2">
     For example, you may want to let the user create an order product by product, so the application needs to remember an incomplete order, commonly represented by a shopping cart on most e-commerce sites.
    </span>
    <span class="koboSpan" id="kobo.105.3">
     To fulfill this requirement, you have two main options:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.106.1">
      Maintain the session state on the client (web browser) using JavaScript code, local storage, and so on.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.107.1">
      Define the shopping cart as a first-class entity of the backend service.
     </span>
     <span class="koboSpan" id="kobo.107.2">
      This means creating a RESTful resource identified by URL for the new entity and using standard HTTP methods to manipulate it.
     </span>
     <span class="koboSpan" id="kobo.107.3">
      This makes the data stored in the backend explicit, as opposed to an implicit session without a clear structure that would be harder to manage.
     </span>
    </li>
   </ul>
   <h2 class="heading-2" id="_idParaDest-273">
    <a id="_idTextAnchor292">
    </a>
    <span class="koboSpan" id="kobo.108.1">
     Limiting large collections
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.109.1">
     When your API transfers a collection of items (usually represented by a JSON list), you should try to find
    </span>
    <a id="_idIndexMarker821">
    </a>
    <span class="koboSpan" id="kobo.110.1">
     out the expected number of items in the collection.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.111.1">
     If the number of items frequently exceeds a reasonable limit, you should consider implementing a pagination solution for the collection (see
    </span>
    <a href="B21843_06.xhtml#_idTextAnchor135">
     <em class="italic">
      <span class="koboSpan" id="kobo.112.1">
       Chapter 6
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.113.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.113.2">
     The number of items in a collection and the number of items per page that calls for the introduction of pagination depend on how expensive the API operation is.
    </span>
    <span class="koboSpan" id="kobo.113.3">
     For small items that are quick to retrieve, the number could be higher.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.114.1">
     You should also think about how large a set it makes sense to work with on the client side at the same time.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     If the items are displayed on a screen, the user can usually not see more than a few items at the same time.
    </span>
    <span class="koboSpan" id="kobo.114.3">
     You can base your pagination policy on that number.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.115.1">
     Besides pagination, you can limit the number of items returned by ensuring that queries are sufficiently specific.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     For instance, in a substring-based search, you can enforce a rule that the search string must have a minimum length of three characters, which helps narrow down the results and improve efficiency.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.116.1">
     Or, before the full data retrieval, you can first execute a cheaper database query returning only the count of the matching items, and if it exceeds a certain limit, you can stop there and return a response asking the client to provide a more specific query.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     Cheaper in the context of performance optimization means taking less time and fewer resources.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.117.1">
     When deciding about the collection size limits, you should also think about the nature of the data sources your API operation needs to access.
    </span>
    <span class="koboSpan" id="kobo.117.2">
     In distributed (microservices) architectures, you usually need to call another API to fulfill an API request.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.118.1">
     If you need to make separate API calls to get some details for each item of a collection, you can try to shorten the response time by making several such API calls in parallel.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     However, you should limit the number of parallel API invocations to avoid overwhelming the API.
    </span>
    <span class="koboSpan" id="kobo.118.3">
     The
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.119.1">
      Increasing the throughput with virtual threads
     </span>
    </em>
    <span class="koboSpan" id="kobo.120.1">
     section later in this chapter may be useful for implementing concurrent API calls.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.121.1">
     Another option is to check whether the API your service needs to call supports (or can be made to support) bulk operations, such as getting details for a list of IDs in one request.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     But you must be reasonable about the size of the request because requests that are too large may take too long and hit timeouts at various points along their path from the client to the server and back.
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.122.1">
      For example, the Order Management API calls the Product API for each product to get its price.
     </span>
     <span class="koboSpan" id="kobo.122.2">
      We could optimize this integration so that the Product API provides a bulk “get multiple products” endpoint.
     </span>
     <span class="koboSpan" id="kobo.122.3">
      The API would take a list of product IDs as its input and return the prices for all the products at once.
     </span>
    </li>
   </ul>
   <h2 class="heading-2" id="_idParaDest-274">
    <a id="_idTextAnchor293">
    </a>
    <span class="koboSpan" id="kobo.123.1">
     Optimizing large objects
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.124.1">
     We have already mentioned that it is not wise to try to optimize everything.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     The Pareto principle
    </span>
    <a id="_idIndexMarker822">
    </a>
    <span class="koboSpan" id="kobo.125.1">
     says that the vast majority (around 80%) of (performance) problems are caused by a small minority (around 20%) of the items comprising your API.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.126.1">
     A relatively common case where a small part of an API is responsible for most of the bytes transferred and time spent is when you want to transfer large blocks of data whose internal structure is not important to the API, such as photos, videos, or documents, which are usually encoded using binary formats.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     These items have a significant impact on the network transfer volume, memory consumption, and response times.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.127.1">
     It is a good practice to avoid including large (binary) objects in structured (JSON) payloads.
    </span>
    <span class="koboSpan" id="kobo.127.2">
     Instead, you can define separate resources (endpoints) for the large objects.
    </span>
    <span class="koboSpan" id="kobo.127.3">
     This has the following advantages:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.128.1">
      The payload can use an encoding that is suitable for the large object format.
     </span>
     <span class="koboSpan" id="kobo.128.2">
      Trying to embed binary data in JSON usually leads to the use of inefficient encodings such as BASE64.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.129.1">
      If the text-based encoding of large data objects cannot be avoided, the efficiency of the network transfer can be improved by combining it with compression, such as gzip.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.130.1">
      Large objects can be cached independently of other data.
     </span>
     <span class="koboSpan" id="kobo.130.2">
      This makes sense given the size of the objects and because it is likely that the large objects change less frequently than the structured data.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.131.1">
     Where possible, you should also try to limit the size of large objects.
    </span>
    <span class="koboSpan" id="kobo.131.2">
     When displaying images on a client device, the performance can be improved by scaling down the images to a lower resolution on the server.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.132.1">
     You can limit the size of large objects at the very beginning.
    </span>
    <span class="koboSpan" id="kobo.132.2">
     If your application allows users to upload files, you should consider constraining the uploaded file size.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.133.1">
     We have implemented a separate endpoint for product photos in our example Product API in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.134.1">
      Uploading and downloading files via the REST API
     </span>
    </em>
    <span class="koboSpan" id="kobo.135.1">
     section in
    </span>
    <a href="B21843_06.xhtml#_idTextAnchor135">
     <em class="italic">
      <span class="koboSpan" id="kobo.136.1">
       Chapter 6
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.137.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.138.1">
     In that example code, we used a method of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.139.1">
      MultipartFile
     </span>
    </code>
    <span class="koboSpan" id="kobo.140.1">
     class to get the file content as a byte array.
    </span>
    <span class="koboSpan" id="kobo.140.2">
     We also return a byte array in the method used to download the file.
    </span>
    <span class="koboSpan" id="kobo.140.3">
     This approach allows our code to stay simple, but it has the drawback that the whole file is stored in the heap memory at once, although we do not do any processing that requires having the whole file in memory.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.141.1">
     We
    </span>
    <a id="_idIndexMarker823">
    </a>
    <span class="koboSpan" id="kobo.142.1">
     could optimize the memory usage by using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.143.1">
      InputStream
     </span>
    </code>
    <span class="koboSpan" id="kobo.144.1">
     /
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.145.1">
      OutputStream
     </span>
    </code>
    <span class="koboSpan" id="kobo.146.1">
     instead of the byte array.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     Or we could use a reactive framework such as WebFlux (more on that in
    </span>
    <a href="B21843_11.xhtml#_idTextAnchor310">
     <em class="italic">
      <span class="koboSpan" id="kobo.147.1">
       Chapter 11
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.148.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.148.2">
     However, we would have to go all the way, that is, also persisting the content using methods supporting streaming access.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-275">
    <a id="_idTextAnchor294">
    </a>
    <span class="koboSpan" id="kobo.149.1">
     Caching
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.150.1">
     Caching
    </span>
    <a id="_idIndexMarker824">
    </a>
    <span class="koboSpan" id="kobo.151.1">
     may be the most popular performance improvement strategy.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     However, caching is not a silver bullet, and designing a correct caching setup is not easy, so before adopting this strategy, you should make sure you have considered the option of improving performance by applying a proper API design, as described in the previous sections.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.152.1">
     Caching
    </span>
    <a id="_idIndexMarker825">
    </a>
    <span class="koboSpan" id="kobo.153.1">
     involves a trade-off: it provides shorter response times at the cost of additional memory to store cached data and the risk of potential inconsistency if the cached data becomes stale.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.154.1">
     Caching is closely tied to the challenge of cache invalidation—determining when data items in the cache should be removed.
    </span>
    <span class="koboSpan" id="kobo.154.2">
     This may occur either because the cached data has become stale or to free up memory when it is unlikely that the cached items will be accessed again.
    </span>
    <span class="koboSpan" id="kobo.154.3">
     Cache invalidation is considered one of the hardest problems in computing.
    </span>
    <span class="koboSpan" id="kobo.154.4">
     The two most common ways to detect items that need to be removed from the cache are as follows:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <em class="italic">
      <span class="koboSpan" id="kobo.155.1">
       Least recently used
      </span>
     </em>
     <span class="koboSpan" id="kobo.156.1">
      , based on the assumption that a resource that was last used a long time ago is unlikely to be used again
     </span>
    </li>
    <li class="bulletList">
     <em class="italic">
      <span class="koboSpan" id="kobo.157.1">
       Least frequently used
      </span>
     </em>
     <span class="koboSpan" id="kobo.158.1">
      , based on the assumption that resources that have been used frequently are likely to be used again
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.159.1">
     To speed up the operations of an API, we can consider caching on the consumer (client) side of the API (caching the HTTP responses) and on the provider (server) side of the API (caching data needed to perform the operation and return a result).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.160.1">
     Caching on the provider (server) side can take many forms: it can be data from a database, results of expensive computations, or semi-processed results of downstream API calls.
    </span>
    <span class="koboSpan" id="kobo.160.2">
     Caching on the service provider side is not specific to just API implementations, and therefore, it is beyond the scope of this book.
    </span>
    <span class="koboSpan" id="kobo.160.3">
     For detailed guidance, you can refer to Mastering Spring Boot 3.0 by Ahmet Meric which covers broader caching strategies within Spring-based applications.
    </span>
    <span class="koboSpan" id="kobo.160.4">
     For database access using JPA/Hibernate, it is advisable to understand the concept of first- and
    </span>
    <a id="_idIndexMarker826">
    </a>
    <span class="koboSpan" id="kobo.161.1">
     second-level cache.
    </span>
    <span class="koboSpan" id="kobo.161.2">
     For general caching at the Spring component level, you should know about Spring Cache (
    </span>
    <a href="https://docs.spring.io/spring-boot/reference/io/caching.html">
     <span class="url">
      <span class="koboSpan" id="kobo.162.1">
       https://docs.spring.io/spring-boot/reference/io/caching.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.163.1">
     ) and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.164.1">
      @Cacheable
     </span>
    </code>
    <span class="koboSpan" id="kobo.165.1">
     annotation.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.166.1">
     To support the cacheability of data, the operations producing the data should be stateless, meaning we should get the same output data if the inputs are the same.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     This allows us to share the cached data across multiple instances of a service or multiple services using distributed caches such as Hazelcast or Redis.
    </span>
    <span class="koboSpan" id="kobo.166.3">
     This way, data put in the cache by one instance of a service can be reused by another instance needing the same data.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-276">
    <a id="_idTextAnchor295">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     Caching on the client side
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.168.1">
     Now, let’s focus on the caching on the client side.
    </span>
    <span class="koboSpan" id="kobo.168.2">
     As the client does not have access to the implementation details of the service, it must use some hints to decide for which API responses
    </span>
    <a id="_idIndexMarker827">
    </a>
    <span class="koboSpan" id="kobo.169.1">
     and for how long a cached response can be used instead of calling the API again.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     Remember that client-side caching need not be done in the end client; it can also be done by a proxy server sitting between the server and the end client.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.170.1">
     Before we get into the details of cache control, it is important to verify the structure and granularity of the resources (endpoints) the API consists of.
    </span>
    <span class="koboSpan" id="kobo.170.2">
     Consider placing data items that rarely change (they are good candidates for caching) in a separate resource from that of other items that change frequently.
    </span>
    <span class="koboSpan" id="kobo.170.3">
     Only then can the caching be aligned well with the modification patterns of the data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.171.1">
     Requests using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.172.1">
      GET
     </span>
    </code>
    <span class="koboSpan" id="kobo.173.1">
     method are considered cacheable by default.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     This rule is used by most web browsers; therefore, users sometimes need to force the browser to reload the web page (e.g., pressing
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.174.1">
      Ctrl
     </span>
    </em>
    <span class="koboSpan" id="kobo.175.1">
     +
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.176.1">
      F5
     </span>
    </em>
    <span class="koboSpan" id="kobo.177.1">
     on the Windows operating system) in case the page content has changed faster than the browser expected.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.178.1">
     Conversely, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.179.1">
      PUT
     </span>
    </code>
    <span class="koboSpan" id="kobo.180.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.181.1">
      PATCH
     </span>
    </code>
    <span class="koboSpan" id="kobo.182.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.183.1">
      DELETE
     </span>
    </code>
    <span class="koboSpan" id="kobo.184.1">
     methods used to modify data on the server cannot be implemented without contacting the server, so they are not suitable for caching.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.185.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.186.1">
      POST
     </span>
    </code>
    <span class="koboSpan" id="kobo.187.1">
     method can be used to modify data on the server, such as creating a new order in our example Order Management API.
    </span>
    <span class="koboSpan" id="kobo.187.2">
     It can also be used for read-only operations, usually for complex queries when you want to use a request body instead of putting the operation inputs in the URL or request headers.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.188.1">
     A more detailed caching control, irrespective of the HTTP method used, can be achieved with standard HTTP response headers:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.189.1">
       Cache-Control
      </span>
     </code>
     <span class="koboSpan" id="kobo.190.1">
      : Supports a detailed specification of who (proxies or the end client) can cache the response with the same URL and when (for how long, based on a validation request)
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.191.1">
       ETag
      </span>
     </code>
     <span class="koboSpan" id="kobo.192.1">
      : Short for “entity tag,” a value that can be used to check whether a resource has changed or not (in combination with the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.193.1">
       If-None-Match
      </span>
     </code>
     <span class="koboSpan" id="kobo.194.1">
      request header in the subsequent request to the same URL)
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.195.1">
     Old headers (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.196.1">
      Expires
     </span>
    </code>
    <span class="koboSpan" id="kobo.197.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.198.1">
      Last-Modified
     </span>
    </code>
    <span class="koboSpan" id="kobo.199.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.200.1">
      Pragma
     </span>
    </code>
    <span class="koboSpan" id="kobo.201.1">
     ), still supported for backward compatibility, are already superseded by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.202.1">
      Cache-Control
     </span>
    </code>
    <span class="koboSpan" id="kobo.203.1">
     header.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-277">
    <a id="_idTextAnchor296">
    </a>
    <span class="koboSpan" id="kobo.204.1">
     Example – caching product photos
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.205.1">
     We will demonstrate client-side caching using the standard HTTP headers on the product photo download endpoint created in
    </span>
    <a href="B21843_06.xhtml#_idTextAnchor135">
     <em class="italic">
      <span class="koboSpan" id="kobo.206.1">
       Chapter 6
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.207.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.208.1">
     Photos are
    </span>
    <a id="_idIndexMarker828">
    </a>
    <span class="koboSpan" id="kobo.209.1">
     relatively large data objects that are not expected to change very frequently, hence, they are a good candidate for caching.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.210.1">
     First, we will use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.211.1">
      Cache-Control
     </span>
    </code>
    <span class="koboSpan" id="kobo.212.1">
     header to specify the time the client can store the photo in the cache.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     Inside the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.213.1">
      ProductsApiController
     </span>
    </code>
    <span class="koboSpan" id="kobo.214.1">
     class, we will change the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.215.1">
      downloadProductPhoto
     </span>
    </code>
    <span class="koboSpan" id="kobo.216.1">
     method body to include the header, specifying 20 seconds as the time to cache the image:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.217.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.218.1">ResponseEntity</span></span><span class="koboSpan" id="kobo.219.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.220.1">ok</span></span><span class="koboSpan" id="kobo.221.1">()
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.222.1">contentType</span></span><span class="koboSpan" id="kobo.223.1">(
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.224.1">MediaType</span></span><span class="koboSpan" id="kobo.225.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.226.1">valueOf</span></span><span class="koboSpan" id="kobo.227.1">(photo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.228.1">getPhotoContentType</span></span><span class="koboSpan" id="kobo.229.1">()))
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.230.1">cacheControl</span></span><span class="koboSpan" id="kobo.231.1">(
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.232.1">CacheControl</span></span><span class="koboSpan" id="kobo.233.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.234.1">maxAge</span></span><span class="koboSpan" id="kobo.235.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.236.1">20</span></span><span class="koboSpan" id="kobo.237.1">, </span><span class="hljs-title"><span class="koboSpan" id="kobo.238.1">TimeUnit</span></span><span class="koboSpan" id="kobo.239.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.240.1">SECONDS</span></span><span class="koboSpan" id="kobo.241.1">))
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.242.1">body</span></span><span class="koboSpan" id="kobo.243.1">(photo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.244.1">getPhoto</span></span><span class="koboSpan" id="kobo.245.1">());
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.246.1">
     Now, we can start the Product API application and add a test product and its image by calling the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.247.1">
      PUT
     </span>
    </code>
    <span class="koboSpan" id="kobo.248.1">
     endpoints:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.249.1">curl -v -X PUT http://localhost:8080/api/products/AK12345 -d '{"name":"testprod235","description":"test description","price":123.45}' -H 'Content-Type: application/json'
curl -v -F "file=@/home/mv/Documents/image.jpeg" -X PUT http://localhost:8080/api/products/AK12345/photo
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.250.1">
     Please note that the caching header tells the client it can store the resource in its cache, but the client is not required to do so.
    </span>
    <span class="koboSpan" id="kobo.250.2">
     Simple clients may ignore the caching headers completely.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.251.1">
     We will use a web browser because it understands and supports the caching headers; however, it does not load the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.252.1">
      main
     </span>
    </code>
    <span class="koboSpan" id="kobo.253.1">
     resource (the one whose URL is entered in the address bar) from the cache.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     This is why we will create an HTML file named
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.254.1">
      refer_img.html
     </span>
    </code>
    <span class="koboSpan" id="kobo.255.1">
     that we will use as the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.256.1">
      main
     </span>
    </code>
    <span class="koboSpan" id="kobo.257.1">
     resource, and inside the HTML file we will refer to the image we want to download or cache:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.258.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.259.1">img</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.260.1">src</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.261.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.262.1">"http://localhost:8080/api/products/AK12345/photo"</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.263.1">/&gt;</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.264.1">
     Now, we can open a new browser tab and turn on the developer tools (by pressing
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.265.1">
      F12
     </span>
    </em>
    <span class="koboSpan" id="kobo.266.1">
     on Windows/Linux or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.267.1">
      Option
     </span>
    </em>
    <span class="koboSpan" id="kobo.268.1">
     +
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.269.1">
      ⌘
     </span>
    </em>
    <span class="koboSpan" id="kobo.270.1">
     +
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.271.1">
      I
     </span>
    </em>
    <span class="koboSpan" id="kobo.272.1">
     on Mac).
    </span>
    <span class="koboSpan" id="kobo.272.2">
     Within the developer tools, we switch to the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.273.1">
      Network
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     tab.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.275.1">
     We will open the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.276.1">
      refer_img.html
     </span>
    </code>
    <span class="koboSpan" id="kobo.277.1">
     file in the browser by dragging and dropping the file in the browser
    </span>
    <a id="_idIndexMarker829">
    </a>
    <span class="koboSpan" id="kobo.278.1">
     window.
    </span>
    <span class="koboSpan" id="kobo.278.2">
     When the HTML file is opened for the first time, the browser must make the HTTP request to download the image:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.279.1">
     <img alt="Figure 10.1 – Downloading a new resource that is not available in the cache yet" src="../Images/B21843_10_01.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.280.1">
     Figure 10.1 – Downloading a new resource that is not available in the cache yet
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.281.1">
     We can see the response headers, including
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.282.1">
      Cache-Control:
     </span>
    </strong>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.283.1">
      max-age=20
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.285.1">
     If we reload the page within 20 seconds, we should see the following:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.286.1">
     <img alt="Figure 10.2 – Browser using the cached resource" src="../Images/B21843_10_02.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.287.1">
     Figure 10.2 – Browser using the cached resource
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.288.1">
     The text next to
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.289.1">
      Status Code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     and the warning in the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.291.1">
      Request Headers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     section indicate that this time, no real network transmission has been done, and the cached image is displayed instead.
    </span>
    <span class="koboSpan" id="kobo.292.2">
     In the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.293.1">
      Response Headers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.294.1">
     section, we can see that the access time (the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.295.1">
      Date
     </span>
    </strong>
    <span class="koboSpan" id="kobo.296.1">
     header) is the same as before because the headers are cached as well.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.297.1">
     If we reload the page after more than 20 seconds, the image is freshly downloaded from the server, and we will see a new time as the value of the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.298.1">
      Date
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     header.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.300.1">
     Let’s make the
    </span>
    <a id="_idIndexMarker830">
    </a>
    <span class="koboSpan" id="kobo.301.1">
     caching more sophisticated with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.302.1">
      ETag
     </span>
    </code>
    <span class="koboSpan" id="kobo.303.1">
     header.
    </span>
    <span class="koboSpan" id="kobo.303.2">
     To make the value of the header change if and only if the image changes, we will compute the entity tag as a hash of the image bytes.
    </span>
    <span class="koboSpan" id="kobo.303.3">
     The following method computes the hash using the SHA-1 algorithm and converts it to a printable string using Base64 encoding:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.304.1">private </span><span class="hljs-title"><span class="koboSpan" id="kobo.305.1">String</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.306.1">getHashString</span></span><span class="koboSpan" id="kobo.307.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.308.1">byte[] bytes</span></span><span class="koboSpan" id="kobo.309.1">) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.310.1">try</span></span><span class="koboSpan" id="kobo.311.1"> {
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.312.1">MessageDigest</span></span><span class="koboSpan" id="kobo.313.1"> md =
            </span><span class="hljs-title"><span class="koboSpan" id="kobo.314.1">MessageDigest</span></span><span class="koboSpan" id="kobo.315.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.316.1">getInstance</span></span><span class="koboSpan" id="kobo.317.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.318.1">"SHA-1"</span></span><span class="koboSpan" id="kobo.319.1">);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.320.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.321.1">Base64</span></span><span class="koboSpan" id="kobo.322.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.323.1">getEncoder</span></span><span class="koboSpan" id="kobo.324.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.325.1">encodeToString</span></span><span class="koboSpan" id="kobo.326.1">(
            md.</span><span class="hljs-title"><span class="koboSpan" id="kobo.327.1">digest</span></span><span class="koboSpan" id="kobo.328.1">(bytes));
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">catch</span></span><span class="koboSpan" id="kobo.330.1"> (</span><span class="hljs-title"><span class="koboSpan" id="kobo.331.1">NoSuchAlgorithmException</span></span><span class="koboSpan" id="kobo.332.1"> e) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.333.1">throw</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.334.1">new</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.335.1">RuntimeException</span></span><span class="koboSpan" id="kobo.336.1">(e);
    }
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.337.1">
     Now, we can change the controller method to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.338.1">
      ETag
     </span>
    </code>
    <span class="koboSpan" id="kobo.339.1">
     header:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code">       <span class="hljs-keyword"><span class="koboSpan" id="kobo.340.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.341.1">ResponseEntity</span></span><span class="koboSpan" id="kobo.342.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.343.1">ok</span></span><span class="koboSpan" id="kobo.344.1">()
           .</span><span class="hljs-title"><span class="koboSpan" id="kobo.345.1">contentType</span></span><span class="koboSpan" id="kobo.346.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.347.1">MediaType</span></span><span class="koboSpan" id="kobo.348.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.349.1">valueOf</span></span><span class="koboSpan" id="kobo.350.1">(
               photo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.351.1">getPhotoContentType</span></span><span class="koboSpan" id="kobo.352.1">()))
           .</span><span class="hljs-title"><span class="koboSpan" id="kobo.353.1">eTag</span></span><span class="koboSpan" id="kobo.354.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.355.1">getHashString</span></span><span class="koboSpan" id="kobo.356.1">(photo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.357.1">getPhoto</span></span><span class="koboSpan" id="kobo.358.1">()))
           .</span><span class="hljs-title"><span class="koboSpan" id="kobo.359.1">body</span></span><span class="koboSpan" id="kobo.360.1">(photo.</span><span class="hljs-title"><span class="koboSpan" id="kobo.361.1">getPhoto</span></span><span class="koboSpan" id="kobo.362.1">());
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.363.1">
     After restarting the application, we can start testing again.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     The first load of the page will download the image normally:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.364.1">
     <img alt="Figure 10.3 – Browser downloading the resource with a new ETag" src="../Images/B21843_10_03.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.365.1">
     Figure 10.3 – Browser downloading the resource with a new ETag
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.366.1">
     The
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.367.1">
      Response Headers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.368.1">
     section
    </span>
    <a id="_idIndexMarker831">
    </a>
    <span class="koboSpan" id="kobo.369.1">
     contains the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.370.1">
      Etag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     header with the computed hash string.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.372.1">
     After that, no matter how long we wait, when reloading the page we will see the following:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.373.1">
     <img alt="Figure 10.4 – Server responding with “304 Not Modified” when the ETag value is matched" src="../Images/B21843_10_04.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.374.1">
     Figure 10.4 – Server responding with “304 Not Modified” when the ETag value is matched
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.375.1">
     The
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.376.1">
      Date
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     header
    </span>
    <a id="_idIndexMarker832">
    </a>
    <span class="koboSpan" id="kobo.378.1">
     is fresh, meaning the browser did send a real request to the server.
    </span>
    <span class="koboSpan" id="kobo.378.2">
     However, the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.379.1">
      Status code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.380.1">
     is
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.381.1">
      304 – Not Modified
     </span>
    </strong>
    <span class="koboSpan" id="kobo.382.1">
     , and no content is sent back.
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.383.1">
     <img alt="Figure 10.5 – No content is returned with the “304 Not Modified” response" src="../Images/B21843_10_05.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.384.1">
     Figure 10.5 – No content is returned with the “304 Not Modified” response
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.385.1">
     This is because
    </span>
    <a id="_idIndexMarker833">
    </a>
    <span class="koboSpan" id="kobo.386.1">
     the browser, when making the request, sent the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.387.1">
      If-None-Match
     </span>
    </code>
    <span class="koboSpan" id="kobo.388.1">
     request header containing the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.389.1">
      ETag
     </span>
    </code>
    <span class="koboSpan" id="kobo.390.1">
     value it got in the previous request.
    </span>
    <span class="koboSpan" id="kobo.390.2">
     Spring Framework automatically compares the value with the newly computed one, and if they match, it returns the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.391.1">
      304
     </span>
    </code>
    <span class="koboSpan" id="kobo.392.1">
     status in the response.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.393.1">
     Let’s check what happens when we upload a new image:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.394.1">curl -v -F "file=@/home/mv/Documents/image2.jpeg" -X PUT http://localhost:8080/api/products/AK12345/photo
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.395.1">
     On the next reload of the page, we get this:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.396.1">
     <img alt="Figure 10.6 – Server responding with “200 OK” and the full content when ETag not matched" src="../Images/B21843_10_06.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.397.1">
     Figure 10.6 – Server responding with “200 OK” and the full content when ETag not matched
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.398.1">
     As the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.399.1">
      Etag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     value has changed, the full content is returned, and the status code is
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.401.1">
      200 OK
     </span>
    </strong>
    <span class="koboSpan" id="kobo.402.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-278">
    <a id="_idTextAnchor297">
    </a>
    <span class="koboSpan" id="kobo.403.1">
     Command Query Responsibility Segregation (CQRS)
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.404.1">
     The
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.405.1">
      Command Query Responsibility Segregation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.407.1">
      CQRS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.408.1">
     ) pattern is designed to separate read and
    </span>
    <a id="_idIndexMarker834">
    </a>
    <span class="koboSpan" id="kobo.409.1">
     write operations, improving performance and scalability in applications.
    </span>
    <span class="koboSpan" id="kobo.409.2">
     By separating data modification (commands) from data
    </span>
    <a id="_idIndexMarker835">
    </a>
    <span class="koboSpan" id="kobo.410.1">
     retrieval (queries), each operation can be optimized independently.
    </span>
    <span class="koboSpan" id="kobo.410.2">
     This separation is particularly useful in applications where read and write operations require different scalability strategies.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.411.1">
     For instance, an application with high read traffic can scale read operations without affecting write performance.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     This prevents slowdowns during read operations when resource-intensive write processes occur.
    </span>
    <span class="koboSpan" id="kobo.411.3">
     In our example from
    </span>
    <a href="B21843_02.xhtml#_idTextAnchor050">
     <em class="italic">
      <span class="koboSpan" id="kobo.412.1">
       Chapter 2
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.413.1">
     , we applied CQRS principles in a single application, but in practice, CQRS typically involves deploying two separate applications: one handling reads and the other handling writes.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.414.1">
     By segregating read and write responsibilities, CQRS improves application performance by eliminating dependency between these operations, enabling independent scaling.
    </span>
    <span class="koboSpan" id="kobo.414.2">
     To ensure both applications share the same API endpoint, a gateway can be used to redirect traffic to the correct application based on the operation being performed.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-279">
    <a id="_idTextAnchor298">
    </a>
    <span class="koboSpan" id="kobo.415.1">
     Echoing request data is not required
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.416.1">
     When implementing a POST or PUT endpoint, a commonly used convention is to return the created or updated entity in the HTTP response body.
    </span>
    <span class="koboSpan" id="kobo.416.2">
     We even use this pattern in the design and code examples in our book.
    </span>
    <span class="koboSpan" id="kobo.416.3">
     This pattern is usually connected to the reuse of data models: we already have a model for the entity that is used in the request and in the GET response, so why not use it also for the POST and PUT responses?
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.417.1">
     There is nothing in the HTTP protocol or REST architecture telling us to echo back what we got in a POST or PUT request.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     On the contrary, there are some arguments against it:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.418.1">
      Waste of network bandwidth and an increase in response time, especially for large entities.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.419.1">
      The client already has the data because it has just sent them in the request.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.420.1">
      It can lead to incorrect assumptions on the client side that the returned data are always up to date, but that might not be true if some other request on the same entity is performed in parallel.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.421.1">
     Even if there is some additional information generated on the server, why do we automatically assume that the client needs the modified parts or the whole entity data?
    </span>
    <span class="koboSpan" id="kobo.421.2">
     It breaks the single responsibility principle: a POST or PUT is expected to do a create/update.
    </span>
    <span class="koboSpan" id="kobo.421.3">
     If the client needs to read the data, it can send a GET request.
    </span>
    <span class="koboSpan" id="kobo.421.4">
     Different models for the read and write operations are also a natural consequence of applying the CQRS principle explained earlier in this chapter.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-280">
    <a id="_idTextAnchor299">
    </a>
    <span class="koboSpan" id="kobo.422.1">
     Asynchronous processing
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.423.1">
     HTTP, the heart of RESTful web services, is built around the synchronous request-response style of
    </span>
    <a id="_idIndexMarker836">
    </a>
    <span class="koboSpan" id="kobo.424.1">
     communication, making it easy to understand and implement.
    </span>
    <span class="koboSpan" id="kobo.424.2">
     When talking about asynchronous APIs, we usually think of systems based on message brokers using protocols other than HTTP.
    </span>
    <span class="koboSpan" id="kobo.424.3">
     Messaging-based communication is one of the
    </span>
    <a id="_idIndexMarker837">
    </a>
    <span class="koboSpan" id="kobo.425.1">
     main alternatives to RESTful web services mentioned in
    </span>
    <a href="B21843_01.xhtml#_idTextAnchor015">
     <em class="italic">
      <span class="koboSpan" id="kobo.426.1">
       Chapter 1
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.427.1">
     .
    </span>
    <span class="koboSpan" id="kobo.427.2">
     However, HTTP can also support asynchronous processing.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.428.1">
     If the operation to be exposed via a REST API involves processing that takes a long time, waiting for the processing to finish before returning a response blocks the API client makes the API seem unresponsive and may lead to time-outs.
    </span>
    <span class="koboSpan" id="kobo.428.2">
     The responsiveness of such an API can be improved by returning a response immediately after reading the request and saving the input data from it in reliable storage.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.429.1">
     The standard response status code in this case is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.430.1">
      202 - Accepted
     </span>
    </code>
    <span class="koboSpan" id="kobo.431.1">
     .
    </span>
    <span class="koboSpan" id="kobo.431.2">
     The long-running processing can continue asynchronously without blocking the client.
    </span>
    <span class="koboSpan" id="kobo.431.3">
     A separate API endpoint can be provided for the client to poll the status of the processing and receive its results when finished.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.432.1">
     For example, suppose we wanted to improve the photo upload endpoint of our example Product API so that it scales the photo to standard dimensions or performs other graphics enhancements on it.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     This kind of processing can be time-consuming.
    </span>
    <span class="koboSpan" id="kobo.432.3">
     In such cases, we can decide to change the upload endpoint to an asynchronous one.
    </span>
    <span class="koboSpan" id="kobo.432.4">
     We would store the unprocessed photo and return a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.433.1">
      202
     </span>
    </code>
    <span class="koboSpan" id="kobo.434.1">
     status code.
    </span>
    <span class="koboSpan" id="kobo.434.2">
     The photo enhancement would be done asynchronously and a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.435.1">
      GET
     </span>
    </code>
    <span class="koboSpan" id="kobo.436.1">
     endpoint would be available for checking whether the photo is ready for use.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.437.1">
     After explaining how to ensure performance and scalability using general approaches at the level of analysis, design, and the HTTP standard, in the next section, we will move more to the level of implementation and focus on one feature of current versions of the Java platform that is particularly relevant to the performance and scalability of applications communicating using APIs.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-281">
    <a id="_idTextAnchor300">
    </a>
    <span class="koboSpan" id="kobo.438.1">
     Increasing the throughput with virtual threads
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.439.1">
     Virtual threads
    </span>
    <a id="_idIndexMarker838">
    </a>
    <span class="koboSpan" id="kobo.440.1">
     are a Java feature (final since Java 21) related to the performance of concurrent processing, a topic highly relevant to API implementation.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     All server-side applications are concurrent because they must handle concurrent incoming requests.
    </span>
    <span class="koboSpan" id="kobo.440.3">
     However, with Java server-side frameworks such as Spring Boot, the code can focus on just one request using the so-called thread-per-request model.
    </span>
    <span class="koboSpan" id="kobo.440.4">
     More advanced applications may need multiple threads per request.
    </span>
    <span class="koboSpan" id="kobo.440.5">
     We will explore both usages of concurrency in the following subsections.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-282">
    <a id="_idTextAnchor301">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     Garbage collector for threads
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.442.1">
     Before going into more exact and detailed descriptions, let’s use a simple metaphor to explain the point
    </span>
    <a id="_idIndexMarker839">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     of virtual threads even to developers who may find threads and concurrency difficult to understand.
    </span>
    <span class="koboSpan" id="kobo.443.2">
     All Java developers must understand the concept of garbage collection, which is an abstraction that the Java Virtual Machine provides to liberate developers from the responsibility for allocating and freeing memory.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.444.1">
     Of course, you can still get an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.445.1">
      OutOfMemoryError
     </span>
    </code>
    <span class="koboSpan" id="kobo.446.1">
     , but if your application uses the objects in a typical way, at some point objects that are not used anymore are not referenced from any other object, so the runtime can detect those objects automatically, and thus the memory they occupy can be freed and reused.
    </span>
    <span class="koboSpan" id="kobo.446.2">
     This abstraction, used by programmers since the very first version of Java, simplifies the code and prevents many hard-to-detect errors related to direct memory access and allocation known from programming in C or other languages without a garbage collector.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.447.1">
     Similarly to what a garbage collector does with memory, virtual threads provide the illusion of an (almost) infinite number of threads.
    </span>
    <span class="koboSpan" id="kobo.447.2">
     What really happens is, in a typical application using one thread per incoming network request (more on that in the next section), the JVM, together with the standard libraries, can automatically detect when the platform thread would be blocked due to waiting (e.g., for I/O).
    </span>
    <span class="koboSpan" id="kobo.447.3">
     To prevent this, the virtual thread state is moved to the heap, and the platform thread is reused to work on some other request.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.448.1">
     For most applications, relying on virtual threads to efficiently utilize platform threads, rather than using platform threads directly, will likely depend on the garbage collector to clean up memory objects at the end of each request.
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.449.1">
     <img alt="Figure 10.7 – Illustration of how virtual threads work, split into layers" src="../Images/B21843_10_07.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.450.1">
     Figure 10.7 – Illustration of how virtual threads work, split into layers
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-283">
    <a id="_idTextAnchor302">
    </a>
    <span class="koboSpan" id="kobo.451.1">
     Thread-per-request model
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.452.1">
     Our example
    </span>
    <a id="_idIndexMarker840">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     APIs are implemented using Spring Web, a framework using the thread-per-request model.
    </span>
    <span class="koboSpan" id="kobo.453.2">
     This means that for every HTTP request, the web server used by the framework takes a dedicated Java thread and, within that thread, it invokes the controller method matching the request path and method.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.454.1">
     The advantage of the thread-per-request model is that it allows the classic imperative programming style with code blocks containing statements executed in the order they appear in the source code.
    </span>
    <span class="koboSpan" id="kobo.454.2">
     This code style is easy to read and understand.
    </span>
    <span class="koboSpan" id="kobo.454.3">
     It is also easy to debug because when the execution stays within one thread, the call stack displayed in debugging tools is complete, letting the developer track the method invocations n
    </span>
    <a id="_idTextAnchor303">
    </a>
    <span class="koboSpan" id="kobo.455.1">
     icely at all code levels.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.456.1">
     Unfortunately, the thread-per-request model without virtual threads has limited scalability because the threads provided by the operating system (so-called platform threads) are an expensive resource.
    </span>
    <span class="koboSpan" id="kobo.456.2">
     Every platform thread occupies a considerable amount of memory, so the number of platform threads a JVM can use is limited.
    </span>
    <span class="koboSpan" id="kobo.456.3">
     Web servers using platform threads must take
    </span>
    <a id="_idIndexMarker841">
    </a>
    <span class="koboSpan" id="kobo.457.1">
     a thread that is needed to handle an incoming request from a limited thread pool.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     If there are no threads left in the pool, the request waits until a thread is available.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.458.1">
     The controller method and any methods invoked from the controller method (let’s call it handling code) hold the dedicated thread until the controller method returns or throws, transferring the execution back to the Spring Web framework.
    </span>
    <span class="koboSpan" id="kobo.458.2">
     It is quite common that the handling code contains blocking operations.
    </span>
    <span class="koboSpan" id="kobo.458.3">
     A blocking operation prevents the CPU from performing useful work because it halts execution while waiting for required data.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.459.1">
     To illustrate this, let’s look at the execution of the “create order” operation of the Order Management API.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.460.1">
     Let’s first look at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.461.1">
      OrderManagementApiController.java
     </span>
    </code>
    <span class="koboSpan" id="kobo.462.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.463.1">    public </span><span class="hljs-title"><span class="koboSpan" id="kobo.464.1">ResponseEntity</span></span><span class="koboSpan" id="kobo.465.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.466.1">OrderResponseDto</span></span><span class="koboSpan" id="kobo.467.1">&gt; </span><span class="hljs-title"><span class="koboSpan" id="kobo.468.1">ordersPost</span></span><span class="koboSpan" id="kobo.469.1">(
</span><span class="hljs-params"><span class="koboSpan" id="kobo.470.1">        OrderRequestBodyDto orderRequestBody</span></span><span class="koboSpan" id="kobo.471.1">) {
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.472.1">// ^ involves deserialization from JSON (CPU usage)</span></span><span class="koboSpan" id="kobo.473.1">
            final </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">var</span></span><span class="koboSpan" id="kobo.475.1"> order = ordersCommandUseCase.</span><span class="hljs-title"><span class="koboSpan" id="kobo.476.1">createOrder</span></span><span class="koboSpan" id="kobo.477.1">(
                orderMapper.</span><span class="hljs-title"><span class="koboSpan" id="kobo.478.1">toOrderRequest</span></span><span class="koboSpan" id="kobo.479.1">(orderRequestBody));
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">return</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.481.1">ResponseEntity</span></span><span class="koboSpan" id="kobo.482.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.483.1">status</span></span><span class="koboSpan" id="kobo.484.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.485.1">HttpStatus</span></span><span class="koboSpan" id="kobo.486.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.487.1">CREATED</span></span><span class="koboSpan" id="kobo.488.1">)
            .</span><span class="hljs-title"><span class="koboSpan" id="kobo.489.1">body</span></span><span class="koboSpan" id="kobo.490.1">(orderMapper.</span><span class="hljs-title"><span class="koboSpan" id="kobo.491.1">toOrderResponse</span></span><span class="koboSpan" id="kobo.492.1">(order));
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.493.1">// ^ involves serialization to JSON (CPU usage)</span></span><span class="koboSpan" id="kobo.494.1">
        }
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.495.1">
     Next, let’s see
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.496.1">
      OrdersCommandUseCaseImpl.java
     </span>
    </code>
    <span class="koboSpan" id="kobo.497.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.498.1">    public </span><span class="hljs-title"><span class="koboSpan" id="kobo.499.1">Order</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.500.1">createOrder</span></span><span class="koboSpan" id="kobo.501.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.502.1">OrderRequest orderRequest</span></span><span class="koboSpan" id="kobo.503.1">) {
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.504.1">updateProductPrice</span></span><span class="koboSpan" id="kobo.505.1">(orderRequest.</span><span class="hljs-title"><span class="koboSpan" id="kobo.506.1">products</span></span><span class="koboSpan" id="kobo.507.1">());
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.508.1">// ^ involves I/O</span></span>
        <span class="hljs-title"><span class="koboSpan" id="kobo.509.1">Order</span></span><span class="koboSpan" id="kobo.510.1"> order = orderMapper.</span><span class="hljs-title"><span class="koboSpan" id="kobo.511.1">toOrder</span></span><span class="koboSpan" id="kobo.512.1">(orderRequest);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.513.1">return</span></span><span class="koboSpan" id="kobo.514.1"> ordersRepository.</span><span class="hljs-title"><span class="koboSpan" id="kobo.515.1">save</span></span><span class="koboSpan" id="kobo.516.1">(</span><span class="hljs-comment"><span class="koboSpan" id="kobo.517.1">// involves I/O</span></span>
            <span class="hljs-title"><span class="koboSpan" id="kobo.518.1">OrderEntity</span></span><span class="koboSpan" id="kobo.519.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.520.1">fromOrder</span></span><span class="koboSpan" id="kobo.521.1">(order, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.522.1">null</span></span><span class="koboSpan" id="kobo.523.1">));
        }
    private </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.524.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.525.1">updateProductPrice</span></span><span class="koboSpan" id="kobo.526.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.527.1">List&lt;Product&gt; products</span></span><span class="koboSpan" id="kobo.528.1">) {
        products.</span><span class="hljs-title"><span class="koboSpan" id="kobo.529.1">forEach</span></span><span class="koboSpan" id="kobo.530.1">(orderProduct -&gt; {
            </span><span class="hljs-title"><span class="koboSpan" id="kobo.531.1">ProductDetails</span></span><span class="koboSpan" id="kobo.532.1"> catalogueProduct =
            productsQueryUseCase.</span><span class="hljs-title"><span class="koboSpan" id="kobo.533.1">getProductById</span></span><span class="koboSpan" id="kobo.534.1">(
                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.535.1">// ^ involves I/O</span></span><span class="koboSpan" id="kobo.536.1">
                orderProduct.</span><span class="hljs-title"><span class="koboSpan" id="kobo.537.1">getProductSKU</span></span><span class="koboSpan" id="kobo.538.1">());
            orderProduct.</span><span class="hljs-title"><span class="koboSpan" id="kobo.539.1">setPrice</span></span><span class="koboSpan" id="kobo.540.1">(
                catalogueProduct.</span><span class="hljs-title"><span class="koboSpan" id="kobo.541.1">price</span></span><span class="koboSpan" id="kobo.542.1">());
        });
    }
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.543.1">
     Blocking operations (commonly caused by the need for network I/O communication) can have a disastrous performance impact because, in many applications, they take orders of magnitude longer than the surrounding non-blocking (CPU-heavy) operations.
    </span>
    <span class="koboSpan" id="kobo.543.2">
     Communication is an essential part of the processing within distributed applications (microservices).
    </span>
    <span class="koboSpan" id="kobo.543.3">
     It is important to understand that the time spent waiting for data to be transferred
    </span>
    <a id="_idIndexMarker842">
    </a>
    <span class="koboSpan" id="kobo.544.1">
     over a remote API (or from a complex database query) is typically hundreds of milliseconds to seconds.
    </span>
    <span class="koboSpan" id="kobo.544.2">
     In contrast, the CPU processing time needed to perform the business logic of most enterprise applications once all the data is available (even if we consider more complex operations such as JSON parsing and serialization) is orders of magnitude shorter – it is counted in microseconds.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.545.1">
     This means that with a thread-per-request model, the CPU that is blocked by the input/output operations cannot be used to serve other requests; in a service under heavy load, more than 99% of the time, the CPU will be idle.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.546.1">
     One way to address this problem is to use a reactive programming framework (more on that in
    </span>
    <a href="B21843_11.xhtml#_idTextAnchor310">
     <em class="italic">
      <span class="koboSpan" id="kobo.547.1">
       Chapter 11
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.548.1">
     ), but that means abandoning the thread-per-request model with its advantages described previously: code that is easy to understand and debug.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.549.1">
     Virtual threads are clever because they let developers keep the thread-per-request model while allowing efficient use of the platform threads.
    </span>
    <span class="koboSpan" id="kobo.549.2">
     When a virtual thread needs to use the CPU, it is mounted on a platform thread (also called a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.550.1">
      carrier thread
     </span>
    </em>
    <span class="koboSpan" id="kobo.551.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.551.2">
     When a virtual thread hits a blocking operation, its state of execution is stored in the heap memory and its carrier thread is released so that it can be used to execute a different virtual thread.
    </span>
    <span class="koboSpan" id="kobo.551.3">
     When the blocking operation finishes, the virtual thread can mount any free carrier thread (that can be different from the one it used before getting blocked), restore its state from the heap, and continue its execution.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.552.1">
     Virtual threads, in contrast to platform threads, are cheap, so an application can use millions of them.
    </span>
    <span class="koboSpan" id="kobo.552.2">
     An HTTP server and an application framework can provide a new virtual thread for every incoming request, no matter how many requests are already waiting for an I/O operation.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.553.1">
     To use virtual threads to process incoming requests, you just need to configure the framework to turn on the feature.
    </span>
    <span class="koboSpan" id="kobo.553.2">
     With Spring Boot 3.2 or later and Java 21 or later, you can use the following configuration property:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.554.1">spring.</span><span class="hljs-property"><span class="koboSpan" id="kobo.555.1">threads</span></span><span class="koboSpan" id="kobo.556.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.557.1">virtual</span></span><span class="koboSpan" id="kobo.558.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.559.1">enabled</span></span><span class="koboSpan" id="kobo.560.1">=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.561.1">true</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.562.1">
     You can
    </span>
    <a id="_idIndexMarker843">
    </a>
    <span class="koboSpan" id="kobo.563.1">
     continue using the code style containing the blocking operations, knowing that the blocked threads will be virtual ones, and the CPU will be used efficiently.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.564.1">
     Besides handling many incoming requests using the thread-per-request model, an application may need to explicitly perform multiple operations in parallel to handle just one incoming request.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-284">
    <a id="_idTextAnchor304">
    </a>
    <span class="koboSpan" id="kobo.565.1">
     Parallel processing within one request
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.566.1">
     In the context of integration-heavy applications, a common case is optimizing the latency when handling the request requires multiple independent remote APIs to be called.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.567.1">
     Imagine
    </span>
    <a id="_idIndexMarker844">
    </a>
    <span class="koboSpan" id="kobo.568.1">
     a price quote API that calls the APIs of multiple vendors, compares their prices, and responds with the best one.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.569.1">
     Java provides a useful abstraction in the form of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.570.1">
      ExecutorService
     </span>
    </code>
    <span class="koboSpan" id="kobo.571.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.571.2">
     Each operation that should be executed in parallel is a task that you submit to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.572.1">
      ExecutorService
     </span>
    </code>
    <span class="koboSpan" id="kobo.573.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.574.1">
     When the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.575.1">
      ExecutorService
     </span>
    </code>
    <span class="koboSpan" id="kobo.576.1">
     class is created, you specify a strategy it should use to manage the threads that execute the tasks.
    </span>
    <span class="koboSpan" id="kobo.576.2">
     Without virtual threads, the typical strategy would be to use a thread pool of a fixed size.
    </span>
    <span class="koboSpan" id="kobo.576.3">
     The thread pool allows a certain number of parallel tasks, but the number is limited because the number of platform threads is limited.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.577.1">
     With virtual threads, we can let
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.578.1">
      ExecutorService
     </span>
    </code>
    <span class="koboSpan" id="kobo.579.1">
     use a new virtual thread for every task without a thread pool and without having to specify the size of that pool:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title"><span class="koboSpan" id="kobo.580.1">try</span></span><span class="koboSpan" id="kobo.581.1"> (</span><span class="hljs-title"><span class="koboSpan" id="kobo.582.1">ExecutorService</span></span><span class="koboSpan" id="kobo.583.1"> es = </span><span class="hljs-title"><span class="koboSpan" id="kobo.584.1">Executors</span></span><span class="koboSpan" id="kobo.585.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.586.1">newVirtualThreadPerTaskExecutor</span></span><span class="koboSpan" id="kobo.587.1">()) {
    es.</span><span class="hljs-title"><span class="koboSpan" id="kobo.588.1">submit</span></span><span class="koboSpan" id="kobo.589.1">(()-&gt; { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.590.1">/* task 1 */</span></span><span class="koboSpan" id="kobo.591.1"> });
    es.</span><span class="hljs-title"><span class="koboSpan" id="kobo.592.1">submit</span></span><span class="koboSpan" id="kobo.593.1">(()-&gt; { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.594.1">/* task 2 */</span></span><span class="koboSpan" id="kobo.595.1"> });
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.596.1">// ...</span></span><span class="koboSpan" id="kobo.597.1">
};
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.598.1">
     We have briefly explained that, in a nutshell, virtual threads enhance CPU efficiency by minimizing idle threads and ensuring more time is spent performing useful operations.
    </span>
    <span class="koboSpan" id="kobo.598.2">
     The immediate effect of that is an increase in throughput (the amount of work done per unit of time).
    </span>
    <span class="koboSpan" id="kobo.598.3">
     However, throughput and response time are usually connected.
    </span>
    <span class="koboSpan" id="kobo.598.4">
     The increased throughput means that a given CPU power can handle a higher load without some of the requests having to wait for a thread to become available.
    </span>
    <span class="koboSpan" id="kobo.598.5">
     Consequently, the response time can be improved as well.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.599.1">
     So far, we have discussed ways to improve performance and scalability that can be applied mostly within individual services.
    </span>
    <span class="koboSpan" id="kobo.599.2">
     However, the infrastructure components that reside between the individual components connected by APIs are usually also involved in achieving satisfactory performance and scalability of the entire distributed system (the application).
    </span>
    <span class="koboSpan" id="kobo.599.3">
     The following section will briefly introduce you to these infrastructure components.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-285">
    <a id="_idTextAnchor305">
    </a>
    <span class="koboSpan" id="kobo.600.1">
     Virtual thread pinning
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.601.1">
     There are situations when a virtual thread performing a blocking operation cannot release the platform thread for other virtual threads.
    </span>
    <span class="koboSpan" id="kobo.601.2">
     Using the official terminology for this situation, we say that
    </span>
    <a id="_idIndexMarker845">
    </a>
    <span class="koboSpan" id="kobo.602.1">
     the virtual thread cannot unmount from its carrier because the virtual thread is pinned to the carrier thread.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.603.1">
     As of Java 21, thread pinning can occur in two cases.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.604.1">
     The first case of thread pinning is when the virtual thread is performing a native code.
    </span>
    <span class="koboSpan" id="kobo.604.2">
     This is inevitable because the JVM cannot take away the platform thread from the non-Java code safely.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.605.1">
     The second case is when the virtual thread runs code inside a synchronized block or method.
    </span>
    <span class="koboSpan" id="kobo.605.2">
     This is a limitation of the implementation of the support for virtual threads within JVM.
    </span>
    <span class="koboSpan" id="kobo.605.3">
     If your application code or the code of some of its dependencies (web server or libraries) uses Java synchronized constructs, it may limit the performance of virtual threads compared to the expectation.
    </span>
    <span class="koboSpan" id="kobo.605.4">
     In some cases, it can even lead to deadlocks where all the available platform threads are blocked by pinned threads waiting on a synchronized lock.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.606.1">
     This means you should not turn on virtual threads blindly.
    </span>
    <span class="koboSpan" id="kobo.606.2">
     It is recommended to run performance tests on your application with and without virtual threads.
    </span>
    <span class="koboSpan" id="kobo.606.3">
     You should be aware of your application dependencies and try to use the latest versions of them.
    </span>
    <span class="koboSpan" id="kobo.606.4">
     Remember that Spring Boot uses the embedded Tomcat as the web server (servlet container) by default, but it also supports switching to other web servers.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.607.1">
     The pinning of virtual threads caused by the synchronized constructs is eliminated in Java 24.
    </span>
    <span class="koboSpan" id="kobo.607.2">
     So, even if the Java version you use supports all the features your application needs, it is always a good idea to upgrade to a new Java version as soon as possible to get fixes and improvements to the implementation of the Java features you use.
    </span>
    <span class="koboSpan" id="kobo.607.3">
     New versions of Java/OpenJDK also come with improvements in tooling that can help to diagnose and fix various performance problems, possibly including virtual thread pinning.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-286">
    <a id="_idTextAnchor306">
    </a>
    <span class="koboSpan" id="kobo.608.1">
     Using infrastructure support
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.609.1">
     Ideally, you want to design and implement your APIs so they can work well without depending on a
    </span>
    <a id="_idIndexMarker846">
    </a>
    <span class="koboSpan" id="kobo.610.1">
     specific infrastructure setup.
    </span>
    <span class="koboSpan" id="kobo.610.2">
     However, software developers should be aware that components external to the services they develop can be used to enhance the performance and scalability of the system.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.611.1">
     There are several types of infrastructure components:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.612.1">
       Load balancer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.613.1">
      : A
     </span>
     <a id="_idIndexMarker847">
     </a>
     <span class="koboSpan" id="kobo.614.1">
      component distributes
     </span>
     <a id="_idIndexMarker848">
     </a>
     <span class="koboSpan" id="kobo.615.1">
      the requests among multiple service instances providing the same API.
     </span>
     <span class="koboSpan" id="kobo.615.2">
      A load balancer is inevitable for horizontal scaling.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.616.1">
       Proxy
      </span>
     </strong>
     <span class="koboSpan" id="kobo.617.1">
      : A component
     </span>
     <a id="_idIndexMarker849">
     </a>
     <span class="koboSpan" id="kobo.618.1">
      that is an HTTP server and
     </span>
     <a id="_idIndexMarker850">
     </a>
     <span class="koboSpan" id="kobo.619.1">
      client at the same time.
     </span>
     <span class="koboSpan" id="kobo.619.2">
      It receives a request and fulfills it by making another request to the actual service providing the API.
     </span>
     <span class="koboSpan" id="kobo.619.3">
      Proxies let us add various functionalities between the client and the server, of which caching is the most important one for performance:
     </span>
     <ul>
      <li class="bulletList">
       <span class="koboSpan" id="kobo.620.1">
        A proxy that receives requests with public URLs and turns them into requests within
       </span>
       <a id="_idIndexMarker851">
       </a>
       <span class="koboSpan" id="kobo.621.1">
        a private network is called a
       </span>
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.622.1">
         reverse proxy
        </span>
       </strong>
       <span class="koboSpan" id="kobo.623.1">
        .
       </span>
      </li>
      <li class="bulletList">
       <span class="koboSpan" id="kobo.624.1">
        Proxies combining
       </span>
       <a id="_idIndexMarker852">
       </a>
       <span class="koboSpan" id="kobo.625.1">
        different functionalities supporting APIs are also called
       </span>
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.626.1">
         API gateways
        </span>
       </strong>
       <span class="koboSpan" id="kobo.627.1">
        .
       </span>
      </li>
     </ul>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.628.1">
       Content delivery network (CDN)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.629.1">
      : This
     </span>
     <a id="_idIndexMarker853">
     </a>
     <span class="koboSpan" id="kobo.630.1">
      is a network of proxies that are geographically distributed
     </span>
     <a id="_idIndexMarker854">
     </a>
     <span class="koboSpan" id="kobo.631.1">
      so that a client can access a URL via a nearby proxy, shortening the response times.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.632.1">
     The components mentioned here often combine performance and security concerns.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     One problem where
    </span>
    <a id="_idIndexMarker855">
    </a>
    <span class="koboSpan" id="kobo.633.1">
     the overlap is obvious is the deflecting of
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.634.1">
      denial of service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.635.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.636.1">
      DoS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.637.1">
     ) and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.638.1">
      distributed denial of service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.639.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.640.1">
      DDoS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     ) attacks.
    </span>
    <span class="koboSpan" id="kobo.641.2">
     It involves throttling, which is
    </span>
    <a id="_idIndexMarker856">
    </a>
    <span class="koboSpan" id="kobo.642.1">
     limiting excessive traffic from one source to ensure that the service remains available to all its clients.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.643.1">
     It follows from this that the architecture in which an API-providing service is embedded may contain multiple components that are often beyond the control of the API developers.
    </span>
    <span class="koboSpan" id="kobo.643.2">
     This is another reason the best possible approach to API design is to adhere to the standards defined by HTTP and other internet standards (RFCs).
    </span>
    <span class="koboSpan" id="kobo.643.3">
     This will ensure that your API works well with the surrounding infrastructure.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.644.1">
     We have gone through several possible performance and scalability issues, along with ways to address them.
    </span>
    <span class="koboSpan" id="kobo.644.2">
     However, in the last section of this chapter, it is essential to show how to examine the performance of a particular service under a particular workload, because only in this way can the real problems be detected and targeted for resolution.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-287">
    <a id="_idTextAnchor307">
    </a>
    <span class="koboSpan" id="kobo.645.1">
     Designing and executing effective load tests
    </span>
   </h1>
   <p class="normal">
    <a href="B21843_08.xhtml#_idTextAnchor223">
     <em class="italic">
      <span class="koboSpan" id="kobo.646.1">
       Chapter 8
      </span>
     </em>
    </a>
    <span class="koboSpan" id="kobo.647.1">
     explained various the tests that can be used to ensure the correctness of APIs, meaning that these tests check that the APIs and services behind them process the input data as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.648.1">
      expected
     </span>
    </code>
    <span class="koboSpan" id="kobo.649.1">
     and respond with the expected output data.
    </span>
    <span class="koboSpan" id="kobo.649.2">
     They focus on the exact values of the detailed
    </span>
    <a id="_idIndexMarker857">
    </a>
    <span class="koboSpan" id="kobo.650.1">
     attributes of the input and output data and their semantics to verify the functional requirements of the application.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     To do so, they try different
    </span>
    <a id="_idIndexMarker858">
    </a>
    <span class="koboSpan" id="kobo.651.1">
     test data combinations to cover the most common use cases as well as negative scenarios and edge cases.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.652.1">
     In the context of performance and scalability, we test the application from a different angle.
    </span>
    <span class="koboSpan" id="kobo.652.2">
     Instead of categorizing test cases by functional requirements and checking the exact data values, we usually try a smaller set of use cases characterized by the expected load they put on the application.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.653.1">
     However, the number of repetitions of identical or very similar requests sent to the application will be significantly higher.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     The timing aspect is very important, so the requests are made at a frequency that simulates real traffic, including load fluctuations.
    </span>
    <span class="koboSpan" id="kobo.653.3">
     Multiple simultaneous requests are sent to simulate many users using the application at the same time.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.654.1">
     These differences in load testing in comparison to the other types of test imply that although it is possible to use the same tools for both, doing load testing using tools that specialize in it is easier, more resource-efficient, and provides results that are more accurate and presented in an appropriate form.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-288">
    <a id="_idTextAnchor308">
    </a>
    <span class="koboSpan" id="kobo.655.1">
     Example – load-testing the Order Management API
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.656.1">
     We will load-test
    </span>
    <a id="_idIndexMarker859">
    </a>
    <span class="koboSpan" id="kobo.657.1">
     our example Order Management API using the tool called Gatling (its documentation
    </span>
    <a id="_idIndexMarker860">
    </a>
    <span class="koboSpan" id="kobo.658.1">
     is available at
    </span>
    <a href="https://docs.gatling.io/">
     <span class="url">
      <span class="koboSpan" id="kobo.659.1">
       https://docs.gatling.io/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.660.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.660.2">
     Gatling
    </span>
    <a id="_idIndexMarker861">
    </a>
    <span class="koboSpan" id="kobo.661.1">
     integrates with Java very well, so we can include the load test in our Java source code and run it using a Maven plugin without having to install a separate program.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.662.1">
     First, we will add the Gatling dependencies (with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.663.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.664.1">
     scope) to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.665.1">
      pom.xml
     </span>
    </code>
    <span class="koboSpan" id="kobo.666.1">
     file:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-tag"><span class="koboSpan" id="kobo.667.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.668.1">dependency</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.669.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.670.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.671.1">groupId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.672.1">&gt;</span></span><span class="koboSpan" id="kobo.673.1">io.gatling</span><span class="hljs-tag"><span class="koboSpan" id="kobo.674.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.675.1">groupId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.676.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.677.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.678.1">artifactId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.679.1">&gt;</span></span><span class="koboSpan" id="kobo.680.1">gatling-app</span><span class="hljs-tag"><span class="koboSpan" id="kobo.681.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.682.1">artifactId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.683.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.684.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.685.1">version</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.686.1">&gt;</span></span><span class="koboSpan" id="kobo.687.1">3.7.2</span><span class="hljs-tag"><span class="koboSpan" id="kobo.688.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.689.1">version</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.690.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.691.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.692.1">scope</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.693.1">&gt;</span></span><span class="koboSpan" id="kobo.694.1">test</span><span class="hljs-tag"><span class="koboSpan" id="kobo.695.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.696.1">scope</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.697.1">&gt;</span></span>
        <span class="hljs-tag"><span class="koboSpan" id="kobo.698.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.699.1">dependency</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.700.1">&gt;</span></span>
        <span class="hljs-tag"><span class="koboSpan" id="kobo.701.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.702.1">dependency</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.703.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.704.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.705.1">groupId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.706.1">&gt;</span></span><span class="koboSpan" id="kobo.707.1">io.gatling.highcharts</span><span class="hljs-tag"><span class="koboSpan" id="kobo.708.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.709.1">groupId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.710.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.711.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.712.1">artifactId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.713.1">&gt;</span></span><span class="koboSpan" id="kobo.714.1">gatling-charts-highcharts</span><span class="hljs-tag"><span class="koboSpan" id="kobo.715.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.716.1">artifactId</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.717.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.718.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.719.1">version</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.720.1">&gt;</span></span><span class="koboSpan" id="kobo.721.1">3.7.2</span><span class="hljs-tag"><span class="koboSpan" id="kobo.722.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.723.1">version</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.724.1">&gt;</span></span>
            <span class="hljs-tag"><span class="koboSpan" id="kobo.725.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.726.1">scope</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.727.1">&gt;</span></span><span class="koboSpan" id="kobo.728.1">test</span><span class="hljs-tag"><span class="koboSpan" id="kobo.729.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.730.1">scope</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.731.1">&gt;</span></span>
        <span class="hljs-tag"><span class="koboSpan" id="kobo.732.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.733.1">dependency</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.734.1">&gt;</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.735.1">
     Then, we can start writing the test class, also known as a Gatling simulation.
    </span>
    <span class="koboSpan" id="kobo.735.2">
     Our simulation will try to
    </span>
    <a id="_idIndexMarker862">
    </a>
    <span class="koboSpan" id="kobo.736.1">
     create many new orders via the Order Management API:
    </span>
   </p>
   <p class="normal">
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.737.1">
      public class CreateOrderSimulation extends Simulation {
     </span>
    </code>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.738.1">
     The top level of the test is in the class constructor:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.739.1">public </span><span class="hljs-title"><span class="koboSpan" id="kobo.740.1">CreateOrderSimulation</span></span><span class="koboSpan" id="kobo.741.1">() {
    </span><span class="hljs-title"><span class="koboSpan" id="kobo.742.1">setUp</span></span><span class="koboSpan" id="kobo.743.1">(</span><span class="hljs-variable"><span class="koboSpan" id="kobo.744.1">POST_SCENARIO_BUILDER</span></span><span class="koboSpan" id="kobo.745.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.746.1">injectOpen</span></span><span class="koboSpan" id="kobo.747.1">(
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.748.1">rampUsersPerSec</span></span><span class="koboSpan" id="kobo.749.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.750.1">10</span></span><span class="koboSpan" id="kobo.751.1">).</span><span class="hljs-title"><span class="koboSpan" id="kobo.752.1">to</span></span><span class="koboSpan" id="kobo.753.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.754.1">300</span></span><span class="koboSpan" id="kobo.755.1">)
        .</span><span class="hljs-title"><span class="koboSpan" id="kobo.756.1">during</span></span><span class="koboSpan" id="kobo.757.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.758.1">Duration</span></span><span class="koboSpan" id="kobo.759.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.760.1">ofSeconds</span></span><span class="koboSpan" id="kobo.761.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.762.1">10</span></span><span class="koboSpan" id="kobo.763.1">)),
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.764.1">constantUsersPerSec</span></span><span class="koboSpan" id="kobo.765.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.766.1">300</span></span><span class="koboSpan" id="kobo.767.1">)
        .</span><span class="hljs-title"><span class="koboSpan" id="kobo.768.1">during</span></span><span class="koboSpan" id="kobo.769.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.770.1">Duration</span></span><span class="koboSpan" id="kobo.771.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.772.1">ofSeconds</span></span><span class="koboSpan" id="kobo.773.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.774.1">80</span></span><span class="koboSpan" id="kobo.775.1">)))
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.776.1">protocols</span></span><span class="koboSpan" id="kobo.777.1">(</span><span class="hljs-variable"><span class="koboSpan" id="kobo.778.1">HTTP_PROTOCOL_BUILDER</span></span><span class="koboSpan" id="kobo.779.1">))
    .</span><span class="hljs-title"><span class="koboSpan" id="kobo.780.1">assertions</span></span><span class="koboSpan" id="kobo.781.1">(
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.782.1">global</span></span><span class="koboSpan" id="kobo.783.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.784.1">responseTime</span></span><span class="koboSpan" id="kobo.785.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.786.1">max</span></span><span class="koboSpan" id="kobo.787.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.788.1">lte</span></span><span class="koboSpan" id="kobo.789.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.790.1">5000</span></span><span class="koboSpan" id="kobo.791.1">),
        </span><span class="hljs-title"><span class="koboSpan" id="kobo.792.1">global</span></span><span class="koboSpan" id="kobo.793.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.794.1">successfulRequests</span></span><span class="koboSpan" id="kobo.795.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.796.1">percent</span></span><span class="koboSpan" id="kobo.797.1">().</span><span class="hljs-title"><span class="koboSpan" id="kobo.798.1">gt</span></span><span class="koboSpan" id="kobo.799.1">(90d));
}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.800.1">
     The code refers to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.801.1">
      HTTP_PROTOCOL_BUILDER
     </span>
    </code>
    <span class="koboSpan" id="kobo.802.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.803.1">
      POST_SCENARIO_BUILDER
     </span>
    </code>
    <span class="koboSpan" id="kobo.804.1">
     constants, which describe the requests that should be sent to the tested API.
    </span>
    <span class="koboSpan" id="kobo.804.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.805.1">
      injectOpen
     </span>
    </code>
    <span class="koboSpan" id="kobo.806.1">
     method specifies the timing and parallelization of the requests:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.807.1">
      During the first 10 seconds of the simulation, the rate of users (requests) grows from 10 per second to 300 per second.
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.808.1">
      During the following 80 seconds, the rate of requests is constant at 300 per second.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.809.1">
     At the end, we can see the test assertions that expect the maximum response time of 5,000 milliseconds and that more than 90% of the requests should be successful.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.810.1">
     To make the performance differences more visible, we will modify the code of the Product API (the API the Order Management API depends on), adding an artificial delay of 1 second in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.811.1">
      getProductById
     </span>
    </code>
    <span class="koboSpan" id="kobo.812.1">
     method of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.813.1">
      ProductsQueryUseCaseImpl
     </span>
    </code>
    <span class="koboSpan" id="kobo.814.1">
     class:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-keyword"><span class="koboSpan" id="kobo.815.1">try</span></span><span class="koboSpan" id="kobo.816.1"> {
            </span><span class="hljs-title"><span class="koboSpan" id="kobo.817.1">TimeUnit</span></span><span class="koboSpan" id="kobo.818.1">.</span><span class="hljs-property"><span class="koboSpan" id="kobo.819.1">SECONDS</span></span><span class="koboSpan" id="kobo.820.1">.</span><span class="hljs-title"><span class="koboSpan" id="kobo.821.1">sleep</span></span><span class="koboSpan" id="kobo.822.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.823.1">1</span></span><span class="koboSpan" id="kobo.824.1">);
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.825.1">catch</span></span><span class="koboSpan" id="kobo.826.1"> (</span><span class="hljs-title"><span class="koboSpan" id="kobo.827.1">InterruptedException</span></span><span class="koboSpan" id="kobo.828.1"> e) {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.829.1">throw</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.830.1">new</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.831.1">RuntimeException</span></span><span class="koboSpan" id="kobo.832.1">(e);
        }
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.833.1">
     Now, we can
    </span>
    <a id="_idIndexMarker863">
    </a>
    <span class="koboSpan" id="kobo.834.1">
     start the Product API application.
    </span>
    <span class="koboSpan" id="kobo.834.2">
     Our test orders contain the product ID AK21101, so we need to create it using the Product API.
    </span>
    <span class="koboSpan" id="kobo.834.3">
     We can use the Swagger UI, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.835.1">
      curl
     </span>
    </code>
    <span class="koboSpan" id="kobo.836.1">
     command, or, if we use IntelliJ IDEA, we can use a simple text file with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.837.1">
      .http
     </span>
    </code>
    <span class="koboSpan" id="kobo.838.1">
     extension to send an HTTP request:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.839.1">PUT http</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.840.1">:</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.841.1">//localhost:8080/api/products/AK21101</span></span><span class="koboSpan" id="kobo.842.1">
Content-Type</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.843.1">:</span></span><span class="koboSpan" id="kobo.844.1"> application/json
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.845.1">{</span></span>
    <span class="hljs-attr"><span class="koboSpan" id="kobo.846.1">"name"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.847.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.848.1">"Keyboard"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.849.1">,</span></span>
    <span class="hljs-attr"><span class="koboSpan" id="kobo.850.1">"description"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.851.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.852.1">"Ergonomic Keyboard"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.853.1">,</span></span>
    <span class="hljs-attr"><span class="koboSpan" id="kobo.854.1">"price"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.855.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.856.1">60</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.857.1">}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.858.1">
     Next, we start the Product Management API with these two configuration properties disabled by commenting them out using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.859.1">
      #
     </span>
    </code>
    <span class="koboSpan" id="kobo.860.1">
     character:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.861.1">    hikari</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.862.1">:</span></span><span class="koboSpan" id="kobo.863.1">
#       maximum-pool-size</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.864.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.865.1">500</span></span><span class="koboSpan" id="kobo.866.1">
threads</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.867.1">:</span></span><span class="koboSpan" id="kobo.868.1">
    virtual</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.869.1">:</span></span><span class="koboSpan" id="kobo.870.1">
#       enabled</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.871.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.872.1">true</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.873.1">
     The load test is started by running the following Maven command:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.874.1">mvn gatling:test
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.875.1">
     As the test is running, we can observe that after the load reaches a certain point, many requests fail (the count of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.876.1">
      KO
     </span>
    </code>
    <span class="koboSpan" id="kobo.877.1">
     , meaning
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.878.1">
      not OK
     </span>
    </code>
    <span class="koboSpan" id="kobo.879.1">
     , is growing).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.880.1">
     The whole test fails because neither the response time nor the percentage of successful requests is fulfilled.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.881.1">
     The detailed graphical visualization of the test can be found in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.882.1">
      target/gatling
     </span>
    </code>
    <span class="koboSpan" id="kobo.883.1">
     directory:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.884.1">
     <img alt="Figure 10.8 – Most of the requests failed as the service was not able to cope with the load" src="../Images/B21843_10_08.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.885.1">
     Figure 10.8 – Most of the requests failed as the service was not able to cope with the load
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.886.1">
     Now, let’s try to
    </span>
    <a id="_idIndexMarker864">
    </a>
    <span class="koboSpan" id="kobo.887.1">
     improve the performance by enabling virtual threads in the Order Management API:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.888.1">threads:
    virtual:
        enabled: true
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.889.1">
     After restarting the application and the Gatling test, we get different results.
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.890.1">
     <img alt="Figure 10.9 – Enabling virtual threads revealed a bottleneck in the database connection pool" src="../Images/B21843_10_09.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.891.1">
     Figure 10.9 – Enabling virtual threads revealed a bottleneck in the database connection pool
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.892.1">
     The number
    </span>
    <a id="_idIndexMarker865">
    </a>
    <span class="koboSpan" id="kobo.893.1">
     of successful responses increased slightly, but still, most of them failed.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.894.1">
     Looking at the console log output of the Order Management API application, we find many repetitions of the following error:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.895.1">java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms.
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.896.1">
     By enabling virtual threads, we removed the limiting caused by a thread pool on the number of requests our application was able to process in parallel.
    </span>
    <span class="koboSpan" id="kobo.896.2">
     However, another part of the application has now become the bottleneck, namely the database connection pool.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.897.1">
     The default limit for the Hikari connection pool is 10 database connections, and that is exhausted very quickly given the 1-second delay of the Product API.
    </span>
    <span class="koboSpan" id="kobo.897.2">
     The Order Management API must wait until it can finish the database transaction and release the connection.
    </span>
    <span class="koboSpan" id="kobo.897.3">
     To get rid of the bottleneck, we set the maximum number of connections to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.898.1">
      500
     </span>
    </code>
    <span class="koboSpan" id="kobo.899.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.900.1">hikari</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.901.1">:</span></span><span class="koboSpan" id="kobo.902.1">
    maximum-pool-size</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.903.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.904.1">500</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.905.1">
     Note that this is just a simple example to make the impact of virtual threads very visible.
    </span>
    <span class="koboSpan" id="kobo.905.2">
     In a real application, such a high number of connections could cause a problem with the database, and we would probably have to use a different solution, such as starting the transaction only after we get the price from the Product API or fixing the long response time of the Product API.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.906.1">
     After this
    </span>
    <a id="_idIndexMarker866">
    </a>
    <span class="koboSpan" id="kobo.907.1">
     change, we can restart the Order Management API and the Gatling test again.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.908.1">
     Now, finally, our test passes, and the results are very satisfactory:
    </span>
   </p>
   <figure class="mediaobject">
    <span class="koboSpan" id="kobo.909.1">
     <img alt="Figure 10.10 – Service using virtual threads can handle the high frequency of requests" src="../Images/B21843_10_10.png"/>
    </span>
   </figure>
   <p class="packt_figref">
    <span class="koboSpan" id="kobo.910.1">
     Figure 10.10 – Service using virtual threads can handle the high frequency of requests
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.911.1">
     All requests were OK, and all the response times were very close to 1 second from the Product API.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-289">
    <a id="_idTextAnchor309">
    </a>
    <span class="koboSpan" id="kobo.912.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.913.1">
     In this chapter, we learned the specifics of performance and scalability in the context of RESTful APIs.
    </span>
    <span class="koboSpan" id="kobo.913.2">
     We explored various design approaches and techniques to improve the two non-functional requirements.
    </span>
    <span class="koboSpan" id="kobo.913.3">
     We saw an example of using caching headers to reduce the volume of network traffic between the client and the server.
    </span>
    <span class="koboSpan" id="kobo.913.4">
     We delved deeper into virtual threads, a highly performance-relevant feature of new Java versions.
    </span>
    <span class="koboSpan" id="kobo.913.5">
     Finally, we verified the achievement of the expected performance improvements using a load test.
    </span>
    <span class="koboSpan" id="kobo.913.6">
     In the next chapter, we will show how the principles described in this book can be applied to back-end Java frameworks beyond Spring Boot, and how you can make your application more future-proof and vendor-neutral by using community-driven standards.
    </span>
   </p>
  </div>
 </body></html>