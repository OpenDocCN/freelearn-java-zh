- en: 10\. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at testing in Clojure. We start by learning about different
    types of tests. We then explore the most common unit testing libraries in order
    to test our Clojure functions. We see how to do test-driven development. We dive
    into property-based testing that helps us to generate a vast amount of testing
    data. We then learn how to integrate testing with Clojure and ClojureScript projects.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to test programs in Clojure and
    ClojureScript using their respective standard test libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about host platform interoperability (inter-op)
    in Clojure. We explored how to use Java code in Clojure and JavaScript in ClojureScript.
    During our inter-op adventure, we created a coffee-ordering application. The application
    has various features, such as displaying a menu with coffee choices and ordering
    a coffee. We ran the code and we saw the application working. It is now time to
    learn about testing in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure was designed from the beginning to be a very practical language. Getting
    things done means interacting with the outside world, building projects, using
    libraries, and deploying your work. We need to be confident that the code that
    we write does what it is supposed to do. As a developer, you will need to test
    your applications. In this chapter, we will see what types of tests can be used.
    We will look at unit tests as they are the most common type of test written by
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a situation where we have an air-ticket ordering application. This
    application allows users to search for flights and book flights. One of its features
    is searching for flights. A user should be able to enter search dates. The end
    date should be after the start date – it does not make much sense to fly back
    before we have even flown out. Testing allows us to ensure that the code handling
    start and end dates are in order.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we would want to make sure that when many customers enter our site,
    it does not slow down. User experience elements such as website speed are also
    tested in software.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to understand why testing is important and what types of tests
    can be done in Clojure and ClojureScript. Then, we will look at testing libraries
    in Clojure and ClojureScript. Finally, we will look at a special type of testing
    called **generative testing** and how it helps developers to write tests.
  prefs: []
  type: TYPE_NORMAL
- en: Why Testing Is Important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we saw that software testing is important.
    Why? In order to answer that, we will need to understand what software testing
    is. It can be defined as a process that ensures that a particular piece of software
    is bug-free. A software bug is a problem that causes a program to crash or produce
    invalid output. In *Chapter 9*, *Host Platform Interoperability with Java and
    JavaScript*, we learned about errors in Clojure and ClojureScript. Testing is
    a step-by-step process that ensures that software passes expected standards of
    performance, set by customers or the industry. These steps can also help to identify
    errors, gaps, or missing requirements. Bugs, errors, and defects are synonyms.
    They all mean problems with our software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of software testing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing a high-quality product with low maintenance costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuring the accuracy and consistency of the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering errors that are not recognized during the developmental phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the application produces the expected output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing us with knowledge of customers' satisfaction with the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of software testing methodologies, depending on the angle
    from which we look at the software. The most common distinction is between functional
    testing and non-functional testing. We will now discuss what makes tests functional
    or non-functional, and when it is appropriate to use one type or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Functional tests** try to capture the functional requirements of the software
    being tested. The requirements are taken from the specifications of the software.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the air-ticket ordering application, which allows users to buy airline
    tickets. As mentioned, one of its features is searching for flights. Users would
    want to search using different criteria. One criterion could be searching for
    direct flights. Functional tests would ensure that when a user searches for a
    direct flight, they do not see connecting flights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, functional testing involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying what functions and features a software component has, based on the
    requirements specification document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating input data based on the requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determining the expected output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparing the expected results with the actual output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While functional testing has advantages, there are some testing areas that are
    not covered by functional tests. In such cases, so-called non-functional tests
    are performed.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Functional Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Non-functional tests** check things that are not directly related to the
    functional requirements. To put it another way, non-functional tests are concerned
    with the way that software operates as a whole, rather than with the specific
    behaviors of the software or its components.'
  prefs: []
  type: TYPE_NORMAL
- en: With non-functional tests, we are concerned with areas such as security, how
    a system behaves under various load conditions, whether it is user-friendly, and
    whether it provides localization to run in different countries.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the air-ticket ordering application again. This application allows
    users to buy airline tickets. Users should be able to pay with their credit cards.
    The application should handle payments securely. This means that transactions
    should be encrypted. Encryption is the process of encoding a message or information
    in such a way that only authorized parties can access it and those who are not
    authorized cannot. Someone who is not authorized should not be able to see transaction
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Another non-functional test for the air-ticket ordering application would be
    load testing. With load testing, we would test that our application can handle
    a very high page load. During the festive period, many customers will enter our
    website. We need to make sure that thousands of users can use the application
    at the same time. The application should be responsive and not slow down when
    many customers use it.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests ensure that our applications are secure. While we have discussed
    functional and non-functional testing separately, they should not be seen as opposing
    testing methodologies, but rather, complementary approaches. They are often performed
    together to provide assurance that software has a high standard of quality and
    can operate under various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and catching bugs in software are not free. It requires time and resources
    from developers and testers. Having said that, fixing bugs late in development
    is more expensive than catching them early in the development phase. Unit testing
    allows us to catch many bugs early on, while not requiring too many resources
    from developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will examine what unit testing is, and the most popular
    unit testing frameworks in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unit testing** is the testing of an individual software component or module.
    In Clojure, a function is a good candidate for unit testing. A function is intended
    to perform one task at a time. Otherwise, a change in logic in one job would influence
    a second job. When a function has one responsibility, we can reason about the
    function much more easily than if it performed more than one thing. Clojure provides
    a number of testing frameworks for unit testing. When we use testing libraries,
    we often call them frameworks. A framework is a structure that supports and encloses
    testing. With testing frameworks, we support testing our code. Our code is enclosed
    in a number of tests written for our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of concepts in testing, two of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertion**: A Boolean (true or false) expression. An assertion is a statement
    about a specific part of our program, which will be true or false. For example,
    we can state that a function in our program will throw an error when we pass a
    string instead of a number as a parameter. The assertion will be: Does this function
    throw an error? The answer is either yes (true) or no (false).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stub**: A temporary replacement for a part of a code or a concept. A stub
    simulates the behavior of the replaced software component. In the flight-ticket
    ordering application, we could have a payment component that takes card details
    and contacts the bank to withdraw money for the plane ticket. After taking payment
    through the bank, we would display ticket details. A stub would simulate contacting
    the bank without actually contacting the bank. When we use a stub, we can focus
    on testing displaying ticket details without handling contacting the bank and
    all card transactions. This keeps the test focused on a single task, in this case,
    displaying a ticket after taking payment via a bank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `clojure.test` framework is the default Clojure unit testing framework that
    comes with the Clojure standard library. The purpose of `clojure.test` is to provide
    developers with a number of testing functions. In our first exercise, we will
    write unit tests for the coffee app from the previous chapter using the clojure.test
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Unit Testing with the clojure.test Library'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to learn how to perform unit testing with the `clojure.test`
    library. This is the default testing library in Clojure. It is included in Clojure
    so we do not need to import this library as an external dependency. In the previous
    chapter, we created a coffee-ordering application that allowed us to display a
    coffee menu and order coffees. In this exercise, we will write unit tests for
    the functions created in the coffee-ordering application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create the application, then we will write tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the coffee-ordering application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leiningen created the project for us. By default, we have one source file called
    `core.clj`. Inside this file, we will add the code responsible for displaying
    the menu options and processing them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `java.util.Scanner` class in the `core` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have imported the `Scanner` class. This class allows us to get input from
    a keyboard. In order to use methods from Scanner, we need to create an instance
    of this class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an instance of the `Scanner` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will call methods on this class instance when we want to get input from a
    user. The `Scanner` class needs to know what the source of the input is. In our
    case, we use the default `in` source of the `System` class – the keyboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a user runs the application, they should see a menu with options. The options
    are displaying and ordering coffees, listing orders, and exiting the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.1: Menu of the application showing all the options'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.1: Menu of the application showing all the options'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the code for displaying the menu and handling user choices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `start-app` function, we set the application to running by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to get the values stored in `run-application`, we use the `deref` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `while` block, the application runs until the user chooses the exit
    option. In such cases, we will update the value of `ref`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After updating, `ref` is no longer true but false. The `while` block will stop
    when the value of `ref` is false and our application will exit. When our application
    runs, the user can choose options from the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the following menu:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.2: Menu of the coffee ordering application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.2: Menu of the coffee ordering application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are able to display the initial menu. We can work on handling user choices
    from the menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to get the user response, we call the `nextInt` method from the `Scanner`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, once we get the user input, we check which option from the menu should
    be executed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now know about the logic in the main application menu when we start the app.
    It is time to dig deeper and look at the code for the `show-menu` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display the menu for the available coffees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `show-menu` function, we let the user know about two available coffees
    – `Latte` and `Mocha`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the coffee menu:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.3: Coffee menu display'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.3: Coffee menu display'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The user can choose numbers `1` or `2`. We need to respond to the user's coffee
    choice now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We use the `Scanner` instance to get the user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we proceed to buy the coffee that the user chose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `show-menu` function is not long. Its purpose is to display the available
    coffees and get the user input. Once the user has chosen their coffee, we call
    the `buy-coffee` function to handle buying the selected coffee.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ask the user how many coffees they''d like to buy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `buy-coffee` function asks how many coffees the user wants to buy. Again,
    we use an instance of the `Scanner` class – `input` – to get the user's choice.
    Next, the function calls two utility functions to process the purchase. The functions
    are responsible for calculating the coffee price and displaying the feedback message
    to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the functions will be placed in the `utils.clj` file. Instead of having
    all functions in one big file, it is good practice to split functions into various
    namespaces. A common namespace name is `utils`. We can keep any useful functions
    that operate on data there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `utils` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the coffee price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first utility function calculates the coffee price. It uses the `get` function
    to check the `coffees` hash for the passed-in coffee type. The hash is defined
    in the core namespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value obtained from the hash is then multiplied by the number of coffee
    cups that the user ordered. Finally, we coerce the number to float. This allows
    us to convert a number such as 1.2000000000000002 to 1.2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last utility function used when we handle buying coffee is the `display-bought-coffee-message`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display the message to the user after buying the coffee:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `display-bought-coffee-message` function takes the order map and constructs
    a string message for the user based on the data from the map. The user is informed
    that they bought a certain amount of cups of coffee for the specified price.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this function, we can control the information passed back to the user
    after completing their order:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.4: Displaying the message for the coffee bought'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.4: Displaying the message for the coffee bought'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second option from the main menu allows us to see the placed orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.5: Orders allows the user to see their orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.5: Orders allows the user to see their orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function responsible for displaying orders is `show-orders` from the `coffee-app.core`
    namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display the placed orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function will display the coffee orders made. In this exercise, we informed
    the user that orders will be displayed here. In the following exercise, we will
    implement saving and displaying orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run the application and buy two cups of latte, we will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.6: Output when the user buys two cups of coffee'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.6: Output when the user buys two cups of coffee'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the main function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to run the application, we will use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we run the application, we can see the available coffees and order them,
    similar to what we saw in *Figure 10.6*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have our application running successfully. We will create tests for our application
    now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the testing directory. We use the `tree` command to display a list of
    folders and files within the test directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we created the application, Leiningen created the `test` directory for
    us. There are a number of ways to check the project's structure. We check the
    project structure using the preceding `tree` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.7: Project structure'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This file imports the Clojure testing namespace, as well as the core file from
    the source directory. The file contains one test method. This method is called
    `a-test`. Because we have autogenerated the `a-test` test function, we can run
    tests after creating a Leiningen project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we create a new project with Leiningen, it will create one test function.
    This function is called `a-test` and is inside the `core_test.clj` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to run tests, we need to call Leiningen''s `test` task. The `test`
    task is a task that will run the tests within the test directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.8: Running the test task'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.8: Running the test task'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `a-test` test fails, as we have not yet implemented the `a-test` test from
    the `core_test.clj` file. Leiningen informed us that it tested the `coffee-app.core-test`
    namespace. We have information that the test failed, including which line in the
    test file (line 7) caused the test to fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leiningen even provided us with information about what the test expected and
    what the actual result was. In this case, the default test tried to compare the
    numbers one and zero. In order to make the test pass, let's change the `a-test` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the default `test` function from the Leiningen project, we will change
    the implementation of the default `a-test` function that we have just seen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We changed the test to state that 1 is equal to 1\. This will make our `a-test`
    pass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We run the test using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the tests again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.9: Running the test after fixing the default a-test function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.9: Running the test after fixing the default a-test function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This time, Leiningen informs us that it ran one test with one assertion (test
    condition). There were zero failures and zero errors. We now know how to run tests.
    It is time to write tests for the `utils` namespace. We will create a testing
    file for the `utils` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a test file for the `utils` namespace. Inside the file, we will write
    code to test functions in the `utils` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After creating `utils_test.clj`, we will have two test files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.10: We now have two test files after creating utils_test.clj'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.10: We now have two test files after creating utils_test.clj'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `utils_test.clj`, we want to test functions from the `utils` namespace. We
    will add the necessary dependencies to the testing namespace. Inside `core_test.clj`,
    we will keep tests for functions that are defined in the `core.clj` file. The
    `utils_test.clj` file will contain tests for functions defined in the `utils.clj`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will import the `clojure.test` library and namespaces from the source directory
    that we will test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `clojure.test` namespace has a number of testing functions. We import them
    using the `:refer` keyword, which we learned about in *Chapter 8*, *Namespaces,
    Libraries, and Leiningen*. We import four functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`are`: Allows you to test multiple testing scenarios'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is`: Allows you to test a single testing scenario'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`deftest`: Defines a Clojure test'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`testing`: Defines an expression that will be tested'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We import the `coffee-app.core` and `coffee-app.utils` namespaces from the source
    directory. From the `core` namespace, we import `price-menu`, which contains a
    list of available coffees and the price for each coffee. Finally, we import the
    `utils` namespace, which contains the functions that we want to test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `clojure.test` object provides the `is` macro for testing. We will learn
    about macros in *Chapter 11*, *Macros*. For the purpose of this exercise, you
    can think of macros as special functions. Macros are used in the same way as we
    have used functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `is` macro takes a test and an optional assertion message. Add the following
    code to `utils_test.clj`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `deftest` macro allows us to define tests. Each test is defined using the
    `testing` macro. The `testing` macro can be supplied with a string to provide
    a testing context. Here, we inform you that this is a single test using the `is`
    macro. In this test, we call the `calculate-coffee-price` function, passing `price-menu`,
    which contains information about the available coffees.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second argument that we pass is the number of cups of coffee that we want
    to buy. In our case, we want to buy one cup. For the test, the result of calling
    the `calculate-coffee-price` function for one latte should be 0.5\.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will run the test now:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.11: Running the test after using the is macro'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.11: Running the test after using the is macro'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can see that the newly added test passes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we can write tests with the `is` macro, testing multiple times with the
    `is` macro results in the unnecessary duplication of code. Consider the next test,
    where we run through three scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buying one coffee – a user decides to buy one cup of coffee
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Buying two coffees – a user decides to buy two cups of coffee
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Buying three coffees – a user decides to buy three cups of coffee
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `calculate-coffee-price-test-with-multiple-is` test, we have three
    single tests using the `is` macro. We test three different scenarios: buying one
    coffee, buying two coffees, and buying three coffees.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run multiple `is` tests. We run the tests for the `calculate-coffee-price-test-with-multiple-is`
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.12: Running multiple is tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.12: Running multiple is tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The new test has been run and passes. In the preceding code, we see that we
    duplicate a lot of calls to the `calculate-coffee-price` function. There should
    be a more efficient way to write tests for multiple scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `are` macro is a convenience macro when we plan to write multiple tests
    using the `is` macro. The `are` macro is a test macro used for testing multiple
    testing scenarios. It differs from the `is` macro in a number of scenarios that
    we can test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `is` macro allows us to test one scenario. It is singular. The `are` macro
    allows us to test more than one scenario. It is plural. We use the `is` macro
    when we want to test a single scenario and the `are` macro when we want to test
    more than one scenario. The previous test with multiple `is` macro calls can be
    rewritten as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `are` macro checks multiple tests against the assertion written by us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding test, we wrote an assertion:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of calling `calculate-coffee-price` with `coffees-hash coffee-type
    number-of-cups` should be equal to the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the vector, we specify four arguments that we need to run our test:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The arguments include coffee-hash with information about coffees, coffee-type,
    number-of-cups, and result – the result of calculating the coffee price.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Again, we use the `equals` (`=`) function to check the result of calling the
    `calculate-coffee-price` function against the result that we expect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we run the tests again, we get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.13: Output for tests run after using the are macro'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.13: Output for tests run after using the are macro'
  prefs: []
  type: TYPE_NORMAL
- en: Our new test passes. We used the `are` macro to simplify writing multiple test
    assertions. Whenever we need to write multiple tests with the `is` macro, using
    the `are` macro will make our code shorter and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have seen how to write tests using the `clojure.test` library.
    In the next exercise, we will look at another Clojure library for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Expectations Testing Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main philosophy in the `Expectations` library revolves around an expectation.
    The `expectation` object is built with the idea that unit tests should contain
    one assertion per test. A result of this design choice is that expectations have
    very minimal syntax, and reduce the amount of code needed to perform tests.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal syntax helps to maintain the code as it is easier to read and reason
    about code that is short and focused on testing one feature. Another benefit relates
    to testing failing code. When a test fails, it is easy to check which test failed
    and why because the test is focused on one feature and not multiple features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Expectations` library allows us to test things like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors thrown by the code: We can test whether a part of our code throws an
    error. Imagine a function that calculates a discount. This function takes numbers
    as input and multiplies them. If we pass a string such as "`text`" and a number
    `5`, we will get an error because Clojure cannot multiply a number and a string.
    We can write tests to check whether an error is thrown in this scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function''s return value: We can test whether a function returns the expected
    value. Imagine a function that calculates a discount. This function takes numbers
    as input and multiplies them. After the multiplication, it should return a number.
    We can write tests to check that our function returns a number instead of a collection
    or a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Elements in a collection: We can write tests to check whether a collection
    contains expected elements. Imagine a function checking a list of users for children.
    This function takes a list of users as input. We can write tests checking the
    age of users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to use `Expectations`, we need to import it into a Leiningen project:'
  prefs: []
  type: TYPE_NORMAL
- en: We add a dependency for the `expectations` library [`expectations "2.1.10"`].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lein-expectations` is a Leiningen plugin that runs expectations tests from
    the command line `[lein-expectations "0.0.8"]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write tests for the `calculate-coffee-price` function. This will allow
    us to compare how we compose tests in the `Expectations` library against tests
    written using the `clojure.test` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Testing the Coffee Application with Expectations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how to write unit testing in Clojure using
    the `Expectations` library. We will write tests for the `calculate-coffee-price`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `expectations` to the `project.clj` file. After adding the `Expectations`
    library to `project.clj`, the file should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a file for the `utils` tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to use the Expectations library, we need to import functions first.
    The `utils` namespace should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the `calculate-coffee-price` function. Buying three cups of latte should
    cost us 1.5\. The following test will check this condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are ready to run the test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the `expectations` test with the Leiningen task. In order to run tests
    on the command line, we need to use the Leiningen task from the `lein-expectations`
    plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This task will execute the `expectations` tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.14: Output after running the expectations test'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.14: Output after running the expectations test'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we expected, for three lattes, we need to pay 1.5\. What will happen if we
    pass a string instead of a number for a number of cups? We would expect an error.
    With `expectations`, we can test for errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `expectations` library allows us to test whether a function throws an error.
    The `calculate-coffee-price` function requires a number. Passing a string should
    result in an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.15: Testing the calculate-coffee-price function using the Expectations
    library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.15: Testing the calculate-coffee-price function using the Expectations
    library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After running the test, we see that all tests pass. Tests do not always pass.
    With `expectations`, we are informed when tests fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we run a test that fails, `Expectations` will let us know. Testing for
    an error when the error is not thrown will fail the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.16: Running a test that fails using the Expectations library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.16: Running a test that fails using the Expectations library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Expectations library informed us that one test failed. We also know in which
    namespace we have a failing test and which line of code caused the test to fail.
    This allows us to quickly find the failing test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We know that passing a string to `calculate-coffee-price` will result in an
    error. With Expectations, we can also check what the return type from the function
    is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Clojure code, we often compose functions. One function operates on the result
    of running other functions. It is common to check that functions that we call
    return the types of values that we expect. With `Expectations`, we can check the
    return type from a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We expect that `calculate-coffee-price` will return a number:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.17: Using Expectations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.17: Using Expectations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running the tests confirms that the number is the correct return type of the
    `calculate-coffee-price` function. With `Expectations`, we also can test whether
    a collection contains requested elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `price-menu` hash contains information about the available coffees, such
    as type and price. With `Expectations`, we can test whether elements belong to
    a collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We expect that, on the menu, we have latte and that its price is `0.5`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.18: Testing whether latte belongs to the menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.18: Testing whether latte belongs to the menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, on our menu, we have a latte. We now know two testing libraries
    in Clojure: `clojure.test` and Expectations. The third testing library that we
    will learn about is `Midje`.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing with the Midje Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Midje` is a testing library in Clojure that encourages writing readable tests.
    `Midje` builds on top of the bottom-up testing provided by `clojure.test` and
    adds support for top-down testing. Bottom-up testing means that we write tests
    for a single function first. If this function is used by some other function,
    we write tests after finishing the implementation for the other function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the coffee-ordering application, we have the `load-orders` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `load-orders` function uses the `file-exists?` function. Functions in Clojure
    should not perform many things. It is good practice to have small functions focusing
    on single tasks. The `file-exist` function checks a file. The `load-orders` function
    loads orders. Because we cannot load orders from a file that does not exist, we
    need to use the `file-exist` function to check for a file with saved orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With bottom-up testing, we have to write the implementation for `file-exists`
    first. After we have a working implementation of `file-exist`, then we can write
    the implementation for `load-orders`. This way of writing tests forces us to think
    about implementation details for all functions instead of focusing on a feature
    that we want to implement. Our original goal was to load data from a file but
    we are focusing now on checking whether a file exists.
  prefs: []
  type: TYPE_NORMAL
- en: With a top-down approach, we can write working tests for the main tested function
    without implementing functions that are used by the tested function. We state
    that we want to test the `load-orders` function and that it uses the file-exist
    function but we do not need to have a full implement of file-exist. We merely
    need to say that we will use this function. This allows us to focus on a feature
    that we want to test without worrying about implementing all sub-steps.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `Midje`, add it as a dependency (`[midje "1.9.4"] to project.clj`)
    to the `project.clj` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: Testing the Coffee Application with Midje'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how to use the `Midje` library and write
    top-down tests. We will write tests for `calculate-coffee-price`. We will use
    a top-down approach to write tests for the load-orders function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will import the `Midje` namespace to the `utils` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After importing the `Midje` namespace, we are ready to use the `fact` macro
    from the `Midje` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Midje` uses the `fact` macro, which states certain facts about a future version
    of our test. The macro takes a single argument on both sides of the `=>` symbol.
    The `fact` macro states that the result from the left-hand side is to be expected
    on the right-hand side of the symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We wrote a test where we expect that the price for three cups of latte is `3`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Midje` supports autotesting in the REPL.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With autotesting, we do not need to run tests every time we make changes. The
    autotester will run the tests anytime it detects changes. In order to use autotesting
    in `Midje`, we enable autotesting in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After starting the REPL, we import the `Midje` namespace and enable the autotester:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After starting the REPL, we imported the `Midje` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second step was calling the `autotest` function. This function will run
    the tests automatically when our code changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After enabling autotesting, our tests are run thanks to the `autotest` function
    that we used in the REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.19: Executing the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.19: Executing the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Midje` informs us that our tests failed. The price for three cups of latte
    is not `3` but `1.5`. When we change the implementation of the test, the autotest
    runs again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The autotest runs as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.20: Running autotest after changing the implementation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.20: Running autotest after changing the implementation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This time, we are informed that our tests pass. We know now how to run autotests
    and how to write tests using `Midje`. It is time now to explore top-down testing
    in `Midje`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `utils` namespace, we have the `display-bought-coffee-message` function,
    which displays a message about the number of coffee types bought. This function
    has a hardcoded currency symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It would be nice to obtain the currency code from a utility function and not
    hardcode it. As some countries use the same currency, just as the euro is used
    in many European countries, it is a good idea to encapsulate the logic of getting
    the currency into a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will keep the information about the currencies in a hash. Remember from
    *Chapter 1*, *Hello REPL!*, that a hash is a Clojure collection where we store
    data using keys and values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to check the currencies that different countries use and currency
    symbols.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we do not plan to write the implementation for the functions of currencies,
    we will provide a stub (substitution) for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We saw an explanation of a stub at the beginning of this chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This tells `Midje` that we plan to use the `get-currency` function but we have
    not implemented it yet. We will test against the euro, so we will add the `helper`
    var:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function for displaying information about bought coffees will initially
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The test for the `get-bought-coffee-message-with-currency` function looks as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the test, we use the `Midje =>` symbol. We expect the result of calling `get-bought-coffee-message-with-currency`
    to equal the string message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the provided function from `Midje` to stub call to the `get-currency`
    function. When the `Midje` test calls this function, it should return the euro
    symbol, €.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we check autorun in the REPL, we will see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.21: Testing the get-bought-coffee-message-with-currency function
    using Midje'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.21: Testing the get-bought-coffee-message-with-currency function
    using Midje'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Midje` informs us that one test failed. The `get-currency` function should
    have been called but was not called at all. We just wrote a test that compiled
    and ran. We did not get a compilation error. We focused on the logic for displaying
    a message and this part was a success. Once we have a test for `get-bought-coffee-message-with-currency`,
    it is time now to think about using `get-currency` to display messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This implementation of the `get-bought-coffee-message-with-currency` function
    uses the `get-currency` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.22: Testing again after using the get-currency function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.22: Testing again after using the get-currency function'
  prefs: []
  type: TYPE_NORMAL
- en: When we check the autotest in the REPL, we see that all tests pass now.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to write tests using the `Midje` library. This
    library allows us to write tests using a top-down approach where we think about
    testing the main function and any other functions called by it are stubbed first.
    This helps us to focus on the behavior of the main function under test without
    worrying about implementing all of the used functions.
  prefs: []
  type: TYPE_NORMAL
- en: While we wrote tests using various libraries, all tests are limited. When we
    tested `calculate-coffee-price`, we tested it a few times. If we could test it
    more times, we could be more confident that the `calculate-coffee-price` function
    is performing as expected. Writing a few tests can be quick but writing 100 or
    200 tests takes time. Luckily, with property-based testing, we can generate lots
    of test scenarios very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Property-Based Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Property-based testing**, also known as generative testing, describes properties
    that should be true for all valid test scenarios. A property-based test consists
    of a method for generating valid inputs (also known as a generator), and a function
    that takes a generated input. This function combines a generator with the function
    under test to decide whether the property holds for that particular input. With
    property-based testing, we automatically generate data across a wide search space
    to find unexpected problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a room-booking application. We should allow users to search for rooms
    suitable for families. Such rooms should have at least two beds. We could have
    a function that returns only those rooms that have at least two beds. With unit
    testing, we would need to write scenarios for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero beds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One bed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two beds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three beds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four beds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Five beds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And other scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we wanted to test rooms with 20 beds, it would mean creating over 20 tests
    that are very similar. We would only change the number of beds. We can generalize
    such tests by describing what a family room is in general terms. As we said, a
    family room would have at least two beds. Property-based testing allows us to
    generalize inputs and generate them for us. Because inputs are generated automatically,
    we are not limited to manually typing tests and we could create 1,000 test scenarios
    easily. For our family room example, the input is a number of rooms. Testing would
    involve specifying that a room number is a number. With property-based tests,
    integer inputs would be automatically generated for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure provides the `test.check` library for property-based testing. Property-based
    testing has two key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test.check.generators` namespace has many built-in generators, as well as
    combinator functions for creating your own new generators from the built-in generators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: Properties are characteristics of inputs. An input to any function
    can be described in general terms. In our family room example, the input is a
    number of rooms. So, the property is a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next exercise, we will write property-based tests for the coffee-ordering
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.04: Using Property-Based Testing in the Coffee-Ordering Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to learn how to create tests using property-based
    testing. We will describe inputs for the `calculate-coffee-price` function and
    this will allow us to generate tests automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the `test.check` library, we need to add `[org.clojure/test.check
    "0.10.0"]` as a dependency in the `project.clj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use `test.check` in the utils namespace, we need to import the
    necessary namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We import three `test.check` namespaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`clojure.test.check.generators`: Will generate inputs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`clojure.test.check.properties`: Will allow us to describe inputs in a general
    form'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`clojure.test.check.clojure-test`: Will allow us to integrate with clojure.test'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to import these namespaces in the REPL, we would do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we have the necessary namespaces imported, we can look at how to generate
    inputs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to generate inputs for tests, we will use generators. The `calculate-coffee-price`
    function takes a number of cups as an argument. A generator creating numbers such
    as `small-integer` is what we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `small-integer` function from the generators'' namespace returns an integer
    between `-32768` and `32767`. The `sample` function returns a sample collection
    of the specified type. In the preceding example, we have a sample collection of
    small integers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.23: Creating a sample of small integers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.23: Creating a sample of small integers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With generator combinators, we can obtain new generators. The `fmap` generator
    allows us to create a new generator by applying a function to the values created
    by another generator. The `fmap` generator works like the `map` function, which
    we know about from the first chapter. It allows us to map a function to a value
    created by the following generator. In this example, each integer created by the
    `small-integer` generator is incremented using the `inc` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We were able to increase the numbers generated by the `small-integer` generator
    by applying the `inc` function using the `fmap` combinator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now know how to create inputs using generators. It is time to learn how to
    describe the properties of inputs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A property is an actual test — it combines a generator with a function you want
    to test, and checks that the function behaves as expected given the generated
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Properties are created using the `for-all` macro from the `clojure.test.check.properties`
    namespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `defspec` macro allows you to run `test.check` tests like standard `clojure.test`
    tests. This allows us to extend test suits to include property-based testing together
    with standard unit tests. In the `for-all` macro, we use a small-integer generator
    to create a number of small integers. Our test passes when the number of coffee
    cups value created by the generator is multiplied by the price of the coffee.
    The result of this calculation should equal the result of running the `calculate-coffee-price`
    function. We intend to run the test 1,000 times. This is amazing that with three
    lines of code we were able to create 1,000 tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can run `test.check` tests using Leiningen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.24:Testing test.check using Leiningen'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our test failed. The original failing example `[-2]` (given at the `:fail`
    key) has been shrunk to `[-1]` (under `[:shrunk :smallest]`). The test failed
    because in the implementation of `calculate-coffee-price`, we return only absolute,
    non-negative values. The current implementation of `calculate-coffee-price` is
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the last line, we have the `Math/abs` function call. `calculate-coffee-price`
    should return only absolute numbers. Yet in our tests we allowed negative numbers
    to be generated. We need to use a different generator to match the expected result
    from the `calculate-coffee-price` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`test.check` provides a `nat` generator that can create natural numbers (non-negative
    integers).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The test for `calculate-coffee-price` should be updated to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run tests with this generator, the tests pass:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.25: Using nat to create non-negative integers and running tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.25: Using nat to create non-negative integers and running tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We were able to test the `calculate-coffee-price` function 1,000 times. We generated
    an integer each time and used the integer as a number of cups. With `test.check`,
    we can truly check parameters against generated inputs. We have tested only the
    number of cups parameter. It is time to write generators and test all of the parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to generate all of the remaining parameters for the `calculate-coffee-price`
    function, we will use some new generators. The code for creating all parameters
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The coffee hash that stores the coffee menu contains information about the
    coffee type as a key and its value as a double:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `gen/map` generator allows us to create a hash. In the hash, we want to
    generate a keyword as a key and a double for a value. We limit the value to be
    between 0.1 and 999\. We are only interested in numbers. We do not want to get
    an infinite value. With generators, we could create an infinite value if we wanted.
    We also do not want a NaN (not a number) to be generated. Lastly, our hash should
    have at least two elements – two tuples to be precise. Each tuple is a pair of
    a key and a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `let` block, we take the first tuple and assign it to `coffee-tuple`.
    This will help us to test and pass appropriate arguments to the `calculate-coffee-price`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will run the tests again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.26: Running the tests after generating all parameters for the calculate-coffee-price
    function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.26: Running the tests after generating all parameters for the calculate-coffee-price
    function'
  prefs: []
  type: TYPE_NORMAL
- en: We see that both `test.check` tests pass. With a few lines of code, we were
    able to test 2,000 scenarios. This is amazing.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have tested the `calculate-coffee-price` function. In the following
    activity, you will write tests for other functions from the coffee-ordering application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Writing Tests for the Coffee-Ordering Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will apply knowledge about unit testing to write a test
    suite. Many applications running in production are very complex. They have lots
    of features. Developers write unit tests in order to increase their trust in the
    application. The features coded should fulfill business needs. A well written
    and maintained test suite gives confidence to developers and people using such
    applications that the applications' features perform as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The coffee-ordering application that we wrote in the previous chapter allowed
    us to display the coffee menu and order some coffees. In this chapter, we have
    learned about unit testing libraries in Clojure by testing the `calculate-coffee-price`
    function. In the coffee-ordering application, there are still functions that have
    not been tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this activity, we will write unit tests for the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display-order`: Displays information about the order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file-exist`: Checks whether a given file exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save-coffee-order`: Saves the coffee order to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load-orders`: Loads coffee orders from a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the testing namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create tests using the `clojure.test` library to display orders messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tests using `is` macro
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tests using `are` macro
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create tests using the `clojure.test` library to test if the file exists or
    if the file does not exist
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `clojure.test` library to save orders, load empty orders,
    load coffee orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `expectations` library to save data to file, save coffee
    orders, save coffee data, and load orders
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `expectations` library to check whether the file exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `expectations` library to save and load orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `Midje` library to display the orders messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `Midje` library to check whether the file exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using the `Midje` library to load orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create tests using `test.check` to display the orders messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `test.check` namespace
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test the displayed orders
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create tests using `test.check` to check whether the file exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests using `test.check` to load orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the `clojure.test` and `test.check` tests will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.27: Expected output for the clojure.test and test.check tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.27: Expected output for the clojure.test and test.check tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `expectations` tests will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.28: Expected output for the expectations test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.28: Expected output for the expectations test'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `Midje` tests will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.29: Output for the Midje tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.29: Output for the Midje tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `test.check` tests will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30: Output for the test.check tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.30: Output for the test.check tests'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 723.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to write unit tests in Clojure using four libraries. In the
    next section, we will look at testing in ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in ClojureScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Clojure, we used the `clojure.test` library for testing. In ClojureScript,
    we have a port of `clojure.test` in the form of `cljs.test`. In `cljs.test`, we
    have functionality that we used when we wrote tests using the `clojure.test` library.
    We can use the `is` and `are` macros to write our tests. `cljs.test` provides
    facilities for asynchronous testing. Asynchronous testing is a type of testing
    that tests asynchronous code. We will see shortly why it is important that `cljs.test`
    allows us to test asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous code is what developers write most of the time, even without realizing
    this. In synchronous code, code is executed line by line. For example, the code
    defined in line 10 needs to finish executing before the code on line 11 can start
    executing. This is step-by-step execution. Asynchronous coding is a more advanced
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous programming, executing code and completing the execution of
    code cannot happen in a line-by-line fashion. For example, we could schedule downloading
    a song on line 10 and then on line 11 we could have code to let the user know
    that downloading has finished. In synchronous code, we would have to wait for
    the download to finish before we can show information to the user or perform some
    other actions. This is not what we would really want. We would like to inform
    the user about the progress as we download the song. In asynchronous code, we
    would schedule downloading a song and start showing the progress bar before the
    song is downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: In Java and Clojure, we would use threads to write asynchronous code. A thread
    is a process on a JVM that consumes little computer resources. One thread would
    handle downloading a song and the other would display the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in *Chapter 1*, *Hello REPL*, ClojureScript runs on top of JavaScript.
    JavaScript provides a single-thread environment. This is in contrast to Java,
    which allows creating many threads. Writing code for one thread is simpler as
    we do not need to coordinate resource-sharing between many threads. ClojureScript
    applications requiring asynchronous code need to use some other facilities than
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provides callbacks to manage writing asynchronous code. Callbacks
    are functions that we define to be run once certain conditions are met. In our
    downloading example, a callback would let us know when downloading is finished
    so we can inform the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'ClojureScript provides the `core.async` library for working with asynchronous
    code. The `core.async` library has a number of functions and macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go`: Creates a block that marks the code as asynchronous. The result from
    the block is put on a channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<!`: Takes a value from a channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need a go block and channels?
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous code is by definition asynchronous. We do not know when we will
    get a return value from an asynchronous call. When we use channels for asynchronous
    calls, our code becomes simpler. This happens because return values are put on
    a channel. We do not need to manage this channel. `core.async` does this management
    for us. When we are ready, we just take value from this channel. Without explicit
    channel management, our code is shorter as the code can focus on simpler tasks
    that we program.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will see how to set up and use testing libraries
    in ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.05: Setting Up Testing in ClojureScript'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to learn how to set up testing libraries in ClojureScript
    and how to use those libraries. We will use `cljs.test` for testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will create a number of folders and files. There are many
    ways to create folders and files. Readers are welcome to use any methods they
    are most comfortable with. The following steps will use the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.31: Command and it''s description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.31: Command and it''s description'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project named `hello-test`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create a project where we will keep our code. Once we finish setting
    up, the project structure should look like the following screenshot. We can see
    the project structure using the `tree` command or your preferred way to check
    directories:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.32: Project structure'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_32.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.32: Project structure'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the source folder, we will keep our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Executing this command will create the `src` and `hello_test` folders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a source file. In the source file, we will keep our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command creates an empty core file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a core namespace. Inside the `core.cljs` file, add a namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `core.cljs` file, put a function for adding numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a testing folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a folder for our testing files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will create the `test` and `hello_test` folders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will keep the project configuration in the `project.clj` file. The file
    should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a standard `project.clj` file like we created in *Chapter 8*, *Namespaces,
    Libraries and Leiningen*. Inside the project.clj file, we have the `:dependencies`
    key where we put the libraries that we need for testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `cljs-http` library will allow us to make HTTP calls. We will use `GET`
    requests to make asynchronous calls that will be tested.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `cuerdas` library has many string utility functions. Some of the functions
    are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`capital`: Uppercases the first character of a string. The string "john" becomes
    "John".'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Clean`: Trims and replaces multiple spaces with a single space. The string
    " a b " becomes "a b."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Human`: Converts a string or keyword into a human-friendly string (lowercase
    and spaces). The string "DifficultToRead" becomes "difficult to read."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reverse`: Returns a reverted string. The string "`john`" becomes "`nhoj`."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will write unit tests manipulating strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a test plugin dependency. We will use the `lein-doo` plugin to run ClojureScript
    tests. Add the following line in `project.clj`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `lein-doo` plugin will be used to run ClojureScript tests. This plugin will
    autorun tests and display test results. We will run `lein-doo` against a web browser
    environment. `lein-doo` relies on the JavaScript `Karma` library to run tests
    in a JavaScript environment. Karma is a JavaScript tool that helps to run JavaScript
    tests. We need to install the necessary dependencies for `Karma`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install Karma. Karma is distributed using `npm` is an equivalent of Maven that
    we learned about in *Chapter 8*, *Namespaces, Libraries, and Leiningen*. Basically,
    it is a repository of projects. While Maven hosts Java projects, npm hosts JavaScript
    projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use npm to install Karma:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `-save-dev` flag, we install the `karma` packages in the current directory.
    The purpose of using the `-save-dev` flag is to allow us to separate different
    test configurations between projects. One legacy project could still rely on an
    old version of Karma while a new project could use a newer version of Karma.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will install the Chrome Karama launcher. Our tests will be run (launched)
    in the Chrome browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command searches `npm` for `karma-chrome-launcher` projects. When
    `npm` finds this project, it will download the Chrome launcher and install it.
    With the -`save-dev` flag, we install the karma-chrome-launcher in the current
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install the Karma command-line tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final step to install the Karma libraries is to install command-line tools
    that allow executing Karma commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We install Karma command-line tools globally as the ClojureScript plugin running
    the tests needs to access Karma commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to set the build configuration for the test task in the `project.clj`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ClojureScript build configurations are set under the `:cljsbuild` key in the
    project.clj file. We specify one `:browser-test` build. This build will access
    files from the `src` and `test` directories. The code will be compiled to the
    `out` directory to the `tests.js` file. The `:main` entry point for tests is the
    `hello-test.runner` namespace. For testing, we do not need any optimizations for
    compilation so we set the optimizations parameter to `:none`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a core test file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command creates the `core_test.cljs` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Import the testing namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `core_test.cljs` file will contain the tests. We need to import the necessary
    namespaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the testing macros from the `cljs.test` namespace. We will use them
    for testing our code. We also import the namespace from the `test.check` namespace.
    We will write property-based tests for our functions. The `cuerdas` namespace
    will be used to manipulate strings. Finally, we import test functions from the
    `hello-test.core` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a test runner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A test runner is a file that runs all the tests. We will test our code using
    the browser engine from Karma:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Import the namespaces for the test runner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `hello_test.runnerfile`, we import the core testing namespace and the
    `lein-doo` namespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We let `lein-doo` know that it needs to run tests from the `hello-test.core-test`
    namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we install Karma and create all the files, the project structure should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.33: Project structure after installing Karma and creating all the
    files'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_33.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.33: Project structure after installing Karma and creating all the
    files'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are ready to launch the test runner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Launch the test runner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We call the `lein doo` plugin to run tests using the Chrome browser. Remember
    that JavaScript is a language that runs in browsers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.34: Launching the test runners'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.34: Launching the test runners'
  prefs: []
  type: TYPE_NORMAL
- en: The `lein doo` plugin launched a Karma server for us. The server is watching
    the source and test directories for us. When we make changes in our ClojureScript
    files, the tests will run against our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to set up testing in ClojureScript. In the
    next exercise, we will learn how to write ClojureScript tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.06: Testing ClojureScript Code'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we configured a project for ClojureScript testing.
    In this exercise, we will write ClojureScript tests. We will use functions from
    the `cuerdas` library that allow us to manipulate strings. We will also test the
    asynchronous ClojureScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement and test three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`profanity-filter`: It is common to filter certain words in chat applications
    or web forums. A profanity filter will remove words that we consider inappropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefix-remover`: This function will use string functions and will remove prefixes
    from words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http-caller`: This function will make a HTTP call to a web address. This will
    help us test asynchronous code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import namespaces for the core file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `core.cljs` file, add the necessary namespaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the `cuerdas` namespace for string manipulation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a profanity filter. The first function that we will write in the `hello_test.core.cljs`
    file is a profanity filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we test whether a passed string contains the word `bad`. If
    it does, we replace it with the word `great`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Import the test namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `hello_test.core_test.cljs` file, import the necessary test namespaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a test for the `profanity-filter` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `hello_test.core_test.cljs` file, add a test for the profanity filter
    function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The tests look similar to the ones we wrote using the `clojure.test` library.
    We use `is` and `are` macros to set testing scenarios. We are ready to run the
    tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to run the tests, we call the `lein doo` task from the command line.
    If you have a `lein doo` running from the previous exercise, it will watch file
    changes and run the tests for us:![Figure 10.35: Calling the lein doo task from
    the command line'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_10_35.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.35: Calling the lein doo task from the command line'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The profanity filter test was run. The output informs us that one test was successful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you do not have `lein doo` running, you need to start `lein doo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starting the `lein doo` task will start watching our ClojureScript files for
    changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.36: Starting the lein doo task'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.36: Starting the lein doo task'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the `lein doo` is watching the changes in our file, we are ready. We are
    informed that the `karma` server has been started. The autorunner is watching
    for changes in the `src` and `test` directories. Any changes in these directories
    will result in `lein doo` running the tests again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to `hello_test.core_test.cljs`, save the file, and watch the tests being
    executed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.37: Executing the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_37.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.37: Executing the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are informed that one test has been successfully executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The autorunner will let us know if our tests fail. If we add the following
    test, the autorunner informs us that one test failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The test fails as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.38: The autorunner informs us when a test fails'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_38.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the test, we pass the lowercase string "`katy`" to the capitalize function
    from the `cuerdas` library. The `capitalize` function will uppercase the first
    letter, "k," and return a new string, "`Katy`". This new string is compared to
    the string `Katy` in a test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As both strings, `Katy` and `Katy`, are equal, the tests will pass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The autorunner tells us that all of the tests passed now:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.39: All of the tests passed after we fixed the string case'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_39.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.39: All of the tests passed after we fixed the string case'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can check for errors being thrown by our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we wanted to insert an apple in the fourth index, which
    does not exist as we have only three elements. Remember that, in Clojure, the
    first index is zero so the third element in a list has an index of two. Trying
    to add an element at index 4 generates an error in ClojureScript. In our test,
    we caught this error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.40: The third test passes because we caught the error in our code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_40.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.40: The third test passes because we caught the error in our code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The autorunner tests our code and the third test passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In ClojureScript, we can make requests to websites. These requests are asynchronous.
    We will import ClojureScript namespaces that help us to make asynchronous calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `cljs-http.client` namespace will allow us to make HTTP calls. Functions
    from the `core.async` namespace will manage asynchronous calls for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our HTTP function will take three arguments, a website address, HTTP parameters,
    and a callback function to call after we finish sending the request to the website
    address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have our function making asynchronous calls. We need to import this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'HTTP calls happen asynchronously in ClojureScript. A `GET` request will run
    a callback function when the request finishes. This is ideal for testing asynchronous
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `async` macro allows us to write an asynchronous block of code for testing.
    In our block, we make a GET request to GitHub API to access the list of current
    public users. The `http-get` function takes a callback function as the last parameter.
    In the callback, we check the response. A successful response will have the status
    `200`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final function call in the callback is `done`. `done` is a function that
    is invoked when we are ready to relinquish control and allow the next test to
    run:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.41: The fourth test is passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_41.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.41: The fourth test is passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our request was successful and the fourth test passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the namespaces for property-based testing. ClojureScript allows us to
    use property-based testing to check our functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We already know about generators and the properties used for property-based
    testing. With generators, we can create various types of function inputs such
    as numbers or strings. Properties allow us to describe the characteristics of
    the inputs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `defspec` macro allows us to write tests that can be run with the `clsj.test`
    library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With property-based tests, we can check 1,000 scenarios against our profanity
    filter. The structure of property-based tests in ClojureScript is the same as
    in Clojure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `for-all` macro, we specify what properties our function parameters
    should have. For the profanity filter, we generate ASCII strings. ASCII, abbreviated
    from American Standard Code for Information Interchange, is a character encoding
    standard for electronic communication:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.42: The fifth test is passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_42.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.42: The fifth test is passed'
  prefs: []
  type: TYPE_NORMAL
- en: Our fifth test passed. Furthermore, the `test.check` informed us that 1,000
    test scenarios were executed.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have seen how to set up testing in ClojureScript. We wrote
    functions and tested them using the `cljs.test` and `test.check` libraries. In
    the next section, we will see how to integrate tests with existing projects.
  prefs: []
  type: TYPE_NORMAL
- en: Testing ClojureScript Applications with Figwheel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Host Platform Interoperability with Java and JavaScript*, we
    learned about Figwheel. Figwheel allows us to create ClojureScript applications.
    Most developers use Figwheel because it provides hot-code reloading. It means
    that any changes in our code are recompiled and the application running in the
    web browser is updated.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous exercise, we learned how to add testing to a ClojureScript project.
    Figwheel comes with a testing configuration. Any Figwheel application is ready
    to add tests to after creating the application. Because the testing configuration
    is included in each project, developers save time. Developers do not need to install
    external tools or create the configuration; they can start writing tests straight
    away.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 9*, *Host Platform Interoperability with Java and JavaScript*,
    we talked about Figwheel projects in detail. As a reminder, in Figwheel, we use
    two concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reactive components – HTML elements that react to user actions – we will
    use the Rum library. The state of the application will be kept inside an atom.
    Concurrency is a topic covered in *Chapter 12*, *Concurrency*. For our purposes,
    an atom is a data structure like a collection. We learned about collections in
    *Chapter 1*, *Hello REPL!*. The main difference between collections and atoms
    is that we can alter the value of an atom, while collections are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.07: Tests in Figwheel Applications'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned that Figwheel supports testing ClojureScript
    applications. We revised the benefits of using Figwheel to create ClojureScript
    applications. We also reminded ourselves about important concepts in Figwheel
    applications, such as reactive components and application state management.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will investigate how Figwheel configures projects to support
    testing in ClojureScript. Figwheel aims to support developers creating applications.
    Figwheel sets up default testing configuration for us. In *Exercise 10.5*, *Setting
    Up Testing in ClojureScript*, we saw how much setup is needed to configure testing
    in ClojureScript. With Figwheel, we do not need to write this configuration; we
    can focus on writing our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write tests in Figwheel, we need to understand how Figwheel sets
    up the default testing configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Figwheel application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a new Figwheel project using Rum.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test the configuration in the project.clj file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figwheel puts some testing configuration in the `project.clj` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `project.clj` file, Figwheel defines aliases to help run tasks on
    the command line. An alias is a shortcut for commands that we use often. Using
    aliases saves developers typing. Figwheel defines the `fig:test` task.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This task runs on a command line with a number of parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`-m`: Search a file for the main function. Remember from *Chapter 8*, *Namespaces,
    Libraries, and Leiningen*, that the main function in Leiningen projects is an
    entry point in an application. We start applications in main functions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`-co`: Load options from a given file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the configuration in the `test.cljs.edn` file. Inside the `test.cljs.edn`
    file, we have the testing configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the Figwheel application is run, it launches a web page. Figwheel provides
    two web pages. There is one web page for the actual application that we are developing.
    Also, there is a different web page for testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figwheel also provides a main method inside the `test-app.test-runner` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the runner namespace. Inside the `test/test_app/test_runner.cljs` file,
    we have code for running ClojureScript tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the file, we require the namespaces that we want to test. Initially,
    the only namespace to test is a `test-app.core-test` namespace created by default
    by Leiningen. If we add more files for testing, we need to import namespaces in
    those files. The second namespace that is required is a Figwheel namespace with
    a utility function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Second, we have the `-main` function. This function is called by Leiningen to
    run tests. Figwheel provides a `run-tests-async` function. This means that tests
    are run in an asynchronous manner. This allows the tests to run faster than if
    run in a synchronous manner. They run faster because the tests do not need to
    wait for other tests to finish before they can be started.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `test/test_app/core_test.cljs` file, we have autogenerated tests
    by Figwheel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Figwheel first requires the `cljs.test` namespace with macros that we are familiar
    with. The tests will use macros such as `deftest`, `is`, and `testing`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second namespace required is the `test-app.core` namespace. This namespace,
    from the source directory, contains the implementation for a `multiply` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `core_test.cljs` file, we have two autogenerated tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both tests use the familiar `is` macro. With the `is` macro, we test whether
    calling the `multiply` function is equal to the expected output. Multiplying 1
    by 2 should equal calling the `multiply` function with two arguments: 1 and 2.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the default tests. When we create a new application based on Figwheel,
    the application has some default tests. Straight after creating the application,
    we can run the default tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.43 Using the fig:test command to run tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_43.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.43 Using the fig:test command to run tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use Leiningen to launch Figwheel. In order to run tests, we use the `fig:test`
    command-line task. This task will read the Figwheel configuration from the `project.clj`
    file and run tests according to the configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We saw two default tests in the previous steps. Both tests pass and we are informed
    about the tests passing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The selling point of Figwheel is hot-code reloading. In order to get an interactive
    development environment, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will launch Figwheel, which autocompiles code for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.44: Figwheel validates the configuration on the figwheel-main.edn
    file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_44.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.44: Figwheel validates the configuration on the figwheel-main.edn
    file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figwheel reads and validates the configuration on the `figwheel-main.edn` file.
    Then, `if` compiles our source code to the `dev-main.js` file. The test code is
    compiled to the `dev-auto-testing.js` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With Figwheel, we can see a summary of our tests in a browser. Go to `http://localhost:9500/figwheel-extra-main/auto-testing`:![Figure
    10.45: All tests passed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_10_45.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.45: All tests passed'
  prefs: []
  type: TYPE_NORMAL
- en: Figwheel informs us that all tests have passed. We have a summary displaying
    which tests were run.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how Figwheel supports testing in ClojureScript.
    We saw the default testing configuration provided by Figwheel. In the next exercise,
    we will see how to add tests to a Figwheel application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.08: Testing a ClojureScript Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to learn how to test ClojureScript applications.
    Often, front-end code is complex. The state of an application in the browser changes.
    User interactions result in many unpredictable scenarios. Having ClojureScript
    tests for frontend applications helps us to catch bugs early.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the Figwheel application template.
    It is a very common template for writing frontend applications in ClojureScript.
    We will create an application that will react to user actions. When a user clicks
    on the action button, we will increment a counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the count will be zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.46: The initial number of clicks is zero'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.46: The initial number of clicks is zero'
  prefs: []
  type: TYPE_NORMAL
- en: 'After six clicks the count will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.47: The count changes to six'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.47: The count changes to six'
  prefs: []
  type: TYPE_NORMAL
- en: We know what our application will do. We are ready to implement the functionality
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Figwheel application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a new Figwheel project using Rum.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the previous section, we learned that Figwheel supports testing. After creating
    a project, we are already set to run tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.48: Two tests containing two assertions are passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_48.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.48: Two tests containing two assertions are passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figwheel compiles our code and runs the tests. We test the tet-app.core-test
    namespace. The two tests pass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will implement a function to handle user clicks inside the `src/test_app/core.cljs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `handle-click` function has one parameter. The parameter is the current
    application state. We increment the value stored in the atom under the `:counter`
    key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will store the state application in an atom in the `core.cljs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The atom is a hash with the `:counter` key. The initial value of the key is
    zero.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the counter component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a Rum component that will display the number of mouse clicks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The component displays the number of clicks, which is passed as an argument.
    Inside the component, we use the `handle-click` function to respond to `:on-click`
    actions. Whenever a user clicks on the component, the `handle-click` function
    is called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a page component. We will put the `counter` component inside the `page-content`
    component. It is good practice to have a main component on the page where we will
    put all our components. In our example, we have one component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The container uses Rum's `reactive` directive. This directive instructs Rum
    to handle the component in a special manner. Reactive components will `react`
    to changes to the application state. Whenever there is a change to the application
    state, the component will be updated and redisplayed in the browser using the
    new application state. We learned about reactive components in *Chapter 9*, *Host
    Platform Interoperability with Java and JavaScript*, and refreshed our memory
    in the section preceding this exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to attach our `page-component` to a web page. As we did in
    *Chapter 9*, *Host Platform Interoperability with Java and JavaScript*, we use
    the `mount` method from Rum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `page-content` component is mounted to the web page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will run our Figwheel application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will launch Figwheel for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.49: Launching the Figwheel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_49.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.49: Launching the Figwheel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figwheel successfully launches our application. We can see the page in the
    browser. It will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.50: The number of clicks at the start of the application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_50.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.50: The number of clicks at the start of the application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the application starts, the number of clicks is zero. After six clicks,
    the state is updated and a new value is displayed on the page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.51: The updated number of clicks'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_51.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.51: The updated number of clicks'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We see that the component on the page reacts to our actions. It is time to write
    tests for the `handle-click` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will create fixtures for our tests. A test fixture is a fixed state of a
    set of objects used as a baseline for running tests. The purpose of a test fixture
    is to ensure that there is a well-known and fixed environment in which tests are
    run so that results are repeatable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we will manipulate the state of an application, we want the state to
    be the same every time we run our tests. We do not want previous tests to influence
    subsequent tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `handle-click` function takes a state atom as an argument. In order to test
    the handle-click function, we need a state atom. `cljs.test` provides the `use-fixtures`
    macro, which allows us to preset tests to the required state before tests are
    run. This is a good place to create a state atom for further manipulation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will put our tests inside the `core_test.cljs` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `:each` keyword, we specify that we want the fixtures to be run for
    each test. This way, we can set the state for each test. An alternative would
    be to use the `:only` keyword, which would set up fixtures only once per test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the fixtures, we have two keys:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`:before`: Runs a function before the test is executed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`:after`: Runs a function after the test is executed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `:before` and `:after`, we set the state of the application's atom. Before
    each test, we set `:counter` to zero. After each test, we reset the application
    state to `nil`. Setting the counter to zero resets it. This way, every time we
    run a new test, the counter is started from zero. Previous tests will not influence
    subsequent tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After setting up fixtures, we are ready to launch the test runner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test the `handle-click` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will test handling multiple clicks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `are` macro to simplify testing. We compare the expected result to
    the return value of calling the `handle-click` function. Calling `handle-click`
    three times should increase the counter to three.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will run the tests now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.52: Running the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_52.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.52: Running the tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we see in the summary, the tests pass. The `handle-click` test used `app-state`,
    which we set up using the `use-fixtures` macro. Before each test, the fixtures
    created an application state. After each test, the fixtures should reset the state
    to zero. We will write a new test to check whether the application state is reset.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the following test, we will test a single click:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we use the `is` macro to test a single click.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will run the tests again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.53: Running the tests again'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_10_53.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.53: Running the tests again'
  prefs: []
  type: TYPE_NORMAL
- en: Running the new test tells us that the state has been reset. We see that our
    test passed as the application state has been reset successfully.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to integrate testing into ClojureScript applications.
    We created a project using the Figwheel template. This template allowed us to
    create a web application. In the application, we added user interaction. The application
    counted the number of clicks. We wrote tests to make sure that our functions perform
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You are ready to start writing web applications and adding tests to them. In
    the following activity, you will put your new knowledge to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.02: Support Desk Application with Tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this activity is to add a testing suite to a web application. Many
    applications require complex functionality and many features. While manual testing
    can catch many bugs, it is time-consuming and requires many testers. With automated
    testing, checking applications are faster and more features can be tested. ClojureScript
    provides tools to help with unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we wrote a support desk application that allowed us
    to manage issues raised with the help desk ([https://packt.live/2NTTJpn](https://packt.live/2NTTJpn)).
    The application allows you to sort issues and resolve them when they are done.
    By sorting the issues, we can raise the priority of the issue. In this activity,
    we will add unit tests using `clsj.test` and `test.check` for property-based testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will write tests for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A function displaying the sort message status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function filtering the list of issues by priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function sorting the list of issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function deleting an item from the issues list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the testing dependencies to the `project.clj` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the namespaces to the `core_test.cljs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create fixtures with issues in the application state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for the sort message function, `cljs.test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for the sort message function using `test.check`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests to filter issues by priority function using `cljs.test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests to sort the issues list using `cljs.test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests to delete issues from the list using `cljs.test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests to handle the sort function using `cljs.test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial issues list will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.54: List of initial issues'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_54.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.54: List of initial issues'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after sorting will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.55: List after sorting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_55.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.55: List after sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the tests are run, the output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.56: Output after running the tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_10_56.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.56: Output after running the tests'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 730
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about testing in Clojure. First, we explored why
    testing is important. We looked at some of the benefits, such as reduced maintenance
    costs and bug fixing. We also learned what testing methodologies are available.
    We focused on unit testing as this is the most common type of test written by
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored four testing libraries available in Clojure. We started with
    the standard clojure.test library, which provides a rich set of testing features.
    The second library we learned about was Expectations. It allows us to write concise
    tests as it focuses on readability.
  prefs: []
  type: TYPE_NORMAL
- en: The `Midje` library allowed us to explore top-down test-driven development (TDD).
    We created a test for the main function and stubs for functions that would be
    implemented in the future. TDD allows us to focus on testing functions' features
    without worrying about implementing all of the subfunctions used.
  prefs: []
  type: TYPE_NORMAL
- en: The last library used was `test.check`, which introduced us to property-based
    testing. With property-based tests, we describe the properties of function arguments
    in a general form. This allows tests to generate input based on such properties.
    With this type of test, we can run thousands of test scenarios with a few lines
    of code. There's no need to enumerate every single test case.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we learned about testing in ClojureScript.
    We saw that the cljs.test library provides us with features comparable to the
    `clojure.test` library. With `clsj.test`, we were able to test ClojureScript code.
    We also looked at macros, allowing us to test asynchronous ClojureScript code.
    We also set up an autorunner to run ClojureScript tests automatically when our
    code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked through two activities that allowed us to use our testing
    knowledge in projects. We wrote tests using libraries we learned about for applications
    developed in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about macros. Macros are a powerful feature
    that allows us to influence the Clojure language.
  prefs: []
  type: TYPE_NORMAL
