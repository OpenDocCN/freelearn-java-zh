<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Presentation Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">In this chapter, we'll cover each topic by explaining the concept and showing examples of implementations.</span> <span class="calibre10">After reading this chapter, you will know about these concepts and will be able to implement them using Java EE 8</span>. Here are the topics that are covered in upcoming sections:</p>
<ul class="calibre15">
<li class="calibre16">Explaining <span class="calibre5">the presentation tier</span></li>
<li class="calibre16">Explaining the <span class="calibre5">intercepting filter pattern</span></li>
<li class="calibre16">Implementing the <span class="calibre5">intercepting filter pattern</span> using Java EE 8</li>
<li class="calibre16">Explaining the <span class="calibre5">front controller pattern</span></li>
<li class="calibre16">Implementing the <span class="calibre5">front controller pattern</span></li>
<li class="calibre16">Explaining the application controller pattern</li>
<li class="calibre16">Implementing the application controller pattern</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the presentation tier</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java EE platform is a distributed multitiered application model that has three widely used common tiers. These tiers are the presentation tier (or web tier), the business tier, and the integration tier (or EIS tier).</p>
<p class="mce-root">The presentation tier, also known as the web tier, contains the components that create a web application. This tier has many components that use the HTTP protocol, construct views and interfaces for users, and provide a web service. These components are called web components. There are two types of presentation tier:</p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Presentation-oriented tier</strong>: This type of presentation tier contains the components to construct an interactive web page and dynamic content using HTML and XHTML. These components are JavaServer Faces technology, Java Servlet technology, and JavaServer Page technology, which allow us to construct an interactive web page.</li>
<li class="calibre16"><strong class="calibre3">Server-oriented tier</strong>: This contains the components to construct an endpoint of a web service. These components are JAX-RS and JAX-WS.</li>
</ul>
<p class="mce-root">The presentation-oriented tier is generally used on web applications using component-based specifications such as <strong class="calibre8">JavaServer Face</strong>s technology, or web applications using action-based Java Servlet technology as well as <strong class="calibre8">JavaServer Pages</strong> technology. The server-oriented tier is generally used on web applications that create a REST <span class="calibre10">API </span>or web service that is consumed by the client running on a mobile platform or browser. In the following diagram, we can see how the presentation tier works:</p>
<div class="cdpaligncenter"><img src="Images/aeb967fa-baf8-48e7-98f6-19fece1ff59c.png" width="423" height="272" class="calibre30"/></div>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10"><span class="calibre10">As shown in the preceding diagram, the <strong class="calibre8">Client</strong> sends a <strong class="calibre8">Request</strong> to the server; the <strong class="calibre8">Presentation Tier</strong> processes the request and sends it to the <strong class="calibre8">Business Tier</strong>; the <strong class="calibre8">Business Tier</strong> then sends a response to the <strong class="calibre8">Presentation Tier</strong> if the request is not asynchronous, and finally the <strong class="calibre8">Presentation Tier</strong> processes and sends the response to the <strong class="calibre8">Client</strong>.</span></span></p>
<p class="mce-root">Because the <strong class="calibre8">Presentation Tier</strong> is responsible for promoting HTTP communications and connections with external users, this tier fulfills many interactions and communications between web components. Numerous tasks need to be performed for this to work well. These tasks include validating the data sent by a client, formatting it, sending it to the correct business component or class, and filtering the data and requests.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining intercepting filter pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When a client sends a request to the server, the server sometimes<span class="calibre10"> </span><span class="calibre10">processes this request/response to perform the following tasks:</span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Validating authentication</span></li>
<li class="calibre16">Generating log</li>
<li class="calibre16">Validating constraints</li>
<li class="calibre16">Verifying the browser of the client</li>
<li class="calibre16">Checking the duration between the request and response; calculating the response time</li>
<li class="calibre16">Setting a cookie</li>
</ul>
<p class="mce-root">However, we don't want to put these tasks within the logic of <span class="calibre10">processing</span><span class="calibre10"> the main request.</span> <span class="calibre10">Consequently, creating a pre-process and/or post-process to do these tasks is a good method for decoupling the main logic from the complementary logic.</span></p>
<p class="mce-root"><span class="calibre10"><span class="calibre10">The intercepting filter pattern is the pattern that </span></span>solves problems when we want to insert a logic that is not part of the main logic but we want to keep the two logics separated and decoupled. Merging the new logic with the main logic is a bad practice because these become coupled. <span class="calibre10">This pattern creates a filter to pre-process and post-process the request, permitting the creation of a logic block to solve some problems that are not part of the main problem, and thus decoupling both pieces of logic. Using this pattern, we can create a pluggable solution without modifying the main logic. Take a look at the model of the</span> <span class="calibre10">intercepting filter pattern</span> <span class="calibre10">i</span><span class="calibre10">n the following diagram:</span></p>
<div class="cdpaligncenter"><img src="Images/a97fc373-2329-4de7-b919-f73cd0e92d23.png" width="562" height="359" class="calibre31"/></div>
<p class="mce-root">In the preceding diagram, we have a <strong class="calibre8">Client</strong>, <strong class="calibre8">FilterManager</strong>, <strong class="calibre8">FilterChain</strong>, <strong class="calibre8">FilterOne</strong>, <strong class="calibre8">FilterTwo</strong>, <strong class="calibre8">FilterThree</strong>, and <strong class="calibre8">Target</strong>. The client sends a request to the server; the FilterManager creates a <strong class="calibre8">FilterChain</strong> with its filters ordered and initiates the processing; the <strong class="calibre8">FilterChain</strong> is an ordered collection of independent filters; <strong class="calibre8">FilterOne</strong>, <strong class="calibre8">FilterTwo</strong>, and <strong class="calibre8">FilterThree</strong> are the filters in the <strong class="calibre8">FilterChain</strong>, which can include N filters; Target is the resource that contains the main logic. The order of filter execution is important because some filters often need to be executed first. An example of filter priority is the task of validating authentication, which generally needs to be executed first because some tasks are executed after client authentication <span class="calibre10">only</span><span class="calibre10">.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the intercepting filter pattern using Java EE 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To implement this pattern with the best practices of Java EE 8, we will use the servlet filter from the Java Servlet specification. With the servlet filter, we can create an ordered request interceptor to treat the requests and responses. These interceptors are mapped by the URL pattern or servlet name. <span class="calibre10">The servlet filter can be configured with XML (on <kbd class="calibre18">web.xml</kbd>) or annotation. In our case, we will imagine that we want to create a log of all the requests that are sent to the server. We will also have two filters—one to log the access time and</span> another to log the information about the browser that the client is using<span class="calibre10">. To log the access time, we will create a filter called <kbd class="calibre18">LogAccessFilter</kbd>, and to log the browser information we will create a filter called <kbd class="calibre18">LogBrowserFilter</kbd>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing LogAccessFilter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we have the implementation of <kbd class="calibre18">LogAccessFilter</kbd>:</p>
<pre class="calibre23"><span class="calibre5">import </span>org.apache.logging.log4j.LogManager<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>org.apache.logging.log4j.Logger<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.annotation.<span class="calibre5">WebFilter</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Date<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@WebFilter</span>(<span class="calibre5">filterName </span>= <span class="calibre5">"LogAccess"</span><span class="calibre5">, </span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/*"</span>)<br class="calibre2"/><span class="calibre5">public class </span>LogAccessFilter <span class="calibre5">implements </span>javax.servlet.Filter {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private static </span>Logger <span class="calibre5">logger </span>= LogManager.<span class="calibre5">getLogger</span>(LogAccess.<span class="calibre5">class</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public void </span><span class="calibre5">destroy</span>() {<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">doFilter</span>(javax.servlet.ServletRequest req<span class="calibre5">, <br class="calibre2"/></span>    javax.servlet.ServletResponse resp<span class="calibre5">, </span>javax.servlet.FilterChain <br class="calibre2"/>    chain) <span class="calibre5">throws </span>javax.servlet.ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//Gets the initial date of request.<br class="calibre2"/></span><span class="calibre5">        </span>Date dateInitRequest = <span class="calibre5">new </span>Date()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Get IP of Client that sent a resquest.<br class="calibre2"/></span><span class="calibre5">        </span>String ip = ((HttpServletRequest)req).getRemoteAddr()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Following to next filter. If none next filter exist, follows   <br class="calibre2"/>        //for main logic.<br class="calibre2"/></span><span class="calibre5">        </span>chain.doFilter(req<span class="calibre5">, </span>resp)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Gets the end date of request.<br class="calibre2"/></span><span class="calibre5">        </span>Date dateEndRequest = <span class="calibre5">new </span>Date()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Logging the informations of IP and access time.<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">logger</span>.info(<span class="calibre5">"IP: "</span>+ip +<span class="calibre5">" Access time : "<br class="calibre2"/></span><span class="calibre5">                              </span>+ Long.<span class="calibre5">toString</span>(dateEndRequest.getTime() <br class="calibre2"/>                              - dateInitRequest.getTime())<br class="calibre2"/>                              + <span class="calibre5">" ms"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">init</span>(javax.servlet.FilterConfig config) <span class="calibre5">throws <br class="calibre2"/></span>    javax.servlet.ServletException {<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">As we can see in the code, to create one servlet filter, we need to create a class that extends <kbd class="calibre18">javax.servlet.Filter</kbd> and puts the <kbd class="calibre18">@WebFilter</kbd> <span class="calibre10">annotation</span><span class="calibre10"> </span><span class="calibre10">with</span> <kbd class="calibre18">filterName</kbd> <span class="calibre10">and</span> <kbd class="calibre18">urlPatterns</kbd><span class="calibre10"> </span><span class="calibre10">parameters, which define the filter name and the URLs to filter, before the definition of class</span><span class="calibre10"><span class="calibre10">. The following is a snippet of code that demonstrates how to do that:</span></span></p>
<pre class="mce-root2"><span class="calibre5">@WebFilter</span>(<span class="calibre5">filterName </span>= <span class="calibre5">"LogAccess"</span><span class="calibre5">, </span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/*"</span>)<br class="calibre2"/>public class LogAccessFilter implements javax.servlet.Filter{<br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">Note that the servlet filter uses the </span><span class="calibre10">chain of responsibility pattern to walk throughout the filters (objects that are servlet filter). The following is a snippet of code that uses a chain of responsibility pattern:</span></p>
<pre class="mce-root2">chain.doFilter(req<span class="calibre5">, </span>resp)<span class="calibre5">;</span></pre>
<p class="mce-root">In the <span class="calibre10">preceding </span>line of code, we established the filter name as <kbd class="calibre18">LogAccess</kbd> through the <kbd class="calibre18">filterName</kbd> parameter<span class="calibre10">. This will filter all requests, because the </span><kbd class="calibre18"><span class="calibre5">urlPatterns</span></kbd><span class="calibre10"> </span><span class="calibre10">parameter has the <kbd class="calibre18">"/*"</kbd></span> <span class="calibre10">value</span><span class="calibre10">. If we filter according to servlet name, we need to use the following annotation:</span></p>
<pre class="mce-root2"><span class="calibre5">//Servlet1 and Servlet2 are the servlets to filter.<br class="calibre2"/>@WebFilter</span>(<span class="calibre5">filterName </span>= <span class="calibre5">"LogAccess"</span><span class="calibre5">, </span><span class="calibre5">servletNames </span>= {<span class="calibre5">"servlet1"</span><span class="calibre5">,</span><span class="calibre5">"servlet2"</span>})</pre>
<p class="mce-root">The <kbd class="calibre18">doFilter</kbd> <span class="calibre10">method </span>is responsible for pre-processing and post-processing and establishes when to follow the request to the next filter or servlet (main logic). To follow the request to the next filter or servlet, the following code needs be executed:<em class="calibre12"><br class="calibre9"/></em></p>
<pre class="mce-root2">//Following to next filter or servlet.<br class="calibre2"/>chain.doFilter(req<span class="calibre5">, </span>resp)<span class="calibre5">;</span></pre>
<p class="mce-root">When the preceding <span class="calibre10">code</span><span class="calibre10"> is executed, the current filter executes </span><span class="calibre10">only</span><span class="calibre10"> </span><span class="calibre10">the next line when the other filters and servlets finish their processing.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing LogBrowserFilter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The implementation of <kbd class="calibre18">LogBrowserFilter</kbd> is as follows:</p>
<pre class="mce-root2"><span class="calibre5">import </span>org.apache.logging.log4j.LogManager<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>org.apache.logging.log4j.Logger<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.*<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.annotation.<span class="calibre5">WebFilter</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@WebFilter</span>(<span class="calibre5">filterName </span>= <span class="calibre5">"LogBrowser"</span><span class="calibre5">,</span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/*"</span>)<br class="calibre2"/><span class="calibre5">public class </span>LogBrowserFilter <span class="calibre5">implements </span>Filter {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private static </span>Logger <span class="calibre5">logger </span>= LogManager.<span class="calibre5">getLogger</span>(LogBrowser.<span class="calibre5">class</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public void </span><span class="calibre5">destroy</span>() {<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">doFilter</span>(ServletRequest req<span class="calibre5">, </span>ServletResponse resp<span class="calibre5">, </span>FilterChain chain) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//Get userAgent that contain browse informations.<br class="calibre2"/></span><span class="calibre5">        </span>String userAgent = ((HttpServletRequest)req).getHeader(<span class="calibre5">"User-Agent"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Get IP of Client that sent a resquest.<br class="calibre2"/></span><span class="calibre5">        </span>String ip = ((HttpServletRequest)req).getRemoteAddr()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Logging the informations of IP and Browser.<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">logger</span>.info(<span class="calibre5">"IP: "</span>+ip +<span class="calibre5">" Browser info: "</span>+userAgent)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Following to the next filter. If none next filter exist, follow to main logic.<br class="calibre2"/></span><span class="calibre5">        </span>chain.doFilter(req<span class="calibre5">, </span>resp)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">init</span>(FilterConfig config) <span class="calibre5">throws </span>ServletException {<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding filter, we get the client IP and <span class="calibre10">browser</span><span class="calibre10"> </span><span class="calibre10">information and log them. The <kbd class="calibre18">LogBrowserFilter</kbd> </span><span class="calibre10">operation</span><span class="calibre10"> </span><span class="calibre10">is similar to that of <kbd class="calibre18">LogAccessFilter</kbd>.</span></p>
<p class="mce-root">To define the order of filter execution, we need to configure the <kbd class="calibre18">web.xml</kbd> and add the filter mapping information. Here, we can see <kbd class="calibre18">web.xml</kbd> with <span class="calibre10"><span class="calibre10">its</span></span> configuration:</p>
<pre class="mce-root2"><span class="calibre5">&lt;web-app </span><span class="calibre5">version</span><span class="calibre5">="3.1"<br class="calibre2"/></span><span class="calibre5">         </span><span class="calibre5">xmlns</span><span class="calibre5">="http://xmlns.jcp.org/xml/ns/javaee"<br class="calibre2"/></span><span class="calibre5">         </span><span class="calibre5">xmlns:</span><span class="calibre5">xsi</span><span class="calibre5">="http://www.w3.org/2001/XMLSchema-instance"<br class="calibre2"/></span><span class="calibre5">         </span><span class="calibre5">xsi</span><span class="calibre5">:schemaLocation</span><span class="calibre5">="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span><span class="calibre5">&gt;</span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    &lt;filter&gt;<br class="calibre2"/></span><span class="calibre5">        &lt;filter-name&gt;</span>LogBrowser<span class="calibre5">&lt;/filter-name&gt;<br class="calibre2"/></span><span class="calibre5">        &lt;filter-class&gt;</span>com.rhuan.filter.LogBrowserFilter<span class="calibre5">&lt;/filter-class&gt;<br class="calibre2"/></span><span class="calibre5">    &lt;/filter&gt;<br class="calibre2"/></span><span class="calibre5">    &lt;filter&gt;<br class="calibre2"/></span><span class="calibre5">        &lt;filter-name&gt;</span>LogAccess<span class="calibre5">&lt;/filter-name&gt;<br class="calibre2"/></span><span class="calibre5">        &lt;filter-class&gt;</span>com.rhuan.filter.LogAccessFilter<span class="calibre5">&lt;/filter-class&gt;<br class="calibre2"/></span><span class="calibre5">    &lt;/filter&gt;<br class="calibre2"/></span><span class="calibre5">&lt;/web-app&gt;</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The configurations defined in <kbd class="calibre18">web.xml</kbd> override the <span class="calibre10">annotation </span><span class="calibre10">configurations. Thus, if we put the <kbd class="calibre18">urlPattern</kbd> configuration on <kbd class="calibre18">web.xml</kbd>, then the configuration considered is <kbd class="calibre18">web.xml</kbd>'s configuration. We don't put the filter mapping </span><span class="calibre10">information</span><span class="calibre10"> on <kbd class="calibre18">web.xml</kbd> because this is already on the annotation configuration in the code. The </span><span class="calibre10"><kbd class="calibre18">web.xml</kbd> </span><span class="calibre10">configuration defines the order—<kbd class="calibre18">LogBrowserFilter</kbd> will be called first, followed by <kbd class="calibre18">LogAccessFilter</kbd>, and then the main logic (servlet).</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deciding filter mapping</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Defining the mapping method is crucial to implementing the intercepting <span class="calibre10">filter pattern</span>. This is because a bad method for mapping can <span class="calibre10">impact </span>the project <span class="calibre10">directly</span><span class="calibre10"> </span><span class="calibre10">and cause rework. We have two filter mapping types—</span><kbd class="calibre18">UrlPattern</kbd> <span class="calibre10">and servlet name.</span></p>
<p class="mce-root">The use of <kbd class="calibre18">UrlPatterns</kbd> is indicated when we want to filter the HTTP Requests to non-specific resources or files, <span class="calibre10">but we also want to filter various unknown resources. Here are some examples of this:</span></p>
<ul class="calibre15">
<li class="calibre16"><kbd class="calibre18">*.jsp</kbd>: This filters all requests to JSP pages. If one JSP page is added to the server, then the filter will filter the new JSP page without making any modifications.</li>
<li class="calibre16"><kbd class="calibre18">/*</kbd>: This filters all requests to all resources or files on the server. If one resource or file is added to the server, then the filter will filter this new resource or file without performing any modifications.</li>
<li class="calibre16"><kbd class="calibre18">/user/*</kbd>: This filters all requests to all resources or files on the server that have a URI beginning with <kbd class="calibre18">/user</kbd>. If one resource or file that is accessed by a URI beginning with <kbd class="calibre18">/user</kbd> is added on servlet, then the filter will filter this new resource or file without performing any modifications.</li>
</ul>
<p class="mce-root">The servlet name used to map the filter indicates when you want to filter a specific servlet, independent of its <kbd class="calibre18">urlPattern</kbd>. This way of mapping allows us to modify one <kbd class="calibre18">urlPattern</kbd> of the mapped servlet without performing any modifications on the filter. Here are some examples:</p>
<ul class="calibre15">
<li class="calibre16"><kbd class="calibre18">{servlet1}</kbd>: This only maps the servlet named as <kbd class="calibre18">servlet1</kbd>. If the <kbd class="calibre18">urlPatterns</kbd> of <kbd class="calibre18">servlet1</kbd> are modified, then the filter doesn't need to be modified.</li>
<li class="calibre16"><kbd class="calibre18">{servlet1,servlet2}</kbd>: This maps two servlets named <kbd class="calibre18">servlet1</kbd> and <kbd class="calibre18">servlet2</kbd>. Its behavior is similar to the previous example shown, in which only one servlet was mapped.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the FrontController pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the Java EE world, we commonly work with complex projects that have similar functionalities and processes. Sometimes, using various controllers to handle a request is a bad practice because it needs to be configured <span class="calibre10">at multiple endpoints </span>and incurs a large cost of creation and maintenance. Consequently, creating a central point to treat a request is a very good solution, as it creates one point to manage all or a group of requests and then sends this request to the correct process. We can then treat all points that are common to all functionalities and send the request to a process to treat the questions that are not common to all but are specific to one functionality. Some configurations, such as session configuration, <span class="calibre10"><span class="calibre10">the maximum size limit</span></span> of a request, cookie, and header, are common to all requests and can be configured <span class="calibre10"><span class="calibre10">from </span></span>a central point.</p>
<p class="mce-root">The <kbd class="calibre18">FrontController</kbd> pattern is a pattern that creates a central manager to treat all requests or a request group of an application and then sends the requests to one specific process, which is generally a command. This pattern is rarely used on common projects because today we have some <span class="calibre10"><span class="calibre10">ready-made solutions,</span></span> and implementing this pattern is generally unnecessary. This pattern is used by frameworks such as JSF, Spring MVC, and struts. The following diagram depicts this pattern:</p>
<div class="cdpaligncenter"><img src="Images/ff229c63-0c7a-40f5-93b2-40bd5ed7fa5c.png" width="575" height="210" class="calibre32"/></div>
<p class="mce-root">In the preceding diagram, we have <strong class="calibre8">FrontController</strong>, <strong class="calibre8">AbstractCommand</strong>, <strong class="calibre8">Command1</strong>, and <strong class="calibre8">Command2</strong>. <strong class="calibre8">FrontController</strong> receives all requests, treats some common points of the request, and sends this request to the <span class="calibre10">matching</span> command. <strong class="calibre8">AbstractCommand</strong> is the <kbd class="calibre18">abstract</kbd> class of command. <strong class="calibre8">Command1</strong> and <strong class="calibre8">Command2</strong> are the subclasses of command, which implement its correspondent logic.</p>
<p class="mce-root">In our case, we will have two pages—a homepage and a login page. If the user is logged in at the moment that a request is sent, then the application will launch the login page, and then the homepage.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing FrontController</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we have an implementation of <kbd class="calibre18">MyAppController</kbd>, which is a <kbd class="calibre18">FrontController</kbd> to treat all the requests of an application:</p>
<pre class="calibre23"><span class="calibre5">import </span>com.rhuan.action.Command.AbstractCommand<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>com.rhuan.action.Command.HomeCommand<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>com.rhuan.action.Command.LoginCommand<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>org.apache.logging.log4j.LogManager<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>org.apache.logging.log4j.Logger<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.ServletException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.annotation.<span class="calibre5">WebServlet</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServlet<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletResponse<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@WebServlet</span>(<span class="calibre5">name </span>= <span class="calibre5">"MyAppController"</span><span class="calibre5">, </span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/myapp/*"</span>)<br class="calibre2"/><span class="calibre5">public class </span>MyAppController <span class="calibre5">extends </span>HttpServlet {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private static </span>Logger <span class="calibre5">logger </span>= <br class="calibre2"/>    LogManager.<span class="calibre5">getLogger</span>(MyAppController.<span class="calibre5">class</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private final </span>String <span class="calibre5">PAGE_ERROR </span>= <span class="calibre5">"/pageError.jsp"</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    protected void </span><span class="calibre5">doPost</span>(HttpServletRequest request<span class="calibre5">, <br class="calibre2"/></span>   HttpServletResponse response) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/>        processRequest(request<span class="calibre5">,</span>response)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">protected void </span><span class="calibre5">doGet</span>(HttpServletRequest request<span class="calibre5">, <br class="calibre2"/></span>   HttpServletResponse response) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/>        processRequest(request<span class="calibre5">,</span>response)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">protected void </span><span class="calibre5">processRequest</span>(HttpServletRequest<br class="calibre2"/>                                 request<span class="calibre5">, </span>HttpServletResponse response)<br class="calibre2"/>            <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>java.io.IOException {<br class="calibre2"/>        String resultPage<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>AbstractCommand command = <span class="calibre5">null;<br class="calibre2"/></span><span class="calibre5">        try </span>{<br class="calibre2"/><br class="calibre2"/>            <span class="calibre5">//Create a correspondent Command.<br class="calibre2"/></span><span class="calibre5">            </span><span class="calibre5">if</span>(request.getSession().getAttribute(<span class="calibre5">"USER"</span>) == <span class="calibre5">null</span>)<br class="calibre2"/>                command = <span class="calibre5">new </span>LoginCommand()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">            else </span>command = <span class="calibre5">new </span>HomeCommand()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">            </span><span class="calibre5">//Execute the Command that return a page.<br class="calibre2"/></span><span class="calibre5">            </span>resultPage = command.execute()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>} <span class="calibre5">catch </span>(Exception e) {<br class="calibre2"/>            <span class="calibre5">logger</span>.error(e.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>resultPage = <span class="calibre5">PAGE_ERROR</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//Dispatch to correspondent page.<br class="calibre2"/></span><span class="calibre5">        </span>getServletContext().getRequestDispatcher(resultPage)<br class="calibre2"/>                           .forward(request<span class="calibre5">, </span>response)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre10"><span class="calibre10">In the following code snippet, it is very important to note</span></span> that <kbd class="calibre18">urlPattern</kbd> is used to define which requests a context will send to our controller. Here's how we do this:</p>
<pre class="mce-root2"><span class="calibre5">//Defining the urlPattern to Front Controller<br class="calibre2"/>@WebServlet</span>(<span class="calibre5">name </span>= <span class="calibre5">"MyAppController"</span><span class="calibre5">, </span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/myapp/*"</span>)<br class="calibre2"/>public class MyAppController extends HttpServlet {<br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root">On the <kbd class="calibre18">urlPattern</kbd>, the value is <kbd class="calibre18">"/myapp/*"</kbd>. As previously <span class="calibre10">shown in the preceding code snippet</span><span class="calibre10">, this</span> URL pattern (<kbd class="calibre18">"/myapp/*"</kbd>) <span class="calibre10">establishes that all requests to the</span> <kbd class="calibre18">myapp</kbd> <span class="calibre10">URI are sent to our controller. For example, <kbd class="calibre18">http://ip:port/context/myapp/myfuncionality</kbd> is sent to our controller.</span></p>
<p class="mce-root">When we implement this pattern, it is very important to pay attention to the use of attributes on servlets, because all the class attributes on a servlet are shared with all threads or all requests.</p>
<p class="mce-root">All <kbd class="calibre18">GET</kbd> requests or <kbd class="calibre18">POST</kbd> requests are sent to the <kbd class="calibre18">processRequest</kbd> method, which implements the logic to send the request to the respective command and executes the respective logic. After the correct command is set, the respective command is executed and the page is dispatched. Here, we have the line that executes the command and dispatches the request to the correct page:</p>
<pre class="mce-root2">//Execute a Command<br class="calibre2"/>resultPage = command.execute()<span class="calibre5">;</span></pre>
<p class="mce-root"><span class="calibre10">Dispatching the request to the corresponding page:</span></p>
<pre class="mce-root2"><span class="calibre5">//Dispatch to correspondent page.<br class="calibre2"/></span>getServletContext().getRequestDispatcher(resultPage)<br class="calibre2"/>                           .forward(request<span class="calibre5">, </span>response)<span class="calibre5">;</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the commands</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we have <kbd class="calibre18">AbstractCommand</kbd>, which is an <kbd class="calibre18">abstract</kbd> class with one <span class="calibre10"><kbd class="calibre18">execute</kbd> </span><span class="calibre10">method. This is the <kbd class="calibre18">abstract</kbd> command, and the <kbd class="calibre18">execute</kbd> method is implemented on the subclasses:</span></p>
<pre class="mce-root2"><span class="calibre5">public abstract class </span>AbstractCommand {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public abstract </span>String <span class="calibre5">execute</span>()<span class="calibre5">;<br class="calibre2"/></span>}</pre>
<p class="mce-root">In the following code snippet, we have the subclass <kbd class="calibre18">HomeCommand</kbd>, which is the implementation of <kbd class="calibre18">AbstractCommand</kbd>. The method <kbd class="calibre18">execute()</kbd> returns the path to the home page (<kbd class="calibre18">/home.jsp</kbd>):</p>
<pre class="mce-root2"><br class="calibre2"/><span class="calibre5">public class </span>HomeCommand <span class="calibre5">extends </span>AbstractCommand {<br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public </span>String <span class="calibre5">execute</span>() {<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">"/home.jsp"</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root">Here, we have the <kbd class="calibre18"><span class="calibre5">LoginCommand</span></kbd> <span class="calibre10">subclass, which is the implementation of <kbd class="calibre18">AbstractCommand</kbd>. The </span><kbd class="calibre18">execute()</kbd> <span class="calibre10">method</span> <span class="calibre10">returns the path to the login page (<kbd class="calibre18">/login.jsp</kbd>):</span></p>
<pre class="mce-root2"><br class="calibre2"/><span class="calibre5">public class </span>LoginCommand <span class="calibre5">extends </span>AbstractCommand {<br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public </span>String <span class="calibre5">execute</span>() {<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">"/login.jsp"</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The application controller pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Some web applications have a complex logic for defining the correct view, content, or action to invoke. The MVC controller can be used to make this decision and get the correct view, content, or action. However, sometimes the logic to define a decision is very hard, and using the MVC controller to do this can cause duplication of a lot of code. To solve this, we need to centralize the logic at one point to permit an easy maintenance and a central logic point.</p>
<p class="mce-root">The application controller pattern is the pattern that permits the centralization of all view logic and promotes a unique process to define the flow of pages. This pattern is used together with <kbd class="calibre18">FrontController</kbd>, discussed earlier, and is an intermediary between <kbd class="calibre18">FrontController</kbd> and <kbd class="calibre18">Command</kbd>. Using this pattern, we will promote the decoupling between view treatment and request treatment. The following diagram represents this:</p>
<div class="cdpaligncenter"><img src="Images/639d81e1-6970-4ef2-878b-3f7ce96a3c2d.png" width="716" height="221" class="calibre33"/></div>
<p class="mce-root">In the preceding diagram, we can see the <strong class="calibre8">ApplicationController</strong> between <strong class="calibre8">FrontController</strong> and <strong class="calibre8">AbstractController</strong>. When the client sends a request, the <strong class="calibre8">FrontController</strong> receives this and treats points about the request. The <strong class="calibre8">FrontController</strong> then sends this request to <strong class="calibre8">ApplicationController</strong>, which treats points about the view and flow and defines the correct <strong class="calibre8">Command</strong> to execute.</p>
<p class="mce-root">In our example scenario, we want to create one point to download a file on our server, and this point can <span class="calibre10">only</span><span class="calibre10"> </span><span class="calibre10">be accessed by</span> <span class="calibre10">a logged-in user. As well as this, we </span><span class="calibre10">will</span><span class="calibre10"> </span><span class="calibre10">only accept </span><span class="calibre10">PDF</span><span class="calibre10"> </span><span class="calibre10">downloads and JPG files. In this example, we will create one class called <kbd class="calibre18">DownloadFrontController</kbd> to receive the request. We will also create a class called </span><kbd class="calibre18">DownloadApplicationController</kbd> to process the logic of view and content choice. <kbd class="calibre18">AbstractCommand</kbd> is the <kbd class="calibre18">abstract</kbd> class for commands. In addition to this, we will create <kbd class="calibre18">PdfCommand</kbd>, which is an implementation of <kbd class="calibre18">AbstractCommand</kbd> that processes the logic to download one PDF file. Finally, we will create <kbd class="calibre18">JpgCommand</kbd>, <span class="calibre10">which is an implementation of</span> <kbd class="calibre18">AbstractCommand</kbd><span class="calibre10"> that processes the logic to download one JPG file.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing DownloadFrontController</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we have the implementation of <kbd class="calibre18">DownloadFrontController</kbd>, which is a Servlet used to download files:</p>
<pre class="calibre23"><span class="calibre5">import </span>javax.servlet.ServletException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.annotation.<span class="calibre5">WebServlet</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServlet<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletResponse<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@WebServlet</span>(<span class="calibre5">name </span>= <span class="calibre5">"DownloadFrontController"</span><span class="calibre5">, </span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/download/*"</span>)<br class="calibre2"/><span class="calibre5">public class </span>DownloadFrontController <span class="calibre5">extends </span>HttpServlet {<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">protected void </span><span class="calibre5">doPost</span>(HttpServletRequest request<span class="calibre5">,  <br class="calibre2"/></span>   HttpServletResponse response) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/>        processRequest(request<span class="calibre5">,</span>response)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">protected void </span><span class="calibre5">doGet</span>(HttpServletRequest request<span class="calibre5">, <br class="calibre2"/></span>   HttpServletResponse response) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/>        processRequest(request<span class="calibre5">,</span>response)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">protected void </span><span class="calibre5">processRequest</span>(HttpServletRequest<br class="calibre2"/>                                  request<span class="calibre5">, </span>HttpServletResponse <br class="calibre2"/>                                  response)<br class="calibre2"/>            <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>java.io.IOException {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//If user is logged the request is sent to <br class="calibre2"/>        ApplicationController,<br class="calibre2"/></span><span class="calibre5">        // then one error 401 is sent to client.<br class="calibre2"/></span><span class="calibre5">       </span><span class="calibre5">if</span>(Objects.nonNull(request.getSession().getAttribute(<span class="calibre5">"USER"</span>))) {<br class="calibre2"/><br class="calibre2"/>            <span class="calibre5">//Send the request to ApplicationController<br class="calibre2"/></span><span class="calibre5">            </span><span class="calibre5">new </span>DownloadApplicationController(request<span class="calibre5">, <br class="calibre2"/></span>            response).process()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">else {<br class="calibre2"/>            </span>response.sendError(<span class="calibre5">401</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        }<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding block of code, we have the <kbd class="calibre18">DownloadFrontController</kbd> <span class="calibre10">class </span>with the logic to process a request. This class is a servlet that responds to all requests sent to <kbd class="calibre18">/download/*</kbd> using the following line of code:</p>
<pre class="mce-root2"><span class="calibre5">@WebServlet</span>(<span class="calibre5">name </span>= <span class="calibre5">"DownloadFrontController"</span><span class="calibre5">, </span><span class="calibre5">urlPatterns </span>= <span class="calibre5">"/download/*"</span>)</pre>
<p class="mce-root">All <kbd class="calibre18">GET</kbd> requests or <kbd class="calibre18">POST</kbd> requests are sent to the <kbd class="calibre18">processRequest</kbd> method, inside which we have the code to send the request to <kbd class="calibre18">DownloadApplicationController</kbd>. The following line of code does just that:</p>
<pre class="mce-root2"><span class="calibre5">//Send the request to ApplicationController<br class="calibre2"/></span><span class="calibre5">new </span>DownloadApplicationController(request<span class="calibre5">, </span>response).process()<span class="calibre5">;</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing DownloadApplicationController</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we have the implementation of <kbd class="calibre18">DownloadApplicationController</kbd>, which is responsible for deciding the correct command to send the request. The process for deciding the correct command can be carried out in several ways, with reflections and annotations, using switch cases and maps, among others. In our example, we use a map to help us:</p>
<pre class="calibre23"><span class="calibre5">import </span>com.rhuan.action.Command.AbstractCommand<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>com.rhuan.action.Command.PdfCommand<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>org.apache.logging.log4j.LogManager<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>org.apache.logging.log4j.Logger<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.ServletException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletResponse<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.HashMap<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Map<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public class </span>DownloadApplicationController {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private static </span>Logger <span class="calibre5">logger </span>= LogManager.<span class="calibre5">getLogger</span>(DownloadApplicationController.<span class="calibre5">class</span>)<span class="calibre5">;</span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private final </span>String <span class="calibre5">PAGE_ERROR </span>= <span class="calibre5">"/pageError.jsp"</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private </span>HttpServletRequest <span class="calibre5">request</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private </span>HttpServletResponse <span class="calibre5">response</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private </span>Map&lt;String<span class="calibre5">, </span>Class&gt; <span class="calibre5">map</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private </span>String <span class="calibre5">key</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public </span><span class="calibre5">DownloadApplicationController</span>(HttpServletRequest<br class="calibre2"/>                                         request<span class="calibre5">, </span>HttpServletResponse <br class="calibre2"/>                                         response){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//On our example, only PDF and JPG is acepted to download.<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">this</span>.<span class="calibre5">map </span>= <span class="calibre5">new </span>HashMap&lt;String<span class="calibre5">, </span>Class&gt;()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        this</span>.<span class="calibre5">map</span>.put(<span class="calibre5">"PDF"</span><span class="calibre5">, </span>PdfCommand.<span class="calibre5">class</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        this</span>.<span class="calibre5">map</span>.put(<span class="calibre5">"JPG"</span><span class="calibre5">, </span>PdfCommand.<span class="calibre5">class</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        this</span>.<span class="calibre5">request </span>= request<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        this</span>.<span class="calibre5">response </span>= response<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">process</span>(){<br class="calibre2"/><br class="calibre2"/>       <span class="calibre5">//Processes the URI and creates the key using URI.<br class="calibre2"/></span><span class="calibre5">       </span><span class="calibre5">this</span>.processUri()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Validates if the request is valid.<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">if </span>(!validate()) {<br class="calibre2"/>            <span class="calibre5">try </span>{<br class="calibre2"/>                <span class="calibre5">response</span>.sendError(4<span class="calibre5">00</span>)<span class="calibre5">;</span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">            </span>} <span class="calibre5">catch </span>(IOException e1) {<br class="calibre2"/>                <span class="calibre5">logger</span>.error(e1.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>}<br class="calibre2"/><br class="calibre2"/>            <span class="calibre5">return;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/><br class="calibre2"/>       <span class="calibre5">//Get the correspondent command.<br class="calibre2"/></span><span class="calibre5">       </span>Class commandClass = <span class="calibre5">map</span>.get(<span class="calibre5">key</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">       boolean </span>error = <span class="calibre5">false;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">       try </span>{<br class="calibre2"/><br class="calibre2"/>            AbstractCommand command = (AbstractCommand) <br class="calibre2"/>            commandClass.newInstance()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">            </span><span class="calibre5">//Executes the command.<br class="calibre2"/></span><span class="calibre5">            </span>command.execute(<span class="calibre5">request</span><span class="calibre5">,</span><span class="calibre5">response</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>} <span class="calibre5">catch </span>(InstantiationException e) {<br class="calibre2"/>            <span class="calibre5">logger</span>.error(e.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>error = <span class="calibre5">true;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>} <span class="calibre5">catch </span>(IllegalAccessException e) {<br class="calibre2"/>            <span class="calibre5">logger</span>.error(e.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>error = <span class="calibre5">true;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>} <span class="calibre5">catch </span>(ServletException e) {<br class="calibre2"/>            <span class="calibre5">logger</span>.error(e.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>error = <span class="calibre5">true;<br class="calibre2"/></span><span class="calibre5">        </span>} <span class="calibre5">catch </span>(IOException e) {<br class="calibre2"/>            <span class="calibre5">logger</span>.error(e.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>error = <span class="calibre5">true;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//If an error ocorred, response 500.<br class="calibre2"/>        </span><span class="calibre5">if(error){<br class="calibre2"/></span><span class="calibre5">             </span><span class="calibre5">try </span>{<br class="calibre2"/>                 <span class="calibre5">response</span>.sendError(<span class="calibre5">500</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">             </span>} <span class="calibre5">catch </span>(IOException e1) {<br class="calibre2"/>                 <span class="calibre5">logger</span>.error(e1.getMessage())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">                 return;<br class="calibre2"/></span><span class="calibre5">             </span>}<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private void </span><span class="calibre5">processUri</span>(){<br class="calibre2"/><br class="calibre2"/>        String uri = <span class="calibre5">request</span>.getRequestURI()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        if</span>(uri.startsWith(<span class="calibre5">"/"</span>)) uri = uri.replaceFirst(<span class="calibre5">"/"</span><span class="calibre5">, </span><span class="calibre5">""</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>String[] uriSplitted = uri.split(<span class="calibre5">"/"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        if</span>(uriSplitted.<span class="calibre5">length </span>&gt; 2)<br class="calibre2"/>            <span class="calibre5">key </span>= uriSplitted[2].toUpperCase()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private boolean </span><span class="calibre5">validate</span>(){<br class="calibre2"/><br class="calibre2"/>        String uri = <span class="calibre5">request</span>.getRequestURI()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        if</span>(uri.startsWith(<span class="calibre5">"/"</span>)) uri = uri.replaceFirst(<span class="calibre5">"/"</span><span class="calibre5">, </span><span class="calibre5">""</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>String[] uriSplitted = uri.split(<span class="calibre5">"/"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        return </span>uriSplitted.<span class="calibre5">length </span>== 3<span class="calibre5"> </span>&amp;&amp; <span class="calibre5">map</span>.containsKey(<span class="calibre5">key</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In the preceding code, we created two methods to help us to process and validate the URI, the <kbd class="calibre18">processUri</kbd> method, and the <kbd class="calibre18">validated</kbd> method. After processing the URI, validating the request and generating the <kbd class="calibre18">key</kbd>, the code finds the correct command using the <kbd class="calibre18">key</kbd> generated. In the following code snippet, we have the line of code that gets the c<span class="calibre10">ommand class </span>by <kbd class="calibre18">key</kbd>, <span class="calibre10">creates a new instance of the command, and executes the following <kbd class="calibre18">command</kbd>:</span></p>
<pre class="mce-root2"><span class="calibre5">//Get the correspondent command.<br class="calibre2"/></span>Class commandClass = <span class="calibre5">map</span>.get(<span class="calibre5">key</span>)<span class="calibre5">;</span></pre>
<p class="mce-root">A new instance of the command is then created using the <kbd class="calibre18">newInstance()</kbd> <span class="calibre10">method</span><span class="calibre10"> </span><span class="calibre10">:</span></p>
<pre class="mce-root2">//Instantiate the command    <br class="calibre2"/>AbstractCommand command = (AbstractCommand) commandClass.newInstance()<span class="calibre5">;</span></pre>
<p class="mce-root"><span class="calibre10">The command is then executed, </span><span class="calibre10">passing <kbd class="calibre18">request</kbd> and <kbd class="calibre18">response</kbd> as parameters:</span></p>
<pre class="mce-root2"><span class="calibre5">//Executes the command.<br class="calibre2"/></span>command.execute(<span class="calibre5">request</span><span class="calibre5">,</span><span class="calibre5">response</span>)<span class="calibre5">;</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing commands</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we have the <kbd class="calibre18">abstract</kbd> class <kbd class="calibre18">AbstractCommand</kbd>, which includes the abstract <kbd class="calibre18"><span class="calibre5">execute</span></kbd> <span class="calibre10">method</span><span class="calibre10">.</span> <span class="calibre10">A</span>ll implementations of this command extend <kbd class="calibre18">AbstractCommand</kbd>, which is an <kbd class="calibre18">abstract</kbd> class:</p>
<pre class="calibre23"><span class="calibre5">package </span>com.rhuan.action.Command<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.ServletException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletResponse<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public abstract class </span>AbstractCommand {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public abstract void</span> <span class="calibre5">execute</span>(HttpServletRequest<br class="calibre2"/>                                 request<span class="calibre5">, </span>HttpServletResponse response)<br class="calibre2"/>            <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>java.io.IOException <span class="calibre5">;<br class="calibre2"/></span>}</pre>
<p class="mce-root">In the following block of code, we have the <kbd class="calibre18">PdfCommand</kbd> <span class="calibre10">class. This </span>is a subclass of <kbd class="calibre18">AbstractCommand</kbd> that implements the logic to download a PDF file:</p>
<pre class="calibre23"><span class="calibre5">import </span>javax.servlet.ServletException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletResponse<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.File<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.FileInputStream<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.OutputStream<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public class </span>PdfCommand <span class="calibre5">extends </span>AbstractCommand {<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public void</span> <span class="calibre5">execute</span>(HttpServletRequest request<span class="calibre5">, </span>HttpServletResponse <br class="calibre2"/>    response) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/><br class="calibre2"/>        String fileName = request.getParameter(<span class="calibre5">"fileName"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">// for example application/pdf, text/plain, text/html, <br class="calibre2"/>        image/jpg<br class="calibre2"/></span><span class="calibre5">        </span>response.setContentType(<span class="calibre5">"application/pdf"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">// Make sure to show the download dialog<br class="calibre2"/></span><span class="calibre5">        </span>response.setHeader(<span class="calibre5">"Content-disposition"</span><span class="calibre5">,</span><span class="calibre5">"attachment; <br class="calibre2"/>        filename=myapp_download.pdf"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">// Assume file name is retrieved from database<br class="calibre2"/></span><span class="calibre5">        // For example D:\\file\\test.pdf<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>File file = <span class="calibre5">new </span>File(fileName)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">// This should send the file to browser<br class="calibre2"/></span><span class="calibre5">        </span>OutputStream out = response.getOutputStream()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>FileInputStream in = <span class="calibre5">new </span>FileInputStream(file)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        byte</span>[] buffer = <span class="calibre5">new byte</span>[<span class="calibre5">4096</span>]<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        int </span>length<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        while </span>((length = in.read(buffer)) &gt; <span class="calibre5">0</span>){<br class="calibre2"/>            out.write(buffer<span class="calibre5">, </span><span class="calibre5">0</span><span class="calibre5">, </span>length)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>        in.close()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>out.flush()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding code block, we have the <kbd class="calibre18">execute()</kbd> <span class="calibre10">method, </span><span class="calibre10">which processes the logic to download a PDF file. At this point, </span><span class="calibre10">a</span>ll the processes and main validations of requests were <span class="calibre10">executed, and the <kbd class="calibre18">execute()</kbd> </span><span class="calibre10">method</span><span class="calibre10"> </span><span class="calibre10">needs only to execute the download process.</span></p>
<p class="mce-root"/>
<p class="mce-root">Here, we have the <kbd class="calibre18">JpgCommand</kbd> <span class="calibre10">class, </span>which is a subclass of <kbd class="calibre18">AbstractCommand</kbd> that implements the logic to download a JPG file:</p>
<pre class="calibre23"><span class="calibre5">import </span>javax.servlet.ServletException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletRequest<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.servlet.http.HttpServletResponse<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.File<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.FileInputStream<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.IOException<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.io.OutputStream<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public class </span>JpgCommand <span class="calibre5">extends </span>AbstractCommand  {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public </span>void <span class="calibre5">execute</span>(HttpServletRequest request<span class="calibre5">, </span>HttpServletResponse <br class="calibre2"/>    response) <span class="calibre5">throws </span>ServletException<span class="calibre5">, </span>IOException {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//Gets the file name sent by paramenter.<br class="calibre2"/></span><span class="calibre5">        </span>String fileName = request.getParameter(<span class="calibre5">"fileName"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Configures the content type.<br class="calibre2"/></span><span class="calibre5">        </span>response.setContentType(<span class="calibre5">"image/jpg"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">// Configure the dialog to download.<br class="calibre2"/></span><span class="calibre5">        </span>response.setHeader(<span class="calibre5">"Content-disposition"</span><span class="calibre5">,</span><span class="calibre5">"attachment; <br class="calibre2"/>        filename=myapp_download.pdf"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">//Read file and send to client.<br class="calibre2"/></span><span class="calibre5">        </span>File file = <span class="calibre5">new </span>File(fileName)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>OutputStream out = response.getOutputStream()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>FileInputStream in = <span class="calibre5">new </span>FileInputStream(file)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        byte</span>[] buffer = <span class="calibre5">new byte</span>[<span class="calibre5">4096</span>]<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        int </span>length<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        while </span>((length = in.read(buffer)) &gt; <span class="calibre5">0</span>){<br class="calibre2"/>            out.write(buffer<span class="calibre5">, </span><span class="calibre5">0</span><span class="calibre5">, </span>length)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>        in.close()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>out.flush()<span class="calibre5">;</span><span class="calibre5"><br class="calibre2"/><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding code block, we have the <kbd class="calibre18">execute()</kbd><span class="calibre10"> </span>method, <span class="calibre10">which processes the logic to download a JPG file. At this point, all request and main validation </span><span class="calibre10">processes</span><span class="calibre10"> </span><span class="calibre10">have already been done.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The difference between the application controller and front controller patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The application controller and front controller patterns are quite similar and can create confusion for some users. The problem that the application controller pattern and <span class="calibre10">front controller patterns</span> solve are similar <span class="calibre10">because both are used to centralize the logic at one point. As well as that, both work together using the design pattern command.</span></p>
<p class="mce-root">The main difference between the application controller and <span class="calibre10">the front controller</span> is that the <span class="calibre10">application controller</span> works to solve the complexity of view and flow page logic, and the <span class="calibre10">front controller</span> works to solve the complexity of the requests and the configurations of them. When the view and flow logic is simple, all logic is sometimes inserted into the front controller, and the <span class="calibre10">application controller</span> is not <span class="calibre10">then</span><span class="calibre10"> </span><span class="calibre10">used. However,</span> when the logic within the view and flow page is complex<span class="calibre10">, it is recommended </span><span class="calibre10">to use the application controller in order </span><span class="calibre10">to decouple the view and flow logic and organize the code.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we learned about the presentation tier and looked at the intercepting <span class="calibre10">filter pattern</span>, <span class="calibre10">front controller patterns</span>, and application controller pattern as well as how to implement them. In the real world, we rarely need to implement these patterns because some frameworks, APIs, and specifications already implement them for us. However, it is very important to know about these patterns in order to improve our <span class="calibre10">understanding of the frameworks, APIs, and specifications that implement them. As well as this, we sometimes need to implement some components outside of the framework. Consequently, it is a good idea to use this pattern.</span></p>
<p class="mce-root">The next chapter will address the business tier and its patterns. Here, we will cover the patterns that act on the business tier. Knowing about these patterns will complement our knowledge of the concepts and implementations of enterprise patterns as well as how these patterns promote the use of good tools to solve common problems in a business environment.</p>


            </article>

            
        </section>
    </div>



  </body></html>