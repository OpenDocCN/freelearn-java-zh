<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;RESTEasy Skeleton Key"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. RESTEasy Skeleton Key</h1></div></div></div><p>Welcome to the fourth chapter! We hope you are enjoying the book, and even more important, learning and understanding what we are transmitting and teaching you. It is time to move forward and immerse yourself in a new chapter.</p><p>Once you read this chapter, you will have the knowledge to design, implement, and aggregate additional security levels to your RESTEasy applications, all of this using OAuth and RESTEasy Skeleton Key and some other specific requirements of these technologies, such as setting up an OAuth server. You will learn through practical and descriptive examples of applications, just as we did in previous chapters; we won't get stuck in theory only, and we'll implement applications and explain specific methods and classes to implement OAuth.</p><p>In this chapter, you will learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">OAuth and RESTEasy</li><li class="listitem" style="list-style-type: disc">SSO configuration for security management</li><li class="listitem" style="list-style-type: disc">Access tokens</li><li class="listitem" style="list-style-type: disc">Custom filters</li><li class="listitem" style="list-style-type: disc">Web services clients for test</li></ul></div><p>As you have probably experienced, if you have an account on one or several social networks, a lot of these social networks allow you to share information between them or post something in all of them. This is a sign that applications need to share information and also use resources that are in other applications. In this example, it can be your account or your contact list. This involves sensitive information, so it needs to be protected. Also, limited permissions over resources means that a third-party application can only read your contacts list. This opens the door to a very important, attractive, and useful feature among applications, which is the capacity to use resources on behalf of the user. Of course, you may ask how the latter authorizes the use? Well, this chapter will show you. So, let's go!</p><div class="section" title="OAuth protocol"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec18"/>OAuth protocol</h1></div></div></div><p>This is an open protocol that allows you to grant safe authorization to your private resources from one site (service provider) to<a class="indexterm" id="id145"/> another (consumer) without sharing your identity.</p><p>A practical example is when you grant authorization to a website or an application to use the contact list in your phone or social network.</p></div></div>
<div class="section" title="OAuth and RESTEasy Skeleton Key"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec19"/>OAuth and RESTEasy Skeleton Key</h1></div></div></div><p>In this section, we will review some concepts related to OAuth<a class="indexterm" id="id146"/> as an authentication framework, RESTEasy Skeleton Key, and how they work together. You will check out some features of these technologies and get your hands dirty with some code as a practical example.</p><div class="section" title="What is RESTEasy Skeleton Key?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>What is RESTEasy Skeleton Key?</h2></div></div></div><p>RESTEasy Skeleton Key<a class="indexterm" id="id147"/> provides a unified way for browser and JAX-RS clients to be secured. This allows executing and forwarding requests in a network of applications and services in a secure and scalable way, without interacting with a central authentication server every time a request appears.</p></div><div class="section" title="OAuth 2.0 authentication framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec18"/>OAuth 2.0 authentication framework</h2></div></div></div><p>This <a class="indexterm" id="id148"/>enables third-party applications or services access to an HTTP resource on behalf of the resource owner. It also prevents the third-party application or service from getting in contact with the owner's credentials. This is possible through issuing access tokens via browsers and using a direct grant.</p><p>With the two concepts explained in a nutshell, it is time to describe how they are related. RESTEasy Skeleton Key is an OAuth 2.0 implementation that uses the JBoss AS 7 security infrastructure in order to secure web applications and RESTful services.</p><p>This means that you can transform a web application into an OAuth 2.0 access token provider, and you can also transform the JBoss AS 7 security domain into a central authentication and authorization server, where applications and services can interact with each other.</p><p>The following diagram describes this process in a better way:</p><div class="mediaobject"><img alt="OAuth 2.0 authentication framework" src="graphics/0109OS_04_01.jpg"/></div><div class="section" title="Main features"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Main features</h3></div></div></div><p>We want<a class="indexterm" id="id149"/> to help you understand these technologies and clarify what they are used for; this is why we will name some of their main features. With OAuth 2.0 and RESTEasy Skeleton Key, you can perform the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transform a servlet-form-auth-based web application into an OAuth 2.0 provider.</li><li class="listitem" style="list-style-type: disc">Provide distributed <a class="indexterm" id="id150"/><span class="strong"><strong>Single Sign-On</strong></span> (<span class="strong"><strong>SSO</strong></span>) throughout a central authentication server in order to log in once and access any browser-based application configured in the domain in a secure way.</li><li class="listitem" style="list-style-type: disc">Use just one link and log out from all the distributed applications that were configured with SSO.</li><li class="listitem" style="list-style-type: disc">Make a web application interact with a remote RESTful service using access tokens.</li><li class="listitem" style="list-style-type: disc">Sign access tokens with OAuth 2.0 and use the tokens later to access any service configured in the domain. The token has Identity and Role Mapping, and there is no need to overload the central authentication server with every request that <a class="indexterm" id="id151"/>appears because tokens are digitally signed.</li></ul></div><p>You can find <a class="indexterm" id="id152"/>more <a class="indexterm" id="id153"/>information about these topics at <a class="ulink" href="http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html">http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html</a>.</p><p>We will discuss the most important parts, but it might be useful for you.</p></div></div><div class="section" title="OAuth2 implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec19"/>OAuth2 implementation</h2></div></div></div><p>We have <a class="indexterm" id="id154"/>just reviewed some of the main concepts that we will deal with in this chapter, but this is not enough. We must implement a descriptive example so that we can completely understand these topics.</p><div class="section" title="Updating RESTEasy modules in JBoss"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Updating RESTEasy modules in JBoss</h3></div></div></div><p>In order <a class="indexterm" id="id155"/>not to mess with your JBoss configuration or anything else, we will use another brand new instance of JBoss. We<a class="indexterm" id="id156"/> have to update some modules that are related to RESTEasy. We can do this very easily. Let's visit the link <a class="ulink" href="http://resteasy.jboss.org/">http://resteasy.jboss.org/</a>; at <a class="indexterm" id="id157"/>your right, you will find a panel with the title <span class="strong"><strong>Useful Links</strong></span>, which has a download link. Click on it to visit another page that has a bunch of download links. In this example, we use the 3.0.7.Final Version. Download this version in order to go forward.</p><p>Once you have downloaded and unzipped it, you will find another <code class="literal">.zip</code> file named <code class="literal">resteasy-jboss-modules-3.0.7.Final</code>; this file contains some JARs that will update your JBoss modules. So, unzip it, copy all folders into <code class="literal">JBOSS_HOME/modules/</code>, and replace all coincidences. There is one last step: we have to update the JAR files' version and modify the module XML in JBoss in order to set <code class="literal">org.apache.httpcomponents</code> to use <code class="literal">httpclient-4.2.1.jar</code>, <code class="literal">httpcore-4.2.1.jar</code> and <code class="literal">httpmime-4.2.1.jar</code> because the current latest Version is 4.3.4, which works fine too. So, copy these JARs and update the version in the <code class="literal">module.xml</code> file in <code class="literal">JBOSS_HOME/modules/org/apache</code> folder. Now, we have updated our modules for RESTEasy.</p></div><div class="section" title="Setting up the configuration in JBoss"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Setting up the configuration in JBoss</h3></div></div></div><p>For the next <a class="indexterm" id="id158"/>step in getting our JBoss ready for our example, we must go to <a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04</a> and download the <code class="literal">chapter04</code> examples zip file. Unzip and you will find a folder named <code class="literal">configuration</code>. This <a class="indexterm" id="id159"/>folder contains the files necessary for setting up our JBoss configuration. So, copy the files and replace the configuration folder in your JBoss located at <code class="literal">JBOSS_HOME/standalone/configuration</code>.</p></div><div class="section" title="Implementing an OAuth client"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Implementing an OAuth client</h3></div></div></div><p>In order to<a class="indexterm" id="id160"/> develop this example, we investigate<a class="indexterm" id="id161"/> a very useful example and apply it to a new project. This example is composed of several projects; each project will produce a WAR file. The purpose of this example is to demonstrate how OAuth works and explain the way you can implement this<a class="indexterm" id="id162"/> technology at a technical level. So, we will simulate several things in order to create the environment where we can apply this implementation. The complete code can be downloaded from the following link:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example</a>
</p><div class="section" title="The oauth-client project"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec03"/>The oauth-client project</h4></div></div></div><p>First <a class="indexterm" id="id163"/>we are going to create the <code class="literal">oauth-client</code> webapp project. You<a class="indexterm" id="id164"/> can use the Maven command we have used before in previous chapters or you can use Eclipse IDE in order to perform this.</p><p>After that, let's add some dependencies in order to implement our client. These dependencies are for all the projects. Go to the <code class="literal">pom.xml</code> file and make sure to add the following dependencies inside the <code class="literal">&lt;dependencies&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">       &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.spec.javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jboss-servlet-api_3.0_spec&lt;/artifactId&gt;
            &lt;version&gt;1.0.1.Final&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
            &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.6.Final&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
            &lt;artifactId&gt;skeleton-key-core&lt;/artifactId&gt;
            &lt;version&gt;3.0.6.Final&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;</pre></div><p>Let's start by creating the package <code class="literal">com.packtpub.resteasy.example.oauth</code>. Then, create the class <code class="literal">public class Loader implements ServletContextListener</code>, which implements <code class="literal">ServletContextListener</code>, because we will load a key store and initialize a context.</p><p>Let's add a field <a class="indexterm" id="id165"/>into our class <code class="literal">private ServletOAuthClient oauthClient</code>, which will represent our OAuth client object.</p><p>Then, let's create the <a class="indexterm" id="id166"/>method shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">private static KeyStore loadKeyStore(String filename, String password) throws Exception 
{
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
File keyStoreFile = new File(filename);
FileInputStream keyStoreStream = new FileInputStream(keyStoreFile);
    keyStore.load(keyStoreStream, password.toCharArray());
    keyStoreStream.close();
    return keyStore; 
}</pre></div><p>This method receives two parameters, the filename and the password, and creates the object <code class="literal">KeyStore</code>. It also creates a <code class="literal">FileInputStream</code> object from the filename received so that it can use it to load the <code class="literal">KeyStore</code> object, and it uses the password received in the form of a char array.</p><p>After this, as our class implements the <code class="literal">ServletContextListener</code> interface, we have to override some methods. The first method to override is <code class="literal">contextInitialized</code>. Let's do it as follows:</p><div class="informalexample"><pre class="programlisting">@Override
 public void contextInitialized(ServletContextEvent sce) {
  String truststoreKSPath = "${jboss.server.config.dir}/client-truststore.ts";
  String truststoreKSPassword = "changeit";
  truststoreKSPath = EnvUtil.replace(truststoreKSPath);
  try {
   KeyStore truststoreKS = loadKeyStore(truststoreKSPath, 
     truststoreKSPassword);
   oauthClient = new ServletOAuthClient();
   oauthClient.setTruststore(truststoreKS);
   oauthClient.setClientId("third-party");
   oauthClient.setPassword("changeit");
   oauthClient.setAuthUrl("https://localhost:8443/oauth-server/login.jsp");
   oauthClient.setCodeUrl("https://localhost:8443/oauth-server/
     j_oauth_resolve_access_code");
   oauthClient.start();
   sce.getServletContext().setAttribute(ServletOAuthClient.class.getName(), oauthClient);
  } catch (Exception e) {
   throw new RuntimeException(e);
  }

 }</pre></div><p>Through this <a class="indexterm" id="id167"/>method, we will accomplish several things. As you can see, we set two internal variables; one is set with the path to our <code class="literal">client-truststore.ts</code> file and the other is set to the password. Make sure to paste the file in the path we<a class="indexterm" id="id168"/> specified in the variable (<code class="literal">JBOSS_HOME/standalone/configuration</code>).</p><p>After this, we load the <code class="literal">KeyStore</code> object using the path and password we specified in the variables, obtaining another <code class="literal">KeyStore</code> object through this.</p><p>Now, it's time to instantiate and set the properties of our OAuth client object. In the previous code, we set the following properties: <code class="literal">trustStore</code>, <code class="literal">clientId</code>, <code class="literal">password</code>, <code class="literal">authUrl</code>, and <code class="literal">codeUrl</code>.</p><p>Finally, we create the client to obtain an access token from the code. In order to accomplish this, we use the <code class="literal">start()</code> method. Also, we set the attribute servlet OAuth client with the OAuth client object we just created.</p><p>In order to finish our OAuth client, we need to override a second method named <code class="literal">public void contextDestroyed(ServletContextEvent sce)</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
  public void contextDestroyed(ServletContextEvent sce) {
    oauthClient.stop();
  }</pre></div><p>This method will be executed when the servlet context is about to shut down, our application is redeploying, and so on. The method closes the client instance and all its associated resources.</p><p>We implemented our OAuth client for our example. We need another resource. This time, we will create a class that works as a database client for our compact discs store. So, let's name it <code class="literal">CompactDiscsDatabaseClient</code>, and we will get the two following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">public static void redirect(HttpServletRequest request, HttpServletResponse response)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">public static List&lt;String&gt; getCompactDiscs(HttpServletRequest request)</code></li></ul></div><p>So, let's begin implementing the first method. This method is explained as follows:</p><div class="informalexample"><pre class="programlisting">public static void redirect(HttpServletRequest request, HttpServletResponse response) {
ServletOAuthClient oAuthClient = (ServletOAuthClient) request.getServletContext().getAttribute(ServletOAuthClient.class.getName());
    try {
oAuthClient.redirectRelative("discList.jsp", request, response);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }</pre></div><p>In the <a class="indexterm" id="id169"/>preceding method, we obtain the <code class="literal">ServletOAuthClient</code> object from the <code class="literal">ServletContext</code> obtained from the request; the servlet OAuth client is in the servlet context as an attribute named <code class="literal">ServletOAuthClient</code>. Remember that in the first class we created, we set this attribute in the servlet context.</p><p>Finally, we<a class="indexterm" id="id170"/> start the process of getting an access token by redirecting the browser to the authentication server through <code class="literal">redirectRelative (String relativePath, HttpServletRequest request, HttpServletResponse response)</code>.</p><p>Now, let's move on with the next method that loads the discs. The following code represents the method:</p><div class="informalexample"><pre class="programlisting">public static List&lt;String&gt; getCompactDiscs(HttpServletRequest request) {

ServletOAuthClient oAuthClient = (ServletOAuthClient) request.getServletContext().getAttribute(
        ServletOAuthClient.class.getName());

ResteasyClient rsClient = new 
ResteasyClientBuilder().trustStore(oAuthClient.getTruststore()).hostnameVerification(ResteasyClientBuilder.HostnameVerificationPolicy.ANY).build();

String urlDiscs = "https://localhost:8443/store/discs";
  try {
String bearerToken = "Bearer" + oAuthClient.getBearerToken(request);
    
<span class="strong"><strong>Response response = rsClient.target(urlDiscs).request().header(HttpHeaders.AUTHORIZATION, bearerToken)</strong></span>
          .get();
    return response.readEntity(new GenericType&lt;List&lt;String&gt;&gt;() {
	      });
    } finally {
      rsClient.close();
    }
}</pre></div><p>Let's check what we have up here. In the preceding <code class="literal">getCompactDiscs ()</code> method, we create a <code class="literal">ServletOAuthClient</code> object that is in charge of starting the process of obtaining an access token by redirecting the browser to the authentication server. Once again, we obtain the attribute from the <code class="literal">ServletContext</code> object from the request. Then, we create a <code class="literal">ResteasyClient</code> object using a new instance of <code class="literal">ResteasyClientBuilder()</code>; this class is an abstraction to create clients and allows SSL configuration.</p><p>We then<a class="indexterm" id="id171"/> set the client-side trust store with the <code class="literal">trustStore()</code> method. This <a class="indexterm" id="id172"/>invocation will return a <code class="literal">KeyStore</code> object and set the client-side trust store. After this, we invoke the <code class="literal">hostnameVerification()</code> method, which sets an SSL policy used to verify hostnames. Finally, using the <code class="literal">build()</code> method, we build a new client instance with the entire configuration previously specified in this client builder. This will return an instance of <code class="literal">ResteasyClient</code>.</p><p>Let's move on to create an internal variable which will hold the URL of the resource that we will set as our target resource. Also, we will create another internal variable to hold the bearer token as a string. This string will comprise the word <code class="literal">Bearer</code> followed by the bearer token from the servlet OAuth client and request.</p><p>Now, in order to create the response, we will use the servlet OAuth client we just created. Let's use the variable <code class="literal">urlDiscs</code> as a parameter and create a new web resource target through the <code class="literal">target()</code> method. After this, using the <code class="literal">request()</code> method, we set up a request to the targeted web resource we just set.</p><p>Finally, we add a header by invoking the <code class="literal">header()</code> method, which will receive two parameters: the first parameter represents the header's name and the second parameter is the header's value. After this, we invoke the <code class="literal">HTTP GET</code> method for the current request.</p><p>Just to clarify, the <code class="literal">HttpHeaders.AUTHORIZATION</code> constant represents the header field in the specific case when a user wants to authenticate themselves with a server. It does so by adding an authorization request-header field along with the request. On the other hand, the authorization field value is composed of credentials that contain the authentication information of the user for the realm of the resource being requested.</p><p>Once the response object is created, we use the <code class="literal">readEntity()</code> method to read the message entity input stream as an instance of the specified Java type. With this, we fill the list with our compact discs example list so that we can present it in the web page. This means that we accessed the resource.</p><p>If you want to explore more about what we just used in the block of code we described, here are some links as references. You can check them out, expand your knowledge, and get more details on <code class="literal">RestEasyClient</code> and <code class="literal">RestEasyClientBuilder</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html">http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore">http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore</a></li></ul></div></div><div class="section" title="The discstore project"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec04"/>The discstore project</h4></div></div></div><p>The <a class="indexterm" id="id173"/>next project we are going to create is the <code class="literal">discstore</code> project; the <a class="indexterm" id="id174"/>steps to create the project are the same as the previous one, and you can use the Maven command or Eclipse IDE.</p><p>In this project, we will create a class that will create the list of compact discs. This class is pretty simple, and it uses some annotations that have already been discussed in previous chapters. The name of this class will be <code class="literal">CompactDiscService</code>, and it will have only one method with several annotations. Let's start with the code, and we will add a short description about it after the code block:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Path("discs")</strong></span>
public class CompactDiscService {
  <span class="strong"><strong>@GET</strong></span>
<span class="strong"><strong>  @Produces("application/json")</strong></span>
  public List&lt;String&gt; getCompactDiscs() {
    ArrayList&lt;String&gt; compactDiscList = new ArrayList&lt;String&gt;();
    compactDiscList.add("The Ramones");
    compactDiscList.add("The Clash");
    compactDiscList.add("Nirvana");
    return compactDiscList;
  }
}</pre></div><p>As you can see, the method<a class="indexterm" id="id175"/> <code class="literal">getCompactDiscs()</code> is in charge of creating a list of strings, which each item will represent as a compact disc as this is an example in which we will add three items.</p><p>The <code class="literal">@Produces</code> annotations<a class="indexterm" id="id176"/> are used to specify the MIME media types, and if applied at the method level, the annotations override any <code class="literal">@Produces</code> annotation applied at the class level. The <code class="literal">@GET</code> annotation<a class="indexterm" id="id177"/>, as you already know, will represent the HTTP method <code class="literal">GET</code>. Meanwhile, the <code class="literal">@Path</code> annotation<a class="indexterm" id="id178"/> will help us to set the class as a resource, and its name will be <code class="literal">discs</code>.</p><p>All the backend has been implemented; we now need to develop some other resources in order to let our example function. Remember we specified some web pages in the classes up there? Well, that is what we will implement now.</p></div><div class="section" title="The oauth-server project"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec05"/>The oauth-server project</h4></div></div></div><p>As before, in <a class="indexterm" id="id179"/>order to create this project, <a class="indexterm" id="id180"/>you can use Maven commands or Eclipse IDE.</p><p>In order to turn this application, we must create the <code class="literal">jboss-web.xml</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">&lt;jboss-web&gt;
    &lt;security-domain&gt;java:/jaas/commerce&lt;/security-domain&gt;
    &lt;valve&gt;
        &lt;class-name&gt;org.jboss.resteasy.skeleton.key.as7.OAuthAuthenticationServerValve&lt;/class-name&gt;
    &lt;/valve&gt;
&lt;/jboss-web&gt;</pre></div><p>One last thing: we have to create a JSON file with the purpose of having our certificates and security configuration in this server. We are going to name it <code class="literal">resteasy-oauth</code>. And as you can see, there is not a big deal with this file; it is a set of properties and values. Through this file, we specify the KeyStores and passwords, the truststore path, and so on. This file will be located in the <code class="literal">WEBINF</code> folder of this project.</p><div class="informalexample"><pre class="programlisting">{
   "realm" : "commerce",
   "admin-role" : "admin",
   "login-role" : "login",
   "oauth-client-role" : "oauth",
   "wildcard-role" : "*",
   "realm-keystore" : "${jboss.server.config.dir}/realm.jks",
   "realm-key-alias" : "commerce",
   "realm-keystore-password" : "changeit",
   "realm-private-key-password" : "changeit",
   "truststore" : "${jboss.server.config.dir}/client-truststore.ts",
   "truststore-password" : "changeit",
   "resources" : [
      "https://localhost:8443/oauth-client",
      "https://localhost:8443/discstore/"
   ]
}</pre></div></div><div class="section" title="webapp/WEB-INF/ jboss-deployment-structure.xml"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec06"/>webapp/WEB-INF/ jboss-deployment-structure.xml</h4></div></div></div><p>We must <a class="indexterm" id="id181"/>configure this file in all the projects because we updated some modules from the instance of JBoss AS. In this file, we must specify the dependencies our application has with some modules of JBoss. Then, we need to clearly set them using the <code class="literal">&lt;module&gt;</code> tag inside<a class="indexterm" id="id182"/> the <code class="literal">&lt;dependencies&gt;</code> tag, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;jboss-deployment-structure&gt;
    &lt;deployment&gt;
        &lt;!-- This allows you to define additional dependencies, it is the same as using the Dependencies: manifest attribute --&gt;
        &lt;dependencies&gt;
            &lt;module name="org.jboss.resteasy.resteasy-jaxrs" services="import"/&gt;
            &lt;module name="org.jboss.resteasy.resteasy-jackson-provider" services="import"/&gt;
            &lt;module name="org.jboss.resteasy.skeleton-key" /&gt;
        &lt;/dependencies&gt;
    &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;</pre></div></div><div class="section" title="Running the application"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec07"/>Running the application</h4></div></div></div><p>We have <a class="indexterm" id="id183"/>explained the main parts of each project, so in order to run and test the application, you can download the examples folder of this chapter from <a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04</a>. After you download the ZIP file, unzip it and you will find there is a folder named <code class="literal">OAuthExample</code>. Inside this folder, there are our three projects. You can copy them and paste them in your workspace and import the projects using Eclipse.</p><p>We have provided you the keystores, and certification and truststore files inside the <code class="literal">configuration</code> folder you just pasted while setting up the JBoss <code class="literal">configuration</code>. In order to make sure the application runs correctly, you may update these files, by following the instructions in the <code class="literal">.txt</code> file named <code class="literal">keystoreCommands</code> located inside the <code class="literal">configuration</code> folder.</p><p>In order to launch our application, we have to deploy it. So, open a terminal. Let's go to <code class="literal">JBOSS_HOME/bin</code> and start JBoss in standalone mode; this means executing <code class="literal">standalone.bat</code> if you are in Windows or <code class="literal">./standalone.sh</code> if you are in Linux. Then, open a terminal and go inside the folder of our application in the workspace. We have to execute the following commands: <code class="literal">mvn clean install</code> followed by <code class="literal">mvn</code> <code class="literal">jboss-as:deploy</code> on each one of the three projects that we have created: <code class="literal">discstore</code>, <code class="literal">oauth-client</code>, and <code class="literal">oauth-server</code>.</p><p>We have created a special class in the <code class="literal">discstore</code> project. This class contains a <code class="literal">void main</code> method, and we test our application through this class. We have named it <code class="literal">OAuthClientTest</code>. The code of this class is as follows:</p><div class="informalexample"><pre class="programlisting">public class OauthClientTest {

  public static void main(String[] args) throws Exception {

    String truststorePath = "C:/Users/Andres/jboss/2do_jboss/jboss-as-7.1.1.Final/standalone/configuration/client-truststore.ts";
    String truststorePassword = "changeit";
    truststorePath = EnvUtil.replace(truststorePath);

    KeyStore truststore = loadKeyStore(truststorePath, truststorePassword);

         ResteasyClient client = new ResteasyClientBuilder()
                .disableTrustManager().trustStore(truststore).build();

    Form form = new Form().param("grant_type", "client_credentials");
    ResteasyWebTarget target = client.target("https://localhost:8443/oauth-server/j_oauth_token_grant");
    target.register(new BasicAuthentication("andres", "andres"));

    AccessTokenResponse tokenResponse = target.request().post(Entity.form(form), AccessTokenResponse.class);
    Response response = client.target("https://localhost:8443/discstore/discs")
        .request()
        .header(HttpHeaders.AUTHORIZATION,
            "Bearer " + tokenResponse.getToken()).get();
    try {
      String xml = response.readEntity(String.class);
      System.out.println(xml);
    } finally {
      client.close();
    }

  }</pre></div><p>We are going to explain the preceding code, first, we have two variables, <code class="literal">truststorePath</code> and <code class="literal">truststorePassword</code>. The first one is referencing the path of our <code class="literal">client-truststore.ts</code> file located in the configuration folder of our JBoss. You should change the <a class="indexterm" id="id184"/>value of this variable in order to make this test work, so place the path of your configuration folder. After this, with a method we already explained, <code class="literal">loadKeyStore ()</code>, we load the KeyStore using the previous variables and we assign this value to a <code class="literal">KeyStore</code> object named <code class="literal">truststore</code>. From <code class="literal">truststore</code>, we create the <code class="literal">RestEasyClient</code> object named <code class="literal">client</code>.</p><p>Now, we will obtain an access token programmatically, so we can request an access token from the auth-server simply by using HTTPS invocation. Then we have to use basic authentication to identify our user; as a result, we will get back a signed access token for that user.</p><p>So, we perform a simple <code class="literal">POST</code> to the context root of the auth-server with <code class="literal">j_oauth_token_grant</code> at the end of the target URL, because when we use that URL and a <code class="literal">POST</code> with basic authentication, we will obtain an access token for a specific user.</p><p>After that, we <a class="indexterm" id="id185"/>obtained the access token, which is a simple string. In order to invoke on a service protected by bearer token authentication, we have to build a string made up of the authorization header of your <code class="literal">HTTPS</code> request plus the string <code class="literal">Bearer</code> and finally the access token string. This will get back the response object, so we can read it and print it as we did in the test. In the console, you will see the list of compact discs as shown in the following screenshot:</p><div class="mediaobject"><img alt="Running the application" src="graphics/0109OS_04_02.jpg"/></div></div></div></div></div>
<div class="section" title="SSO configuration for security management"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec20"/>SSO configuration for security management</h1></div></div></div><p>SSO is a <a class="indexterm" id="id186"/>mechanism for authentication. It allows a user to access several systems <a class="indexterm" id="id187"/>or <a class="indexterm" id="id188"/>applications entering credentials just once. We think you experience this more often these days because we are living in a social network era, and most of these services let us use each other's credentials to access several services.</p><p>After discussing some concepts of SSO, let's try and implement this mechanism. In order to achieve this, we will use JBoss 7 Application Server and our earlier project <code class="literal">secure-demo</code>.</p><p>As a brief introduction to this implementation, we want to tell you that we will work with two files; one file belongs to JBoss and the other belongs to our application.</p><p>The file that <a class="indexterm" id="id189"/>belongs to JBoss is <code class="literal">standalone.xml</code>. We will <a class="indexterm" id="id190"/>add some lines to this file. In the following lines of code, let's add the SSO element in the <code class="literal">virtual-server</code> definition:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem  default-virtual-server="default-host" native="false"&gt;
            &lt;connector name="http" protocol="HTTP/1.1" scheme="http" socket-binding="http"/&gt;
            &lt;virtual-server name="default-host" enable-welcome-root="true"&gt;
                &lt;alias name="localhost"/&gt;
                &lt;sso domain="localhost" reauthenticate="false"/&gt;
            &lt;/virtual-server&gt;
&lt;/subsystem&gt;</pre></div><p>The <code class="literal">reauthenticate</code> attribute allows us to establish whether each request needs to be reauthenticated to <code class="literal">securityReal</code>. The default value is <code class="literal">false</code>.</p><p>The next file we must edit is in our application, and its name is <code class="literal">jboss-web.xml</code>. Also, we need to add some lines of code to this file. These lines of code will declare the valve that will manage the SSO. In other words, every request will go through this valve, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;jboss-web&gt;
    &lt;security-domain&gt;java:/jaas/other &lt;/security-domain&gt;
          &lt;valve&gt;
        &lt;class-name&gt;org.apache.catalina.authenticator.SingleSignOn&lt;/class-name&gt;
    &lt;/valve&gt;
&lt;/jboss-web&gt;</pre></div><p>Just in case you forgot it or deleted it, we set a security domain in the previous chapters. The following block of code must exist in the <code class="literal">standalone.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="other" cache-type="default"&gt;
    &lt;authentication&gt;
      &lt;login-module code="Remoting" flag="optional"&gt;
&lt;module-option name="password-stacking"  value="useFirstPass"/&gt;
      &lt;/login-module&gt;
      &lt;login-module code="RealmUsersRoles" flag="required"&gt;
&lt;module-option name="usersProperties" value="${jboss.server.config.dir}/application-users.properties"/&gt;
&lt;module-option name="rolesProperties" value="${jboss.server.config.dir}/application-roles.properties"/&gt;
&lt;module-option name="realm" value="ApplicationRealm"/&gt;
&lt;module-option name="password-stacking" value="useFirstPass"/&gt;
      &lt;/login-module&gt;
     &lt;/authentication&gt;
&lt;/security-domain&gt;</pre></div><p>Since we are using the <code class="literal">secure-demo</code> example, this is all we must modify in order to configure SSO.</p><p>In order to test <a class="indexterm" id="id191"/>this mechanism, we need another application. We <a class="indexterm" id="id192"/>must replicate the configuration we just did in our <code class="literal">secure-demo</code> example.</p><p>When we enter the credentials in one of them, we no longer need to enter the credentials in the others, since we have applied SSO. We will authenticate in both applications.</p></div>
<div class="section" title="OAuth token via Basic Auth"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>OAuth token via Basic Auth</h1></div></div></div><p>Now, let's explore<a class="indexterm" id="id193"/> and implement a short example<a class="indexterm" id="id194"/> of using tokens. In order to build this example, we will create a class. This class, as in the previous example, will simulate a database client. It will have the same method, <code class="literal">getCompactDiscs()</code>, but we will modify the internal function in this example. Also, it won't receive any parameter this time.</p><p>Alright, let's do it! First, create two static string fields in the class. The first field will hold the URL for authentication in the auth-server. The other field will have the URL showing the compact discs list; you can reuse the same web page from the previous example. Then, you should have your variables as shown:</p><div class="informalexample"><pre class="programlisting">private static String urlAuth = "https://localhost:8443/auth-server /j_oauth_token_grant";
private static String urlDiscs = "https://localhost:8443/discstore/discs";</pre></div><p>After this, let's create our method to obtain the compact discs list. The following piece of code shows you exactly how the method is executed:</p><div class="informalexample"><pre class="programlisting">public static List&lt;String&gt; getCompactDiscs() {
  <span class="strong"><strong>ResteasyClient rsClient = new ResteasyClientBuilder().disableTrustManager().build();</strong></span>
    Form form = new Form().param("grant_type", "client_credentials");
  ResteasyWebTarget resourceTarget = rsClient.target(urlAuth);
    resourceTarget.register(new BasicAuthentication("andres", "andres"));
  <span class="strong"><strong>AccessTokenResponse accessToken = resourceTarget.request().post(Entity.form(form), AccessTokenResponse.class);</strong></span>
    try {
      String bearerToken = "Bearer " + accessToken.getToken();
      Response response = rsClient.target(urlDiscs).request().header(HttpHeaders.AUTHORIZATION, bearerToken).get();
      return response.readEntity(new GenericType&lt;List&lt;String&gt;&gt;() {
      });
    } finally {
      rsClient.close();
    }
  }</pre></div><p>It is time<a class="indexterm" id="id195"/> to check what we have just done. As a first step, we created a <code class="literal">ResteasyClient</code> object. If you noticed, we used something to disable trust management and hostname verification. The result of this invocation is that it turns off server-certificate verification allowing MITM (man-in-the-middle) attacks. So, use this feature with caution.</p><p>After this, we create<a class="indexterm" id="id196"/> a <code class="literal">form</code> object and pass in some parameters. These parameters are passed in through the <code class="literal">param()</code> method, representing the parameter name and parameter value, respectively. This means we specify the type of grant being requested by the application, which will be <code class="literal">client_credentials</code>.</p><p>Then, as we did before in the previous example, let's create a RESTEasy web target that will target our URL showing the compact discs list. Remember that this URL was set in a static field we created earlier. This web target will be the <code class="literal">resourceTarget</code> object that we will access.</p><p>When we use the <code class="literal">register()</code> method and pass in a <code class="literal">BasicAuthentication</code> object, we register an instance of a custom JAX-RS component to be instantiated and used in the scope of this configurable context.</p><p>Moving forward, we create the <code class="literal">AccessTokenResponse</code> class by executing a request to our web target. Then, in the same line, we execute a post in order to send the entity and the response type we want to obtain for the current request synchronously. The <code class="literal">Entity.form()</code> method creates the <code class="literal">application/x-www-form-urlencoded</code> entity from the <code class="literal">form</code> object we created before. Now, this will return an <code class="literal">AccessTokenResponse</code> object; we use this object to build the bearer token by adding the word <code class="literal">Bearer</code> at the beginning of the token.</p><p>Finally, let's create the response object by executing a request to the URL that is set in the <code class="literal">urlDiscs</code> variable. We should use the <code class="literal">ResteasyClient</code> object to target this resource, and then execute the request and set the headers field with <code class="literal">HttpHeaders.AUTHORIZATION</code> using the <code class="literal">bearer</code> token set in the variable <code class="literal">bearerToken</code>. In this way, we gain access to the target resource; in this case, we can see the information.</p><p>As we keep using the same application business, we can reuse the web pages of the previous example. Make sure to incorporate in to your example, in the same path as in the previous example, the <a class="indexterm" id="id197"/>web pages <code class="literal">index.html</code> and <code class="literal">discsList.jsp</code>. We will also use the <a class="indexterm" id="id198"/>configuration set in the <code class="literal">jboss-deployment-structure.xml</code> file since we are using the same module dependencies.</p><p>Our <code class="literal">web.xml</code> file should look simpler than the previous example, so it might be something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app 
      
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0"&gt;
    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
&lt;/web-app&gt;</pre></div><div class="section" title="Running the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Running the application</h2></div></div></div><p>You can<a class="indexterm" id="id199"/> download the complete code and configuration from <a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04</a>. Unzip the file, and inside you will find a folder named <code class="literal">token-grant</code>. You have to deploy this project using the same commands. As a requirement, you have to deploy the projects <code class="literal">oauth-server</code>, <code class="literal">oauth-client</code>, and <code class="literal">discstore</code>.</p><p>It is time to run our application. Let's execute the steps we did in the previous example, the OAuth example. After this, we have to open our favorite browser and type the URL <code class="literal">https://localhost:8443/token-grant/</code>. This will lead us to the following web page:</p><div class="mediaobject"><img alt="Running the application" src="graphics/0109OS_04_03.jpg"/></div><p>Well, as you notice, we reused the same web page, just for the purpose of these examples. There is, however, a <a class="indexterm" id="id200"/>little difference; when calling a different web page, you can look in the core we just explained. This will execute a token, where we will perform a request to the data we want to access through this token. As a result, we will read the list of our compact discs in the web page, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Running the application" src="graphics/0109OS_04_04.jpg"/></div><p>The final result is the capability to present the discs list in the web page. However, don't forget what happened; we<a class="indexterm" id="id201"/> just obtained an access token response using the request, the basic authentication with our credentials, and a form. With the access token response, we can create the response and present the data with the respective authorization.</p></div></div>
<div class="section" title="Custom filters"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Custom filters</h1></div></div></div><p>As a brief <a class="indexterm" id="id202"/>introduction, JAX-RS 2.0 has two different concepts for interceptions: filters and interceptors.</p><p>Interceptors<a class="indexterm" id="id203"/> are <a class="indexterm" id="id204"/>components that intercept EJB method invocations. They can be used to audit and log as and when EJBs are accessed. This is a topic that won't be included in this book, but if you feel curious and want to find out some more about it, we give <a class="indexterm" id="id205"/>you the following links as references so you can look it up:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html">http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html">http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html</a></li></ul></div><p>Filters <a class="indexterm" id="id206"/>are <a class="indexterm" id="id207"/>mainly used to alter or process incoming and outgoing request or response headers. They can be executed before and after request and response processing.</p><p>Also, JAX-RS 2.0 offers us two categories of filters: server-side filters<a class="indexterm" id="id208"/> and <a class="indexterm" id="id209"/>client-side filters. The following diagram shows us a better classification of this concept:</p><div class="mediaobject"><img alt="Custom filters" src="graphics/0109OS_04_05.jpg"/></div><div class="section" title="Server-side filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Server-side filters</h2></div></div></div><p>When <a class="indexterm" id="id210"/>we are on the server side, we have another classification for these filters; container request filters are executed before the JAX-RS resource method is invoked. Also, we have the container response filters; you've probably guessed, they are executed after the JAX-RS resource method is invoked. However, this doesn't end here; there is another classification of container request filters: pre-matching and post-matching.</p><p>You can specify a pre-matching container request filter through the <code class="literal">@PreMatching</code> annotation, and this means that the filter will be executed before the JAX-RS resource method is matched with the incoming HTTP request.</p><p>Container request filters can abort the request by executing the <code class="literal">abortWith (Response)</code> method. A filter might want to abort if it implements a custom authentication protocol.</p><p>Once the <a class="indexterm" id="id211"/>resource class method has been executed, JAX-RS will run all container response filters. These filters let you modify the outgoing response before it is marshalled and is sent to the client.</p></div><div class="section" title="Client-side filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Client-side filters</h2></div></div></div><p>As we <a class="indexterm" id="id212"/>already told you, there are filters on the client side too, and similar to the server-side filters, they also have two types of filters: client request filters and client response filters. Client request filters are executed before your HTTP request is sent over the wire to the server. On the other hand, client response filters run after a response is received from the server, but before the response body is assembled.</p><p>Client request filters are also capable of aborting the request and providing a response without going over the wire to the server. Client response filters are capable of altering the response object before it is handed back to the application code.</p></div><div class="section" title="Example usage of filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Example usage of filters</h2></div></div></div><p>After<a class="indexterm" id="id213"/> looking at some of the necessary theory around this topic, it is time to get your feet wet. Now, we will implement an example in order to support our new theoretical knowledge. So, let's start!</p><p>We will implement an interceptor that will verify the access permissions for a user, based on the username and password sent in the request. You can download the complete code of this example from the following link:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04</a>
</p><p>We have the topic of our compact discs store. So, the following class will represent our service, and it will have the functions to find the compact discs by name and update the compact disc information. The annotations used here have already been studied in the previous chapter, so you will probably find the following code understandable:</p><div class="informalexample"><pre class="programlisting"> @Path("/compactDisc-service")
public class CompactDiscService {
  <span class="strong"><strong>@PermitAll</strong></span>
<span class="strong"><strong>  @GET</strong></span>
<span class="strong"><strong>  @Path("/compactDiscs/{name}")</strong></span>
  public Response getCompactDiscByName(@PathParam("name") String name, @Context Request request) {
    Response.ResponseBuilder rb = Response.ok(CompactDiscDatabase.getCompactDiscByName(name));
    return rb.build();
  }

  <span class="strong"><strong>@RolesAllowed("ADMIN")</strong></span>
<span class="strong"><strong>  @PUT</strong></span>
<span class="strong"><strong>  @Path("/compactDiscs/{name}")</strong></span>
  public Response updatePriceByDiscName(@PathParam("name") String name) {
    // Update the User resource
    CompactDiscDatabase.updateCompactDisc(name, 10.5);
    return Response.status(200).build();
  }
}</pre></div><p>As you <a class="indexterm" id="id214"/>can see, we have created only two methods, one to retrieve compact discs by name and the other to update the compact discs' price. The annotations let us know that the method <code class="literal">getCompactDiscByName()</code> can be accessed and executed by all; meanwhile, the method <code class="literal">updatePriceByDiscName()</code> can be accessed and executed by users with the role <code class="literal">ADMIN</code>.</p><p>If you noticed in the preceding code, we used the class <code class="literal">CompactDiscDatabase</code>, which simulates a database. We applied the same technique in the previous examples. As it worked very well, let's do it again. This class doesn't have any special code. You can get an idea about this from the following code:</p><div class="informalexample"><pre class="programlisting">public class CompactDiscDatabase {
  public static HashMap&lt;String, CompactDisc&gt; compactDiscs = new HashMap&lt;String, CompactDisc&gt;();

  static {
    CompactDisc ramonesCD = new CompactDisc();
    ramonesCD.setDiscName("Ramones Anthology");
    ramonesCD.setBandName("The Ramones");
    ramonesCD.setPrice(15.0);

    Calendar calendar = Calendar.getInstance();
    calendar.set(1980, 10, 22);
    Date realeaseDate = calendar.getTime();
    ramonesCD.setReleaseDate(realeaseDate);
    compactDiscs.put("Ramones Anthology", ramonesCD);

  }

  public static CompactDisc getCompactDiscByName(String name) {
    return compactDiscs.get(name);
  }

  public static void updateCompactDisc(String name, double newPrice) {
    CompactDisc cd = compactDiscs.get(name);
    cd.setPrice(newPrice);
  }
}</pre></div><p>There is <a class="indexterm" id="id215"/>nothing complex here; we just created a map and put one entry there. This entry is a compact disc object, as you can tell. We have two static methods that will simulate queries—a SELECT statement and an UPDATE statement.</p><p>Now, let's check our <a class="indexterm" id="id216"/>
<code class="literal">CompactDisc</code> class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@XmlAccessorType(XmlAccessType.NONE)
@XmlRootElement(name = "compactDisc")
public class CompactDisc implements Serializable {
  private static final long serialVersionUID = 1L;

  <span class="strong"><strong>@XmlElement(name = "discName")</strong></span>
  private String discName;

  <span class="strong"><strong>@XmlElement(name = "bandName")</strong></span>
  private String bandName;

  <span class="strong"><strong>@XmlElement(name = "releaseDate")</strong></span>
  private Date releaseDate;

  <span class="strong"><strong>@XmlElement(name = "price")</strong></span>
  private double price;
//getters and setters
}</pre></div><p>In this class, we just set the fields that represent a common compact disc attribute. The annotation <code class="literal">@XmlElement</code> is <a class="indexterm" id="id217"/>used to map a property to an XML element derived from a property name.</p><p>Now, it is time to implement the filter. We will show you the code after this short introduction, explain what we have done, and explain some technical concepts used in the implementation. Ready? Here we go!</p><p>Since the code of this class is a little bit long, we will split it and include a short description after each block of code, as follows:</p><div class="informalexample"><pre class="programlisting">@Provider
public class SecurityFilter implements javax.ws.rs.container.ContainerRequestFilter {

  private static final String ADMIN = "ADMIN";
  private static final String RESOURCE_METHOD_INVOKER = "org.jboss.resteasy.core.ResourceMethodInvoker";
  private static final String AUTHORIZATION_PROPERTY = "Authorization";
  private static final String AUTHENTICATION_SCHEME = "Basic";
  private static final ServerResponse ACCESS_DENIED = new ServerResponse("Access denied for this resource", 401,
      new Headers&lt;Object&gt;());
  private static final ServerResponse ACCESS_FORBIDDEN = new ServerResponse("Nobody can access this resource", 403,
      new Headers&lt;Object&gt;());</pre></div><p>Let's check<a class="indexterm" id="id218"/> out this code. The first step, in order to implement a filter, is the annotation <code class="literal">@Provider</code>. When we place this annotation at class level, we set the class as a filter. Our class name is <code class="literal">SecurityFilter</code>, and as you can see, it implements the interface <code class="literal">ContainerRequestFilter</code>. If you remember, this filter will execute on the server side and before the resource method is invoked.</p><p>At the start of our class's body, we set some constants that we will use later. The <code class="literal">AUTHORIZATION_PROPERTY</code> constant represents just the name of a property, as does the <code class="literal">RESOURCE_METHOD_INVOKER</code> constant. The <code class="literal">AUTHENTICATION_SCHEME</code> constant represents just a string. Both <code class="literal">ACCESS_DENIED</code> and <code class="literal">ACCESS_FORBIDDEN</code> constants represent two different server response objects in order to notify the user of the result of their request when it is denied or the user doesn't have enough permission.</p><p>As we implemented the interface <code class="literal">ContainerRequestFilter</code>, we must override the <code class="literal">filter()</code> method. It is inside this method that we will put our logic for the purpose of filtering the request based on the user that executed the request.</p><p>Let's start. As a first step, we obtain the method of the request using the constant <code class="literal">RESOURCE_METHOD_INVOKER</code>. After this, we will have a <code class="literal">ResourceMethodInvoker</code> object, and then the <code class="literal">Method</code> object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void filter(ContainerRequestContext requestContext) {
    ResourceMethodInvoker methodInvoker = (ResourceMethodInvoker) requestContext
        .getProperty(RESOURCE_METHOD_INVOKER);
    Method method = methodInvoker.getMethod();</pre></div><p>Next, we will perform some simple validations over <code class="literal">method</code>. We will check whether the method is annotated with <code class="literal">@PermitAll</code>. If it isn't, then the method continues, and we check whether it is annotated with <code class="literal">@DenyAll</code>. If the method is annotated with <code class="literal">DenyAll</code>, then we abort the request, including the constant <code class="literal">ACCESS_FORBIDDEN</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// Access allowed for all
    if (!method.isAnnotationPresent(PermitAll.class)) {
      // Access denied for all
      if (method.isAnnotationPresent(DenyAll.class)) {
        requestContext.abortWith(ACCESS_FORBIDDEN);
        return;
      }</pre></div><p>Now, we have<a class="indexterm" id="id219"/> to obtain the username and password. We must first obtain the headers of the request and put it in a map. Then, we obtain the authorization string list using <code class="literal">constant AUTHORIZATION_PROPERTY</code> as a key. This list will let us know whether the user has enough permission or not. So, we check if the list is empty or null; if it enters the <code class="literal">if()</code> block, we abort the request, including the constant <code class="literal">ACCESS_DENIED</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">      final MultivaluedMap&lt;String, String&gt; headersMap = requestContext.getHeaders();

      final List&lt;String&gt; authorizationList = headersMap.get(AUTHORIZATION_PROPERTY);

      if (authorizationList == null || authorizationList.isEmpty()) {
        requestContext.abortWith(ACCESS_DENIED);
        return;
      }</pre></div><p>This list has the encoded username and password as a string in the first element. So, we execute a replacement and eliminate the string contained in the constant <code class="literal">AUTHENTICATION_SCHEME</code>. Then, we decode it using the <code class="literal">Base64.decodeBase64</code> decoder, and through <code class="literal">StringTokenizer</code>, we obtain the username and password separated. Let's look at the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>      final String encodedUserPassword = authorizationList.get(0).replaceFirst(AUTHENTICATION_SCHEME + " ", "");</strong></span>

      String usernameAndPassword = new String(Base64.decodeBase64(encodedUserPassword));

      // Split username and password tokens
      final StringTokenizer tokenizer = new StringTokenizer(usernameAndPassword, ":");
      final String userName = tokenizer.nextToken();
      final String password = tokenizer.nextToken();</pre></div><p>Now is the time to evaluate and check whether the user has enough permission. First, let's check whether <code class="literal">method</code> has the <code class="literal">@RolesAllowed</code> annotation; if it does, we obtain the set of roles allowed using the object <code class="literal">method</code>. Finally, we check whether the constant <code class="literal">ADMIN</code> is included in this list. If it is not, the request is aborted and <code class="literal">ACCESS_DENIED</code> is once again included, as shown in the <a class="indexterm" id="id220"/>following code:</p><div class="informalexample"><pre class="programlisting">      // Verify user access
<span class="strong"><strong>      if (method.isAnnotationPresent(RolesAllowed.class)) {</strong></span>
<span class="strong"><strong>        RolesAllowed rolesAnnotation = method.getAnnotation(RolesAllowed.class);</strong></span>
        Set&lt;String&gt; rolesSet = new HashSet&lt;String&gt;(Arrays.asList(rolesAnnotation.value()));

        // Is user valid?
        if (!isUserAllowed(userName, password, rolesSet)) {
        requestContext.abortWith(ACCESS_DENIED);
          return;
        }
      }
    }
  }



  private boolean isUserAllowed(final String username, final String password, final Set&lt;String&gt; rolesSet) {
    boolean isAllowed = false;

    if (rolesSet.contains(ADMIN)) {
      isAllowed = true;
    }
    return isAllowed;
  }
}</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we studied and implemented one of the most useful and necessary techniques with the purpose of sharing and protecting our information. Nowadays, applications have dramatically increased their interaction with each other because they want to meet and satisfy the requirements of clients, users, and so on, compromising neither the security nor the integrity of the data while doing this.</p><p>In this chapter, we studied several technologies to secure, limit, and authorize the use of our resources to a third-party application, starting with brief but descriptive concepts about OAuth 2.0 authentication, Single Sign-On, filters, and tokens.</p><p>Through a practical example and real code, you witnessed how you can grant permission over specific resources to a third-party application in order to share the information and maintain control over it. Also, we checked and worked with specific code to implement one of the most used technologies in recent times, especially in the world of social networks, Single Sign-On. Now, you can put in to practice these concepts and technologies in order to build applications to interact with each other, selecting which resource you want to be shared, which applications you want to use as Single Sign-On, and filtering the use of certain resources based on the user and role.</p></div></body></html>