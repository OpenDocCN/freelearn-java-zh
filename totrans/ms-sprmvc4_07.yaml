- en: Chapter 7. Leaving Nothing to Luck – Unit Tests and Acceptance Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。别把希望寄托在运气上——单元测试和验收测试
- en: In this chapter, we will see why and how our application should be tested. We
    will see the differences between unit tests and acceptance tests, and learn how
    to do both.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解为什么以及如何对我们的应用程序进行测试。我们将了解单元测试和验收测试之间的区别，并学习如何进行这两种测试。
- en: This chapter is divided in two parts. In the first part, we will write tests
    in Java while studying the different ways of testing. In the second part, which
    is shorter, we will write the exact same tests in Groovy, and see how we can improve
    our code readability with this awesome language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两部分。在第一部分，我们将学习不同的测试方法的同时，用Java编写测试。在第二部分，这部分较短，我们将用Groovy编写完全相同的测试，并看看我们如何利用这种出色的语言提高代码的可读性。
- en: If you do everything in this chapter, you will have double tests, so feel free
    to keep only the tests that are most readable for you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成本章的所有内容，你将面临双重测试，所以请随意保留对你来说最易读的测试。
- en: Why should I test my code?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我应该测试我的代码？
- en: Working in the Java world has made a lot of developers aware of the importance
    of tests. A good series of tests can catch regressions early and allows us to
    be more confident when we ship our product.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中工作使许多开发者意识到了测试的重要性。一套好的测试可以尽早捕捉回归，并使我们发布产品时更有信心。
- en: A lot of people are now familiar with the notion of continuous integration ([http://www.thoughtworks.com/continuous-integration](http://www.thoughtworks.com/continuous-integration)).
    This is a practice where a server is in charge of building the application every
    time a change is made on the source control system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很多人已经熟悉了持续集成（[http://www.thoughtworks.com/continuous-integration](http://www.thoughtworks.com/continuous-integration)）的概念。这是一种实践，其中服务器负责在源代码控制系统上每次更改时构建应用程序。
- en: The build should be as fast as possible and capable of self testing. The main
    idea of this practice is to get a fast feedback loop; you should get details about
    what went wrong as soon as something in the system breaks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应该尽可能快，并且能够自我测试。这种实践的主要思想是获得快速的反馈循环；你应该在系统中的某个部分出错时立即获得有关出错详情。
- en: Why should you care? After all, testing your application is an additional cost;
    the time spent designing and maintaining tests will necessarily eat into some
    development time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要关心？毕竟，测试你的应用程序是一种额外的成本；设计和维护测试所花费的时间必然会占用一些开发时间。
- en: 'Actually, the later a bug is found, the costlier it gets. If you think about
    it, even a bug found by your QA team begins to cost more than a bug you find on
    your own. It forces you to switch back to the context you were in when writing
    the code: why did I write this line? What was the underlying business rule of
    that function?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，发现的错误越晚，成本越高。如果你这么想，即使是由你的QA团队发现的错误，其成本也开始超过你自己发现的错误。它迫使你回到编写代码时的上下文：我为什么要写这一行？那个函数的潜在业务规则是什么？
- en: If you write tests early on and are able to launch them in a few seconds, it
    will certainly cost less time to address potential bugs in your code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你早期编写测试，并且能够在几秒钟内启动它们，那么解决代码中潜在错误的成本肯定会更低。
- en: Another benefit of tests is that they act as a living documentation of your
    code. While writing extensive documentation, and even code comments, can prove
    ineffective because they easily become outdated, forming the habit of writing
    a good test for limit cases or surprising behaviors will act as a safety net for
    the future.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的另一个好处是它们充当了代码的活文档。虽然编写广泛的文档，甚至代码注释，可能会证明是无效的，因为它们很容易过时，但养成编写良好测试以限制情况或意外行为的习惯将作为未来的安全网。
- en: What is this line of code for? Have you ever found yourself asking this kind
    of question? Well, if you have a good set of unit tests, you can just remove it
    and see what breaks! Tests give us an unprecedented confidence in our code and
    in our ability to refactor it. Software is very fragile. If you stop caring, it
    will slowly rot and die.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码是做什么用的？你是否曾发现自己提出过这类问题？好吧，如果你有一套好的单元测试，你只需移除它并看看什么会出错！测试给了我们对代码和重构能力的空前信心。软件非常脆弱。如果你不再关心，它将慢慢腐烂并死亡。
- en: Be responsible—don't let your code die!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要负责任——不要让你的代码死亡！
- en: How should I test my code?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我应该如何测试我的代码？
- en: There are different kinds of tests that we can perform on a piece of software,
    such as security tests, performances test, and so on. As developers, we will focus
    on the tests we can automate and that will help improve our code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在软件上执行不同类型的测试，例如安全测试、性能测试等。作为开发者，我们将专注于我们可以自动化并且有助于改进我们代码的测试。
- en: 'The tests fall under two categories: unit tests and acceptance tests. The test
    pyramid ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    shows in what proportions these tests should be written:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试分为两大类：单元测试和验收测试。测试金字塔（[http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html)）显示了这些测试应该以何种比例编写：
- en: '![How should I test my code?](img/2117_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![如何测试我的代码？](img/2117_07_01.jpg)'
- en: 'At the bottom of the pyramid, you have the unit tests (fast to launch and relatively
    easy to maintain), and at the top, UI tests (costlier and slower to execute).
    Integration tests sit in the middle: they can be viewed as big unit tests with
    complex interactions between units.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的底部，是单元测试（启动快且相对容易维护），在顶部是UI测试（成本更高且执行速度更慢）。集成测试位于中间：它们可以被视为大型单元测试，具有单元之间的复杂交互。
- en: The idea of the pyramid is to remind you to put your focus where you have the
    most impact and get the best feedback loops.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的理念是提醒你将重点放在你影响最大和获得最佳反馈循环的地方。
- en: Test-driven development
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'Many developers develop the healthy habit of **Test-driven Development** (**TTD**).
    This practice, inherited from Extreme Programming (XP), is the process of splitting
    each development stage into small steps and then writing a failing test for every
    one of them. You make the necessary modifications so that the tests pass again
    (test are green). You can then refactor your code as long as the tests remain
    green. The following figure illustrates the TDD cycle:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者养成了健康的习惯，即**测试驱动开发**（**TDD**）。这种做法，源自极限编程（XP），是将每个开发阶段拆分成小步骤，并为每个步骤编写一个失败的测试。你进行必要的修改，以便测试再次通过（测试为绿色）。只要测试保持绿色，你就可以重构代码。以下图示说明了TDD周期：
- en: '![Test-driven development](img/2117_07_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动开发](img/2117_07_02.jpg)'
- en: You can iterate until the feature is done with very short feedback loops, with
    the insurance of no regressions, and the guarantee that all the code you write
    will be tested from the very beginning.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以迭代，直到功能完成，具有非常短的反馈循环，没有回归的保险，以及保证你写的所有代码从一开始就被测试。
- en: 'TDD gets its share of criticisms. The most interesting ones are these:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TDD受到了一些批评。其中最有趣的是这些：
- en: It takes more time to write the tests than to do the actual implementation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试所需的时间比实际实现的时间要多
- en: It can lead to poorly designed applications
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能导致设计不良的应用程序
- en: The truth of the matter is that it takes time to become a good TDD practitioner.
    Once you get the feeling of what should be tested and know your tools well enough,
    you won't lose much time at all.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，成为一名优秀的TDD实践者需要时间。一旦你掌握了应该测试什么的感觉，并且足够熟悉你的工具，你将不会浪费太多时间。
- en: It also takes experienced developers to craft an application with a proper design
    using TDD (or with any other methodology). Poor design can be a side effect of
    TDD if you get trapped in the baby steps mantra and forget to look at the big
    picture. It is true that TDD won't magically lead to great application design,
    so be careful and remember to take a step back after completing each feature.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD（或任何其他方法）构建具有适当设计的应用程序也需要经验丰富的开发者。如果你陷入“小步骤”的咒语而忘记了看大局，设计不良可能是TDD的副作用。诚然，TDD不会神奇地导致优秀应用程序的设计，所以请小心，并在完成每个功能后记得退一步思考。
- en: From the beginning of the book, we have only had one autogenerated unit test
    in our code. This is bad! We didn't follow good practice. This chapter is here
    to address this problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书开始，我们的代码中只有一个自动生成的单元测试。这是不好的！我们没有遵循良好的实践。本章就是为了解决这个问题而存在的。
- en: The unit tests
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: The lower level tests we can write are called unit tests. They should test a
    small portion of code, hence the notion of unit. How you define a unit is up to
    you; it can be a class or a bunch of closely related classes. Defining this notion
    will determine what will be mocked (replaced with a dummy object). Are you going
    to replace the database with a lightweight alternative? Are you going to replace
    interactions with external services? Are you going to mock-up closely related
    objects whose behavior is not relevant to the context of what's being tested?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写的较低级别的测试被称为单元测试。它们应该测试一小部分代码，因此有“单元”这一概念。你如何定义一个单元取决于你；它可以是类或是一组紧密相关的类。定义这一概念将决定什么将被模拟（用假对象替换）。你打算用轻量级替代品替换数据库吗？你打算替换与外部服务的交互吗？你打算模拟与测试上下文无关的行为不相关的紧密相关对象吗？
- en: My advice here is to keep a balanced approach. Keep your tests clean and fast,
    and everything else will follow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是保持平衡的方法。保持你的测试干净和快速，其他一切都会随之而来。
- en: I rarely completely mock the data layer. I tend to use embedded databases for
    testing. They provide an easy way to load data while testing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少完全模拟数据层。我倾向于使用嵌入式数据库进行测试。它们提供了一种在测试时轻松加载数据的方法。
- en: 'As a rule, I always mock collaboration with external services for two reasons,
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我总是出于两个原因模拟与外部服务的协作：
- en: The speed of the tests and the possibility to run the tests without connecting
    to the network
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的速度以及在没有连接到网络的情况下运行测试的可能性
- en: To be able to test error cases while communicating with those services
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够在与这些服务通信时测试错误情况
- en: Additionally, there is a subtle difference between mocking and stubbing. We
    will try to use both approaches to see how they relate to each other.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模拟和存根之间存在微妙的区别。我们将尝试使用这两种方法来了解它们之间的关系。
- en: The right tools for the job
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适合工作的正确工具
- en: The first barrier for test novices is the lack of knowledge of the good tools
    and libraries for writing relevant and maintainable tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试新手面临的第一道障碍是缺乏编写相关和可维护测试的良好工具和库的知识。
- en: 'I''m going to list a few here. This list is by no means exhaustive, but it
    contains the tools we are going to use and that are easily compatible with Spring:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里列出一些。这个列表绝对不是详尽的，但它包含了我们将要使用且与Spring兼容的工具：
- en: '| JUnit | The most universally adopted Java test runner. Launched by default
    by all build tools. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| JUnit | 最广泛采用的Java测试运行器。默认由所有构建工具启动。|'
- en: '| AssertJ | A fluent assertion library. It''s way easier to use than Hamcrest.
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| AssertJ | 一个流畅的断言库。它比Hamcrest更容易使用。|'
- en: '| Mockito | An easy mocking framework. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Mockito | 一个易于使用的模拟框架。|'
- en: '| DbUnit | For mocking and asserting your database content with XML datasets.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| DbUnit | 用于使用XML数据集模拟和断言你的数据库内容。|'
- en: '| Spock | An elegant Groovy DSL to write tests with Behaviour Driven Development
    (BDD) style (Given/When/Then). |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Spock | 一个优雅的Groovy DSL，用于以行为驱动开发（BDD）风格（Given/When/Then）编写测试。|'
- en: Groovy has a place of choice in my testing toolset. Even if you're not ready
    yet to put some Groovy code into production, you can easily use the convenience
    of the language in your tests. With Gradle, this is very easy to do, but we will
    see that in a few minutes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy在我的测试工具集中有特殊的位置。即使你还没有准备好将Groovy代码投入生产，你也可以轻松地在测试中使用该语言的便利性。使用Gradle，这非常容易做到，但我们将稍后看到。
- en: The acceptance tests
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试
- en: In the context of a web application, "acceptance test" will often refer to in-browser,
    end-to-end testing. In the Java world, Selenium is clearly one of the most reliable
    and mature libraries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的上下文中，“验收测试”通常指的是浏览器内、端到端测试。在Java世界中，Selenium显然是最可靠和成熟的库之一。
- en: 'In the JavaScript world, we can find other alternatives, such as PhantomJS
    or Protractor. PhantomJS is very relevant in our case because there is a web driver
    available to run Selenium tests inside of this headless browser, which will improve
    launch time and won''t require emulating an X Server or launching a separate Selenium
    server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript世界中，我们可以找到其他替代品，例如PhantomJS或Protractor。PhantomJS在我们的案例中非常相关，因为有一个WebDriver可以在无头浏览器中运行Selenium测试，这将提高启动时间，并且不需要模拟X服务器或启动单独的Selenium服务器：
- en: '| Selenium 2 | This provides web drivers to pilot browsers for automated testing.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Selenium 2 | 这提供了用于自动化测试的浏览器驱动程序。|'
- en: '| PhantomJS | A headless browser (without GUI). Probably the fastest browser.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| PhantomJS | 一个无头浏览器（没有GUI）。可能是最快的浏览器。|'
- en: '| FluentLenium | A fluent library for piloting Selenium tests. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| FluentLenium | 一个用于引导Selenium测试的流畅库。|'
- en: '| Geb | A Groovy library for piloting Selenium tests. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Geb | 一个用于执行Selenium测试的Groovy库。|'
- en: Our first unit test
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一单元测试
- en: It is now time to write our first unit test.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写我们的第一个单元测试了。
- en: 'We will focus on writing tests at the controller level because we have little
    to no business code or service. The key to writing tests for Spring MVC is the
    `org.springframework.boot:spring-boot-starter-test` dependency in our classpath.
    It will add a few very useful libraries, such as these:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于编写控制器级别的测试，因为我们几乎没有业务代码或服务。编写Spring MVC测试的关键是我们类路径中的`org.springframework.boot:spring-boot-starter-test`依赖项。它将添加一些非常实用的库，例如这些：
- en: '`hamcrest`: This is JUnit''s assertion library'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hamcrest`：这是JUnit的断言库'
- en: '`mockito`: This is a mocking library'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockito`：这是一个模拟库'
- en: '`spring-test`: This is the Spring testing library'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-test`：这是Spring测试库'
- en: We will test the redirection to the profile page that is created when the user
    hasn't created their profile yet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试当用户还没有创建他们的个人资料时，重定向到个人资料页面的情况。
- en: 'We already have an autogenerated test called `MasterSpringMvc4ApplicationTests`.
    It is the most basic kind of test one can write with the Spring test framework:
    it does nothing but blow up if the context cannot be loaded:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个自动生成的测试叫做`MasterSpringMvc4ApplicationTests`。这是可以用Spring测试框架编写的最基本类型的测试：它什么也不做，如果上下文无法加载，就会崩溃：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can delete this test and create one that will ensure that a user with no
    profile will be redirected to the profile page by default. It will actually test
    the code of the `HomeController` class, so let's call it `HomeControllerTest`
    class and put it in the same package as `HomeController`, in `src/test/java`.
    All IDEs have shortcuts for creating a JUnit test case from a class. Find out
    how to do it with yours now!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除这个测试，创建一个新的测试来确保没有个人资料的用户新建默认重定向到个人资料页面。实际上，这将测试`HomeController`类的代码，所以让我们称它为`HomeControllerTest`类，并将其放在与`HomeController`相同的包中，在`src/test/java`。所有IDE都有从类创建JUnit测试用例的快捷方式。现在就找出如何使用你的IDE来做这件事吧！
- en: 'Here is the test:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是测试：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use `MockMvc` to simulate interactions with a Spring controller without the
    actual overhead of a Servlet container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`MockMvc`来模拟与Spring控制器的交互，而不需要Servlet容器的实际开销。
- en: We also use a couple of matchers that Spring provides to assert our result.
    They actually implement Hamcrest matchers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一些Spring提供的匹配器来断言我们的结果。它们实际上实现了Hamcrest匹配器。
- en: The `.andDo(print())` statement will produce a neat debug output for the request
    and response of the scenario under test. You can comment it if you find it too
    verbose.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`.andDo(print())`语句将为测试场景的请求和响应生成整洁的调试输出。如果你觉得它太冗长，可以将其注释掉。'
- en: That's all there is to it! The syntax is a bit tricky at the beginning, but
    an IDE with good completion will be able to help you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！一开始语法有点棘手，但一个具有良好补全功能的IDE将能够帮助你。
- en: 'Now we want to test whether, if the user has filled in the test part of their
    profile, we can redirect them to the correct search. For that, we will need to
    stub the session with the `MockHttpSession` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想测试如果用户已经填写了他们的个人资料测试部分，我们能否将他们重定向到正确的搜索。为此，我们需要使用`MockHttpSession`类存根会话：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will have to add the `setTastes()` setter to the `UserProfileSession` bean
    for the test to work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试工作，你必须将`setTastes()`设置器添加到`UserProfileSession`bean中。
- en: There are a lot of mocking utilities for the Servlet environment in the `org.springframework.mock.web`
    package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.mock.web`包中有许多用于Servlet环境的模拟工具。'
- en: Note that the attribute representing our bean in session is prefixed by `scopedTarget`.
    That's because session beans are proxified by Spring. Therefore, there are actually
    two objects in the Spring context, the actual bean that we defined and its proxy
    that will end up in the session.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代表我们的bean在会话中的属性以`scopedTarget`为前缀。这是因为会话bean被Spring代理。因此，在Spring上下文中实际上有两个对象，我们定义的实际bean及其最终将放入会话的代理。
- en: 'The mock session is a neat class, but we can refactor the test with a builder
    that will hide implementation details and can be reused later:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟会话是一个整洁的类，但我们可以通过一个构建器重构测试，该构建器将隐藏实现细节，并且可以在以后重用：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code for the builder is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器的代码如下：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After this refactoring, your test should always pass, of course.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重构之后，当然你的测试应该总是通过。
- en: Mocks and stubs
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟和存根
- en: If we wanted to test the search request handled by the `SearchController` class,
    we would certainly want to mock `SearchService`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想测试由`SearchController`类处理的搜索请求，我们当然会想模拟`SearchService`。
- en: 'There are two ways of doing this: with a mock or with a stub.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法来做这件事：使用模拟或使用存根。
- en: Mocking with Mockito
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Mockito进行模拟
- en: 'First, we can create a mock object with Mockito:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用Mockito创建一个模拟对象：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that instead of setting up `MockMvc` with the web application context,
    we have created a standalone context. This context will only contain our controller.
    That means we have full control over the instantiation and initialization of controllers
    and their dependencies. It will allow us to easily inject a mock inside of our
    controller.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们不是使用带有Web应用程序上下文的`MockMvc`来设置，而是创建了一个独立上下文。这个上下文将只包含我们的控制器。这意味着我们对控制器及其依赖的实例化和初始化有完全的控制权。这将使我们能够轻松地在控制器内部注入模拟对象。
- en: The downside is that we have to redeclare pieces of our configuration like the
    one saying we don't want to remove URL characters after a semicolon.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，我们必须重新声明我们配置的一部分，比如说我们不想在分号之后删除URL字符。
- en: We use a couple of Hamcrest matchers to assert the properties that will end
    up in the view model.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用几个Hamcrest匹配器来断言最终会出现在视图模型中的属性。
- en: The mocking approach has its benefits, such as the ability to verify interactions
    with the mock and create expectations at runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟方法有其优点，例如能够验证与模拟对象的交互并在运行时创建期望。
- en: This will also couple your test with the actual implementation of the object.
    For instance, if you changed how a tweet is fetched in the controller, you would
    likely break the tests related to this controller because they still try to mock
    the service we no longer rely on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将使你的测试与对象的实际实现相关联。例如，如果你在控制器中更改了获取推文的方式，你可能会破坏与此控制器相关的测试，因为它们仍然试图模拟我们不再依赖的服务。
- en: Stubbing our beans while testing
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试时存根我们的豆
- en: Another approach is to replace the implementation of our `SearchService` class
    with another one in our test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是替换我们的`SearchService`类在测试中的实现。
- en: We were a bit lazy early on and did not define an interface for `SearchService`.
    *Always program to an interface and not to an implementation*. Behind this proverbial
    wisdom lies the most important lesson from the *Gang of Four*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始有点懒惰，没有为`SearchService`定义接口。*始终面向接口编程，而不是面向实现*。这句谚语背后的智慧是“四人帮”最重要的教训之一。
- en: 'One of the benefits of the Inversion of Control is to allow for the easy replacement
    of our implementations in tests or in a real system. For this to work, we will
    have to modify all the usages `SearchService` with the new interface. With a good
    IDE, there is a refactoring called `extract interface` that will do just that.
    This should create an interface that contains the public method `search()` of
    our `SearchService` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转的一个好处是允许我们在测试或真实系统中轻松替换我们的实现。为了使这成为可能，我们必须修改所有使用`SearchService`的地方，使用新的接口。一个好的IDE有一个名为“提取接口”的重构，它将做到这一点。这应该会创建一个包含我们`SearchService`类公共方法`search()`的接口：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, our two controllers, `SearchController` and `SearchApiController`,
    must now use the interface and not the implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的两个控制器`SearchController`和`SearchApiController`现在必须使用接口而不是实现。
- en: 'We now have the ability to create a test double for the `TwitterSearch` class
    specially for our test case. For this to work, we will need to declare a new Spring
    configuration named `StubTwitterSearchConfig` that will contain another implementation
    for `TwitterSearch`. I placed it in the search package, next to `SearchControllerMockTest`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有能力为`TwitterSearch`类创建一个专门针对测试用例的测试双胞胎。为了使这成为可能，我们需要声明一个新的Spring配置，名为`StubTwitterSearchConfig`，它将包含`TwitterSearch`的另一个实现。我将它放在了搜索包中，紧挨着`SearchControllerMockTest`：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this configuration class, we redeclare the `TwitterSearch` bean with the
    `@Primary` annotation, which will tell Spring to use this implementation on priority
    if other implementations are found in the classpath.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置类中，我们重新声明了带有`@Primary`注解的`TwitterSearch`豆，这将告诉Spring如果类路径中找到其他实现，则优先使用这个实现。
- en: Since the `TwitterSearch` interface contains only one method, we can implement
    it with a lambda expression.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`TwitterSearch`接口只包含一个方法，我们可以使用lambda表达式来实现它。
- en: 'Here is the complete test that uses our `StubConfiguration` class along with
    our main configuration with the `SpringApplicationConfiguration` annotation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用我们的`StubConfiguration`类以及带有`SpringApplicationConfiguration`注解的主要配置的完整测试：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Should I use mocks or stubs?
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该使用模拟还是存根？
- en: 'Both approaches have their own merits. For a detailed explanation, check out
    this great essay by Martin Fowler: [http://martinfowler.com/articles/mocksArentStubs.html](http://martinfowler.com/articles/mocksArentStubs.html).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优点。对于详细解释，请查看 Martin Fowler 的这篇优秀文章：[http://martinfowler.com/articles/mocksArentStubs.html](http://martinfowler.com/articles/mocksArentStubs.html)。
- en: My testing routine is more about writing stubs because I like the idea of testing
    the output of my objects more than their inner workings. But that's up to you.
    Spring being a dependency injection framework at its core means that you can easily
    choose what your favorite approach is.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我的测试例程更多的是编写存根，因为我更喜欢测试对象的输出而不是它们的内部工作。但那取决于你。Spring 作为其核心的依赖注入框架意味着你可以轻松地选择你喜欢的任何方法。
- en: Unit testing REST controllers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 REST 控制器
- en: We have just tested a traditional controller redirecting to a view. Testing
    a REST controller is very similar in principle, but there are a few subtleties.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚测试了一个传统的控制器重定向到视图。在原则上测试 REST 控制器非常相似，但有一些细微差别。
- en: 'Since we are going to test the JSON output of our controller, we need a JSON
    assertion library. Add the following dependency to your `build.gradle` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算测试我们控制器的 JSON 输出，我们需要一个 JSON 断言库。将以下依赖项添加到您的 `build.gradle` 文件中：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s write a test for the `SearchApiController` class, the controller that
    allows searching for a tweet and returns results as JSON or XML:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为允许搜索推文并返回 JSON 或 XML 结果的 `SearchApiController` 类编写一个测试，该控制器：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note the simple and elegant assertions on the JSON output. Testing our user
    controller will require a bit more work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对 JSON 输出的简单而优雅的断言。测试我们的用户控制器将需要更多的工作。
- en: 'First, let''s add `assertj` to the classpath; it will help us write cleaner
    tests:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将 `assertj` 添加到类路径中；它将帮助我们编写更干净的测试：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, to simplify testing, add a `reset()` method to our `UserRepository` class
    that will help us with the test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了简化测试，向我们的 `UserRepository` 类添加一个 `reset()` 方法，这将帮助我们进行测试：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In real life, we should probably extract an interface and create a stub for
    testing. I will leave that as an exercise for you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们可能需要提取一个接口并为测试创建一个存根。我将把这个作为你的练习。
- en: 'Here is the first test that gets the list of users:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一个获取用户列表的测试：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For this to work, add a constructor to the `User` class, taking the e-mail
    property as a parameter. Be careful: you also need to have a default constructor
    for Jackson.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这生效，向 `User` 类添加一个构造函数，该构造函数接受电子邮件属性作为参数。请注意：您还需要为 Jackson 提供一个默认构造函数。
- en: The test is very similar to the previous test with the additional setup of `UserRepository`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与之前的测试非常相似，只是增加了 `UserRepository` 的设置。
- en: 'Let''s test the `POST` method that creates a user now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试创建用户的 `POST` 方法：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are two things to be noted. The first one is the use of AssertJ to assert
    the content of the repository after the test. You will need the following static
    import for that to work:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点需要注意。第一点是使用 AssertJ 在测试后断言存储库的内容。为此，您需要以下静态导入：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second is that we use a utility method to convert our object to JSON before
    sending it to the controller. For that purpose, I created a simple utility class
    in the `utils` package, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是我们在发送到控制器之前使用一个实用方法将我们的对象转换为 JSON。为此目的，我在 `utils` 包中创建了一个简单的实用类，如下所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The tests for the `DELETE` method are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 方法的测试如下：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, here''s the test for the `PUT` method, which updates a user:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是测试 `PUT` 方法的测试，该方法更新用户：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Whoops! The last test does not pass! By checking the implementation of `UserApiController`,
    we can easily see why:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！最后一个测试没有通过！通过检查 `UserApiController` 的实现，我们可以很容易地看出原因：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We returned the wrong status in the controller! Change it to `HttpStatus.OK`
    and the test should be green again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制器中返回了错误的状态！将其更改为 `HttpStatus.OK`，测试应该再次变绿。
- en: With Spring, one can easily write controller tests using the same configuration
    of our application, but we can just as efficiently override or change some elements
    in our testing setup.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring，可以轻松地使用我们应用程序的相同配置编写控制器测试，但我们也可以有效地覆盖或更改我们的测试设置中的某些元素。
- en: Another interesting thing that you will notice while running all the tests is
    that the application context is only loaded once, which means that the overhead
    is actually very small.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行所有测试时，您会发现的一个有趣的事情是应用程序上下文只加载一次，这意味着开销实际上非常小。
- en: Our application is small too, so we did not make any effort to split our configuration
    into reusable chunks. It can be a really good practice not to load the full application
    context inside of every test. You can actually split the component scanned into
    different units with the `@ComponentScan` annotation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This annotation has several attributes that allow you to define filters with
    `includeFilter` and `excludeFilter` (loading only the controller for instance)
    and scan specific packages with the `basePackageClasses` and `basePackages` annotations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: You can also split your configuration into multiple `@Configuration` classes.
    A good example would be splitting the code for the users and for the tweet parts
    of our application into two independent parts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We will now have a look at acceptance tests, which are a very different kind
    of beast.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Testing the authentication
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to set up Spring Security in a MockMvc test, you can write this
    test next to our previous test:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we added `SpringSecurityFilter` to our configuration.
    This will activate Spring Security checks. To test if the authentication works,
    we simply send the correct headers along with the request we would like to perform.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of basic authentication is that it's really straightforward to
    simulate. With a more complicated setup, you would have to perform a mock request
    on the authentication endpoint.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Spring Boot is at version 1.2.3 and depends on Spring
    Security 3.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In a few weeks, Spring Boot 1.3.0 will be available, it will update Spring Security
    and use version 4.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: This is good news because Spring Security 4 includes a really easy setup of
    the authenticated user with simple annotations. See [http://docs.spring.io/spring-security/site/docs/4.0.x/reference/htmlsingle/#test](http://docs.spring.io/spring-security/site/docs/4.0.x/reference/htmlsingle/#test)
    for more details.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Writing acceptance tests
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests can only cover a subset of the different interactions between the
    components of our application. To go a little further, we will need to set up
    acceptance tests, tests that will actually boot up the complete application and
    allow us to interact with its interface.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle configuration
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we will want to do when we add integration tests to a project
    is to put them in a different location to that of the unit tests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is, essentially, that acceptance tests are slower than
    unit tests. They can be part of a different integration job, such as a nightly
    build, and we want developers to be able to launch the different kinds of tests
    easily from their IDE. To do this with Gradle, we will have to add a new configuration
    called `integrationTest`. For Gradle, a configuration is a group of artifacts
    and their dependencies. We already have several configurations in our project:
    `compile`, `testCompile`, and so on.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: You can have a look at the configurations of your project, and much more, by
    typing `./gradlew properties` at the root of your project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在项目根目录下输入`./gradlew properties`来查看你项目的配置，以及更多内容。
- en: 'Add a new configuration at the end of `build.gradle` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`文件末尾添加一个新的配置：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will allow you to declare dependencies for `integrationTestCompile` and
    `integrationTestRuntime`. More importantly, by inheriting the test configurations,
    we have access to their dependencies.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你为`integrationTestCompile`和`integrationTestRuntime`声明依赖项。更重要的是，通过继承测试配置，我们可以访问它们的依赖项。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I do not recommend declaring your integration test dependencies as `integrationTestCompile`.
    It will work as far as Gradle is concerned, but support inside of IDE is non-existent.
    What I usually do is declare my integration test dependencies as `testCompile`
    dependencies instead. This is only a small inconvenience.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议将你的集成测试依赖项声明为`integrationTestCompile`。它对Gradle来说会正常工作，但在IDE中的支持不存在。我通常会将我的集成测试依赖项声明为`testCompile`依赖项。这只是一个小的不便。
- en: 'Now that we have our new configurations, we must create a `sourceSet` class
    associated with them. A `sourceSet` class represents a logical group of Java source
    and resources. Naturally, they also have to inherit from the test and main classes;
    see the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的配置，我们必须为它们创建一个与之关联的`sourceSet`类。`sourceSet`类代表一组逻辑上的Java源代码和资源。自然地，它们也必须继承自测试和主类；请参见以下代码：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we need to add a task to run them from our build, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个任务来从我们的构建中运行它们，如下所示：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To run our test, we can type `./gradlew integrationTest`. Besides configuring
    our classpath and where to find our test classes, we also defined a directory
    where the test report will be generated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试，我们可以输入`./gradlew integrationTest`。除了配置我们的类路径和测试类的位置外，我们还定义了一个测试报告将被生成的目录。
- en: This configuration allows us to write our tests in `src/integrationTest/java`
    or `src/integrationTest/groovy`, which will make it easier to identify them and
    run them separately from our unit tests.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置允许我们在`src/integrationTest/java`或`src/integrationTest/groovy`中编写我们的测试，这将使它们更容易被识别，并且可以单独从我们的单元测试中运行它们。
- en: By default, they will be generated in `build/reports/tests`. If we do not override
    them, if we launch both tests and integration tests with `gradle clean test integrationTest`,
    they will override each other.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它们将被生成在`build/reports/tests`目录下。如果我们不覆盖它们，如果我们使用`gradle clean test integrationTest`启动测试和集成测试，它们将相互覆盖。
- en: It's also worth mentioning that a young plugin in the Gradle ecosystem aims
    to simplify declaring new test configurations, visit [https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets](https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets)
    for detailed information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Gradle生态系统中的一个年轻插件旨在简化声明新的测试配置，有关详细信息，请访问[https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets](https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets)。
- en: Our first FluentLenium test
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一条FluentLenium测试
- en: 'FluentLenium is an amazing library for piloting Selenium tests. Let''s add
    a few dependencies to our build script:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: FluentLenium是一个用于执行Selenium测试的出色库。让我们在我们的构建脚本中添加一些依赖项：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By default, `fluentlenium` comes with `selenium-java`. We redeclare it just
    to explicitly require the latest version available. We also added a dependency
    to the `PhantomJS` driver, which is not officially supported by Selenium. The
    problem with the `selenium-java` library is that it comes bundled with all the
    supported web drivers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`fluentlenium`附带`selenium-java`。我们重新声明它只是为了明确要求可用的最新版本。我们还添加了对`PhantomJS`驱动程序的依赖项，该驱动程序不是由Selenium官方支持的。`selenium-java`库的问题在于它捆绑了所有受支持的Web驱动程序。
- en: 'You can see the dependency tree of our project by typing `gradle dependencies`.
    At the bottom, you will see something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`gradle dependencies`来查看你项目的依赖树。在底部，你会看到类似以下的内容：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Having all those dependencies in the classpath is highly unnecessary since
    we will just use the `PhantomJS` driver. To exclude the dependencies we won''t
    need, we can add the following part to our buildscript, right before the dependencies
    declaration:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只会使用`PhantomJS`驱动程序，所以将这些依赖项全部放在类路径中是非常不必要的。为了排除我们不需要的依赖项，我们可以在我们的buildscript中添加以下部分，在依赖项声明之前：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We just keep the `firefox` driver at hand. `PhantomJS` driver is a headless
    browser, so understanding what happens without a GUI can prove tricky. It can
    be nice to switch to Firefox to debug a complex test.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需保留`firefox`驱动器。`PhantomJS`驱动器是一个无头浏览器，因此理解没有GUI发生的事情可能会很棘手。切换到Firefox来调试复杂的测试可能是个不错的选择。
- en: 'With our classpath correctly configured, we can now write our first integration
    test. Spring Boot has a very convenient annotation to support this test:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确配置了classpath之后，我们现在可以编写我们的第一个集成测试。Spring Boot有一个非常方便的注解来支持这种测试：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that FluentLenium has a neat API for requesting DOM elements. With AssertJ,
    we can then write easy-to read-assertions on the page content.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，FluentLenium有一个用于请求DOM元素的整洁API。然后，我们可以使用AssertJ在页面内容上编写易于阅读的断言。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have a look at the documentation at [https://github.com/FluentLenium/FluentLenium](https://github.com/FluentLenium/FluentLenium)
    for further information.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://github.com/FluentLenium/FluentLenium](https://github.com/FluentLenium/FluentLenium)上的文档以获取更多信息。
- en: With the `@WebIntegrationTest` annotation, Spring will actually create the embedded
    Servlet container (Tomcat) and launch our web application on a random port! We
    need to retrieve this port number at runtime. This will allow us to provide a
    base URL for our tests, a URL that will be the prefix for all the navigation we
    do in our tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@WebIntegrationTest`注解，Spring实际上会创建嵌入的Servlet容器（Tomcat）并在随机端口上启动我们的Web应用程序！我们需要在运行时检索这个端口号。这将允许我们为测试提供一个基本URL，这个URL将是我们在测试中进行的所有导航的前缀。
- en: 'If you try to run the test at this stage, you will see the following error
    message:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个阶段尝试运行测试，你将看到以下错误信息：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Indeed, PhantomJS needs to be installed on your machine for this to work correctly.
    On a Mac, simply use `brew install phantomjs`. For other platforms, see the documentation
    at [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，PhantomJS需要安装在你的机器上才能正确工作。在Mac上，只需使用`brew install phantomjs`。对于其他平台，请参阅[http://phantomjs.org/download.html](http://phantomjs.org/download.html)上的文档。
- en: If you don't want to install a new binary on your machine, replace `new PhantomJSDriver()`
    with `new FirefoxDriver()`. Your test will be a bit slower, but you will have
    a GUI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在机器上安装新的二进制文件，将`new PhantomJSDriver()`替换为`new FirefoxDriver()`。你的测试会稍微慢一些，但你将有一个GUI。
- en: Our first test is landing on the profile page, right? We need to find a way
    to log in now.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一测试是登录到配置文件页面，对吧？我们现在需要找到一种登录的方法。
- en: What about faking login with a stub?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用存根伪造登录怎么办？
- en: 'Put this class in the test sources (`src/test/java`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类放入测试源代码（`src/test/java`）：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will authenticate any user clicking on the Twitter sign in button as geowarin.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将验证任何点击Twitter登录按钮的用户为geowarin。
- en: 'We will write a second test that will fill the profile form and assert that
    the search result is displayed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写第二个测试，该测试将填写配置文件表单并断言搜索结果已显示：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that we can easily ask our web driver to take a screenshot of the current
    browser used for testing. This will produce the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以轻松地让我们的WebDriver截取当前用于测试的浏览器的屏幕截图。这将产生以下输出：
- en: '![Our first FluentLenium test](img/2117_07_03.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个FluentLenium测试](img/2117_07_03.jpg)'
- en: Page Objects with FluentLenium
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FluentLenium的页面对象
- en: The previous test was a bit messy. We have hardcoded all the selectors in our
    test. This can become very risky when we write a lot of tests using the same elements
    because whenever we change the page layout, all the tests will break. Moreover,
    the test is a little difficult to read.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试有点混乱。我们在测试中硬编码了所有的选择器。当我们使用相同的元素编写大量测试时，这可能会变得非常危险，因为每次我们更改页面布局，所有测试都会失败。此外，测试的阅读性有点困难。
- en: To fix this, a common practice is to use a page object that will represent a
    specific web page in our application. With FluentLenium, page objects must inherit
    the `FluentPage` class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，一个常见的做法是使用一个页面对象来表示我们应用程序中的特定网页。使用FluentLenium，页面对象必须继承`FluentPage`类。
- en: We will create three pages, one for each element of our GUI. The first one will
    be the login page with the option to click on the `twitterSignin` button, the
    second one will be the profile page with convenience methods for filling in the
    profile form, and the last one will be the result page on which we can assert
    the results displayed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个页面，一个用于GUI的每个元素。第一个将是登录页面，可以选择点击`twitterSignin`按钮，第二个将是配置文件页面，其中包含填充配置文件表单的便利方法，最后一个将是结果页面，我们可以断言显示的结果。
- en: 'Let''s create the login page at once. I put all the three pages in a `pages`
    package:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s create one page for our profile page:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s also create another one for the search result page:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now refactor the test using those Page Objects:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Much more readable, isn't it?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Making our tests more Groovy
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't know Groovy, consider it like a close cousin of Java, without the
    verbosity. Groovy is a dynamic language with optional typing. This means that
    you can have the guarantees of a type system when it matters and the versatility
    of duck typing when you know what you are doing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: With this language, you can write POJOs without getters, setters, `equals` and
    `hashcode` methods. Everything is handled for you.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Writing `==` will actually call the `equals` method. The operators can be overloaded,
    which allows a neat syntax with little arrows, such as `<<`, to write text to
    a file, for instance. It also means that you can add integers to `BigIntegers`
    and get a correct result.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The **Groovy Development Kit** (**GDK**) also adds several very interesting
    methods to classic Java objects. It also considers regular expressions and closures
    as first-class citizens.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want a solid introduction to Groovy, check out the Groovy style guide
    at [http://www.groovy-lang.org/style-guide.html](http://www.groovy-lang.org/style-guide.html).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: You can also watch this amazing presentation by Peter Ledbrook at [http://www.infoq.com/presentations/groovy-for-java](http://www.infoq.com/presentations/groovy-for-java).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: As far as I am concerned, I always try to push Groovy on the testing side of
    the application I work on. It really improves the readability of the code and
    the productivity of developers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests with Spock
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to write Groovy tests in our project, we need to use the Groovy plugin
    instead of the Java plugin.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you have in your build script:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Change it to the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This modification is perfectly harmless. The Groovy plugin extends the Java
    plugin, so the only difference it makes is that it gives the ability to add Groovy
    source in `src/main/groovy`, `src/test/groovy` and `src/integrationTest/groovy`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we also need to add Groovy to the classpath. We will also add Spock,
    the most popular Groovy testing library, via the `spock-spring` dependency, which
    will enable compatibility with Spring:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now rewrite `HomeControllerTest` with a different approach. Let''s create
    a `HomeControllerSpec` class in `src/test/groovy`. I added it to the `masterSpringMvc.controller`
    package just like our first instance of `HomeControllerTest`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our test instantaneously became more readable with the ability to use strings
    as method names and the little BDD DSL (Domain Specific Language) provided by
    Spock. This is not directly visible here, but every statement inside of a `then`
    block will implicitly be an assertion.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, because Spock doesn't read meta annotations, the `@SpringApplicationConfiguration`
    annotation cannot be used so we just replaced it with `@ContextConfiguration(loader
    = SpringApplicationContextLoader)`, which is essentially the same thing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，由于Spock不读取元注解，因此不能使用`@SpringApplicationConfiguration`注解，所以我们将其替换为`@ContextConfiguration(loader
    = SpringApplicationContextLoader)`，这本质上是一样的。
- en: We now have two versions of the same test, one in Java and the other in Groovy.
    It is up to you to choose the one that best fits your style of coding and remove
    the other one. If you decide to stick with Groovy, you will have to rewrite the
    `should_redirect_to_tastes()` test in Groovy. It should be easy enough.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了同一测试的两个版本，一个是Java版本，另一个是Groovy版本。选择最适合您编码风格的版本，并删除另一个版本。如果您决定坚持使用Groovy，您将不得不将`should_redirect_to_tastes()`测试重写为Groovy。这应该不难。
- en: 'Spock also has powerful support for mocks. We can rewrite the previous `SearchControllerMockTest`
    class a bit differently:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Spock也提供了强大的mock支持。我们可以将之前的`SearchControllerMockTest`类稍作修改：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the verbosity of Mockito is now gone. The `then` block actually asserts
    that the `twitterSearch` method is called once (`1 *`) with any parameter (`_,
    _`). Like with mockito, we could have expected specific parameters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito的所有冗余现在都消失了。`then`块实际上断言`twitterSearch`方法被调用一次（`1 *`）并且带有任何参数（`_, _`）。就像mockito一样，我们本可以期望特定的参数。
- en: The double arrow `>>` syntax is used to return an object from the mocked method.
    In our case, it's a list containing only one element.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 双箭头`>>`语法用于从mocked方法返回一个对象。在我们的例子中，它是一个只包含一个元素的列表。
- en: With only a little dependency in our classpath, we have already written more
    readable tests, but we're not done yet. We will also refactor our acceptance tests
    to use Geb, a Groovy library that pilots Selenium tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过在我们的类路径中添加少量依赖项，我们就已经编写了更易于阅读的测试，但我们还没有完成。我们还将重构我们的验收测试以使用Geb，这是一个引导Selenium测试的Groovy库。
- en: Integration tests with Geb
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Geb的集成测试
- en: Geb is the de facto library for writing tests in the Grails framework. Although
    its version is 0.12.0, it is very stable and extremely comfortable to work with.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Geb是Grails框架中编写测试的事实上的库。尽管其版本为0.12.0，但它非常稳定，并且非常易于使用。
- en: It provides a selector API à la jQuery, which makes tests easy to write, even
    for frontend developers. Groovy is also a language that has some JavaScript influences
    that will also appeal to them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个类似于jQuery的选择器API，这使得测试易于编写，即使是对于前端开发者来说也是如此。Groovy也是一种受到JavaScript影响的编程语言，这也将吸引他们。
- en: 'Let''s add Geb with the support for Spock specifications to our classpath:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加Geb和Spock规范支持的类路径：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Geb can be configured via a Groovy script found directly at the root of `src/integrationTest/groovy`,
    called `GebConfig.groovy`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Geb可以通过位于`src/integrationTest/groovy`根目录下的Groovy脚本进行配置，该脚本名为`GebConfig.groovy`：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this configuration, we indicate where Geb will generate its reports and which
    driver to use. Reports in Geb are an enhanced version of screenshots, which also
    contains the current page in HTML. Their generation can be triggered at any moment
    by calling the `report` function inside a Geb test.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们指定了Geb将生成报告的位置以及要使用的驱动器。Geb的报告是屏幕截图的增强版本，它还包含当前页面的HTML。可以在任何时刻通过在Geb测试中调用`report`函数来触发报告的生成。
- en: 'Let''s rewrite out first integration test with Geb:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Geb重写我们的第一个集成测试：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For the moment, it is very similar to FluentLenium. We can already see the `$`
    function, which will allow us to grab a DOM element via its selector. Here, we
    also state that we want the first `h2` in the page by giving the `0` index.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它与FluentLenium非常相似。我们已经可以看到`$`函数，它将允许我们通过其选择器获取DOM元素。在这里，我们还声明我们想要页面的第一个`h2`，通过给出`0`索引。
- en: Page Objects with Geb
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Geb的页面对象
- en: Page objects with Geb are a real pleasure to work with. We will create the same
    page objects that we did previously so that you can appreciate the differences.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Geb的页面对象非常易于工作。我们将创建与之前相同的页面对象，以便您能够欣赏到差异。
- en: 'With Geb, the Page Objects must inherit from the `geb.Page` class. First, let''s
    create the `LoginPage`. I suggest avoiding putting it in the same package as the
    previous one. I created a package called `geb.pages`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Geb时，页面对象必须继承自`geb.Page`类。首先，让我们创建`LoginPage`。我建议不要将其放在与之前相同的包中。我创建了一个名为`geb.pages`的包：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we can create the `ProfilePage`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建`ProfilePage`：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is basically the same page as before. Note the little `<<` to assign values
    to an input element. You could also call `setText` on them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与之前的页面相同。注意小 `<<` 用于将值分配给输入元素。您也可以调用 `setText`。
- en: The `at` method is completely part of the framework, and Geb will automatically
    assert those when you navigate to the corresponding page.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`at` 方法完全是框架的一部分，当您导航到相应的页面时，Geb 会自动断言这些内容。'
- en: 'Let''s create the `SearchResultPage`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `SearchResultPage`：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's a bit shorter, thanks to the ability to reuse previously defined content
    for the results.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以重用先前定义的内容来生成结果，所以它稍微短一些。
- en: 'With out the Page Object set up, we can write the test as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有设置页面对象的情况下，我们可以这样编写测试：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: My, what a beauty! You can certainly write your user stories directly with Geb!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，真美！您当然可以直接用 Geb 编写用户故事！
- en: With our simple tests, we only scratched the surface of Geb. There is much more
    functionality available, and I encourage you to read the *Book of Geb*, a very
    fine piece of documentation available at [http://www.gebish.org/manual/current/](http://www.gebish.org/manual/current/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们简单的测试，我们只是触及了 Geb 的表面。还有很多功能可用，我鼓励您阅读《Geb 之书》，这是一份非常好的文档，可在[http://www.gebish.org/manual/current/](http://www.gebish.org/manual/current/)找到。
- en: The check point
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点
- en: 'In this chapter, we added a bunch of tests in `src/test/java`. I chose to go
    with Groovy, so I deleted the duplicated tests:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在 `src/test/java` 中添加了大量测试。我选择使用 Groovy，因此我删除了重复的测试：
- en: '![The check point](img/2117_07_04.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_07_04.jpg)'
- en: 'In the `src/test/groovy` directory, I have refactored two tests as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/test/groovy` 目录中，我已经重构了两个测试，如下所示：
- en: '![The check point](img/2117_07_05.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_07_05.jpg)'
- en: 'In `src/integrationTest/groovy`, we have an integration test written with Geb:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/integrationTest/groovy` 中，我们用 Geb 编写了一个集成测试：
- en: '![The check point](img/2117_07_06.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_07_06.jpg)'
- en: Finally, we added an `integrationTest` task to the Gradle build. Run `gradle
    clean test` and `gradle clean integrationTest` to make sure that all your tests
    pass.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 Gradle 构建中添加了一个 `integrationTest` 任务。运行 `gradle clean test` 和 `gradle
    clean integrationTest` 以确保所有测试都通过。
- en: If the build is successful, we are ready for the next chapter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，我们就准备好进入下一章了。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've studied the differences between unit and integration
    tests.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了单元测试和集成测试之间的区别。
- en: We saw how testing is a healthy habit that will give us confidence in what we
    build and what we ship. It will save us money and spare some headaches in the
    long run.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了测试是如何成为一种健康的习惯，它将给我们对我们所构建和所发布的信心。从长远来看，它将节省我们的金钱并避免一些头痛。
- en: Spring works well with classical JUnit tests written in Java, and it has first-class
    support for integration tests. But we can also easily use other languages, such
    as Groovy, to make the tests more readable and easier to write.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 与用 Java 编写的经典 JUnit 测试配合得很好，并且它对集成测试有第一级支持。但我们也容易使用其他语言，例如 Groovy，使测试更易于阅读和编写。
- en: Testing is undeniably one of the strongest points of the Spring framework and
    one of the main reasons to use dependency injection in the first place.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 测试无疑是 Spring 框架最强大的特点之一，也是最初使用依赖注入的主要原因。
- en: Stay tuned for the next chapter, where we will optimize our application so that
    it is ready to be deployed in the cloud!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请期待下一章，我们将优化我们的应用程序，使其准备好在云中部署！
