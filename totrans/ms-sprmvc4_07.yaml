- en: Chapter 7. Leaving Nothing to Luck – Unit Tests and Acceptance Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see why and how our application should be tested. We
    will see the differences between unit tests and acceptance tests, and learn how
    to do both.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is divided in two parts. In the first part, we will write tests
    in Java while studying the different ways of testing. In the second part, which
    is shorter, we will write the exact same tests in Groovy, and see how we can improve
    our code readability with this awesome language.
  prefs: []
  type: TYPE_NORMAL
- en: If you do everything in this chapter, you will have double tests, so feel free
    to keep only the tests that are most readable for you.
  prefs: []
  type: TYPE_NORMAL
- en: Why should I test my code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working in the Java world has made a lot of developers aware of the importance
    of tests. A good series of tests can catch regressions early and allows us to
    be more confident when we ship our product.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of people are now familiar with the notion of continuous integration ([http://www.thoughtworks.com/continuous-integration](http://www.thoughtworks.com/continuous-integration)).
    This is a practice where a server is in charge of building the application every
    time a change is made on the source control system.
  prefs: []
  type: TYPE_NORMAL
- en: The build should be as fast as possible and capable of self testing. The main
    idea of this practice is to get a fast feedback loop; you should get details about
    what went wrong as soon as something in the system breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Why should you care? After all, testing your application is an additional cost;
    the time spent designing and maintaining tests will necessarily eat into some
    development time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the later a bug is found, the costlier it gets. If you think about
    it, even a bug found by your QA team begins to cost more than a bug you find on
    your own. It forces you to switch back to the context you were in when writing
    the code: why did I write this line? What was the underlying business rule of
    that function?'
  prefs: []
  type: TYPE_NORMAL
- en: If you write tests early on and are able to launch them in a few seconds, it
    will certainly cost less time to address potential bugs in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of tests is that they act as a living documentation of your
    code. While writing extensive documentation, and even code comments, can prove
    ineffective because they easily become outdated, forming the habit of writing
    a good test for limit cases or surprising behaviors will act as a safety net for
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: What is this line of code for? Have you ever found yourself asking this kind
    of question? Well, if you have a good set of unit tests, you can just remove it
    and see what breaks! Tests give us an unprecedented confidence in our code and
    in our ability to refactor it. Software is very fragile. If you stop caring, it
    will slowly rot and die.
  prefs: []
  type: TYPE_NORMAL
- en: Be responsible—don't let your code die!
  prefs: []
  type: TYPE_NORMAL
- en: How should I test my code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different kinds of tests that we can perform on a piece of software,
    such as security tests, performances test, and so on. As developers, we will focus
    on the tests we can automate and that will help improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests fall under two categories: unit tests and acceptance tests. The test
    pyramid ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    shows in what proportions these tests should be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How should I test my code?](img/2117_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the pyramid, you have the unit tests (fast to launch and relatively
    easy to maintain), and at the top, UI tests (costlier and slower to execute).
    Integration tests sit in the middle: they can be viewed as big unit tests with
    complex interactions between units.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the pyramid is to remind you to put your focus where you have the
    most impact and get the best feedback loops.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many developers develop the healthy habit of **Test-driven Development** (**TTD**).
    This practice, inherited from Extreme Programming (XP), is the process of splitting
    each development stage into small steps and then writing a failing test for every
    one of them. You make the necessary modifications so that the tests pass again
    (test are green). You can then refactor your code as long as the tests remain
    green. The following figure illustrates the TDD cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test-driven development](img/2117_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can iterate until the feature is done with very short feedback loops, with
    the insurance of no regressions, and the guarantee that all the code you write
    will be tested from the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD gets its share of criticisms. The most interesting ones are these:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes more time to write the tests than to do the actual implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can lead to poorly designed applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The truth of the matter is that it takes time to become a good TDD practitioner.
    Once you get the feeling of what should be tested and know your tools well enough,
    you won't lose much time at all.
  prefs: []
  type: TYPE_NORMAL
- en: It also takes experienced developers to craft an application with a proper design
    using TDD (or with any other methodology). Poor design can be a side effect of
    TDD if you get trapped in the baby steps mantra and forget to look at the big
    picture. It is true that TDD won't magically lead to great application design,
    so be careful and remember to take a step back after completing each feature.
  prefs: []
  type: TYPE_NORMAL
- en: From the beginning of the book, we have only had one autogenerated unit test
    in our code. This is bad! We didn't follow good practice. This chapter is here
    to address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lower level tests we can write are called unit tests. They should test a
    small portion of code, hence the notion of unit. How you define a unit is up to
    you; it can be a class or a bunch of closely related classes. Defining this notion
    will determine what will be mocked (replaced with a dummy object). Are you going
    to replace the database with a lightweight alternative? Are you going to replace
    interactions with external services? Are you going to mock-up closely related
    objects whose behavior is not relevant to the context of what's being tested?
  prefs: []
  type: TYPE_NORMAL
- en: My advice here is to keep a balanced approach. Keep your tests clean and fast,
    and everything else will follow.
  prefs: []
  type: TYPE_NORMAL
- en: I rarely completely mock the data layer. I tend to use embedded databases for
    testing. They provide an easy way to load data while testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule, I always mock collaboration with external services for two reasons,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The speed of the tests and the possibility to run the tests without connecting
    to the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to test error cases while communicating with those services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there is a subtle difference between mocking and stubbing. We
    will try to use both approaches to see how they relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: The right tools for the job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first barrier for test novices is the lack of knowledge of the good tools
    and libraries for writing relevant and maintainable tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to list a few here. This list is by no means exhaustive, but it
    contains the tools we are going to use and that are easily compatible with Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JUnit | The most universally adopted Java test runner. Launched by default
    by all build tools. |'
  prefs: []
  type: TYPE_TB
- en: '| AssertJ | A fluent assertion library. It''s way easier to use than Hamcrest.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mockito | An easy mocking framework. |'
  prefs: []
  type: TYPE_TB
- en: '| DbUnit | For mocking and asserting your database content with XML datasets.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spock | An elegant Groovy DSL to write tests with Behaviour Driven Development
    (BDD) style (Given/When/Then). |'
  prefs: []
  type: TYPE_TB
- en: Groovy has a place of choice in my testing toolset. Even if you're not ready
    yet to put some Groovy code into production, you can easily use the convenience
    of the language in your tests. With Gradle, this is very easy to do, but we will
    see that in a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The acceptance tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of a web application, "acceptance test" will often refer to in-browser,
    end-to-end testing. In the Java world, Selenium is clearly one of the most reliable
    and mature libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript world, we can find other alternatives, such as PhantomJS
    or Protractor. PhantomJS is very relevant in our case because there is a web driver
    available to run Selenium tests inside of this headless browser, which will improve
    launch time and won''t require emulating an X Server or launching a separate Selenium
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Selenium 2 | This provides web drivers to pilot browsers for automated testing.
    |'
  prefs: []
  type: TYPE_TB
- en: '| PhantomJS | A headless browser (without GUI). Probably the fastest browser.
    |'
  prefs: []
  type: TYPE_TB
- en: '| FluentLenium | A fluent library for piloting Selenium tests. |'
  prefs: []
  type: TYPE_TB
- en: '| Geb | A Groovy library for piloting Selenium tests. |'
  prefs: []
  type: TYPE_TB
- en: Our first unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to write our first unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on writing tests at the controller level because we have little
    to no business code or service. The key to writing tests for Spring MVC is the
    `org.springframework.boot:spring-boot-starter-test` dependency in our classpath.
    It will add a few very useful libraries, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hamcrest`: This is JUnit''s assertion library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mockito`: This is a mocking library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test`: This is the Spring testing library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will test the redirection to the profile page that is created when the user
    hasn't created their profile yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have an autogenerated test called `MasterSpringMvc4ApplicationTests`.
    It is the most basic kind of test one can write with the Spring test framework:
    it does nothing but blow up if the context cannot be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can delete this test and create one that will ensure that a user with no
    profile will be redirected to the profile page by default. It will actually test
    the code of the `HomeController` class, so let's call it `HomeControllerTest`
    class and put it in the same package as `HomeController`, in `src/test/java`.
    All IDEs have shortcuts for creating a JUnit test case from a class. Find out
    how to do it with yours now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use `MockMvc` to simulate interactions with a Spring controller without the
    actual overhead of a Servlet container.
  prefs: []
  type: TYPE_NORMAL
- en: We also use a couple of matchers that Spring provides to assert our result.
    They actually implement Hamcrest matchers.
  prefs: []
  type: TYPE_NORMAL
- en: The `.andDo(print())` statement will produce a neat debug output for the request
    and response of the scenario under test. You can comment it if you find it too
    verbose.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it! The syntax is a bit tricky at the beginning, but
    an IDE with good completion will be able to help you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to test whether, if the user has filled in the test part of their
    profile, we can redirect them to the correct search. For that, we will need to
    stub the session with the `MockHttpSession` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will have to add the `setTastes()` setter to the `UserProfileSession` bean
    for the test to work.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of mocking utilities for the Servlet environment in the `org.springframework.mock.web`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the attribute representing our bean in session is prefixed by `scopedTarget`.
    That's because session beans are proxified by Spring. Therefore, there are actually
    two objects in the Spring context, the actual bean that we defined and its proxy
    that will end up in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mock session is a neat class, but we can refactor the test with a builder
    that will hide implementation details and can be reused later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the builder is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After this refactoring, your test should always pass, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks and stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we wanted to test the search request handled by the `SearchController` class,
    we would certainly want to mock `SearchService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of doing this: with a mock or with a stub.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking with Mockito
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we can create a mock object with Mockito:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see that instead of setting up `MockMvc` with the web application context,
    we have created a standalone context. This context will only contain our controller.
    That means we have full control over the instantiation and initialization of controllers
    and their dependencies. It will allow us to easily inject a mock inside of our
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that we have to redeclare pieces of our configuration like the
    one saying we don't want to remove URL characters after a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: We use a couple of Hamcrest matchers to assert the properties that will end
    up in the view model.
  prefs: []
  type: TYPE_NORMAL
- en: The mocking approach has its benefits, such as the ability to verify interactions
    with the mock and create expectations at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This will also couple your test with the actual implementation of the object.
    For instance, if you changed how a tweet is fetched in the controller, you would
    likely break the tests related to this controller because they still try to mock
    the service we no longer rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing our beans while testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach is to replace the implementation of our `SearchService` class
    with another one in our test.
  prefs: []
  type: TYPE_NORMAL
- en: We were a bit lazy early on and did not define an interface for `SearchService`.
    *Always program to an interface and not to an implementation*. Behind this proverbial
    wisdom lies the most important lesson from the *Gang of Four*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the benefits of the Inversion of Control is to allow for the easy replacement
    of our implementations in tests or in a real system. For this to work, we will
    have to modify all the usages `SearchService` with the new interface. With a good
    IDE, there is a refactoring called `extract interface` that will do just that.
    This should create an interface that contains the public method `search()` of
    our `SearchService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, our two controllers, `SearchController` and `SearchApiController`,
    must now use the interface and not the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the ability to create a test double for the `TwitterSearch` class
    specially for our test case. For this to work, we will need to declare a new Spring
    configuration named `StubTwitterSearchConfig` that will contain another implementation
    for `TwitterSearch`. I placed it in the search package, next to `SearchControllerMockTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration class, we redeclare the `TwitterSearch` bean with the
    `@Primary` annotation, which will tell Spring to use this implementation on priority
    if other implementations are found in the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `TwitterSearch` interface contains only one method, we can implement
    it with a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete test that uses our `StubConfiguration` class along with
    our main configuration with the `SpringApplicationConfiguration` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Should I use mocks or stubs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both approaches have their own merits. For a detailed explanation, check out
    this great essay by Martin Fowler: [http://martinfowler.com/articles/mocksArentStubs.html](http://martinfowler.com/articles/mocksArentStubs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: My testing routine is more about writing stubs because I like the idea of testing
    the output of my objects more than their inner workings. But that's up to you.
    Spring being a dependency injection framework at its core means that you can easily
    choose what your favorite approach is.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing REST controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just tested a traditional controller redirecting to a view. Testing
    a REST controller is very similar in principle, but there are a few subtleties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to test the JSON output of our controller, we need a JSON
    assertion library. Add the following dependency to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a test for the `SearchApiController` class, the controller that
    allows searching for a tweet and returns results as JSON or XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note the simple and elegant assertions on the JSON output. Testing our user
    controller will require a bit more work.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add `assertj` to the classpath; it will help us write cleaner
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to simplify testing, add a `reset()` method to our `UserRepository` class
    that will help us with the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In real life, we should probably extract an interface and create a stub for
    testing. I will leave that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first test that gets the list of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, add a constructor to the `User` class, taking the e-mail
    property as a parameter. Be careful: you also need to have a default constructor
    for Jackson.'
  prefs: []
  type: TYPE_NORMAL
- en: The test is very similar to the previous test with the additional setup of `UserRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the `POST` method that creates a user now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to be noted. The first one is the use of AssertJ to assert
    the content of the repository after the test. You will need the following static
    import for that to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is that we use a utility method to convert our object to JSON before
    sending it to the controller. For that purpose, I created a simple utility class
    in the `utils` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests for the `DELETE` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s the test for the `PUT` method, which updates a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoops! The last test does not pass! By checking the implementation of `UserApiController`,
    we can easily see why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We returned the wrong status in the controller! Change it to `HttpStatus.OK`
    and the test should be green again.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring, one can easily write controller tests using the same configuration
    of our application, but we can just as efficiently override or change some elements
    in our testing setup.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing that you will notice while running all the tests is
    that the application context is only loaded once, which means that the overhead
    is actually very small.
  prefs: []
  type: TYPE_NORMAL
- en: Our application is small too, so we did not make any effort to split our configuration
    into reusable chunks. It can be a really good practice not to load the full application
    context inside of every test. You can actually split the component scanned into
    different units with the `@ComponentScan` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: This annotation has several attributes that allow you to define filters with
    `includeFilter` and `excludeFilter` (loading only the controller for instance)
    and scan specific packages with the `basePackageClasses` and `basePackages` annotations.
  prefs: []
  type: TYPE_NORMAL
- en: You can also split your configuration into multiple `@Configuration` classes.
    A good example would be splitting the code for the users and for the tweet parts
    of our application into two independent parts.
  prefs: []
  type: TYPE_NORMAL
- en: We will now have a look at acceptance tests, which are a very different kind
    of beast.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to set up Spring Security in a MockMvc test, you can write this
    test next to our previous test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added `SpringSecurityFilter` to our configuration.
    This will activate Spring Security checks. To test if the authentication works,
    we simply send the correct headers along with the request we would like to perform.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of basic authentication is that it's really straightforward to
    simulate. With a more complicated setup, you would have to perform a mock request
    on the authentication endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Spring Boot is at version 1.2.3 and depends on Spring
    Security 3.
  prefs: []
  type: TYPE_NORMAL
- en: In a few weeks, Spring Boot 1.3.0 will be available, it will update Spring Security
    and use version 4.
  prefs: []
  type: TYPE_NORMAL
- en: This is good news because Spring Security 4 includes a really easy setup of
    the authenticated user with simple annotations. See [http://docs.spring.io/spring-security/site/docs/4.0.x/reference/htmlsingle/#test](http://docs.spring.io/spring-security/site/docs/4.0.x/reference/htmlsingle/#test)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Writing acceptance tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests can only cover a subset of the different interactions between the
    components of our application. To go a little further, we will need to set up
    acceptance tests, tests that will actually boot up the complete application and
    allow us to interact with its interface.
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we will want to do when we add integration tests to a project
    is to put them in a different location to that of the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is, essentially, that acceptance tests are slower than
    unit tests. They can be part of a different integration job, such as a nightly
    build, and we want developers to be able to launch the different kinds of tests
    easily from their IDE. To do this with Gradle, we will have to add a new configuration
    called `integrationTest`. For Gradle, a configuration is a group of artifacts
    and their dependencies. We already have several configurations in our project:
    `compile`, `testCompile`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: You can have a look at the configurations of your project, and much more, by
    typing `./gradlew properties` at the root of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new configuration at the end of `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to declare dependencies for `integrationTestCompile` and
    `integrationTestRuntime`. More importantly, by inheriting the test configurations,
    we have access to their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I do not recommend declaring your integration test dependencies as `integrationTestCompile`.
    It will work as far as Gradle is concerned, but support inside of IDE is non-existent.
    What I usually do is declare my integration test dependencies as `testCompile`
    dependencies instead. This is only a small inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our new configurations, we must create a `sourceSet` class
    associated with them. A `sourceSet` class represents a logical group of Java source
    and resources. Naturally, they also have to inherit from the test and main classes;
    see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a task to run them from our build, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To run our test, we can type `./gradlew integrationTest`. Besides configuring
    our classpath and where to find our test classes, we also defined a directory
    where the test report will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration allows us to write our tests in `src/integrationTest/java`
    or `src/integrationTest/groovy`, which will make it easier to identify them and
    run them separately from our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: By default, they will be generated in `build/reports/tests`. If we do not override
    them, if we launch both tests and integration tests with `gradle clean test integrationTest`,
    they will override each other.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth mentioning that a young plugin in the Gradle ecosystem aims
    to simplify declaring new test configurations, visit [https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets](https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets)
    for detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: Our first FluentLenium test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FluentLenium is an amazing library for piloting Selenium tests. Let''s add
    a few dependencies to our build script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By default, `fluentlenium` comes with `selenium-java`. We redeclare it just
    to explicitly require the latest version available. We also added a dependency
    to the `PhantomJS` driver, which is not officially supported by Selenium. The
    problem with the `selenium-java` library is that it comes bundled with all the
    supported web drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the dependency tree of our project by typing `gradle dependencies`.
    At the bottom, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Having all those dependencies in the classpath is highly unnecessary since
    we will just use the `PhantomJS` driver. To exclude the dependencies we won''t
    need, we can add the following part to our buildscript, right before the dependencies
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We just keep the `firefox` driver at hand. `PhantomJS` driver is a headless
    browser, so understanding what happens without a GUI can prove tricky. It can
    be nice to switch to Firefox to debug a complex test.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our classpath correctly configured, we can now write our first integration
    test. Spring Boot has a very convenient annotation to support this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that FluentLenium has a neat API for requesting DOM elements. With AssertJ,
    we can then write easy-to read-assertions on the page content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have a look at the documentation at [https://github.com/FluentLenium/FluentLenium](https://github.com/FluentLenium/FluentLenium)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: With the `@WebIntegrationTest` annotation, Spring will actually create the embedded
    Servlet container (Tomcat) and launch our web application on a random port! We
    need to retrieve this port number at runtime. This will allow us to provide a
    base URL for our tests, a URL that will be the prefix for all the navigation we
    do in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to run the test at this stage, you will see the following error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, PhantomJS needs to be installed on your machine for this to work correctly.
    On a Mac, simply use `brew install phantomjs`. For other platforms, see the documentation
    at [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to install a new binary on your machine, replace `new PhantomJSDriver()`
    with `new FirefoxDriver()`. Your test will be a bit slower, but you will have
    a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Our first test is landing on the profile page, right? We need to find a way
    to log in now.
  prefs: []
  type: TYPE_NORMAL
- en: What about faking login with a stub?
  prefs: []
  type: TYPE_NORMAL
- en: 'Put this class in the test sources (`src/test/java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will authenticate any user clicking on the Twitter sign in button as geowarin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a second test that will fill the profile form and assert that
    the search result is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can easily ask our web driver to take a screenshot of the current
    browser used for testing. This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first FluentLenium test](img/2117_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Page Objects with FluentLenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous test was a bit messy. We have hardcoded all the selectors in our
    test. This can become very risky when we write a lot of tests using the same elements
    because whenever we change the page layout, all the tests will break. Moreover,
    the test is a little difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, a common practice is to use a page object that will represent a
    specific web page in our application. With FluentLenium, page objects must inherit
    the `FluentPage` class.
  prefs: []
  type: TYPE_NORMAL
- en: We will create three pages, one for each element of our GUI. The first one will
    be the login page with the option to click on the `twitterSignin` button, the
    second one will be the profile page with convenience methods for filling in the
    profile form, and the last one will be the result page on which we can assert
    the results displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the login page at once. I put all the three pages in a `pages`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create one page for our profile page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create another one for the search result page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now refactor the test using those Page Objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Much more readable, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Making our tests more Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't know Groovy, consider it like a close cousin of Java, without the
    verbosity. Groovy is a dynamic language with optional typing. This means that
    you can have the guarantees of a type system when it matters and the versatility
    of duck typing when you know what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: With this language, you can write POJOs without getters, setters, `equals` and
    `hashcode` methods. Everything is handled for you.
  prefs: []
  type: TYPE_NORMAL
- en: Writing `==` will actually call the `equals` method. The operators can be overloaded,
    which allows a neat syntax with little arrows, such as `<<`, to write text to
    a file, for instance. It also means that you can add integers to `BigIntegers`
    and get a correct result.
  prefs: []
  type: TYPE_NORMAL
- en: The **Groovy Development Kit** (**GDK**) also adds several very interesting
    methods to classic Java objects. It also considers regular expressions and closures
    as first-class citizens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want a solid introduction to Groovy, check out the Groovy style guide
    at [http://www.groovy-lang.org/style-guide.html](http://www.groovy-lang.org/style-guide.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can also watch this amazing presentation by Peter Ledbrook at [http://www.infoq.com/presentations/groovy-for-java](http://www.infoq.com/presentations/groovy-for-java).
  prefs: []
  type: TYPE_NORMAL
- en: As far as I am concerned, I always try to push Groovy on the testing side of
    the application I work on. It really improves the readability of the code and
    the productivity of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests with Spock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to write Groovy tests in our project, we need to use the Groovy plugin
    instead of the Java plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you have in your build script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This modification is perfectly harmless. The Groovy plugin extends the Java
    plugin, so the only difference it makes is that it gives the ability to add Groovy
    source in `src/main/groovy`, `src/test/groovy` and `src/integrationTest/groovy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we also need to add Groovy to the classpath. We will also add Spock,
    the most popular Groovy testing library, via the `spock-spring` dependency, which
    will enable compatibility with Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now rewrite `HomeControllerTest` with a different approach. Let''s create
    a `HomeControllerSpec` class in `src/test/groovy`. I added it to the `masterSpringMvc.controller`
    package just like our first instance of `HomeControllerTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our test instantaneously became more readable with the ability to use strings
    as method names and the little BDD DSL (Domain Specific Language) provided by
    Spock. This is not directly visible here, but every statement inside of a `then`
    block will implicitly be an assertion.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, because Spock doesn't read meta annotations, the `@SpringApplicationConfiguration`
    annotation cannot be used so we just replaced it with `@ContextConfiguration(loader
    = SpringApplicationContextLoader)`, which is essentially the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: We now have two versions of the same test, one in Java and the other in Groovy.
    It is up to you to choose the one that best fits your style of coding and remove
    the other one. If you decide to stick with Groovy, you will have to rewrite the
    `should_redirect_to_tastes()` test in Groovy. It should be easy enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spock also has powerful support for mocks. We can rewrite the previous `SearchControllerMockTest`
    class a bit differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All the verbosity of Mockito is now gone. The `then` block actually asserts
    that the `twitterSearch` method is called once (`1 *`) with any parameter (`_,
    _`). Like with mockito, we could have expected specific parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The double arrow `>>` syntax is used to return an object from the mocked method.
    In our case, it's a list containing only one element.
  prefs: []
  type: TYPE_NORMAL
- en: With only a little dependency in our classpath, we have already written more
    readable tests, but we're not done yet. We will also refactor our acceptance tests
    to use Geb, a Groovy library that pilots Selenium tests.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests with Geb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Geb is the de facto library for writing tests in the Grails framework. Although
    its version is 0.12.0, it is very stable and extremely comfortable to work with.
  prefs: []
  type: TYPE_NORMAL
- en: It provides a selector API à la jQuery, which makes tests easy to write, even
    for frontend developers. Groovy is also a language that has some JavaScript influences
    that will also appeal to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add Geb with the support for Spock specifications to our classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Geb can be configured via a Groovy script found directly at the root of `src/integrationTest/groovy`,
    called `GebConfig.groovy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, we indicate where Geb will generate its reports and which
    driver to use. Reports in Geb are an enhanced version of screenshots, which also
    contains the current page in HTML. Their generation can be triggered at any moment
    by calling the `report` function inside a Geb test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite out first integration test with Geb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For the moment, it is very similar to FluentLenium. We can already see the `$`
    function, which will allow us to grab a DOM element via its selector. Here, we
    also state that we want the first `h2` in the page by giving the `0` index.
  prefs: []
  type: TYPE_NORMAL
- en: Page Objects with Geb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Page objects with Geb are a real pleasure to work with. We will create the same
    page objects that we did previously so that you can appreciate the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Geb, the Page Objects must inherit from the `geb.Page` class. First, let''s
    create the `LoginPage`. I suggest avoiding putting it in the same package as the
    previous one. I created a package called `geb.pages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create the `ProfilePage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the same page as before. Note the little `<<` to assign values
    to an input element. You could also call `setText` on them.
  prefs: []
  type: TYPE_NORMAL
- en: The `at` method is completely part of the framework, and Geb will automatically
    assert those when you navigate to the corresponding page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `SearchResultPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It's a bit shorter, thanks to the ability to reuse previously defined content
    for the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'With out the Page Object set up, we can write the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: My, what a beauty! You can certainly write your user stories directly with Geb!
  prefs: []
  type: TYPE_NORMAL
- en: With our simple tests, we only scratched the surface of Geb. There is much more
    functionality available, and I encourage you to read the *Book of Geb*, a very
    fine piece of documentation available at [http://www.gebish.org/manual/current/](http://www.gebish.org/manual/current/).
  prefs: []
  type: TYPE_NORMAL
- en: The check point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we added a bunch of tests in `src/test/java`. I chose to go
    with Groovy, so I deleted the duplicated tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `src/test/groovy` directory, I have refactored two tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In `src/integrationTest/groovy`, we have an integration test written with Geb:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we added an `integrationTest` task to the Gradle build. Run `gradle
    clean test` and `gradle clean integrationTest` to make sure that all your tests
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: If the build is successful, we are ready for the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've studied the differences between unit and integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how testing is a healthy habit that will give us confidence in what we
    build and what we ship. It will save us money and spare some headaches in the
    long run.
  prefs: []
  type: TYPE_NORMAL
- en: Spring works well with classical JUnit tests written in Java, and it has first-class
    support for integration tests. But we can also easily use other languages, such
    as Groovy, to make the tests more readable and easier to write.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is undeniably one of the strongest points of the Spring framework and
    one of the main reasons to use dependency injection in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Stay tuned for the next chapter, where we will optimize our application so that
    it is ready to be deployed in the cloud!
  prefs: []
  type: TYPE_NORMAL
