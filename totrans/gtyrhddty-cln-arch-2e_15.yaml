- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deciding on an Architecture Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this book has provided an opinionated approach to building a web application
    in a Hexagonal Architecture style. From organizing code to taking shortcuts, we
    have answered many questions that this architecture style confronts us with.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the answers in this book can be applied to the conventional layered
    architecture style. Some answers can only be implemented in a domain-centric approach,
    such as the one proposed in this book. And some answers you might not even agree
    with because they haven’t worked in your experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final questions we want answers for, however, are these: when should we
    actually use the Hexagonal Architecture style? And when should we rather stick
    with the conventional layered style (or any other style for that matter)?'
  prefs: []
  type: TYPE_NORMAL
- en: Start simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important point that took me far too long to realize is that software architecture
    isn’t just something we define at the beginning of a software project that will
    take care of itself after. We can’t know everything we need to know to design
    a great architecture at the beginning of a project! The architecture of a software
    project can and should evolve over time to adapt to changing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we won’t know which architecture style will be the best for
    the software project in the long run, and we might need to change the architecture
    style in the future! To make this possible, we need to make certain that our software
    is supple to change. We need to plant a seed of maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability** means that we need to make our code modular so that we
    can work on each module in isolation and move it around in the code base, should
    the need arise. Our architecture needs to make the boundaries between those modules
    as clear as possible so that unwanted dependencies between those modules don’t
    accidentally creep in, reducing maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: The start of a project might only involve a collection of *CRUD* use cases,
    and a domain-centric architecture such as Hexagonal Architecture might be overkill,
    so we opt for something simpler such as the component-based approach. Or we might
    know enough about the project already that we start building out a rich domain
    model, in which case the Hexagonal Architecture style might be the right one to
    start with.
  prefs: []
  type: TYPE_NORMAL
- en: Evolve the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, we learn more and more about the requirements of our software, and
    we can make better and better decisions about the best architecture style. The
    application might evolve from a collection of simple CRUD use cases to a rich
    domain-centric application with a lot of business rules. At this point, the Hexagonal
    Architecture style becomes a good option.
  prefs: []
  type: TYPE_NORMAL
- en: It should have become clear in the previous chapters that the main feature of
    a Hexagonal Architecture style is that we can develop domain code free from diversions,
    such as persistence concerns and dependencies on external systems. In my opinion,
    evolving domain code free from external influence is the single most important
    argument for the Hexagonal Architecture style.
  prefs: []
  type: TYPE_NORMAL
- en: This is why this architecture style is such a good match for DDD practices.
    To state the obvious, in DDD, the domain drives the development, and we can best
    reason about the domain if we don’t have to think about persistence concerns and
    other technical aspects simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: I would even go so far as to say that *domain-centric architecture styles such
    as the hexagonal style are enablers of DDD*. Without an architecture that puts
    the domain at the center of things, and without inverting dependencies toward
    domain code, we have no chance of really doing DDD. The design will always be
    driven by other factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a first indicator of whether to use the architecture style presented
    in this book or not: *if the domain code is not the most important thing in your
    application, you probably don’t need this* *architecture style*.'
  prefs: []
  type: TYPE_NORMAL
- en: Trust your experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re creatures of habit. Habits automate decisions for us, so we don’t have
    to spend time on them. If there’s a lion running toward us, we run. If we build
    a new web application, we use the layered architecture style. We have done it
    so often in the past that it has become a habit.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not saying that habitual decisions are necessarily bad decisions. Habits
    are just as good at helping to make a good decision as they are at helping to
    make a bad one. I’m saying that we’re doing what we’re experienced in. We’re comfortable
    with what we’ve done in the past, so why should we change anything?
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the only way to make an educated decision about an architecture style
    is by having experience in different architecture styles. If you’re unsure about
    the Hexagonal Architecture style, try it out on a small module of the application
    that you’re currently building. Get used to the concepts. Get comfortable. Apply
    the ideas in this book, modify them, and add your own ideas to develop a style
    that you’re comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: This experience can then guide your next architecture decision.
  prefs: []
  type: TYPE_NORMAL
- en: It depends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I would love to provide a list of multiple-choice questions to decide on an
    architecture style, just like all those “*Which personality type are you?*” and
    “*If you were a dog, what kind of dog would you be?*” tests that regularly swirl
    around on social media.[1](#footnote-048)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-048-backlink) In case you wanted to know, I’m the “Defender”
    personality type, and if I were a dog, I would apparently be a pitbull.'
  prefs: []
  type: TYPE_NORMAL
- en: However, it isn’t as easy as that. My answer to the question of which architecture
    style to choose remains the professional consultant’s – “*It depends.*” It depends
    on the type of software to be built. It depends on the role of the domain code.
    It depends on the experience of the team. And finally, it depends on being comfortable
    with a decision.
  prefs: []
  type: TYPE_NORMAL
- en: I hope, however, that this book has provided some sparks of inspiration to help
    with the question of architecture. If you have a story to tell about architecture
    decisions, with or without Hexagonal Architecture, I’d love to hear about it.[2](#footnote-047)
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-047-backlink) Contact: you can drop me an email at [tom@reflectoring.io](B19916_15.xhtml).'
  prefs: []
  type: TYPE_NORMAL
