["```java\nimport akka.actor._ \nimport akka.event.Logging \nclass HelloActor(val hello: String) extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case `hello` => \n      log.info(s\"Received a '$hello'... $hello!\") \n    case msg     => \n      log.info(s\"Unexpected message '$msg'\") \n      context.stop(self) \n  } \n} \n\n```", "```java\nobject HelloActor { \n  def props(hello: String) = Props(new HelloActor(hello)) \n  def propsAlt(hello: String) = Props(classOf[HelloActor], hello) \n} \n\n```", "```java\nclass HelloActorUtils { \n  val defaultHi = \"Aloha!\" \n  def defaultProps() = Props(new HelloActor(defaultHi)) \n} \n\n```", "```java\nlazy val ourSystem = ActorSystem(\"OurExampleSystem\") \n\n```", "```java\nobject ActorsCreate extends App { \n  val hiActor: ActorRef = \n    ourSystem.actorOf(HelloActor.props(\"hi\"), name = \"greeter\") \n  hiActor ! \"hi\" \n  Thread.sleep(1000) \n  hiActor ! \"hola\" \n  Thread.sleep(1000) \n  ourSystem.shutdown() \n} \n\n```", "```java\nclass DeafActor extends Actor { \n  val log = Logging(context.system, this) \n  def receive = PartialFunction.empty \n  override def unhandled(msg: Any) = msg match { \n    case msg: String => log.info(s\"I do not hear '$msg'\") \n    case msg         => super.unhandled(msg) \n  } \n} \n\n```", "```java\nobject ActorsUnhandled extends App { \n  val deafActor: ActorRef = \n    ourSystem.actorOf(Props[DeafActor], name = \"deafy\") \n  deafActor ! \"hi\" \n  Thread.sleep(1000) \n  deafActor ! 1234 \n  Thread.sleep(1000) \n  ourSystem.shutdown() \n} \n\n```", "```java\ndef receive = { \n  case msg: String => log.info(s\"I do not hear '$msg'\") \n} \n\n```", "```java\nclass CountdownActor extends Actor { \n  var n = 10 \n  def receive = if (n > 0) { // never do this \n    case \"count\" => \n      log(s\"n = $n\") \n      n -= 1 \n  } else PartialFunction.empty \n} \n\n```", "```java\nclass CountdownActor extends Actor { \n  val log = Logging(context.system, this) \n  var n = 10 \n  def counting: Actor.Receive = { \n    case \"count\" => \n      n -= 1 \n      log.info(s\"n = $n\") \n      if (n == 0) context.become(done) \n  } \n  def done = PartialFunction.empty \n  def receive = counting \n} \n\n```", "```java\nobject ActorsCountdown extends App { \n  val countdown = ourSystem.actorOf(Props[CountdownActor]) \n  for (i <- 0 until 20) countdown ! \"count\" \n  Thread.sleep(1000) \n  ourSystem.shutdown() \n} \n\n```", "```java\nobject DictionaryActor { \n  case class Init(path: String) \n  case class IsWord(w: String) \n  case object End \n} \n\n```", "```java\nclass DictionaryActor extends Actor { \n  private val log = Logging(context.system, this) \n  private val dictionary = mutable.Set[String]() \n  def receive = uninitialized \n  def uninitialized: PartialFunction[Any, Unit] = { \n    case DictionaryActor.Init(path) => \n      val stream = getClass.getResourceAsStream(path) \n      val words = Source.fromInputStream(stream) \n      for (w <- words.getLines) dictionary += w \n      context.become(initialized) \n  } \n  def initialized: PartialFunction[Any, Unit] = { \n    case DictionaryActor.IsWord(w) => \n      log.info(s\"word '$w' exists: ${dictionary(w)}\") \n    case DictionaryActor.End => \n      dictionary.clear() \n      context.become(uninitialized) \n  } \n  override def unhandled(msg: Any) = { \n    log.info(s\"cannot handle message $msg in this state.\") \n  } \n} \n\n```", "```java\nval dict = ourSystem.actorOf(Props[DictionaryActor], \"dictionary\") \n\ndict ! DictionaryActor.IsWord(\"program\") \nThread.sleep(1000) \n\ndict ! DictionaryActor.Init(\"/org/learningconcurrency/words.txt\") \nThread.sleep(1000) \n\n```", "```java\ndict ! DictionaryActor.IsWord(\"program\") \nThread.sleep(1000) \n\ndict ! DictionaryActor.IsWord(\"balaban\") \nThread.sleep(1000) \n\ndict ! DictionaryActor.End \nThread.sleep(1000) \n\nourSystem.shutdown() \n\n```", "```java\nclass ChildActor extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case \"sayhi\" => \n      val parent = context.parent \n      log.info(s\"my parent $parent made me say hi!\") \n  } \n  override def postStop() { \n    log.info(\"child stopped!\") \n  } \n} \n\n```", "```java\nclass ParentActor extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case \"create\" => \n      context.actorOf(Props[ChildActor]) \n      log.info(s\"created a kid; children = ${context.children}\") \n    case \"sayhi\" => \n      log.info(\"Kids, say hi!\") \n      for (c <- context.children) c ! \"sayhi\" \n    case \"stop\" => \n      log.info(\"parent stopping\") \n      context.stop(self) \n  } \n} \n\n```", "```java\nobject ActorsHierarchy extends App { \n  val parent = ourSystem.actorOf(Props[ParentActor], \"parent\") \n  parent ! \"create\" \n  parent ! \"create\" \n  Thread.sleep(1000) \n  parent ! \"sayhi\" \n  Thread.sleep(1000) \n  parent ! \"stop\" \n  Thread.sleep(1000) \n  ourSystem.shutdown() \n} \n\n```", "```java\nclass CheckActor extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case path: String => \n      log.info(s\"checking path $path\") \n      context.actorSelection(path) ! Identify(path) \n    case ActorIdentity(path, Some(ref)) => \n      log.info(s\"found actor $ref at $path\") \n    case ActorIdentity(path, None) => \n      log.info(s\"could not find an actor at $path\") \n  } \n} \n\n```", "```java\nval checker = ourSystem.actorOf(Props[CheckActor], \"checker\") \nchecker ! \"../*\" \n\n```", "```java\nchecker ! \"../../*\" \n\n```", "```java\nchecker ! \"/system/*\" \n\n```", "```java\nchecker ! \"/user/checker2\" \n\n```", "```java\nclass StringPrinter extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case msg => log.info(s\"printer got message '$msg'\") \n  } \n  override def preStart(): Unit = log.info(s\"printer preStart.\") \n  override def postStop(): Unit = log.info(s\"printer postStop.\") \n} \n\n```", "```java\nclass LifecycleActor extends Actor { \n  val log = Logging(context.system, this) \n  var child: ActorRef = _ \n  def receive = { \n    case num: Double  => log.info(s\"got a double - $num\") \n    case num: Int     => log.info(s\"got an integer - $num\") \n    case lst: List[_] => log.info(s\"list - ${lst.head}, ...\") \n    case txt: String  => child ! txt \n  } \n} \n\n```", "```java\noverride def preStart(): Unit = { \n  log.info(\"about to start\") \n  child = context.actorOf(Props[StringPrinter], \"kiddo\") \n} \n\n```", "```java\noverride def preRestart(t: Throwable, msg: Option[Any]): Unit = { \n  log.info(s\"about to restart because of $t, during message $msg\") \n  super.preRestart(t, msg) \n} \noverride def postRestart(t: Throwable): Unit = { \n  log.info(s\"just restarted due to $t\") \n  super.postRestart(t) \n} \n\n```", "```java\noverride def postStop() = log.info(\"just stopped\") \n\n```", "```java\nval testy = ourSystem.actorOf(Props[LifecycleActor], \"testy\") \ntesty ! math.Pi \n\n```", "```java\ntesty ! \"hi there!\" \n\n```", "```java\ntesty ! Nil \n\n```", "```java\nimport akka.pattern._ \n\n```", "```java\nclass Pongy extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case \"ping\" => \n      log.info(\"Got a ping -- ponging back!\") \n      sender ! \"pong\" \n      context.stop(self) \n  } \n  override def postStop() = log.info(\"pongy going down\") \n} \n\n```", "```java\nimport akka.util.Timeout \nimport scala.concurrent.duration._ \nclass Pingy extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case pongyRef: ActorRef => \n      implicit val timeout = Timeout(2 seconds) \n      val f = pongyRef ? \"ping\" \n      f pipeTo sender \n  } \n} \n\n```", "```java\nclass Pingy extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case pongyRef: ActorRef => \n      implicit val timeout = Timeout(2 seconds) \n      val f = pongyRef ? \"ping\" \n      f onComplete { case v => log.info(s\"Response: $v\") } // bad! \n  } \n} \n\n```", "```java\nclass Master extends Actor { \n  val pingy = ourSystem.actorOf(Props[Pingy], \"pingy\") \n  val pongy = ourSystem.actorOf(Props[Pongy], \"pongy\") \n  def receive = { \n    case \"start\" => \n      pingy ! pongy \n    case \"pong\" => \n      context.stop(self) \n  } \n  override def postStop() = log.info(\"master going down\") \n} \nval masta = ourSystem.actorOf(Props[Master], \"masta\") \nmasta ! \"start\" \n\n```", "```java\nclass Router extends Actor { \n  var i = 0 \n  val children = for (_ <- 0 until 4) yield \n    context.actorOf(Props[StringPrinter]) \n  def receive = { \n    case msg => \n      children(i) forward msg \n      i = (i + 1) % 4 \n  } \n} \n\n```", "```java\nval router = ourSystem.actorOf(Props[Router], \"router\") \nrouter ! \"Hola\" \nrouter ! \"Hey!\" \n\n```", "```java\nclass GracefulPingy extends Actor { \n  val pongy = context.actorOf(Props[Pongy], \"pongy\") \n  context.watch(pongy) \n  def receive = { \n    case \"Die, Pingy!\" => \n      context.stop(pongy) \n    case Terminated(`pongy`) => \n      context.stop(self) \n  } \n} \n\n```", "```java\nobject CommunicatingGracefulStop extends App { \n  val grace = ourSystem.actorOf(Props[GracefulPingy], \"grace\") \n  val stopped = \n    gracefulStop(grace, 3.seconds, \"Die, Pingy!\") \n  stopped onComplete { \n    case Success(x) => \n      log(\"graceful shutdown successful\") \n      ourSystem.shutdown() \n    case Failure(t) => \n      log(\"grace not stopped!\") \n      ourSystem.shutdown() \n  } \n} \n\n```", "```java\nclass Naughty extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case s: String => log.info(s) \n    case msg => throw new RuntimeException \n  } \n  override def postRestart(t: Throwable) = \n    log.info(\"naughty restarted\") \n} \n\n```", "```java\nclass Supervisor extends Actor { \n  val child = context.actorOf(Props[StringPrinter], \"naughty\") \n  def receive = PartialFunction.empty \n  override val supervisorStrategy = \n    OneForOneStrategy() { \n      case ake: ActorKilledException => Restart \n      case _ => Escalate \n    } \n} \n\n```", "```java\nourSystem.actorOf(Props[Supervisor], \"super\") \nourSystem.actorSelection(\"/user/super/*\") ! Kill \nourSystem.actorSelection(\"/user/super/*\") ! \"sorry about that\" \nourSystem.actorSelection(\"/user/super/*\") ! \"kaboom\".toList \n\n```", "```java\nobject DownloadManager { \n  case class Download(url: String, dest: String) \n  case class Finished(dest: String) \n} \n\n```", "```java\nclass Downloader extends Actor { \n  def receive = { \n    case DownloadManager.Download(url, dest) => \n      val content = Source.fromURL(url) \n      FileUtils.write(new java.io.File(dest), content.mkString) \n      sender ! DownloadManager.Finished(dest) \n  } \n} \n\n```", "```java\nclass DownloadManager(val downloadSlots: Int) extends Actor { \n  import DownloadManager._ \n  val log = Logging(context.system, this) \n  val downloaders = mutable.Queue[ActorRef]() \n  val pendingWork = mutable.Queue[Download]() \n  val workItems = mutable.Map[ActorRef, Download]() \n  private def checkDownloads(): Unit = { \n    if (pendingWork.nonEmpty && downloaders.nonEmpty) { \n      val dl = downloaders.dequeue() \n      val item = pendingWork.dequeue() \n      log.info( \n        s\"$item starts, ${downloaders.size} download slots left\") \n      dl ! item \n      workItems(dl) = item \n    } \n  } \n  def receive = { \n    case msg @ DownloadManager.Download(url, dest) => \n      pendingWork.enqueue(msg) \n      checkDownloads() \n    case DownloadManager.Finished(dest) => \n      workItems.remove(sender) \n      downloaders.enqueue(sender) \n      log.info( \n        s\"'$dest' done, ${downloaders.size} download slots left\") \n      checkDownloads() \n  } \n} \n\n```", "```java\noverride def preStart(): Unit = { \n  for (i <- 0 until downloadSlots) { \n    val dl = context.actorOf(Props[Downloader], s\"dl$i\") \n    downloaders.enqueue() \n  } \n} \n\n```", "```java\noverride val supervisorStrategy = \n  OneForOneStrategy( \n    maxNrOfRetries = 20, withinTimeRange = 2 seconds \n  ) { \n    case fnf: java.io.FileNotFoundException => \n      log.info(s\"Resource could not be found: $fnf\") \n      workItems.remove(sender) \n      downloaders.enqueue(sender) \n      Resume // ignores the exception and resumes the actor \n    case _ => \n      Escalate \n  } \n\n```", "```java\n  val downloadManager = \n    ourSystem.actorOf(Props(classOf[DownloadManager], 4), \"man\") \n  downloadManager ! Download( \n    \"http://www.w3.org/Addressing/URL/url-spec.txt\", \n    \"url-spec.txt\")   \n\n```", "```java\ndownloadManager ! Download( \n  \"https://github.com/scala/scala/blob/master/README.md\", \n  \"README.md\") \n\n```", "```java\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-remote\" % \"2.3.2\" \n\n```", "```java\nimport com.typesafe.config._ \ndef remotingConfig(port: Int) = ConfigFactory.parseString(s\"\"\" \nakka { \n  actor.provider = \"akka.remote.RemoteActorRefProvider\" \n  remote { \n    enabled-transports = [\"akka.remote.netty.tcp\"] \n    netty.tcp { \n      hostname = \"127.0.0.1\" \n      port = $port \n    } \n  } \n} \n\"\"\") \n\n```", "```java\ndef remotingSystem(name: String, port: Int): ActorSystem = \n  ActorSystem(name, remotingConfig(port)) \n\n```", "```java\nobject RemotingPongySystem extends App { \n  val system = remotingSystem(\"PongyDimension\", 24321) \n  val pongy = system.actorOf(Props[Pongy], \"pongy\") \n  Thread.sleep(15000) \n  system.shutdown() \n} \n\n```", "```java\nclass Runner extends Actor { \n  val log = Logging(context.system, this) \n  val pingy = context.actorOf(Props[Pingy], \"pingy\") \n  def receive = { \n    case \"start\" => \n      val pongySys = \"akka.tcp://PongyDimension@127.0.0.1:24321\" \n      val pongyPath = \"/user/pongy\" \n      val url = pongySys + pongyPath \n      val selection = context.actorSelection(url) \n      selection ! Identify(0) \n    case ActorIdentity(0, Some(ref)) => \n      pingy ! ref \n    case ActorIdentity(0, None) => \n      log.info(\"Something's wrong - ain't no pongy anywhere!\") \n      context.stop(self) \n    case \"pong\" => \n      log.info(\"got a pong from another dimension.\") \n      context.stop(self) \n  } \n} \n\n```", "```java\nobject RemotingPingySystem extends App { \n  val system = remotingSystem(\"PingyDimension\", 24567) \n  val runner = system.actorOf(Props[Runner], \"runner\") \n  runner ! \"start\" \n  Thread.sleep(5000) \n  system.shutdown() \n} \n\n```", "```java\n            class SessionActor(password: String, r: ActorRef) \n            extends Actor { \n              def receive = ??? \n            } \n\n    ```", "```java\n            class DistributedMap[K, V](shards: ActorRef*) { \n              def update(key: K, value: V): Future[Unit] = ??? \n              def get(key: K): Future[Option[V]] = ??? \n            } \n\n    ```", "```java\n            def broadcast(refs: ActorRef*)(msg: Any): Unit = ??? \n\n    ```"]