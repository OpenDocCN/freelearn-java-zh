- en: Fast Track to OOP - Classes and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing object-oriented design using classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inner classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inheritance and composition to make the design extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding to an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with default and static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with private methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enums to represent constant entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the @Deprecated annotation to deprecate APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML5 in Javadocs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gives you a quick introduction to the components of OOP and covers
    the new enhancements in these components in Java 8 and Java 9\. We will also try
    to cover a few good **object-oriented design** (**OOD**) practices wherever applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the recipes, we will use the new (introduced in Java 8 and Java 9)
    enhancements, define and demonstrate the concepts of OOD using specific code examples,
    and present new capabilities for better code documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can spend many hours reading articles and practical advice on OOD in books
    and on the Internet. Some of this activity can be beneficial for some people.
    But, in our experience, the fastest way to get hold of OOD is to try its principles
    early in your own code. This is exactly the goal of this chapter: to give you
    a chance to see and use the OOD principles so that the formal definition makes
    sense immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main criteria of well-written code is its clarity of expressing its
    intent. A well-motivated and clear design helps achieve this. The code is run
    by a computer, but it is maintained and extended by humans. Keeping this in mind
    will assure longevity of the code written by you and perhaps even a few thanks
    and mentions with appreciation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use the five basic OOD concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Object/Class - Keeping data and procedures together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation - Hiding data and/or procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance - Extending another class data and/or procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface - Deferring the implementation and coding for a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism - Using the base class type for all its extensions when a parent
    class reference is used to refer to a child class object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These concepts will be defined and demonstrated in the code snippets presented
    in this chapter. If you search the Internet, you may notice that many other concepts
    and additions to them can be derived from the five points we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Although the following text does not require prior knowledge of OOD, some experience
    of writing code in Java would be beneficial. The code samples are fully functional
    and compatible with Java 9\. For better understanding, we recommend that you try
    to run the presented examples.
  prefs: []
  type: TYPE_NORMAL
- en: We also encourage you to adapt the tips and recommendations in this chapter
    to your needs in the context of your team experience. Consider sharing your new-found
    knowledge with your colleagues and discuss how the described principles can be
    applied to your domain, for your current project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing object-oriented design using classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about the first two OOD concepts: object/class
    and encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *object* usually refers to the coupling of data and procedures that
    can be applied to these data. Neither data, nor procedures are required, but one
    of them is--and, typically, both are--always present. The data are called object
    properties, while procedures are called methods. Properties capture the state
    of the object. Methods describe objects' behavior. Every object has a type, which
    is defined by its class (see the following). An object also is said to be an instance
    of a class.
  prefs: []
  type: TYPE_NORMAL
- en: The term *class* is a collection of the definitions of properties and methods
    that will be present in each of its instances--the objects created based on this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is the hiding of object properties and methods that should not
    be accessible by other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is achieved by the Java keywords `private` or `protected` in the
    declaration of properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `Engine` class with the `horsePower` property, the `setHorsePower()` method
    that sets this property''s value, and the `getSpeedMph()` method that calculates
    the speed of a vehicle, based on the time since the vehicle started moving, the
    vehicle weight, and the engine power:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the application that will use these classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding application produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/588c3c06-9cce-4b44-b151-ef935580b1ff.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, an `engine` object was created by invoking the default constructor
    of the `Engine` class without parameters and with the Java keyword `new` that
    allocated memory for the newly created object on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The second object, namely `vehicle`, was created with the explicitly defined
    constructor of the `Vehicle` class with two parameters. The second parameter of
    the constructor is an `engine` object that carries the `horsePower` property with
    the value set as `246`, using the `setHorsePower()` method.
  prefs: []
  type: TYPE_NORMAL
- en: It also contains the `getSpeedMph()` method that can be called by any other
    object that has access to the `engine` object, as it is done in the `getSpeedMph()`
    method of the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noticing that the `getSpeedMph()` method of the `Vehicle` class
    relies on the presence of a value assigned to the `engine` property. The object
    of the `Vehicle` class delegates the speed calculation to the object of the `Engine`
    class. If the latter is not set (`null` passed in the `Vehicle()` constructor,
    for example), we will get `NullPointerException` at runtime. To avoid this, we
    can place a check for the presence of this value in the `Vehicle()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can place a check in the `getSpeedMph()` method of the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This way, we avoid the ambiguity of `NullPointerException` and tell the user
    exactly what the source of the problem was.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, the `getSpeedMph()` method can be removed from the `Engine`
    class and fully implemented in the `Vehicle`: class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To do this, we would need to add the public method `getHorsePower()` to the `Engine`
    class in order to make it available for usage by the `getSpeedMph()` method in
    the `Vehicle` class. For now, we leave the `getSpeedMph()` method in the `Engine`.
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the design decisions you need to make. If you think that an object
    of the `Engine` class is going to be passed around to the objects of different
    classes (not only `Vehicle`), then you would need to keep the `getSpeedMph()`
    method in the `Engine` class. Otherwise, if you think that the `Vehicle` class
    is going to be responsible for the speed calculation (which makes sense, since
    it is the speed of a vehicle, not of an engine), then you should implement the
    method inside the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides a capability to extend a class and allow the subclass to access
    all of the functionality of the base class. For example, you can decide that every
    object that could be asked about its speed belongs to a subclass that is derived
    from the `Vehicle` class. In such a case, `Car` may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can change our test code by replacing the `Vehicle` class with the `Car`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, it produces the same value as with an object of the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d1e55c8-80ef-4773-9d71-a2a59cca2ec7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because of polymorphism, a reference to the object of the `Car` class can be
    assigned to the reference of the base class, that is, `Vehicle`. The object of
    the `Car` class has two types: its own type, that is, `Car` and the type of the
    base class, namely `Vehicle`.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a class can also implement multiple interfaces, and the object of such
    a class would have a type of each of the implemented interfaces too. We will talk
    about this in subsequent recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There are usually several ways to design an application for the same functionality.
    It all depends on the needs of your project and the style adopted by the development
    team. But in any context, clarity of design will help you communicate the intent.
    Good design contributes to the quality and longevity of the code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance and composition to make the design extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inner classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about three types of inner classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner class**: This is a class defined inside another (enclosing) class.
    Its accessibility from outside the enclosing class is regulated by the `public`,
    `protected`, and `private` keywords. It can access the private members of the
    enclosing class, and the enclosing class can access the private members of its
    inner class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method-local inner class**: This is a class defined inside a method. Its
    scope is restricted to within the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymous inner class**: This is an anonymous class defined during object
    instantiation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class is used by one, and only one, other class, the designer might decide
    that there is no need to make such a class public. For example, let's assume that
    the Engine class is used by the `Vehicle` class only.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `Engine` class as an inner class of the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getSpeedMph()` method of the `Vehicle` class has access to
    the `Engine` class (although it is declared `private`) and even to the private
    `getSpeedMph()` method of the `Engine` class. The inner class has access to all
    the private elements of the enclosing class too. This is why `getSpeedMph()` of
    the `Engine` class has access to the private `getWeightPounds()` method of the
    enclosing `Vehicle` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look closer at the usage of the inner class `Engine`. Only the `getSpeedMph()`
    method uses it. If the designer believes that it is going to be the case in future
    too, it would be reasonable to make it method-local inner class, which is the
    second type of an inner class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulation--hiding the state and behavior of objects--helps avoid unexpected
    side effects resulting from an accidental change or overriding. It makes the behavior
    more predictable and easier to understand. That's why a good design exposes only
    the functionality that must be accessible from the outside. Typically, this is
    the main functionality that motivated the class creation in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether the `Engine` class is implemented as an inner class or a method-local
    inner class, the test code looks the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, we get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ce136e8-9e00-42a0-b323-1a0a023d2cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s assume we need to test different implementations of the `getSpeedMph()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If this speed calculation formula does not make sense to you, you are correct.
    It does not. We did it for making the result predictable and different from the
    result of the previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to introduce this new implementation. We can change the implementation
    of the `getSpeedMph()` method in the `Engine` class, for example. Or, we can change
    the implementation of the same method in the `Vehicle` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will do this using the third type of inner class called
    anonymous inner class. This approach is especially handy when you want to write
    as little new code as possible or you want to quickly test the new behavior by
    temporarily overriding the old one. The code would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, the result would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b37c5de-af1d-4660-bc11-44725cd18112.png)'
  prefs: []
  type: TYPE_IMG
- en: We have overridden the `Vehicle` class implementation by leaving only one method
    in it--the `getSpeedMph()` method that returns hardcoded value. We could override
    other methods or add new ones, but we will keep it simple for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition, anonymous inner class has to be an expression that is part of
    a statement that ends (as any statement) with a semicolon. The expression is composed
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `new` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the implemented interface (followed by parentheses `()` that represent
    the default constructor) or a constructor of the extended class (the latter is
    our case, the extended class being `Vehicle`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class body with method declarations (statements are not allowed in the body
    of an anonymous inner class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like any inner classes, anonymous inner class can access any member of the enclosing
    class and can capture the values of its variables. To be able to do this, these
    variables have to be declared `final`. Otherwise, they become `final` implicitly,
    which means their values cannot be changed (a good modern IDE will warn you about
    the violation of this constraint if you try to change such a value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these features, we can modify our sample code and provide more input
    data for the newly implemented `getSpeedMph()` method without passing them as
    method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the variables `timeSec`, `engineHorsePower`, and `vehicleWeightPounds`
    are accessible by the `getSpeedMph()` method of the inner class and cannot be
    modified. If we run this code, the result will be the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c68560b-cb9e-404e-891c-7c6936a8fef9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the case of an interface with only one abstract method (called functional
    interface), a particular type of anonymous inner class, called **lambda expression**,
    it allows you to have a shorter notation but provides the interface implementation. We
    are going to discuss functional interface and lambda expression in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An inner class is a non-static nested class. Java also allows you to create
    a static nested class that can be used when an inner class does not require access
    to non-public properties and methods of the enclosing class. Here is an example
    (the keyword `static` is added to the `Engine` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because a static class couldn't access a non-static member (the `getWeightPounds()`
    method of the enclosing class `Vehicle`), we were forced to pass the weight value
    to the `Engine` class during its construction (and we removed the `getWeightPounds()`
    method as it was not needed anymore).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Going functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inheritance and composition to make the design extensible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about two important OOD concepts, namely Inheritance
    and Polymorphism, which have been mentioned already and used in the examples of
    the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is the ability of one class to extend (and, optionally, override)
    the properties and/or methods of another class. The extended class is called the base
    class, superclass, or parent class. The new extension of the class is called a subclass or
    child class.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is the ability to use the base class as a type for the references
    to the objects of its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the power of these two concepts, let's create classes that represent
    cars and trucks, each having weight, engine power, and speed it can reach (as
    a function of time) with maximum load. In addition, a car, in this case, will
    be characterized by the number of passengers, while a truck's important feature
    will be its payload.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the `Vehicle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is an obvious commonality between a car and a truck that can be encapsulated
    in the `Vehicle` class as the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass, called `Car`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another subclass, called `Truck`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since the base class `Vehicle` has neither an implicit or explicit constructor
    without parameters (because we have chosen to use an explicit constructor with
    parameters only), we will have to call the base class constructor `super()` as
    the first line of the constructor of every subclass.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a test program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the reference `vehicle` to the base class `Vehicle` points to the
    object of the subclass `Car`. This is made possible by polymorphism, according
    to which an object has a type of every class in its line of inheritance (including
    all the interfaces, which we will discuss a bit later).
  prefs: []
  type: TYPE_NORMAL
- en: One needs to cast such a reference to the subclass type, as you can see in the
    preceding example, in order to invoke a method that exists only in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding example, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b22a6f7-658c-4f04-b790-1b31f7a1a897.png)'
  prefs: []
  type: TYPE_IMG
- en: We should not be surprised to see the same speed, that is, `117.0 mph`, calculated
    for both--the car and the truck--because the same weight and engine power are
    used to calculate the speed of each. But, intuitively, we feel that a heavily
    loaded truck should not be able to reach the same speed as a car. To verify this,
    we need to include the total weight of the car (with the passengers and their
    luggage) and the truck (with the payload) in the `getSpeedMph()` method. One way
    to do this is to override the `getSpeedMph()` method of the base class `Vehicle` in
    each of the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `horsePower` and `weightPounds` properties and the following method
    to the `Car` class (we assume that a passenger with a luggage weighs 250 pounds
    total on average):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the `horsePower` and `weightPounds` properties and the following
    method to the `Truck` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of these two additions (if we run the same test class) will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6c54379-5e48-47eb-815f-e43f033390ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These results do confirm our intuition: a fully loaded car or truck does not
    reach the same speed as an empty one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new methods in the subclasses override `getSpeedMph()` of the base class
    `Vehicle`, although we access it via the base class reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The overridden method is dynamically bound, which means that the context of
    the method invocation is determined by the type of the actual object being referred
    to. Since, in our example, the reference `vehicle` points to an object of the
    subclass `Car`, the `vehicle.getSpeedMph()` construct invokes the method of the
    subclass, not the method of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is obvious code redundancy in the two new methods, which we can refactor
    by creating a method in the base class, that is, `Vehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since this method is used by subclasses only, it can be protected (and thus,
    accessible only to the subclasses).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the `getSpeedMph()` method of the `Car` subclass would look now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it will appear in the `Truck` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to modify the test class by adding casting. Otherwise, there will
    be a runtime error because the `getSpeedMph(int timeSec)` method does not exist
    in the base class `Vehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have expected, the test class produces the same values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf68928d-e7fa-45b2-836f-ad5e6b863228.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To simplify the test code, we can drop casting and write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The speed values produced by this code remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, there is an even simpler way to achieve the same effect. We can add the `getMaxWeightPounds()`
    method to the base class and each of the subclasses. The `Car` class will now
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the new version of the `Truck` class will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the `getMaxWeightPounds()` method to the base class so
    it can be used for the speed calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an abstract method `getMaxWeightPounds()` to the `Vehicle` class makes
    the class abstract. This has a positive side effect: it enforces the implementation
    of the `getMaxWeightPounds()` method in each subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class remains the same and produces the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b773c1f3-bbdc-4df9-9f70-9c09acda2f24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is an even simpler code change for the same effect--to use the maximum
    weight in the speed calculations in the base class. If we get back to the original
    version of the classes, all we need to do is to pass the maximum weight to the
    constructor of the base class `Vehicle`. The resulting classes will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the weight of the passengers to the value we pass to the constructor
    of the superclass; this is the only change in this subclass. There was a similar
    change in the `Truck` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The base class `Vehicle` remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The test class does not change and produces the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/695b3517-b722-44bb-b141-70c5175a291d.png)'
  prefs: []
  type: TYPE_IMG
- en: This last version--passing the maximum weight to the constructor of the base
    class--will now be the starting point for further demo code development.
  prefs: []
  type: TYPE_NORMAL
- en: Composition makes the design more extensible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, the speed model is implemented in the `getSpeedMph()`
    method of the `Vehicle` class. If we need to use a different speed model (which
    includes more input parameters and is more tuned to certain driving conditions,
    for example), we would need to change the `Vehicle` class or create a new subclass
    to override the method. In the case when we need to experiment with tens or even
    hundreds of different models, this approach becomes untenable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in real life, modeling based on machine learning and other advanced techniques
    becomes so involved and specialized, that it is quite common that the modeling
    of car acceleration is done by a different team, not the team that builds vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the proliferation of subclasses and code merge conflicts between vehicle
    builders and speed model developers, we can create a more extensible design using
    composition.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is an OOD principle for implementing the necessary functionality
    using the behavior of classes that are not part of the inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can encapsulate the speed calculations inside the `SpeedModel` class in
    the `getSpeedMph()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An object of this class can be created and then set on the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the test class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f73ccaca-62d9-47e6-adf5-0bc130d5000f.png)'
  prefs: []
  type: TYPE_IMG
- en: We isolated the speed calculating functionality in a separate class and can
    now modify or extend it without changing any class of the `Vehicle` hierarchy.
    This is how the composition design principle allows you to change the behavior
    of the `Vehicle` class and its subclasses without changing their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will show how the OOD concept of Interface unlocks more
    power of composition and polymorphism, making the design simpler and even more
    expressive.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Coding to an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enums to represent constant entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding to an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about the last of the OOD concepts, called Interface,
    and further practice the usage of composition and polymorphism as well as inner
    classes and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interface, in this case, is a reference type that defines the signatures of
    the methods one can expect to see in the class that implements the interface. It
    is the public face of the functionality accessible to a client and is thus often
    called an **Application Program Interface** (**API**). It supports polymorphism
    and composition and thus facilitates even more flexible and extensible design.
  prefs: []
  type: TYPE_NORMAL
- en: An interface is implicitly abstract, which means it cannot be instantiated (no
    object can be created based on an interface only). It is used to contain abstract
    methods (without body) only. Now, since Java 8, it is possible to add default
    and private methods to an interface--the capability we are going to discuss in
    the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Each interface can extend multiple other interfaces and, similar to class inheritance,
    inherit all the methods of the extended interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create interfaces that will describe the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Use factories, which are classes that generate objects that implement certain
    interfaces. A factory is an implementation of a pattern for creating objects without
    having to specify the exact class of the object that is created--specifying an
    interface only, rather than calling a constructor. It is especially helpful when
    an instance of object creation requires a complex process and/or significant code
    duplication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, it makes sense to have the `FactoryVehicle` class that will create
    objects for the `Vehicle`, `Car`, and `Truck` interfaces and the `FactorySpeedModel`
    class that will generate objects for the `SpeedModel` interface. Such an API will
    allow you to write the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that the code behavior is the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4cb4d51f-2ed9-4e45-9cc0-b8a2a275cf7e.png)'
  prefs: []
  type: TYPE_IMG
- en: However, the design is much more extensible.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen one possible implementation of the `SpeedModel` class.
    Here is another way to do this inside the `FactorySpeedModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We put comments (as pseudo code) and the `...` symbol instead of the code for
    brevity.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the factory class may hide many different private and static
    nested classes, each containing a specialized model for particular driving conditions.
    Each model brings different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of the `FactoryVehicle` class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an interface describes how to invoke object behavior; it also
    allows you to generate different implementations for different requests (and provided
    values) without changing the code of the main application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to model a crew cab--a truck with multiple passenger seats that combines
    the properties of a car and a truck. Java does not allow multiple inheritances.
    This is another case where interfaces come to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CrewCab` class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This class implements both the interfaces--`Car` and `Truck`--and passes the
    combined weight of the vehicle, payload, and passengers with their luggage to
    the base class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add the following method to `FactoryVehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The double nature of the `CrewCab` object can be demonstrated in the following
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can cast the object of the `CrewCub` class to each of the
    interfaces it implements. If we run this program, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6bb6903-fd2b-4b30-bedf-658be189bb28.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces with default and static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with private methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with default and static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about two new features that were first introduced
    in Java 8: default and static methods in an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default method allows you to add new functionality to an interface without
    changing the classes that have implemented this interface. The method is called
    *default* because it provides functionality in case a method is not implemented
    by the class. If, however, the class implements it, the interface's default implementation
    is ignored and overridden by the class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Having a static method in an interface can provide functionality the same way
    a static method in a class can. As with a class static method (which can be called
    without class instantiation), an interface static method can also be called by
    adding the name of the interface in front of it.
  prefs: []
  type: TYPE_NORMAL
- en: A static interface method cannot be overridden by any class, including the class
    that implements this interface, and it cannot hide any static method of any class,
    including the class that implements this interface.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created an amazing piece of software that calculates the speed
    of a vehicle. If this program becomes popular (as it should), it can be used by
    readers who prefer a metric system of weight units. To address such a need later--after
    our speed-calculating software has become popular--we have decided to add more
    methods to the `Truck` interface; however, we do not want to break the existing
    implementation of `FactoryVehicle`, created by some other company.
  prefs: []
  type: TYPE_NORMAL
- en: The default interface methods were introduced for exactly such a situation.
    Using them, we can release a new version of an interface without the need to coordinate
    it with the development of `FactoryVehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enhance the `Truck` interface by adding the `getPayloadKg()` method, which
    returns the truck payload in kilograms. You can do this without forcing a change
    in the `TruckImpl` class that implements the `Truck` interface inside `FactoryVehicle`--by
    adding a new default method to the `Truck` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the new method `getPayloadKg()` uses the existing `getPayloadPounds()` method
    as if the latter is implemented inside the interface too when, in fact, it is
    implemented by a class inside `FactoryVehicle`. The magic happens during runtime
    when this method becomes dynamically bound to the instance of the class that implements
    this interface.
  prefs: []
  type: TYPE_NORMAL
- en: We could not make the `getPayloadKg()` method static because it would not be
    able to access the non-static `getPayloadPounds()` method, and we must use the
    `default` keyword because only the default or static method of an interface can
    have a body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the demo code that uses the new method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding program and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d779c3d6-9a12-4182-b28e-4a8f850a6a23.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the new method works even without changing the class that implemented
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Later, when you decide to improve the implementation of the `FactoryVehicle` class,
    you can do it by adding the corresponding method, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We made the `return -2` implementation in order to make it obvious which implementation
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the same demo program. The results will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86a7f48c-f9c7-4b14-923d-ec2a9f861d8e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the method in the `TruckImpl` class has overridden the default
    implementation in the `Truck` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhance the `Truck` interface with the ability to enter the payload in kilograms
    without changing the implementation of `FactoryVehicle`. But we would also like
    the `Truck` implementation to remain immutable, and we do not want to add a setter
    method. With all these limitations, our only recourse is to add `convertKgToPounds()`
    to the `Truck` interface, and it has to be `static` since we are going to use
    it before the object that implements the `Truck` interface is constructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fans who love using the metric system of units can now take advantage of the
    new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ba684a5-eae1-4f97-9deb-7186ea1d6531.png)'
  prefs: []
  type: TYPE_IMG
- en: The value 1,502 is close to the original 1,500, while 3,308 is close to 3,312\.
    The difference is caused by the error of approximation during the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces with private methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces with private methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about a new feature introduced in Java 9: private
    interface method, which is of two types, namely static and non-static.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private methods in an interface are new in Java 9\. They allow you to make interface
    methods (with a body) accessible only to other methods (with a body) in the same
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: A private method in an interface cannot be overridden anywhere--not by a method
    of any interface, nor by a method in any class. Its only purpose is to contain
    functionality that is common between two or more methods with a body, either private
    or public, in the same interface. It can also be used by one method only in order
    to make the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: A private interface method must have an implementation. A private interface
    method not used by other methods of the same interface does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: A static private interface method can be accessed by non-static and static methods
    of the same interface. The non-static private interface method can be accessed
    only by static methods of the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the `getWeightKg()` implementation too. Since we do not have the `getWeightPounds()`
    method in the interface, the method signature should include an input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the redundant code using the private interface method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code demonstrates the new addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the test run do not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acc2484b-046c-4f1e-89bb-6eaebf0e6879.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, with the `getWeightKg(int pounds)` method accepting the input parameter,
    the method name can be misleading because (by contrast, with `getPayloadKg()`)
    the method does not control the source of the data. The input value can represent
    anything. After realizing it, we decided that the interface would be better without
    it, but only after making the `convertPoundsToKg()` method public. Since it does
    not require access to the object elements, it can be static too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Fans of the metric system will still be able to convert pounds into kilograms
    and back. Besides, since the converting methods are static, we do not need to
    create an instance of the class that implements the `Truck` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The results do not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1911b481-e70a-4ea0-814c-c855c3fd9e66.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces with default and static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enums to represent constant entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about the special data type `enum` that allows
    you to create a custom type with predefined values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at a couple of examples. Here is the simplest possible
    `enum` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we run the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff9021e-eb00-4482-9825-3876c3ec2606.png)'
  prefs: []
  type: TYPE_IMG
- en: The `enum` type implicitly extends `java.util.Enum` (so you cannot extend your
    custom type `RoadCondition`, for example) and automatically acquires its methods.
    In the preceding code, we have already seen one (the most useful) method, `values()`,
    that returns an array of the `enum` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful `enum` method is `valueOf(String)` that returns the constant
    of the specified `enum` type with the specified name (passed in as `String`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods of each element include useful ones such as `equals()`, `name()`,
    and `ordinal()`. Now say we run the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88928175-8f84-407c-8704-ac44ca3a6dc4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may have guessed, `ordinal()` returns the position of the value in the
    `enum` declaration, starting with zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other `enum` features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` class body can include a constructor, methods, variables, and constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor is called automatically when `enum` is accessed the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static constant can be accessed via the class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-static constant can be accessed via any of the elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java comes with several predefined `enum` types, including `DayOfWeek` and `Month`.
  prefs: []
  type: TYPE_NORMAL
- en: To make it look more like a real-life `enum`, let's use traction coefficient
    as an element value. Such a coefficient reflects the degree of traction between
    the road and the tires. The higher the value, the better the traction. This value
    can be used for the improvement of a vehicle speed calculation. For example, `SpeedModel`
    should be able to receive `RoadCondition.WET` and extract the traction coefficient
    `0.2` from it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define the `RoadCondition` enumeration in the `SpeedModel` interface (because
    it is part of the `SpeedModel` API):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to add the `public` keyword in front of `enum RoadCondition` because,
    in an interface, it defaults to `public` (if the `private` keyword is not used
    instead).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6926d3f5-dcd9-4a2e-bf05-14ec9220152d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `enum TireCondition` to the `iSpeedModel` interface too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `enum` for `DrivingCondition`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the three `enum` types in place, we can calculate the vehicle speed of
    all the possible combinations of the given driving conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7044df96-2382-4ce6-80a0-c79796543285.png)'
  prefs: []
  type: TYPE_IMG
- en: That is how `enum` allows you to define an API input and make input data validation
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The higher the temperature, the quicker the road dries out, and the traction
    coefficient is getting higher. To account for this, we can add a `temperature`
    property to `enum RoadCondition` and override the `getTraction()` method for the `WET` element,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set the `temperature` property on `RoadCondition` before the speed
    calculation and get a different value of speed for the wet road condition. Add
    this line before calling the speed calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do this, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d678b27a-77e3-4d32-994c-b0a14e981ab5.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the @Deprecated annotation to deprecate APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about the deprecation of API elements and the
    enhancements of the `@Deprecated`  annotation in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@Deprecated` annotation was first introduced in Java 5, while the Javadoc
    tag `@deprecated` was introduced in Java even earlier. The presence of the annotation
    forces the compiler to generate a warning that can be suppressed by the annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Java 9, the annotation can have one or both the methods, namely `since()`
    and `forRemoval()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `since()` method allows the setting of the API version (as `String`). It
    depicts the API version from where the particular class or method was deprecated.
    If not specified, the default value of the `since()` method is `""` (empty `String`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `forRemoval()` method depicts the intent to remove the marked element (if
    `true`) or not (if `false`). If not set, the default value is `false`. If the
    `forRemoval()` method is present with the value `true` to suppress the warning,
    one needs to specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the `Car` interface again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the `getPayloadKg()` method, introduce a more general method and
    `enum` for supporting the metric system of weight units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Such an enhancement allows you to have more flexibility in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecate the `getPayloadPounds()` method and add a Javadoc with explanations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Each of the methods in the `@Deprecated` annotation is optional.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we compile the preceding code, there will be a warning *this method has been
    deprecated and marked for removal* at every place of its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If the `forRemoval()` method is not present or set to `false`, the warning message
    would say *has been deprecated* only.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the warning, we need to either avoid using the deprecated method or
    suppress the warning as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java 9, both--the Javadoc tag `@deprecated` and `@Deprecated` annotation--are
    required. The presence of only one of them is considered an error.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML5 in Javadocs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about the usage of HTML5 tags in the Javadoc
    comments in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of sources on the Internet that describe HTML5 tags. Since
    Java 9, one can use any one of them in Javadoc comments.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 provides better browser compatibility. It is also more mobile-friendly
    than its predecessor, HTML4\. But to take advantage of HTML5, one has to specify
    the `-html5` parameter during Javadoc generation. Otherwise, only HTM4-style comments
    will continue to be supported.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of the HTML5 tags used for Javadoc comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using IntelliJ IDEA, go to Tools | Generate JavaDoc... and set the
    `-html5` value in the Other command line arguments field and click on OK. Without
    an IDE, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64f67412-aa5d-4f8b-ae17-162cac5bb934.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, `src` is the folder that contains the source code in the `com` subfolder,
    and `api` is a folder in the current directory where Javadoc is going to be stored.
    The `com.cookbook.oop` is the package for which you want to generate Javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting Javadoc will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/113f566e-6e34-4e39-9189-c957049dbbd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding description is taken from the text inside tags `<h2>`, but its
    font is not different from other lines. Here''s how the full description will
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5462c68d-d7c2-41ce-aae5-edc7aebeb87c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see how prominently the text in tags `<h2>` and `<h3>` is presented
    and the `here` link is highlighted and can be clicked.
  prefs: []
  type: TYPE_NORMAL
