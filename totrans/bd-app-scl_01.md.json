["```java\n$ cd ~/\n$ wget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"\nhttp://download.oracle.com/otn-pub/java/jdk/8u77-b03/jdk-8u77-linux-i586.tar.gz\"\n$ tar -xzvf $ jdk-8u77-linux-x64.tar.gz \n$ rm -f jdk-8u77-linux-x64.tar.gz\n\n```", "```java\nexport JAVA_HOME=~/jdk1.8.0_77\nexport PATH=$PATH:$JAVA_HOME/bin\n\n```", "```java\n$ java -version\njava version \"1.8.0_77\"\nJava(TM) SE Runtime Environment (build 1.8.0_77-b03)\nJava HotSpot(TM) Server VM (build 25.77-b03, mixed mode)\n\n```", "```java\n$ cd ~/\n$ wget http://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz\n$ tar -xzvf scala-2.11.8.tgz\n$ rm -rf scala-2.11.8.tgz\n\n```", "```java\nexport SCALA_HOME=~/scala-2.11.8/\nexport PATH=$PATH:$SCALA_HOME/bin\n\n```", "```java\n$ scala -version\nScala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala>\nScala REPL\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> \"Hello World\"\nres0: String = Hello World\nscala> \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> object HelloWorld {\n |   def main(args:Array[String]) = println(\"Hello World\")\n | }\ndefined object HelloWorld\nscala> HelloWorld.main(null)\nHello World\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> System.out.println(\"Hello World\") \nHello World\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> object HelloWorld extends App {\n |  println(\"Hello World\")\n | }\ndefined object HelloWorld\nscala> HelloWorld\nobject HelloWorld\nscala> HelloWorld.main(null)\nHello World\nscala>\n\n```", "```java\n    package scalabook.javacode.chap1; \n\n    public class HelloWorld { \n      public static void main(String args[]){ \n        System.out.println(\"Hellow World\"); \n      } \n    } \n\n```", "```java\n    package scalabook.javacode.chap1; \n\n    public class HelloWorldSingleton { \n\n      private HelloWorldSingleton(){} \n\n      private static class SingletonHelper{ \n        private static final HelloWorldSingleton INSTANCE =  \n        new HelloWorldSingleton(); \n      } \n\n      public static HelloWorldSingleton getInstance(){ \n        return SingletonHelper.INSTANCE; \n      } \n\n      public void sayHello(){ \n        System.out.println(\"Hello World\"); \n      } \n\n      public static void main(String[] args) { \n        getInstance().sayHello(); \n      } \n    } \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\n\nscala> var x = 10\nx: Int = 10\n\nscala> x\nres0: Int = 10\n\nscala> x = 11\nx: Int = 11\n\nscala> x \nres1: Int = 11\n\nscala> \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val x = 10\nx: Int = 10\nscala> x\nres0: Int = 10\nscala> x = 11\n<console>:12: error: reassignment to val\n x = 11\n ^\nscala> x\nres1: Int = 10\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val x = 10\nx: Int = 10\nscala> val y = 11.1\ny: Double = 11.1\nscala> val b = true\nb: Boolean = true\nscala> val f = false\nf: Boolean = false\nscala> val s = \"A Simple String\"\ns: String = A Simple String\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val x:Int = 10\nx: Int = 10\nscala> val y:Double = 11.1\ny: Double = 11.1\nscala> val s:String = \"My String \"\ns: String = \"My String \"\nscala> val b:Boolean = true\nb: Boolean = true\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val x = 10\nx: Int = 10\nscala> if (x == 10) \n | println (\"X is 10\")\nX is 10\nscala> val y = if (x == 10 ) 11\ny: AnyVal = 11\nscala> y\nres1: AnyVal = 11\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val x = 10\nx: Int = 10\nscala> def someFunction = if (x == 10) \"X is 10\"\nsomeFunction: Any\nscala> someFunction\nres0: Any = X is 10\nscala>\n\n```", "```java\n~$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val x = 10\nx: Int = 10\nscala> if (x==10){\n |   println(\"X is 10\")\n | } else {\n |   println (\"X is something else\")\n | }\nX is 10\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> for ( i <- 1 to 10)\n | println(\"i * \" + i + \" = \" +  i * 10)\ni * 1 = 10\ni * 2 = 20\ni * 3 = 30\ni * 4 = 40\ni * 5 = 50\ni * 6 = 60\ni * 7 = 70\ni * 8 = 80\ni * 9 = 90\ni * 10 = 100\nscala> \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val listOfValues = List(1,2,3,4,5,6,7,8,9,10)\nlistOfValues: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nscala> for ( i<- listOfValues ) println(i)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val listOfValues = List(1,2,3,4,5,6,7,8,9,10)\nlistOfValues: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nscala> for ( i<- listOfValues ) if  (i % 2== 0) println(i)\n2\n4\n6\n8\n10\nscala>\n\n```", "```java\n    package scalabook.javacode.chap1; \n\n    import java.util.Arrays; \n    import java.util.List; \n\n    public class ForLoopsEvenNumberFiltering { \n      public static void main(String[] args) { \n        List<Integer> listOfValues = Arrays.asList( \n          new Integer[]{1,2,3,4,5,6,7,8,9,10}); \n        for(Integer i : listOfValues){ \n          if (i%2==0) System.out.println(i); \n        } \n      } \n    } \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val names = Set(\"Diego\", \"James\", \"John\", \"Sam\", \"Christophe\")\nnames: scala.collection.immutable.Set[String] = Set(John, Sam, Diego, James, Christophe)\nscala> \nscala> val brazilians = for {\n |   name <- names \n |   initial <- name.substring(0, 1)\n |     } yield if (name.contains(\"Die\")) name\nbrazillians: scala.collection.immutable.Set[Any] = Set((), Diego)\nscala>\n\n```", "```java\n    package scalabook.javacode.chap1; \n\n    import java.util.LinkedHashSet; \n    import java.util.Set; \n\n    public class JavaNoForComprehension { \n      public static void main(String[] args) { \n\n        Set<String> names = new LinkedHashSet<>(); \n        Set<String> brazillians = new LinkedHashSet<>(); \n\n        names.add(\"Diego\"); \n        names.add(\"James\"); \n        names.add(\"John\"); \n        names.add(\"Sam\"); \n        names.add(\"Christophe\"); \n\n        for (String name: names){ \n          if (name.contains(\"Die\")) brazillians.add(name);  \n        } \n\n        System.out.println(brazillians); \n      } \n    } \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> var ms = scala.collection.mutable.ListBuffer(1,2,3)\nms: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)\nscala> ms += 4\nres0: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)\nscala> ms += 5\nres1: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 5)\nscala> ms += 6\nres2: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 5, 6)\nscala> ms(1)\nres3: Int = 2\nscala> ms(5)\nres4: Int = 6\nscala> ms -= 5\nres5: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 6)\nscala> ms -= 6\nres6: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> var names = scala.collection.mutable.SortedSet[String](\"Diego\", \"Poletto\", \"Jackson\")\nnames: scala.collection.mutable.SortedSet[String] = TreeSet(Diego, Jackson, Poletto)\nscala> names += \"Sam\"\nres2: scala.collection.mutable.SortedSet[String] = TreeSet(Diego, Jackson, Poletto, Sam)\nscala> names(\"Diego\")\nres4: Boolean = true\nscala> names -= \"Jackson\"\nres5: scala.collection.mutable.SortedSet[String] = TreeSet(Diego, Poletto, Sam)\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val config = (\"localhost\", 8080)\nconfig: (String, Int) = (localhost,8080)\nscala> config._1\nres0: String = localhost\nscala> config._2\nres1: Int = 8080\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val numbers = Map(\"one\"   -> 1, \n |                   \"two\"   -> 2,\n |                   \"three\" -> 3,\n |                   \"four\"  -> 4,\n |                   \"five\"  -> 5,\n |                   \"six\"   -> 6,\n |                   \"seven\" -> 7,\n |                   \"eight\" -> 8,\n |                   \"nine\"  -> 9,\n |                   \"ten\"   -> 10)\nnumbers: scala.collection.immutable.Map[String,Int] = Map(four -> 4, three -> 3, two -> 2, six -> 6, seven -> 7, ten -> 10, five -> 5, nine -> 9, one -> 1, eight -> 8)\nscala> \nscala> numbers.keys\nres0: Iterable[String] = Set(four, three, two, six, seven, ten, five, nine, one, eight)\nscala> \nscala> numbers.values\nres1: Iterable[Int] = MapLike(4, 3, 2, 6, 7, 10, 5, 9, 1, 8)\nscala> \nscala> numbers(\"one\")\nres2: Int = 1\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val map = scala.collection.mutable.HashMap.empty[Int,String]\nmap: scala.collection.mutable.HashMap[Int,String] = Map()\nscala> map += (1 -> \"one\")\nres0: map.type = Map(1 -> one)\nscala> map += (2 -> \"two\")\nres1: map.type = Map(2 -> two, 1 -> one)\nscala> map += (3 -> \"three\")\nres2: map.type = Map(2 -> two, 1 -> one, 3 -> three)\nscala> map += (4 -> \"mutable\")\nres3: map.type = Map(2 -> two, 4 -> mutable, 1 -> one, 3 -> three)\nscala> \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> \nscala> val numbers = List(1,2,3,4,5,6)\nnumbers: List[Int] = List(1, 2, 3, 4, 5, 6)\nscala> def doubleIt(i:Int):Double = i * 2\ndoubleIt: (i: Int)Double\nscala> val doubled = numbers.map( doubleIt _ )\ndoubled: List[Double] = List(2.0, 4.0, 6.0, 8.0, 10.0, 12.0)\nscala> val doubled = numbers.map( 2.0 * _ )\ndoubled: List[Int] = List(2.0, 4.0, 6.0, 8.0, 10.0, 12.0)\nscala>\n\n```", "```java\nscala> val one = Some(1) \none: Some[Int] = Some(1)\nscala> val oneString = one.map(_.toString)\noneString: Option[String] = Some(1)\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val a:Option[Int] = Some(1)\na: Option[Int] = Some(1)\nscala> a.get\nres0: Int = 1\nscala> val b:Option[Int] = None\nb: Option[Int] = None\nscala> b.get\njava.util.NoSuchElementException: None.get\n at scala.None$.get(Option.scala:347)\n at scala.None$.get(Option.scala:345)\n ... 32 elided\nscala> b.getOrElse(0)\nres2: Int = 0\nscala> a == b\nres3: Boolean = false\nscala> \n\n```", "```java\nscala> val c = Some(\"one\")\nc: Some[String] = Some(one)\nscala> c.flatMap( s => Some(s.toUpperCase) )\nres6: Option[String] = Some(ONE)\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val c = Some(\"one\")\nc: Some[String] = Some(one)\nscala> c.\n++             count       foreach              iterator     productArity   seq         toBuffer             unzip \n++:            drop        genericBuilder       last         productElement size        toIndexedSeq         unzip3 \n/:             dropRight   get                  lastOption   productIterator slice      toIterable           view \n:\\             dropWhile   getOrElse            map          productPrefix  sliding     toIterator           withFilter \nWithFilter     equals      groupBy              max          \nreduce         span        toLeft               x \naddString      exists      grouped              maxBy        \nreduceLeft     splitAt     toList               zip \naggregate      filter      hasDefiniteSize      min          reduceLeftOption stringPrefix   toMap           zipAll \ncanEqual       filterNot   hashCode             minBy        reduceOption   sum         toRight              zipWithIndex \ncollect        find        head                 mkString     reduceRight    tail        toSeq \ncollectFirst   \nflatMap        headOption  nonEmpty             reduceRightOption   tails          toSet \ncompanion            flatten     \ninit           orElse      repr                 take           \ntoStream \ncontains    fold                 inits                orNull         sameElements takeRight           toString \ncopy           foldLeft    isDefined            par          \nscan           takeWhile   toTraversable \ncopyToArray    foldRight      isEmpty     partition            scanLeft            \nto             toVector \ncopyToBuffer         forall      isTraversableAgain product scanRight            toArray        \ntranspose \nscala> c\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> class Calculator {\n |    def add(a: Int, b: Int): Int = a + b\n |    def multiply(n: Int, f: Int): Int = n * f\n | }\ndefined class Calculator\nscala> \nscala> val c = new Calculator\nc: Calculator = Calculator@380fb434\nscala> c.add(1,2)\nres0: Int = 3\nscala> c.multiply(3,2)\nres1: Int = 6\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> class Person(\n |   @scala.beans.BeanProperty var name:String = \"\",\n |   @scala.beans.BeanProperty var age:Int = 0\n | ){\n |    name = name.toUpperCase\n |    override def toString = \"name: \" + name + \" age: \" + age\n | }\ndefined class Person\nscala> \nscala> val p  = new Person(\"Diego\",31)\np: Person = name: DIEGO age: 31\nscala> val p1 = new Person(age = 31, name = \"Diego\")\np1: Person = name: DIEGO age: 31\nscala> p.getAge\nres0: Int = 31\nscala> p1.getName\nres1: String = DIEGO\nscala> \n\n```", "```java\n    package scalabook.javacode.chap1; \n\n    public class JavaPerson { \n\n      private String name; \n      private Integer age; \n\n      public JavaPerson() {} \n\n      public JavaPerson(String name, Integer age) { \n        super(); \n        this.name = name; \n        this.age = age; \n      } \n\n      public JavaPerson(String name) { \n        super(); \n        this.name = name; \n      } \n\n      public JavaPerson(Integer age) { \n        super(); \n        this.age = age; \n      } \n\n      public Integer getAge() { \n        return age; \n      } \n\n      public void setAge(Integer age) { \n        this.age = age; \n      } \n\n      public String getName() { \n        return name; \n      } \n\n      public void setName(String name) { \n        this.name = name; \n      } \n\n    } \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> class Person(\n |   @scala.beans.BeanProperty var name:String = \"\",\n |   @scala.beans.BeanProperty var age:Int = 0\n | ){\n |    name = name.toUpperCase\n |    override def toString = \"name: \" + name + \" age: \" + age\n | }\ndefined class Person\nscala> \nscala> class LowerCasePerson(name:String,age:Int) extends Person(name,age) {\n |    setName(name.toLowerCase)\n | }\ndefined class LowerCasePerson\nscala> \nscala> val p  = new LowerCasePerson(\"DIEGO PACHECO\",31)\np: LowerCasePerson = name: diego pacheco age: 31\nscala> p.getName\nres0: String = diego pacheco\nscala> \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> trait Car\ndefined trait Car\nscala> \nscala> trait SportCar {\n |    val brand:String \n |    def run():String = \"Rghhhhh Rghhhhh Rghhhhh....\"\n | }\ndefined trait SportCar\nscala> \nscala> trait Printable {\n |    def printIt:Unit \n | }\ndefined trait Printable\nscala> \nscala> class BMW extends Car with SportCar with Printable{\n |    override val brand = \"BMW\"\n |    override def printIt:Unit = println(brand + \" does \" + run() )\n | }\ndefined class BMW\nscala> \nscala> val x1 = new BMW\nx1: BMW = BMW@22a71081\nscala> x1.printIt\nBMW does Rghhhhh Rghhhhh Rghhhhh....\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> trait SportCar {\n |    def run():String = \"Rghhhhh Rghhhhh Rghhhhh....\"\n | }\ndefined trait SportCar\nscala> \nscala> val bmw = new Object with SportCar\nbmw: SportCar = $anon$1@ed17bee\nscala> bmw.run\nres0: String = Rghhhhh Rghhhhh Rghhhhh....\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> type Email = String\ndefined type alias Email\nscala> \nscala> val e = new Email(\"me@mail.com.br\")\ne: String = me@mail.com.br\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> case class Person(name: String, age: Int)\ndefined class Person\nscala> val p = Person(\"Diego\",31)\np: Person = Person(Diego,31)\nscala> val p2 = Person(\"Diego\",32)\np2: Person = Person(Diego,32)\nscala> p.name\nres0: String = Diego\nscala> p.age\nres1: Int = 31\nscala> p == p \nres2: Boolean = true\nscala> p.toString\nres3: String = Person(Diego,31)\nscala> p.hashCode\nres4: Int = 668670772\nscala> p.equals(p2)\nres5: Boolean = false\nscala> p.equals(p)\nres6: Boolean = true\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> def resolve(choice:Int):String = choice match {\n |     case 1 => \"yes\"\n |     case 0 => \"no\"\n |     case _ => throw new IllegalArgumentException(\"Valid arguments are: 0 or 1\\. Your arg is: \n           \" + choice)\n | }\nresolve: (choice: Int)String\nscala> println(resolve(0))\nno\nscala> println(resolve(1))\nyes\nscala> try {\n |   println(resolve(33))\n | } catch{\n |   case e:Exception => println(\"Something Went Worng. EX: \" + e)\n | }\nSomething Went Worng. EX: java.lang.IllegalArgumentException: Valid arguments are: 0 or 1\\. Your arg is: 33\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> def factorial(n:Int):Int = n match {\n |     case 0 => 1\n |     case n => n * factorial(n - 1)\n | }\nfactorial: (n: Int)Int\nscala> \nscala> println(factorial(3))\n6\nscala> println(factorial(6))\n720\nscala> \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> trait Color\ndefined trait Color\nscala> case class Red(saturation: Int)   extends Color\ndefined class Red\nscala> case class Green(saturation: Int) extends Color\ndefined class Green\nscala> case class Blue(saturation: Int)  extends Color\ndefined class Blue\nscala> def matcher(arg:Any): String = arg match {\n |   case \"Scala\"                            => \"A Awesome Language\"\n |   case x: Int                               => \"An Int with value \" + x\n |   case Red(100)                        => \"Red sat 100\"\n |   case Red(_)                            => \"Any kind of RED sat\"\n |   case Green(s) if s == 233       => \"Green sat 233\"\n |   case Green(s)                          => \"Green sat \" + s\n |   case c: Color                           => \"Some Color: \" + c\n |   case w: Any                            => \"Whatever: \" + w\n | }\nmatcher: (arg: Any)String\nscala> println(matcher(\"Scala\"))\nA Awesome Language\nscala> println(matcher(1))\nAn Int with value 1\nscala> println(matcher(Red(100)))\nRed sat 100\nscala> println(matcher(Red(160)))\nAny kind of RED sat\nscala> println(matcher(Green(160)))\nGreen sat 160\nscala> println(matcher(Green(233)))\nGreen sat 233\nscala> println(matcher(Blue(111)))\nSome Color: Blue(111)\nscala> println(matcher(false))\nWhatever: false\nscala> println(matcher(new Object))\nWhatever: java.lang.Object@b56c222\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val positiveNumber = new PartialFunction[Int, Int] {\n |   def apply(n:Int) = n / n\n |   def isDefinedAt(n:Int) = n != 0\n | }\npositiveNumber: PartialFunction[Int,Int] = <function1>\nscala> \nscala> println( positiveNumber.isDefinedAt(6) )\ntrue\nscala> println( positiveNumber.isDefinedAt(0) )\nfalse\nscala> \nscala> println( positiveNumber(6) ) \n1\nscala> println( positiveNumber(0) ) \n java.lang.ArithmeticException: / by zero\n at $anon$1.apply$mcII$sp(<console>:12)\n ... 32 elided\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val positiveNumber:PartialFunction[Int, Int]  =  {\n |   case n: Int if n != 0 => n / n\n | }\npositiveNumber: PartialFunction[Int,Int] = <function1>\nscala> \nscala> println( positiveNumber.isDefinedAt(6) )\ntrue\nscala> println( positiveNumber.isDefinedAt(0) )\nfalse\nscala> \nscala> println( positiveNumber(6) ) \n1\nscala> println( positiveNumber(0) ) \nscala.MatchError: 0 (of class java.lang.Integer)\n at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)\n at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:251)\n at $anonfun$1.applyOrElse(<console>:11)\n at $anonfun$1.applyOrElse(<console>:11)\n at scala.runtime.AbstractPartialFunction$mcII$sp.apply$mcII$sp\n  (AbstractPartialFunction.scala:36)\n ... 32 elided\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> val even:PartialFunction[Int, String] = {\n |   case i if i%2 == 0 => \"even\"\n | }\neven: PartialFunction[Int,String] = <function1>\nscala> \nscala> val odd:PartialFunction[Int, String] = { case _ => \"odd\"}\nodd: PartialFunction[Int,String] = <function1>\nscala> \nscala> val evenOrOdd:(Int => String) = even orElse odd\nevenOrOdd: Int => String = <function1>\nscala> \nscala> println( evenOrOdd(1) == \"odd\"  )\ntrue\nscala> println( evenOrOdd(2) == \"even\" )\ntrue\nscala>\n\n```", "```java\n    package com.packait.scala.book \n\n    package object commons { \n\n      val PI = 3.1415926 \n\n      object constraintsHolder { \n        val ODD = \"Odd\" \n        val EVEN = \"Even\" \n      } \n\n      def isOdd(n:Int):String  = if (n%2==0) constraintsHolder.ODD else \n      null   \n\n      def isEven(n:Int):String = if (n%2!=0) constraintsHolder.EVEN \n      else null \n\n      def show(s:String) = println(s) \n\n    } \n\n```", "```java\n    package com.packait.scala.book.commons \n\n    object MainApp extends App { \n\n      show(\"PI is: \" + PI) \n      show(constraintsHolder.getClass.toString()) \n\n      show( isOdd(2) ) \n      show( isOdd(6) ) \n\n      show( isEven(3) ) \n      show( isEven(7) ) \n\n    } \n\n```", "```java\nPI is: 3.1415926\nclass com.packait.scala.book.commons.package$constraintsHolder$\nOdd\nOdd\nEven\nEven\n\n```", "```java\n    /*                     __                                               \n    *\\ \n    **     ________ ___   / /  ___     Scala API                            \n    ** \n    **    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             \n    ** \n    **  __\\ \\/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               \n    ** \n    ** /____/\\___/_/ |_/____/_/ | |                                         \n    ** \n    **                          |/                                          \n    ** \n    \\*                                                                      \n    */ \n\n    /** \n     * Core Scala types. They are always available without an explicit \n     import. \n     * @contentDiagram hideNodes \"scala.Serializable\" \n     */ \n    package object scala { \n      type Throwable = java.lang.Throwable \n      type Exception = java.lang.Exception \n      type Error     = java.lang.Error \n\n      type RuntimeException                = java.lang.RuntimeException \n      type NullPointerException            = \n      java.lang.NullPointerException \n      type ClassCastException              = \n      java.lang.ClassCastException \n      type IndexOutOfBoundsException       = \n      java.lang.IndexOutOfBoundsException \n      type ArrayIndexOutOfBoundsException  = \n      java.lang.ArrayIndexOutOfBoundsException \n      type StringIndexOutOfBoundsException = \n      java.lang.StringIndexOutOfBoundsException \n      type UnsupportedOperationException   = \n      java.lang.UnsupportedOperationException \n      type IllegalArgumentException        = \n      java.lang.IllegalArgumentException \n      type NoSuchElementException          = \n      java.util.NoSuchElementException \n      type NumberFormatException           = \n      java.lang.NumberFormatException \n      type AbstractMethodError             = \n      java.lang.AbstractMethodError \n      type InterruptedException            = \n      java.lang.InterruptedException \n\n      // A dummy used by the specialization annotation. \n      val AnyRef = new Specializable { \n        override def toString = \"object AnyRef\" \n      } \n\n      type TraversableOnce[+A] = scala.collection.TraversableOnce[A] \n\n      type Traversable[+A] = scala.collection.Traversable[A] \n      val Traversable = scala.collection.Traversable \n\n      type Iterable[+A] = scala.collection.Iterable[A] \n      val Iterable = scala.collection.Iterable \n\n      type Seq[+A] = scala.collection.Seq[A] \n      val Seq = scala.collection.Seq \n\n      type IndexedSeq[+A] = scala.collection.IndexedSeq[A] \n      val IndexedSeq = scala.collection.IndexedSeq \n\n      type Iterator[+A] = scala.collection.Iterator[A] \n      val Iterator = scala.collection.Iterator \n\n      type BufferedIterator[+A] = scala.collection.BufferedIterator[A] \n\n      type List[+A] = scala.collection.immutable.List[A] \n      val List = scala.collection.immutable.List \n\n      val Nil = scala.collection.immutable.Nil \n\n      type ::[A] = scala.collection.immutable.::[A] \n      val :: = scala.collection.immutable.:: \n\n      val +: = scala.collection.+: \n      val :+ = scala.collection.:+ \n\n      type Stream[+A] = scala.collection.immutable.Stream[A] \n      val Stream = scala.collection.immutable.Stream \n      val #:: = scala.collection.immutable.Stream.#:: \n\n      type Vector[+A] = scala.collection.immutable.Vector[A] \n      val Vector = scala.collection.immutable.Vector \n\n      type StringBuilder = scala.collection.mutable.StringBuilder \n      val StringBuilder = scala.collection.mutable.StringBuilder \n\n      type Range = scala.collection.immutable.Range \n      val Range = scala.collection.immutable.Range \n\n      // Numeric types which were moved into scala.math.* \n\n      type BigDecimal = scala.math.BigDecimal \n      val BigDecimal = scala.math.BigDecimal \n\n      type BigInt = scala.math.BigInt \n      val BigInt = scala.math.BigInt \n\n      type Equiv[T] = scala.math.Equiv[T] \n      val Equiv = scala.math.Equiv \n\n      type Fractional[T] = scala.math.Fractional[T] \n      val Fractional = scala.math.Fractional \n\n      type Integral[T] = scala.math.Integral[T] \n      val Integral = scala.math.Integral \n\n      type Numeric[T] = scala.math.Numeric[T] \n      val Numeric = scala.math.Numeric \n\n      type Ordered[T] = scala.math.Ordered[T] \n      val Ordered = scala.math.Ordered \n\n      type Ordering[T] = scala.math.Ordering[T] \n      val Ordering = scala.math.Ordering \n\n      type PartialOrdering[T] = scala.math.PartialOrdering[T] \n      type PartiallyOrdered[T] = scala.math.PartiallyOrdered[T] \n\n      type Either[+A, +B] = scala.util.Either[A, B] \n      val Either = scala.util.Either \n\n      type Left[+A, +B] = scala.util.Left[A, B] \n      val Left = scala.util.Left \n\n      type Right[+A, +B] = scala.util.Right[A, B] \n      val Right = scala.util.Right \n\n      // Annotations which we might move to annotation.* \n    /* \n      type SerialVersionUID = annotation.SerialVersionUID \n      type deprecated = annotation.deprecated \n      type deprecatedName = annotation.deprecatedName \n      type inline = annotation.inline \n      type native = annotation.native \n      type noinline = annotation.noinline \n      type remote = annotation.remote \n      type specialized = annotation.specialized \n      type transient = annotation.transient \n      type throws  = annotation.throws \n      type unchecked = annotation.unchecked.unchecked \n      type volatile = annotation.volatile \n      */ \n    } \n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> // Creates the numbers 1,2,3,4,5 and them multiply they by 2 and creates a new Vector\nscala> println ((1 to 5).map(_*2)) \nVector(2, 4, 6, 8, 10)\nscala> \nscala> // Creates 1,2,3 and sum them all with each orher and return the total\nscala> println ( (1 to 3).reduceLeft(_+_) )\n6\nscala> \nscala> // Creates 1,2,3 and multiply each number by it self and return a Vector\nscala> println ( (1 to 3).map( x=> x*x ) )\nVector(1, 4, 9)\nscala> \nscala> // Creates numbers 1,2,3,4 ans 5 filter only Odd numbers them multiply them odds by 2 and return a Vector\nscala> println ( (1 to 5) filter { _%2 == 0 } map { _*2 } )\nVector(4, 8)\nscala> \nscala> // Creates a List with 1 to 5 and them print each element being multiplyed by 2\nscala> List(1,2,3,4,5).foreach ( (i:Int) => println(i * 2 ) )\n2\n4\n6\n8\n10\nscala> \nscala> // Creates a List with 1 to 5 and then print each element being multiplied by 2\nscala> List(1,2,3,4,5).foreach ( i => println(i * 2) )\n2\n4\n6\n8\n10\nscala> \nscala> // Drops 3 elements from the lists\nscala> println( List(2,3,4,5,6).drop(3))\nList(5, 6)\nscala> println( List(2,3,4,5,6) drop 3 )\nList(5, 6)\nscala> \nscala> // Zip 2 lists into a single one: It will take 1 element of each list and create a pair List\nscala> println(  List(1,2,3,4).zip( List(6,7,8) )) \nList((1,6), (2,7), (3,8))\nscala> \nscala> // Take nested lists and create a single list with flat elements\nscala> println( List(List(1, 2), List(3, 4)).flatten )\nList(1, 2, 3, 4)\nscala> \nscala> // Finds a person in a List by Age\nscala> case class Person(age:Int,name:String)\ndefined class Person\nscala> println( List(Person(31,\"Diego\"),Person(40,\"Nilseu\")).find( (p:Person) => p.age <= 33 ) )\nSome(Person(31,Diego))\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> def sum(a:Int,b:Int) = a+b\nsum: (a: Int, b: Int)Int\nscala> \nscala> val add6 = sum(6,_:Int)\nadd6: Int => Int = <function1>\nscala> \nscala> println(add6(1))\n7\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> // Function Definition\nscala> def sum(x:Int)(y:Int):Int = x+y\nsum: (x: Int)(y: Int)Int\nscala> \nscala> // Function call - Calling a curried function \nscala> sum(2)(3)\nres0: Int = 5\nscala> \nscala> // Doing partial with Curried functions\nscala> val add3 = sum(3) _\nadd3: Int => Int = <function1>\nscala> \nscala> // Supply the last argument now\nscala> add3(3)\nres1: Int = 6\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> def normalSum(x:Int,y:Int):Int=x+y\nnormalSum: (x: Int, y: Int)Int\nscala> \nscala> val curriedSum = (normalSum _).curried\ncurriedSum: Int => (Int => Int) = <function1>\nscala> \nscala> val add3= curriedSum(3)\nadd3: Int => Int = <function1>\nscala> \nscala> println(add3(3))\n6\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> case class MyNumber(value:Int){\n | def +(that:MyNumber):MyNumber = new MyNumber(that.value + this.value)\n | def +(that:Int):MyNumber = new MyNumber(that + this.value)\n | }\ndefined class MyNumber\nscala> val v = new MyNumber(5)\nv: MyNumber = MyNumber(5)\nscala> \nscala> println(v)\nMyNumber(5)\nscala> println(v + v)\nMyNumber(10)\nscala> println(v + new MyNumber(4))\nMyNumber(9)\nscala> println(v + 8)\nMyNumber(13)\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> implicit def transformStringtoInt(n:String) = n.toInt\nwarning: there was one feature warning; re-run with -feature for details\ntransformStringtoInt: (n: String)Int\nscala> \nscala> val s:String = \"123456\"\ns: String = 123456\nscala> println(s)\n123456\nscala> \nscala> val i:Int = s\ni: Int = 123456\nscala> println(i)\n123456\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> implicit val yValue:Int = 6\nyValue: Int = 6\nscala> def sum(x:Int)(implicit yValue:Int) = x + yValue\nsum: (x: Int)(implicit yValue: Int)Int\nscala> val result = sum(10)\nresult: Int = 16\nscala> println(result)\n16\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> import concurrent.Future\nimport concurrent.Future\nscala> import concurrent.ExecutionContext.Implicits.global\nimport concurrent.ExecutionContext.Implicits.global\nscala> \nscala> val f: Future[String] = Future { \"Hello world!\" }\nf: scala.concurrent.Future[String] = Success(Hello world!)\nscala> \nscala> println(\"Result: \" + f.value.get.get)\nResult: Hello world!\nscala> \nscala> println(\"Result: \" + f)\nResult: Success(Hello world!)\nscala>\n\n```", "```java\n$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).\nType in expressions for evaluation. Or try :help.\nscala> import concurrent.Future\nimport concurrent.Future\nscala> import concurrent.ExecutionContext.Implicits.global\nimport concurrent.ExecutionContext.Implicits.global\nscala> import scala.util.{Success, Failure}\nimport scala.util.{Success, Failure}\nscala> def createFuture():Future[Int] = {\n | Future { \n | val r = scala.util.Random\n | if (r.nextInt(100)%2==0) 0 else throw new RuntimeException(\"ODD numbers are not good here :( \")\n | }\n | }\ncreateFuture: ()scala.concurrent.Future[Int]\nscala> def evaluateFuture(f:Future[_]) {\n | f.onComplete {\n | case Success(i) => println(s\"A Success $i \")\n | case Failure(e) => println(s\"Something went wrong. Ex: ${e.getMessage}\")\n | }\n | }\nevaluateFuture: (f: scala.concurrent.Future[_])Unit\nscala> evaluateFuture(createFuture)\nscala> Something went wrong. Ex: ODD numbers are not good here :( \nevaluateFuture(createFuture)\nA Success 0 \nscala> evaluateFuture(createFuture)\nSomething went wrong. Ex: ODD numbers are not good here :( \nscala> evaluateFuture(createFuture)\nSomething went wrong. Ex: ODD numbers are not good here :( \nscala> evaluateFuture(createFuture)\nA Success 0 \nscala> evaluateFuture(createFuture)\nA Success 0 \nscala>\n\n```", "```java\npackage scalabook.rx.chap1 \n\nimport rx.lang.scala.Observable \nimport scala.concurrent.duration._ \n\nobject SimpleRX extends App { \n\n  val o = Observable. \n            interval(100 millis). \n            take(5)             \n\n  o.subscribe( x => println(s\"Got it: $x\") )             \n  Thread.sleep(1000)           \n\n  Observable. \n      just(1, 2, 3, 4). \n      reduce(_+_). \n      subscribe( r => println(s\"Sum 1,2,3,4 is $r in a Rx Way\")) \n\n} \n\n```", "```java\nGot it: 0 \nGot it: 1 \nGot it: 2 \nGot it: 3 \nGot it: 4 \nSum 1,2,3,4 is 10 in a Rx Way \n\n```", "```java\npackage scalabook.rx.chap1 \n\nimport rx.lang.scala.Observable \n\nobject ComplexRxScala extends App { \n\n  Observable. \n      just(1,2,3,4,5,6,7,8,9,10).       // 1,2,3,4,5,6,7,8,9,10 \n      filter( x => x%2==0).             // 2,4,6,8,10 \n      take(2).                          // 2,4 \n      reduce(_+_).                      // 6 \n      subscribe( r => println(s\"#1 $r\")) \n\n   val o1 = Observable. \n            just(1,2,3,4,5,6,7,8,9,10).  // 1,2,3,4,5,6,7,8,9,10 \n            filter( x => x%2==0).        // 2, 4, 6, 8, 10 \n            take(3).                     // 2, 4 ,6     \n            map( n => n * n)             // 4, 16, 36 \n\n   val o2 = Observable.                  \n            just(1,2,3,4,5,6,7,8,9,10). // 1,2,3,4,5,6,7,8,9,10  \n            filter( x => x%2!=0).       // 1, 3, 5, 7, 9    \n            take(3).                    // 1, 3, 5 \n            map( n => n * n)            // 1, 9, 25 \n\n   val o3 = o1\\. \n           merge(o2).                  // 2,16, 36, 1, 9, 25 \n           subscribe( r => println(s\"#2 $r\")) \n\n} \n\n```"]