["```java\nval set = Set(1,2,3)\nval list = List(1,2,3)\n\nset == list // false\n\nset.iterator.sameElements(list) // true\n\nlist.sameElements(set) // true\n\n```", "```java\nscala> set.corresponds(list)(_ == _)\nres2: Boolean = true\nscala> list.corresponds(set)(_ == _)\nres3: Boolean = true\n```", "```java\nscala> List(1,2,3,4,5,6).flatMap(i => if (i<3) Set.fill(i)(i) else Seq.fill(i)(i))\nres28: List[Int] = List(1, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6)\n```", "```java\nscala> List(1,2,3,4,5).view.flatMap(List.fill(_)(\"a\")).map(_.toUpperCase).toList\nres33: List[String] = List(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)\n```", "```java\ndef factorial(n: Long): Long = {\n  def f(n: Long, acc: Long): Long = if (n < 2) acc else f(n-1, n * acc)\n  f(n,1)\n}\n```", "```java\nimport util.control.TailCalls._\ndef factorial(n: Long): TailRec[Long] = if (n<2) done(n) else tailcall(factorial(n-1)).map(_ * n)\n```", "```java\ntype ComparableContext[T] = T => Comparable[T]\ndef compare[T : ComparableContext](x: T, y: T) = x < y\n```", "```java\npackage object resolution {\n  // change // implicit val a: TS = new TS(\"val in package object\") // (1)\n  // to     //\n  implicit object TSO extends TS(\"object in package object\") // (1)\n}\n```", "```java\ndef invariant[T: Ordering: Arbitrary]: Prop =\n  forAll((l: List[T]) => l.sorted.length == l.length)\n\nscala> invariant[Long].check\n+ OK, passed 100 tests.\n\nscala> invariant[String].check\n+ OK, passed 100 tests.\n```", "```java\ndef idempotent[T: Ordering: Arbitrary]: Prop =\n  forAll((l: List[T]) => l.sorted.sorted == l.sorted)\n\nscala> idempotent[Long].check\n+ OK, passed 100 tests.\n\nscala> idempotent[String].check\n+ OK, passed 100 tests.\n```", "```java\ndef inductive[T: Ordering: Arbitrary]: Prop = {\n  def ordered(l: List[T]): Boolean =\n    (l.length < 2) || \n      (ordered(l.tail) && implicitly[Ordering[T]].lteq(l.head, l.tail.head))\n  forAll((l: List[T]) => ordered(l.sorted))\n}\n\nscala> inductive[Int].check\n+ OK, passed 100 tests.\n\nscala> inductive[String].check\n+ OK, passed 100 tests.\n```", "```java\nval genListListInt = Gen.listOf(Gen.listOf(Gen.posNum[Int]))\n\nscala> genListListInt.sample\nres35: Option[List[List[Int]]] = Some(List(List(60, 99, 5, 68, 52, 98, 31, 29, 30, 3, 91, 54, 88, 49, 97, 2, 92, 28, 75, 100, 100, 38, 16, 2, 86, 41, 4, 7, 43, 70, 21, 72, 90, 59, 69, 43, 88, 35, 57, 67, 88, 37, 4, 97, 51, 76, 69, 79, 33, 53, 18), List(85, 23, 4, 97, 7, 50, 36, 24, 94), List(97, 9, 25, 34, 29, 82, 59, 24, 94, 42, 34, 80, 7, 79, 44, 54, 61, 84, 32, 14, 9, 17, 95, 98), List(4, 70, 13, 18, 42, 74, 63, 21, 58, 4, 32, 61, 52, 77, 57, 40, 37, 54, 11), List(9, 22, 33, 19, 56, 29, 45, 34, 61, 48, 42, 56, 64, 96, 56, 77, 58, 90, 30, 48, 32, 49, 80, 58, 65, 5, 24, 88, 27, 44, 15, 5, 65, 11, 14, 80, 30, 5, 23, 31, 38, 55, 1, 94, 15, 89, 69, 23, 35, 45, 38, 96, 11, 35, 22, 90, 46, 39, 69, 11, 26, 53, 18, 23, 8, 85, 22, 12, 49, 79, 63, 39, 1, 89, 68, 91, 24...\n```", "```java\nval pairGen = for {\n  uuid <- Gen.uuid\n  function0 <- Gen.function0(Gen.asciiStr)\n} yield (uuid, function0)\n\nval mapGen = Gen.mapOf(pairGen)\nmapGen: org.scalacheck.Gen[Map[java.util.UUID,() => String]] = org.scalacheck.Gen$$anon$1@16ca4e8d\n\nscala> mapGen.sample\nres36: Option[Map[java.util.UUID,() => String]] = Some(Map(31395a9b-78af-4f4a-9bf3-c19b3fb245b6 -> org.scalacheck.Gen$$$Lambda$2361/1400300928@178b18c, ...\n```", "```java\nTry[Int](throw new OutOfMemoryError()).filter(_ > 10).recover {\n  case _: OutOfMemoryError => 100\n}(20)\n```", "```java\nFuture[Int](throw new OutOfMemoryError()).filter(_ > 10).recover {\n  case _: OutOfMemoryError => 100\n}\n```", "```java\ndef either(i: Int): Boolean = \n  Either.cond(i > 10, i * 10, new IllegalArgumentException(\"Give me more\")).forall(_ < 100)\n```", "```java\nimplicit val booleanOr: Monoid[Boolean] = new Monoid[Boolean] {\n  override def identity: Boolean = false\n  override def op(l: Boolean, r: Boolean): Boolean = l || r\n}\n```", "```java\nproperty(\"boolean under or\") = {\n  import Assessment.booleanOr\n  monoidProp[Boolean]\n}\n```", "```java\nimplicit val booleanAnd: Monoid[Boolean] = new Monoid[Boolean] {\n  override def identity: Boolean = true\n  override def op(l: Boolean, r: Boolean): Boolean = l && r\n}\n```", "```java\nproperty(\"boolean under and\") = {\n  import Assessment.booleanAnd\n  monoidProp[Boolean]\n}\n```", "```java\nimplicit def option[A : Monoid]: Monoid[Option[A]] = new Monoid[Option[A]] {\n  override def identity: Option[A] = None\n  override def op(l: Option[A], r: Option[A]): Option[A] = (l, r) match {\n    case (Some(la), Some(lb)) => Option(implicitly[Monoid[A]].op(la, lb))\n    case _ => l orElse r\n  }\n}\n```", "```java\nproperty(\"Option[Int] under addition\") = {\n  import Monoid.intAddition\n  import Assessment.option\n  monoidProp[Option[Int]]\n}\n\nproperty(\"Option[String] under concatenation\") = {\n  import Monoid.stringConcatenation\n  import Assessment.option\n  monoidProp[Option[String]]\n}\n```", "```java\ndef either[L, R : Monoid]: Monoid[Either[L, R]] = new Monoid[Either[L, R]] {\n  private val ma = implicitly[Monoid[R]]\n  override def identity: Either[L, R] = Right(ma.identity)\n  override def op(l: Either[L, R], r: Either[L, R]): Either[L, R] = (l, r) match {\n    case (l @ Left(_), _) => l\n    case (_, l @ Left(_)) => l\n    case (Right(la), Right(lb)) => Right(ma.op(la, lb))\n  }\n}\n```", "```java\nproperty(\"Either[Int] under multiplication\") = {\n  import Monoid.intMultiplication\n  implicit val monoid: Monoid[Either[Unit, Int]] = Assessment.either[Unit, Int]\n  monoidProp[Either[Unit, Int]]\n}\n\nproperty(\"Either[Boolean] under OR\") = {\n  import Assessment.booleanOr\n  implicit val monoid: Monoid[Either[String, Boolean]] = Assessment.either[String, Boolean]\n  monoidProp[Either[String, Boolean]]\n}\n```", "```java\nimplicit val tryFunctor: Functor[Try] = new Functor[Try] {\n  override def map[A, B](in: Try[A])(f: A => B): Try[B] = in.map(f)\n  override def mapC[A, B](f: A => B): Try[A] => Try[B] = fa => map(fa)(f)\n}\n```", "```java\nimplicit val tryApplicative: Applicative[Try] = new Applicative[Try] {\n  override def apply[A, B](a: Try[A])(f: Try[A => B]): Try[B] = (a, f) match {\n    case (Success(a), Success(f)) => Try(f(a))\n    case (Failure(ex), _) => Failure(ex)\n    case (_, Failure(ex)) => Failure(ex)\n  }\n  override def unit[A](a: => A): Try[A] = Success(a)\n}\n```", "```java\nimplicit def eitherApplicative[L] = new Applicative[({ type T[A] = Either[L, A] })#T] {\n  override def apply[A, B](a: Either[L, A])(f: Either[L, A => B]): Either[L, B] = (a, f) match {\n    case (Right(a), Right(f)) => Right(f(a))\n    case (Left(l), _) => Left(l)\n    case (_, Left(l)) => Left(l)\n  }\n  override def unit[A](a: => A): Either[L, A] = Right(a)\n}\n```", "```java\nimplicit val tryTraversable = new Traversable[Try] {\n  override def map[A, B](in: Try[A])(f: A => B): Try[B] = Functor.tryFunctor.map(in)(f)\n  override def traverse[A, B, G[_] : Applicative](a: Try[A])(f: A => G[B]): G[Try[B]] = {\n    val G = implicitly[Applicative[G]]\n    a match {\n      case Success(s) => G.map(f(s))(Success.apply)\n      case Failure(ex) => G.unit(Failure(ex)) // re-wrap the ex to change the type of Failure\n    }\n  }\n}\n```", "```java\nimplicit def eitherTraversable[L] = new Traversable[({ type T[A] = Either[L, A] })#T] {\n  override def map[A, B](in: Either[L, A])(f: A => B): Either[L, B] = \n    Functor.eitherFunctor[L].map(in)(f)\n  override def traverse[A, B, G[_] : Applicative](a: Either[L, A])(f: A => G[B]): G[Either[L, B]] = {\n    val G = implicitly[Applicative[G]]\n    a match {\n      case Right(s) => G.map(f(s))(Right.apply)\n      case Left(l) => G.unit(Left(l)) // re-wrap the l to change the type of Failure\n    }\n  }\n}\n```", "```java\ntrait Traversable[F[_]] extends Functor[F] {\n  def traverse[A,B,G[_]: Applicative](a: F[A])(f: A => G[B]): G[F[B]]\n  def sequence[A,G[_]: Applicative](a: F[G[A]]): G[F[A]] = traverse(a)(identity)\n\n  def compose[H[_]](implicit H: Traversable[H]): Traversable[({type f[x] = F[H[x]]})#f] = {\n    val F = this\n    new Traversable[({type f[x] = F[H[x]]})#f] {\n      override def traverse[A, B, G[_] : Applicative](fa: F[H[A]])(f: A => G[B]) =\n        F.traverse(fa)((ga: H[A]) => H.traverse(ga)(f))\n\n      override def map[A, B](in: F[H[A]])(f: A => B): F[H[B]] =\n        F.map(in)((ga: H[A]) => H.map(ga)(f))\n    }\n  }\n}\n```", "```java\nimplicit val tryMonad = new Monad[Try] {\n  override def unit[A](a: => A): Try[A] = Success(a)\n\n  override def flatMap[A, B](a: Try[A])(f: A => Try[B]): Try[B] = a match {\n    case Success(value) => f(value)\n    case Failure(ex) => Failure(ex)\n  }\n}\n```", "```java\nval rightIdentity = forAll { (a: A, f: A => M[B]) =>\n  M.flatMap(M.unit(a))(f) == f(a)\n}\n```", "```java\nState(s => { \n  val (a, nextState) = (a, s)\n  f(a).run(nextState)\n}\n```", "```java\nimport Monad.optionMonad\n\ndef go(speed: Float, time: Float)(boat: Boat): Option[Boat] = \n  if (Random.nextInt(100) == 0) None\n  else Option(boat.go(speed, time))\n\nprintln(move(go, turn[Option])(Option(boat)))\n```", "```java\nimport Monad.tryMonad\n\ndef go(speed: Float, time: Float)(boat: Boat): Try[Boat] =\n  if (Random.nextInt(100) == 0) Failure(new Exception(\"Motor malfunction\"))\n  else Success(boat.go(speed, time))\n\nprintln(move(go, turn[Try])(Success(boat)))\n```", "```java\nimport Monad.eitherMonad\ntype ErrorOr[B] = Either[String, B]\n\ndef go(speed: Float, time: Float)(boat: Boat): ErrorOr[Boat] =\n  if (Random.nextInt(100) == 0) Left(\"Motor malfunction\")\n  else Right(boat.go(speed, time))\n\nprintln(move(go, turn[ErrorOr])(Right(boat)))\n```", "```java\nobject WriterOptionExample extends App {\n  type WriterOption[B] = Writer[Vector[(Double, Double)], Option[B]]\n  import WriterExample.vectorMonoid\n\n  // this implementation delegates to the logic we've implemented in the chapter\n  def go(speed: Float, time: Float)(boat: Boat): WriterOption[Boat] = {\n    val b: Option[Boat] = OptionExample.go(speed, time)(boat)\n    val c: WriterTracking[Boat] = WriterExample.go(speed, time)(boat)\n    Writer((b, c.run._2))\n  }\n\n  // constructor - basically unit for the combined monad\n  private def writerOption[A](a: A) =\n    Writer[Vector[(Double, Double)], Option[A]](Option(a))\n\n  // we need a monad of the appropriate type\n  implicit val readerWriterMonad = new Monad[WriterOption] {\n    override def flatMap[A, B](wr: WriterOption[A])(f: A => WriterOption[B]): WriterOption[B] =\n      wr.compose {\n        case Some(a) => f(a)\n        case None => Writer(Option.empty[B])\n      }\n\n    override def unit[A](a: => A): WriterOption[A] = writerOption(a)\n  }\n  // tracks boat movement until it is done navigating or sank\n  println(move(go, turn)(writerOption(boat)).run)\n}\n```", "```java\nprivate def noResultTryT[F[_] : Monad, T](ex: Throwable): F[Try[T]] = \n  Monad[F].unit(Failure[T](ex))\n\nimplicit class TryT[F[_] : Monad, A](val value: F[Try[A]]) {\n  def compose[B](f: A => TryT[F, B]): TryT[F, B] = {\n    val result = value.flatMap {\n      case Failure(ex) => noResultTryT[F, B](ex)\n      case Success(a) => f(a).value\n    }\n    new TryT(result)\n  }\n\n  def isSuccess: F[Boolean] = Monad[F].map(value)(_.isSuccess)\n}\n\ndef tryTunit[F[_] : Monad, A](a: => A) = new TryT(Monad[F].unit(Try(a)))\n\nimplicit def TryTMonad[F[_] : Monad]: Monad[TryT[F, ?]] = new Monad[TryT[F, ?]] {\n  override def unit[A](a: => A): TryT[F, A] = Monad[F].unit(Monad[Try].unit(a))\n  override def flatMap[A, B](a: TryT[F, A])(f: A => TryT[F, B]): TryT[F, B] = a.compose(f)\n}\n```", "```java\nobject Ch10FutureTryFishing extends FishingApi[TryT[Future, ?]] with App {\n  val buyBateImpl: String => Future[Bate] = ???\n  val castLineImpl: Bate => Try[Line] = ???\n  val hookFishImpl: Line => Future[Fish] = ???\n\n  override val buyBate: String => TryT[Future, Bate] = \n    (name: String) => buyBateImpl(name).map(Try(_))\n  override val castLine: Bate => TryT[Future, Line] = \n    castLineImpl.andThen(Future.successful(_))\n  override val hookFish: Line => TryT[Future, Fish] = \n    (line: Line) => hookFishImpl(line).map(Try(_))\n\n  val result: Future[Try[Fish]] = goFishing(tryTunit[Future, String](\"Crankbait\")).value\n}\n```", "```java\ntype Inner[A] = OptionT[Future, A]\ntype Outer[F[_], A] = EitherT[F, String, A]\ntype Stack[A] = Outer[Inner, A]\n\nobject Ch10EitherTOptionTFutureFishing extends FishingApi[Stack[?]] with App {\n\n  val buyBateImpl: String => Future[Bate] = ???\n  val castLineImpl: Bate => Either[String, Line] = ???\n  val hookFishImpl: Line => Future[Fish] = ???\n\n  override val castLine: Bate => Stack[Line] =\n    (bate: Bate) => new OptionT(Future.successful(Option(castLineImpl(bate))))\n\n  override val buyBate: String => Stack[Bate] =\n    (name: String) => new OptionT(buyBateImpl(name).map(l => Option(Right(l)): Option[Either[String, Bate]]))\n\n  override val hookFish: Line => Stack[Fish] =\n    (line: Line) => new OptionT(hookFishImpl(line).map(l => Option(Right(l)): Option[Either[String, Fish]]))\n\n  val input: EitherT[Inner, String, String] = eitherTunit[Inner, String, String](\"Crankbait\")\n  val outerResult: Inner[Either[String, Fish]] = goFishing(input).value\n  val innerResult: Future[Option[Either[String, Fish]]] = outerResult.value\n\n}\n```", "```java\nfinal case class ReleaseFish[A](fish: Fish, f: Unit => A) extends Action[A]\n\ndef releaseFish(fish: Fish): Free[Action, Unit] = Join(ReleaseFish(fish, _ => Done(())))\n\nimplicit val actionFunctor: Functor[Action] = new Functor[Action] {\n  override def map[A, B](in: Action[A])(f: A => B): Action[B] = in match {\n    ... // other actions as before  \n    case ReleaseFish(fish, a) => ReleaseFish(fish, x => f(a(x)))\n  }\n}\n\ndef catchFish(bateName: String): Free[Action, _] = for {\n    bate <- buyBate(bateName)\n    line <- castLine(bate)\n    fish <- hookFish(line)\n    _ <- releaseFish(fish)\n} yield ()\n\ndef goFishingLogging[A](actions: Free[Action, A], unit: Unit): A = actions match {\n    ... // the rest as in the chapter code\n    case Join(ReleaseFish(fish, f)) =>\n      goFishingLogging(f(()), log(s\"Releasing the fish $fish\"))\n}\n\ndef goFishingAcc[A](actions: Free[Action, A], log: List[AnyVal]): List[AnyVal] = actions match {\n    ...\n    // the rest as in the chapter code\n    case Join(ReleaseFish(fish, f)) =>\n      goFishingAcc(f(()), fish.copy(name = fish.name + \" released\") :: log)\n}\n```", "```java\ndef getArticle(name: String): Stream[IO, Inventory] =\n  sql\"SELECT name, count FROM article where name = $name\"\n    .query[(String, Int)].stream.transact(transactor)\n    .fold(Map.empty[String, Int])(_ + _)\n```", "```java\nfinal case class GetArticle(name: String) extends Query\n```", "```java\ncase GetArticle(name) =>\n  sender() ! Inventory(inventory.state.filter(_._1 == name))\n```", "```java\n  pathPrefix(\"articles\") {\n      path(Segment) { name =>\n          get {\n            complete((inventory ? GetArticle(name)).mapTo[Inventory])\n          }\n      }\n  }\n```", "```java\ndef answer(parameter: Int): ServiceCall[NotUsed, Done]\n\noverride def descriptor: Descriptor = {\n  import Service._\n  named(\"Answer\").withCalls(\n    restCall(Method.POST, \"/answer?parameter\", answer _)\n  )\n}\n```", "```java\ntrait ManagerCommand\nfinal case class AddCookies(count: Int) extends ManagerCommand with ReplyType[Int]\nfinal case class RemoveCookies(count: Int) extends ManagerCommand with ReplyType[Int]\n\ntrait ManagerEvent\nfinal case class NumberOfCookiesChanged(count: Int) extends ManagerEvent with AggregateEvent[NumberOfCookiesChanged] {\n  override def aggregateTag: AggregateEventTag[NumberOfCookiesChanged] = AggregateEventTag[NumberOfCookiesChanged](\"NumberOfCookiesChanged\")\n}\nsealed trait ManagerState {\n  def cookies: Int\n}\nfinal case class MixingState(cookies: Int) extends ManagerState\n```"]