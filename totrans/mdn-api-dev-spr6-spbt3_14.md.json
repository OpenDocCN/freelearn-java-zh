["```java\n// update following build.gradle filesourceCompatibility = JavaVersion.VERSION_17\n// or for Java 20\n// sourceCompatibility = JavaVersion.VERSION_20\n// or for Java 21\n// sourceCompatibility = JavaVersion.VERSION_20\n```", "```java\n plugins {    id 'org.springframework.boot' version '3.0.6'\n    id 'io.spring.dependency-management' version '1.1.0'\n    id 'java'\n    id 'com.netflix.dgs.codegen' version '5.7.1'\n }\n // code truncated for brevity\n def dgsVersion = '6.0.5'\n dependencies {\n    implementation platform(\"com.netflix.graphql.\n        dgs:graphql-dgs-platform-dependencies:${\n        dgsVersion}\")\n    implementation 'com.netflix.graphql.dgs:graphql-dgs-\n        spring-boot-starter'\n    implementation 'com.netflix.graphql.dgs:graphql-dgs-\n        extended-scalars'\n    implementation 'com.netflix.graphql.dgs:graphql-dgs-\n        spring-boot-micrometer'\n    runtimeOnly 'com.netflix.graphql.dgs:graphql-dgs-\n        subscriptions-websockets-autoconfigure'\n    implementation 'org.springframework.boot:spring-boot-\n        starter-web'\n    implementation 'org.springframework.boot:spring-boot-\n        starter-actuator'\n    testImplementation 'org.springframework.boot:\n        spring-boot-starter-test'\n    implementation 'net.datafaker:datafaker:1.9.0'\n }\n```", "```java\n generateJava {     generateClient = true\n     packageName = \"com.packt.modern.api.generated\"\n }\n```", "```java\norg.hidetake.swagger. generator Gradle plugin while generating the Java code from OpenAPI specs in *step 4* of the *Converting OAS to Spring code* section in *Chapter 3*, *API Specifications and Implementation*. To add a custom type mapping, you can add the typeMapping property to the plugin task, as shown next:\n\n```", "```java\n\n This property accepts an array; you can add one or more type mappings here. You can refer to the plugin documentation at [https://netflix.github.io/dgs/generating-code-from-schema/](https://netflix.github.io/dgs/generating-code-from-schema/) for more information.\nLet’s add the GraphQL schema next.\nAdding the GraphQL schema\nNetflix’s DGS supports both the code-first and design-first approaches. However, we are going to use the design-first approach in this chapter as we have done throughout this book. Therefore, first, we’ll design the schema using the GraphQL schema language and then use the generated code to implement the GraphQL APIs.\nWe are going to keep the domain objects minimal to reduce the complexity of business logic and keep the focus on the GraphQL server implementation. Therefore, you’ll have just two domain objects – `Product` and `Tag`. The GraphQL schema allows the following operation using its endpoint as shown in the following schema definition:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/schema/schema.graphqls](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/schema/schema.graphqls)\nYou need to add the `schema.graphqls` GraphQL schema file at the `src/main/ resources/schema` location. You can have multiple schema files there to create the schema module-wise.\nHere, the following root types have been exposed:\n\n*   `Query`: The product and product queries to fetch a product by its ID, and a collection of products matched by the given criteria.\n*   `Mutation`: The `addTag` mutation adds a tag to the product that matches the given ID. Another mutation, `addQuantity`, increases the product quantity. The `addQuantity` mutation can also be used as an event that triggers the subscription publication.\n*   `Subscription`: The `quantityChanged` subscription publishes the product where the quantity has been updated. The event quantity change is captured through the `addQuantity` mutation.\n\nLet’s add the object types and input types being used in these root types to `schema. graphqls` as shown in the next code block:\n\n```", "```java\n\nThese are straightforward object and input types. All fields of the `ProductCriteria` input type have been kept optional.\nWe have also used a `BigDecimal` custom scalar type. Therefore, we need to first declare it in the schema. We can do that by adding `BigDecimal` to the end of the schema file, as shown next:\n\n```", "```java\ngenerateJava {    generateClient = true\n    packageName = \"com.packt.modern.api.generated\"\n    typeMapping = [\"BigDecimal\": \"java.math.BigDecimal\"]\n}\n```", "```java\n $ ./gradlew clean build\n```", "```java\n@DgsScalar(name=\"DateTime\")public class DateTimeScalar\n               implements Coercing<LocalDateTime, String> {\n  @Override\n  public String serialize(Object dataFetcherResult)\n                throws CoercingSerializeException {\n    if (dataFetcherResult instanceof LocalDateTime) {\n      return ((LocalDateTime) dataFetcherResult)\n            .format(DateTimeFormatter.ISO_DATE_TIME);\n    } else {\n      throw new CoercingSerializeException\n          (\"Invalid Dt Tm\");\n    }\n  }\n  @Override\n  public LocalDateTime parseValue(Object input)\n        throws CoercingParseValueException {\n    return LocalDateTime.parse(input.toString(),\n        DateTimeFormatter.ISO_DATE_TIME);\n  }\n  @Override\n  public LocalDateTime parseLiteral(Object input)\n       throws CoercingParseLiteralException {\n    if (input instanceof StringValue) {\n      return LocalDateTime.parse(((StringValue) input)\n          .getValue(), DateTimeFormatter.ISO_DATE_TIME);\n    }\n    throw new CoercingParseLiteralException\n        (\"Invalid Dt Tm\");\n  }\n}\n```", "```java\n@DgsComponentpublic class BigDecimalScalar {\n  @DgsRuntimeWiring\n  public RuntimeWiring.Builder addScalar(\n      RuntimeWiring.Builder builder) {\n    return builder.scalar(GraphQLBigDecimal);\n  }\n}\n```", "```java\npublic interface Repository {  Product getProduct(String id);\n  List<Product> getProducts();\n}\n```", "```java\n@org.springframework.stereotype.Repositorypublic class InMemRepository implements Repository {\n  private static final Map<String, Product>\nproductEntities = new ConcurrentHashMap<>();\n  private static final Map<String, Tag> tagEntities =\n      new ConcurrentHashMap<>();\n  // rest of the code is truncated\n```", "```java\npublic InMemRepository() {  Faker faker = new Faker();\n  IntStream.range(0, faker.number()\n      .numberBetween(20, 50)).forEach(number -> {\n    String tag = faker.book().genre();\n    tagEntities.putIfAbsent(tag,\n       Tag.newBuilder().id(UUID.randomUUID().toString())\n         .name(tag).build());\n  });\n  IntStream.range(0, faker.number().numberBetween(4, 20))\n    .forEach(number -> {\n      String id = String.format(\"a1s2d3f4-%d\", number);\n      String title = faker.book().title();\n      List<Tag> tags = tagEntities.entrySet().stream()\n        .filter(t -> t.getKey().startsWith(\n          faker.book().genre().substring(0, 1)))\n        .map(Entry::getValue).collect(toList());\n    if (tags.isEmpty()) {\n     tags.add(tagEntities.entrySet().stream()\n       .findAny().get().getValue());\n    }\n    Product product = Product.newBuilder().id(id).\n        name(title)\n      .description(faker.lorem().sentence())\n      .count(faker.number().numberBetween(10, 100))\n      .price(BigDecimal.valueOf(faker.number()\n         .randomDigitNotZero()))\n      .imageUrl(String.format(\"/images/%s.jpeg\",\n         title.replace(\" \", \"\")))\n      .tags(tags).build();\n    productEntities.put(id, product);\n  });\n  // rest of the code is truncated\n```", "```java\n@Overridepublic Product getProduct(String id) {\n  if (Strings.isBlank(id)) {\n    throw new RuntimeException(\"Invalid Product ID.\");\n  }\n  Product product = productEntities.get(id);\n  if (Objects.isNull(product)) {\n    throw new RuntimeException(\"Product not found.\");\n  }\n  return product;\n}\n@Override\npublic List<Product> getProducts() {\n  return productEntities.entrySet().stream()\n    .map(e -> e.getValue()).collect(toList());\n}\n```", "```java\npublic interface ProductService {  Product getProduct(String id);\n  List<Product> getProducts(ProductCriteria criteria);\n  Product addQuantity(String productId, int qty);\n  Publisher<Product> gerProductPublisher();\n}\n```", "```java\n@Servicepublic class ProductServiceImpl implements ProductService {\n  private final Repository repository;\n  public ProductServiceImpl(Repository repository) {\n    this.repository = repository;\n  }\n  @Override\n  public Product getProduct(String id) {\n    return repository.getProduct(id);\n  }\n  // continue …\n```", "```java\n@Overridepublic List<Product> getProducts(ProductCriteria criteria) {\n  List<Predicate<Product>> predicates = new ArrayList<>(2);\n  if (!Objects.isNull(criteria)) {\n    if (Strings.isNotBlank(criteria.getName())) {\n      Predicate<Product> namePredicate =\n        p -> p.getName().contains(criteria.getName());\n      predicates.add(namePredicate);\n    }\n    if (!Objects.isNull(criteria.getTags()) &&\n        !criteria.getTags().isEmpty()) {\n      List<String> tags = criteria.getTags().stream()\n        .map(ti -> ti.getName()).collect(toList());\n      Predicate<Product> tagsPredicate =\n        p -> p.getTags().stream().filter(\n          t -> tags.contains(t.getName())).count() > 0;\n      predicates.add(tagsPredicate);\n    }\n  }\n  if (predicates.isEmpty()) {\n    return repository.getProducts();\n  }\n  return repository.getProducts().stream()\n    .filter(p -> predicates.stream().allMatch(\n      pre -> pre.test(p))).collect(toList());\n}\n```", "```java\n@DgsComponentpublic class ProductDatafetcher {\n  private final ProductService productService;\n  public ProductDatafetcher(\n      ProductService productService) {\n    this.productService = productService;\n  }\n  @DgsData(parentType = DgsConstants.QUERY_TYPE,\n           field = QUERY.Product)\n  public Product getProduct(@InputArgument(\"id\") String id) {\n    if (Strings.isBlank(id)) {\n      new RuntimeException(\"Invalid Product ID.\");\n    }\n    return productService.getProduct(id);\n  }\n  // continue …\n```", "```java\n@DgsComponentpublic class ProductsDatafetcher {\n  private ProductService service;\n  public ProductsDatafetcher(ProductService service) {\n    this.service = service;\n  }\n  @DgsData(\n    parentType = DgsConstants.QUERY_TYPE,\n    field = QUERY.Products\n  )\n  public List<Product> getProducts(@InputArgument(\"filter\")\n      ProductCriteria criteria) {\n    return service.getProducts(criteria);\n  }\n // continue …\n```", "```java\n $ gradlew clean build\n```", "```java\n $ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar\n```", "```java\n{  products(\n    filter: {name: \"His Dark Materials\",\n       tags: [{name: \"Fantasy\"}, {name: \"Legend\"}]}\n  ) {\n    id\n    name\n    price\n    description\n    tags {\n      id\n      name\n    }\n  }\n}\n```", "```java\n@DgsData(    parentType = PRODUCT.TYPE_NAME,\n    field = PRODUCT.Tags\n)\npublic List<Tags> tags(String productId) {\n  return tagService.fetch(productId);\n}\n```", "```java\n @DgsData(   parentType = PRODUCT.TYPE_NAME,\n   field = PRODUCT.Tags\n )\n public CompletableFuture<List<Tags>> tags(\n     DgsDataFetchingEnvironment env) {\n   DataLoader<String, List<Tags>> tagsDataLoader =\n       env.getDataLoader(TagsDataloaderWithContext.class);\n   Product product = env.getSource();\n   return tagsDataLoader.load(product.getId());\n }\n```", "```java\n CompletionStage<Map<K, V>> load(Set<K> keys);\n```", "```java\n CompletionStage<Map<K, V>> load(Set<K> keys,                         BatchLoaderEnvironment environment);\n```", "```java\n@DgsDataLoader(name = \"tagsWithContext\")public class TagsDataloaderWithContext implements\n          MappedBatchLoaderWithContext<String, List<Tag>> {\n  private final TagService tagService;\n  public TagsDataloaderWithContext(TagService tagService) {\n    this.tagService = tagService;\n  }\n  @Override\n  public CompletionStage<Map<String, List<Tag>>> load(\n    Set<String> keys, BatchLoaderEnvironment environment) {\n    return CompletableFuture.supplyAsync(() ->\n        tagService.getTags(new ArrayList<>(keys)));\n  }\n}\n```", "```java\npublic interface TagService {  Map<String, List<Tag>> getTags(List<String> productIds);\n}\n```", "```java\n@Servicepublic class TagServiceImpl implements TagService {\n  private final Repository repository;\n  public TagServiceImpl(Repository repository) {\n    this.repository = repository;\n  }\n  @Override\n  public Map<String, List<Tag>> getTags(\n       List<String> productIds) {\n    return repository.getProductTagMappings(productIds);\n  }\n  @Override\n  public Product addTags(\n       String productId, List<TagInput> tags) {\n    return repository.addTags(productId, tags);\n  }\n}\n```", "```java\nMap<String, List<Tag>> getProductTagMappings(     List<String> productIds);\n```", "```java\n@Overridepublic Map<String, List<Tag>> getProductTagMappings(\n     List<String> productIds) {\n  return productEntities.entrySet().stream()\n    .filter(e -> productIds.contains(e.getKey()))\n    .collect(toMap(e -> e.getKey(),\n       e -> e.getValue().getTags()));\n}\n```", "```java\n// rest of the ProductDatafetcher class code@DgsMutation(field = MUTATION.AddTag)\npublic Product addTags(\n    @InputArgument(\"productId\") String productId,\n    @InputArgument(value = \"tags\", collectionType =\n         TagInput.class) List<TagInput> tags) {\n  return tagService.addTags(productId, tags);\n}\n@DgsMutation(field = MUTATION.AddQuantity)\npublic Product addQuantity(\n      @InputArgument(\"productId\") String productId,\n      @InputArgument(value = \"quantity\") int qty) {\n  return productService.addQuantity(productId, qty);\n}\n// rest of the ProductDatafetcher class code\n```", "```java\n// rest of the ProductDatafetcher class codeprivate final TagService tagService;\npublic ProductDatafetcher(ProductService productService,\n     TagService tagService) {\n  this.productService = productService;\n  this.tagService = tagService;\n}\n// rest of the ProductDatafetcher class code\n```", "```java\n // rest of the Repository class code Product addTags(String productId, List<TagInput> tags);\n Product addQuantity(String productId, int qty);\n // rest of the Repository class code\n```", "```java\n@Overridepublic Product addTags(String productId, List<TagInput> tags) {\n  if (Strings.isBlank(productId)) {\n    throw new RuntimeException(\"Invalid Product ID.\");\n  }\n  Product product = productEntities.get(productId);\n  if (Objects.isNull(product)) {\n    throw new RuntimeException(\"Product not found.\");\n  }\n  if (tags != null && !tags.isEmpty()) {\n    List<String> newTags = tags.stream().map(\n         t -> t.getName()).collect(toList());\n    List<String> existingTags = product.getTags().stream()\n         .map(t -> t.getName())\n         .collect(toList());\n    newTags.stream().forEach(nt -> {\n      if (!existingTags.contains(nt)) {\n        product.getTags().add(Tag.newBuilder()\n          .id(UUID.randomUUID().toString())\n        .name(nt).build());\n      }\n    });\n    productEntities.put(product.getId(), product);\n  }\n  return product;\n}\n```", "```java\n $ gradlew clean build\n```", "```java\n $ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar\n```", "```java\nmutation {   addTag(productId: \"a1s2d3f4-0\",\n          tags: [{name: \"new Tags...\"}]) {\n     id\n     name\n     price\n     description\n     tags {\n       id\n       name\n     }\n   }\n }\n```", "```java\nmutation {   addQuantity(productId: \"a1s2d3f4-0\", quantity: 10) {\n     id\n     name\n     description\n     price\n     count\n     tags {\n       id\n       name\n     }\n   }\n }\n```", "```java\nmanagement.endpoints.web.exposure.include=health,metricsgraphql.servlet.actuator-metrics=true\ngraphql.servlet.tracing-enabled=false\ngraphql.servlet.corsEnabled=true\n```", "```java\n// rest of the ProductDatafetcher class code @DgsSubscription(field = SUBSCRIPTION.QuantityChanged)public Publisher<Product> quantityChanged(\n    @InputArgument(\"productId\") String productId) {\n  return productService.gerProductPublisher();\n}\n// rest of the ProductDatafetcher class code\n```", "```java\n    Publisher<Product> getProductPublisher();\n    ```", "```java\n    public Publisher<Product> getProductPublisher() {  return productPublisher;}\n    ```", "```java\n    private InMemRepository constructor, as shown in the following code:\n\n    ```", "```java\n\n    ```", "```java\n    product.setCount(product.getCount() + qty);productEntities.put(product.getId(), product);productsStream.next(product);return product;\n    ```", "```java\n $ gradlew clean build\n```", "```java\n $ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar\n```", "```java\nobject MessageType {    const val CONNECTION_INIT = \"connection_init\"\n    const val CONNECTION_ACK = \"connection_ack\"\n    const val PING = \"ping\"\n    const val PONG = \"pong\"\n    const val SUBSCRIBE = \"subscribe\"\n    const val NEXT = \"next\"\n    const val ERROR = \"error\"\n    const val COMPLETE = \"complete\"\n}\n```", "```java\n    {  type: 'connection_init';  payload: Map<String, Object>; // optional}\n    ```", "```java\n    {  type: 'connection_ack';  payload: Map<String, Any>; // optional}\n    ```", "```java\n{  id: '<unique-id>';\n  type: 'subscribe';\n  payload: {\n    operationName: ''; // optional operation name\n    query: '';  // Mandatory GraphQL subscription\n    query\n    variables?: Map<String, Any>; // optional\n    variables\n    extensions?: Map<String, Any>; // optional\n  };\n}\n```", "```java\n    {  id: '<unique-id>'; // one sent with subscribe  type: 'next';  payload: ExecutionResult;}\n    ```", "```java\n{  id: '<unique-id>'; // one sent with subscribe\n  type: 'complete';\n}\n```", "```java\n    {  id: '<unique-id>';  type: 'error';  payload: GraphQLError[];}\n    ```", "```java\n    {  type: String; // either 'ping' or 'pong'  payload: Map<String, Object>; // optional}\n    ```", "```java\n    ws://localhost:8080/subscriptions\n    ```", "```java\n    Connection: UpgradeUpgrade: websocketdnt: 1accept: */*accept-encoding: gzip, deflate, brhost: localhost:8080origin: http://localhost:8080sec-fetch-dest: websocketsec-fetch-mode: websocketsec-fetch-site: same-originSec-WebSocket-Protocol: graphql-transport-wsSec-WebSocket-Version: 13Sec-WebSocket-Key: 3dcYr9va5icM8VcKuCr/KA==Sec-WebSocket-Extensions: permessage-deflate\n    ```", "```java\n    {  \"type\": \"connection_init\",  \"payload\": {     \"variables\": {},  \"extensions\": {},  \"operationName\": null,  \"query\":\"subscription { quantityChanged { id name price count} }\"}}\n    ```", "```java\n    {  \"payload\": {},  \"type\": \"connection_ack\"}\n    ```", "```java\n    {  \"id\": \"b\",  \"type\": \"subscribe\",  \"payload\": {     \"variables\": {},  \"extensions\": {},  \"operationName\": null,      \"operationName\": null,\"query\":\"subscription { quantityChanged { id name price count} }\"}}\n    ```", "```java\n    mutation {  addQuantity(productId: \"a1s2d3f4-0\", quantity: 10) {    id    name    price    count  }}\n    ```", "```java\n    {  \"id\": \"b\",  \"type\": \"complete\"}\n    ```", "```java\n@Componentpublic class DemoInstrumentation\n               extends SimpleInstrumentation {\n  @NotNull\n  @Override\n  public CompletableFuture<ExecutionResult>\n     instrumentExecutionResult(ExecutionResult exeResult,\n               InstrumentationExecutionParameters params,\n               InstrumentationState state) {\n    HttpHeaders responseHeaders = new HttpHeaders();\n    responseHeaders.add(\"myHeader\", \"hello\");\n    return super.instrumentExecutionResult(DgsExecutionResult\n        .builder().executionResult(execResult)\n        .headers(responseHeaders).build(),\n        params,\n        state\n    );\n  }\n}\n```", "```java\nmutation {  addQuantity(productId: \"a1s2d3f4-0\", quantity: 10) {\n    id\n    name\n    price\n    count\n  }\n}\n```", "```java\n@Configurationpublic class InstrumentationConfig {\n  @Bean\n  @ConditionalOnProperty( prefix = \"graphql.tracing\",\n        name = \"enabled\", matchIfMissing = true)\n  public Instrumentation tracingInstrumentation(){\n    return new TracingInstrumentation();\n  }\n}\n```", "```java\nmutation {  addQuantity(productId: \"a1s2d3f4-0\", quantity: 10) {\n    id\n    name\n    price\n    count\n  }\n}\n```", "```java\n{  \"data\": {\n    \"addQuantity\": {\n      \"id\": \"a1s2d3f4-0\",\n      // output truncated for brevity\n    }\n  },\n  \"extensions\": {\n    \"tracing\": {\n      \"version\": 1,\n      \"startTime\": \"2023-05-07T19:04:42.032422Z\",\n      \"endTime\": \"2023-05-07T19:04:42.170516Z\",\n      \"duration\": 138103974,\n      \"parsing\": {\n        \"startOffset\": 11023640,\n        \"duration\": 7465319\n      },\n      \"validation\": {\n        \"startOffset\": 31688145,\n        \"duration\": 20146090\n      },\n      \"execution\": {\n        \"resolvers\": [\n          {\n            \"path\": [\n              \"addQuantity\"\n            ],\n            \"parentType\": \"Mutation\",\n            \"returnType\": \"Product\",\n            \"fieldName\": \"addQuantity\",\n            \"startOffset\": 92045595,\n            \"duration\": 24507328\n          },\n          // output truncated for brevity\n        ]\n     }\n    }\n  }\n}\n```", "```java\nmanagement.endpoints.web.gql.error:\n\n```", "```java\n\n This endpoint displays the list of available metrics in your application, including GraphQL metrics.\nThe following four types of GraphQL metrics are provided by the DGS framework, which may help you to find out the code responsible for poor performance:\n\n*   `gql.query`: This captures the time taken by the GraphQL query or mutation.\n*   `gql.resolver`: This captures the time taken by each data fetcher invocation.\n*   `gql.error`: A single GraphQL request can have multiple errors. This metric captures the number of errors encountered during the GraphQL request execution. It will only be available when there are errors in execution.\n*   `gql.dataLoader`: This captures the time taken by the data loader invocation for the batch of queries.\n\nThe available GraphQL metrics from the actuator metrics endpoint output can be accessed using the following endpoint call:\n\n```", "```java\n\n It may provide output as shown here:\n\n```", "```java\n\nYou can see that it provides the total elapsed time, a number of requests count, and the max time taken by the query/mutation. It also provides tags. These tags can be customized if required by implementing the following interfaces – `DgsContextualTagCustomizer` (to customize common tags such as application profile and version or deployment environment), `DgsExecutionTagCustomizer` (to customize the tags related to execution results), and `DgsFieldFetchTagCustomizer` (to customize the tags related to data fetchers).\nYou have learned how to instrument the GraphQL APIs in this section. Let’s explore automating the testing of GraphQL code in the next section.\nTest automation\nThe DGS framework provides classes and utilities that facilitate the automation of GraphQL API tests.\nCreate a new file called `ProductDatafetcherTest.java` inside the `datafetchers` package in the `test` directory and add the following code:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/test/java/com/packt/modern/api/datafetchers/ProductDatafetcherTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/test/java/com/packt/modern/api/datafetchers/ProductDatafetcherTest.java)\nHere, you are using the `@SpringBootTest` annotation to auto-configure a Spring Boot based test. You are limiting the Spring context by providing specific classes such as `DgsAutoConfiguration`, `ProductDatafetcher`, and `BigDecimalScalar`. You should add only those classes here that are required to perform the test.\nThen, you are auto-wiring the `DgsQueryExecutor` class, which provides the query execution capability to your test. After that, you add two Spring-injected mock beans for the `Product` and `Tag` services.\nYou are ready with the configuration and instances you need to run the tests.\nLet’s add the setup method that is required before running the tests. You can add the following method for this purpose in `ProductDatafetcherTest.java`:\n\n```", "```java\n\nHere, you are using Mockito to stub the `productService.getProduct()` and `tagService.addTags()` calls.\nYou are done with the setup. Let’s run our first test, which will fetch the JSON object after running the GraphQL `product` query next.\nTesting GraphQL queries\nLet’s add the following code to `ProductDatafetcherTest.java` to test the `product` query:\n\n```", "```java\n\nHere, the code is using the `DgsQueryExecutor` instance to execute the `product` query and extract the JSON property. Then, it validates the name extracted from the JSON and compares it with the value set in the `beforeEach()` method.\nNext, you’ll test the `product` query again, but this time, to test the exception.\nYou can add the following code to `ProductDatafetcherTest.java` to test the exception thrown by the `product` query:\n\n```", "```java\n\nHere, the `productService` method is stubbed to throw the exception. When `DgsQueryExecutor` runs, the Spring-injected mock bean uses the stubbed method to throw the exception that is being asserted here.\nNext, let’s query `product` again, this time to explore `GraphQLQueryRequest`, which allows you to form the GraphQL query in a fluent way. The `GraphQLQueryRequest` construction takes two arguments – first, the instance of `GraphVQLQuery`, which can be a query/mutation or subscription, and second, the projection root type of `BaseProjectionNode`, which allows you to select the fields.\nLet’s add the following code to `ProductDatafetcherTest.java` to test the `product` query using `GraphQLQueryRequest`:\n\n```", "```java\n\nHere, the `ProductGraphQLQuery` class is part of the auto-generated code by the DGS GraphQL Gradle plugin.\nOne thing we have not yet tested in previous tests is verifying the subfields in the `tags` field of `product`.\nLet’s verify it in the next test case. Add the following code in `ProductDatafetcherTest.java` to verify the tags:\n\n```", "```java\n\nHere, you can see that you have to use a third argument (`TypeRef`) in the `executeAndExtractJsonPathAsObject()` method if you want to query the subfields. If you don’t use it, you will get an error.\nYou are done with GraphQL query testing. Let’s move on to testing the mutations in the next subsection.\nTesting GraphQL mutations\nTesting a GraphQL mutation is no different from testing GraphQL queries.\nLet’s test the `addTag` mutation to `ProductDatafetcherTest.java` as shown in the following code:\n\n```", "```java\n\nHere, the `AddTagGraphQLQuery` class is part of the code auto-generated by the DGS GraphQL Gradle plugin. You fire the request and then validate the results based on the existing configuration and setup.\nSimilarly, you can test the `addQuantity` mutation. Only the arguments and assertions will change; the core logic and classes will remain the same.\nYou can add the test to `ProductDatafetcherTest.java` as shown in the next code block to test the `addQuantity` mutation:\n\n```", "```java\n\nYou are done with GraphQL mutation testing. Let’s move on to testing subscriptions in the next subsection.\nTesting GraphQL subscriptions using automated test code\nTesting a subscription needs extra effort and care, as you can see in the following code, which performs the test for the `quantityChanged` subscription. It uses the existing `addQuantity` mutation to trigger the subscription publisher that sends a `product` object on each call. You capture the product of the first call and store the value of the `count` field. Then, use it to perform the assertion as shown in the following code:\n\n```", "```java\n\nHere, the core logic lies in the subscription that is done by calling the `publisher.subscribe()` method (check the highlighted line). You know that the GraphQL `quantityChanged` subscription returns the publisher. This publisher is received from the `data` field of the execution result.\nThe publisher subscribes to the stream by passing a `Subscriber` object, which is created on the fly. The subscriber’s `onNext()` method is used to receive the product sent by the GraphQL server. These objects are pushed into the list. Then, you use this list to perform the assertion.\nSummary\nIn this chapter, you learned about the different ways of implementing the GraphQL server, including federated GraphQL services. You have also explored the complete standalone GraphQL server implementation, which performs the following operations:\n\n*   Writing the GraphQL schema\n*   Implementing the GraphQL query APIs\n*   Implementing the GraphQL mutation APIs\n*   Implementing the GraphQL subscription APIs\n*   Writing the data loaders to solve the N+1 problem\n*   Adding custom scalar types\n*   Adding the GraphQL API’s instrumentation\n*   Writing the GraphQL API’s test automation using Netflix’s DGS framework\n\nYou learned about GraphQL API implementation using Spring and Spring Boot skills that will help you implement GraphQL APIs for your work assignments and personal projects.\nQuestions\n\n1.  Why should you prefer frameworks such as Netflix’s DGS in place of the `graphql-java` library to implement GraphQL APIs?\n2.  What are federated GraphQL services?\n\nAnswers\n\n1.  You should prefer a framework such as Netflix DGS in place of the `graphql-java` library to implement GraphQL APIs because it bootstraps the development and avoids writing boilerplate code.\n\nApart from the ease of development, the framework uses `graphql-java` internally; therefore, it keeps itself in sync with the GraphQL specification’s Java implementation. It also supports developing federated GraphQL services.\nIt also provides plugins, the Java client, and testing utilities that help you to automate the development. The Netflix DGS framework is well tested and has been used by Netflix in production for quite some time.\n\n1.  A federated GraphQL service contains a single distributed graph exposed using a gateway. Clients call the gateway, which is an entry point to the system. A data graph will be distributed among multiple services and each service can maintain its own development and release cycle independently. Having said that, federated GraphQL services still follow the OneGraph principle. Therefore, the client would query a single endpoint for fetching any part of the graph.\n\nFurther reading\n\n*   GraphQL Java implementation: [https://www.graphql-java.com/](https://www.graphql-java.com/) and [https://github.com/graphql-java/graphql-java](https://github.com/graphql-java/graphql-java)\n*   Netflix DGS documentation: [https://netflix.github.io/dgs/getting-started/](https://netflix.github.io/dgs/getting-started/)\n*   *Full-Stack Web Development with GraphQL and* *React*: [https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880](https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880)\n\n```", "```java\n\n```"]