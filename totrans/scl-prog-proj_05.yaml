- en: Type Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about concepts that are built on top of Scala.
    The concepts in this chapter will be abstract, and they will require some concentration
    to understand; do not feel bad if you do not get it right away. Each individual
    part is relatively easy to understand, but when you put them all together, things
    can get complicated.
  prefs: []
  type: TYPE_NORMAL
- en: We will be focusing on type classes, with a definition for each one. They will
    be followed by an example illustrating how type classes can be useful in typical
    programs. As these concepts can be difficult, we also suggest some optional exercises
    that can strengthen your understanding. You do not have to do them to be able
    to follow the rest of the chapter. The solutions to the exercises are available
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of type classes presented here come from a library called Cats,
    created by Typelevel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following type classes:'
  prefs: []
  type: TYPE_NORMAL
- en: scala.math.Ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: org.scalactic.Equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cats.Semigroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cats.Monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cats.Functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cats.Apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cats.Applicative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cats.Monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding type classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **type class** represents a group of types that share a common behavior. A
    type class is to a type what a class is to an object. As with traditional classes,
    a type class can define methods. These methods can be invoked on all types that
    belong to the type class.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes were introduced in the Haskell programming language. However, thanks
    to the power of implicits, we can also use them in Scala. In Scala, type classes
    are not built-in language constructs (like they are in Haskell) and, as a result,
    we need to write a bit of boilerplate code to define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Scala, we declare a type class by using `trait`, which accepts a type parameter.
    For instance, let''s define a `Combine` type class that allows for combining two
    objects into one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can define two type class instances for `Combine`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One for `Int`, which will add the two arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One for `String`, which will concatenate them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we define an `apply` constructor for our type class, which just returns
    the implicit argument. Then, we declare the type class instances by using `implicit
    val`. This way, the compiler will be able to automatically discover them by using
    the implicit resolution rules that we saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can instantiate and use our type class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we call `Combine[Int]`, we actually call `Combine.apply[Int]`. Since our
    `apply` function accepts an implicit parameter of the type `Combine[Int]`, the
    compiler tries to find it. One of the implicit resolution rules is to search in
    the companion object of the argument's type.
  prefs: []
  type: TYPE_NORMAL
- en: As we declared `combineInt` in the companion object of `Combine`, the compiler
    uses it as the argument for `Combine.apply`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained an instance of the `Combine` type class, we can invoke
    its method, `combine`. When we call it with two `Int` it will sum them, and when
    we call it with two `String` it will concatenate them.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good; but, this is a bit cumbersome to use. It would be more practical
    to call `combine` as if it were a method on `Int` or `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the previous section, we can define an implicit class inside
    of the `Combine` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This implicit class allows us to call `combine` on any type `A` that has a
    type class instance `Combine[A]`. Therefore, we can now call `combine` on `Int`
    or `String`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It might not look impressive; you might say that we merely gave another name
    to the `+` method. The key benefit of using type classes is that we can make the
    `combine` method available for any other type, without having to change it.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional object-oriented programming, you would have to change all classes
    and make them extend a trait, which is not always possible.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes allow us to morph a type into another one on demand (in our example,
    from `Int` to `Combine`). This is what we call **ad hoc polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another key benefit is that by using `implicit def`, we can generate type class
    instances for parameterized types, such as `Option` or `Vector`. All we have to
    do is add them in the `Combine` companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As long as we have an implicit `Combine[A]` for a type parameter `A`, our function, `combineOption`,
    can generate `Combine[Option[A]]`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is extremely powerful; it lets us generate type class instances
    by using other type class instances! The compiler will automatically find the
    right generator, based on its return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is so common that Scala provides some syntactic sugar to simplify the
    definitions of such functions. We can rewrite `combineOption` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having a function that has a type parameter declared with `A: MyTypeClass`
    is equivalent to having an implicit parameter of the type `MyTypeClass[A]`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, when we use this syntax, we do not have a name for that implicit; we
    just have it in the current scope. Having it in scope is sufficient to call any
    other function that accepts an implicit parameter of the type `MyTypeClass[A]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is why we can call `Combine.apply[A]` in the preceding example. With this
    `combineOption` definition, we can now call `combine` on `Option`, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Define a type class instance for `Combine[Vector[A]]` that concatenates
    two vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Define a type class instance for `Combine[(A, B)]` that combines the
    first and second elements of two tuples. For instance, `(1, "Hello ") combine
    (2, "World")` should return `(3, "Hello World")`.
  prefs: []
  type: TYPE_NORMAL
- en: Type class recipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To summarize, if we want to create a type class, we have to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `trait`, `MyTypeClass[A]`, that accepts a parameterized type `A`. It
    represents the type class interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an `apply[A]` function in the companion object of `MyTypeClass`, in order
    to facilitate the instantiation of type class instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide implicit instances of `trait` for all of the desired types (`Int`, `String`,
    `Option`, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an implicit conversion to an `Ops` class, so that we can call methods
    of the type class as if they were declared in the target type (like you saw previously,
    with `2.combine(3)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These definitions can be written manually, like in the previous section. Alternatively,
    you can use **simulacrum** to generate some of them for you. This has the double
    benefit of reducing boilerplate code and ensuring some consistency. You can check
    it out here: [https://github.com/mpilquist/simulacrum](https://github.com/mpilquist/simulacrum).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Use simulacrum to define the `Combine` type class.'
  prefs: []
  type: TYPE_NORMAL
- en: Common type classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical project, you will not create many of your own type classes. Since
    type classes capture behaviors that are common across several types, it is likely
    that someone else has already implemented a type class similar to what you need,
    located in a library. It is usually more productive to reuse type classes defined
    in the SDK (or in third-party libraries) than to try and define your own.
  prefs: []
  type: TYPE_NORMAL
- en: In general, these libraries define predefined instances of a type class for
    the SDK types (`String`, `Int`, `Option`, and so on). You would typically reuse
    these instances to derive instances for your own types.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will present the type classes that you are most likely to
    encounter, and how to use them to solve day-to-day programming challenges.
  prefs: []
  type: TYPE_NORMAL
- en: scala.math.Ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Ordering` is an SDK type class that represents a strategy to sort the instances
    of a type. The most common use case is to sort the elements of a collection, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the declaration of `sorted`, you will see that it accepts an
    implicit, `Ordering[B]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we called `sorted` on our `Vector[Int]`, the compiler found an implicit
    value of the type `Ordering[Int]` to pass to the function. This implicit was found
    in the companion object of `Ordering`, which also defines instances for `String`,
    `Long`, `Option`, `Tuples`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an instance of the type class for `LocalDate`, so that we can
    compare dates, or sort them more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With `Ordering[LocalDate]` and `Ordering.Implicits` in scope, we can use the
    `<` operator to compare dates. `Ordering.Implicits` also defines other useful
    pimped methods, such as `<`, `>`, `<=`, `>=`, `max`, and `min`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also easily sort `Vector[LocalDate]` in reverse order by using a reversed
    `Ordering[LocalDate]`. This is more efficient than sorting in ascending order
    and then reversing the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Define an `Ordering[Person]` that can order instances of `case class
    Person(name: String, age: Int)` from the oldest to the youngest. You will need
    to use `Ordering.by`.'
  prefs: []
  type: TYPE_NORMAL
- en: org.scalactic.Equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Equality` type class is used by ScalaTest unit tests whenever you write
    assertions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you will not have to worry about it; the default instance
    compares types by using the `equals` method. However, whenever you compare double
    values or classes that contain double attributes, it becomes necessary to provide
    a different `Equality` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This test should pass, right? Wrong! Try to run it; the assertion fails, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is because `Double` is an IEEE754 double-precision floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, some decimal numbers cannot be represented exactly with `Double`.
    To make our test pass, we need to provide an `Equality[Double]` instance that
    will return true if the absolute difference between the two numbers is less than
    a certain tolerance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the test again; it will pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Implement a type class derivation, `Equality[Vector[A]]`, so that
    we can compare two `Vector[Double]` instances with a tolerance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the declaration of the equality instance that you have to
    implement in the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have done the exercise, it should make the test pass, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For more information about floating point number encoding, please refer to [https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html](https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html).
  prefs: []
  type: TYPE_NORMAL
- en: cats.Semigroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the type class introduction, we defined a `Combine` type class. It turns
    out that this type class is already defined in the Cats library. Its name is `Semigroup`;
    this name comes from the mathematical representation of this algebraic structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open it in IntelliJ to see how it is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `@sp` annotation is an optimization to avoid the boxing/unboxing of primitive
    types. Apart from that, the definition of `Semigroup` is the same as our `Combine`
    type class.
  prefs: []
  type: TYPE_NORMAL
- en: Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The documentation mentions a very important point: the instances of the type
    class must implement an associative combine function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that they must verify the following law:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Most type classes in Cats have their own specific laws. The library guarantees
    that the type class instances that it defines verify this law. However, if you
    implement your own instance of a type class, it is your responsibility to verify
    that it does not break any law.
  prefs: []
  type: TYPE_NORMAL
- en: A user of a type class instance expects that it verifies all of the laws of
    the type class; it is part of the type class’s contract.
  prefs: []
  type: TYPE_NORMAL
- en: A type class contract is the type class trait plus the laws.
  prefs: []
  type: TYPE_NORMAL
- en: When a type class verifies certain laws, you can reason about generic code more
    easily, and you can confidently apply some transformations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you know that the associativity law is verified, you can evaluate
    `a combine b combine c combine d` in parallel: one thread can evaluate `(a combine
    b)`, while another one evaluates `(c combine d)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Cats provide a `laws` module to help check your type class instances. You can
    check that your type class respects the laws by writing unit tests. This will
    not be detailed in this book; if you are interested in more information, you can
    go to [https://typelevel.org/cats/typeclasses/lawtesting.html](https://typelevel.org/cats/typeclasses/lawtesting.html).
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cats provide several derivations of the `Semigroup` type class. It also declares
    a `|+|` operator in `SemigroupOps`, which is an alias for `combine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the built-in derivations brought up with `import cats.implicits._`,
    we can combine `Int`, `String`, `Tuple2`, and `Tuple3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also combine some parameterized types, such as `Option` and `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For `Option`, notice that an empty `Option` is ignored whenever we combine it
    with a non-empty `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling Errors*,
    you saw that `Option` was one way of handling errors, and you learned that whenever
    an error message is needed, you can use `Either` instead of `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens, then, if we call `combine` on `Either`? Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `|+|` (or `combine`) function returns the first argument of type `Left`.
    If all the combined values are of type Right, their values are combined and put
    in `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, all the combined values are of type `Right`, hence the result
    is a `Right(3)`, because `3`  is the result of `combine` applied to `1` and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second line, the first combined value of type `Left` is `Left("error")`,
    hence the result is also `Left("error")`.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line, the first combined value of type `Left` is  `Left("error1")`,
    hence the result is `Left("error1")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Use the `|+|` operator to combine instances of `ValidatedNel[String,
    Int]`.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you combine several invalid values?
  prefs: []
  type: TYPE_NORMAL
- en: cats.Monoid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Monoid` is `Semigroup` with an additional `empty` function, also called an
    **identity element**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract of this trait''s definition in Cats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Monoid` trait extends the `Semigroup` trait. As such, it has all of the
    methods of `Semigroup`, plus this additional `empty` method. We have already seen
    several examples of the `combine` operation of `Semigroup`'s for different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens when we call `empty` for the same types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For each type, the `empty` element is quite natural: `0` for `Int`, `None`
    for `Option`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see why this `empty` function is called the identity element; if you
    combine any object with the identity element, it returns the same object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This property is formally defined by the identity laws, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Left identity: For all `x` of type `A`, `Monoid[A].empty |+| x == x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right identity: For all `x` of type `A`, `x |+| Monoid[A].empty == x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is interesting—how can we use `Monoid` in our day-to-day programs? The
    most compelling use case is to fold data structures. When you have `Monoid[A]`,
    it is trivial to combine all of the elements of `Vector[A]` to obtain one `A`.
    For instance, we can get the sum of all of the elements of `Vector[Int]`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to calling `foldLeft` on `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, `foldLeft` accepts two arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A start value, for which we can pass the monoid's empty value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function, for which we can pass the monoid's `combine` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cats also provide a `foldMap` function, which lets you transform the elements
    of a collection into `Monoid` before folding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Implement an instance of `Monoid[Int]` to multiply all of the elements
    of a `Vector[Int]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Use `foldMap` to compute the average of `Vector[Double]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: The return type of the call to `foldMap` should be `(Int, Double)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-kinded types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before exploring other type classes, it would be useful to be familiar with
    the concept of **higher-kinded** types and **arities**.
  prefs: []
  type: TYPE_NORMAL
- en: You are already familiar with values and functions. A value is a literal or
    an object, such as `1`, `false`, or `"hello world"`.
  prefs: []
  type: TYPE_NORMAL
- en: Arity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function takes one or many values as parameters and returns another value.
  prefs: []
  type: TYPE_NORMAL
- en: The **arity** of a function is the number of parameters it takes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: A **nullary** (arity 0) function does not take any parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **unary** (arity 1) function takes only one parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **binary** (arity 2) function takes two parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **type constructor** is a type that accepts parameters. It is called type
    constructor, because it constructs a concrete type when we pass a concrete type
    to it. For instance, `Option[A]` is a type constructor. When we pass a concrete
    type `Int` to it, we obtain a concrete type `Option[Int]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As type constructors can accept 0 to n arguments, the concept or arity also
    applies here:'
  prefs: []
  type: TYPE_NORMAL
- en: A nullary type does not take any parameter. It is a concrete type—`Int`, `Boolean`,
    and many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary type takes one parameter—`Option[A]`, `Vector[A]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary type takes two parameters—`Either[L, R]`, `Map[K, V]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ternary type takes three parameters—`Tuple3[A, B, C]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **order** of a function is the nesting depth of function arrows:'
  prefs: []
  type: TYPE_NORMAL
- en: Order 0—values, for instance, `1`, `false` or `"hello"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order 1—functions `A => B`, for instance `def addOne: Int => Int = x => x +
    1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order 2—higher-order functions `A => B => C`, for instance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Order 3—higher-order functions `A => B => C => D`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any function of an order strictly greater than `1` is a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-kinded types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out that similar concepts exist with types and **kinds**:'
  prefs: []
  type: TYPE_NORMAL
- en: The kind of ordinary types such as `Int` or `Boolean` is `*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kind of unary type constructors is `* -> *`, for instance, `Option` or `List`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kind of binary type constructors is `(*, *) -> *`, for instance, `Either`
    or `Map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly to functions and order, we can order kinds by the number of type
    arrow `->` they have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Order 0 (`*`): Ordinary types such as `Int`, `Boolean`, or `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order 1 (`* -> *` or `(*, *) -> *`): Type constructors `Option`, `Vector`,
    `Map`, and many more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order 2 (`(* -> *) -> *`): Higher-kinded types `Functor`, `Monad`, and many
    more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **higher-kinded** type is a type constructor that has strictly more than one
    arrow `->`. In the following section, we are going to explore type classes that
    are defined using higher-kinded types.
  prefs: []
  type: TYPE_NORMAL
- en: cats.Functor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Functor` is a **higher-kinded** **type** of **arity** one. It accepts a unary
    type parameter `F[_]`. In other words, its type parameter must be a type that
    has a type parameter itself; for instance, `Option[A]`, `Vector[A]`, `Future[A]`,
    and so on. It declares a `map` method that can transform the elements inside of
    `F`. Here is a simplified definition of `cats.Functor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This should be familiar. We have already seen several classes of the SDK that
    define a `map` function doing the same thing: `Vector`, `Option`, and so on. Hence,
    you might wonder why you would ever need to use an instance of `Functor[Option]`
    or `Functor[Vector]`; they would only define a `map` function that is already
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of having this `Functor` abstraction in Cats is that it lets
    us write more generic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function adds `1` for any `F[Int]` that has a `Functor` type class instance.
    The only thing I know about `F` is that it has a `map` operation. Hence, this
    function will work for many parameterized types such as `Option` or `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our function, `addOne`, applies the principle of the least power; given a choice
    of solutions, it picks the least powerful solution capable of solving your problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a parameter type that is more generic, and hence, less powerful (it
    only has one `map` function). This makes our function more reusable, easier to
    read, and easier to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**More reusable**: The same function can be used with `Option` or `Vector`
    or `List`, or anything that has a `Functor` type class instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to read**: When you read the signature of `addOne`, you know that
    the only thing it can do is transform the elements inside of the `F`. It cannot,
    for instance, shuffle the order of the elements, nor can it drop some elements.
    This is guaranteed by the `Functor` laws. Therefore, you do not have to read its
    implementation to make sure that it does not get into any mischief.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to test**: You can test the function with the simplest type that has
    a `Functor` instance, which is `cats.Id`. the code coverage will be the same.
    A simple test would be, for instance, `addOne[cats.Id](1) == 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be `Functor`, the `Functor` instance's `map` function must satisfy
    two laws.  In the rest of this chapter, we will define our laws in terms of an
    equality: `left_expression == right_expression`. These equalities must be true
    for any types and instances specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a type `F` that has a `Functor[F]` instance, for any type `A` and any
    instance `fa: F[A]`, the following equalities must be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity preservation**: `fa.map(identity) == fa`. The identity function
    always returns its argument. Mapping with this function should not change `fa`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition preservation**: For any function `f` and `g`, `fa.map(f).map(g)
    == fa.map(f andThen g)`. Mapping `f` and `g` successively is the same as mapping
    with a composition of these functions. This law allows us to optimize code. When
    we find ourselves calling `map` many times on a large vector, we know that we
    can replace all of the `map` calls with a single one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: Write an instance of `Functor[Vector]` that breaks the identity preservation
    law.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Write an instance of `Functor[Vector]` that breaks the composition
    preservation law.'
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you have a function `A => B`, you can lift it to make a function `F[A]
    => F[B]`, as long as you have a `Functor[F]` instance in scope, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy function is `fproduct`, which tuples value with the result of
    applying a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We created `Vector[(String, Int)]` by using `fproduct`, and then converted it
    to `Map`. We obtain `Map` (keyed with a word) whose associated value is the number
    of characters of the word.
  prefs: []
  type: TYPE_NORMAL
- en: cats.Apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Apply` is a subclass of `Functor`. It declares an additional `ap` function.
    Here is a simplified definition of `cats.Apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This signature means that for a given context `F`, if we have a function `A
    => B` inside of `F`, we can apply it to `A` inside of another `F` to obtain `F[B]`.
    We can also use `ap` alias operator, `<*>`. Let''s try it out with different `F`
    contexts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For `F = Option`, `ap` returns a nonempty `Option` only if both arguments are
    nonempty.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `F = Vector`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `Vector`, `ap` takes each element for the first `Vector` and
    applies it to each element of the second `Vector`. Hence, we obtain all of the
    combinations of applying every function to every element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Use `ap` with `Future`.'
  prefs: []
  type: TYPE_NORMAL
- en: Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other Cats type classes, an `Apply` instance must obey certain laws.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a type `F` that has an `Apply[F]` instance, for all types `A`, given
    an instance `fa: F[A]`, the following equalities must be verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product associativity**: For all `fb: F[B]` and `fc: F[C]`, the following
    applies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can change the parenthesis and hence the evaluation order without changing
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: '**`ap` function composition**: For all types `B` and `C`, given the instances
    `fab: F[A => B]` and `fbc: F[B => C]`, the following applies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the function composition law that we saw in the `Functor`
    section: `fa.map(f).map(g) == fa.map(f andThen g)`.
  prefs: []
  type: TYPE_NORMAL
- en: Do not get lost in reading this law; the `<*>` function is applied right to
    left, and the `andThen` used for a function is `.compose[A]` for `Functor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Verify the product associativity for `F = Option`. You can use specific
    values for `fa`, `fc`, and `fc`, for instance `val (fa, fb, fc) = (Option(1),
    Option(2), Option(3))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Verify the `ap` function composition for `F = Option`. As before,
    you can use specific values for `fa`, `fab`, and `fbc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is all good, but in practice, I rarely put functions inside of contexts.
    I find that the function `map2` in `Apply` is more useful. It is defined in `Apply` by
    using `product` and `map`. The `product` defines itself, using `ap` and `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map2` object allows for applying a function to two values inside of an
    `F` context. This can be used to combine two values inside `F`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, for `F = Option`, `map2` lets us call the function
    `/` if both values are nonempty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cats also provide an `Apply` instance for `F = Either[E, ?]`. Therefore, we
    can change the signature of `parseIntOpt` to return `Either[Throwable, Int]`,
    and the rest of the code will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This `map2` function works well for two elements, but what if we have three,
    four, or *N* elements? `Apply` does not define a `map3` or `map4` function, but
    fortunately, Cats defines a `mapN` function on tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling Errors*,
    we saw that `Either` is used when we want to stop at the first error. This is
    what we saw in the previous example: the error mentions that `"abc"` cannot be
    parsed, but it does not mention anything about `"def"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying what we just learned, if we want to accumulate all errors, we can
    use `ValidatedNel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Use `mapN` with `Future[Int]`. This allows you to run several computations
    in parallel, and to process their results when they are complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Use `mapN` with `Vector[Int]`.'
  prefs: []
  type: TYPE_NORMAL
- en: cats.Applicative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Applicative` is a subclass of `Apply`. It declares an additional function,
    called `pure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `pure` function puts any value of type `A` into the `F` context. A type
    `F` that has an instance of `Applicative[F]` and that respects the associated
    laws is called an **Applicative Functor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this new `pure` function with different `F` contexts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, `pure` is equivalent to the `apply` constructor. We can call
    it by using the function declared on the `Applicative` trait, or by calling `.pure[F]`
    on any type.
  prefs: []
  type: TYPE_NORMAL
- en: Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you would expect, `Applicative` must conform to some laws.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a type `F` that has an `Applicative[F]` instance, for all types `A` given
    an instance `fa: F[A]`, the following equalities must be verified:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Applicative identity is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we put the `identity` function in a `F` context using `pure` and call `<*>`
    on `fa`, it does not change `fa`. It is similar to the identity law in `Functor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Applicative composition, given the instances `fab: F[A => B]` and `fbc:
    F[B => C]`, is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is similar to the composition preservation in `Functor` . By using `compose`,
    we can change the parenthesis around the `<*>` expressions without changing the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Applicative` homomorphism is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we call `pure(f)` and then `<*>` , it is the same as applying `f` and then
    calling `pure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Applicative` interchange, given the instance `fab: F[A => B]`, is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can flip the `fab` argument of `<*>`, provided that we wrap `a` on the left
    side of the equality, or `f(a)` on the right side of the equality.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, I encourage you to open the `cats.laws.ApplicativeLaws` class
    from the Cats source code. There are a few other laws to discover, as well as
    the implementations of all of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the section *cats.Apply* about `Apply`, you saw that we can combine many
    values in an `F` context by using `mapN`. However, what if the values that we
    want to combine are in a collection instead of a tuple?
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we can use the `Traverse` type class. Cats provide instances of
    this type class for many collection types, such as `List`, `Vector`, and `SortedMap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simplified definition of `Traverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This signature means that I can call it with a collection, `fa: F[A]` (for
    instance, `Vector[String]`), and a function that takes `A` and returns `G[B]`,
    `G` being `Applicative Functor` (for instance, `Option[Int]`). It will run the
    `f` function on all of the values inside the `F`, and will return `F[B]` in a
    `G` context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action with concrete examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can safely parse `Vector[String]` to return `Option[Vector[Int]]`. The result
    will be `None` if any value cannot be parsed. In this example, we called `Traverse`
    with `F = Vector`, `G = Option`, `A = String`, and `B = Int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to keep some details about the parsing error, we can use `G = ValidatedNel`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Use `Traverse` with `G = Future`. This will let you run a function
    in parallel for each element of the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Another common use case is to flip a structure `F[G[A]]` into an `F[G[A]]`,
    using `sequence`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of `sequence` in the `cats.Traverse` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `sequence` is actually implemented using `traverse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example, with `F = Vector` and `G = Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is another example, with `F = List` and `G = Future`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The call to `sequence` returns `Future` which will complete only when the three
    futures inside of `vecFut` complete.
  prefs: []
  type: TYPE_NORMAL
- en: cats.Monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Monad` is a subclass of `Applicative`. It declares an additional function, `flatMap`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This signature tells us that in order to produce `F[B]`, `flatMap` will somehow
    have to extract `A` inside `fa: F[A]`, and then call the function, `f`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, you saw that `Applicative` and `mapN` allow us to process several
    `F[A]` values in parallel, and combine them into a single `F[B]`. What `Monad`
    adds is the capability of processing `F[]` values in sequence: `flatMap` must
    process the `F` effect first, then call the `f` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `Functor` and `map`, many classes of the SDK already have a `flatMap`
    method, such as `Option`, `Vector`, `Future`, and so on. One advantage of having
    this `Monad` abstraction is that we can write functions that accept `Monad` so
    that it can be reused with different types.
  prefs: []
  type: TYPE_NORMAL
- en: Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given a type `F` that has a `Monad[F]` instance, for all types `A` given an
    instance `fa: F[A]`, the following equalities must be verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '**All of the laws from the super traits**: See `Applicative`, `Apply`, and `Functor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FlatMap associativity**: Given two types `B` and `C`, and two functions `f:
    A => F[B]` and `g: B => F[C]`, the following applies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Left identity**: Given a type `B`, a value `a: A`, and a function `f: A =>
    F[B]`, the following applies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Bringing a value in the `F` context and calling `flatMap f` should provide the
    same result as calling the function `F` directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Right identity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `fa` object should not change when we call `flatMap` and `pure`.
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose that you are building a program to manage a shop''s inventory. The
    following is a simplified API to manage the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The API is parametrized with an `F` context. This allows you to have different
    implementations of your API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In your unit tests, you would use `class TestItemApi extends ItemApi[cats.Id]`.
    If you look for the definition of `Id`, you will find `type Id[A] = A`. This means
    that this `TestItemApi` can directly return `Vector[Item]` in `findAllItems`,
    and `Unit` in `saveItem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your production code, you will need access to a database, or to call a remote
    REST service. These actions take time and can fail; hence, you will need to use
    something like `F = Future`, or maybe `F = cats.effects.IO`. You will, for instance,
    define `class DbItemApi extends ItemApi[Future]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Future` class in the SDK has some issues and breaks some laws. I encourage
    you to use better abstractions, such as `cats.effects.IO` ([https://typelevel.org/cats-effect/datatypes/io.html](https://typelevel.org/cats-effect/datatypes/io.html))
    or `monix.eval.Task` ([https://monix.io/docs/2x/eval/task.html](https://monix.io/docs/2x/eval/task.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with this API, we can implement some business logic. The following
    is the implementation of a function that applies a discount to all items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `F[_]: Monad` type parameter constraint implies that we can call `startSalesSeason`
    with any `ItemApi[F]`, as long as `F` has a `Monad` instance. The presence of
    this implicit in scope allows us to call `map` and `flatMap` on an instance `F[A]`.
    Since a `for` comprehension is transformed by the compiler into a combination
    of `map`/`flatMap`, we can use a `for` comprehension to make our function more
    readable. In the section *cats.Applicative*, about `Applicative`, you saw that
    we can call `traverse` on `Vector`, as long as the function returns `F` which
    has an `Applicative[F]` instance. Since `Monad` extends `Applicative`, we could
    use `traverse` to iterate through the items and save each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: If you squint at this code, it looks very similar to what an imperative implementation
    would look like. We managed to write a purely functional function while keeping
    readability. The advantage of this technique is that we can easily unit test the
    logic of `startSalesSeason` with `F = Id`, without having to deal with `Futures`.
    In the production code, the same code can use `F = Future`, or even `F = Future[Either[Exception,
    ?]]`, and gracefully handle the process in multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Implement `TestItemApi`, which extends `ItemApi[Id]`. You can use
    a mutable `Map` to store the items. After that, write a unit test for `startSalesSeason`.
    Then, implement a production version of the API that extends `ItemApi[Future]`.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach is known as **tagless final encoding**. You can find more information
    about this pattern at [https://www.beyondthelines.net/programming/introduction-to-tagless-final/](https://www.beyondthelines.net/programming/introduction-to-tagless-final/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered some challenging concepts in this chapter. Type classes are also
    used in other functional programming languages, such as Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, the following table summarizes the type classes that we enumerated
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Method | Law(s) | Example(s) |'
  prefs: []
  type: TYPE_TB
- en: '| `Semigroup` | `def combine(` `x: A, y: A) : A` | Associativity |'
  prefs: []
  type: TYPE_TB
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Monoid` | `def empty: A` | Identity |'
  prefs: []
  type: TYPE_TB
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Functor` | `def map[A, B]` `(fa: F[A])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(f: A => B): F[B]` | Identity, Composability |'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Apply` | `def ap[A, B]` `(ff: F[A => B])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fa: F[A]): F[B]`'
  prefs: []
  type: TYPE_NORMAL
- en: alias `<*>` | Associativity, Composability |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Applicative` | `def pure[A]` `(x: A): F[A]` | Identity, Composability,'
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism,
  prefs: []
  type: TYPE_NORMAL
- en: Interchange |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Monad` | `def flatMap[A, B]` `(fa: F[A])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(f: A =>F[B]): F[B]` | Identity, Associativity,'
  prefs: []
  type: TYPE_NORMAL
- en: Composability,
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism,
  prefs: []
  type: TYPE_NORMAL
- en: Interchange |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to explore type classes in more detail, I encourage you to
    view the Cats documentation at [https://typelevel.org/cats](https://typelevel.org/cats).
    I have also found it very helpful to read the source code and tests in the SDK,
    or in libraries such as Cats.
  prefs: []
  type: TYPE_NORMAL
- en: Cats is the main library of the Typelevel initiative, but there are many more
    fascinating projects hosted under this umbrella, as shown at [https://typelevel.org/projects/](https://typelevel.org/projects/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement a cart for a shopping website, using
    frameworks that are popular in the Scala community.
  prefs: []
  type: TYPE_NORMAL
