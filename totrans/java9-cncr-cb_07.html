<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Concurrent Collections</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Using non-blocking thread-safe <span>deques</span></li>
<li class="calibre18">Using blocking thread-safe <span>deques</span></li>
<li class="calibre18">Using blocking thread-safe queue ordered by priority</li>
<li class="calibre18">Using thread-safe lists with delayed elements</li>
<li class="calibre18">Using thread-safe navigable maps</li>
<li class="calibre18">Using thread-safe HashMaps</li>
<li class="calibre18">Using atomic variables</li>
<li class="calibre18">Using atomic arrays</li>
<li class="calibre18">Using the volatile keyword</li>
<li class="calibre18">Using variable handles</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">Data structure</strong> is a basic element of programming. Almost every program uses one or more types of data structure to store and manage data. The Java API provides the <strong class="calibre1">Java Collections framework</strong>. It contains interfaces, classes, and algorithms that implement a lot of different data structures that you can use in your programs.</p>
<p class="calibre4">When you need to work with data collections in a concurrent program, you must be very careful with the implementation you choose. Most collection classes do not work with concurrent applications because they can't control concurrent access to their data. If a concurrent task shares a data structure that is unable to work with another concurrent task, you might have data inconsistency errors that will affect the operation of the program. One example of this kind of data structure is the <kbd class="calibre15">ArrayList</kbd> class.</p>
<p class="calibre4">Java provides data collection processes that you can use in your concurrent programs without any problems or inconsistency. Basically, Java provides two kinds of collections to use in concurrent applications:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Blocking collections</strong>: This kind of collection includes operations to add and remove data. If the operation can't be done immediately, because the collection is either full or empty, the thread that makes the call will be blocked until the operation could be carried out.</li>
<li class="calibre18"><strong class="calibre1">Non-blocking collections</strong>: This kind of collection also includes operations to add and remove data. But in this case, if the operation can't be done immediately, it returns a <kbd class="calibre15">null</kbd> value or throws an exception; the thread that makes the call won't be blocked here.</li>
</ul>
<p class="calibre4">Through the recipes in this chapter, you will learn how to use some Java collections in your concurrent applications. These include:</p>
<ul class="calibre17">
<li class="calibre18">Non-blocking deques, using the <kbd class="calibre15">ConcurrentLinkedDeque</kbd> class</li>
<li class="calibre18">Blocking deques, using the <kbd class="calibre15">LinkedBlockingDeque</kbd> class</li>
<li class="calibre18">Blocking queues to be used with producers and consumers of data, using the <kbd class="calibre15">LinkedTransferQueue</kbd> class</li>
<li class="calibre18">Blocking queues that order elements by priority, using the <kbd class="calibre15">PriorityBlockingQueue</kbd> class</li>
<li class="calibre18">Blocking queues with delayed elements, using the <kbd class="calibre15">DelayQueue</kbd> class</li>
<li class="calibre18">Non-blocking navigable maps, using the <kbd class="calibre15">ConcurrentSkipListMap</kbd> class</li>
<li class="calibre18">Non-blocking hash tables, using the <kbd class="calibre15">ConcurrentHashMap</kbd> class</li>
<li class="calibre18">Atomic variables, using the <kbd class="calibre15">AtomicLong</kbd> and <kbd class="calibre15">AtomicIntegerArray</kbd> classes</li>
<li class="calibre18">Variables stored in fields marked with the <kbd class="calibre15">volatile</kbd> keyword</li>
<li class="calibre18">Atomic operations on the fields of individual classes, using variable handles.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using non-blocking thread-safe deques</h1>
            

            <article>
                
<p class="calibre4">"List" is referred to as the most basic collection. It has an undetermined number of elements, and you can add, read, or remove an element from any position. Concurrent lists allow various threads to add or remove elements from the list at a time, without producing any data inconsistency errors. Similar to lists, we have deques. A deque is a data structure similar to a queue, but in a deque, you can add or remove elements from either the front (head) or back (tail).</p>
<p class="calibre4">In this recipe, you will learn how to use a non-blocking deque in a concurrent program. Non-blocking deques provide operations that, if not done immediately (for example, you want to get an element from a list but the list is empty), throw an exception or return a <kbd class="calibre15">null</kbd> value, depending on the operation. Java 7 introduced the <kbd class="calibre15">ConcurrentLinkedDeque</kbd> class that implements a non-blocking concurrent deque.</p>
<p class="calibre4">We are going to implement an example with the following two different tasks:</p>
<ul class="calibre17">
<li class="calibre18">One that adds thousands of elements to the deque</li>
<li class="calibre18">One that removes data from the deque</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">AddTask</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class AddTask implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">ConcurrentLinkedDeque</kbd> attribute parameterized by the <kbd class="calibre15">String</kbd> class named <kbd class="calibre15">list</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ConcurrentLinkedDeque&lt;String&gt; list;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public AddTask(ConcurrentLinkedDeque&lt;String&gt; list) { <br class="title-page-name"/>         this.list=list; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the class. This method will have a loop with 5000 cycles. In each cycle, we will take the first and last elements of the deque so we will take a total of 10,000 elements:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          String name=Thread.currentThread().getName(); <br class="title-page-name"/>          for (int i=0; i&lt;10000; i++){ <br class="title-page-name"/>            list.add(name+": Element "+i); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">PollTask</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class PollTask implements Runnable {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare a private <kbd class="calibre15">ConcurrentLinkedDeque</kbd> attribute parameterized by the <kbd class="calibre15">String</kbd> class named <kbd class="calibre15">list</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ConcurrentLinkedDeque&lt;String&gt; list;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public PollTask(ConcurrentLinkedDeque&lt;String&gt; list) { <br class="title-page-name"/>          this.list=list; <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the class. It takes out 10,000 elements of the deque in a loop with 5,000 steps, taking off two elements in each step:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;5000; i++) { <br class="title-page-name"/>            list.pollFirst(); <br class="title-page-name"/>            list.pollLast(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a <kbd class="calibre15">ConcurrentLinkedDeque</kbd> object parameterized by the <kbd class="calibre15">String</kbd> class named <kbd class="calibre15">list</kbd>:</li>
</ol>
<pre class="calibre23">
        ConcurrentLinkedDeque&lt;String&gt; list=new ConcurrentLinkedDeque&lt;&gt;();
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create an array of 100 <kbd class="calibre15">Thread</kbd> objects named <kbd class="calibre15">threads</kbd>:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[100];
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create 100 <kbd class="calibre15">AddTask</kbd> objects and threads to run each one of them. Store every thread in the array created earlier and start them:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length ; i++){ <br class="title-page-name"/>          AddTask task=new AddTask(list); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("Main: %d AddTask threads have been launched\n",<br class="title-page-name"/>                          threads.length);
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Wait for the completion of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Write the size of the list in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Size of the List: %d\n",list.size());
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create 100 <kbd class="calibre15">PollTask</kbd> objects and threads to run each one of them. Store every thread in the array created earlier and start them:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt; threads.length; i++){ <br class="title-page-name"/>          PollTask task=new PollTask(list); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("Main: %d PollTask threads have been launched\n",<br class="title-page-name"/>                          threads.length);
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Write the size of the list in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Size of the List: %d\n",list.size());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we used the <kbd class="calibre15">ConcurrentLinkedDeque</kbd> object parameterized by the <kbd class="calibre15">String</kbd> class to work with a non-blocking concurrent deque of data. The following screenshot shows the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone27" src="../images/00043.jpeg"/></div>
<p class="calibre4">First, you executed 100 <kbd class="calibre15">AddTask</kbd> tasks to add elements to the list. Each one of these tasks inserts 10,000 elements to the list using the <kbd class="calibre15">add()</kbd> method. This method adds new elements at the end of the deque. When all the tasks had finished, you wrote the number of elements of the deque in the console. At that moment, the deque had 1,000,000 elements.</p>
<p class="calibre4">Then, you executed 100 <kbd class="calibre15">PollTask</kbd> tasks to remove elements from the deque. Each one of these tasks removes 10,000 elements from the deque using the <kbd class="calibre15">pollFirst()</kbd> and <kbd class="calibre15">pollLast()</kbd> methods. The <kbd class="calibre15">pollFirst()</kbd> method returns and removes the first element of the deque, and the <kbd class="calibre15">pollLast()</kbd> method returns and removes the last element of the deque. If the deque is empty, they return a <kbd class="calibre15">null</kbd> value. When all the tasks had finished, you wrote the number of elements of the deque in the console. At that moment, the list had zero elements. Take into account that the <kbd class="calibre15">ConcurrentLinkedDeque</kbd> data structure doesn't allow you to add <kbd class="calibre15">null</kbd> values.</p>
<p class="calibre4">To write the number of elements in the deque, you used the <kbd class="calibre15">size()</kbd> method. You have to take into account that this method can return a value that is not real, especially if you use it when there are threads adding to or deleting data from the list. The method has to traverse the entire deque to count the elements, and the contents of the list can change with this operation. Only if you use them when there aren't any threads modifying the deque, you will have the guarantee that the returned result would be correct.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ConcurrentLinkedDeque</kbd> class provides more methods to get elements from the deque:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getFirst()</kbd> and <kbd class="calibre15">getLast()</kbd>: These methods return the first and last element from the deque, respectively. They don't remove the returned element from the deque. If the deque is empty, they throw a <kbd class="calibre15">NoSuchElementExcpetion</kbd> exception.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>, <kbd class="calibre15">peekFirst()</kbd>, and <kbd class="calibre15">peekLast()</kbd>: These methods return the first and the last element of the deque, respectively. They don't remove the returned element from the deque. If the deque is empty, they return a <kbd class="calibre15">null</kbd> value.</li>
<li class="calibre18"><kbd class="calibre15">remove()</kbd>, <kbd class="calibre15">removeFirst()</kbd>, and <kbd class="calibre15">removeLast()</kbd>: These methods return the first and last element of the deque, respectively. They remove the returned element as well. If the deque is empty, they throw a <kbd class="calibre15">NoSuchElementException</kbd> exception.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using blocking thread-safe deques</h1>
            

            <article>
                
<p class="calibre4">The most basic collection is referred to as a list. A list has an unlimited number of elements, and you can add, read, or remove an element from any position. A concurrent list allows various threads to add or remove elements from the list at a time without producing any data inconsistency. Similar to lists, we have deques. A deque is a data structure similar to a queue, but in a deque, you can add or remove elements from either the front (head) or back (tail).</p>
<p class="calibre4">In this recipe, you will learn how to use blocking deques in your concurrent programs. The main difference between blocking deques and non-blocking deques is that blocking deques have methods to insert and delete elements that, if not done immediately because the list is either full or empty, block the thread that make the call until the operation could be carried out. Java includes the <kbd class="calibre15">LinkedBlockingDeque</kbd> class that implements a blocking deque.</p>
<p class="calibre4">You are going to implement an example with the following two tasks:</p>
<ul class="calibre17">
<li class="calibre18">One that adds thousands of elements to the deque</li>
<li class="calibre18">One that massively removes data from the same list</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse<br class="title-page-name"/>
or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow the steps described next to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Client</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Client implements Runnable{
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">LinkedBlockingDeque</kbd> attribute parameterized by the <kbd class="calibre15">String</kbd> class named <kbd class="calibre15">requestList</kbd>:</li>
</ol>
<pre class="calibre23">
        private final LinkedBlockingDeque&lt;String&gt; requestList;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Client (LinkedBlockingDeque&lt;String&gt; requestList) { <br class="title-page-name"/>          this.requestList=requestList; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Insert five <kbd class="calibre15">String</kbd> objects into the deque per second using the <kbd class="calibre15">put()</kbd> method of the <kbd class="calibre15">requestList</kbd> object. Repeat this cycle three times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;3; i++) { <br class="title-page-name"/>            for (int j=0; j&lt;5; j++) { <br class="title-page-name"/>              StringBuilder request=new StringBuilder(); <br class="title-page-name"/>              request.append(i); <br class="title-page-name"/>              request.append(":"); <br class="title-page-name"/>              request.append(j); <br class="title-page-name"/>              try { <br class="title-page-name"/>                requestList.put(request.toString()); <br class="title-page-name"/>              } catch (InterruptedException e) { <br class="title-page-name"/>                e.printStackTrace(); <br class="title-page-name"/>              } <br class="title-page-name"/>              System.out.printf("Client added: %s at %s.\n",request,<br class="title-page-name"/>                                new Date()); <br class="title-page-name"/>            } <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Client: End.\n"); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare and create <kbd class="calibre15">LinkedBlockingDeque</kbd> parameterized by the <kbd class="calibre15">String</kbd> class named list specifying a fixed size of three:</li>
</ol>
<pre class="calibre23">
        LinkedBlockingDeque&lt;String&gt; list=new LinkedBlockingDeque&lt;&gt;(3);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create and start a <kbd class="calibre15">Thread</kbd> object to execute a client task:</li>
</ol>
<pre class="calibre23">
        Client client=new Client(list); <br class="title-page-name"/>        Thread thread=new Thread(client); <br class="title-page-name"/>        thread.start();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Get three <kbd class="calibre15">String</kbd> objects from the list every 300 milliseconds using the <kbd class="calibre15">take()</kbd> method of the list object. Repeat this cycle five times. Write the strings in the console:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5 ; i++) { <br class="title-page-name"/>          for (int j=0; j&lt;3; j++) { <br class="title-page-name"/>            String request=list.take(); <br class="title-page-name"/>            System.out.printf("Main: Removed: %s at %s. Size: %d\n",<br class="title-page-name"/>                              request,new Date(), list.size()); <br class="title-page-name"/>          } <br class="title-page-name"/>          TimeUnit.MILLISECONDS.sleep(300); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Write a message to indicate the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you used <kbd class="calibre15">LinkedBlockingDeque</kbd>, parameterized by the <kbd class="calibre15">String</kbd> class, to work with a non-blocking concurrent deque of data.</p>
<p class="calibre4">The <kbd class="calibre15">Client</kbd> class uses the <kbd class="calibre15">put()</kbd> method to insert strings into the deque. If the deque is full (because you have created it with fixed capacity), the method will block the execution of its thread until there is empty space in the list.</p>
<p class="calibre4">The <kbd class="calibre15">Main</kbd> class uses the <kbd class="calibre15">take()</kbd> method to get strings from the deque. If the deque is empty, the method blocks the execution of its thread until there are elements in the deque.</p>
<p class="calibre4">Both the methods of the <kbd class="calibre15">LinkedBlockingDeque</kbd> class used in this example can throw an <kbd class="calibre15">InterruptedException</kbd> exception if they are interrupted while they are being blocked. So, you have to include the necessary code to catch this exception.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">LinkedBlockingDeque</kbd> class also provides methods to insert and get elements from the deque that, instead of being blocked, throws an exception or returns the <kbd class="calibre15">null</kbd> value. These methods are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">takeFirst()</kbd> and <kbd class="calibre15">takeLast()</kbd>: These return the first and last element of the deque, respectively. They remove the returned element from the deque. If the deque is empty, they block the thread until there are elements in the deque.</li>
<li class="calibre18"><kbd class="calibre15">getFirst()</kbd> and <kbd class="calibre15">getLast()</kbd>: These return the first and last element of the deque, respectively. They don't remove the returned element from the deque. If the deque is empty, they throw a <kbd class="calibre15">NoSuchElementExcpetion</kbd> exception.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>, <kbd class="calibre15">peekFirst()</kbd>, and <kbd class="calibre15">peekLast()</kbd>: The <kbd class="calibre15">peekFirst()</kbd> and <kbd class="calibre15">peekLast()</kbd> methods return the first and last element of the deque, respectively. They don't remove the returned element from the deque. If the deque is empty, they return a <kbd class="calibre15">null</kbd> value.</li>
<li class="calibre18"><kbd class="calibre15">poll()</kbd>, <kbd class="calibre15">pollFirst()</kbd>, and <kbd class="calibre15">pollLast()</kbd>: The <kbd class="calibre15">pollFirst()</kbd> and <kbd class="calibre15">pollLast()</kbd> methods return the first and last element of the deque, respectively. They remove the returned element from the deque. If the list is empty, they return a <kbd class="calibre15">null</kbd> value.</li>
<li class="calibre18"><kbd class="calibre15">add()</kbd>, <kbd class="calibre15">addFirst()</kbd>, and <kbd class="calibre15">addLast()</kbd>: The <kbd class="calibre15">addFirst()</kbd> and <kbd class="calibre15">addLast()</kbd> methods add an element to the first and last position, respectively. If the deque is full (created with fixed capacity), they throw an <kbd class="calibre15">IllegalStateException</kbd> exception.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using non-blocking thread-safe deques</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using blocking thread-safe queue ordered by priority</h1>
            

            <article>
                
<p class="calibre4">When you work with data structures, you may typically feel the need to have an ordered queue. Java provides <kbd class="calibre15">PriorityBlockingQueue</kbd> that has this functionality.</p>
<p class="calibre4">All the elements you want to add to <kbd class="calibre15">PriorityBlockingQueue</kbd> have to implement the <kbd class="calibre15">Comparable</kbd> interface; alternatively, you can include <kbd class="calibre15">Comparator</kbd> in the queue's constructor. This interface has a method called <kbd class="calibre15">compareTo()</kbd> that receives an object of the same type. So you have two objects to compare: the one that is executing the method and the one that is received as a parameter. The method must return a number less than zero if the local object is less than the parameter. It should return a number bigger than zero if the local object is greater than the parameter. The number must be zero if both the objects are equal.</p>
<p class="calibre4"><kbd class="calibre15">PriorityBlockingQueue</kbd> uses the <kbd class="calibre15">compareTo()</kbd> method when you insert an element in it to determine the position of the element inserted. Bigger elements will either be the tail or head of the queue, depending on the <kbd class="calibre15">compareTo()</kbd> method.</p>
<p class="calibre4">Another important characteristic of <kbd class="calibre15">PriorityBlockingQueue</kbd> is that it's a <strong class="calibre1">blocking data structure</strong>. It has methods that, if unable to perform the operation immediately, will block the thread until they are able to do it.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">PriorityBlockingQueue</kbd> class by implementing an example, where you are going to store a lot of events with different priorities in the same list, to check that the queue will be ordered as you want.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse<br class="title-page-name"/>
or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Event</kbd> and specify that it implements the <kbd class="calibre15">Comparable</kbd> interface parameterized by the <kbd class="calibre15">Event</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Event implements Comparable&lt;Event&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">thread</kbd> to store the number of threads that have created the event:</li>
</ol>
<pre class="calibre23">
        private final int thread;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">priority</kbd> to store the priority of the event:</li>
</ol>
<pre class="calibre23">
        private final int priority;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Event(int thread, int priority){ <br class="title-page-name"/>          this.thread=thread; <br class="title-page-name"/>          this.priority=priority; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">getThread()</kbd> method to return the value of the thread attribute:</li>
</ol>
<pre class="calibre23">
        public int getThread() { <br class="title-page-name"/>          return thread; <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">getPriority()</kbd> method to return the value of the priority attribute:</li>
</ol>
<pre class="calibre23">
        public int getPriority() { <br class="title-page-name"/>          return priority; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">compareTo()</kbd> method. It receives <kbd class="calibre15">Event</kbd> as a parameter and compares the priority of the current event and the one received as a parameter. It returns <kbd class="calibre15">-1</kbd> if the priority of the current event is bigger, <kbd class="calibre15">0</kbd> if both the priorities are equal, and <kbd class="calibre15">1</kbd> if the priority of the current event is smaller. Note that this is the opposite of most <kbd class="calibre15">Comparator.compareTo()</kbd> implementations:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public int compareTo(Event e) { <br class="title-page-name"/>          if (this.priority&gt;e.getPriority()) { <br class="title-page-name"/>            return -1; <br class="title-page-name"/>          } else if (this.priority&lt;e.getPriority()) { <br class="title-page-name"/>            return 1;  <br class="title-page-name"/>          } else { <br class="title-page-name"/>            return 0; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">id</kbd> to store the number that identifies the task:</li>
</ol>
<pre class="calibre23">
        private final int id;
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private <kbd class="calibre15">PriorityBlockingQueue</kbd> attribute parameterized by the <kbd class="calibre15">Event</kbd> class named <kbd class="calibre15">queue</kbd> to store the events generated by the task:</li>
</ol>
<pre class="calibre23">
        private final PriorityBlockingQueue&lt;Event&gt; queue;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(int id, PriorityBlockingQueue&lt;Event&gt; queue) { <br class="title-page-name"/>          this.id=id; <br class="title-page-name"/>          this.queue=queue; <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It stores 1,000 events in the queue, using its ID, to identify the task that creates the event and we assign to each event a different priority from 1 to 1000. Use the <kbd class="calibre15">add()</kbd> method to store the events in the queue:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;1000; i++){ <br class="title-page-name"/>            Event event=new Event(id,i); <br class="title-page-name"/>            queue.add(event); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main{ <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a <kbd class="calibre15">PriorityBlockingQueue</kbd> object parameterized by the <kbd class="calibre15">Event</kbd> class named <kbd class="calibre15">queue</kbd>:</li>
</ol>
<pre class="calibre23">
        PriorityBlockingQueue&lt;Event&gt; queue=new PriorityBlockingQueue&lt;&gt;();
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create an array of five <kbd class="calibre15">Thread</kbd> objects to store the threads that will execute the five tasks:</li>
</ol>
<pre class="calibre23">
        Thread taskThreads[]=new Thread[5];
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create five <kbd class="calibre15">Task</kbd> objects. Store the threads in the array created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;taskThreads.length; i++){ <br class="title-page-name"/>          Task task=new Task(i,queue); <br class="title-page-name"/>          taskThreads[i]=new Thread(task); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Start the five threads created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;taskThreads.length ; i++) { <br class="title-page-name"/>          taskThreads[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Wait for the finalization of the five threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;taskThreads.length ; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            taskThreads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Write the actual size of the queue in the console and the events stored in it. Use the <kbd class="calibre15">poll()</kbd> method to take off the events from the queue:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Queue Size: %d\n",queue.size()); <br class="title-page-name"/>        for (int i=0; i&lt;taskThreads.length*1000; i++){ <br class="title-page-name"/>          Event event=queue.poll(); <br class="title-page-name"/>          System.out.printf("Thread %s: Priority %d\n",<br class="title-page-name"/>                            event.getThread(),event.getPriority()); <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Write a message to the console with the final size of the queue:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Queue Size: %d\n",queue.size()); <br class="title-page-name"/>        System.out.printf("Main: End of the program\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, you implemented a priority queue of <kbd class="calibre15">Event</kbd> objects using <kbd class="calibre15">PriorityBlockingQueue</kbd>. As mentioned in the introduction, all the elements stored in <kbd class="calibre15">PriorityBlockingQueue</kbd> have to implement the <kbd class="calibre15">Comparable</kbd> interface or provide a <kbd class="calibre15">Comparator</kbd> object to the constructor of the queue. In this case, you used the first approach, so you implemented the <kbd class="calibre15">compareTo()</kbd> method in the <kbd class="calibre15">Event</kbd> class.</p>
<p class="calibre4">All the events have a priority attribute. The elements that have a higher value of priority will be the first elements in the queue. When you implement the <kbd class="calibre15">compareTo()</kbd> method, if the event executing the method has a priority higher than the priority of the event passed as a parameter, it returns <kbd class="calibre15">-1</kbd> as the result. In another case, if the event executing the method has a priority lower than the priority of the event passed as a parameter, it returns <kbd class="calibre15">1</kbd> as the result. If both objects have the same priority, the <kbd class="calibre15">compareTo()</kbd> method returns <kbd class="calibre15">0</kbd>. In this case, the <kbd class="calibre15">PriorityBlockingQueue</kbd> class doesn't guarantee the order of the elements.</p>
<p class="calibre4">We implemented the <kbd class="calibre15">Task</kbd> class to add the <kbd class="calibre15">Event</kbd> objects to the priority queue. Each task object adds 1,000 events to the queue, with priorities between <kbd class="calibre15">0</kbd> and <kbd class="calibre15">999</kbd>, using the <kbd class="calibre15">add()</kbd> method.</p>
<p class="calibre4">The <kbd class="calibre15">main()</kbd> method of the <kbd class="calibre15">Main</kbd> class creates five <kbd class="calibre15">Task</kbd> objects and executes them in the corresponding threads. When all the threads had finished their execution, you wrote all the elements to the console. To get the elements from the queue, we used the <kbd class="calibre15">poll()</kbd> method. This method returns and removes the first element from the queue.</p>
<p class="calibre4">The following screenshot shows part of the output of an execution of the program:</p>
<div class="cdpaligncenter"><img class="alignnone28" src="../images/00044.jpeg"/></div>
<p class="calibre4">You can see how the queue has a size of 5,000 elements and how the first elements have the biggest priority value.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">PriorityBlockingQueue</kbd> class has other interesting methods. The following is a description of some of them:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">clear()</kbd>: This method removes all the elements of the queue.</li>
<li class="calibre18"><kbd class="calibre15">take()</kbd>: This method returns and removes the first element of the queue. If the queue is empty, it blocks its thread until the queue has elements.</li>
<li class="calibre18"><kbd class="calibre15">put(E e)</kbd>: This is the class used to parameterize the <kbd class="calibre15">PriorityBlockingQueue</kbd> class. It inserts the element that is passed as a parameter into the queue.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>: This method returns the first element of the queue but doesn't remove it.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using blocking thread-safe deques</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using thread-safe lists with delayed elements</h1>
            

            <article>
                
<p class="calibre4">An interesting data structure provided by the Java API, which you can use in concurrent applications, is implemented in the <kbd class="calibre15">DelayQueue</kbd> class. In this class, you can store elements with an activation date. The methods that return or extract elements from the queue will ignore these elements whose data will appear in the future. They are invisible to these methods.To obtain this behavior, the elements you want to store in the <kbd class="calibre15">DelayQueue</kbd> class need to have the <kbd class="calibre15">Delayed</kbd> interface implemented. This interface allows you to work with delayed objects. This interface has the <kbd class="calibre15">getDelay()</kbd> method that returns the time until the activation of the element. This interface forces you to implement the following two methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">compareTo(Delayed o)</kbd>: The <kbd class="calibre15">Delayed</kbd> interface extends the <kbd class="calibre15">Comparable</kbd> interface. This method will return a value less than zero if the object that is executing the method has a delay smaller than the object passed as a parameter. It will return a value greater than zero if the object that is executing the method has a delay bigger than the object passed as a parameter. It will return zero if both the objects have the same delay.</li>
<li class="calibre18"><kbd class="calibre15">getDelay(TimeUnit unit)</kbd>: This method has to return the time remaining until the activation date in units, as specified by the unit parameter. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>
<p class="calibre4">In this example, you will learn how to use the <kbd class="calibre15">DelaydQueue</kbd> class by storing in it some events with different activation dates.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse<br class="title-page-name"/>
or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Event</kbd> and specify that it implements the <kbd class="calibre15">Delayed</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Event implements Delayed {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">Date</kbd> attribute named <kbd class="calibre15">startDate</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Date startDate;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Event (Date startDate) { <br class="title-page-name"/>          this.startDate=startDate; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">compareTo()</kbd> method. It receives a <kbd class="calibre15">Delayed</kbd> object as its parameter. Return the difference between the delay of the current object and the one passed as a parameter:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public int compareTo(Delayed o) { <br class="title-page-name"/>          long result=this.getDelay(TimeUnit.NANOSECONDS)-o.getDelay<br class="title-page-name"/>                                                    (TimeUnit.NANOSECONDS); <br class="title-page-name"/>          if (result&lt;0) { <br class="title-page-name"/>            return -1; <br class="title-page-name"/>          } else if (result&gt;0) { <br class="title-page-name"/>            return 1; <br class="title-page-name"/>          } <br class="title-page-name"/>          return 0; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">getDelay()</kbd> method. Return the difference between the start date of the object and the actual date in <kbd class="calibre15">TimeUnit</kbd>, which is received as a parameter:</li>
</ol>
<pre class="calibre23">
        public long getDelay(TimeUnit unit) {   <br class="title-page-name"/>          Date now=new Date(); <br class="title-page-name"/>          long diff=startDate.getTime()-now.getTime(); <br class="title-page-name"/>          return unit.convert(diff,TimeUnit.MILLISECONDS); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">id</kbd> to store a number that identifies this task:</li>
</ol>
<pre class="calibre23">
        private final int id;
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a private <kbd class="calibre15">DelayQueue</kbd> attribute parameterized by the <kbd class="calibre15">Event</kbd> class named <kbd class="calibre15">queue</kbd>:</li>
</ol>
<pre class="calibre23">
        private final DelayQueue&lt;Event&gt; queue;
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(int id, DelayQueue&lt;Event&gt; queue) { <br class="title-page-name"/>          this.id=id; <br class="title-page-name"/>          this.queue=queue; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. First, calculate the activation date of the events that this task is going to create. Then, add the number of seconds equal to the ID of the object to the actual date:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          Date now=new Date(); <br class="title-page-name"/>          Date delay=new Date(); <br class="title-page-name"/>          delay.setTime(now.getTime()+(id*1000)); <br class="title-page-name"/>          System.out.printf("Thread %s: %s\n",id,delay);
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Store 100 events in the queue using the <kbd class="calibre15">add()</kbd> method:</li>
</ol>
<pre class="calibre23">
          for (int i=0; i&lt;100; i++) { <br class="title-page-name"/>            Event event=new Event(delay); <br class="title-page-name"/>            queue.add(event); <br class="title-page-name"/>          }   <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create a <kbd class="calibre15">DelayQueue</kbd> object parameterized by the <kbd class="calibre15">Event</kbd> class:</li>
</ol>
<pre class="calibre23">
        DelayQueue&lt;Event&gt; queue=new DelayQueue&lt;&gt;();
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create an array of five <kbd class="calibre15">Thread</kbd> objects to store the tasks you're going to execute:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[5];
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create five <kbd class="calibre15">Task</kbd> objects with different IDs:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++){ <br class="title-page-name"/>          Task task=new Task(i+1, queue); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Launch all the five tasks created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          threads[i].join(); <br class="title-page-name"/>        }
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Write to the console the events stored in the queue. When the size of the queue is bigger than zero, use the <kbd class="calibre15">poll()</kbd> method to obtain an <kbd class="calibre15">Event</kbd> class. If it returns <kbd class="calibre15">null</kbd>, put the main thread to sleep for 500 milliseconds for the activation of more events:</li>
</ol>
<pre class="calibre23">
            do { <br class="title-page-name"/>              int counter=0; <br class="title-page-name"/>              Event event; <br class="title-page-name"/>              do { <br class="title-page-name"/>                event=queue.poll(); <br class="title-page-name"/>                if (event!=null) counter++; <br class="title-page-name"/>              } while (event!=null); <br class="title-page-name"/>              System.out.printf("At %s you have read %d events\n",<br class="title-page-name"/>                                new Date(), counter); <br class="title-page-name"/>              TimeUnit.MILLISECONDS.sleep(500); <br class="title-page-name"/>            } while (queue.size()&gt;0); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented the <kbd class="calibre15">Event</kbd> class. This class has a unique attribute, the activation date of the events, and it implements the <kbd class="calibre15">Delayed</kbd> interface. You can store <kbd class="calibre15">Event</kbd> objects in the <kbd class="calibre15">DelayQueue</kbd> class.</p>
<p class="calibre4">The <kbd class="calibre15">getDelay()</kbd> method returns the number of nanoseconds between the activation date and the actual date. Both dates are objects of the <kbd class="calibre15">Date</kbd> class. You used the <kbd class="calibre15">getTime()</kbd> method that returns a date converted into milliseconds. Then, you converted this value into <kbd class="calibre15">TimeUnit</kbd>, which was received as a parameter. The <kbd class="calibre15">DelayQueue</kbd> class works in nanoseconds, but at this point, it's transparent to you.</p>
<p class="calibre4">The <kbd class="calibre15">compareTo()</kbd> method returns a value less than zero if the delay of the object executing the method is smaller than the delay of the object passed as a parameter. It returns a value greater than zero if the delay of the object executing the method is bigger than the delay of the object passed as a parameter. It returns <kbd class="calibre15">0</kbd> if both the delays are equal.</p>
<p class="calibre4">You also implemented the <kbd class="calibre15">Task</kbd> class. This class has an <kbd class="calibre15">integer</kbd> attribute named <kbd class="calibre15">id</kbd>. When a <kbd class="calibre15">Task</kbd> object is executed, it adds the number of seconds that is equal to the ID of the task to the actual date, and this refers to the activation date of the events stored by this task in the <kbd class="calibre15">DelayQueue</kbd> class. Each <kbd class="calibre15">Task</kbd> object stores 100 events in the queue using the <kbd class="calibre15">add()</kbd> method.</p>
<p class="calibre4">Finally, in the <kbd class="calibre15">main()</kbd> method of the <kbd class="calibre15">Main</kbd> class, you created five <kbd class="calibre15">Task</kbd> objects and executed them in their corresponding threads. When these threads finished their execution, you wrote all the events using the <kbd class="calibre15">poll()</kbd> method in the console. This method retrieves and removes the first element of the queue. If the queue does not have any active element, it returns the <kbd class="calibre15">null</kbd> value. You call the <kbd class="calibre15">poll()</kbd> method, and if it returns an <kbd class="calibre15">Event</kbd> class, you increment a counter. When it returns the <kbd class="calibre15">null</kbd> value, you write the value of the counter in the console and put the thread to sleep for half a second to wait for more active events. When you obtained the 500 events stored in the queue, the execution of the program finished.</p>
<p class="calibre4">The following screenshot shows part of the output of an execution of the program:</p>
<div class="cdpaligncenter"><img class="alignnone29" src="../images/00045.jpeg"/></div>
<p class="calibre4">You can see how the program only gets 100 events when it is activated.</p>
<div class="packt_infobox">You must be very careful with the <kbd class="calibre25">size()</kbd> method. It returns the total number of elements in the list that includes both active and non-active elements.</div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">DelayQueue</kbd> class has other interesting methods, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">clear()</kbd>: This method removes all the elements of the queue.</li>
<li class="calibre18"><kbd class="calibre15">offer(E e)</kbd>: Here, <kbd class="calibre15">E</kbd> represents the class used to parameterize the <kbd class="calibre15">DelayQueue</kbd> class. This method inserts the element that is passed as a parameter into the queue.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>: This method retrieves but doesn't remove the first element of the queue.</li>
<li class="calibre18"><kbd class="calibre15">take()</kbd>: This method retrieves and removes the first element of the queue. If there aren't any active elements, the thread that is executing the method will be blocked until the thread gets some active elements.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using blocking thread-safe deques</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using thread-safe navigable maps</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ConcurrentNavigableMap</kbd> is an interface that defines interesting data structures provided by the Java API that you can use in your concurrent programs. The classes that implement the <kbd class="calibre15">ConcurrentNavigableMap</kbd> interface stores elements in two parts:</p>
<ul class="calibre17">
<li class="calibre18">A <strong class="calibre1">key</strong> that uniquely identifies an element</li>
<li class="calibre18">The rest of the data that defines the element, called <strong class="calibre1">value</strong></li>
</ul>
<p class="calibre4">The Java API also provides a class that implements <kbd class="calibre15">ConcurrentSkipListMap</kbd>, which is the interface that implements a non-blocking list with the behavior of the <kbd class="calibre15">ConcurrentNavigableMap</kbd> interface. Internally, it uses a <strong class="calibre1">Skip List</strong> to store data. A Skip List is a data structure based on parallel lists that allow us to get the kind of efficiency that is associated with a binary tree. You can get more information about Skip Lists at <a href="https://en.wikipedia.org/wiki/Skip_list" class="calibre9">https://en.wikipedia.org/wiki/Skip_list</a>. With it, you can get a sorted data structure, instead of a sorted list, with better access time to insert, search, or delete elements.</p>
<div class="packt_infobox">Skip List was introduced by William Pugh in 1990.</div>
<p class="calibre4">When you insert an element to a map, the map uses a key to order them; therefore, all the elements will be ordered. The keys have to implement the <kbd class="calibre15">Comparable</kbd> interface, or you have to supply a <kbd class="calibre15">Comparator</kbd> class <span>to</span> the constructor of the map. The class also provides methods to obtain a submap of the map, in addition to the ones that return a concrete element.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">ConcurrentSkipListMap</kbd> class to implement a map of contacts.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Contact</kbd>:</li>
</ol>
<pre class="calibre23">
        public class Contact {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two private <kbd class="calibre15">String</kbd> attributes named <kbd class="calibre15">name</kbd> and <kbd class="calibre15">phone</kbd>:</li>
</ol>
<pre class="calibre23">
        private final String name; <br class="title-page-name"/>        private final String phone;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Contact(String name, String phone) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>          this.phone=phone; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the methods to return the values of the <kbd class="calibre15">name</kbd> and <kbd class="calibre15">phone</kbd> attributes:</li>
</ol>
<pre class="calibre23">
        public String getName() { <br class="title-page-name"/>          return name; <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        public String getPhone() { <br class="title-page-name"/>          return phone; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare a private <kbd class="calibre15">ConcurrentSkipListMap</kbd> attribute, parameterized by the <kbd class="calibre15">String</kbd> and <kbd class="calibre15">Contact</kbd> classes, named <kbd class="calibre15">map</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ConcurrentSkipListMap&lt;String, Contact&gt; map;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">id</kbd> to store the ID of the current task:</li>
</ol>
<pre class="calibre23">
        private final String id;
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the constructor of the class to store its attributes:</li>
</ol>
<pre class="calibre23">
        public Task (ConcurrentSkipListMap&lt;String, Contact&gt; map,String id){ <br class="title-page-name"/>          this.id=id; <br class="title-page-name"/>          this.map=map; <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It stores 1,000 different contacts in the map using the ID of the task and an incremental number to create <kbd class="calibre15">Contact</kbd> objects. Use the <kbd class="calibre15">put()</kbd> method to store the contacts in the map:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;1000; i++) { <br class="title-page-name"/>            Contact contact=new Contact(id, String.valueOf(i+1000)); <br class="title-page-name"/>            map.put(id+contact.getPhone(), contact); <br class="title-page-name"/>          }     <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a <kbd class="calibre15">ConcurrentSkipListMap</kbd> object, parameterized by the <kbd class="calibre15">String</kbd> and <kbd class="calibre15">Conctact</kbd> classes, named <kbd class="calibre15">map</kbd>:</li>
</ol>
<pre class="calibre23">
        ConcurrentSkipListMap&lt;String, Contact&gt; map = new<br class="title-page-name"/>                                          ConcurrentSkipListMap&lt;&gt;();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create an array for 26 <kbd class="calibre15">Thread</kbd> objects to store all the <kbd class="calibre15">Task</kbd> objects that you're going to execute:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[26]; <br class="title-page-name"/>        int counter=0;
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create and launch 26 <kbd class="calibre15">task</kbd> objects and assign a capital letter to the ID of each task:</li>
</ol>
<pre class="calibre23">
        for (char i='A'; i&lt;='Z'; i++) { <br class="title-page-name"/>          Task task=new Task(map, String.valueOf(i)); <br class="title-page-name"/>          threads[counter]=new Thread(task); <br class="title-page-name"/>          threads[counter].start(); <br class="title-page-name"/>          counter++; <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (Thread thread : threads){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Get the first entry of the map using the <kbd class="calibre15">firstEntry()</kbd> method. Write its data to the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Size of the map: %d\n",map.size()); <br class="title-page-name"/>     <br class="title-page-name"/>        Map.Entry&lt;String, Contact&gt; element; <br class="title-page-name"/>        Contact contact; <br class="title-page-name"/>     <br class="title-page-name"/>        element=map.firstEntry(); <br class="title-page-name"/>        contact=element.getValue(); <br class="title-page-name"/>        System.out.printf("Main: First Entry: %s: %s\n", contact.getName(), <br class="title-page-name"/>                          contact.getPhone());
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Get the last entry of the map using the <kbd class="calibre15">lastEntry()</kbd> method. Write its data to the console:</li>
</ol>
<pre class="calibre23">
        element=map.lastEntry(); <br class="title-page-name"/>        contact=element.getValue(); <br class="title-page-name"/>        System.out.printf("Main: Last Entry: %s: %s\n", contact.getName(),<br class="title-page-name"/>                          contact.getPhone());
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Obtain a submap of the map using the <kbd class="calibre15">subMap()</kbd> method. Write its data to the console:</li>
</ol>
<pre class="calibre23">
          System.out.printf("Main: Submap from A1996 to B1002: \n"); <br class="title-page-name"/>          ConcurrentNavigableMap&lt;String, Contact&gt; submap=map<br class="title-page-name"/>                                               .subMap("A1996","B1002"); <br class="title-page-name"/>          do { <br class="title-page-name"/>            element=submap.pollFirstEntry(); <br class="title-page-name"/>            if (element!=null) { <br class="title-page-name"/>              contact=element.getValue(); <br class="title-page-name"/>              System.out.printf("%s: %s\n", contact.getName(),<br class="title-page-name"/>                                contact.getPhone()); <br class="title-page-name"/>            } <br class="title-page-name"/>          } while (element!=null); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented a <kbd class="calibre15">Task</kbd> class to store <kbd class="calibre15">Contact</kbd> objects in a navigable map. Each contact has a name, which is the ID of the task that creates it, and a phone number, which is a number between 1,000 and 2,000. We concatenated these values as keys for the contacts. Each <kbd class="calibre15">Task</kbd> object creates 1,000 contacts; these contacts are stored in the navigable map using the <kbd class="calibre15">put()</kbd> method.</p>
<div class="packt_infobox">If you insert an element with a key that exists in the map, the element associated with that key will be replaced by the new element.</div>
<p class="calibre4">The <kbd class="calibre15">main()</kbd> method of the <kbd class="calibre15">Main</kbd> class creates 26 <kbd class="calibre15">Task</kbd> objects, using the letters between A and Z as IDs. Then, you used some methods to obtain data from the map. The <kbd class="calibre15">firstEntry()</kbd> method returns a <kbd class="calibre15">Map.Entry</kbd> object with the first element of the map. This method doesn't remove the element from the map. The object contains the key and the element. To obtain the element, you called the <kbd class="calibre15">getValue()</kbd> method. You can use the <kbd class="calibre15">getKey()</kbd> method to obtain the key of that element.</p>
<p class="calibre4">The <kbd class="calibre15">lastEntry()</kbd> method returns a <kbd class="calibre15">Map.Entry</kbd> object with the last element of the map. The <kbd class="calibre15">subMap()</kbd> method returns the <kbd class="calibre15">ConcurrentNavigableMap</kbd> object with part of the elements of the map, in this case, the elements that had keys between <kbd class="calibre15">A1996</kbd> and <kbd class="calibre15">B1002</kbd>. You used the <kbd class="calibre15">pollFirst()</kbd> method to process the elements of the <kbd class="calibre15">subMap()</kbd> method. This method returns and removes the first <kbd class="calibre15">Map.Entry</kbd> object of the submap.</p>
<p class="calibre4">The following screenshot shows the output of an execution of the program:</p>
<div class="cdpaligncenter"><img class="alignnone30" src="../images/00046.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ConcurrentSkipListMap</kbd> class has other interesting methods. Some of them are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">headMap(K toKey)</kbd>: Here, <kbd class="calibre15">K</kbd> is the class of the key values used in the parameterization of the <kbd class="calibre15">ConcurrentSkipListMap</kbd> object. This method returns a submap of the first elements of the map with the elements that have a key smaller than the one passed as a parameter.</li>
<li class="calibre18"><kbd class="calibre15">tailMap(K fromKey)</kbd>: Here, <kbd class="calibre15">K</kbd> is the class of the key values used in the parameterization of the <kbd class="calibre15">ConcurrentSkipListMap</kbd> object. This method returns a submap of the last elements of the map with the elements that have a key greater than the one passed as a parameter.</li>
<li class="calibre18"><kbd class="calibre15">putIfAbsent(K key, V Value)</kbd>: This method inserts the value specified as a parameter and also the key specified as a parameter if it doesn't exist in the map.</li>
<li class="calibre18"><kbd class="calibre15">pollLastEntry()</kbd>: This method returns and removes a <kbd class="calibre15">Map.Entry</kbd> object with the last element of the map.</li>
<li class="calibre18"><kbd class="calibre15">replace(K key, V Value)</kbd>: This method replaces the value associated with the key specified as a parameter if this key exists in the map.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using non-blocking thread-safe deques</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using thread-safe HashMaps</h1>
            

            <article>
                
<p class="calibre4">A hash table is a data structure that allows you to map a key to a value. Internally, it usually uses an array to store the elements and a hash function to calculate the position of the element in the array, using its key. The main advantage of this data structure is that the insert, delete, and search operations are very fast here, so it's very useful in situations when you have to carry out a lot of search operations.</p>
<p class="calibre4">The Java API provides different hash table implementations through the <kbd class="calibre15">Map</kbd> and <kbd class="calibre15">ConcurrentMap</kbd> interfaces. The <kbd class="calibre15">ConcurrentMap</kbd> interface provides thread-safety and atomic guarantees to all the operations, so you can use them in concurrent applications. The <kbd class="calibre15">ConcurrentHashMap</kbd> class implements the <kbd class="calibre15">ConcurrentMap</kbd> interface and adds some more methods to the ones defined in the interface. This class supports the following:</p>
<ul class="calibre17">
<li class="calibre18">Full concurrency of read operations</li>
<li class="calibre18">High expected concurrency for insert and delete operations</li>
</ul>
<p class="calibre4">Both the elements (class and interface) were introduced in Java version 5, but in version 8, a lot of new methods similar to the ones provided by the stream API were developed.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">ConcurrentHashMap</kbd> class in your application and the most important methods it provides.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Operation</kbd> with three attributes: a <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">user</kbd>, a <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">operation</kbd>, and a <kbd class="calibre15">Date</kbd> attribute named <kbd class="calibre15">time</kbd>. Add the methods to get and set the values of the attributes. The code of this class is very simple, so it won't be included here.</li>
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">HashFiller</kbd>. Specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class HashFiller implements Runnable {
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">ConsurrentHashMap</kbd> attribute named <kbd class="calibre15">userHash</kbd>. The key of the hash will be a <kbd class="calibre15">String</kbd> type and its value will be a <kbd class="calibre15">ConcurrentLinkedDeque</kbd> object of <kbd class="calibre15">Operation</kbd> objects. Implement the constructor of the class to initialize the attribute:</li>
</ol>
<pre class="calibre23">
        private ConcurrentHashMap&lt;String, ConcurrentLinkedDeque&lt;Operation&gt;&gt;<br class="title-page-name"/>                userHash; <br class="title-page-name"/> <br class="title-page-name"/>        public HashFiller(ConcurrentHashMap&lt;String, ConcurrentLinkedDeque<br class="title-page-name"/>                          &lt;Operation&gt;&gt; userHash) { <br class="title-page-name"/>          this.userHash = userHash; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. We're going to fill <kbd class="calibre15">ConcurrentHashMap</kbd> with 100 random <kbd class="calibre15">Operation</kbd> objects. First, generate random data and then use the <kbd class="calibre15">addOperationToHash()</kbd> method to insert the object in the hash:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/> <br class="title-page-name"/>          Random randomGenerator = new Random(); <br class="title-page-name"/>          for (int i = 0; i &lt; 100; i++) { <br class="title-page-name"/>            Operation operation = new Operation(); <br class="title-page-name"/>            String user = "USER" + randomGenerator.nextInt(100); <br class="title-page-name"/>            operation.setUser(user); <br class="title-page-name"/>            String action = "OP" + randomGenerator.nextInt(10); <br class="title-page-name"/>            operation.setOperation(action); <br class="title-page-name"/>            operation.setTime(new Date()); <br class="title-page-name"/> <br class="title-page-name"/>            addOperationToHash(userHash, operation); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">addOperationToHash()</kbd> method. It receives the hash and the operation you want to add as parameters. The key in the map will be the user assigned to the operation. We use the <kbd class="calibre15">computeIfAbsent()</kbd> method to obtain the <kbd class="calibre15">ConcurrentLinkedDeque</kbd> object associated with the key. If the key exists, this method returns the value associated with it. If it doesn't, it executes the lambda expression passed as a parameter to this method to generate the value and associate it with the key. In this case, we generate a new <kbd class="calibre15">ConcurrentLinkedDeque</kbd> object. Finally, insert the operation to the deque:</li>
</ol>
<pre class="calibre23">
        private void addOperationToHash(ConcurrentHashMap&lt;String,<br class="title-page-name"/>                                        ConcurrentLinkedDeque&lt;Operation&gt;&gt;<br class="title-page-name"/>                                        userHash, Operation operation) { <br class="title-page-name"/> <br class="title-page-name"/>          ConcurrentLinkedDeque&lt;Operation&gt; opList = userHash<br class="title-page-name"/>                                   .computeIfAbsent(operation.getUser(),<br class="title-page-name"/>                                   user -&gt; new ConcurrentLinkedDeque&lt;&gt;()); <br class="title-page-name"/>                                 <br class="title-page-name"/>          opList.add(operation); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now implement the <kbd class="calibre15">Main</kbd> class and include the <kbd class="calibre15">main()</kbd> method. First, declare a <kbd class="calibre15">ConcurrentHashMap</kbd> object and a <kbd class="calibre15">HashFiller</kbd> task:</li>
</ol>
<pre class="calibre23">
        ConcurrentHashMap&lt;String, ConcurrentLinkedDeque&lt;Operation&gt;&gt;<br class="title-page-name"/>          userHash = new ConcurrentHashMap&lt;&gt;(); <br class="title-page-name"/>        HashFiller hashFiller = new HashFiller(userHash);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Execute 10 threads with the <kbd class="calibre15">HashFiller</kbd> class and wait for their finalization using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        Thread[] threads = new Thread[10]; <br class="title-page-name"/>        for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>          threads[i] = new Thread(hashFiller); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        for (int i = 0; i &lt; 10; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Now, extract the information of <kbd class="calibre15">ConcurrentHashMap</kbd>. First, extract the number of elements stored in it with the <kbd class="calibre15">size()</kbd> method. Then, use the <kbd class="calibre15">forEach()</kbd> method to apply an action to all the elements stored in the hash. The first parameter is the parallelism threshold. This is the minimum number of elements required to make the operation execute in a concurrent way. We have specified the value 10 and the hash has 100 elements, so the operation will be executed in a parallel way. The lambda expression receives two parameters: key and value. Print the key and size of <kbd class="calibre15">ConcurrentLinkedDeque</kbd> stored as a value:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Size: %d\n", userHash.size()); <br class="title-page-name"/> <br class="title-page-name"/>        userHash.forEach(10, (user, list) -&gt; { <br class="title-page-name"/>          System.out.printf("%s: %s: %d\n", Thread.currentThread()<br class="title-page-name"/>                            .getName(), user, list.size()); <br class="title-page-name"/>        });
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, use the <kbd class="calibre15">forEachEntry()</kbd> method. This is similar to the previous one, but the lambda expression receives an <kbd class="calibre15">Entry</kbd> object as a parameter instead of receiving two parameters. You can use this entry object to obtain the key and value:</li>
</ol>
<pre class="calibre23">
        userHash.forEachEntry(10, entry -&gt; { <br class="title-page-name"/>          System.out.printf("%s: %s: %d\n", Thread.currentThread()<br class="title-page-name"/>                            .getName(), entry.getKey(), <br class="title-page-name"/>          entry.getValue().size()); <br class="title-page-name"/>        });
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, use the <kbd class="calibre15">search()</kbd> method to find the first element that satisfies the search function specified. In our case, we search for an operation whose operation code ends in 1. As occurs with the <kbd class="calibre15">forEach()</kbd> method, we specify a parallelism threshold:</li>
</ol>
<pre class="calibre23">
        Operation op = userHash.search(10, (user, list) -&gt; { <br class="title-page-name"/>          for (Operation operation : list) { <br class="title-page-name"/>            if (operation.getOperation().endsWith("1")) { <br class="title-page-name"/>              return operation; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          return null; <br class="title-page-name"/>        }); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("The operation we have found is: %s, %s, %s,\n",<br class="title-page-name"/>                          op.getUser(), op.getOperation(), op.getTime());
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Use the <kbd class="calibre15">search()</kbd> method again, but <span>this time, use it to find a user with more than 10 operations:</span></li>
</ol>
<pre class="calibre23">
        ConcurrentLinkedDeque&lt;Operation&gt; operations = userHash.search(10,<br class="title-page-name"/>                                                          (user, list) -&gt; { <br class="title-page-name"/>          if (list.size() &gt; 10) { <br class="title-page-name"/>            return list; <br class="title-page-name"/>          } <br class="title-page-name"/>          return null; <br class="title-page-name"/>        }); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("The user we have found is: %s: %d operations\n",<br class="title-page-name"/>                          operations.getFirst().getUser(),<br class="title-page-name"/>                          operations.size());
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Finally, use the <kbd class="calibre15">reduce()</kbd> method to calculate the total number of operations stored in the hash:</li>
</ol>
<pre class="calibre23">
            int totalSize = userHash.reduce(10, (user, list) -&gt; { <br class="title-page-name"/>              return list.size(); <br class="title-page-name"/>            }, (n1, n2) -&gt; { <br class="title-page-name"/>              return n1 + n2; <br class="title-page-name"/>            }); <br class="title-page-name"/> <br class="title-page-name"/>            System.out.printf("The total size is: %d\n", totalSize); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented an application that uses <kbd class="calibre15">ConcurrentHashMap</kbd> to store information about operations made by users. Internally, the hash table uses the user attribute of the <kbd class="calibre15">Operation</kbd> class as a key and <kbd class="calibre15">ConcurrentLinkedDeque</kbd> (a non-blocking concurrent list) as its value to store all the operations associated with that user.</p>
<p class="calibre4">First, we filled the hash with some <span>random</span> data using 10 different threads. We implemented the <kbd class="calibre15">HashFiller</kbd> task for this purpose. The biggest problem with these tasks is what happens when you have to insert a key in the hash table. If two threads want to add the same key at the same time, you can lose the data inserted by one of the threads and have a data-race condition. To solve this problem, we used the <kbd class="calibre15">computeIfAbsent()</kbd> method.</p>
<p class="calibre4">This method receives a key and an implementation of the <kbd class="calibre15">Function</kbd> interface that can be expressed as a lambda expression; the key and implementation are received as parameters. If the key exists, the method returns the value associated with the key. If it doesn't, the method executes the <kbd class="calibre15">Function</kbd> object specified and adds the key and value returned by <kbd class="calibre15">Function</kbd> to the HashMap. In our case, the key didn't exist, so we created a new instance of the <kbd class="calibre15">ConcurrentLinkedDeque</kbd> class. The main advantage of this method is that it's executed atomically; so, if another thread tries to do the same operation, it will be blocked until this operation is finished.</p>
<p class="calibre4">Then, in the <kbd class="calibre15">main()</kbd> method, we used other methods of <kbd class="calibre15">ConcurrentHashMap</kbd> to process the information stored in the hash. We used the following methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">forEach()</kbd>: This method receives an implementation of the <kbd class="calibre15">BiConsumer</kbd> interface that can be expressed as a lambda expression; it is received as a parameter. The other two parameters of this expression represent the key and value of the element we're processing. This method applies the expression to all the elements stored in <kbd class="calibre15">ConcurrentHashMap</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">forEachEntry()</kbd>: This method is equivalent to the previous one, but here the expression is an implementation of the <kbd class="calibre15">Consumer</kbd> interface. It receives an <kbd class="calibre15">Entry</kbd> object that stores the key and value of the entry we're processing as a parameter. This is another way to express the same functionality.</li>
<li class="calibre18"><kbd class="calibre15">search()</kbd>: This method receives the implementation of the <kbd class="calibre15">BiFunction</kbd> interface that can be expressed as a lambda expression; it is received as a parameter. This function also receives the key and value of the entry of the <kbd class="calibre15">ConcurrentHashMap</kbd> object we're processing as parameters. It returns the first non-null value returned by <kbd class="calibre15">BiFunction</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">reduce()</kbd>: This method receives two <kbd class="calibre15">BiFunction</kbd> <span>interfaces</span> to reduce the elements of <kbd class="calibre15">ConcurrentHashMap</kbd> to a unique value. This allows you to implement a <kbd class="calibre15">MapReduce</kbd> operation with the elements of <kbd class="calibre15">ConcurrentHashMap</kbd>. The first <kbd class="calibre15">BiFunction</kbd> <span>interface</span> allows you to transform the key and value of the elements into a unique value, and the second <kbd class="calibre15">BiFunction</kbd> <span>interface</span> allows you to aggregate the values of two different elements.</li>
</ul>
<p class="calibre4">All the methods described so far have a first parameter named <kbd class="calibre15">parallelismThreshold</kbd>. This parameter is described as <em class="calibre14">...the (estimated) number of elements needed for this operation to be executed in parallel...,</em> that is to say, if <kbd class="calibre15">ConcurrentHashMap</kbd> has fewer elements than the value specified in the parameter, the method is executed in a sequential way. On the contrary (as in our case), the method is executed in a parallel way.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4"><kbd class="calibre15">ConcurrentHashMap</kbd> has more methods than what's specified in the previous section. We enumerate some of them in the following list:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">forEachKey()</kbd> and <kbd class="calibre15">forEachValue()</kbd>: These methods are similar to the <kbd class="calibre15">forEach()</kbd> methods, but in this case, the expression processes the keys and values stored in <kbd class="calibre15">ConcurrentHashMap</kbd>, respectively.</li>
<li class="calibre18"><kbd class="calibre15">searchEntries()</kbd>, <kbd class="calibre15">searchKeys()</kbd>, and <kbd class="calibre15">searchValues()</kbd>: These methods are similar to the <kbd class="calibre15">search()</kbd> method explained before. However, in this case, the expression passed as a parameter receives an <kbd class="calibre15">Entry</kbd> object, a key, or a value of the elements stored in <kbd class="calibre15">ConcurrentHashMap</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">reduceEntries()</kbd>, <kbd class="calibre15">reduceKeys()</kbd>, and <kbd class="calibre15">reduceValues()</kbd>: These methods are similar to the <kbd class="calibre15">reduce()</kbd> method explained before. However, in this case, the expression passed as a parameter receives an <kbd class="calibre15">Entry</kbd> object, a key, or a value of the elements stored in <kbd class="calibre15">ConcurrentHashMap</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">reduceXXXToDouble()</kbd>, <kbd class="calibre15">reduceXXXToLong()</kbd>, and <kbd class="calibre15">reduceXXXToInt()</kbd>: These methods allow you to make a reduction of the elements of <kbd class="calibre15">ConcurrentHashMap</kbd> by generating a <kbd class="calibre15">double</kbd>, <kbd class="calibre15">long</kbd>, or <kbd class="calibre15">int</kbd> value, respectively.</li>
<li class="calibre18"><kbd class="calibre15">computeIfPresent()</kbd>: This method complements the <kbd class="calibre15">computeIfAbsent()</kbd> method. In this case, it receives a key and an implementation of the <kbd class="calibre15">BiFunction</kbd> interface that can be expressed as a lambda expression. If the key exists in the <kbd class="calibre15">HashMap</kbd>, the method applies the expression to calculate the new value of the key. The <kbd class="calibre15">BiFunction</kbd> interface receives the key and the actual value of that key as parameters, and it returns the new value.</li>
<li class="calibre18"><kbd class="calibre15">merge()</kbd>: This method receives a key, value, and implementation of the <kbd class="calibre15">BiFunction</kbd> interface that can be expressed as a lambda expression; they are received as parameters. If the key doesn't exist in <kbd class="calibre15">ConcurrentHashMap</kbd>, it inserts it there and associates the value parameter with it. If it exists, execute <kbd class="calibre15">BiFunction</kbd> to calculate the new value associated with the key. The <kbd class="calibre15">BiFunction</kbd> <span>interface</span> receives the key and its actual value as parameters and returns the new value associated with the key.</li>
<li class="calibre18"><kbd class="calibre15">getOrDefault()</kbd>: This method receives a key and a default value as parameters. If the key exists in <kbd class="calibre15">ConcurrentHashMap</kbd>, it returns its associated value. Otherwise, it returns the default value.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using thread-safe navigable maps </em>recipe in <span>this chapter</span></li>
<li class="calibre18">The <em class="calibre14">Reducing the elements of a stream</em> recipe in <a href="part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736" class="calibre9">Chapter 6</a>, <em class="calibre14">Parallel and Reactive Streams</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using atomic variables</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">Atomic variables</strong> were introduced in Java version 5 to provide atomic operations on single variables. When you work with a normal variable, each operation that you implement in Java is transformed into several instructions of Java byte code that is understandable by the JVM when you compile the program. For example, when you assign a value to a variable, you only use one instruction in Java; however, when you compile this program, it is transformed into various instructions in the JVM language. This can lead to data inconsistency errors when you work with multiple threads that share a variable.</p>
<p class="calibre4">To avoid these problems, Java introduced atomic variables. When a thread is doing an operation with an atomic variable and if other threads want to do an operation with the same variable, the implementation of the class includes a mechanism to check that the operation is done atomically. Basically, the operation gets the value of the variable, changes the value to a local variable, and then tries to change the old value with the new one. If the old value is still the same, it is substituted; if not, the method begins the operation again. This operation is called <strong class="calibre1">Compare and Set</strong>. It implements the modification of the value of a variable in the following three steps:</p>
<ol class="calibre19">
<li value="1" class="calibre18">You get the value of the variable, which is the old value of the variable.</li>
<li value="2" class="calibre18">You change the value of the variable in a temporal variable, which is the new value of the variable.</li>
<li value="3" class="calibre18">You substitute the old value with the new value if the old value is equal to the actual value of the variable. The old value may be different from the actual value if another thread changes the value of the variable.</li>
</ol>
<p class="calibre4">Some of these variables, for example, the <kbd class="calibre15">LongAccumulator</kbd> class, receive an operation as a parameter that could be executed inside some of its methods. These operations must be free from any side effects, as they might be executed multiple times in every value update.</p>
<p class="calibre4">Atomic variables don't use locks or other synchronization mechanisms to protect access to their values. All their operations are based on Compare and Set. It's guaranteed that several threads can work with an atomic variable at a time without generating data inconsistency errors; plus, they simplify the implementation.</p>
<p class="calibre4">Java 8 has added four new atomic classes. First we have the <kbd class="calibre15">LongAdder</kbd> and <kbd class="calibre15">DoubleAdder</kbd> classes; they store <kbd class="calibre15">long</kbd> and <kbd class="calibre15">double</kbd> values that are updated frequently by different threads. You can obtain the same functionality as that of the <kbd class="calibre15">LongAdder</kbd> class with the <kbd class="calibre15">AtomicLong</kbd> class, but the former provides better performance. The other two classes are <kbd class="calibre15">LongAccumulator</kbd> and <kbd class="calibre15">DoubleAccumulator</kbd>. These classes are similar to the previous one, but here, you have to specify two parameters in the constructor:</p>
<ul class="calibre17">
<li class="calibre18">The initial value of the counter.</li>
<li class="calibre18">A <kbd class="calibre15">LongBinaryOperator</kbd> or <kbd class="calibre15">DoubleBinaryOperator</kbd> that can be indicated as a lambda expression. This expression receives the old value of the variable and the increment you want to apply and returns the new value of the variable.</li>
</ul>
<p class="calibre4">In this recipe, you will learn how to use atomic variables implementing a bank account and two different tasks: one that adds money to the account and one that subtracts money from it. You will use the <kbd class="calibre15">AtomicLong</kbd> class in the implementation of the example.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you are using Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Account</kbd> to simulate a bank account:</li>
</ol>
<pre class="calibre23">
        public class Account {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">AtomicLong</kbd> attribute named <kbd class="calibre15">balance</kbd> to store the balance of the account. In addition, declare a private <kbd class="calibre15">LongAdder</kbd> attribute named operations and a private <kbd class="calibre15">DoubleAccumulator</kbd> attribute named commission:</li>
</ol>
<pre class="calibre23">
        private final AtomicLong balance; <br class="title-page-name"/>        private final LongAdder operations; <br class="title-page-name"/>        private final DoubleAccumulator commission;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attributes. For the <kbd class="calibre15">DoubleAccumulator</kbd> class, the identity value is <kbd class="calibre15">0</kbd> and we update the actual value with the result of multiply <kbd class="calibre15">0.2</kbd> to the increment passed as parameter:</li>
</ol>
<pre class="calibre23">
        public Account() { <br class="title-page-name"/>          balance = new AtomicLong(); <br class="title-page-name"/>          operations = new LongAdder(); <br class="title-page-name"/>          commission = new DoubleAccumulator((x,y)-&gt; x+y*0.2, 0); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the method to get the value of the three attributes:</li>
</ol>
<pre class="calibre23">
        public long getBalance() { <br class="title-page-name"/>          return balance.get(); <br class="title-page-name"/>        } <br class="title-page-name"/>        public long getOperations() { <br class="title-page-name"/>          return operations.longValue(); <br class="title-page-name"/>        } <br class="title-page-name"/>        public double getCommission() { <br class="title-page-name"/>          return commission.get(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement a method named <kbd class="calibre15">setBalance()</kbd> to establish the value of the balance attribute. We also have to initialize the operations and commission attributes using the <kbd class="calibre15">reset()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public void setBalance(long balance) { <br class="title-page-name"/>          this.balance.set(balance); <br class="title-page-name"/>          operations.reset(); <br class="title-page-name"/>          commission.reset(); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement a method named <kbd class="calibre15">addAmount()</kbd> to increment the value of the <kbd class="calibre15">balance</kbd> attribute. In addition, use the <kbd class="calibre15">increment()</kbd> method of the <kbd class="calibre15">LongAdder</kbd> class to increment the value of the <kbd class="calibre15">operations</kbd> attribute and the <kbd class="calibre15">accumulate()</kbd> method by one unit to add 20 percent of the amount value to the <kbd class="calibre15">commission</kbd> object:</li>
</ol>
<pre class="calibre23">
        public void addAmount(long amount) { <br class="title-page-name"/>          this.balance.getAndAdd(amount); <br class="title-page-name"/>          this.operations.increment(); <br class="title-page-name"/>          this.commission.accumulate(amount);<br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement a <span>method </span><span>named</span> <kbd class="calibre15">substractAmount()</kbd> <span>to decrement the value of the</span> <kbd class="calibre15">balance</kbd> <span>attribute. As it occurs with the</span> <kbd class="calibre15">addAmount()</kbd> <span>method, we modify the values of the</span> <kbd class="calibre15">operations</kbd> <span>and</span> <kbd class="calibre15">commission</kbd> <span>attributes:</span></li>
</ol>
<pre class="calibre23">
        public void subtractAmount(long amount) { <br class="title-page-name"/>          this.balance.getAndAdd(-amount); <br class="title-page-name"/>          this.operations.increment(); <br class="title-page-name"/>          this.commission.accumulate(amount);<br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">Company</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class will simulate the payments made by a company:</li>
</ol>
<pre class="calibre23">
        public class Company implements Runnable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare a private <kbd class="calibre15">Account</kbd> attribute named <kbd class="calibre15">account</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Account account;
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Company(Account account) { <br class="title-page-name"/>          this.account=account; <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the task. Use the <kbd class="calibre15">addAmount()</kbd> method of the account to make 10 increments of 1,000 each in its balance:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>            account.addAmount(1000); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create a class named <kbd class="calibre15">Bank</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class will simulate the withdrawal of money from the account:</li>
</ol>
<pre class="calibre23">
        public class Bank implements Runnable {
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Declare a private <kbd class="calibre15">Account</kbd> attribute named <kbd class="calibre15">account</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Account account;
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Bank(Account account) { <br class="title-page-name"/>          this.account=account; <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the task. Use the <kbd class="calibre15">subtractAmount()</kbd> method of the account to make 10 decrements of 1,000 each from its balance:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>            account.subtractAmount(1000); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create an <kbd class="calibre15">Account</kbd> object and set its balance to <kbd class="calibre15">1000</kbd>:</li>
</ol>
<pre class="calibre23">
        Account  account=new Account(); <br class="title-page-name"/>        account.setBalance(1000);
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a new <kbd class="calibre15">Company</kbd> task and a thread to execute it:</li>
</ol>
<pre class="calibre23">
        Company company=new Company(account);<br class="title-page-name"/>        Thread companyThread=new Thread(company);
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create a new <kbd class="calibre15">Bank</kbd> task and a thread to execute it:</li>
</ol>
<pre class="calibre23">
        Bank bank=new Bank(account);<br class="title-page-name"/>        Thread bankThread=new Thread(bank);
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Write the initial balance of the account in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Account : Initial Balance: %d\n",<br class="title-page-name"/>                          account.getBalance());
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Start the threads:</li>
</ol>
<pre class="calibre23">
        companyThread.start(); <br class="title-page-name"/>        bankThread.start();
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method and write the final balance in the console, the number of operations, and the accumulated commission of the account:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          companyThread.join(); <br class="title-page-name"/>          bankThread.join(); <br class="title-page-name"/>          System.out.printf("Account : Final Balance: %d\n",<br class="title-page-name"/>                            account.getBalance()); <br class="title-page-name"/>          System.out.printf("Account : Number of Operations: %d\n",<br class="title-page-name"/>                            account.getOperations().intValue()); <br class="title-page-name"/>          System.out.printf("Account : Accumulated commisions: %f\n",<br class="title-page-name"/>                            account.getCommission().doubleValue()); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key to this example is in the <kbd class="calibre15">Account</kbd> class. In this class, we declared an <kbd class="calibre15">AtomicLong</kbd> variable named <kbd class="calibre15">balance</kbd> to store the balance of the account, a <kbd class="calibre15">LongAdder</kbd> variable named <kbd class="calibre15">operations</kbd> to store the number of operations we made with the account, and a <kbd class="calibre15">DoubleAccumulator</kbd> variable named <kbd class="calibre15">commission</kbd> to store the value of the commissions of the operations. In the constructor of the <kbd class="calibre15">commission</kbd> object, we specified that the value will be incremented with the expression <kbd class="calibre15">0.2*y</kbd>. With this, we wanted to specify that we will increment the actual value of the variable with the result of its multiplication by <kbd class="calibre15">0.2</kbd> and the value of the parameter we pass to the <kbd class="calibre15">accumulate()</kbd> method.</p>
<p class="calibre4">To implement the <kbd class="calibre15">getBalance()</kbd> method that returns the value of the <kbd class="calibre15">balance</kbd> attribute, we used the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">AtomicLong</kbd> class. To implement the <kbd class="calibre15">getOperations()</kbd> method that returns a <kbd class="calibre15">long</kbd> value with the number of operations, we used the <kbd class="calibre15">longValue()</kbd> method. To implement the <kbd class="calibre15">getCommission()</kbd> method, we used the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">DoubleAccumulator</kbd> class. To implement the <kbd class="calibre15">setBalance()</kbd> method that establishes the value of the balance attribute, we used the <kbd class="calibre15">set()</kbd> method of the <kbd class="calibre15">AtomicLong</kbd> class.</p>
<p class="calibre4">To implement the <kbd class="calibre15">addAmount()</kbd> method that adds an import to the balance of the account, we used the <kbd class="calibre15">getAndAdd()</kbd> method of the <kbd class="calibre15">AtomicLong</kbd> class that returns the value and increments it by the value specified as a parameter. We also used the <kbd class="calibre15">increment()</kbd> method of the <kbd class="calibre15">LongAdder</kbd> class that increments the value of the variable by one and the <kbd class="calibre15">accumulate()</kbd> method of the <kbd class="calibre15">DoubleAccumulator</kbd> class to increment the value of the <kbd class="calibre15">commission</kbd> attribute following the specified expression. Take into account that the <kbd class="calibre15">addAmount()</kbd> method is not atomic as a whole although it calls three atomic operations.</p>
<p class="calibre4">Finally, to implement the <kbd class="calibre15">subtractAmount()</kbd> method that decrements the value of the <kbd class="calibre15">balance</kbd> attribute, we used the <kbd class="calibre15">getAndAdd()</kbd> method. We also included calls to the <kbd class="calibre15">increment()</kbd> and <kbd class="calibre15">accumulate()</kbd> methods of the <kbd class="calibre15">LongAdder</kbd> and <kbd class="calibre15">DoubleAccumulator</kbd> classes.</p>
<p class="calibre4">Then, we implemented two different tasks:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">Company</kbd> class simulates a company that increments the balance of the account. Each task of this class makes 10 increments of 1,000 each.</li>
<li class="calibre18">The <kbd class="calibre15">Bank</kbd> class simulates a bank where the proprietary of the bank account takes out its money. Each task of this class makes 10 decrements of 1,000 each.</li>
</ul>
<p class="calibre4">In the <kbd class="calibre15">Main</kbd> class, you created an <kbd class="calibre15">Account</kbd> object with a balance of 1,000. Then, you executed a bank task and a company task so the final balance of the account is the same as the initial one.</p>
<p class="calibre4">When you execute the program, you will see how the final balance is the same as the initial one. The following screenshot shows the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone31" src="../images/00047.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">As mentioned in the introduction, there are other atomic classes in Java. <kbd class="calibre15">AtomicBoolean</kbd>, <kbd class="calibre15">AtomicInteger</kbd>, and <kbd class="calibre15">AtomicReference</kbd> are other examples of atomic classes.</p>
<p class="calibre4">The <kbd class="calibre15">LongAdder</kbd> class provides other interesting methods as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">add()</kbd>: To increment the value of the internal counter by the value specified as a parameter</li>
<li class="calibre18"><kbd class="calibre15">decrement()</kbd>: To decrement the internal counter by one</li>
<li class="calibre18"><kbd class="calibre15">reset()</kbd>: To return the internal value to zero</li>
</ul>
<p class="calibre4">You can also use the <kbd class="calibre15">DoubleAdder</kbd> class that is similar to <kbd class="calibre15">LongAdder</kbd>, but it doesn't have the <kbd class="calibre15">increment()</kbd> and <kbd class="calibre15">decrement()</kbd> methods and the internal counter is a <kbd class="calibre15">double</kbd> value.</p>
<p class="calibre4">You can also use the <kbd class="calibre15">LongAccumulator</kbd> class that is similar to <kbd class="calibre15">DoubleAccumulator</kbd> but with an internal <kbd class="calibre15">long</kbd> counter.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a method</em> recipe in <a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using atomic arrays</h1>
            

            <article>
                
<p class="calibre4">Consider that you need to implement a concurrent application that has one or more objects shared by several threads. In such a scenario, you have to protect access to their attributes using a synchronization mechanism, such as locks or the <kbd class="calibre15">synchronized</kbd> keyword, to avoid data inconsistency errors.</p>
<p class="calibre4">These mechanisms have the following problems:</p>
<ul class="calibre17">
<li class="calibre18">Deadlock: This situation occurs when a thread is blocked waiting for a lock that is locked by other threads that will never free it. This situation blocks the program, so it will never finish.</li>
<li class="calibre18">If only one thread is accessing the shared object, it has to execute the code necessary to get and release the lock.</li>
</ul>
<p class="calibre4">To provide better performance in this situation, the <strong class="calibre1">compare-and-swap operation</strong> was developed. This operation implements the modification of the value of a variable in the following three steps:</p>
<ol class="calibre19">
<li value="1" class="calibre18">You get the value of the variable, which is the old value of the variable.</li>
<li value="2" class="calibre18">You change the value of the variable in a temporal variable, which is the new value of the variable.</li>
<li value="3" class="calibre18">You substitute the old value with the new value if the old value is equal to the actual value of the variable. The old value may be different from the actual value if another thread has changed it.</li>
</ol>
<p class="calibre4">With this mechanism, you don't need to use a synchronization mechanism, so you avoid deadlocks and you obtain better performance. This mechanism also has its drawbacks. Operations must be free from any side effects as they might be retried using livelocks with highly contended resources; they are also harder to monitor for performance when compared with standard locks.</p>
<p class="calibre4">Java implements this mechanism in <strong class="calibre1">atomic variables</strong>. These variables provide the <kbd class="calibre15">compareAndSet()</kbd> method, which is an implementation of the compare-and-swap operation and other methods based on it.</p>
<p class="calibre4">Java also introduced <strong class="calibre1">atomic arrays</strong> that provide atomic operations for arrays of <kbd class="calibre15">integer</kbd> or <kbd class="calibre15">long</kbd> numbers. In this recipe, you will learn how to use the <kbd class="calibre15">AtomicIntegerArray</kbd> class to work with atomic arrays. Take into account that if you use <kbd class="calibre15">AtomicInteger[]</kbd>, it's not a thread-safe object. The individual <kbd class="calibre15">AtomicInteger</kbd> objects are thread-safe, but the array as a data structure is not.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Incrementer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Incrementer implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">AtomicIntegerArray</kbd> attribute named <kbd class="calibre15">vector</kbd> to store an array of <kbd class="calibre15">integer</kbd> numbers:</li>
</ol>
<pre class="calibre23">
        private final AtomicIntegerArray vector;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Incrementer(AtomicIntegerArray vector) { <br class="title-page-name"/>          this.vector=vector; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Increment all the elements of the array using the <kbd class="calibre15">getAndIncrement()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;vector.length(); i++){ <br class="title-page-name"/>            vector.getAndIncrement(i); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">Decrementer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Decrementer implements Runnable {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare a private <kbd class="calibre15">AtomicIntegerArray</kbd> attribute named <kbd class="calibre15">vector</kbd> to store an array of <kbd class="calibre15">integer</kbd> numbers:</li>
</ol>
<pre class="calibre23">
        private AtomicIntegerArray vector;
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Decrementer(AtomicIntegerArray vector) { <br class="title-page-name"/>          this.vector=vector; <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Decrement all the elements of the array using the <kbd class="calibre15">getAndDecrement()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;vector.length(); i++) { <br class="title-page-name"/>            vector.getAndDecrement(i); <br class="title-page-name"/>          }   <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a constant named <kbd class="calibre15">THREADS</kbd> and assign the value <kbd class="calibre15">100</kbd> to it. Create an <kbd class="calibre15">AtomicIntegerArray</kbd> object with 1,000 elements:</li>
</ol>
<pre class="calibre23">
        final int THREADS=100; <br class="title-page-name"/>        AtomicIntegerArray vector=new AtomicIntegerArray(1000);
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create an <kbd class="calibre15">Incrementer</kbd> task to work with the atomic array created earlier:</li>
</ol>
<pre class="calibre23">
        Incrementer incrementer=new Incrementer(vector);
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create a <kbd class="calibre15">Decrementer</kbd> task to work with the atomic array created earlier:</li>
</ol>
<pre class="calibre23">
        Decrementer decrementer=new Decrementer(vector);
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create two arrays to store 100 <kbd class="calibre15">Thread</kbd> objects:</li>
</ol>
<pre class="calibre23">
        Thread threadIncrementer[]=new Thread[THREADS]; <br class="title-page-name"/>        Thread threadDecrementer[]=new Thread[THREADS];
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create and launch 100 threads to execute the <kbd class="calibre15">Incrementer</kbd> task and another 100 threads to execute the <kbd class="calibre15">Decrementer</kbd> task. Store the threads in the arrays created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;THREADS; i++) { <br class="title-page-name"/>          threadIncrementer[i]=new Thread(incrementer); <br class="title-page-name"/>          threadDecrementer[i]=new Thread(decrementer); <br class="title-page-name"/>       <br class="title-page-name"/>          threadIncrementer[i].start(); <br class="title-page-name"/>          threadDecrementer[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;100; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threadIncrementer[i].join(); <br class="title-page-name"/>            threadDecrementer[i].join();
</pre>
<pre class="calibre23">
          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">In the console, write the elements of the atomic array distinct from zero. Use the <kbd class="calibre15">get()</kbd> method to obtain the elements of the atomic array:</li>
</ol>
<pre class="calibre23">
        int errors=0;  <br class="title-page-name"/>        for (int i=0; i&lt;vector.length(); i++) { <br class="title-page-name"/>          if (vector.get(i)!=0) { <br class="title-page-name"/>            System.out.println("Vector["+i+"] : "+vector.get(i)); <br class="title-page-name"/>            errors++; <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        if (errors==0) { <br class="title-page-name"/>          System.out.printf("No errors found\n"); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Write a message in the console indicating the finalization of the example:</li>
</ol>
<pre class="calibre23">
        System.out.println("Main: End of the example");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, you implemented two different tasks to work with an <kbd class="calibre15">AtomicIntegerArray</kbd> object:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">Incrementer</kbd>: This class increments all the elements of the array using the <kbd class="calibre15">getAndIncrement()</kbd> method</li>
<li class="calibre18"><kbd class="calibre15">Decrementer</kbd>: This class decrements all the elements of the array using the <kbd class="calibre15">getAndDecrement()</kbd> method</li>
</ul>
<p class="calibre4">In the <kbd class="calibre15">Main</kbd> class, you created <kbd class="calibre15">AtomicIntegerArray</kbd> with 1,000 elements, then you executed 100 incrementer and 100 decrementer tasks. At the end of these tasks, if there were no inconsistency errors, all the elements of the array must have the value <kbd class="calibre15">0</kbd>. If you execute the program, you will see how the program only writes the final message to the console because all the elements are zero.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">Nowadays, Java provides another atomic array class. It's called the <kbd class="calibre15">AtomicLongArray</kbd> class and it provides the same methods as the <kbd class="calibre15">IntegerAtomicArray</kbd> class.</p>
<p class="calibre4">Other interesting methods provided by these classes are:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">get(int i)</kbd>: Returns the value of the array position specified by the parameter</li>
<li class="calibre18"><kbd class="calibre15">set(int I, int newValue)</kbd>: Establishes the value of the array position specified by the parameter.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using atomic variables</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using the volatile keyword</h1>
            

            <article>
                
<p class="calibre4">Almost every application reads and writes data to the main memory of the computer. For performance reasons, these operations aren't performed directly in the memory. CPUs have a system of cache memory, so applications write data in the cache and then the data is moved from the cache to the main memory.</p>
<p class="calibre4">In multithread applications, concurrent threads run in different CPUs or cores inside a CPU. When a thread modifies a variable stored in the memory, the modification is made in the cache or the CPU or core where it's running. However, there's no guarantee about when that modification would reach the main memory. If another thread wants to read the value of the data, it's possible that it would not read the modified value because it's not in the main memory of the computer.</p>
<p class="calibre4">To solve this problem (there are other solutions, such as the <kbd class="calibre15">synchronized</kbd> keyword), the Java language includes the <kbd class="calibre15">volatile</kbd> keyword. It's a modifier that allows you to specify that a variable must always be read from and stored in the main memory, not the cache of your CPU. You should use the volatile keyword when it's important that other threads have visibility of the actual value of the variable; however, order of access to that variable is not important. In this scenario, the <kbd class="calibre15">volatile</kbd> keyword will give you better performance because it doesn't need to get any monitor or lock to access the variable. On the contrary, if the order of access to the variable is important, you must use another synchronization mechanism.</p>
<p class="calibre4">In this recipe, you will learn how to use the volatile keyword and the effects of its use.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Flag</kbd> with a public <kbd class="calibre15">Boolean</kbd> attribute named <kbd class="calibre15">flag</kbd> initialized to the <kbd class="calibre15">true</kbd> value:</li>
</ol>
<pre class="calibre23">
        public class Flag { <br class="title-page-name"/>          public boolean flag=true; <br class="title-page-name"/>        }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">VolatileFlag</kbd> with a public Boolean attribute named <kbd class="calibre15">flag</kbd> initialized to the <kbd class="calibre15">true</kbd> value. We add the <kbd class="calibre15">volatile</kbd> modifier to the declaration of this attribute:</li>
</ol>
<pre class="calibre23">
        public class VolatileFlag { <br class="title-page-name"/>          public volatile boolean flag=true; <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. It has a private <kbd class="calibre15">Flag</kbd> attribute and a constructor to initialize it:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { <br class="title-page-name"/>          private Flag flag; <br class="title-page-name"/>          public Task(Flag flag) { <br class="title-page-name"/>            this.flag = flag; <br class="title-page-name"/>          }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of this task. It will increment an <kbd class="calibre15">int</kbd> variable when the value of the <kbd class="calibre15">flag</kbd> attribute is <kbd class="calibre15">true</kbd>. Then, write the final value of the variable:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          int i = 0; <br class="title-page-name"/>
</pre>
<pre class="calibre23">
          while (flag.flag) { <br class="title-page-name"/>            i++; <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("VolatileTask: Stopped %d - %s\n", i,<br class="title-page-name"/>                            new Date()); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">VolatileTask</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. It has a private <kbd class="calibre15">VolatileFlag</kbd> attribute and a constructor to initialize it:</li>
</ol>
<pre class="calibre23">
        public class VolatileTask implements Runnable { <br class="title-page-name"/> <br class="title-page-name"/>          private VolatileFlag flag; <br class="title-page-name"/>          public VolatileTask(VolatileFlag flag) { <br class="title-page-name"/>            this.flag = flag; <br class="title-page-name"/>          }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of this task. It's equal to the one in the <kbd class="calibre15">Task</kbd> class, so it won't be included here:</li>
<li value="7" class="calibre18">Implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, create four objects of the <kbd class="calibre15">VolatileFlag</kbd>, <kbd class="calibre15">Flag</kbd>, <kbd class="calibre15">VolatileTask</kbd>, and <kbd class="calibre15">Task</kbd> classes:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            VolatileFlag volatileFlag=new VolatileFlag(); <br class="title-page-name"/>            Flag flag=new Flag(); <br class="title-page-name"/>                         <br class="title-page-name"/>            VolatileTask vt=new VolatileTask(volatileFlag); <br class="title-page-name"/>            Task t=new Task(flag);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, create two threads to execute the tasks, start them, and sleep the main thread for a second:</li>
</ol>
<pre class="calibre23">
        Thread thread=new Thread(vt); <br class="title-page-name"/>        thread.start(); <br class="title-page-name"/>        thread=new Thread(t); <br class="title-page-name"/>        thread.start(); <br class="title-page-name"/>                         <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, change the value of the <kbd class="calibre15">volatileFlag</kbd> variable to stop the execution of <kbd class="calibre15">volatileTask</kbd> and sleep the main thread for a second:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Going to stop volatile task: %s\n",<br class="title-page-name"/>                          new Date()); <br class="title-page-name"/>        volatileFlag.flag=false; <br class="title-page-name"/>        System.out.printf("Main: Volatile task stoped: %s\n", new Date()); <br class="title-page-name"/>         <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Finally, change the value of the <kbd class="calibre15">task</kbd> object to stop the execution of the task and sleep the main thread for a second:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Going to stop task: %s\n", new Date()); <br class="title-page-name"/>        flag.flag=false; <br class="title-page-name"/>        System.out.printf("Main: Volatile stop flag changed: %s\n",<br class="title-page-name"/>                          new Date()); <br class="title-page-name"/>                         <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the output of the example:</p>
<div class="cdpaligncenter"><img class="alignnone32" src="../images/00048.jpeg"/></div>
<p class="calibre4">The application doesn't finish its execution because the <kbd class="calibre15">task</kbd> thread has not finished. When we change the value of <kbd class="calibre15">volatileFlag</kbd>-as its <kbd class="calibre15">flag</kbd> attribute is marked as <kbd class="calibre15">volatile</kbd>--the new value is written in the main memory and <kbd class="calibre15">VolatileTask</kbd> accesses the value immediately and finishes its execution. On the contrary, when you change the value of the <kbd class="calibre15">flag</kbd> object--as its <kbd class="calibre15">flag</kbd> attribute is not marked as volatile-the new value is stored in the cache of the main thread and the task object doesn't see the new value and never ends its execution. The <kbd class="calibre15">volatile</kbd> keyword is important not only because it requires that the writes are flushed, but also because it ensures that reads are not cached and they fetch the up-to-date value from the main memory. It's very important and very often neglected.</p>
<p class="calibre4">Take into account that the <kbd class="calibre15">volatile</kbd> keyword guarantees that modifications are written in the main memory, but its contrary is not always true. For example, if you work with a non-volatile integer value shared by more than one thread and make a lot of modifications, you may be able to see the modifications made by other threads because they were written in the main memory. However, there's no guarantee that these changes were passed from the cache to the main memory.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">volatile</kbd> keyword only works well when the value of the shared variable is only modified by one thread. If the variable is modified by multiple threads, the <kbd class="calibre15">volatile</kbd> keyword doesn't protect you from possible data-race conditions. It also doesn't make operations, such as <kbd class="calibre15">+</kbd> or <kbd class="calibre15">-</kbd>, atomic. For example, the <kbd class="calibre15">++</kbd> operator over a volatile variable is not thread-safe.</p>
<p class="calibre4">Since Java 5, <strong class="calibre1">Java Memory Model</strong> has a happens--before guarantee established with the <kbd class="calibre15">volatile</kbd> keyword. This fact has two implications:</p>
<ul class="calibre17">
<li class="calibre18">When you modify a volatile variable, its value is sent to the main memory. The value of all the variables modified previously by the same thread are sent too.</li>
<li class="calibre18">Compilers can't reorder sentences that modify a volatile variable for an optimization purpose. It can reorder the previous operations and the later ones, but not the modifications of a volatile variable. The changes that happen before these modifications will be visible to those instructions.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using atomic variables</em> and <em class="calibre14">Using atomic arrays</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using variable handles</h1>
            

            <article>
                
<p class="calibre4">Variable handles are a new feature of Java 9 that allow you to get a typed reference to a variable (attribute, static field, or array element) in order to access it in different modes. You can, for example, protect access to this variable in a concurrent application by allowing atomic access to the variable. Until now, you could only obtain this behavior with atomic variables, but now, you can use variable handles to obtain the same functionality without using any synchronization mechanism. A variable handle also allows you to get additional access modes to a variable.</p>
<p class="calibre4">In this recipe, you will learn how to obtain and use a variable handle and the benefits you obtain using it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Account</kbd> with two double public attributes named <kbd class="calibre15">amount</kbd> and <kbd class="calibre15">unsafeAmount</kbd>. Implement the constructor to initialize its values:</li>
</ol>
<pre class="calibre23">
        public class Account { <br class="title-page-name"/>          public double amount; <br class="title-page-name"/>          public double unsafeAmount; <br class="title-page-name"/>         <br class="title-page-name"/>          public Account() { <br class="title-page-name"/>            this.amount=0; <br class="title-page-name"/>            this.unsafeAmount=0; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">Decrementer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. It has a private <kbd class="calibre15">Account</kbd> attribute initialized in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        public class Decrementer implements Runnable { <br class="title-page-name"/> <br class="title-page-name"/>          private Account account; <br class="title-page-name"/>          public Decrementer(Account account) { <br class="title-page-name"/>            this.account = account; <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. This method will make 10,000 decrement operations in the <kbd class="calibre15">amount</kbd> and <kbd class="calibre15">unsafeAmount</kbd> attributes. To modify the value of the amount attribute, use <kbd class="calibre15">VarHandle</kbd>. Obtain it using the <kbd class="calibre15">lookup()</kbd> method of the <kbd class="calibre15">MethodHandles</kbd> class, then use the <kbd class="calibre15">getAndAdd()</kbd> method to modify the value of the attribute. To modify the <kbd class="calibre15">unsafeAmount</kbd> attribute, use the <kbd class="calibre15">=</kbd> operator:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          VarHandle handler; <br class="title-page-name"/>          try { <br class="title-page-name"/>            handler = MethodHandles.lookup().in(Account.class)<br class="title-page-name"/>                        .findVarHandle(Account.class, "amount",<br class="title-page-name"/>                        double.class); <br class="title-page-name"/>            for (int i = 0; i &lt; 10000; i++) { <br class="title-page-name"/>              handler.getAndAdd(account, -100); <br class="title-page-name"/>              account.unsafeAmount -= 100; <br class="title-page-name"/>            } <br class="title-page-name"/>          } catch (NoSuchFieldException | IllegalAccessException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement a class named <kbd class="calibre15">Incrementer</kbd>. This will be equivalent to the <kbd class="calibre15">Drementer</kbd> class, but it will increase the value of the account. The source code of this class won't be included here.</li>
<li value="5" class="calibre18">Finally, implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, create an <kbd class="calibre15">account</kbd> object:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            Account account = new Account();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, create a thread to execute an <kbd class="calibre15">Incrementer</kbd> task and a thread to execute a <kbd class="calibre15">Decrementer</kbd> task. Start them and wait for their finalization using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        Thread threadIncrementer = new Thread(new Incrementer(account)); <br class="title-page-name"/>        Thread threadDecrementer = new Thread(new Decrementer(account)); <br class="title-page-name"/> <br class="title-page-name"/>        threadIncrementer.start(); <br class="title-page-name"/>        threadDecrementer.start(); <br class="title-page-name"/> <br class="title-page-name"/>        try { <br class="title-page-name"/>          threadIncrementer.join(); <br class="title-page-name"/>          threadDecrementer.join(); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, write the value of the amount and <kbd class="calibre15">unsafeAmount</kbd> attributes in the console:</li>
</ol>
<pre class="calibre23">
            System.out.printf("Safe amount: %f\n", account.amount); <br class="title-page-name"/>            System.out.printf("Unsafe amount: %f\n", account.unsafeAmount); <br class="title-page-name"/> <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the output of an execution of the application:</p>
<div class="cdpaligncenter"><img class="alignnone33" src="../images/00049.jpeg"/></div>
<p class="calibre4">As you make the same number of increment and decrement operations, the expected result in both cases is <kbd class="calibre15">0</kbd>. We obtain this result with the amount attribute because as we access it using the <kbd class="calibre15">VarHandle</kbd>, we guarantee atomic access to its modifications. On the other hand, the <kbd class="calibre15">unsafeAmount</kbd> doesn't have the expected value. Access to this value is not protected and we have a data-race condition.</p>
<p class="calibre4">To use a variable handle, first we have to obtain it using the <kbd class="calibre15">lookup()</kbd> method of the <kbd class="calibre15">MethodHandles</kbd> class, followed by the <kbd class="calibre15">in()</kbd> method and then the <kbd class="calibre15">findVarHandle()</kbd> method. The <kbd class="calibre15">lookup()</kbd> method returns a <kbd class="calibre15">Lookup</kbd> object, the <kbd class="calibre15">in()</kbd> method returns a <kbd class="calibre15">Lookup</kbd> object of the specified class—in our case, the <kbd class="calibre15">Account</kbd> class—and <kbd class="calibre15">findVarHandle()</kbd> generates <kbd class="calibre15">VarHandle</kbd> for the attribute we want to access.</p>
<p class="calibre4">Once we have the <kbd class="calibre15">VarHandle</kbd> object, we can use different methods to use different access modes. In this example, we used the <kbd class="calibre15">getAndAdd()</kbd> method. This method guarantees atomic access to increment the value of the attribute. We pass to them the object we want to access and the value of the increment.</p>
<p class="calibre4">The next section provides more information about the different access modes and the methods you can use in each case.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You have four different access types to a variable with a variable handle:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Read mode</strong>: This is used to get read mode access to a variable. You can use the following methods:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">get()</kbd>: Read the value of the variable as if it was declared non-volatile</li>
<li class="calibre18"><kbd class="calibre15">getVolatile()</kbd>: Read the value of the variable as if it was declared volatile</li>
<li class="calibre18"><kbd class="calibre15">getAcquire()</kbd>: Read the value of the variable and guarantee that the following instructions that modify or access this variable are not reordered before the instructions for optimization purposes</li>
<li class="calibre18"><kbd class="calibre15">getOpaque()</kbd>: Read the value of variable and guarantee that the instructions of the current thread are not reordered; no guarantee is provided for other threads</li>
</ul>
</li>
</ul>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Write mode</strong>: This is used to get write access mode to a variable. You can use the <kbd class="calibre15">set()</kbd>, <kbd class="calibre15">setVolatile()</kbd>, <kbd class="calibre15">setRelease()</kbd>, and <kbd class="calibre15">setOpaque()</kbd> methods. They are equivalent to the previous ones but with write access.</li>
<li class="calibre18"><strong class="calibre1">Atomic access mode</strong>: This is used to get a functionality that is similar to the one provided by the atomic variables with operations to, for example, compare and get the value of the variable. You can use the following methods:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">compareAndSet()</kbd>: Change the value of the variable as it was declared as a volatile variable if the expected value passed as parameter is equal to the current value of the variable</li>
<li class="calibre18"><kbd class="calibre15">weakCompareAndSet()</kbd> and <kbd class="calibre15">weakCompareAndSetVolatile()</kbd>: Possibly atomically' changes the value of the variable as it was declared as non-volatile or volatile variables respectively if the expected value passed as parameter is equals to the current value of the variable</li>
</ul>
</li>
<li class="calibre18"><strong class="calibre1">Numerical update access mode</strong>: This is to modify numerical values in an atomic way.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using atomic variables</em> and <em class="calibre14">Using atomic arrays</em> recipe in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>