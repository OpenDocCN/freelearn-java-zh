- en: 'Chapter 12: Cross-Cutting Concerns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the previous chapters, we have explored many different aspects of
    Java application development. Starting from the beginning of the development life
    cycle (including requirements collection and architecture design), we've focused
    on many different technological aspects, including frameworks and middleware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, several cross-cutting concerns need to be examined, regardless
    of the kind of application we are building and the architectural style we choose.
    In this chapter, we are going to look at a few of these aspects, as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Identity management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resiliency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cross-cutting concerns discussed in this chapter provide some very useful
    information about topics that are crucial for a project's success. Indeed, implementing
    identity management, security, and resiliency in the right way can be beneficial
    to the success of our application, both from an architectural point of view (by
    providing elegant, scalable, and reusable solutions) and a functional point of
    view (by avoiding reinventing the wheel and approaching these issues in a standardized
    way).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s get started with a classic issue in application development:
    identity management.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Identity management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Identity management** is a broad concept that deals with many different aspects
    and involves interaction with many different systems.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This concept is indeed related to identifying a user (that is, who is asking
    for a particular resource or functionality) and checking the associated permissions
    (whether they are allowed to do so and so, or not). So, it's easy to see how this
    is a core concept, common in many applications and many components inside the
    application. If we have different functionalities provided by different components
    (as in a microservices application), then obviously each of them will need to
    perform the same kind of checks, to be sure about the user's identity and act
    accordingly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: However, having an ad hoc identity management infrastructure for each application
    can be considered an *antipattern*, especially in a complex enterprise environment,
    since each application (or component) has the same goal of identifying the user
    and its permissions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, a common approach is to define a company-wide identity management
    strategy and adopt it in all of the applications, including the off-premises and
    microservices architectures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to come back to the fundamentals, identity management is basically about
    two main concepts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This is a way of ensuring, with the maximum possible degree
    of certainty, that the person asking for access to a resource (or to perform an
    action) is the person that they claim to be. Here is a diagram of the username
    and password authentication method:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Authentication'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B16354.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Authentication
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization**: This is a way of declaring who can access each resource
    and perform a specific action, as shown in the following diagram. This may involve
    authenticated and non-authenticated entities (sometimes referred to as anonymous
    access).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是一种声明谁可以访问每个资源并执行特定操作的方式，如下面的图所示。这可能涉及已验证和未验证的实体（有时称为匿名访问）。'
- en: '![Figure 12.2 – Authorization'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 授权'
- en: '](img/Figure_12.2_B16354.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B16354.jpg)'
- en: Figure 12.2 – Authorization
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 授权
- en: 'Both authentication and authorization include two main scenarios:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权包括两个主要场景：
- en: '**Machine to machine**: This is when the entity requesting access is an application,
    for example, in batch calculations or other processes that do not directly involve
    the interaction of a human user. This is also called **server to server**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器到机器**：这种情况是指请求访问的实体是一个应用程序，例如在批量计算或其他不直接涉及人类用户交互的过程中。这也被称为**服务器到服务器**。'
- en: '**Interactive** or **use**: This is the other scenario, with a human operator
    interacting directly with the resource, hence requesting authentication and authorization.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式**或**使用**：这是另一种场景，其中人类操作员直接与资源交互，因此请求身份验证和授权。'
- en: Now that we have the hang of some basic concepts, let's learn a bit more about
    authentication and authorization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了某些基本概念，让我们进一步了解身份验证和授权。
- en: Authentication
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'As stated, **authentication** is about verifying that the entity performing
    a request (be it a human or a machine) is who they claim to be. There are many
    different ways to perform this verification. The main differentiator is what the
    user presents (and needs to be checked). It falls into one of the following three
    categories:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，**身份验证**是验证执行请求的实体（无论是人类还是机器）是否是他们所声称的那样。有许多不同的验证方式。主要区别在于用户呈现的内容（以及需要检查的内容）。它属于以下三个类别之一：
- en: '**Something that the user knows**: This refers to secrets, such as passwords,
    pins, or similar things, like the sequence to unlock a mobile phone.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户知道的东西**：这指的是秘密，例如密码、PIN码或类似的东西，比如解锁手机的序列。'
- en: '**Something that the user has**: This refers to physical devices (such as badges
    or hardware tokens) or software artifacts (such as certificates and software tokens).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户拥有的东西**：这指的是物理设备（如徽章或硬件令牌）或软件工件（如证书和软件令牌）。'
- en: '**Something that the user is**: In this case, authentication is linked to biometric
    factors (such as a fingerprint or face identification), or similar things like
    a signature.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户是的东西**：在这种情况下，身份验证与生物识别因素（如指纹或面部识别）或类似的东西（如签名）相关联。'
- en: 'There are several things to consider here, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要考虑的事项，如下所述：
- en: The first is that a piece of public information, such as a username, may be
    associated with the authentication factor. In this case, multiple users can share
    the same factor (such as a password or a badge) and we can tell them apart by
    using the username. The unintentional occurrence of this pattern (such as two
    users choosing the same password by accident) may be harmless, whereas intentional
    implementations (multiple users using the same badge) can be a security issue.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况是，一些公开信息，如用户名，可能与身份验证因素相关联。在这种情况下，多个用户可以共享相同的因素（如密码或徽章），我们可以通过使用用户名来区分他们。这种模式的无意发生（如两个用户意外选择相同的密码）可能无害，而有意实施（多个用户使用相同的徽章）可能是一个安全问题。
- en: You also have to consider that a combination of more than one authentication
    factor is considered a best practice and is encouraged for stronger security implementations.
    This is called **multi-factor authentication** (**MFA**). Moreover, in some specific
    environments (such as banking) this may be mandated by specific regulations. Strong
    authentication is often one of those specifics and refers to an authentication
    process leveraging at least two different factors, belonging to different groups
    (for example, *something that a user knows*, plus *something that a user has*).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还必须考虑，超过一个身份验证因素的组合被认为是最佳实践，并且鼓励用于更强的安全实现。这被称为**多因素身份验证**（**MFA**）。此外，在某些特定环境（如银行）中，这可能是由特定法规规定的。强身份验证通常是这些具体要求之一，它指的是利用至少两个不同因素的身份验证过程，这些因素属于不同的组（例如，*用户知道的东西*，加上*用户拥有的东西*）。
- en: Some authentication factors may be subject to policies. The most common examples
    are password rules (length, complexity) or expiration policies (forcing a user
    to change a factor after a certain time where possible).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些认证因素可能受到策略的限制。最常见的例子是密码规则（长度、复杂性）或过期策略（在可能的情况下，强制用户在一段时间后更改因素）。
- en: Of course, an immediate concern that comes to mind is how and where to store
    the information relevant for implementing authentication – in other words, where
    to save our usernames and passwords (and/or the other kinds of secrets used for
    authentication).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个立即浮现的问题是如何以及在哪里存储与实现认证相关的信息——换句话说，在哪里保存我们的用户名和密码（以及/或用于认证的其他类型的秘密）。
- en: The most common technology used for this goal is **LDAP**, which is short for
    **Lightweight Directory Access Protocol**. LDAP is a protocol for storing user
    information. An LDAP server can be seen as a standard way to store information
    about users, including things such as usernames, emails, phone numbers, and, of
    course, passwords. Being quite an old standard, around since the 1990s, it's widely
    adopted and compatible with a lot of other technology.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的最常见的技术是**LDAP**，即**轻量级目录访问协议**。LDAP是存储用户信息的协议。LDAP服务器可以被视为存储用户信息（包括用户名、电子邮件、电话号码等）的标准方式。作为一个相当古老的标准，自1990年代以来一直存在，它被广泛采用并且与许多其他技术兼容。
- en: Without going into too much detail, we can look at it as just another datastore,
    which we can connect to using a connection URL. Then, we can query the datastore
    by passing specific attributes to search for specific entries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，我们可以将其视为只是一个数据存储库，我们可以通过连接URL来连接它。然后，我们可以通过传递特定的属性来查询数据存储库，以搜索特定的条目。
- en: The authentication operation against an LDAP server is called **Bind**. LDAP
    can typically encrypt the passwords in various ways. One very famous implementation
    of an LDAP server (technically, an extension of it, providing more services than
    just the standard) is **Microsoft Active Directory**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对LDAP服务器的认证操作称为**绑定**。LDAP通常可以以各种方式加密密码。一个非常著名的LDAP服务器实现（技术上，是其扩展，提供比标准更多的服务）是**微软活动目录**。
- en: LDAP is not the only way to store user information (including passwords) but
    is likely the only widely adopted standard. Indeed, it is common to store user
    information in relational databases, but this is almost exclusively done in a
    custom way, meaning that there is no standard naming nor formats for tables and
    columns storing usernames, passwords, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP不是存储用户信息（包括密码）的唯一方式，但可能是唯一广泛采用的标准。实际上，用户信息通常存储在关系数据库中，但这几乎完全是自定义的，这意味着没有标准命名也没有表格和列的格式，用于存储用户名、密码等。
- en: One other way to store user information is to use files, but this is an approach
    that's not scalable nor efficient. It works mostly for a small set of users or
    testing purposes. A common file format used to store user information is `.htpasswd`,
    which is simply a flat file storing a username and password, in a definition originally
    used by the Apache httpd server for authentication purposes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存储用户信息的另一种方式是使用文件，但这不是一个可扩展或高效的方法。它主要用于一小组用户或测试目的。用于存储用户信息的常见文件格式是`.htpasswd`，它只是一个简单的平面文件，存储用户名和密码，最初由Apache
    httpd服务器用于认证目的。
- en: 'It is a commonly accepted best practice to store passwords in an encrypted
    form whenever possible. This is a crucial point. Whatever the user store technology
    (such as LDAP or a database), it is crucial that the passwords are not stored
    in cleartext. The reason is simple and quite obvious: if our server gets compromised
    in some way, the attacker should not be able to access the stored passwords.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，以加密形式存储密码是一种普遍接受的最佳实践。这是一个关键点。无论用户存储技术（如LDAP或数据库）如何，密码都不应以明文形式存储。原因简单且明显：如果我们的服务器以某种方式被入侵，攻击者不应能够访问存储的密码。
- en: I have used the word *encryption* generically. A solution, indeed, can be to
    encrypt the passwords with a symmetrical algorithm, such as AES. Symmetrical encryption
    implies that by using a specific secret key, I can make the password unusable.
    Then, I can again decrypt the password using the same key.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了“加密”这个词来泛指。一个解决方案确实可以是使用对称算法，如AES来加密密码。对称加密意味着通过使用一个特定的密钥，我可以使密码不可用。然后，我可以用同样的密钥再次解密密码。
- en: This approach is useful, but we will still need to store the key securely since
    an attacker with the encrypted password and the key can access the original password
    as cleartext. Hence, a more secure way is to store the hashed password.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: By hashing a password, you transform it into an encrypted string. The great
    thing, compared to the previous approach, is that we are implementing asymmetrical
    encryption. There is no way (if we are using a proper algorithm) to reverse the
    encrypted string to the original one in a reasonable amount of time. In this way,
    we can store the encrypted passwords without requiring any key. To validate the
    passwords provided by the clients, we simply apply the same hashing algorithm
    used for saving it initially and compare the results. Even if an attacker gains
    access to our user information store, the stolen encrypted passwords will be more
    or less useless.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: It's certainly better to encrypt a password rather than store it in cleartext;
    even the encrypted ones are not 100% secure. Indeed, even if it is impossible,
    in theory, to reconstruct the original password from a hashed value, some techniques
    attempt to do so. In particular, it is possible to try to run a brute-force attack,
    which basically tries a lot of passwords (from a dictionary, or simply random
    strings), hashes them, and compares the output with a known actual hash. A more
    efficient alternative is to use **rainbow tables**, which are basically tables
    of passwords and their pre-computed hashes. Defenses against these kinds of techniques
    are possible, however, by using longer and more complex passwords and using salting,
    which is a way to add some more randomness to hashed passwords.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User **authorization** is complementary to authentication. Once we are sure
    that a user is who they claim to be (using authentication), we have to understand
    what they are allowed to do. This means which resources and which operations they
    are permitted to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The most basic form of authorization is no authorization. In simple systems,
    you can allow an authenticated user to do everything.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: A better approach, in real-world applications, is to grant granular permissions,
    differentiated for different kinds of users. This is basically the concept of
    roles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: A **role** can be considered a link between a set of users and a set of permissions.
    It is usually mapped to a job function or a department and is defined by a list
    of permissions, in terms of resources that can be accessed and functionalities
    that can be used. Each user can be associated with a role, and with this, they
    inherit the permissions associated with that role.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This kind of authorization methodology is called **Role-Based Access Control**
    (**RBAC**). Based on the kind of RBAC implementation, each user can be assigned
    to more than one role, with different kinds of compositions. Normally, policies
    are additive, meaning that a user belonging to more than one role gets all the
    permissions from both roles. However, this may be subject to slight changes, especially
    if the permissions conflict, up to the point that there may be implementations
    denying the possibility of having more than one role associated with each user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种授权方法被称为**基于角色的访问控制**（**RBAC**）。基于RBAC实现，每个用户可以分配给多个角色，具有不同的组合。通常，策略是累加的，这意味着属于多个角色的用户从这两个角色中获得所有权限。然而，这可能会略有变化，特别是如果权限冲突，甚至可能存在拒绝每个用户关联多个角色的实现。
- en: Another aspect of RBAC implementations concerns role inheritance. Some RBAC
    implementations employ the concept of a hierarchy of roles, meaning that a role
    can inherit the set of permissions associated with its parent role. This allows
    for a modular system. In the Java Enterprise world, **JAAS** (short for **Java
    Authentication and Authorization Service**) is the implementation standard for
    authentication and authorization. It can be regarded as a reference implementation
    of an RBAC-based security system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC实现的一个方面是角色继承。一些RBAC实现采用角色层次结构的概念，这意味着一个角色可以继承与其父角色关联的权限集。这允许构建模块化系统。在Java企业领域，**JAAS**（即**Java
    Authentication and Authorization Service**）是身份验证和授权的实现标准。它可以被视为基于RBAC的安全系统的参考实现。
- en: An alternative to RBAC is `if then` statement, where more than one attribute
    can be combined with `AND`, `OR`, and other logic operators. The attributes can
    be simply related to the user (such as checking whether a user belongs to a particular
    group), or to other conditions (such as the time of the day, the source IP, and
    the geographical location).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC（基于角色的访问控制）的替代方案是`if then`语句，其中可以结合多个属性使用`AND`、`OR`和其他逻辑运算符。这些属性可以简单地与用户相关（例如检查用户是否属于特定组），或者与其他条件相关（例如一天中的时间、源IP地址和地理位置）。
- en: '`SELinux`, which is a security module underlying some **Linux** OS variants
    (including **Android**) is a common implementation of PBAC.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELinux`是一种安全模块，它是某些**Linux**操作系统变体（包括**Android**）的底层安全模块，是PBAC（基于属性的访问控制）的常见实现。'
- en: Identity and Access Management
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份和访问管理
- en: '**Identity and Access Management** (**IAM**) is a term usually associated with
    systems that provide authentication, authorization, and other identity security
    services to client applications. The function of an IAM system is to implement
    such features in a unified way, so each application can directly use it and benefit
    from an adequate level of security. Other than what we have seen here in terms
    of authentication and authorization, an IAM system also provides the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份和访问管理**（**IAM**）是一个通常与提供身份验证、授权和其他身份安全服务的系统相关的术语。IAM系统的功能是以统一的方式实现这些功能，以便每个应用程序可以直接使用它并从中受益于适当的安全级别。除了我们在身份验证和授权方面看到的内容之外，IAM系统还提供以下功能：'
- en: '**Decoupling the user store**: This means that usernames, passwords, and other
    information can be stored in the technology of choice (such as LDAP or a database),
    and the client application does not need to know the implementation details. An
    IAM can also usually unify multiple storage systems in a unique view. And of course,
    if the user storage system needs to change (such as being moved from LDAP to a
    database), or we have to add a new one, we don''t need to make any changes to
    the client applications.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦用户存储**：这意味着用户名、密码和其他信息可以存储在所选技术中（如LDAP或数据库），客户端应用程序不需要知道实现细节。IAM通常还可以在统一视图中统一多个存储系统。当然，如果用户存储系统需要更改（例如从LDAP迁移到数据库），或者我们必须添加一个新的系统，我们不需要对客户端应用程序进行任何更改。'
- en: '**Federating other authentication systems (such as more IAM systems)**: This
    can be particularly useful in shared systems where access is required from more
    than one organization. Most of us have experienced something like this when accessing
    a service through a third-party login using **Google** or **Facebook**.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦其他认证系统（如更多的IAM系统）**：这在需要从多个组织访问共享系统的场景中尤其有用。我们大多数人都有过通过第三方登录（如使用**Google**或**Facebook**）访问服务的类似经历。'
- en: '**Single sign-on** (**SSO**): This means that we only need to log in (and log
    out) once, and then we can directly access the set of applications configured
    in the IAM.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录**（**SSO**）：这意味着我们只需要登录（和注销）一次，然后就可以直接访问 IAM 中配置的应用程序集。'
- en: 'There are many different ways (and standards) to implement such features, depending
    on each specific IAM product used. Such standards often boil down to some key
    concepts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类功能（和标准）的方式（和标准）有很多，这取决于所使用的每个特定 IAM 产品。这些标准通常归结为一些关键概念：
- en: '**Provisioning and connecting each application managed by the IAM**: This usually
    means configuring each application to point to the IAM. In the Java world, a common
    way to achieve this is to configure a servlet filter to intercept all requests.
    Other alternatives are agent software or reverse proxies that implement the same
    functionality of intercepting all the requests coming to our application.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为 IAM 管理的每个应用程序提供和连接**：这通常意味着配置每个应用程序以指向 IAM。在 Java 世界中，实现这一点的常见方法是为所有请求配置一个
    servlet 过滤器。其他替代方案是代理软件或反向代理，它们实现了拦截所有进入我们应用程序的请求的相同功能。'
- en: '**Checking each request coming to each application**: In case a request needs
    to be authenticated (because it is trying to access a protected resource or perform
    a limited action), check whether the client is already authenticated. If not,
    redirect to an authentication system (such as a login form).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查每个应用程序收到的每个请求**：如果请求需要认证（因为它试图访问受保护的资源或执行有限的操作），则需要检查客户端是否已经认证。如果没有，则重定向到认证系统（例如登录表单）。'
- en: '**Identifying the user**: Once the client provides a valid authentication credential
    (such as a username and password), it must be provided with a unique identifier,
    which is regarded as the *ID card* of the user, used to recognize it across different
    requests (and potentially log in to other applications in an SSO scenario). To
    do so, the client is often provided with a session token, which may then be stored
    by the client application (as in a cookie) and usually has a limited lifespan.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别用户**：一旦客户端提供了有效的认证凭证（如用户名和密码），它必须提供一个唯一的标识符，这被视为用户的*身份证*，用于在不同请求中识别它（以及在单点登录场景中登录到其他应用程序）。为此，客户端通常会提供一个会话令牌，然后客户端应用程序（如
    cookie）可能会存储该令牌，并且通常具有有限的生命周期。'
- en: A standard way to implement this kind of scenario is the **OAuth protocol**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类场景的标准方式是**OAuth 协议**。
- en: However, IAM is not the only security aspect that we need to take care of in
    a cloud-native architecture. Indeed, the topic of security in an application (especially
    in a cloud-native one) includes many more considerations. We are going to discuss
    some of them in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IAM 并不是我们需要在云原生架构中关注的唯一安全方面。实际上，应用程序（尤其是在云原生应用程序中）的安全问题包括许多更多的考虑因素。我们将在下一节中讨论其中的一些。
- en: Security
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: '**Security** is a very complex aspect, as well as a foundational and crucial
    one. Unless security is your main focus (which is unlikely if you are in charge
    of defining the whole architecture of a cloud-native application), chances are
    that you will have some experts to work with. Nevertheless, it''s important to
    take care of some simple security implications right from the outset of software
    implementation (including requirement collection, design, and development), to
    avoid going through a security check after you have completed architecture and
    development, only to realize that you have to make a lot of changes to implement
    security (thereby incurring costs and delays).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**是一个非常复杂且基础且关键的一个方面。除非安全是你的主要关注点（如果你负责定义云原生应用程序的整体架构，这种情况不太可能），否则你很可能会与一些专家合作。尽管如此，从软件实施的开始（包括需求收集、设计和开发）就关注一些简单的安全影响是很重要的，以避免在完成架构和开发后进行安全检查，结果发现你需要进行大量的更改来实现安全（从而产生成本和延误）。'
- en: This approach is often referred to as **shift-left security**, and it's a common
    practice in **DevOps** teams.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常被称为**左移安全**，并且在**DevOps**团队中是一种常见的做法。
- en: Intrinsic software security
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内在软件安全
- en: The first aspect to take care of is **intrinsic software security**. Indeed,
    software code can be subject to security vulnerabilities, often due to bugs or
    poor software testing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要关注的是**内在软件安全**。确实，软件代码可能会受到安全漏洞的影响，这通常是由于错误或软件测试不佳造成的。
- en: 'The main scenario is software behaving unexpectedly as a result of a malformed
    or maliciously crafted input. Some common security issues of this kind are the
    following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 主要场景是软件由于格式错误或恶意构造的输入而表现出意外行为。这类常见的安全问题如下：
- en: '**SQL injection**: A malicious parameter is passed to the application and is
    attached to a SQL string. The application then performs a special SQL operation
    that is different from the expected operation and can allow the attacker access
    to unauthorized data (or even to damage existing data).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL注入**：一个恶意参数被传递给应用程序，并附加到一个SQL字符串上。然后应用程序执行一个特殊的SQL操作，这与预期的操作不同，可能允许攻击者访问未经授权的数据（甚至可能损坏现有数据）。'
- en: '**Unsafe memory handling**: A purposely wrong parameter is passed to the application
    and is copied to a special portion of memory, which the server interprets as executable
    code. Hence, unauthorized instructions can be executed. A well-known instance
    of this kind of bug is the *buffer overflow*.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的内存处理**：将一个故意错误的参数传递给应用程序，并将其复制到内存的特殊部分，服务器将其解释为可执行代码。因此，可以执行未经授权的指令。这种类型错误的常见实例是*缓冲区溢出*。'
- en: '**Cross-site scripting**: This is a specific security issue in web applications
    where an attacker can inject client-server code (such as JavaScript) that is then
    executed and the attacker can use it to steal data or perform unauthorized operations.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本**：这是网络应用中的一种特定安全漏洞，攻击者可以注入客户端-服务器代码（如JavaScript），然后执行这些代码，攻击者可以利用它窃取数据或执行未经授权的操作。'
- en: 'There are several techniques for avoiding or mitigating these issues:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 避免或减轻这些问题的技术有几种：
- en: '**Input sanitizing**: Every input should be checked for special characters
    and anything unnecessary. Checking the format and the length is also important.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入清理**：每个输入都应该检查特殊字符和任何不必要的部分。检查格式和长度也很重要。'
- en: '**Running as a user with limited permissions on the local machine (the fewer
    permissions, the better)**: If there''s an unexpected security exception, the
    impact may be limited.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以具有有限权限的用户身份在本地机器上运行（权限越少越好）**：如果出现意外的安全异常，影响可能会有限。'
- en: '**Sandboxing**: In this case, the application will run within a limited and
    constrained environment. It is kind of an extension of the previous approach.
    There are various techniques for doing this, depending on the specific application
    technology. The JVM itself is kind of a sandbox. Containers are another way to
    implement sandboxing.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙箱**：在这种情况下，应用程序将在一个有限和受约束的环境中运行。这可以看作是之前方法的扩展。根据具体的应用技术，有各种实现沙箱的技术。JVM本身也是一种沙箱。容器是另一种实现沙箱的方式。'
- en: The preceding topics are a quick list of common issues (and advice to mitigate
    them) with regard to software development. However, these approaches, while crucial,
    are not exhaustive, and it's important to take a look at the overall security
    of our applications and systems, which will involve some other considerations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述主题是关于软件开发中常见问题（以及缓解这些问题的建议）的快速列表。然而，尽管这些方法至关重要，但并不全面，因此重要的是要考虑我们应用程序和系统的整体安全性，这将涉及一些其他考虑因素。
- en: Overall application security
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总体应用程序安全
- en: 'Good overall security starts with the way we write our application but doesn''t
    end there. There are several other security techniques that may involve different
    IT departments, such as network administrators. Let''s look at some of them here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的整体安全性始于我们编写应用程序的方式，但并不止于此。还有其他几种安全技术可能涉及不同的IT部门，例如网络管理员。以下是一些例子：
- en: '**Network firewalls**: They are an integral piece of the enterprise security
    strategy and are very often completely transparent to developers and architects
    (at least until you find that some of the connections you want to make are failing
    due to a missing network rule). The primary duty of firewalls is to block all
    the network connections unless they are explicitly allowed. This includes rules
    on ports, protocols, IP addresses, and so on.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络防火墙**：它们是企业安全策略的一个基本组成部分，并且通常对开发人员和架构师来说非常透明（至少直到你发现你想要建立的某些连接由于缺少网络规则而失败）。防火墙的主要职责是阻止所有网络连接，除非它们被明确允许。这包括端口、协议、IP地址等方面的规则。'
- en: Nowadays, however, firewalls are way more sophisticated than they used to be.
    They are now capable of inspecting the application-level protocols and are often
    not only deployed at the forefront of the infrastructure but also between each
    component, to monitor and limit unauthorized accesses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，防火墙比过去要复杂得多。它们现在能够检查应用层协议，并且通常不仅部署在基础设施的前端，还部署在每个组件之间，以监控和限制未经授权的访问。
- en: For the same reason, some orchestrator tools (such as **Kubernetes**, but also
    the public cloud providers) offer the possibility to implement the so-called *network
    policies*, which are essentially **Access Control Lists** (**ACLs**) acting as
    a network firewall, hence not allowing (or dropping) unwanted network connections.
    Firewalls can be hardware appliances (with major vendors including **Cisco** and
    **Check Point**, among others), or even software distributions (such as **PFSense**
    and **Zeroshell**).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，一些编排工具（如 **Kubernetes**，以及公共云提供商）提供了实现所谓的 *网络策略* 的可能性，这些策略本质上是在充当网络防火墙的**访问控制列表**（**ACLs**），因此不允许（或丢弃）不受欢迎的网络连接。防火墙可以是硬件设备（包括
    **Cisco** 和 **Check Point** 等主要供应商），甚至是软件发行版（如 **PFSense** 和 **Zeroshell**）。
- en: '**Intrusion Protection Systems** (**IPSes**) (similar to **Intrusion Detection
    Systems**, with a slight difference in the implementation): These are an extension
    to firewalls. An IPS, like a firewall, is capable of inspecting network connections.
    But instead of just identifying authorized and unauthorized routes, an IPS is
    also capable of inspecting the packages to identify signatures (recurrent patterns)
    of well-known attacks (such as SQL injections or similar behaviors).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入侵保护系统**（**IPSes**）（类似于**入侵检测系统**，但在实现上略有不同）：这些是防火墙的扩展。IPS，就像防火墙一样，能够检查网络连接。但除了仅识别授权和不授权的路径外，IPS
    还能够检查数据包以识别已知攻击（如 SQL 注入或类似行为）的签名（重复模式）。'
- en: Moreover, an IPS can inspect other aspects of an application beyond just its
    network connections. Typically, an IPS can access application logs or even inspect
    the application behavior at runtime, with the same goal of identifying and blocking
    malevolent behavior. In this context, IPSes are similar to antivirus software
    running on workstations. Two common IPS implementations are **Snort** and **Suricata**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IPS 还可以检查应用程序的其他方面，而不仅仅是其网络连接。通常，IPS 可以访问应用程序日志或甚至在运行时检查应用程序的行为，以达到识别和阻止恶意行为的目标。在这种情况下，IPS
    与在工作站上运行的防病毒软件类似。两种常见的 IPS 实现是 **Snort** 和 **Suricata**。
- en: '**Source code inspection**: This is focused on analyzing the code for well-known
    bugs. While this is a general-purpose technique, it can be focused on security
    issues. In most cases, this kind of analysis is integrated into the software delivery
    cycle as a standard step for each release. This kind of test is also named **static
    software analysis** because it refers to inspecting the software when it is not
    being executed (hence, looking at the source code).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码检查**：这是专注于分析代码中的已知错误。虽然这是一种通用技术，但它可以专注于安全问题。在大多数情况下，这种分析作为每个发布的标准步骤集成到软件交付周期中。这种测试也被称为**静态软件分析**，因为它指的是在软件未执行时检查软件（因此，查看源代码）。'
- en: A technique similar to the previous point is checking the versions of dependencies
    in an application. This may refer to libraries, such as Maven dependencies. Such
    modules are checked against databases for known vulnerabilities linked to the
    specific version. This is part of following the general recommendation of keeping
    the software constantly patched and upgraded.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一点类似的技术是检查应用程序中依赖项的版本。这可能指的是库，例如 Maven 依赖项。这些模块会与数据库中的已知漏洞进行比对，这些漏洞与特定版本相关联。这是遵循保持软件持续打补丁和升级的一般建议的一部分。
- en: All of the aspects seen so far are relevant best practices that can be partially
    or completely adopted in your project. However, there are contexts where security
    checks and considerations must be applied in a standardized and well-defined way,
    which we will see next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止看到的所有方面都是相关的最佳实践，可以在项目中部分或全部采用。然而，在某些情况下，必须以标准化和明确的方式应用安全检查和考虑因素，我们将在下一部分看到。
- en: Security standards and regulations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全标准和法规
- en: '**Security** is a core concept in applications, especially in some specific
    industries, such as financial services, defense, healthcare, and the public sector.
    But it''s really a cross-concept that cannot be ignored in any context. For this
    reason, there are sets of regulations, sometimes mandated by law or industry standards
    (for example, banking associations), that mandate and standardize some security
    practices. These include the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Payment Card Industry Data Security Standard** (**PCI DSS**): This is a very
    widespread standard for implementing and maintaining IT systems that provide credit
    card payments. The goal is to reduce fraud and establish the maximum level of
    trust and safety for credit card users. PCI DSS mandates a set of rules not only
    on the system itself (such as access control and network security) but also in
    the way IT staff should handle such systems (by defining roles and responsibilities).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Criteria** (**CC**): This is an international standard (under the
    denomination ISO/IEC 15408) that certifies a set of tests for checking the security
    of an IT system. Such certification is conducted by authorized entities, and the
    certified systems are registered on an official list.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Web Application Security Project** (**OWASP**): This approach is a bit
    different from what we have seen so far. Instead of being a centralized testing
    institution providing a certification, OWASP is an open and distributed initiative
    that provides a set of tools, tests, and best practices for application security
    (especially focused on web application security). OWASP also shares and maintains
    a list of well-known security issues. The association distributes the **Dependency-Check**
    tool ([https://owasp.org/www-project-dependency-check](https://owasp.org/www-project-dependency-check)),
    which helps in identifying vulnerable software dependencies, and the Dependency-Track
    tool monitors and checks dependency usage.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we explained, security is a crucial topic that must be considered important
    in all project phases (from design to implementation to testing) and across all
    different teams (from developers to testers to sysadmins). This is the reason
    why we decided to consider it a cross-cutting concern (and why we discussed it
    in this chapter). To establish and maintain security in our applications, best
    practices must be taken into account at every step of a development project, including
    coding. But to maintain a safe system, we should also consider other potential
    sources of disruption and data loss, and ways to avoid or mitigate them, which
    we will look at in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is about preventing fraudulent activities, the theft of data, and other
    improper behavior that could lead to service disruptions. However, our application
    can go down or provide degraded service for several other reasons. This could
    be due to a traffic spike causing an overload, a software bug, or a hardware failure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The core concept (sometimes underestimated) behind the resiliency of a system
    is the **Service Level Agreement** (**SLA**).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: An SLA is an attempt to quantify (and usually enforce with a contract) some
    core metrics that our service should respect.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Uptime
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most widely used SLA is **uptime**, measuring the availability of the system.
    It is a basic metric, and it's commonly very meaningful for services providing
    essential components, such as connectivity or access to storage. However, if we
    consider more complex systems (such as an entire application, or a set of different
    applications, as in microservices architectures), it becomes more complex to define.
    Indeed, our application may still be available, but responding with the wrong
    content, or simply showing static pages (such as a so-called *courtesy page*,
    explaining that the system is currently unavailable).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: So, the uptime should be defined carefully in complex systems, by restricting
    it to specific features and defining their expected behaviors (such as the data
    that these features should provide).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Uptime is usually measured as a percentage over a defined period, such as 99.9%
    per year.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the uptime, it''s useful to define the two possible types
    of outages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Planned downtime**: This refers to service disruption occurring due to maintenance
    or other predictable operations, such as deployments. To reduce planned downtime,
    one technique is to reduce the number of releases. However, this kind of technique
    may be impractical for modern systems because it will reduce agility and increase
    time to market. So, an alternative approach is to implement rolling releases or
    similar techniques to continue to provide services (eventually in a degraded mode)
    while performing releases or other maintenance activities.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unplanned downtime**: This is, of course, linked to unpredictable events,
    such as system crashes or hardware failures. As we will see in this section, there
    are several techniques available for increasing uptime, especially in cloud-native
    architectures.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With regard to unplanned downtime, there are several further metrics (I would
    say *sub-metrics*) that measure certain specific aspects that are useful for further
    monitoring of the service levels of a system:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean time between failures**: This measures the average time between two
    services outages (as said before, an outage can be defined in many ways, ranging
    from being completely down to services answering incorrectly). A system with a
    short mean time between failures, even if still respecting the overall uptime
    SLA, should be considered unstable and probably fixed or strengthened.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean time to recovery**: This measures the average time to restore a system
    to operation following a period of downtime. This includes any kind of workaround
    or manual fix to resolve an issue. These kinds of fixes are considered temporary.
    A system with a high mean time to recovery might need some supporting tools or
    better training for the team operating it.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean time to repair**: This is similar to the previous metric but measures
    the complete resolution of an issue definitively. The difference between this
    metric and the previous one is subtle and subjective. A high mean time to repair
    can signify a poorly designed system or the lack of good troubleshooting tools.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uptime is not the only SLA to consider when monitoring a system with regard
    to resiliency. Several other metrics can be measured, such as the response time
    of an API (which can be measured with something such as *90% of the calls should
    respond in under 1 millisecond*), the error rate (the percentage of successful
    calls per day), or other related metrics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: But as we said, there are several techniques to achieve these SLAs and increase
    system reliability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Increasing system resiliency
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most commonly used (sometimes overused) technique for increasing system
    resiliency is **clustering**. A **cluster** is a set of components working concurrently
    in a mirrored way. In a cluster, there is a way to constantly share the system
    status between two or more instances. In this way, we can keep the services running
    in case downtime (planned or unplanned) occurs in one of the systems belonging
    to the cluster itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, a cluster may involve a redundant implementation of every subsystem
    (including network, storage, and so on) to further improve resiliency in the event
    of the failure of supporting infrastructure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Clusters are usually complex to set up and there is a price to pay for the increase
    in reliability, usually a performance impact due to the replication of the state.
    Moreover, depending on the specific application, there are several restrictions
    for implementing a cluster, such as network latency and the number of servers
    (nodes).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We discussed a related topic in [*Chapter 11*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271)*,*
    *Dealing with Data*, when talking about **NoSQL** repositories and the **CAP**
    theorem. Since the data inside a cluster can be considered distributed storage,
    it must obey the CAP theorem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: A cluster often relies on a networking device, such as a network load balancer,
    that points to every node of the cluster and re-establishes full system operativity
    in case of a failure, by redirecting all the requests to a node that is still
    alive.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: To communicate with each other, the cluster nodes use specific protocols, commonly
    known as a **heartbeat** protocol, which usually involves the exchange of special
    messages over the network or filesystem. A widely used library for implementing
    heartbeat and leader election in Java is **JGroups**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: One common issue with clusters is the **split-brain** problem. In a split-brain
    situation, the cluster is divided into two or more subsets, which are unable to
    reach each other via the heartbeat. This usually occurs because of a network interruption
    between the two system subsets, caused by a physical disconnection, a misconfiguration,
    or something else. In this situation, one part of the cluster is unaware if the
    other part is still up and running (but cannot be seen using the heartbeat) or
    is down. To maintain data consistency (as seen in the CAP theorem in [*Chapter
    11*](B16354_11_Final_JM_ePUB.xhtml#_idTextAnchor271), *Dealing with Data*) in
    the case of split-brain, the cluster may decide to stop operating (or at least
    stop writing functionalities) to avoid processing conflicting operations in two
    parts of the cluster that are not communicating with each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: To address these scenarios, clusters may invoke the concept of a quorum. A **quorum**
    is the number of nodes in a cluster required for the cluster to operate properly.
    A quorum is commonly fixed to *half of the cluster nodes + 1*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: While the details may vary with the type of specific cluster implementation,
    a quorum is usually necessary to elect a cluster leader. The leader may be the
    only member of the cluster running, or, more commonly, having other duties related
    to cluster coordination (such as declaring a cluster fully functional or not).
    To properly handle split-brain situations, a cluster is usually composed of an
    odd number of nodes, so if there's a split between two subsets, one of the two
    will be in the majority and continue to operate, while the other will be the minority
    and will shut down (or at least deny write operations).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the use of a quorum is the technique of **witnesses**. A cluster
    may be implemented with an even number of nodes, and then have a special node
    (usually dislocated in the cloud or a remote location) that acts as a witness.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: If there's a cluster split, the witness node can reach every subset of the cluster
    and decide which one should continue to operate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As we have said, clustering can be expensive and has lots of requirements. Moreover,
    in modern architectures (such as **microservices**), there are alternative approaches
    for operating in the case of a failure in distributed setups. One common consideration
    is about the eventual consistency, discussed in the previous chapter, under the
    *Exploring NoSQL repositories* section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For all these reasons, there are other approaches to improving system availability,
    which can be used as an alternative or a complement to clustering.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Further techniques for improving reliability
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative approach to clustering used to improve reliability is **High
    Availability** (**HA**). An HA system is similar to a clustered system. The main
    difference is that in normal conditions, not all nodes are serving requests. Conversely,
    in this kind of setup, there is usually one (or a limited number of) primary nodes
    running and serving requests, and one or more failover nodes, which are ready
    to take over in the case of a failure of the primary node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The time for restoring the system may vary depending on the implementation of
    the systems and the amount of data to restore. The system taking over can already
    be up and running (and more or less aligned with the primary). In this scenario,
    it's called a **Hot Standby**. An alternative scenario is when the failover servers
    are usually shut down and lack data. In this case, the system is called **Cold
    Standby** and may take some time to become fully operational.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: An extreme case of Cold Standby is **Disaster Recovery** (**DR**). This kind
    of system, often mandated by law, is dislocated in a remote geographical location,
    and aligned periodically. How remote it should be and how often it is aligned
    are parameters that will vary depending on how critical the system is and how
    much budget is available. A DR system, as the name implies, is useful when recovering
    from the complete disruption of a data center (due to things such as a fire, an
    earthquake, or flooding). Those events, even if unlikely, are crucial to consider
    because being unprepared means losing a lot of money or being unable to re-establish
    a system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: DR is also linked to the concept of **Backup and Restore**. Constantly backing
    up data (and configurations) is crucial to re-establishing system operation in
    the case of a disaster or unforeseen data loss (think about a human error or a
    bug). Backed-up data should also be periodically tested for restore to check the
    completeness of data, especially if (as is advised) the data is encrypted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you are planning to use clustering, HA, or DR, two special metrics
    are commonly used to measure the effectiveness and the goals of this kind of configuration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Recovery time objective** (**RTO**): This is the time needed for a failover
    node to take over after the primary node fails. This time can be 0 (or very limited)
    in the case of clustering, as every node is already up and running, or can be
    very high in the case of DR (which may be acceptable as the occurrence of a disaster
    is usually very unlikely).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recovery point objective** (**RPO**): This is the amount of data that it
    is acceptable to lose. This may be measured in terms of time (such as the number
    of minutes, hours, or days since the last sync), the number of records, or something
    similar. An RPO can be 0 (or very limited) in a clustered system, while it can
    be reasonably high (such as 24 hours) in the case of DR.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A last important topic is the **physical location** of the application. Indeed,
    all of the approaches that we have seen so far (clustering, HA, and DR, with all
    the related metrics and measurements, such as RPO and RTO) can be implemented
    in various physical setups, greatly varying the final effect (and the implementation
    costs).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: One core concept is the **data center**. Indeed, each node (or portion) of a
    cluster (or of an HA or DR setup) can be running on a physically different data
    center in a specific geographical location.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Running servers in different data centers usually provides the maximum level
    of resiliency, especially if the data centers are far away from each other. On
    the other hand, the connection between applications running in different data
    centers can be expensive and subject to high latency. Cloud providers often call
    the different data centers **availability zones**, further grouping them by geographical
    area, to provide information about the distance between them and the users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: However, even if an application is running in just one data center, there are
    techniques to improve resilience to failures and disasters. A good option is running
    the application copies in different rooms in a data center. The rooms of a data
    center, even if belonging to the same building, can be greatly independent of
    each other. These data centers may apply specific techniques to enforce such independence
    (such as dedicated power lines, different networking equipment, and specific air
    conditioning systems). However, it's easy to understand that major disasters such
    as earthquakes, floods, and fires will be disruptive for all the rooms in the
    same way. However, hosting in separate rooms is usually cheaper than in separate
    data centers, and rooms have quite good connectivity with each other.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: A lower degree of isolation can be obtained by running different copies of our
    application (different nodes of a cluster) on different racks. A **rack** is a
    grouping of servers, often all running in the same room (or close to each other,
    at least). In this sense, two applications running on different racks may be unaffected
    by minor issues impacting just one rack, such as a local network hardware failure
    or power adapter disruption, as these physical devices are commonly specific to
    each rack.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a blackout or a defect in the air conditioning system will almost
    certainly impact all the instances of our cluster, even if running on different
    racks. For all of these reasons, different racks are cheaper than the other implementations
    seen so far, but can be pretty poor in offering resilience to major disasters,
    and are completely unsuitable for implementing proper DR.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: A closer alternative to different racks is running our application in the same
    rack but on different machines. Here, the only redundancy available is against
    local hardware failures, such as a disk, memory, or CPU malfunctioning. Every
    other physical issue, including minor ones (such as a power adapter failing),
    will almost certainly impact the cluster availability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, it is possible to have the instances of a cluster running
    on the same physical machine thanks to containers or server virtualization.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, this technique, while very easy and cheap to implement, will
    not provide any protection against hardware failures. The only available reliability
    improvement is against software crashes, as the different nodes will be isolated
    to some degree.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: All of the approaches that we have seen so far offer ways to improve the overall
    application availability and were available long before cloud-native applications.
    However, some modern evolutions of such techniques (such as the **saga pattern**,
    seen in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing
    Cloud-Native Architectures*) happen to better suit modern applications (such as
    microservices-based ones).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: A topic that is worth highlighting is **reliability**. In the past, reliability
    was treated exclusively at the infrastructure level, with highly available hardware
    and redundant network connections. However, nowadays, it is more common to design
    application architectures that are aware of where they run, or of how many instances
    are running concurrently. In other words, applications that take reliability and
    high availability into consideration have become common. In this way, it is possible
    to implement mixed approaches that provide degraded functionalities if failure
    is detected in other nodes of the cluster. So, our application will still be partially
    available (for example in read-only mode), thereby reducing the total outage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Another technique is to apply **tiering** to functionalities (for example, to
    different microservices). To do so, it's possible to label each specific functionality
    according to the severity and the SLA needed. Hence, some functionalities can
    be deployed on highly resilient, expensive, and geographically distributed systems,
    while other functionalities can be considered disposable (or less important) and
    then deployed on cheaper infrastructure, taking into account that they will be
    impacted by outages in some situations (but this is accepted, as the functionalities
    provided are not considered core).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: All of these last considerations are to say that even if you will never have
    the job of completely designing the availability options of a full data center
    (or of more than one data center) in your role as a software architect, you will
    still benefit from knowing the basics of application availability so that you
    can design applications properly (especially the cloud-native, microservices-based
    ones), thereby greatly improving the overall availability of the system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: With this section, we have completed our overview of cross-cutting concerns
    in software architectures.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen an overview of the different cross-cutting concerns
    that affect software architecture. This also included some solutions and supporting
    systems and tools.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the different ways of managing identity inside our application
    (especially when it involves several different components, such as in a microservice
    architecture).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We had an overview of the security considerations to be made when designing
    and implementing an application (such as intrinsic software security and overall
    software security), which are crucial in a shift-left approach, which is the way
    security is managed in DevOps scenarios.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we had a complete overview of application resiliency, discussing
    what a cluster is, what the implications of using clustering are, and what other
    alternatives (such as HA and DR) can be implemented.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore the tooling supporting the software
    life cycle, with a particular focus on continuous integration and continuous delivery.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Neil Daswani, Christoph Kern, and Anita Kesavan: *Foundations of Security:
    What Every Programmer Needs to Know*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Keycloak community: *The Keycloak OpenSource IDM* ([https://www.keycloak.org](https://www.keycloak.org))'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evan Marcus and Hal Stern: *Blueprints for High Availability: Timely, Practical,
    Reliable*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
