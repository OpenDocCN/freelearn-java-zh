- en: RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the basics of REST and how to use Postman
    and Spring for accessing and writing REST APIs. Lastly, we will build an app with
    a REST interface.
  prefs: []
  type: TYPE_NORMAL
- en: Postman is a GUI-driven app for interacting with HTTP APIs by constructing requests
    and reading responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the fundamentals of REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize Postman to access both public and personal REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize Spring for writing REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an app with a REST interface, based on the blogmania app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a RESTful API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) is an access point to a software
    meant for machines (or other software products) rather than people. It has become
    kind of a buzzword lately, even though the concept has been there for decades.
  prefs: []
  type: TYPE_NORMAL
- en: APIs, and more specifically (and more recently) REST APIs, are the backbone
    of communication services. They are what modern distributed cloud-based applications
    work through. They are also the way that modern browser user interfaces communicate
    with their backend services.
  prefs: []
  type: TYPE_NORMAL
- en: 'For communication services, there are different styles of API. What kinds can
    you come up with? Examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST – Formal Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The acronym **REST** stands for **REpresentational State Transfer**. The term
    was coined in the influential work *Architectural Styles and the Design of Network-Based
    Software Architectures*, (University of California, Irvine, 2000) by Roy Fielding.
    As this was his doctoral dissertation, few people have actually read it, and it
    is far beyond the scope of a Spring Boot book.
  prefs: []
  type: TYPE_NORMAL
- en: Fielding's original work can be viewed online at [https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
  prefs: []
  type: TYPE_NORMAL
- en: for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: For a more hands-on view, similar to what we will take in this book, you may
    go to [https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer](https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer)
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: The RESTful API – Practitioner's Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a programmer, a slightly relaxed set of rules is sufficient for daily work.
    On the other hand, we use some fixed defaults where the REST architecture allows
    different choices:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP calls using all the verbs—Calls in RESTful APIs are done using the well-known
    HTTP protocol. This allows us to use all the infrastructure of the web, such as
    load balancers or caches. In addition to GET and POST calls, a RESTful API also
    uses `PUT` and `DELETE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass options in the URL or in headers—It is customary to put real data in the
    body of requests, but only options that influence the search or the requested
    representation of the response in URL parameters or even HTTP headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer status as HTTP status code—HTTP offers a wide range of response codes.
    On the WWW, you mostly see only 200 (OK) and 404 (Not Found), but there are codes
    to signify that the request was in a bad format or that a new entity was created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and answer payload in JSON format—JSON is the de facto standard these
    days. This excludes, of course, binary data such as images, which are transmitted
    as is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the Yes/No API in Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When starting Postman for the first time, you must get past two dialogs: the
    first prompts you to register, but there is a link to take you to the app without
    registering. The second creates a collection of queries, and Postman requires
    at least one such collection, even if you do not intend to save your queries at
    all.'
  prefs: []
  type: TYPE_NORMAL
- en: Once inside the main window, enter [https://yesno.wtf/api](https://yesno.wtf/api)
    into the field for the URL. In front of this field, there is a dropdown for the
    HTTP method; leave it at GET. After pressing the Enter key (or the Send button),
    the request is performed, and you can see the response status (which should be
    200 OK) and the response body in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response body contains a field called `answer` which is either yes or no.
    For fun, you can click and follow the link to the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ee6d8f8-3067-4123-a0e3-02c1d7192b2d.png)'
  prefs: []
  type: TYPE_IMG
- en: REST Guiding Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen a REST call in action, let's revisit some guiding principles
    that a good REST API should follow in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: A web browser can navigate to any kind of website. Just like this, a REST client
    should be able to navigate to a REST API. (Of course, in practice, this is limited
    by the intelligence of the machine.) This means that, ideally, all you need for
    an API is the starting point, and then all navigation only follows links that
    were embedded in a previous response. This principle is called **hypertext** or
    **hypermedia** - and, yes, that is the `HT` part in both **HTML** (**Hypertext
    Markup Language**) and **HTTP** (**Hypertext Transfer Protocol**).
  prefs: []
  type: TYPE_NORMAL
- en: The second principle is to make proper use of the HTTP verbs. There are quite
    a few of them, some rather technical and only concerned with the protocol itself,
    others for very special purposes.
  prefs: []
  type: TYPE_NORMAL
- en: REST Resource Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following table that highlights the main methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/599068f3-d67e-43db-9879-2db79e781491.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The third principle is to use resources instead of remote procedure calls.
    This becomes very apparent when it comes to the naming of endpoints: endpoints
    are not verbs (after all, that is what the HTTP verbs are for), but they are nouns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize the lifecycle of a resource, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1617a1d2-688e-4fc4-8f5a-4282fc32e844.png)'
  prefs: []
  type: TYPE_IMG
- en: Utilizing SWAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to view a good REST API in action. We'll be exploring or testing
    an existing API. Unfortunately, in the beginning, this will be a read-only API,
    so we will only see GET requests. The API we are using here is **SWAPI**, the
    **Star Wars API**. It is a REST API that allows you to browse planets, spaceships,
    vehicles, people, films, and species of the Star Wars universe. This API is public
    and not access-controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Before beginning, you should open Postman. If your Postman app is freshly installed,
    you can tell it that you do not want to register at the first prompt. At the second,
    you have to create a collection (any name is fine, although **Default** may just
    be a good choice here). You are presented with the main window. Depending on the
    size of the window, the request history may or may not be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the entry URL of SWAPI: [https://swapi.co/api/](https://swapi.co/api/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see as an answer a set of links to other resources: a resource for
    people, a resource for planets, and so on. Follow the resource for people.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In *step 2*, you get a not only people answer, since you accessed a collection
    resource. There are two things to take note of here: first, it is not a list containing
    all the people, but only the first ten, with a link to the next ten (if applicable,
    you may get a link to the previous ten as well). Second, each entry has a link
    to itself, not only an ID that could be used to construct such a link.'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the link for Luke.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result of *step 3*, however, is a single entry: a resource that ends with
    an ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2075a66-361e-4534-943b-a85a908a5c48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Have a look in the **Headers** area of the response and find the **Content-Type**
    header to confirm that the server sent JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99369fbb-bd37-4699-ba4a-45ea977eb350.png)'
  prefs: []
  type: TYPE_IMG
- en: Back in the Body area, you can choose to view the raw answer of the server instead
    of the pretty-printed version that Postman presents to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, do some research: what is Luke''s homeworld?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may find that Luke's homeworld is Tatooine, but the important thing to note
    here is that you can follow the links and explore the data just as you would on
    a traditional web page in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: All of the source code for this chapter, including some Postman collections
    in JSON format to be imported in Postman, can be found at [https://bit.ly/2QxGni4](https://bit.ly/2QxGni4)
     in the accompanying GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following Postman screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/957ece56-981f-4513-ad9e-9573070f2a45.png)'
  prefs: []
  type: TYPE_IMG
- en: REST Controllers in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have recapped what REST APIs are, you probably want to know how
    to use them with Spring. You will see that you already know most of what you need
    for this. The key is in the little enhancements that Spring provides.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a REST Controller Different?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen many controller functions in the preceding chapters. Spring is
    enormously flexible in the signatures that controller functions are allowed to
    have, both in the parameters they take and the results they return; but in most
    cases, the return value of such a controller function is not the actual response
    sent to the browser, but a view name that is then resolved against static content
    or a view rendered by a template engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a REST controller, this is different— we want to return data instead. We
    can do this directly or by using an implicit mapper, as you will see. You have
    already seen in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml): The
    MVC Pattern, in the Additional Annotations and Parameters for Handler*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Methods* section how to return data instead of the view name from a controller—The
    controller needs to be annotated with `@ResponseBody`.'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, that's all you need to know for REST controllers.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section will show you how to implement all the REST-guiding
    principles that we introduced previously. These advanced elements are not REST-specific
    and can sometimes become useful in a normal Spring MVC context, but they are indispensable
    for implementing REST controllers.
  prefs: []
  type: TYPE_NORMAL
- en: '"Response Body" in Detail'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at short code excerpts to bring the main concepts
    to you step by step. More complete code that is an extension to the blog application
    (from the previous chapter) will come a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following piece of code, which is a complete Spring controller
    class in Java (lacking only the imports):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `@Controller` annotation also marks this class as a Spring
    component that will be found in the `classpath` scanning. The `@RequestMapping`
    annotation marks a method as a method to map to a certain path, given here as
    its argument. Finally, the `@ResponseBody` annotation lets Spring return the literal
    data of the method's return value instead of mapping it using a view name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what will the outcome be? You can actually follow that link in your web
    browser or in Postman, but for this document, we will use a notation that looks
    like the HTTP communication on the wire, with only some details left off. If you
    are interested, you can look at this for yourself by using telnet, but mostly
    it is very convenient for showing both the client''s request and the server''s
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the String return value of our method is also the data that
    the server sends out. Spring filled out some response headers automatically—it
    set the Content-Length to `8` (this is measured in bytes), and it set the Content-Type
    (also known as the MIME type or media type) of the response to plain text in UTF-8
    encoding. (Encoding is a misnamed charset in many contexts.)
  prefs: []
  type: TYPE_NORMAL
- en: Of course, producing text instead of HTML is good, but the standard format for
    data exchange in REST controllers these days is JSON, so let's make the controller
    return this.
  prefs: []
  type: TYPE_NORMAL
- en: Returning JSON Manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try the straightforward way first. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that changed here is the returned string. It now contains JSON,
    with a log of backslashes to encode the necessary double quotes within a Java
    string. The result of the request, then, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to criticize here. The first thing is that the JSON is
    cumbersome to write. Java makes this very hard because the embedded double quotes
    need to be escaped. JSON may be a reasonably easy format, but, still, particularly
    for bigger data structures than the one returned here, creating it by hand is
    error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Second, and more importantly, the content type is still set to plain text! Some
    clients may ignore the Content-Type header anyway and just expect JSON to be returned,
    and those clients will work with our faulty server. Well-behaved clients, however,
    will not recognize it as JSON. They may accept it as text (albeit weird text)
    or altogether reject it.
  prefs: []
  type: TYPE_NORMAL
- en: Postman, for instance, honors the Content-Type header. By default, it will show
    the output of a call to this controller as plain text. You may, however, choose
    JSON by hand, thereby overriding the detected Content-Type.
  prefs: []
  type: TYPE_NORMAL
- en: In rare circumstances, this might be a quick hack to satisfy some required interface,
    but surely we can do much better!
  prefs: []
  type: TYPE_NORMAL
- en: Manual JSON, Correct Content-Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main problem with the preceding code is that it created an incorrect HTTP
    response for what we intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What changed here in this code excerpt is only the `@RequestMapping` line. We
    add a second parameter that produces the annotation, which then gives the value
    of the Content-Type HTTP header. Actually, it's not the verbatim header, as you'll
    see in a moment; also, repeating such a value may lead to subtle errors, and you
    will see a better alternative later on. The path parameter is the same as the
    implicit value parameter that was used before when we only had one argument for
    the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outcome of this controller has improved greatly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We get the same Content-Length here and in fact the same payload, but the Content-Type
    header is now pointing to JSON as we wanted! Notice how Spring added the encoding
    on its own. Now, Postman will, by default, show this as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once more, we will go through a demo, using Postman to access a REST resource,
    but this time accessing our own application instead of something from the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the "rest-intro" project provided on GitHub, and start the `RestIntroApplication`
    class within it: navigate to the class and then either press *Ctrl-Shift-F10*
    or click on any of the green triangles in the gutter of the editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Postman. You should import the Postman collections that are available
    on GitHub, so that you can easily use the pre-defined queries. The "REST-Intro"
    collection contains the requests needed here. Execute the queries `greeting/string`,
    `greeting/fakeJson` and `greeting/manualJson`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show both the **Body** and the **Headers** panes. The first query will return
    a proper string, the second one returns a hybrid (a string that looks like JSON),
    and the third will return a proper JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other drawback remains: hand-written JSON is probably not what we want.
    Though slightly more complicated in these toy examples, the following sections
    will show you how to deal with JSON in real life.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping Data to JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To conclude this section on simple REST controllers, these two methods will
    return proper JSON, but you will see nothing of that in the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Wow! That was easy.
  prefs: []
  type: TYPE_NORMAL
- en: Both variants produce exactly the same outcome (except for the text itself,
    that is). It is also the same as in the preceding code, only that for non-string
    return values, Spring does not automatically add the Content-Length header. This
    is a bit unfortunate, but since most clients do not make much use of it, it is
    generally acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: What happened here? Upon finding a complex return type, Spring will look for
    an `HttpMessageConverter` bean in the application context and relay processing
    to it. A very good library for converting between Java objects and JSON is *Jackson*
    by *FasterXML* (you can find the project homepage at [https://github.com/ FasterXML/jackson](https://github.com/FasterXML/jackson)).
    Spring comes with a specific `HttpMessageConverter` implementation called `MappingJackson2HttpMessageConverter`,
    which uses Jackson for the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do to use this implementation is nothing at all. The `spring-boot-starter-
    web` dependency that we use for this Spring MVC project already depends on `spring-boot-starter-json`
    that, in turn, depends on Jackson. Now, Spring''s magic kicks in: when Jackson
    is found in the Java `classpath` upon startup, then all the necessary Beans are
    created automatically. This way, returning JSON just works - out of the box!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only question that remains is whether you would prefer to create specialized
    Java classes for all different kinds of JSON payloads that you expect, or whether
    you would rather go with (nested) maps. One is more type-safe; one is more flexible;
    the choice is up to you. Throughout this book, we are giving preference to sections
    of Java that are easy enough to create with Project Lombok, which was introduced
    in *[Chapter 1](9c691a93-c936-4976-b836-8ec08d62bffb.xhtml): The Spring Project
    and Framework*.'
  prefs: []
  type: TYPE_NORMAL
- en: REST Controllers in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap it up, please remind yourself that most of the annotations that were
    mentioned can not only go on a method, but also on the class level. The semantics
    are then that those annotations are for all methods in the class,
  prefs: []
  type: TYPE_NORMAL
- en: Some annotations serve as defaults for all methods. They count if they are not
    overwritten on the method. An example of this would be `@RequestBody`, which turns
    all methods in a class that are also annotated as mapped into REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Some annotations are additive. The `@RequestMapping` annotation is one of those.
    It does not turn each method into an endpoint, but it gives a common path prefix
    for all methods that are also endpoints. In an extreme scenario, these methods
    do not need to specify any path if they only differ in the produced MIME type
    or the HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of `@Controller` and a class-level `@RequestBody` annotation
    is so common and useful for REST controllers that there is a specialized annotation
    just for this case, and it is, rather unsurprisingly, called `@RestController`.
    It is this annotation that will be used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim is to implement your first REST endpoint by returning JSON. You have
    an existing application that needs another endpoint. The project is completely
    set up, so adding a single class is enough. Before beginning, open the rest-intro
    project in IntelliJ and make sure that you can start the `RestIntroApplication`. The
    steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class – you may call it `DateTimeController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate it with `@RestController`. Use auto-completion or *Ctrl+Space* in IntelliJ
    to complete the annotation and add the import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new inner static class called `DateTime` with some String fields such
    as date and time. Add the appropriate getters and constructor. Lombok will be
    very helpful here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new method that returns an instance of the new data class. It does not
    need any arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the method with `@GetMapping` and make it react to some path, for instance,
    to `/api/datetime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the current time and date, put them into a new instance of `DateTime`,
    and return that. You can use the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Re-run the program and access your new resource with Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The answer will, of course, depend on your local time and date, but it will
    be JSON (application/json) format and look something along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**{"date":"1989-11-09","time":"19:01:30.123","zone":"Central European Time
    (CET)","zoneId":"Europe/Berlin","zoneOffset":"+01:00"}**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a possible solution that also returns the time zone in the GitHub
    repository by going to [https://bit.ly/2qABGIY](https://bit.ly/2qABGIY). Go
  prefs: []
  type: TYPE_NORMAL
- en: to [https://bit.ly/2xaeSlT](https://bit.ly/2xaeSlT) to access the complete code
    for the `RestIntroApplicationTests.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Content Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw Content-Types in the preceding responses.
  prefs: []
  type: TYPE_NORMAL
- en: All content has some type (or many, mixed). Humans are good at reading and understanding
    content by just looking at it, but computers work best if they are told beforehand
    what to expect. For that purpose, and originally as an extension to the internet
    mail standard, RFC 2046 specifies Media Types (formerly known as MIME types).
    A list of agreed-upon Media Types is coordinated by the IANA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following resources for the standards:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 2046: [https://tools.ietf.org/html/rfc2046](https://tools.ietf.org/html/rfc2046).'
  prefs: []
  type: TYPE_NORMAL
- en: 'IANA: [http://www.iana.org/assignments/media-types/mediatypes.xhtml](http://www.iana.org/assignments/media-types/mediatypes.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content types most interesting in the web application context are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: text/html when HTML pages are returned to the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: text/css, text/javascript, and image/jpeg for the content linked in web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: text/plain as a fallback for plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: application/x-www-form-urlencoded as the default format, where the browser sends
    data entered in a form to the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: application/json for AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The HTTP protocol has two headers that deal with content types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Accept` in the *request* to specify what is accepted as a result. This can
    be a list of accepted types ('
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or the header can be repeated), and it can contain wildcards and weights to
    specify preferences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This header has companions such as Accept-Charset and Accept-Language that are
    of lesser interest, meaning that you will not be concerned with them generally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Content-Type` in the *response* to specify what the actual result is. This
    header has similar companions to the Accept header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing Different Content Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already saw that the produced content type may change when you return different
    things from your controller, and that you can also influence the content type
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: An important principle of REST is that we use the HTTP protocol to its full
    extent, using the right HTTP methods (or verbs), but also leave content negotiation
    and caching to the protocol and the intermediary nodes. Therefore, you shall never
    have two resources called `/api/customers.json` and `/api/customers.xml` if you
    need the same logical resource in two different formats.
  prefs: []
  type: TYPE_NORMAL
- en: Spring, by the way, allows just that if you configure it that way, but this
    will not be shown here on purpose. It used to be the default in previous versions,
    but is now deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code seems to specify the same resource twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note how the path to the resource is only specified at the class level. The
    two functions only provide GET endpoints, and they do differ— one of them returns
    a String that will be sent to the client as plain text, and the other one returns
    a complex object that will be turned into JSON by the mapper. You have already
    seen the produces option; it is still of String type, but this time, we use predefined
    constants in the `MediaType` class to avoid duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two endpoints will react to different requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Both requests go to the same resource, but with different Accept headers. As
    you can see, Spring, by default, added the charset, which is UTF-8 in this case,
    to the response. That way, the client is able to understand the encoding of the
    response body. Currently, Spring controllers will return the JSON if no Accept
    header is given, but you should not rely on such behavior.
  prefs: []
  type: TYPE_NORMAL
- en: All that was needed was the differing product options. The method names are
    ignored by Spring, and they are different only to avoid a name clash, and also
    to document our intention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content negotiation, and later the dispatch to one of our functions, is
    done by the `DispatcherServlet`, which you already heard about in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml):
    The MVC Pattern*. If no method can provide the requested (or **accepted**) `Content-Type`,
    then the HTTP status **406 Not Acceptable** is issued to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Responding with XML to the Rest-intro Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim is to demonstrate responding with XML to the rest-intro application.
    The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the `RestIntroApplication` in the rest-intro project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Postman to call the resources and show that they indeed return text and
    JSON, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can use the provided Postman collection **Content-Types** for that. Also,
    try to request XML: Postman will show you an HTTP response status of **406 Not
    Acceptable**. This was to be expected since we did not provide an endpoint for
    that representation.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the application's log remains quite quiet about this in the default
    settings. Also, note that you can request many other unsupported types, but if
    you should request text/html, then alongside the 406 status code, you actually
    do get a bit of HTML showing the error, and you can also view that in the **Preview**
    pane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the ability to return XML to the resource! You need to add a new method
    to `ContentTypeController`, which is basically a copy of `greetJson()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to run the application with debug logging, you would see that Spring
    tries to use this new method when you request XML, but fails later on because
    there is no message converter. To add one, all we need is Jackson XML on the classpath,
    and the rest will be wired automatically. Add the following dependency to the
    POM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the application and demonstrate that we also respond with XML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to the JSON data structure that you know, the answer will now be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2Abj4Vb](https://bit.ly/2Abj4Vb) to access the complete
    code for the `RestIntroApplication.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Job Aid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could also just add a second media type to the existing `greetJson()`, but
    then the contained text would be the same, of course. In general, though, you
    do not want to send different data when different Content-Types are requested.
    You only want to send different representations.
  prefs: []
  type: TYPE_NORMAL
- en: You can add as many media types to a handler method as you want.
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose not to add any media type at all, as Spring will try to
    find the best matching handler method that can produce the requested `Content-Type`.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Different Content Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is by far the most common data exchange format for REST services today.
    However, it used to be XML. Some flexibility in accepting different formats may
    mean more clients are able to connect to your service.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider is that web applications can only send JSON with the
    help of JavaScript. However, a simple HTML form can also issue a POST, but it
    cannot send JSON. The default format has the `Content-Type application/x-www-form-urlencoded`,
    which is basically a simple string of key/value pairs. If our server can accept
    this, it can react to actions from a form (you saw this earlier in this chapter).
    This format may even be preferable in other contexts, since it will not need preflight
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
    for a discussion of Cross-Origin Resource Sharing. In particular, note that "simple
    requests" do not need preflight, which is an additional request the client would
    issue to find out allowed methods. Such a simple request may only have a `Content-Type
    of application/xwww-form-urlencoded`, and not JSON. Avoiding preflight requests
    may speed up a client application considerably on networks with high latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2pVBBz7](https://bit.ly/2pVBBz7) to access the complete
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mappings use the same endpoint as before, but now utilize the POST method
    instead. This makes the dispatch possible. The result of calling these is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is (almost) as easy as putting the consumes option on the mapping annotation.
    For historical reasons, however, form values are handled a bit differently than
    JSON. For JSON and other formats with a mapper (XML, for instance), we use the
    `@RequestBody` annotation on the Java method's formal parameter. This illustrates
    quite well that the value for the actual parameter is to be taken from the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: For form encoding, each of the expected form values is passed on its own to
    a parameter that is annotated with `@RequestParameter` (which is mapped by the
    name of the formal parameter, if not overridden). Note that this is the same annotation
    that we would use to extract URL parameters. In fact, a method that does not have
    a consumes option on the mapping, but `@RequestParameter` annotations will be
    able to take the values both from form-encoded values in the request body and
    from URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For GET requests, it is not portable to have a request body. The HTTP specification
    does not require anybody handling for GET, and intermediate proxies and clients
    may strip the body if one is sent. Therefore, GET mappings cannot consume anything.
  prefs: []
  type: TYPE_NORMAL
- en: The only reliable way to pass values to a GET request is via URL parameters
    such as in `/api/greeting?addressee=John`. This is done using the `@RequestParam`
    annotation and, in code, looks the same as accepting a form with POST.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Status Code and Important Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we only cared for the body of the response (and the content-type,
    since it is so closely linked). HTTP, however, has two more very important channels
    to convey information back to the client: These are the status code and a number
    of further HTTP headers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A status code comes with every response from the server. It is a quick way
    to triage the success of the query, even before looking into the content. The
    status codes fall into five categories, the important ones in our context being
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 2xx range: Everything went well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 4xx range: The request was faulty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 5xx range: The server had a problem that is not the client''s responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full list of return codes, consult external resources such as RFC 7231\.
    Of course, there is no need to use all of them, but choosing wisely can enhance
    the meaningfulness of your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen some status codes, and we will see some more throughout
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c0bf73b-139d-424c-a525-b07b52f65fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Headers are too numerous to even scrape the surface here, but the ones you
    will see here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Content-Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location (with 201 code (see the previous table) or 3xx codes) to point to the
    real location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow (with 405 code (see the previous table) and for `OPTION` requests) to
    list allowed request methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache-Control and ETag (and others) for controlling how content should be cached
    and when to update the values in the caches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, headers starting with X-… are commonly used for various application-specific
    purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about RFC 7231 at [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the HTTP status is as per the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1XX – Hold on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2XX – Here you go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3XX – Look elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4XX – You messed up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5XX – I messed up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative Status Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to control the response status code is to simply declare it
    using the `@ResponseStatus` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is no useful information to be sent back from the PUT request, so the
    method returns void and carries an annotation to return **204 No Content**.
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest case, and especially useful to get you started. When your
    demands grow, you may need more fine-grained control and have to influence the
    response programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic Status Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the status code is always the same, unconditionally, what's the point of
    setting it anyway? Most of the time, the return values depend somehow on the input,
    or on the state of the overall system. If that is the case, we can only decide
    on which answer to send after checking some conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is to make use of a response entity, that is, a data object wrapping
    both the returned data and the all the metadata for the HTTP response. Consequently,
    Spring offers a parameterized type called `ResponseEntity<T>`, where T is the
    data that we want to be sent as JSON. This class comes with a number of static
    functions wherein each creates a response entity builder to add more information
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2xeqODe](https://bit.ly/2xeqODe) to access the complete
    code for this section.
  prefs: []
  type: TYPE_NORMAL
- en: The resource `/api/mottos` is a REST collection resource. With POST, new messages
    can be posted to the list of mottos. We do not want a motto to appear twice, so
    the method checks for uniqueness and has two different paths to create a return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: If the motto already exists, a new builder (actually called `BodyBuilder`, a
    name that may make you smile a bit, even though it is perfectly reasonable) is
    created with the `static status()` method of the `ResponseEntity` class. It takes
    as its sole argument the required response status. To actually build the response
    with an empty body, `build()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the `ok()` method is used to create the builder; this is a shortcut
    for a very common status code, and `status()` could have been used as well. This
    time, a body of the correct type is sent along as well. The `body()` function
    can be used once at most and will immediately build the result.
  prefs: []
  type: TYPE_NORMAL
- en: The `uniqueAppend()` method had `ResponseEntity<Message>` as its return type.
    But, if you look closely, it is almost like cheating, because a message was only
    sent in one of the two branches. It just so happens that an empty body is compatible
    with every generic type.
  prefs: []
  type: TYPE_NORMAL
- en: Spring is enormously flexible in the signatures it accepts for handler mapping
    functions (go to the Spring documentation under [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods)
    to verify this claim). The dispatch is done at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We hit a Java restriction here. We cannot return either a message or a specific
    error object from the same function and stay within the type system. You will
    see one way to circumvent this for most applications (error handling). If you
    really must return different types from one method, you may declare it as returning
    `ResponseEntity<?>` (a practice that static code checkers will likely criticize)
    or even `Object`. You will lose the type checking of the compiler, so be sure
    to write proper unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Global Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The error handling in each method may be quite similar and repetitive. It is
    often the same for all methods. It may also bury the main intention of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns such as these are often handled by aspects, and Spring
    uses quite a number of these. However, global error handling is provided through
    a different mechanism here, which is called an **exception handler**.
  prefs: []
  type: TYPE_NORMAL
- en: A method annotated with `@ExceptionHandler` can handle exceptions for many handler
    mappers within the same controller (or, using `@ControllerAdvice`, more globally,
    which will be explained a bit later).
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript Evaluator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement a controller that has more than one possible cause for problems,
    and do so without cluttering the business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2x9HZWM](https://bit.ly/2x9HZWM) to access the complete
    code for this section.
  prefs: []
  type: TYPE_NORMAL
- en: The controller accepts a JavaScript expression as a parameter and returns the
    result as a JSON wrapped message. It contains a bit of argument checking before
    feeding the parameter straight into the built-in JavaScript interpreter. Note
    that you do not want to do this outside a protected environment because of security
    implications, but it is fine as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what could possibly go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: One thing is the `IllegalArgumentException` that we throw ourselves, and the
    other is the checked `ScriptException` and another unchecked `ParserException`
    that Nashorn may throw. The error handling that we have in place right now only
    replaces one exception with a more informative one. The exceptions will escape
    our handler mapping. What will Spring do about it? The answer is that, by default,
    it will generate a rather helpful error object and a response status code of **500
    Internal Server Error**.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is not quite satisfying, since the error really was on the client''s side,
    and we should properly signal that to the client. To handle the two exceptions,
    we add two error handlers to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `handleArgument()` method handles the `IllegalArgumentException`, while
    `handleParse()` handles the two Nashorn exceptions. The exception argument is
    entirely optional and can have any compatible type. Again, the signatures are
    very flexible, and we could choose to return a `ResponseEntity<>` for a specialized
    error object instead.
  prefs: []
  type: TYPE_NORMAL
- en: Advising Many Controllers at Once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Advices**, in Spring MVC, are methods that declare certain aspects of handler
    functions. There are three of such advices in Spring, two of which are out of
    the scope of this introductory book (but you have seen the second briefly in Chapter
    4):'
  prefs: []
  type: TYPE_NORMAL
- en: '`@InitBinder` — to configure automatic conversion from primitive parameters
    to custom domain objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ModelAttribute` — to control common attributes in the controllers model (such
    as data).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ExceptionHandler` — to convert thrown exceptions to proper responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are scoped to the controller that they were defined in.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want a more global approach. For that, we need to define a Spring
    Bean annotated with `@ControllerAdvice`. When we do not need view resolution on
    our exception handlers, but message conversion on the response bodies instead,
    we can either put `@ResponseBody` in the appropriate places or simply use the
    `@RestControllerAdvice` annotation on the advising class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a controller advice annotation is global for all controllers by default.
    To narrow it down, there are several options to the annotation to limit the scope
    to certain packages or even to specific annotations. One very useful example would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Controlling Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To polish the responses, we may want to control the response headers. The builder
    we get from the static functions in `ResponseEntity` is actually an extension
    of a `HeaderBuilder`, so we can build both headers and a body with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the most basic form, we can use the `header()` method on this builder. For
    some common headers, specialized methods exist. Look at these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: GET requests can profit greatly from caching. For that to work, the server needs
    to know how long to cache values. Alternatively, sometimes also in conjunction,
    the client may send along with the request some data from which the server can
    determine whether the content has changed in the meantime. Without going into
    the details here, the preceding code adds the Cache-Control and the ETag headers.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the normative RFCs, you may want to read the excellent documentation
    on the Mozilla Development Network (for instance, on ETag at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag))
    when you want to know more about HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, when posting to a list resource, the new entity will be assigned
    a new ID that the client cannot know. To relay that information back to the client,
    we set the Location header with a URL pointing to the newly created entity. Spring
    supports this by the argument to the `created()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as an example, we set the X-Copyright header. Headers starting with
    X-… are not standardized and can be used for application-specific purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Different Status Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A code review asks you not to throw exceptions that you can easily avoid, so
    you should alter the code for `retrieveById()` to check its argument. (This is
    a fictional scenario where the style you find in the controller is quite acceptable,
    but remains a matter of taste.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim is to use different strategies for returning different status codes. As
    we did previously before beginning, open the rest-intro project. Navigate to the
    `MottoController` and notice that it is, in fact, a bit more useful that shown
    previously in this script: it also has an implementation for GET that uses an
    `@ExceptionHandler` to return a **404 Not Found** message. The steps for completion
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the return value of `retrieveById()` to `ResponseEntity<Message>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a condition to check whether the ID is within the range of accepted indexes
    (using `id < 1 || id > motto.size()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the out-of-bounds case, return a `ResponseEntity` with HTTP status **404
    Not Found**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the within-bounds case, return a `ResponseEntity` with HTTP status 200 OK
    and the correct motto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can remove the `@ExceptionHandler` that is now superfluous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check with Postman that the endpoint still reacts in the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The observed behavior of the program has not changed, but we are using an alternative
    way to achieve the result.
  prefs: []
  type: TYPE_NORMAL
- en: You may use `ResponseEntity.ok()` to create the response entity builder and
    then add the body, or just put the body into the `ok()` invocation as a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may use either `ResponseEntity.notFound()` or `ResponseEntity.status(HttpStatus.NOT_FOUND)`
    to create the response entity builder. However, while the second alternative returns
    a proper `BodyBuilder`, the first alternative only returns a `HeaderBuilder`.
    This means that you cannot add a body. It is unfortunate that Spring decided to
    go that way. Go to [https://bit.ly/2CZSx0S](https://bit.ly/2CZSx0S) to access
    the complete code for the `MottoController.java` file. You have to use for example
    the `mottos #1` post request first otherwise any request returns a **404** because
    the list is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a possible solution in the GitHub repository, or you can view
    the excerpt shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hypermedia with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hypermedia is an extension to hypertext that allows handling of sound and video.
    It is a key aspect of REST as it enables the creation of services that decouple
    the client and server and thus allowing them to develop independently.
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that someone gives you the link to a website. Usually, it is a link
    to the top-level page on the site or even the only page; usually, you only have
    this link. As you look at the page, you start to read and explore—you follow links
    to other pages, read on, and follow other links. You discover the whole site just
    by following the links.
  prefs: []
  type: TYPE_NORMAL
- en: Should a REST API not be the same? It can be made fully discoverable by following
    links that are embedded in the answers, so all you ever need is the start URL.
  prefs: []
  type: TYPE_NORMAL
- en: This is generally known as **hypermedia**, or **hypertext**. It is part of the
    main REST principle in Fielding's original work, and at the same time, the most
    often violated property in many REST APIs. However, it is not a mere academic
    proposal; there are APIs that follow this principle closely. Remember the beginning
    of this chapter, when we discovered the SWAPI Star Wars API from a single entry
    link?
  prefs: []
  type: TYPE_NORMAL
- en: This principle is known as **Hypermedia As The Engine Of Application State**,
    or as the unwieldy and unpronounceable acronym **HATEOAS**. Used correctly, it
    gives the server and client much more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A blog entry has an author. How would you represent this in the REST response?
    We could just embed the author, losing track of the reverse relation. We could
    return the author's ID, but how does the client know with which URL to use for
    this ID? Finally, we can just return a link to the author, solving both problems.
  prefs: []
  type: TYPE_NORMAL
- en: The REST answer may contain different links for different regions of the clients.
    This provides a single point of entry combined with location-based load balancing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When changing an endpoint, we lose backward compatibility. If, however, the
    clients are not supposed to access arbitrary URLs buried deeply in our application,
    but to follow links, we can just change the link list on the entry point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways to meet the goals of the principle. The main challenge is
    to produce all the links, particularly in a way that allows maintenance of the
    software. The Spring HATEOAS subproject simplifies the creation and consumption
    of HATEOAS resources and offers convenient functions for link creation. In this
    book, we will only touch the surface of it and add a link back to the entity itself.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `ContentTypeController` and its endpoint, `/api/greeting`, which
    could produce greetings to a person requested in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'When querying the endpoint with `/api/greeting?addressee=John`, the answer
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The addressee was given in the request, and we can see it in the message, too.
    Now, why would we return the addressee? To make it easier to recreate the link
    that we used to get the resource. This, however, means that we have to construct
    the URL from the parameter using our knowledge of the API. Let''s turn this into
    the following answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This time, we have a reference to the original link stored alongside the data.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an Application with Spring HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring HATEOAS, data objects with the ability to link to others via URL
    links are called resources (a term which has many overloaded meanings). One way
    to turn your data into such a resource is to let it extend the `ResourceSupport`
    class. This class provides the necessary mapping to JSON and an `add()` method
    to add a link. Assuming that message is such an object, a link to itself can be
    created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This needs some explaining. Both `linkTo()` and `methodOn()` are static helper
    functions in `ControllerLinkBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: The outer expression `linkTo(…).withSelfRel()` will create the link itself and
    give it a relation called self. Other styles of linking than the shown JSON exist.
    For instance, you may have seen HTML anchors with a `rel` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The inner expression is similar to what can be seen in mocking frameworks. What
    may look like a call to the actual controller function is indeed against a proxy
    object. The effect of this and quite some reflection magic is that Spring HATEOAS
    is able to evaluate the annotations that are present on the referenced method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a HATEOAS Resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have started to lay out your REST API and are faced with the requirement
    to make it HATEOAS compliant. You go ahead and enhance the API using Spring HATEOAS.
    The aim is to create a HATEOAS resource that exhibits a link to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before beginning, open the `hateoas-intro` project. This is a much stripped-down
    version of the rest-intro project. Only the `ContentTypeController` and a single
    handler method are left. The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need one more dependency in the POM. As usual, no version is required,
    as the version already comes with the Spring Boot parent POM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `ContentTypeController`, make the `Message` class extend Spring's `ResourceSupport`.
    Remove the `addressee` field that is not needed anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the code in the `greetFromPath()` method and introduce a variable message
    instead of immediately returning the result of the constructor call. (You can
    use the shortcut *Ctrl-Alt-V* to extract a variable.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, before returning the message, add the link with the code snippet you have
    already seen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Test the application in Postman now that it is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The produced JSON now contains an `additional _links` field that contains a
    reference to the resource itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the complete code placed in [https://bit.ly/2PHxyoD](https://bit.ly/2PHxyoD).
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2MsadRU](https://bit.ly/2MsadRU) to access the complete
    code for the `HateoasIntroApplicationTests.java` file. You will even find the
    solution in the `exercises/hateoas-intro-after` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Creating a List of Blog Articles as a REST Resource'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: We are building this activity upon the `blogmania` application that we built
    in the previous chapters. It already has a human-facing web frontend. You can
    find the source code at [https://bit.ly/2OxaeoF](https://bit.ly/2OxaeoF). It is
    the same as we left it in the previous activity that we've covered, so you can
    reuse that project or create a new one as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To create a list of current blog articles that will be available as a REST resource
    to query with Postman.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You have a working application for humans and are asked to add another interface
    to it, suited for other programs as clients. You decide to do it the RESTful way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Take the `blogmania` application and find the `BlogPostController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a REST controller that gives a list of all the articles under the URL
    `/api/blogposts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the full path to each method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or two dependencies to the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a mapping function to get all of the blog articles via REST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the application and use Postman to access `localhost:8080/api/blogposts`.
    We are doing this to see the list of blog articles returned as a JSON list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f85486a-888b-45e4-b58c-54587c5e1e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: The list of current blog articles will be available as a REST resource to query
    with Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2xezb1A](https://bit.ly/2xezb1A) to access the code for
    the `BlogPostController.java` file. Go to [https://bit.ly/2NFjris](https://bit.ly/2NFjris)
    to access the code for the `BlogPostRestController.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2QrByao](https://bit.ly/2QrByao) to access the `activity/`
    folder. To refer to the detailed steps, go to the *Solutions* section at the end
    of this book on page 260.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter built straight on top of the concepts of the previous chapters,
    expanding your mastery of Spring MVC controllers to different responses. This
    is flexible enough to return any kind of data but is particularly suited to serve
    REST APIs. You have learned what REST principles are and how to implement those
    with Spring. This included returning the most appropriate HTTP status code and
    various useful HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, everybody can post articles in our blogging app. We need to restrict
    this access, so we will turn our attention toward security in the next chapter.
  prefs: []
  type: TYPE_NORMAL
