<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Testing and Reporting with Gradle" id="1AT9A1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Testing and Reporting with Gradle</h1></div></div></div><p class="calibre8">In this chapter, we will cover four different topics: testing with TestNG, integration testing, code coverage with JaCoCo, and code analysis with Sonar. In <a class="calibre1" title="Chapter 2. Building Java Projects" href="part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 2</a>, <span class="strong"><em class="calibre10">Building Java Projects</em></span>, we already discussed unit testing with JUnit. In this chapter, we'll cover another widely used testing tool, TestNG. Code coverage and code quality are the other two important aspects in <span class="strong"><strong class="calibre9">test-driven development</strong></span> (<span class="strong"><strong class="calibre9">TDD</strong></span>). In today's agile development process, developers need continuous feedback on the code developed by them. Code quality tools help us to achieve this goal. Often, these tools are integrated with the <a id="id230" class="calibre1"/>
<span class="strong"><strong class="calibre9">Continuous Integration</strong></span> (<span class="strong"><strong class="calibre9">CI</strong></span>) systems so that these reports are created on a daily basis (may be even after each commit), shared among different teams, and even be persisted for future analysis. In this chapter, we will be focusing only on the Gradle aspects of different tools. We will mainly cover different Gradle plugins that support these features.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Testing and Reporting with Gradle" id="1AT9A1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="Testing with TestNG"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec38" class="calibre1"/>Testing with TestNG</h1></div></div></div><p class="calibre8">Working <a id="id231" class="calibre1"/>with TestNG is similar to the JUnit integration that we discussed in <a class="calibre1" title="Chapter 2. Building Java Projects" href="part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 2</a>, <span class="strong"><em class="calibre10">Building Java Projects</em></span>. The very first step is to create the build file with TestNG dependencies and configure the test closure. The following build file adds the TestNG library as the <code class="literal">testCompile</code> dependency and in the test closure, we added a <code class="literal">testng.xml</code> file to execute the test cases. In this section, we will briefly discuss the use of <code class="literal">testng.xml</code>:</p><div class="informalexample"><pre class="programlisting">apply plugin:'java'

repositories {
  mavenCentral()
}

dependencies {
  testCompile 'org.testng:testng:6.8.21'
}

test {
  ignoreFailures = true
  useTestNG(){
    suites("src/test/resources/testng.xml")
  }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre8">However, you can read more about<a id="id232" class="calibre1"/> TestNG configuration at <a class="calibre1" href="http://testng.org/doc/documentation-main.html">http://testng.org/doc/documentation-main.html</a>.</p></div><p class="calibre8">In our example, we<a id="id233" class="calibre1"/> have created three test cases named as <code class="literal">verifyMapSize</code>, <code class="literal">verifyMapNotNull</code>, and <code class="literal">addEvenNumbers</code>. These test cases are grouped as <code class="literal">Smoke</code> and <code class="literal">Integration</code> test cases. If you execute a Gradle test command, all the three test cases will be executed and the test report will be created in the <code class="literal">build/reports/tests</code> directory. The look and feel of the report is similar to the JUnit report that we saw earlier. The actual TestNG report is created in the <code class="literal">test-output/</code> directory in the project home directory. Both JUnit and TestNG generate their own different report formats, but Gradle reconciles them into a standard look and feel:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.ch7;

import java.util.HashMap;

import org.testng.Assert;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

public class HashTest {
  
  private HashMap&lt;Integer,String&gt; hm;
  
  @BeforeClass(alwaysRun = true)
  public void setup(){
    hm = new HashMap&lt;Integer, String&gt;();
  }
  
  @AfterMethod(alwaysRun = true)
  public void cleantask(){
    hm.clear();
  }
  
  @Test(groups = "Smoke")
  public void verifyMapSize(){
    Assert.assertEquals(hm.size(), 0);
    hm.put(1, "first");
    hm.put(2, "second");
    hm.put(3, "third");
    Assert.assertEquals(hm.size(), 3);
  }
  
  @Test(groups = "Smoke")
  public void verifyMapNotNull(){
    Assert.assertNotNull(hm);
    
  }
  
  @Test(groups = "Integration")
  public void addEvenNumbers(){
    hm.put(2, "second");
    hm.put(4, "fourth");
    Assert.assertEquals(hm.size(), 2);
  }

  
}</pre></div><p class="calibre8">A TestNG test case<a id="id234" class="calibre1"/> can be executed from a command line, Ant file, Gradle script, Eclipse plugin, or a TestNG test suite file. TestNG suite files provide a flexible mechanism control for the test execution. In a test suite file, you can define test classes, tests, test group names, listener information, and so on.</p><p class="calibre8">We have created a sample <code class="literal">testng.xml</code> file in the <code class="literal">src/test/resource</code> folder. The file has some important information. The <a id="id235" class="calibre1"/>
<span class="strong"><strong class="calibre9">listener configuration</strong></span> to create a report format, a <span class="strong"><strong class="calibre9">test group</strong></span> declaration <a id="id236" class="calibre1"/>as <code class="literal">Smoke</code>, and a test class named <code class="literal">com.packtpub.ge.ch7.HashTest</code>.</p><p class="calibre8">Gradle doesn't force you to put <code class="literal">testng.xml</code> in the <code class="literal">src/test/resources</code>, and we're just doing this as a means to keep it organized:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;
&lt;suite name="Suite1" verbose="1" &gt;
  &lt;listeners&gt;
    &lt;listener class-name="org.testng.reporters.EmailableReporter" /&gt;
  &lt;/listeners&gt;
  &lt;test name="Smoke Test"&gt;
  &lt;groups&gt;
    &lt;run&gt;
      &lt;exclude name="Integration"  /&gt;
      &lt;include name="Smoke"  /&gt;
    &lt;/run&gt;
  &lt;/groups&gt;
  &lt;classes&gt;
    &lt;class name="com.packtpub.ge.ch7.HashTest"&gt;
    &lt;/class&gt;
  &lt;/classes&gt;
  &lt;/test&gt;
&lt;/suite&gt;</pre></div><p class="calibre8">As we have <a id="id237" class="calibre1"/>only included test cases that are marked as <code class="literal">Smoke</code>, the TestNG invoked only two test cases, <code class="literal">verifyMapNotNull</code> and <code class="literal">addEvenNumbers</code>, when we executed the <code class="literal">gradle test</code> command. The following figure shows the TestNG report that is created in the <code class="literal">&lt;Project_Home&gt;/ test-output/</code> directory:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Testing with TestNG" class="calibre11"/><div class="caption"><p class="calibre26">Figure 7.1</p></div></div><p class="calibre12"> </p></div></div>
<div class="book" title="Integration testing"><div class="book" id="1BRPS2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec39" class="calibre1"/>Integration testing</h1></div></div></div><p class="calibre8">Unit testing is<a id="id238" class="calibre1"/> one of the key step in software development life cycle. It is one of the first checks to verify the code quality. Most of the basic functionalities can be tested with unit test cases. They are quick and take little time to execute. We discussed both JUnit framework and TestNG framework to unit test the code. The next step in the quality check process is integration testing. As by general definition of unit testing, you divide your code into small units and test them independently, which is good when you are developing your code independently. Once you commit the code and integrate the code with other developers, you need another level of testing, which is known as integration testing. It verifies the communication between different components working together as expected or not. Your test reports might give 100 percent success results in unit testing, but unless and until you perform integration testing, you cannot be assured of the functionality of the software as a whole.</p><p class="calibre8">We have <a id="id239" class="calibre1"/>already seen Gradle support for unit testing and how Gradle provides conventions to write your test classes in different directory structures and tasks to execute the test cases. Gradle does not differentiate between unit testing and integration testing, if we talk in terms of the convention it provides. To enable integration testing along with unit testing in Gradle, you need to customize the Gradle to enable both. Consider the following hierarchy for your project source code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">C:.</strong></span>
<span class="strong"><strong class="calibre9">└───IntegrationSample</strong></span>
<span class="strong"><strong class="calibre9">   └───src</strong></span>
<span class="strong"><strong class="calibre9">       ├───main</strong></span>
<span class="strong"><strong class="calibre9">       │   └───java</strong></span>
<span class="strong"><strong class="calibre9">       └───test</strong></span>
<span class="strong"><strong class="calibre9">           └───java</strong></span>
</pre></div><p class="calibre8">This is the standard folder structure you create for your source and test code. You create <code class="literal">src/test/java</code> to store your unit test cases. Now, if you want to add integration test cases to your project, you can merge the integration test cases in the same directory structure; however, this would not be a good design—since you might want to execute the unit test case each time you build your project and might want to execute the integration test biweekly or weekly—as it might consume more time depending on the project complexity and size. Thus, rather than merging the integration tests to your unit test cases' directory structure, we recommend you to create a separate directory structure, <code class="literal">src/integrationTest/java</code>, for integration test cases, and you can configure the same in your Gradle build scripts.</p><p class="calibre8">The following will be the updated directory structure to store the integration test cases:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">C:.</strong></span>
<span class="strong"><strong class="calibre9">└───IntegrationSample</strong></span>
<span class="strong"><strong class="calibre9">   └───src</strong></span>
<span class="strong"><strong class="calibre9">       ├───integrationTest</strong></span>
<span class="strong"><strong class="calibre9">       │   └───java</strong></span>
<span class="strong"><strong class="calibre9">       ├───main</strong></span>
<span class="strong"><strong class="calibre9">       │   └───java</strong></span>
<span class="strong"><strong class="calibre9">       └───test</strong></span>
<span class="strong"><strong class="calibre9">           └───java</strong></span>
</pre></div><p class="calibre8">Once you have <a id="id240" class="calibre1"/>created the directory structure, you need to configure this in your Gradle build script. The updated build script would be as follows:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
sourceSets {
   integrationTest {
       java.srcDir file('src/integrationTest/java')
       resources.srcDir file('src/integrationTest/resources') // to add the resources
   }
}

task runIntegrationTest(type: Test) {
   testClassesDir = sourceSets.integrationTest.output.classesDir
   classpath = sourceSets.integrationTest.runtimeClasspath
}</pre></div><p class="calibre8">Here, we have added one extra configuration, <code class="literal">integrationTest</code>, to add the integration test cases. To execute the integration tests, we have also defined one task, <code class="literal">runIntegrationTest</code>, which is of type <code class="literal">Test</code> and configured the <code class="literal">testClassesDir</code> and classpath attributes. Once we have added additional <code class="literal">sourceSets</code> to the build script, the <code class="literal">java</code> plugin automatically adds two new dependency configurations to your build script <code class="literal">integrationTestCompile</code> and <code class="literal">integrationTestRuntime</code>.</p><p class="calibre8">Execute the following command to check for the current dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle dependencies</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre9">Root project</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre9">……...</strong></span>
<span class="strong"><strong class="calibre9">compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong class="calibre9">No dependencies</strong></span>
<span class="strong"><strong class="calibre9">integrationTestCompile - Compile classpath for source set 'integration test'.</strong></span>
<span class="strong"><strong class="calibre9">No dependencies</strong></span>
<span class="strong"><strong class="calibre9">integrationTestRuntime - Runtime classpath for source set 'integration test'.</strong></span>
<span class="strong"><strong class="calibre9">No dependencies</strong></span>
<span class="strong"><strong class="calibre9">……….</strong></span>
<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong class="calibre9">Total time: 3.34 secs</strong></span>
</pre></div><p class="calibre8">Here, <code class="literal">integrationTestCompile</code> can be used to configure dependencies required to compile<a id="id241" class="calibre1"/> the test cases and <code class="literal">integrationTestRuntime</code> can be used to configure dependencies required to execute the test cases. As you can see, no dependencies are explicitly configured for integration test cases. You can configure them under dependencies closure:</p><div class="informalexample"><pre class="programlisting">dependencies {
// other configuration dependencies 
integrationTestCompile 'org.hibernate:hibernate:3.2.3.ga'
}</pre></div><p class="calibre8">We do not want to execute the integration tests each time we build the project. Thus, to execute the integration test, you need to explicitly execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle runIntegrationTest</strong></span>
</pre></div><p class="calibre8">This will invoke the <code class="literal">runIntegrationTest</code> task and will execute the integration test cases. If you want to execute these test cases each time you build your code, you can link this task with other tasks using <code class="literal">dependsOn</code> or any other dependency attributes.</p></div>
<div class="book" title="Code coverage" id="1CQAE1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec40" class="calibre1"/>Code coverage</h1></div></div></div><p class="calibre8">There are <a id="id242" class="calibre1"/>so many coverage tools available for source code analysis such as EMMA, Corbatura, JaCoCo, and so on. In this section, we'll cover Gradle integration with JaCoCo to find the source code analysis.</p><p class="calibre8">Before we get started, we need to understand what code coverage is and why it is important in the test-driven development.</p><p class="calibre8">Code coverage is a metric that we can use to check how much of the source code was tested. Higher code coverage means a greater percentage of our code has been tested. Code coverage is typically done in the unit testing cycle. During code coverage, a developer must ensure that different logical paths in the source code have been tested and verified to achieve better code coverage.</p><p class="calibre8">Here, it is important to understand that the code coverage is not directly related to code quality. High code coverage does not guarantee that the quality code has been written. A developer must use static code analysis tools such as <a id="id243" class="calibre1"/>PMD (<a class="calibre1" href="https://pmd.github.io/">https://pmd.github.io/</a>) to find the quality of the code. Another point to remember is that, even with 100 percent of code coverage, there is no guarantee that a complete bug-free code has been written. Thus, many developers argue that this not a right metric to be considered for the code quality or unit test. However, 70-80 percent code coverage is considered to be a good number for healthy code coverage.</p><p class="calibre8">In Gradle, the code coverage tool, JaCoCo, can be applied to a project like any other plugin:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'jacoco'</pre></div><p class="calibre8">Our <code class="literal">build.gradle</code> file has the following content. We have created a few TestNG test cases to test the<a id="id244" class="calibre1"/> functionalities of the source code. We have also configured a test task to be dependent on the <code class="literal">jacocoTestReport</code> task. This is to make sure that test cases are executed before running and creating the test coverage reports:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'jacoco'

repositories {
  mavenCentral()
}

dependencies {
  testCompile 'org.testng:testng:6.8.8'
}

test{
    systemProperty "url",System.properties['url']
    useTestNG()
}

jacocoTestReport.dependsOn test</pre></div><p class="calibre8">By default, the report will be created in the <code class="literal">&lt;build dir&gt;/reports/jacoco/test/html directory</code> and an HTML report file will be generated. For example, we have created a simple POJO <code class="literal">User.java</code> file with the getter and setter methods. Also, we have created a few unit test cases to verify the functionalities. The two sample test cases are as follows:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void userEmailTest() {
    User user1 = new User("User2", "User2 user2", "user2@abc.com");
    Assert.assertEquals(user1.getEmail(), "user2@abc.com");
  }
  
  @Test
  public void userIdTest() {
    User user1 = new User();
    user1.setUserId("User3");
    user1.setName("User3 user3");
    user1.setEmail("user3@abc.com");
    Assert.assertEquals(user1.getName(), "User3 user3");
    Assert.assertEquals(user1.getUserId(), "User3");
  }</pre></div><p class="calibre8">Next, we <a id="id245" class="calibre1"/>can execute the <code class="literal">jacocoTestReport</code> task to generate the code coverage report:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle clean jacocoTestReport</strong></span>
<span class="strong"><strong class="calibre9">:clean</strong></span>
<span class="strong"><strong class="calibre9">:compileJava</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:compileTestJava</strong></span>
<span class="strong"><strong class="calibre9">:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:testClasses</strong></span>
<span class="strong"><strong class="calibre9">:test</strong></span>
<span class="strong"><strong class="calibre9">:jacocoTestReport</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 7.433 secs</strong></span>
</pre></div><p class="calibre8">In the coverage report, you can observe that all the methods of the Java class were tested unit tests. You can further drill down following the links in the report that shows the line coverage on the source code. The source code is marked in green and red to display what is covered and what is not tested. The following figure (<span class="strong"><em class="calibre10">Figure 7.2</em></span>) shows the code coverage statistics for the <code class="literal">User.java</code> class:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Code coverage" class="calibre11"/><div class="caption"><p class="calibre26">Figure 7.2</p></div></div><p class="calibre12"> </p><p class="calibre8">By default, an HTML report file is generated in the <code class="literal">build/reports/jacoco/test/html</code> directory. Also, the default version of the <code class="literal">jacoco</code> plugin can be <a id="id246" class="calibre1"/>modified by modifying the <code class="literal">jacoco</code> extension as follows:</p><div class="informalexample"><pre class="programlisting">jacoco {
    toolVersion = "&lt;Required-Version&gt;"
    reportsDir = file("Path_to_Jacoco_ReportDir")
}</pre></div><p class="calibre8">Similarly, the report can be customized by configuring the <code class="literal">jacocoTestReport</code> task as follows:</p><div class="informalexample"><pre class="programlisting">jacocoTestReport {
    reports {
        xml.enabled false
        html.destination "&lt;Path_to_dircectory&gt;"
    }
}</pre></div></div>
<div class="book" title="Code analysis reports"><div class="book" id="1DOR02-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec41" class="calibre1"/>Code analysis reports</h1></div></div></div><p class="calibre8">Sonar is one of <a id="id247" class="calibre1"/>the most popular quality management tools that gives a complete analysis of a project in terms of lines of code, documentation, test coverage, issues, and complexities. As a developer, we are mainly interested in the following areas:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Duplicate lines of code</li><li class="listitem">Lacking comments in the source code, especially in public APIs</li><li class="listitem">Not following coding standards and best practices</li><li class="listitem">Finding code complexity</li><li class="listitem">Code coverage produced by unit tests</li></ul></div><p class="calibre8">In this section, we will discuss Gradle integration with Sonar. The only prerequisite is, the Sonar server should be installed and running.</p><p class="calibre8">A prerequisite to run Sonar is to have Java installed on the box. Once prerequisites are met, you can install Sonar in just three simple steps as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Download the<a id="id248" class="calibre1"/> distribution from <a class="calibre1" href="http://www.sonarqube.org/downloads/">http://www.sonarqube.org/downloads/</a> and unzip it.</li><li class="listitem" value="2">Open a console and start the Sonar server:<div class="book"><ul class="itemizedlist1"><li class="listitem">On Windows platforms, start <code class="literal">$SONAR_HOME\bin\windows-x86-32\StartSonar.bat</code></li><li class="listitem">On other platforms, start <code class="literal">$SONAR_HOME/bin/[OS]/sonar.sh</code></li></ul></div></li><li class="listitem" value="3">Go to <code class="literal">http://localhost:9000</code>.</li></ol><div class="calibre15"/></div><p class="calibre8">To run <code class="literal">sonar-runner</code> plugin, we just need to apply the plugin <code class="literal">sonar-runner</code> and configure it to connect to the Sonar server.</p><p class="calibre8">Create the<a id="id249" class="calibre1"/> build file <code class="literal">build.gradle</code> for your project with the following contents:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'groovy'
apply plugin: "sonar-runner"

repositories {
    mavenCentral()
}

version = '1.0'
repositories {
    mavenCentral()
}

sonarRunner {
  sonarProperties {
    property "sonar.host.url", "http://&lt;IP_ADDRESS&gt;:&lt;PORT&gt;"
    property "sonar.jdbc.url",
    "jdbc:h2:tcp://&lt;IP_ADDRESS&gt;:&lt;PORT&gt;/sonar"
    property "sonar.jdbc.driverClassName", "org.h2.Driver"
    property "sonar.jdbc.username", "sonar"
    property "sonar.jdbc.password", "sonar"
  }
}</pre></div><p class="calibre8">The above configuration is self-explanatory. You need to add configurations such as Sonar URL, DB URL, and JDBC driver details, and our build file is ready.</p><p class="calibre8">The next step is to run the <code class="literal">sonarRunner</code> task for code analysis. After successful execution of this task, you will find the report hosted on the Sonar server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt;gradle clean sonarRunner</strong></span>
<span class="strong"><strong class="calibre9">:clean</strong></span>
<span class="strong"><strong class="calibre9">:compileJava</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:compileTestJava</strong></span>
<span class="strong"><strong class="calibre9">:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:testClasses</strong></span>
<span class="strong"><strong class="calibre9">:test</strong></span>
<span class="strong"><strong class="calibre9">:sonarRunner</strong></span>
<span class="strong"><strong class="calibre9">SonarQube Runner 2.3</strong></span>
<span class="strong"><strong class="calibre9">Java 1.7.0_51 Oracle Corporation (64-bit)</strong></span>
<span class="strong"><strong class="calibre9">Windows 7 6.1 amd64</strong></span>
<span class="strong"><strong class="calibre9">INFO: Runner configuration file: NONE</strong></span>
<span class="strong"><strong class="calibre9">INFO: Project configuration file: &lt;Project_Home&gt;\UserService\build\tmp\sonarRunner\sonar-project.properties</strong></span>
<span class="strong"><strong class="calibre9">INFO: Default locale: "en_IN", source code encoding: "windows-1252" (analysis is platform dependent)</strong></span>
<span class="strong"><strong class="calibre9">INFO: Work directory: &lt;Project_Home&gt;\UserService\build\sonar</strong></span>
<span class="strong"><strong class="calibre9">INFO: SonarQube Server 3.7.4</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">Now, you <a id="id250" class="calibre1"/>can open <code class="literal">http://localhost:9000/</code> to browse the projects. This page is the default dashboard page, which shows the details of all the projects. You can find your project and browse through the details. The details will be displayed as follows:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Code analysis reports" class="calibre11"/><div class="caption"><p class="calibre26">Figure 7.3</p></div></div><p class="calibre12"> </p><p class="calibre8">You can again further verify the details of each metric, just by following the links provided in the project home page. For example, the following figure displays the source code-related metrics in the Sonar. It provides details such as code complexity, lines of code, methods, documentation, and so on:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Code analysis reports" class="calibre11"/><div class="caption"><p class="calibre26">Figure 7.4</p></div></div><p class="calibre12"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre8">You can find more on <a id="id251" class="calibre1"/>Sonar at <a class="calibre1" href="http://docs.sonarqube.org/display/SONAR/Documentation/">http://docs.sonarqube.org/display/SONAR/Documentation/</a>.</p></div></div>
<div class="book" title="Summary" id="1ENBI1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec42" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we discussed the testing and reporting aspects of Gradle. We started our discussion with TestNG and also discussed how we can configure Gradle to support the integration test cases separate from unit test cases. Then, we discussed code coverage with JaCoCo and, finally, we talked about Sonar integration with Gradle.</p><p class="calibre8">In the next chapter, we will discuss how to organize the build logic in build scripts and plugins. We'll explore how to modularize plugin code so that it can be shared across multi-project Gradle build. We'll also explore how to create a custom plugin in Gradle.</p></div></body></html>