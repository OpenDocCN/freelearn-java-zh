<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Defining Dependencies" id="aid-DB7S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Defining Dependencies</h1></div></div></div><p>When we develop software, we need to write code. Our code consists of packages with classes, and those can be dependent on the other classes and packages in our project. This is fine for one project, but we sometimes depend on classes in other projects we didn't develop ourselves, for example, we might want to use classes from an Apache Commons library or we might be working on a project that is part of a bigger, multi-project application and we are dependent on classes in these other projects.</p><p>Most of the time, when we write software, we want to use classes outside of our project. Actually, we have a dependency on those classes. Those dependent classes are mostly stored in archive files, such <a id="id0" class="indexterm"/>as <span class="strong"><strong>Java Archive</strong></span> (<span class="strong"><strong>JAR</strong></span>) files. Such archive files are identified by a unique version number, so we can have a dependency on the library with a specific version.</p><p>In this chapter, you are going to learn how to define dependencies in your Gradle project. We will see how we can define the configurations of dependencies. You will learn about the different dependency types in Gradle and how to use them when you configure your build.</p><div class="section" title="Declaring dependency configurations"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Declaring dependency configurations</h1></div></div></div><p>In Gradle, we <a id="id1" class="indexterm"/>define dependency configurations to group dependencies together. A dependency configuration has a name and several properties, such as a description and is actually a special type of <code class="literal">FileCollection</code>. Configurations can extend from each other, so we can build a hierarchy of configurations in our build files. Gradle plugins can also add new configurations to our project, for example, the Java plugin adds several new configurations, such as <code class="literal">compile</code> and <code class="literal">testRuntime</code>, to our project. The <code class="literal">compile</code> configuration is then used to define the dependencies that are needed to compile our source tree. The dependency configurations are defined with a <code class="literal">configurations</code> configuration block. Inside the block, we can define new configurations for our build. All configurations are added to the project's <code class="literal">ConfigurationContainer</code> object.</p><p>In the following example build file, we define two new configurations, where the <code class="literal">traffic</code> configuration extends from the <code class="literal">vehicles</code> configuration. This means that any dependency added to the <code class="literal">vehicles</code> configuration is also available in the <code class="literal">traffic</code> configuration. We can also assign a <code class="literal">description</code> property to our configuration to provide some more <a id="id2" class="indexterm"/>information about the configuration for documentation purposes. The following code shows this:</p><div class="informalexample"><pre class="programlisting">// Define new configurations for build.
configurations {

  // Define configuration vehicles.
  vehicles {
    description = 'Contains vehicle dependencies'
  }

  traffic {
    extendsFrom vehicles
    description = 'Contains traffic dependencies'
  }

}</pre></div><p>To see which configurations are available in a project, we can execute the <code class="literal">dependencies</code> task. This task is available for each Gradle project. The task outputs all the configurations and dependencies of a project. Let's run this task for our current project and check the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>traffic - Contains traffic dependencies</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>vehicles - Contains vehicle dependencies</strong></span>
<span class="strong"><strong>No dependencies</strong></span>
</pre></div><p>Note that we can see our two configurations, <code class="literal">traffic</code> and <code class="literal">vehicles</code>, in the output. We have not defined any dependencies to these configurations, as shown in the output.</p><p>The Java plugin adds a couple of configurations to a project, which are used by the tasks from the Java plugin. Let's add the Java plugin to our Gradle build file:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'</pre></div><p>To see which configurations are added, we invoke the <code class="literal">dependencies</code> task and look at the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>archives - Configuration for archive artifacts.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>default - Configuration for default artifacts.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>testCompile - Compile classpath for source set 'test'.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>testRuntime - Runtime classpath for source set 'test'.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>
</pre></div><p>We see six configurations in our project just by adding the Java plugin. The <code class="literal">archives</code> configuration is used to <a id="id3" class="indexterm"/>group the artifacts our project creates. The other configurations are used to group the dependencies for our project. In the following table, the dependency configurations are summarized:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Name</p>
</th><th valign="bottom">
<p>Extends</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>compile</p>
</td><td valign="top">
<p>none</p>
</td><td valign="top">
<p>These are dependencies to compile.</p>
</td></tr><tr><td valign="top">
<p>runtime</p>
</td><td valign="top">
<p>compile</p>
</td><td valign="top">
<p>These are runtime dependencies.</p>
</td></tr><tr><td valign="top">
<p>testCompile</p>
</td><td valign="top">
<p>compile</p>
</td><td valign="top">
<p>These are extra dependencies to compile tests.</p>
</td></tr><tr><td valign="top">
<p>testRuntime</p>
</td><td valign="top">
<p>runtime, testCompile</p>
</td><td valign="top">
<p>These are extra dependencies to run tests.</p>
</td></tr><tr><td valign="top">
<p>default</p>
</td><td valign="top">
<p>runtime</p>
</td><td valign="top">
<p>These are dependencies used by this project and artifacts created by this project.</p>
</td></tr></tbody></table></div><p>Later in the chapter, we will see how we can work with the dependencies assigned to the configurations. In the next <a id="id4" class="indexterm"/>section, we will learn how to declare our project's dependencies.</p></div></div>
<div class="section" title="Declaring dependencies"><div class="titlepage" id="aid-E9OE2"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Declaring dependencies</h1></div></div></div><p>We defined <a id="id5" class="indexterm"/>configurations or applied a plugin that added new configurations to our project. However, a configuration is empty unless we add dependencies to the configuration. To declare dependencies in our Gradle build file, we must add the <code class="literal">dependencies</code> configuration block. The configuration block will contain the definition of our dependencies. In the following example Gradle build file, we define the <code class="literal">dependencies</code> block:</p><div class="informalexample"><pre class="programlisting">// Dependencies configuration block.
dependencies {
    // Here we define our dependencies.
}</pre></div><p>Inside the configuration block, we use the name of a dependency configuration followed by the description of our dependencies. The name of the dependency configuration can be defined explicitly in the build file or can be added by a plugin we use. In Gradle, we can define several types of dependencies. In the following table, we will see the different types we can use:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Dependency <a id="id6" class="indexterm"/>type</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>External module <a id="id7" class="indexterm"/>dependency</p>
</td><td valign="top">
<p>This is a dependency on an external module or library that is probably stored in a repository.</p>
</td></tr><tr><td valign="top">
<p>Client module <a id="id8" class="indexterm"/>dependency</p>
</td><td valign="top">
<p>This is a dependency on an external module where the artifacts are stored in a repository, but the meta information about the module is in the build file. We can override meta information using this type of dependency.</p>
</td></tr><tr><td valign="top">
<p>Project <a id="id9" class="indexterm"/>dependency</p>
</td><td valign="top">
<p>This is a dependency on another Gradle project in the same build.</p>
</td></tr><tr><td valign="top">
<p>File <a id="id10" class="indexterm"/>dependency</p>
</td><td valign="top">
<p>This is a dependency on a collection of files on the local computer.</p>
</td></tr><tr><td valign="top">
<p>Gradle API <a id="id11" class="indexterm"/>dependency</p>
</td><td valign="top">
<p>This is a dependency on the Gradle API of the current Gradle version. We use this dependency when we develop Gradle plugins and tasks.</p>
</td></tr><tr><td valign="top">
<p>Local Groovy <a id="id12" class="indexterm"/>dependency</p>
</td><td valign="top">
<p>This is a <a id="id13" class="indexterm"/>dependency on the Groovy libraries used by the current Gradle version. We use this dependency when we develop Gradle plugins and tasks.</p>
</td></tr></tbody></table></div><div class="section" title="External module dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>External module dependencies</h2></div></div></div><p>External module <a id="id14" class="indexterm"/>dependencies are the most common dependencies in projects. These dependencies refer to a module in an external <a id="id15" class="indexterm"/>repository. Later in the book, we will find out more about repositories, but basically, a repository stores modules in a central location. A module contains one or more artifacts and meta information, such as references to the other modules it depends on.</p><p>We can use two notations to define an external module dependency in Gradle. We can use a string notation or a map notation. With the map notation, we can use all the properties available for a dependency. The string notation allows us to set a subset of the properties but with a very concise syntax.</p><p>In the following example Gradle build file, we define several dependencies using the string notation:</p><div class="informalexample"><pre class="programlisting">// Define dependencies.
dependencies {
  // Defining two dependencies.
  vehicles 'com.vehicles:car:1.0', 'com.vehicles:truck:2.0'

  // Single dependency.
  traffic 'com.traffic:pedestrian:1.0'
}</pre></div><p>The string notation has the following format: <span class="strong"><strong>moduleGroup:moduleName:version</strong></span>. Before the first colon, the module group name is used, followed by the module name, and the version is mentioned last.</p><p>If we use the map notation, we use the names of the attributes explicitly and set the value for each attribute. Let's rewrite our previous example build file and use the map notation:</p><div class="informalexample"><pre class="programlisting">// Compact definition of configurations.
configurations {
  vehicles
  traffic.extendsFrom vehicles
}

// Define dependencies.
dependencies {
  // Defining two dependencies.
  vehicles(
    [group: 'com.vehicles', name: 'car', version: '1.0'],
    [group: 'com.vehicles', name: 'truck', version: '2.0'],
  )

  // Single dependency.
  traffic group: 'com.traffic', name: 'pedestrian', version: '1.0'
}</pre></div><p>We can specify extra configuration attributes with the map notation, or we can add an extra configuration closure. One of the attributes of an external module dependency is the <code class="literal">transitive</code> <a id="id16" class="indexterm"/>attribute. We learn more about how to work with transitive dependencies in <a class="link" title="Chapter 3. Resolving Dependencies" href="part0024.xhtml#aid-MSDG2">Chapter 3</a>, <span class="emphasis"><em>Resolving Dependencies</em></span>. In <a id="id17" class="indexterm"/>the next example build file, we will set this attribute using the map notation and a configuration closure:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // Use transitive attribute in map notation.
  vehicles group: 'com.vehicles', name: 'car',
      version: '1.0', transitive: false

  // Combine map notation with configuration closure.
  vehicles(group: 'com.vehicles', name: 'car', version: '1.0') {
    transitive = true
  }

  // Combine string notation with configuration closure.
  traffic('com.traffic:pedestrian:1.0') {
    transitive = false
  }
}</pre></div><p>In the rest of this section, you will learn about more attributes you can use to configure a dependency.</p><p>Once of the advantages of Gradle is that we can write Groovy code in our build file. This means that we can define methods and variables and use them in other parts of our Gradle file. This way, we can even apply refactoring to our build file and make maintainable build scripts. Note that in our examples, we included multiple dependencies with the <code class="literal">com.vehicles</code> group name. The value is defined twice, but we can also create a new variable with the group name and reference of the variable in the dependencies configuration. We define a variable in our build file inside an <code class="literal">ext</code> configuration block. We use the <code class="literal">ext</code> block in Gradle to add extra properties to an object, such as our project.</p><p>The following sample code defines an extra variable to hold the group name:</p><div class="informalexample"><pre class="programlisting">// Define project property with
// dependency group name 'com.vehicles'
ext {
  groupNameVehicles = 'com.vehicles'
}

dependencies {
  // Using Groovy string support with
  // variable substition.
  vehicles "$groupNameVehicles:car:1.0"

  // Using map notation and reference
  // property groupNameVehicles.
  vehicles group: groupNameVehicles, name: 'truck', version: '2.0'
}</pre></div><p>If we define an external module dependency, then Gradle tries to find a module descriptor in a repository. If the module descriptor is available, it is parsed to see which artifacts need to be downloaded. Also, if the module descriptor contains information about the dependencies <a id="id18" class="indexterm"/>needed by the module, those dependencies are downloaded as well. Sometimes, a dependency has no descriptor in the repository, and it is only then that Gradle downloads the artifact for that dependency.</p><p>A dependency based on a Maven module only contains one artifact, so it is easy for Gradle to know <a id="id19" class="indexterm"/>which artifact to download. But for a Gradle or Ivy module, it is not so obvious, because a module can contain multiple artifacts. The module will have multiple configurations, each with different artifacts. Gradle will use the configuration with the name <code class="literal">default</code> for such modules. So, any artifacts and dependencies associated with the <code class="literal">default</code> configuration are downloaded. However, it is possible that the <code class="literal">default</code> configuration doesn't contain the artifacts we need. We, therefore, can specify the <code class="literal">configuration</code> attribute for the dependency configuration to specify a specific configuration that we need.</p><p>The following example defines a <code class="literal">configuration</code> attribute for the dependency configuration:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // Use the 'jar' configuration defined in the
  // module descriptor for this dependency.
  traffic group: 'com.traffic', 
      name: 'pedestrian', 
      version: '1.0',
      configuration: 'jar'

}</pre></div><p>When there is no module descriptor for a dependency, only the artifact is downloaded by Gradle. We can use an artifact-only notation if we only want to download the artifact for a module with a descriptor and not any dependencies. Or, if we want to download another archive file, such as a TAR file, with documentation, from a repository.</p><p>To use the artifact-only notation, we must add the file extension to the dependency definition. If we use the string notation, we must add the extension prefixed with an <code class="literal">@</code> sign after the version. With the map notation, we can use the <code class="literal">ext</code> attribute to set the extension. If we define <a id="id20" class="indexterm"/>our dependency as artifact-only, Gradle will not check whether there is a module descriptor available for the <a id="id21" class="indexterm"/>dependency. In the next build file, we will see examples of the different artifact-only notations:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // Using the @ext notation to specify
  // we only want the artifact for this
  // dependency.
  vehicles 'com.vehicles:car:2.0@jar'

  // Use map notation with ext attribute
  // to specify artifact only dependency.
  traffic group: 'com.traffic', name: 'pedestrian',
      version: '1.0', ext: 'jar'

  // Alternatively we can use the configuration closure.
  // We need to specify an artifact configuration closure
  // as well to define the ext attribute.
  vehicles('com.vehicles:car:2.0') {
    artifact {
      name = 'car-docs'
      type = 'tar'
      extension = 'tar'
    }
  }
}</pre></div><p>A Maven module descriptor can use classifiers for the artifact. This is mostly used when a library with the same code is compiled for different Java versions, for example, a library is compiled for Java 5 and Java 6 with the <code class="literal">jdk15</code> and <code class="literal">jdk16</code> classifiers. We can use the <code class="literal">classifier</code> attribute when we define an external module dependency to specify which classifier we want to use. Also, we can use it in a string or map notation. With the string notation, we add an extra colon after the version attribute and specify the classifier. For the map notation, we can add the <code class="literal">classifier</code> attribute and specify the value we want. The following build file contains an example of the different definitions of a dependency with a classifier:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // Using string notation we can
  // append the classifier after
  // the version attribute, prefixed
  // with a colon.
  vehicles 'com.vehicles:car:2.0:jdk15'

  // With the map notation we simply use the
  // classifier attribute name and the value.
  traffic group: 'com.traffic', name: 'pedestrian',
      version: '1.0', classifier: 'jdk16'

  // Alternatively we can use the configuration closure.
  // We need to specify an artifact configuration closure
  // as well to define the classifier attribute.
  vehicles('com.vehicles:truck:2.0') {
    artifact {
      name = 'truck'
      type = 'jar'
      classifier = 'jdk15'
    }
  }
}</pre></div><p>In the following section, we <a id="id22" class="indexterm"/>will see how we can define <a id="id23" class="indexterm"/>client module dependencies in our build file.</p></div><div class="section" title="Defining client module dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Defining client module dependencies</h2></div></div></div><p>When we define external module dependencies, we expect that there is a module descriptor file with information about the artifacts and dependencies for those artifacts. Gradle will <a id="id24" class="indexterm"/>parse this file and determine <a id="id25" class="indexterm"/>what needs to be downloaded. Remember that if such a file is not available on the artifact, it will be downloaded. However, what if we want to override the module descriptor or provide one if it is not available? In the module descriptor that we provide, we can define the dependencies of the module ourselves.</p><p>We can do this in Gradle with client module dependencies. Instead of relying on a module descriptor in a repository, we define our own module descriptor locally in the build file. We now have full control over what we think the module should look like and which dependencies the module itself has. We use the <code class="literal">module</code> method to define a client module dependency for a dependency configuration.</p><p>In the following <a id="id26" class="indexterm"/>example build file, we will write a client module dependency for the dependency car, and we will add a transitive dependency to the driver:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // We use the module method to instruct
  // Gradle to not look for the module descriptor
  // in a repository, but use the one we have
  // defined in the build file.
  vehicles module('com.vehicles:car:2.0') {
    // Car depends on driver.
    dependency('com.traffic:driver:1.0')
  }
}</pre></div></div><div class="section" title="Using project dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Using project dependencies</h2></div></div></div><p>Projects can be <a id="id27" class="indexterm"/>part of a bigger, multi-project build, and the projects can be dependent on each other, for example, one project can be made dependent on the generated artifact of another project, including the transitive dependencies of the other project. To define such a dependency, we use the <code class="literal">project</code> method in our <a id="id28" class="indexterm"/>dependencies configuration block. We specify the name of the project as an argument. We can also define the name of a dependency configuration of the other project we depend on. By default, Gradle will look for the default dependency configuration, but with the <code class="literal">configuration</code> attribute, we can specify a specific dependency configuration to be used.</p><p>The next example build file will define project dependencies on the <code class="literal">car</code> and <code class="literal">truck</code> projects:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // Use project method to define project
  // dependency on car project.
  vehicles project(':car')

  // Define project dependency on truck
  // and use dependency configuration api
  // from that project.
  vehicles project(':truck') {
    configuration = 'api'
  }

  // We can use alternative syntax
  // to specify a configuration.
  traffic project(path: ':pedestrian',
          configuration: 'lib')
}</pre></div></div><div class="section" title="Defining file dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Defining file dependencies</h2></div></div></div><p>We can directly add <a id="id29" class="indexterm"/>files to a dependency configuration in Gradle. The files don't need to be stored in a repository but must be accessible from the project directory. Although most projects will have module descriptors stored in a <a id="id30" class="indexterm"/>repository, it is possible that a legacy project might have a dependency on files available on a shared network drive in the company. Otherwise, we must use a library in our project, which is simply not available in any repository. To add file dependencies to our dependency configuration, we specify a file collection with the <code class="literal">files</code> and <code class="literal">fileTree</code> methods. The following example build file shows the usage of all these methods:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // Define a dependency on explicit file(s).
  vehicles files(
    'lib/vehicles/car-2.0.jar',
    'lib/vehicles/truck-1.0.jar'
  )

  // We can use the fileTree method to include
  // multiples from a directory and it's subdirectories.
  traffic fileTree(dir: 'deps', include: '*.jar')
}</pre></div><p>The added files will not be part of the transitive dependencies of our project if we publish our project's artifacts to a repository, but they are if our project is part of a multi-project build.</p></div><div class="section" title="Using internal Gradle and Groovy dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Using internal Gradle and Groovy dependencies</h2></div></div></div><p>When we write code <a id="id31" class="indexterm"/>to extend Gradle, such as custom <a id="id32" class="indexterm"/>tasks or plugins, we can have a dependency on the Gradle API and possibly the Groovy libraries used by the current Gradle version. We can use the <code class="literal">gradleApi</code> and <code class="literal">localGroovy</code> methods in our dependency configuration to have all the right dependencies.</p><p>If we are writing some <a id="id33" class="indexterm"/>Groovy code to extend Gradle, but we don't use any of the Gradle API classes, we can use <code class="literal">localGroovy</code>. With this method, the classes and libraries of the Groovy version shipped with the current Gradle version are added as dependencies. The following example build script uses the Groovy plugin and adds a dependency to the <code class="literal">compile</code> configuration on Groovy bundled with Gradle:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'groovy'

dependencies {
  // Define dependency on Groovy
  // version shipped with Gradle.
  compile localGroovy()
}</pre></div><p>When we write <a id="id34" class="indexterm"/>custom tasks or plugins for Gradle, we <a id="id35" class="indexterm"/>are dependent on the Gradle API. We need to <a id="id36" class="indexterm"/>import some of the API's classes in order to write our code. To define a dependency on the Gradle classes, we use the <code class="literal">gradleApi</code> method. This will include the dependencies for the Gradle version the build is executed for. The next example build file will show the use of this method:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'groovy'

dependencies {
  // Define dependency on Gradle classes.
  compile gradleApi()
}</pre></div></div></div>
<div class="section" title="Using dynamic versions" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Using dynamic versions</h1></div></div></div><p>Until now, we <a id="id37" class="indexterm"/>have set a version for a dependency explicitly with a complete version number. To set a minimum version number, we can use a special dynamic version syntax, for example, to set the dependency version to a minimum of 2.1 for a dependency, we use a version value of 2.1.+. Gradle will resolve the dependency to the latest version after version 2.1.0, or to version 2.1 itself. The upper bound is 2.2. In the following example, we will define a dependency on a spring-context version of at least 4.0.x:</p><div class="informalexample"><pre class="programlisting">dependencies {
  compile 'org.springframework:spring-context:4.0.+'
}</pre></div><p>To reference the latest released version of a module, we can use <code class="literal">latest.integration</code> as the version value. We can also set the minimum and maximum version numbers we want. The following table shows the ranges we can use in Gradle:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Range</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">[1.0, 2.0]</code>
</p>
</td><td valign="top">
<p>We can use all versions greater than or equal to 1.0 and lower than or equal to 2.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">[1.0, 2.0[</code>
</p>
</td><td valign="top">
<p>We can use all versions greater than or equal to 1.0 and lower than 2.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">]1.0, 2.0]</code>
</p>
</td><td valign="top">
<p>We can use all versions greater than 1.0 and lower than or equal to 2.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">]1.0, 2.0[</code>
</p>
</td><td valign="top">
<p>We can use all versions greater than 1.0 and lower than 2.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">[1.0, )</code>
</p>
</td><td valign="top">
<p>We can use all versions greater than or equal to 1.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">]1.0, )</code>
</p>
</td><td valign="top">
<p>We can use all versions greater than 1.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">(, 2.0]</code>
</p>
</td><td valign="top">
<p>We can use all versions lower than or equal to 2.0</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">(, 2.0[</code>
</p>
</td><td valign="top">
<p>We can use all versions lower than 2.0</p>
</td></tr></tbody></table></div><p>In the following <a id="id38" class="indexterm"/>example build file, we will set the version for the spring-context module to greater than <code class="literal">4.0.1.RELEASE</code> and lower than <code class="literal">4.0.4.RELEASE</code>:</p><div class="informalexample"><pre class="programlisting">dependencies {
  // The dependency will resolve to version 4.0.3.RELEASE as
  // the latest version if available. Otherwise 4.0.2.RELEASE
  // or 4.0.1.RELEASE.
  compile 'org.springframework:spring-context:[4.0.1.RELEASE,4.0.4.RELEASE['
}</pre></div></div>
<div class="section" title="Getting information about dependencies"><div class="titlepage" id="aid-G6PI2"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting information about dependencies</h1></div></div></div><p>We have seen how we <a id="id39" class="indexterm"/>can define dependencies in our build scripts. To get more information about our dependencies, we can use the <code class="literal">dependencies</code> task. When we invoke the task, we can see which dependencies belong to the available configurations of our project. Also, any transitive dependencies are shown. The next example build file defines a dependency on Spring beans and we apply the Java plugin. We also specify a repository in the <code class="literal">repositories</code> configuration block. We will learn more about repositories in the next chapter. The following code captures the discussion in this paragraph:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories {
  // Repository definition for JCenter Bintray.
  // Needed to download artifacts. Repository
  // definitions are covered later.
  jcenter()
}

dependencies {
  // Define dependency on spring-beans library.
  compile 'org.springframework:spring-beans:4.0.+'
}</pre></div><p>When we execute the <code class="literal">dependencies</code> task, we get the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>archives - Configuration for archive artifacts.</strong></span>
<span class="strong"><strong>No dependencies</strong></span>

<span class="strong"><strong>compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>          \--- commons-logging:commons-logging:1.1.3</strong></span>

<span class="strong"><strong>default - Configuration for default artifacts.</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>          \--- commons-logging:commons-logging:1.1.3</strong></span>

<span class="strong"><strong>runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>          \--- commons-logging:commons-logging:1.1.3</strong></span>

<span class="strong"><strong>testCompile - Compile classpath for source set 'test'.</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>          \--- commons-logging:commons-logging:1.1.3</strong></span>

<span class="strong"><strong>testRuntime - Runtime classpath for source set 'test'.</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>          \--- commons-logging:commons-logging:1.1.3</strong></span>
</pre></div><p>We see all the configurations of our project, and for each configuration, we see the defined dependency with the transitive dependencies. Also, we can see how our dynamic version <code class="literal">4.0.+</code> is resolved to version <code class="literal">4.0.6.RELEASE</code>. To only see dependencies for a specific configuration, we can use the <code class="literal">--configuration</code> option for the <code class="literal">dependencies</code> task. We must use the value of the configuration we want to see the dependencies for. In the following output, we see the result when we only want to see the dependencies for the compile configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencies --configuration compile</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Root project</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>

<span class="strong"><strong>compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>          \--- commons-logging:commons-logging:1.1.3</strong></span>
</pre></div><p>There is also the <code class="literal">dependencyInsight</code> incubating task in Gradle. Because it is incubating, the functionality or syntax can change in future versions of Gradle. With the <code class="literal">dependencyInsight</code> task, we can find out why a specific dependency is in our build and to which configuration it belongs. We have to use the <code class="literal">--dependency</code> option, the required one, with part of the name of the dependency. Gradle will look for dependencies where the group, name, or version <a id="id40" class="indexterm"/>contains part of the specified value for the <code class="literal">--dependency</code> option. Optionally, we can specify the <code class="literal">--configuration</code> option to only look for the dependency in the specified configuration. If we leave out this option, Gradle will look for the dependency in all the configurations of our project.</p><p>Let's invoke the <code class="literal">dependencyInsight</code> task to find the dependencies with Spring in the name and in the runtime configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q dependencyInsight --dependency spring --configuration runtime</strong></span>
<span class="strong"><strong>org.springframework:spring-beans:4.0.6.RELEASE</strong></span>

<span class="strong"><strong>org.springframework:spring-beans:4.0.+ -&gt; 4.0.6.RELEASE</strong></span>
<span class="strong"><strong>\--- runtime</strong></span>

<span class="strong"><strong>org.springframework:spring-core:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>\--- org.springframework:spring-beans:4.0.6.RELEASE</strong></span>
<span class="strong"><strong>    \--- runtime</strong></span>
</pre></div><p>In the output, we see how version <code class="literal">4.0.+</code> is resolved to <code class="literal">4.0.6.RELEASE</code>. We also see that the <code class="literal">spring-beans</code> dependency and the transitive <code class="literal">spring-core</code> dependency are part of the runtime configuration.</p><div class="section" title="Accessing dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Accessing dependencies</h2></div></div></div><p>To access the <a id="id41" class="indexterm"/>configurations, we can use the <code class="literal">configurations</code> property of the Gradle project object. The <code class="literal">configurations</code> property contains a collection of <code class="literal">Configuration</code> objects. It is good to remember that a <code class="literal">Configuration</code> object is an instance of <code class="literal">FileCollection</code>. So, we can reference <code class="literal">Configuration</code> in our build scripts where <code class="literal">FileCollection</code> is allowed. The <code class="literal">Configuration</code> object contains more properties we can use to access the dependencies belonging to the configuration.</p><p>In the next example <a id="id42" class="indexterm"/>build, we will define two tasks that work with the files and information available from configurations in the project:</p><div class="informalexample"><pre class="programlisting">configurations {
  vehicles
  traffic.extendsFrom vehicles
}

task dependencyFiles &lt;&lt; {
  // Loop through all files for the dependencies
  // for the traffic configuration, including
  // transitive dependencies.
  configurations.traffic.files.each { file -&gt;
    println file.name
  }

  // We can also filter the files using
  // a closure. For example to only find the files
  // for dependencies with driver in the name.
  configurations.vehicles.files { dep -&gt;
    if (dep.name.contains('driver')) {
      println dep.name
    }
  }

  // Get information about dependencies only belonging
  // to the vehicles configuration.
  configurations.vehicles.dependencies.each { dep -&gt;
    println "${dep.group} / ${dep.name} / ${dep.version}"
  }

  // Get information about dependencies belonging
  // to the traffice configuration and
  // configurations it extends from.
  configurations.traffic.allDependencies.each {  dep -&gt;
    println "${dep.group} / ${dep.name} / ${dep.version}"
  }
}

task copyDependencies(type: Copy) {
  description = 'Copy dependencies from configuration traffic to lib directory'

  // Configuration can be the source for a CopySpec.
  from configurations.traffic

  into "$buildDir/lib"
}</pre></div></div><div class="section" title="Buildscript dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Buildscript dependencies</h2></div></div></div><p>When we define <a id="id43" class="indexterm"/>dependencies, we mostly want to define them for the code we are developing. However, we may also want to add a dependency to the Gradle build script itself. We can write code in our build files, which might be dependent on a library that is not included in the Gradle distribution. Let's suppose we <a id="id44" class="indexterm"/>want to use a class from the Apache Commons Lang library in our build script. We must add a <code class="literal">buildscript</code> configuration closure to our build script. Within the configuration closure, we can define repositories and dependencies. We must use the special <code class="literal">classpath</code> configuration to add dependencies to. Any dependency added to the <code class="literal">classpath</code> configuration can be used by the code in our build file.</p><p>Let's see how this works with an example build file. We want to use the <code class="literal">org.apache.commons.lang3.RandomStringUtils</code> class inside a <code class="literal">randomString</code> task. This class can be found in the <code class="literal">org.apache.commons:commons-lang3</code> dependency. We define this as an external dependency for the <code class="literal">classpath</code> configuration. We also include a repository definition inside the <code class="literal">buildscript</code> configuration block so that the dependency can be downloaded. The following code shows this:</p><div class="informalexample"><pre class="programlisting">buildscript {
  repositories {
    // Bintray JCenter repository to download
    // dependency commons-lang3.
    jcenter()
  }

  dependencies {
    // Extend classpath of build script with
    // the classpath configuration.
    classpath 'org.apache.commons:commons-lang3:3.3.2'
  }
}

// We have add the commons-lang3 dependency
// as a build script dependency so we can
// reference classes for Apache Commons Lang.
import org.apache.commons.lang3.RandomStringUtils

task randomString &lt;&lt; {
  // Use RandomStringUtils from Apache Commons Lang.
  String value = RandomStringUtils.randomAlphabetic(10)
  println value
}</pre></div><p>To include external plugins, which are not part of the Gradle distribution, we can also use the <code class="literal">classpath</code> <a id="id45" class="indexterm"/>configuration in the <code class="literal">buildscript</code> <a id="id46" class="indexterm"/>configuration block. In the next example build file, we will include the <code class="literal">Asciidoctor</code> Gradle plugin:</p><div class="informalexample"><pre class="programlisting">buildscript {
  repositories {
    // We need the repository definition, from
    // where the dependency can be downloaded.
    jcenter()
  }

  dependencies {
    // Define external module dependency for the Gradle
    // Asciidoctor plugin.
    classpath 'org.asciidoctor:asciidoctor-gradle-plugin:0.7.3'
  }
}

// We defined the dependency on this external
// Gradle plugin in the buildscript {...}
// configuration block
apply plugin: 'org.asciidoctor.gradle.asciidoctor'</pre></div></div></div>
<div class="section" title="Optional Ant task dependencies" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Optional Ant task dependencies</h1></div></div></div><p>We can reuse the <a id="id47" class="indexterm"/>existing Ant tasks in Gradle. The <a id="id48" class="indexterm"/>default tasks from Ant can be invoked from within our build scripts. However, if we want to use an optional Ant task, we must define a dependency for the classes needed by the optional Ant task. We create a new dependency configuration, and then we add a dependency to this new configuration. We can reference this configuration when setting the classpath for the optional Ant task.</p><p>Let's add the optional Ant task SCP for the secure copying of files to/from a remote server. We create the <code class="literal">sshAntTask</code> configuration to add dependencies for the optional Ant task. We can choose any name for the configuration. To define the optional task, we use the <code class="literal">taskdef</code> method from the internal <code class="literal">ant</code> object. The method takes a <code class="literal">classpath</code> attribute, which must be the actual path of all files of the <code class="literal">sshAntTask</code> dependencies. The <code class="literal">Configuration</code> class <a id="id49" class="indexterm"/>provides the <code class="literal">asPath</code> property to return the path to the files in a platform-specific way. So, if we use this on a Windows computer, the file path <a id="id50" class="indexterm"/>separator is a <code class="literal">;</code> and for other platforms it is a <code class="literal">:</code>. The following example build file contains all the code to define and uses the SCP Ant task:</p><div class="informalexample"><pre class="programlisting">configurations {
  // We define a new dependency configuration.
  // This configuration is used to assign
  // dependencies to, that are needed by the
  // optional Ant task scp.
  sshAntTask
}

repositories {
  // Repository definition to download dependencies.
  jcenter()
}

dependencies {
  // Define external module dependencies
  // for the scp Ant task.
  sshAntTask(group: 'org.apache.ant', 
        name: 'ant-jsch', 
        version: '1.9.4')
}

// New task that used Ant scp task.
task copyRemote(
  description: 'Secure copy files to remote server') &lt;&lt; {

  // Define optional Ant task scp.
  ant.taskdef(
    name: 'scp',
    classname: 'org.apache.tools.ant.taskdefs.optional.ssh.Scp',

    // Set classpath based on dependencies assigned
    // to sshAntTask configuration. The asPath property
    // returns a platform-specific string value
    // with the dependency JAR files.
    classpath: configurations.sshAntTask.asPath)

  // Invoke scp task we just defined.
  ant.scp(
    todir: 'user@server:/home/user/upload',
    keyFile: '${user.home}/.ssh/id_rsa',
    passphrase: '***',
    verbose: true) {
    fileset(dir: 'html/files') {
      include name: '**/**'
    }
  }
}</pre></div></div>
<div class="section" title="Managing dependencies" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Managing dependencies</h1></div></div></div><p>You have already <a id="id51" class="indexterm"/>learned earlier in the chapter that we can refactor the dependency definitions by extracting common parts into project properties. This way, we only have to change a few project property values to make changes to multiple dependencies. In the next example build file, we will use lists to group dependencies together and reference those lists from the dependency definition:</p><div class="informalexample"><pre class="programlisting">ext {
  // Group is used multiple times, so
  // we extra the variable for re-use.
  def vehiclesGroup = 'com.vehicles'

  // libs will be available from within
  // the Gradle script code, like dependencies {...}.
  libs = [
    vehicles: [
      [group: vehiclesGroup, name: 'car', version: '2.0'],
      [group: vehiclesGroup, name: 'truck', version: '1.0']
    ],
    traffic: [
      [group: 'com.traffic', name: 'pedestrian', version: '1.0']
    ]
  ]
}

configurations {
  vehicles
}

dependencies {
  // Reference ext.libs.vehicles defined earlier
  // in the build script.
  vehicles libs.vehicles
}</pre></div><p>Maven has a feature called dependency management metadata that allows us to define versions used for dependencies in a common part of the build file. Then, when the actual dependency is configured, we can leave out the version because it will be determined from the dependency management section of the build file. Gradle doesn't have such a built-in feature, but as illustrated earlier, we can use simple code refactoring to get a similar effect.</p><p>We can still have declarative dependency management, as we do in Maven, in our Gradle build, with the external dependency management plugin by Spring. This plugin adds a <code class="literal">dependencyManagement</code> configuration block to Gradle. Inside the configuration block, we can define dependency metadata, such as the group, name, and version. In the <code class="literal">dependencies</code> <a id="id52" class="indexterm"/>configuration closure in our Gradle build script, we don't have to specify the version anymore because it will be resolved via the dependency metadata in the <code class="literal">dependencyManagement</code> configuration. The following example build file uses this plugin and specifies dependency metadata using <code class="literal">dependencyManagement</code>:</p><div class="informalexample"><pre class="programlisting">buildscript {
  repositories {
    // Specific repository to find and download
    // dependency-management-plugin.
    maven {
      url 'http://repo.spring.io/plugins-snapshot'
    }
  }
  dependencies {
    // Define external module dependency with plugin.
    classpath 'io.spring.gradle:dependency-management-plugin:0.1.0.RELEASE'
  }
}

// Apply the external plugin dependency-management.
apply plugin: 'io.spring.dependency-management'
apply plugin: 'java'

repositories {
  // Repository for downloading dependencies.
  jcenter()
}

// This block is added by the dependency-management
// plugin to define dependency metadata.
dependencyManagement {
  dependencies {
    // Specify group:name followed by required version.
    'org.springframework.boot:spring-boot-starter-web' '1.1.5.RELEASE'

    // If we have multiple module names for the same group
    // and version we can use dependencySet.
    dependencySet(group: 'org.springframework.boot',
          version: '1.1.5.RELEASE') {
      entry 'spring-boot-starter-web'
      entry 'spring-boot-starter-actuator'
    }
  }
}

dependencies {
  // Version is resolved via dependencies metadata
  // defined in dependencyManagement.
  compile 'org.springframework.boot:spring-boot-starter-web'
}</pre></div><p>To import a Maven <span class="strong"><strong>bill of materials</strong></span> (<span class="strong"><strong>BOM</strong></span>) provided by an organization, we can use the <code class="literal">imports</code> method inside the <code class="literal">dependencyManagement</code> configuration. In the next example, we will use the Spring <a id="id53" class="indexterm"/>IO platform BOM. In the <code class="literal">dependencies</code> configuration, we can leave out the version because it will be resolved via the BOM:</p><div class="informalexample"><pre class="programlisting">buildscript {
  repositories {
    // Specific repository to find and download
    // dependency-management-plugin.
    maven {
      url 'http://repo.spring.io/plugins-snapshot'
    }
  }
  dependencies {
    // Define external module dependency with plugin.
    classpath 'io.spring.gradle:dependency-management-plugin:0.1.0.RELEASE'
  }
}

// Apply the external plugin dependency-management.
apply plugin: 'io.spring.dependency-management'
apply plugin: 'java'

repositories {
  // Repository for downloading BOM and dependencies.
  jcenter()
}

// This block is added by the dependency-management
// plugin to define dependency metadata.
dependencyManagement {
  imports {
    // Use Maven BOM provided by Spring IO platform.
    mavenBom 'io.spring.platform:platform-bom:1.0.1.RELEASE'
  }
}

dependencies {
  // Version is resolved via Maven BOM.
  compile 'org.springframework.boot:spring-boot-starter-web'
}</pre></div></div>
<div class="section" title="Summary" id="aid-J2B81"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, you learned how to create and use dependency configurations to group together dependencies. We saw how to define several types of dependencies, such as external module dependency and internal dependencies.</p><p>Also, we saw how we can add dependencies to code in Gradle build scripts with the <code class="literal">classpath</code> configuration and the <code class="literal">buildscript</code> configuration.</p><p>Finally, we looked at some maintainable ways of defining dependencies using code refactoring and the external dependency management plugin.</p><p>In the next chapter, we will learn more about how we can configure repositories that store dependency modules.</p></div></body></html>