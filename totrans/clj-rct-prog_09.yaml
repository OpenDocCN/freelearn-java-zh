- en: Chapter 9. A Reactive API to Amazon Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。亚马逊网络服务的响应式API
- en: Throughout this book, we have learned a number of tools and techniques to aid
    us in building reactive applications—futures with imminent, Observables with RxClojure/RxJava,
    channels with `core.async`—and even in building reactive user interfaces using
    Om and React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们学习了许多工具和技术，以帮助我们构建响应式应用程序——使用即将到来的未来、使用RxClojure/RxJava的Observables、使用`core.async`的通道——甚至使用Om和React构建响应式用户界面。
- en: In the process, we also became acquainted with the concept of **Functional Reactive
    Programming** and **Compositional Event Systems**, as well as what makes them
    different.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还了解了**函数式响应式编程**和**组合事件系统**的概念，以及它们之间的区别。
- en: 'In this last chapter, we will bring a few of these different tools and concepts
    together by developing an application based on a real-world use case from a client
    I worked with in Sydney, Australia. We will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将通过开发一个基于我在澳大利亚悉尼的客户的一个真实世界用例的应用程序，将一些不同的工具和概念结合起来。我们将：
- en: Describe the problem of infrastructure automation we were trying to solve
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述我们试图解决的自动化基础设施问题
- en: Have a brief look at some of Amazon's AWS services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要了解一下亚马逊的一些AWS服务
- en: Build an AWS dashboard using the concepts we have learned so far
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们迄今为止学到的概念构建一个AWS仪表板
- en: The problem
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'This client—which we will call BubbleCorp from now on—had a big problem that
    is all too common and well known to big enterprises: one massive monolithic application.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户——从现在起我们将称之为BubbleCorp——有一个非常普遍且众所周知的大企业问题：一个庞大的单体应用程序。
- en: 'Besides making them move slow, as individual components can''t be evolved independently,
    this application makes deployment incredibly hard due to its environment constraints:
    all infrastructure needs to be available in order for the application to work
    at all.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使它们变得缓慢外，由于各个组件不能独立演进，这个应用程序由于其环境限制而使得部署变得极其困难：所有基础设施都必须可用，应用程序才能正常运行。
- en: As a result, developing new features and bug fixes involves having only a handful
    of development environments shared across dozens of developers each. This requires
    a wasteful amount of coordination between teams just so that they won't step on
    each other's toes, contributing to slow the whole life-cycle further.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发新功能和修复错误仅涉及少数几个由数十名开发者共享的开发环境。这需要在团队之间进行大量的协调，以免他们相互干扰，从而进一步减缓整个生命周期。
- en: The long-term solution to this problem is to break down this big application
    into smaller components, which can be deployed and worked on independently, but
    as good as this sounds, it's a laborious and lengthy process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的长期方案是将这个大应用程序分解成更小的组件，这些组件可以独立部署和开发，但尽管这个方案听起来很好，但它是一个既费时又漫长的过程。
- en: As a first step, BubbleCorp decided the best thing they could improve in the
    short term is to give developers the ability to work in the application independently
    from each other, which implies being able to create a new environment as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，BubbleCorp决定他们短期内能改进的最佳方法是让开发者能够独立工作，这意味着能够创建一个新环境。
- en: Given the infrastructure constraints, running the application on a single developer
    machine is prohibitive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到基础设施的限制，在单个开发者的机器上运行应用程序是不切实际的。
- en: 'Instead, they turned to infrastructure automation: they wanted a tool that,
    with the press of a button, would spin up a completely new environment.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，他们转向了基础设施自动化：他们想要一个工具，只需按一下按钮，就能启动一个全新的环境。
- en: This new environment would be already preconfigured with the proper application
    servers, database instances, DNS entries, and everything else needed to run the
    application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新环境将预先配置好适当的应用服务器、数据库实例、DNS条目以及运行应用程序所需的一切。
- en: This way, developers would only need to deploy their code and test their changes,
    without having to worry about the application setup.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，开发者只需部署他们的代码并测试他们的更改，无需担心应用程序的设置。
- en: Infrastructure automation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施自动化
- en: '**Amazon Web Services** (**AWS**) is the most mature and comprehensive cloud
    computing platform available today, and as such it was a natural choice for BubbleCorp
    to host its infrastructure in.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务**（**AWS**）是目前最成熟和最全面的云计算平台，因此对BubbleCorp来说，将其基础设施托管在这里是顺理成章的选择。'
- en: 'If you haven''t used AWS before, don''t worry, we''ll focus only on a few of
    its services:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过AWS，不要担心，我们只会关注其服务中的几个：
- en: '**Elastic Compute Cloud** (**EC2**): A service that provides users with the
    ability to rent virtual computers in which to run their applications.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性计算云**（**EC2**）：一项为用户提供租用虚拟计算机以运行其应用程序的服务。'
- en: '**Relational Database Service** (**RDS**): This can be thought of as a specialized
    version of EC2 that provides managed database services.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系数据库服务**（**RDS**）：这可以被视为EC2的一个特殊版本，提供托管数据库服务。'
- en: '**CloudFormation**: With CloudFormation, users have the ability to specify
    infrastructure templates, called stacks, of several different AWS resources—such
    as EC2, AWS, and many others—as well as how they interact with each other. Once
    written, the infrastructure template can be sent to AWS to be executed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloudFormation**：使用CloudFormation，用户可以指定多个不同AWS资源的基础设施模板，称为堆栈，例如EC2、AWS以及许多其他资源，以及它们如何相互交互。一旦编写完成，基础设施模板可以发送到AWS执行。'
- en: For **BubbleCorp**, the idea was to write these infrastructure templates, which
    once submitted would result into a completely new, isolated environment containing
    all data and components required to run its app. At any given time, there would
    be dozens of these environments running with developers working on them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**BubbleCorp**，想法是编写这些基础设施模板，一旦提交，就会产生一个完全新的、隔离的环境，其中包含运行其应用程序所需的所有数据和组件。在任何给定时间，都会有数十个这样的环境在运行，开发者正在对它们进行工作。
- en: 'As decent a plan as this sounds, big corporations usually have an added burden:
    cost centers. Unfortunately, BubbleCorp can''t simply allow developers to log
    into the AWS Console—where we can manage AWS resources—and spin up environments
    at will. They needed a way to, among other things, add cost center metadata to
    the environment to handle their internal billing process.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个计划听起来不错，但大公司通常还有一个额外的负担：成本中心。不幸的是，BubbleCorp不能简单地允许开发者登录AWS控制台——在那里我们可以管理AWS资源——并且随意启动环境。他们需要一种方法，在众多其他事情中，向环境添加成本中心元数据以处理他们的内部计费流程。
- en: This brings us to the application we will be focusing on for the remainder of
    this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到本章剩余部分我们将要关注的应用程序。
- en: AWS resources dashboard
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS资源仪表板
- en: My team and I were tasked with building a web-based dashboard for AWS. This
    dashboard would allow developers to log in using their BubbleCorp's credentials
    and, once authenticated, create new CloudFormation environments as well as visualize
    the status of each individual resource within a CloudFormation stack.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我的团队和我被分配了一个任务，即构建一个基于Web的AWS仪表板。这个仪表板将允许开发者使用他们的BubbleCorp凭证登录，一旦认证通过，就可以创建新的CloudFormation环境以及可视化CloudFormation堆栈中每个单独资源的状态。
- en: 'The application itself is fairly involved, so we will focus on a subset of
    it: interfacing with the necessary AWS services in order to gather information
    about the status of each individual resource in a given CloudFormation stack.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身相当复杂，因此我们将关注其子集：与必要的AWS服务接口，以收集有关给定CloudFormation堆栈中每个单独资源状态的信息。
- en: 'Once finished, this is what our simplified dashboard will look like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的简化仪表板将看起来像这样：
- en: '![AWS resources dashboard](img/00027.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![AWS资源仪表板](img/00027.jpeg)'
- en: It will display the ID, type, and current status of each resource. This might
    not seem like much for now, but given that all this information is coming from
    different, independent web services, it is far too easy to end up with unnecessarily
    complex code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示每个资源的ID、类型和当前状态。现在这看起来可能不多，但考虑到所有这些信息都来自不同的、独立的网络服务，最终得到不必要的复杂代码的情况是非常容易发生的。
- en: We will be using ClojureScript for this and therefore the JavaScript version
    of the AWS SDK, whose documentation can be found at [http://aws.amazon.com/sdk-for-node-js/](http://aws.amazon.com/sdk-for-node-js/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ClojureScript来完成这项工作，因此我们将使用AWS SDK的JavaScript版本，其文档可以在[http://aws.amazon.com/sdk-for-node-js/](http://aws.amazon.com/sdk-for-node-js/)找到。
- en: Before we get started, let's have a look at each of the AWS Services APIs we
    will be interacting with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们看看我们将与之交互的每个AWS服务API。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In reality, we will not be interacting with the real AWS services but rather
    a stub server provided for download from the book's GitHub repository.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不会与真实的AWS服务交互，而是与从本书的GitHub存储库提供的占位符服务器交互。
- en: The reason for this is to make following this chapter easier, as you won't need
    to create an account as well as generate an API access key to interact with AWS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的理由是为了使跟随本章内容更加容易，因为你不需要创建账户以及生成API访问密钥来与AWS交互。
- en: Additionally, creating resources incurs cost, and the last thing I want is for
    you to be charged hundreds of dollars at the end of the month because someone
    accidentally left resources running for longer than they should—trust me it has
    happened before.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建资源会产生成本，我当然不希望你在月底因为有人不小心让资源运行时间过长而被收取数百美元——相信我，这种情况以前发生过。
- en: CloudFormation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFormation
- en: The first service we will look at is CloudFormation. This makes sense as the
    APIs found in here will give us a starting point for finding information about
    the resources in a given stack.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个服务是CloudFormation。这是有道理的，因为这里找到的API将为我们找到给定堆栈中资源的信息提供一个起点。
- en: The describeStacks endpoint
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: describeStacks端点
- en: 'This endpoint is responsible for listing all stacks associated with a particular
    AWS account. For a given stack, its response looks like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点是负责列出与特定AWS账户关联的所有堆栈。对于给定的堆栈，其响应如下所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, it doesn't say anything about which resources belong to this
    stack. It does, however, give us the stack name, which we can use to look up resources
    in the next service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它没有说明哪些资源属于这个堆栈。然而，它确实给了我们堆栈名称，我们可以使用它来在下一个服务中查找资源。
- en: The describeStackResources endpoint
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: describeStackResources端点
- en: 'This endpoint receives many arguments, but the one we''re interested in is
    the stack name, which, once provided, returns the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点接收许多参数，但我们感兴趣的是堆栈名称，一旦提供，就会返回以下内容：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We seem to be getting somewhere now. This stack has several resources: three
    EC2 instances and two RDS instances—not too bad for only two API calls.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们似乎有所进展。这个堆栈有几个资源：三个EC2实例和两个RDS实例——对于仅两次API调用来说并不算太坏。
- en: However, as we mentioned previously, our dashboard needs to show the status
    of each of the resources. With the list of resource IDs at hand, we need to look
    to other services that could give us detailed information about each resource.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前提到的，我们的仪表板需要显示每个资源的状态。有了资源ID列表在手，我们需要查看其他可能提供每个资源详细信息的服务的端点。
- en: EC2
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EC2
- en: The next service we will look at is specific to EC2\. As we will see, the responses
    of the different services aren't as consistent as we would like them to be.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的服务是针对EC2的。正如我们将看到的，不同服务的响应并不像我们希望的那样一致。
- en: The describeInstances endpoint
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: describeInstances端点
- en: 'This endpoint sounds promising. Based on the documentation, it seems we can
    give it a list of instance IDs and it will give us back the following response:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点听起来很有希望。根据文档，我们可以给它一个实例ID列表，它将返回以下响应：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Buried in this response, we can see the `State` key, which gives us the status
    of that particular EC2 instance. This is all we need as far as EC2 goes. This
    leaves us with RDS to handle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个响应中，我们可以看到`State`键，它告诉我们特定EC2实例的状态。就EC2而言，这就是我们所需要的。这让我们剩下RDS要处理。
- en: RDS
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RDS
- en: One might be tempted to think that getting the statuses of RDS instances would
    be just as easy as with EC2\. Let's see if that is the case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会想，获取RDS实例的状态应该和EC2一样简单。让我们看看这是否属实。
- en: The describeDBInstances endpoint
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: describeDBInstances端点
- en: 'This endpoint is equivalent in purpose to the analogous EC2 endpoint we just
    looked at. Its input, however, is slightly different: it accepts a single instance
    ID as input and, as of the time of this writing, doesn''t support filters.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点在目的上与刚才我们查看的类似EC2端点相同。然而，它的输入略有不同：它接受单个实例ID作为输入，并且截至本文撰写时，不支持过滤器。
- en: This means that if our stack has multiple RDS instances—say, in a primary/replica
    setup—we need to make multiple API calls to gather information about each one
    of them. Not a big deal, of course, but a limitation to be aware of.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们的堆栈有多个RDS实例——比如说，在主/副本设置中——我们需要对每个实例进行多次API调用以收集信息。当然，这不是什么大问题，但这是一个需要注意的限制。
- en: 'Once given a specific database instance ID, this service responds with the
    following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦给出了特定的数据库实例ID，这个服务会返回以下代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The fact that a single instance comes inside a vector hints at the fact that
    filtering will be supported in the future. It just hasn't happened yet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单个实例包含在向量中这一事实暗示了将来将支持过滤。但这还没有发生。
- en: Designing the solution
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: 'We now have all the information we need to start designing our application.
    We need to coordinate four different API calls per CloudFormation stack:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了开始设计我们应用程序所需的所有信息。我们需要为每个CloudFormation堆栈协调四次不同的API调用：
- en: '`describeStacks`: To list all available stacks'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describeStacks`：用于列出所有可用的堆栈'
- en: '`describeStackResources`: To retrieve details of all resources contained in
    a stack'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describeStackResources`：用于检索堆栈中包含的所有资源的详细信息'
- en: '`describeInstances`: To retrieve details of all EC2 instances in a stack'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describeInstances`：用于检索堆栈中所有EC2实例的详细信息'
- en: '`describeDBInstances`: To retrieve details of all DB2 instances in a stack'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describeDBInstances`：用于检索堆栈中所有DB2实例的详细信息'
- en: Next, I would like you to step back for a moment and think about how you would
    design code like this. Go ahead, I'll wait.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我希望你能暂时退后一步，思考你将如何设计这样的代码。请继续，我会等待。
- en: Now that you're back, let's have a look at one possible approach.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您回来了，让我们看看一种可能的方法。
- en: If we recall the screenshot of what the dashboard would look like, we realize
    that, for the purposes of our application, the difference between EC2 and RDS
    resources can be completely ignored so long as each one has the attributes ID,
    type, and status.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回想一下仪表板的外观截图，我们会意识到，对于我们的应用程序来说，只要每个资源都有ID、类型和状态属性，EC2和RDS资源之间的区别就可以完全忽略。
- en: This means whatever our solution may be, it has to somehow provide a uniform
    way of abstracting the different resource types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论我们的解决方案可能是什么，它都必须以某种方式提供一种统一的方式来抽象不同的资源类型。
- en: Additionally, apart from `describeStacks` and `describeStackResources`, which
    need to be called sequentially, `describeInstances` and `describeDBInstances`
    can be executed concurrently, after which we will need a way to merge the results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了需要按顺序调用的`describeStacks`和`describeStackResources`之外，`describeInstances`和`describeDBInstances`可以并发执行，之后我们需要一种方法来合并结果。
- en: 'Since an image is worth a thousand words, the following image is what we would
    like the workflow to look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一张图片胜过千言万语，以下是我们希望工作流程看起来是这样的图片：
- en: '![Designing the solution](img/00028.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![设计解决方案](img/00028.jpeg)'
- en: 'The preceding image highlights a number of key aspects of our solution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片突出了我们解决方案的几个关键方面：
- en: We start by retrieving stacks by calling `describeStacks`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先通过调用`describeStacks`来检索堆栈
- en: Next, for each stack, we call `describeStackResources` to retrieve a list of
    resources for each one
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，对于每个堆栈，我们调用`describeStackResources`来检索每个堆栈的资源列表
- en: Then, we split the list by type, ending with a list of EC2 and one with RDS
    resources
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们按类型拆分列表，最后得到一个包含EC2和包含RDS资源的列表
- en: We proceed by concurrently calling `describeInstances` and `describeDBInstances`,
    yielding two lists of results, one per resource type
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过并发调用`describeInstances`和`describeDBInstances`，得到两个结果列表，每个资源类型一个
- en: As the response formats are different, we transform each resource into a uniform
    representation
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于响应格式不同，我们将每个资源转换为统一的表现形式
- en: Lastly, we merge all results into a single list, ready for rendering
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将所有结果合并到一个列表中，以便渲染
- en: This is quite a bit to take in, but as you will soon realize, our solution isn't
    too far off this high-level description.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要吸收很多信息，但正如您很快就会意识到的那样，我们的解决方案并不偏离这个高级描述太远。
- en: We can quite easily think of this problem as having information about several
    different types of instances flowing through this graph of API calls—being transformed
    as needed in between—until we arrive at the information we're after, in the format
    we would like to work with.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将这个问题想象成有关几种不同类型的实例的信息通过这个API调用图流动——在需要时进行转换——直到我们到达我们想要的信息，以我们想要工作的格式。
- en: 'As it turns out, a great way to model this problem is to use one of the Reactive
    abstractions we learned about earlier in this book: Observables.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个很好的方法来建模这个问题是使用我们在本书早期学习到的Reactive抽象之一：Observables。
- en: Running the AWS stub server
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行AWS占位符服务器
- en: Before we jump into writing our dashboard, we should make sure our AWS stub
    server is properly set up. The stub server is a Clojure web application that simulates
    how the real AWS API behaves and is the backend our dashboard will talk to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写仪表板之前，我们应该确保我们的AWS占位符服务器已经正确设置。占位符服务器是一个Clojure网络应用程序，它模拟了真实AWS API的行为，并且是仪表板将要与之通信的后端。
- en: 'Let''s start by going into our terminal, cloning the book repository using
    Git and then starting the stub server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先进入我们的终端，使用Git克隆书籍仓库，然后启动占位符服务器：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will have started the server on port 3001\. To validate it is working
    as expected, point your browser to `http://localhost:3001/cloudFormation/describeStacks`.
    You should see the following JSON response:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动服务器在端口3001上。为了验证它是否按预期工作，请将您的浏览器指向`http://localhost:3001/cloudFormation/describeStacks`。您应该看到以下JSON响应：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting up the dashboard project
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置仪表板项目
- en: As we previously mentioned, we will be developing the dashboard using ClojureScript
    with the UI rendered using Om. Additionally, as we have chosen Observables as
    our main Reactive abstraction, we will need RxJS, one of the many implementations
    of Microsoft's Reactive Extensions. We will be pulling these dependencies into
    our project shortly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将使用ClojureScript开发仪表板，并通过Om渲染UI。此外，由于我们选择了Observables作为我们的主要响应式抽象，我们需要RxJS，这是Microsoft响应式扩展的许多实现之一。我们将很快将这些依赖项拉入我们的项目。
- en: 'Let''s create a new ClojureScript project called `aws-dash` using the `om-start`
    leiningen template:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`om-start` leiningen模板创建一个名为`aws-dash`的新ClojureScript项目：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This gives us a starting point, but we should make sure our versions all match.
    Open up the `project.clj` file found in the root directory of the new project
    and ensure the dependencies section looks like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个起点，但我们应该确保我们的所有版本都匹配。打开新项目根目录中的`project.clj`文件，并确保依赖项部分看起来如下：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the first time we see the last two dependencies. `cljs-http` is a simple
    HTTP library we will use to make AJAX requests to our AWS stub server. `transit-cljs`
    allows us to, among other things, parse JSON responses into ClojureScript data
    structures.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到最后两个依赖项。`cljs-http`是一个简单的HTTP库，我们将用它来向我们的AWS模拟服务器发送AJAX请求。`transit-cljs`允许我们做许多事情，例如将JSON响应解析为ClojureScript数据结构。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Transit itself is a format and a set of libraries through which applications
    developed in different technologies can speak to each other. In this case, we
    are using the Clojurescript library to parse JSON, but if you're interested in
    learning more, I recommend reading the official blog post announcement by Rich
    Hickey at [http://blog.cognitect.com/blog/2014/7/22/transit](http://blog.cognitect.com/blog/2014/7/22/transit).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Transit本身是一种格式和一系列库，通过这些库，使用不同技术开发的程序可以相互通信。在这种情况下，我们正在使用Clojurescript库来解析JSON，但如果你有兴趣了解更多，我建议阅读Rich
    Hickey在[http://blog.cognitect.com/blog/2014/7/22/transit](http://blog.cognitect.com/blog/2014/7/22/transit)发布的官方博客文章。
- en: 'Next, we need RxJS, which, being a JavaScript dependency, isn''t available
    via leiningen. That''s OK. We will simply download it into the application output
    directory, `aws-dash/dev-resources/public/js/`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要RxJS，作为一个JavaScript依赖项，它不能通过leiningen获得。没关系。我们将简单地将其下载到应用程序输出目录`aws-dash/dev-resources/public/js/`：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Moving on, we need to make our application aware of our new dependency on RxJS.
    Open the `aws-dash/dev-resources/public/index.html` file and add a script tag
    to pull in RxJS:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要让我们的应用程序意识到我们对RxJS的新依赖。打开`aws-dash/dev-resources/public/index.html`文件，并添加一个script标签来引入RxJS：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With all the dependencies in place, let''s start the auto-compilation for our
    ClojureScript source files as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有依赖项就绪后，让我们开始自动编译我们的ClojureScript源文件，如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating AWS Observables
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AWS Observables
- en: We're now ready to start implementing our solution. If you recall from the Reactive
    Extensions chapter, `RxJava/RxJS/RxClojure` ship with several useful Observables.
    However, when the built-in Observables aren't enough, it gives us the tools to
    build our own.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始实现我们的解决方案了。如果你还记得反应式扩展章节，`RxJava/RxJS/RxClojure`提供了几个有用的Observables。然而，当内置的Observables不足以满足需求时，它为我们提供了构建自己的工具。
- en: Since it is highly unlikely RxJS already provides Observables for Amazon's AWS
    API, we will start by implementing our own primitive Observables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RxJS很可能已经为亚马逊的AWS API提供了Observables，我们将首先实现我们自己的原始Observables。
- en: 'To keep things neat, we will do this in a new file, under `aws-dash/src/cljs/aws_dash/observables.cljs`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，我们将在一个新文件中这样做，位于`aws-dash/src/cljs/aws_dash/observables.cljs`：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The namespace declaration requires the necessary dependencies we will need in
    this file. Note how there is no explicit dependency on RxJS. Since it is a JavaScript
    dependency that we manually pulled in, it is globally available for us to use
    via JavaScript interoperability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间声明需要我们在文件中需要的必要依赖项。注意，这里没有对RxJS的显式依赖。由于它是一个我们手动拉入的JavaScript依赖项，它通过JavaScript互操作性对我们来说是全局可用的。
- en: The next line sets up a `transit` reader for JSON, which we will use when parsing
    the stub server responses.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行设置了一个`transit`读取器用于JSON，我们将用它来解析模拟服务器响应。
- en: Then, we define the endpoint we will be talking to as well as a helper function
    to build the correct URIs. Make sure the variable `aws-endpoint` matches the host
    and port of the stub server started in the previous section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们将与之通信的端点以及一个辅助函数来构建正确的 URI。确保变量 `aws-endpoint` 与上一节中启动的占位符服务器的宿主和端口匹配。
- en: 'All Observables we are about to create follow a common structure: they make
    a request to the stub server, extract some information from the response, optionally
    transforming it, and then emit each item in the transformed sequence into the
    new Observable sequence.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将创建的所有 Observables 都遵循一个共同的结构：它们向占位符服务器发送请求，从响应中提取一些信息，可选地进行转换，然后将转换后的序列中的每个项目发射到新的
    Observable 序列中。
- en: 'To avoid repetition, this pattern is captured in the following function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复，这个模式被以下函数捕获：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s break this function down:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个函数：
- en: '`observable-seq` receives two arguments: the backend URI to which we will issue
    a GET request, and a `transform` function which is given the raw parsed JSON response
    and returns a sequence of transformed items.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observable-seq` 接收两个参数：我们将向其发出 GET 请求的后端 URI，以及一个 `transform` 函数，该函数接受原始解析的
    JSON 响应并返回一个转换项的序列。'
- en: 'Then, it calls the `create` function of the RxJS object `Rx.Observable`. Note
    how we make use of JavaScript interoperability here: we access the create function
    by prepending it with a dot much like in Java interoperability. Since `Rx.Observable`
    is a global object, we access it by prepending the global JavaScript namespace
    ClojureScript makes available to our program, `js/Rx.Observable`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它调用 RxJS 对象 `Rx.Observable` 的 `create` 函数。注意我们如何利用 JavaScript 互操作性：我们通过在前面加上一个点来访问
    create 函数，就像在 Java 互操作性中一样。由于 `Rx.Observable` 是一个全局对象，我们通过在前面加上 ClojureScript
    为我们的程序提供的全局 JavaScript 命名空间 `js/Rx.Observable` 来访问它。
- en: The Observable's create function receives two arguments. One is a function that
    gets called with an Observer to which we can push items to be published in the
    Observable sequence. The second function is a function that is called whenever
    this Observable is disposed of. This is the function where we could perform any
    cleanup needed. In our case, this function simply logs the fact that it is called
    to the console.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observable 的 create 函数接收两个参数。一个是带有观察者的函数，我们可以向其中推送要发布在 Observable 序列中的项目。第二个函数是每当这个
    Observable 被处置时调用的函数。这是我们可以执行任何清理所需的函数。在我们的情况下，这个函数只是将调用的事实记录到控制台。
- en: 'The first function is the one that interests us though:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一个函数是我们感兴趣的：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As soon as it gets called, it performs a request to the provided URI using cljs-http's
    `get` function, which returns a `core.async` channel. That's why the whole logic
    is inside a `go` block.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦被调用，它就会使用 cljs-http 的 `get` 函数对提供的 URI 发出请求，该函数返回一个 `core.async` 通道。这就是为什么整个逻辑都在
    `go` 块中的原因。
- en: Next, we use the transit JSON reader we configured previously to parse the body
    of the response, feeding the result into the `transform` function. Remember this
    function, as per our design, returns a sequence of things. Therefore, all that
    is left to do is push each item into the observer in turn.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用之前配置的 transit JSON 读取器来解析响应体，并将结果输入到 `transform` 函数中。记住这个函数，根据我们的设计，它返回一个序列。因此，我们唯一要做的就是依次将每个项目推送到观察者。
- en: Once we're done, we indicate that this Observable sequence won't emit any new
    item by invoking the `.onCompleted` function of the `observer` object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们通过调用 `observer` 对象的 `.onCompleted` 函数来指示这个 Observable 序列不会发射任何新的项目。
- en: 'Now, we can proceed creating our Observables using this helper function, starting
    with the one responsible for retrieving CloudFormation stacks:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个辅助函数继续创建我们的 Observables，从负责检索 CloudFormation 服务的那个开始：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This creates an observable that will emit one item per stack, in the following
    format:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 Observable，它将为每个堆栈发射一个项目，格式如下：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have stacks, we need an Observable to describe its resources:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了堆栈，我们需要一个 Observable 来描述其资源：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It has a similar purpose and emits resource items in the following format:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有类似的目的，并以以下格式发射资源项：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we''re following our strategy almost to the letter, we need two more
    observables, one for each instance type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们几乎字面地遵循我们的策略，我们还需要两个更多的 observables，每个实例类型一个：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each of which will emit resource items in the following formats for EC2 and
    RDS, respectively:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个都会以以下格式为 EC2 和 RDS 分别发射资源项：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Combining the AWS Observables
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合 AWS Observables
- en: It seems we have all major pieces in place now. All that is left to do is to
    combine the more primitive, basic Observables we just created into more complex
    and useful ones by combining them to aggregate all the data we need in order to
    render our dashboard.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们现在已经拥有了所有主要部件。剩下要做的就是将我们刚刚创建的更原始、基本的Observables组合成更复杂、更有用的Observables，通过组合它们来聚合我们渲染仪表板所需的所有数据。
- en: 'We will start by creating a function that combines both the `describe-stacks`
    and `describe-stack-resources` Observables:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个函数，它结合了`describe-stacks`和`describe-stack-resources`Observables：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Starting in the previous example, we begin to see how defining our API calls
    in terms of Observable sequences pays off: it''s almost simple combining these
    two Observables in a declarative manner.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个示例开始，我们开始看到如何用Observable序列来定义我们的API调用是如何带来好处的：几乎是以声明式的方式简单地将这两个Observable结合起来。
- en: 'Remember the role of `flatMap`: as `describe-stack-resources` itself returns
    an Observable, we use `flatMap` to flatten both Observables, as we have done before
    in various different abstractions.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`flatMap`的作用：由于`describe-stack-resources`本身返回一个Observable，我们使用`flatMap`来扁平化这两个Observables，就像我们在各种不同的抽象中之前所做的那样。
- en: The `stack-resources` Observable will emit resource items for all stacks. According
    to our plan, we would like to fork the processing here in order to concurrently
    retrieve EC2 and RDS instance data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack-resources`Observable将为所有堆栈发出资源项。根据我们的计划，我们希望在这里分叉处理，以并发检索EC2和RDS实例数据。'
- en: 'By following this train of thought, we arrive at two more functions that combine
    and transform the previous Observables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个思路，我们得到了两个更多函数，它们结合并转换了之前的Observables：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Both the functions receive an argument, resources, which is the result of calling
    the `stack-resources` Observable. That way, we only need to call it once.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都接收一个参数，resources，它是调用`stack-resources`Observable的结果。这样，我们只需要调用一次。
- en: Once again, it is fairly simple to combine the Observables in a way that makes
    sense, following our high-level idea described previously.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，按照我们之前描述的高级想法，以有意义的方式结合Observables相当简单。
- en: Starting with `resources`, we filter out the types we're not interested in,
    retrieve its IDs, and request its detailed information by flatmapping the `describe-instances`
    and `describe-db-instances` Observables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从`resources`开始，我们过滤掉我们不感兴趣的类型，检索其ID，并通过flatmapping `describe-instances`和`describe-db-instances`Observables来请求其详细信息。
- en: Note, however, that due to a limitation in the RDS API described earlier, we
    have to call it multiple times to retrieve information about all RDS instances.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，由于前面描述的RDS API的限制，我们必须多次调用它来检索所有RDS实例的信息。
- en: This seemingly fundamental difference in how we use the API becomes a minor
    transformation in our EC2 observable, which simply accumulates all IDs into a
    vector so that we can retrieve them all at once.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看似基本的使用API的差异在我们的EC2 observable中变成了一个小的转换，它只是将所有ID累积到一个向量中，这样我们就可以一次性检索它们。
- en: Our simple Reactive API to Amazon AWS is now complete, leaving us with the UI
    to create.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的Reactive API到Amazon AWS现在已经完成，剩下的是创建UI。
- en: Putting it all together
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有这些整合在一起
- en: 'Let''s now turn to building our user interface. It''s a simple one, so let''s
    just jump into it. Open up `aws-dash/src/cljs/aws_dash/core.cljs` and add the
    following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向构建我们的用户界面。这是一个简单的界面，所以我们直接进入。打开`aws-dash/src/cljs/aws_dash/core.cljs`并添加以下内容：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our application state contains a single key, `:instances`, which starts as an
    empty vector. As we can see from each Om component, instances will be rendered
    as rows in a HTML table.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用状态包含一个单一的关键字，`:instances`，它最初是一个空向量。正如我们可以从每个Om组件中看到的那样，实例将以HTML表格中的行形式渲染。
- en: 'After saving the file, make sure the web server is running by starting it from
    the REPL:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，确保通过从REPL启动它来运行Web服务器：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should now be able point your browser to `http://localhost:3000/`, but,
    as you might have guessed, you will see nothing but an empty table.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够将你的浏览器指向`http://localhost:3000/`，但是，正如你可能已经猜到的，你将看到的是一个空表。
- en: This is because we haven't yet used our Reactive AWS API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有使用我们的Reactive AWS API。
- en: 'Let''s fix it and bring it all together at the bottom of `core.cljs`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复它，并在`core.cljs`的底部将其全部整合在一起：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Yes, this is all we need! We create a `stack-resources` Observable and pass
    it as an argument to both `rds-instance-status` and `ec2-instance-status`, which
    will concurrently retrieve status information about all instances.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是我们所需要的！我们创建一个 `stack-resources` 可观察对象，并将其作为参数传递给 `rds-instance-status`
    和 `ec2-instance-status`，这将并发检索所有实例的状态信息。
- en: Next, we create a new Observable by merging the previous two followed by a call
    to `.reduce`, which will accumulate all information into a vector, convenient
    for rendering.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过合并前两个可观察对象并调用 `.reduce` 方法创建一个新的可观察对象，这将把所有信息累积到一个向量中，这对于渲染来说很方便。
- en: Finally, we simply subscribe to this Observable and, when it emits its results,
    we simply update our application state, leaving Om to do all the rendering for
    us.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简单地订阅这个可观察对象，当它发出结果时，我们简单地更新我们的应用程序状态，让 Om 为我们做所有的渲染。
- en: Save the file and make sure ClojureScript has compiled successfully. Then, go
    back to your browser at `http://localhost:3000/`, and you should see all instance
    statuses, as pictured at the beginning of this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并确保 ClojureScript 已成功编译。然后，回到你的浏览器 `http://localhost:3000/`，你应该能看到所有实例的状态，就像本章开头所展示的那样。
- en: Exercises
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: With our previous approach, the only way to see new information about the AWS
    resources is by refreshing the whole page. Modify our implementation in such a
    way that it queries the stub services every so often—say, every 500 milliseconds.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的方法，查看 AWS 资源的新信息的唯一方法是刷新整个页面。修改我们的实现，使其每隔一段时间查询占位符服务——比如说，每 500 毫秒查询一次。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `interval` function from RxJS can be helpful in solving this exercise. Think
    how you might use it together with our existing stream by reviewing how `flatMap`
    works.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 中的 `interval` 函数可以帮助解决这个练习。想想你如何结合我们现有的流使用它，通过回顾 `flatMap` 的工作原理。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at a real use case for Reactive applications: building
    a dashboard for AWS CloudFormation stacks.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了反应式应用程序的一个实际用例：为 AWS CloudFormation 堆栈构建仪表板。
- en: We have seen how thinking of all the information needed as resources/items flowing
    through a graph fits nicely with how one creates Observables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，将所有需要的信息视为通过图流动的资源/项目，这与创建可观察对象的方式非常契合。
- en: In addition, by creating primitive Observables that do one thing only gives
    us a nice declarative way to combine them into more complex Observables, giving
    us a degree of reuse not usually found with common techniques.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过创建只做一件事的原始可观察对象，我们得到了一个很好的声明式方法来将它们组合成更复杂可观察对象，这为我们提供了一种通常在常见技术中找不到的复用程度。
- en: Finally, we packaged it together with a simple Om-based interface to demonstrate
    how using different abstractions in the same application does not add to complexity
    as long as the abstractions are chosen carefully for the problem at hand.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将它包装在一个简单的基于 Om 的界面中，以展示在同一个应用程序中使用不同的抽象不会增加复杂性，只要这些抽象被仔细地选择来处理当前的问题。
- en: This brings us to the end of what hopefully was an enjoyable and informative
    journey through the different ways of Reactive Programming.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们到达了希望是一个愉快且富有信息性的旅程的终点，通过不同的反应式编程方式。
- en: Far from being a complete reference, this book aims to provide you, the reader,
    with enough information, as well as concrete tools and examples that you can apply
    today.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书远非一个完整的参考手册，它的目的是为你，读者，提供足够的信息，以及你可以今天就能应用的切实工具和示例。
- en: It is also my hope that the references and exercises included in this book prove
    themselves useful, should you wish to expand your knowledge and seek out more
    details.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我也希望这本书中包含的参考和练习能够证明它们是有用的，如果你希望扩展你的知识并寻找更多细节的话。
- en: Lastly, I strongly encourage you to turn the page and read the [Appendix](part0070_split_000.html#page
    "Appendix A. The Algebra of Library Design") , *The Algebra of Library Design*,
    as I truly believe it will, if nothing else, make you think hard about the importance
    of composition in programming.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我强烈建议你翻到下一页阅读[附录](part0070_split_000.html#page "附录 A. 库设计代数")，即《库设计代数》，因为我真心相信，至少它会使你深入思考编程中组合的重要性。
- en: I sincerely wish this book has been as entertaining and instructional to read
    as it was to write.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望这本书的阅读体验像写作一样有趣和有教育意义。
- en: Thank you for reading. I look forward to seeing the great things you build.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。我期待看到你构建的伟大事物。
- en: Appendix A. The Algebra of Library Design
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 库设计代数
- en: 'You might have noticed that all reactive abstractions we have encountered in
    this book have a few things in common. For one, they work as "container-like"
    abstractions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在这本书中遇到的所有的反应式抽象都有一些共同点。首先，它们作为“容器式”抽象工作：
- en: Futures encapsulate a computation that eventually yields a single value
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期货封装了一个最终会产生单个值的计算。
- en: Observables encapsulate computations that can yield multiple values over time
    in the shape of a stream
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察封装了可以在一段时间内以流的形式产生多个值的计算。
- en: Channels encapsulate values pushed to them and can have them popped from it,
    working as a concurrent queue through which concurrent processes communicate
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道封装了推送到它们的值，并且可以从它们中弹出值，作为一个并发队列，通过这个队列并发进程进行通信。
- en: 'Then, once we have this "container," we can operate on it in a number of ways,
    which are very similar across the different abstractions and frameworks: we can
    `filter` the values contained in them, transform them using `map`, combine abstractions
    of the same type using `bind`/`flatMap`/`selectMany`, execute multiple computations
    in parallel, aggregate the results using `sequence`, and much more.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们有了这个“容器”，我们就可以以多种方式对其进行操作，这些方式在不同抽象和框架之间非常相似：我们可以使用 `filter` 过滤它们包含的值，使用
    `map` 对其进行转换，使用 `bind`/`flatMap`/`selectMany` 组合相同类型的抽象，并行执行多个计算，使用 `sequence`
    聚合结果，等等。
- en: As such, even though the abstractions and their underlying workings are fundamentally
    different, it still feels they belong to some type of higher-level abstractions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管抽象及其底层工作原理在本质上不同，但它们仍然感觉属于某种类型的高级抽象。
- en: In this appendix, we will explore what these higher-level abstractions are,
    the relationship between them, and how we can take advantage of them in our projects.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们将探索这些高级抽象是什么，它们之间的关系，以及我们如何在项目中利用它们。
- en: The semantics of map
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map` 的语义'
- en: 'We will get started by taking a look at one of the most used operations in
    these abstractions: `map`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看这些抽象中最常用的一个操作：`map`。
- en: We've been using `map` for a long time in order to transform sequences. Thus,
    instead of creating a new function name for each new abstraction, library designers
    simply abstract the `map` operation over its own container type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经长时间使用 `map` 来转换序列。因此，为了避免为每个新的抽象创建一个新的函数名，库设计者只是简单地在其自己的容器类型上抽象 `map` 操作。
- en: Imagine the mess we would end up in if we had functions such as `transform-observable`,
    `transform-channel`, `combine-futures`, and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们有 `transform-observable`、`transform-channel`、`combine-futures` 等函数，我们会陷入多么混乱的局面。
- en: Thankfully, this is not the case. The semantics of `map` are well understood
    to the point that even if a developer hasn't used a specific library before, he
    will almost always assume that `map` will apply a function to the value(s) contained
    within whatever abstraction the library provides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，情况并非如此。`map` 的语义已经被充分理解，以至于即使开发者之前没有使用过特定的库，他也会几乎总是假设 `map` 会将函数应用于库提供的任何抽象中的值（或值）。
- en: 'Let''s look at three examples we encountered in this book. We will create a
    new leiningen project in which to experiment with the contents of this appendix:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这本书中遇到的三个例子。我们将创建一个新的 leiningen 项目，以便在这个附录的内容上进行实验：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, let''s add a few dependencies to our `project.clj` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向我们的 `project.clj` 文件添加一些依赖项：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Don't worry about the last dependency—we'll get to it later on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心最后一个依赖项——我们稍后会处理它。
- en: 'Now, start an REPL session so that we can follow along:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个 REPL 会话，这样我们就可以跟随操作：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, enter the following into your REPL:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下内容输入到你的 REPL 中：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The three examples—using imminent, RxClojure, and core.async, respectively—look
    remarkably similar. They all follow a simple recipe:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个例子——分别使用 imminent、RxClojure 和 core.async——看起来非常相似。它们都遵循一个简单的配方：
- en: Put the number 31 inside their respective abstraction.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字 31 放入它们各自的抽象中。
- en: Double that number by mapping a function over the abstraction.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在抽象上映射一个函数来将这个数字翻倍。
- en: Print its result to the REPL.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其结果打印到 REPL。
- en: As expected, this outputs the value `62` three times to the screen.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它将值 `62` 输出到屏幕上三次。
- en: 'It would seem `map` performs the same abstract steps in all three cases: it
    applies the provided function, puts the resulting value in a fresh new container,
    and returns it. We could continue generalizing, but we would just be rediscovering
    an abstraction that already exists: Functors.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`map`在所有三种情况下都执行相同的抽象步骤：它应用提供的函数，将结果值放入一个全新的容器中，并返回它。我们可以继续进行泛化，但这样我们只是在重新发现已经存在的抽象：函子。
- en: Functors
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函子
- en: 'Functors are the first abstraction we will look at and they are rather simple:
    they define a single operation called `fmap`. In Clojure, Functors can be represented
    using protocols and are used for containers that can be mapped over. Such containers
    include, but are not limited to, lists, Futures, Observables, and channels.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 函子是我们将要研究的第一个抽象，它们相当简单：它们定义了一个名为`fmap`的单一操作。在Clojure中，可以使用协议来表示函子，并且它们用于可以映射的容器。这些容器包括但不限于列表、Future、Observables和通道。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The *Algebra* in the title of this *Appendix* refers to **Abstract Algebra**,
    a branch of Mathematics that studies algebraic structures. An algebraic structure
    is, to put it simply, a set with one or more operations defined on it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录标题中的*代数*指的是**抽象代数**，这是研究代数结构的数学的一个分支。简单来说，代数结构是在其上定义了一个或多个运算的集合。
- en: As an example, consider **Semigroups**, which is one such algebraic structure.
    It is defined to be a set of elements together with an operation that combines
    any two elements of this set. Therefore, the set of positive integers together
    with the addition operation form a Semigroup.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑**半群**，这是一种这样的代数结构。它被定义为包含一组元素以及一个将这个集合中的任意两个元素结合起来的运算。因此，正整数集合加上加法运算构成一个半群。
- en: Another tool used for studying algebraic structures is called Category Theory,
    of which Functors are part of.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于研究代数结构的工具被称为范畴论，函子是范畴论的一部分。
- en: We won't delve too much into the theory behind all this, as there are plenty
    of books [9][10] available on the subject. It was, however, a necessary detour
    to explain the title used in this appendix.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨所有这些理论背后的细节，因为关于这个主题有大量的书籍[9][10]可供参考。然而，解释这个附录中使用的标题却是必要的。
- en: Does this mean all of these abstractions implement a Functor protocol? Unfortunately,
    this is not the case. As Clojure is a dynamic language and it didn't have protocols
    built in—they were added in version 1.2 of the language—these frameworks tend
    to implement their own version of the `map` function, which doesn't belong to
    any protocol in particular.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着所有这些抽象都实现了函子协议？不幸的是，并非如此。由于Clojure是一种动态语言，它没有内置协议——这些协议是在语言的1.2版本中添加的——这些框架倾向于实现自己的`map`函数版本，而这个版本不属于任何特定的协议。
- en: The only exception is imminent, which implements the protocols included in `fluokitten`,
    a Clojure library providing concepts from Category theory such as Functors.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是即将到来的，它实现了`fluokitten`库中包含的协议，这是一个提供范畴论概念（如函子）的Clojure库。
- en: 'This is a simplified version of the Functor protocol found in `fluokitten`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fluokitten`中找到的函子协议的简化版本：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As mentioned previously, Functors define a single operation. `fmap` applies
    the function `g` to whatever value is inside the container, Functor, `fv`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函子定义了一个单一的操作。`fmap`将函数`g`应用于容器`Functor``fv`内部的任何值。
- en: However, implementing this protocol does not guarantee that we have actually
    implemented a Functor. This is because, in addition to implementing the protocol,
    Functors are also required to obey a couple of laws, which we will examine briefly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现这个协议并不能保证我们实际上已经实现了函子。这是因为，除了实现协议之外，函子还必须遵守一些定律，我们将简要地考察这些定律。
- en: 'The identity law is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 恒等律如下：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code is all we need to verify this law. It simply says that mapping
    the `identity` function over `a-functor` is the same as simply applying the `identity`
    function to the Functor itself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码就是我们验证这个定律所需的所有内容。它只是简单地说明，在`a-functor`上映射`identity`函数与直接将`identity`函数应用于函子本身是相同的。
- en: 'The composition law is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 组合律如下：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The composition law, in turn, says that if we compose two arbitrary functions
    `f` and `g`, take the resulting function and apply that to `a-functor`, that is
    the same as mapping `g` over the Functor and then mapping `f` over the resulting
    Functor.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 组合律反过来表明，如果我们组合两个任意函数`f`和`g`，将得到的结果函数应用于`a-functor`，这与先映射`g`到函子，然后映射`f`到结果函子是相同的。
- en: No amount of text will be able to replace practical examples, so we will implement
    our own Functor, which we will call `Option`. We will then revisit the laws to
    ensure we have respected them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 无论文本有多少，都无法取代实际示例，因此我们将实现自己的 Functor，我们将其称为 `Option`。然后我们将重新审视这些定律，以确保我们已经遵守了它们。
- en: The Option Functor
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项 Functor
- en: As Tony Hoare once put it, null references are his one billion dollar mistake
    ([http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)).
    Regardless of background, you no doubt will have encountered versions of the dreadful
    `NullPointerException`. This usually happens when we try to call a method on an
    object reference that is `null`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如托尼·霍尔（Tony Hoare）曾经说过的，空引用是他价值十亿美元的失误（[http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)）。无论背景如何，你无疑都会遇到可怕的
    `NullPointerException`。这通常发生在我们尝试在 `null` 对象引用上调用方法时。
- en: Clojure embraces null values due to its interoperability with Java, its host
    language, but it provides improved support for dealing with them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Clojure 与其宿主语言 Java 的互操作性，Clojure 接受了空值，但它提供了更好的支持来处理它们。
- en: The core library is packed with functions that do the right thing if passed
    a nil value—Clojure's version of Java's `null`. For instance, how many elements
    are there in a `nil` sequence?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 核心库包含了许多函数，如果传递 `nil` 值，它们会执行正确操作——这是 Clojure 对 Java 的 `null` 的版本。例如，一个 `nil`
    序列中有多少个元素？
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Thanks to conscious design decisions regarding `nil`, we can, for the most part,
    afford not worry about it. For all other cases, the `Option` Functor might be
    of some help.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对 `nil` 的有意识设计决策，我们大部分情况下可以不必担心它。对于所有其他情况，`Option` Functor 可能会有些帮助。
- en: The remaining of the examples in this appendix should be in a file called `option.clj`
    under `library-design/src/library_design/`. You're welcome to try this in the
    REPL as well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录中剩余的示例应在 `library-design/src/library_design/` 目录下的 `option.clj` 文件中。欢迎你在
    REPL 中尝试这个示例。
- en: 'Let''s start our next example by adding the namespace declaration as well as
    the data we will be working with:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加命名空间声明以及我们将要使用的数据开始我们的下一个示例：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As a Pirates of the Caribbean fan, I thought it would be interesting to play
    with pirates for this example. Let''s say we would like to calculate Jack Sparrow''s
    age. Given the data and functions we just covered, this is a simple task:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为加勒比海盗的粉丝，我认为在这个例子中玩海盗很有趣。假设我们想要计算杰克·斯派洛的年龄。根据我们刚刚覆盖的数据和函数，这是一个简单的任务：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, what if we would like to know Davy Jones'' age? We don''t actually
    have any data for this pirate, so if we run our program again, this is what we''ll
    get:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想知道戴维·琼斯（Davy Jones）的年龄怎么办？实际上我们没有这个海盗的数据，所以如果我们再次运行我们的程序，我们会得到以下结果：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There it is. The dreadful `NullPointerException`. This happens because in the
    implementation of the age function, we end up trying to subtract two `nil` values,
    which is incorrect. As you might have guessed, we will attempt to fix this by
    using the `Option` Functor.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。可怕的 `NullPointerException`。这是因为在我们年龄函数的实现中，我们最终尝试从两个 `nil` 值中减去，这是不正确的。正如你可能已经猜到的，我们将尝试通过使用
    `Option` Functor 来修复这个问题。
- en: 'Traditionally, `Option` is implemented as an algebraic data type, more specifically
    a sum type with two variants: `Some` and `None`. These variants are used to identify
    whether a value is present or not without using `nils`. You can think of both
    `Some` and `None` as subtypes of `Option`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，`Option` 是作为代数数据类型实现的，更具体地说，是一个具有两种变体的求和类型：`Some` 和 `None`。这些变体用于确定值是否存在，而不使用
    `nils`。你可以将 `Some` 和 `None` 都视为 `Option` 的子类型。
- en: 'In Clojure, we will represent them using records:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，我们将使用记录来表示它们：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can see, `Some` can contain a single value whereas `None` contains nothing.
    It's simply a marker indicating the absence of content. We have also created a
    helper function called `option`, which creates the appropriate record depending
    on whether its argument is `nil` or not.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Some` 可以包含单个值，而 `None` 则不包含任何内容。它只是一个表示内容缺失的标记。我们还创建了一个名为 `option` 的辅助函数，该函数根据其参数是否为
    `nil` 创建适当的记录。
- en: 'The next step is to extend the `Functor` protocol to both records:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 `Functor` 协议扩展到两个记录：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here''s where the semantic meaning of the `Option` Functor becomes apparent:
    as `Some` contains a value, its implementation of `fmap` simply applies the function
    `g` to the value inside the Functor `f`, which is of type `Some`. Finally, we
    put the result inside a new `Some` record.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Option` Functor的语义意义变得明显的地方：因为`Some`包含一个值，它的`fmap`实现只是将函数`g`应用到Functor `f`内部的值上，该值是`Some`类型。最后，我们将结果放入一个新的`Some`记录中。
- en: Now what does it mean to map a function over a `None`? You probably guessed
    that it doesn't really make sense—the `None` record holds no values. The only
    thing we can do is return another `None`. As we will see shortly, this gives the
    `Option` Functor a short-circuiting semantic.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在映射一个函数到`None`意味着什么呢？你可能已经猜到了，这实际上没有太多意义——`None`记录不包含任何值。我们能做的唯一一件事就是返回另一个`None`。正如我们很快就会看到的，这给了`Option`
    Functor短路语义。
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the `fmap` implementation of `None`, we could have returned a reference to
    `this` instead of a new record instance. I've not done so simply to make it clear
    that we need to return an instance of `None`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`None`的`fmap`实现中，我们可以返回对`this`的引用而不是一个新的记录实例。我没有这样做只是为了清楚地表明我们需要返回`None`的一个实例。
- en: 'Now that we''ve implemented the Functor protocol, we can try it out:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了Functor协议，我们可以尝试一下：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first example shouldn't hold any surprises. We convert the pirate map we
    get from calling `pirate-by-name` into an option, and then `fmap` the age function
    over it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子不应该有任何惊喜。我们将从调用`pirate-by-name`得到的海盗地图转换成一个选项，然后对它应用年龄函数。
- en: The second example is the interesting one. As stated previously, we have no
    data about Davy Jones. However, mapping `age` over it does not throw an exception
    any longer, instead returning `None`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子更有趣。正如之前所述，我们没有关于Davy Jones的数据。然而，对它映射`age`不再抛出异常，而是返回`None`。
- en: 'This might seem like a small benefit, but the bottom line is that the `Option`
    Functor makes it safe to chain operations together:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个小小的好处，但关键是`Option` Functor使得链式操作变得安全：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, some readers might be thinking about the `some->` macro—introduced
    in Clojure 1.5—and how it effectively achieves the same result as the `Option`
    Functor. This intuition is correct as demonstrated as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一些读者可能已经在思考`some->`宏——在Clojure 1.5中引入——以及它如何有效地实现与`Option` Functor相同的结果。这种直觉是正确的，如下所示：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `some->` macro threads the result of the first expression through the first
    form if it is not `nil`. Then, if the result of that expression isn't `nil`, it
    threads it through the next form and so on. As soon as any of the expressions
    evaluates to nil, `some->` short-circuits and returns nil immediately.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`some->`宏会将第一个表达式的结果通过第一个形式传递，如果它不是`nil`。然后，如果那个表达式的结果不是`nil`，它会通过下一个形式传递，依此类推。一旦任何表达式评估为`nil`，`some->`就会短路并立即返回`nil`。'
- en: 'That being said, Functor is a much more general concept, so as long as we are
    working with this concept, our code doesn''t need to change as we are operating
    at a higher level of abstraction:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Functor是一个更为通用的概念，因此只要我们在这个概念下工作，我们的代码就不需要随着我们在更高层次的抽象操作而改变：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, even though we are working with a fundamentally different
    tool—futures—the code using the result did not have to change. This is only possible
    because both Options and futures are Functors and implement the same protocol
    provided by fluokitten. We have gained composability and simplicity as we can
    use the same API to work with various different abstractions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，尽管我们使用的是一个本质上不同的工具——未来（futures），但使用结果的代码并不需要改变。这之所以可能，仅仅是因为Options和futures都是Functors，并且实现了fluokitten提供的相同协议。我们获得了可组合性和简单性，因为我们可以使用相同的API来处理各种不同的抽象。
- en: 'Speaking of composability, this property is guaranteed by the second law of
    Functors. Let''s see if our Option Functor respects this and the first—the identity—laws:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 说到可组合性，这个特性由Functors的第二定律保证。让我们看看我们的Option Functor是否遵守这个以及第一定律——恒等定律：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And we're done, our `Option` Functor is a lawful citizen. The remaining two
    abstractions also come paired with their own laws. We will not cover the laws
    in this section, but I encourage the reader to read about them ([http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/](http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/)).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就完成了，我们的 `Option` 函子现在是一个合法的公民。剩下的两个抽象也各自配对了自己的法则。我们不会在本节中介绍这些法则，但我鼓励读者去了解它们（[http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/](http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/))。
- en: Finding the average of ages
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算年龄的平均值
- en: 'In this section, we will explore a different use case for the `Option` Functor.
    We would like to, given a number of pirates, calculate the average of their ages.
    This is simple enough to do:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索 `Option` 函子的不同用法。我们希望，给定一定数量的海盗，计算他们的平均年龄。这很简单：
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note how we are using `some->` here to protect us from `nil` values. Now, what
    happens if there is a pirate for which we have no information?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里是如何使用 `some->` 来保护我们免受 `nil` 值的影响。现在，如果我们对某个海盗没有信息怎么办？
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It seems we're back at square one! It's worse now because using `some->` doesn't
    help if we need to use all values at once, as opposed to threading them through
    a chain of function calls.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们又回到了起点！现在更糟，因为如果我们需要一次性使用所有值，而不是通过一系列函数调用传递它们，使用 `some->` 就没有帮助了。
- en: 'Of course, not all is lost. All we need to do is check if all values are present
    before calculating the average:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并没有失去所有东西。我们只需要在计算平均值之前检查所有值是否都存在：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: While this works perfectly fine, our implementation suddenly had to become aware
    that any or all of the values `a`, `b`, and `c` could be `nil`. The next abstraction
    we will look at, Applicative Functors, fixes this.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这工作得很好，但我们的实现突然必须意识到 `a`、`b` 和 `c` 中的任何一个或所有值都可能是 `nil`。我们将要查看的下一个抽象，应用函子，解决了这个问题。
- en: Applicative Functors
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用函子
- en: 'Like Functors, **Applicative Functors** are a sort of container and defines
    two operations:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与函子类似，**应用函子**是一种容器，并定义了两个操作：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `pure` function is a generic way to put a value inside an Applicative Functor.
    So far, we have been using the `option` helper function for this purpose. We will
    be using it a little later.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`pure` 函数是一种将值放入应用函子的通用方式。到目前为止，我们一直使用 `option` 辅助函数来完成这个目的。我们稍后会用到它。'
- en: The `fapply` function will unwrap the function contained in the Applicative
    `ag` and apply it to the value contained in the applicative `av`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`fapply` 函数将展开应用函子 `ag` 中包含的函数，并将其应用于应用函子 `av` 中包含的值。'
- en: 'The purpose of both the functions will become clear with an example, but first,
    we need to promote our `Option` Functor into an Applicative Functor:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例，这两个函数的目的将变得清晰，但首先，我们需要将我们的 `Option` 函子提升为应用函子：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The implementation of `pure` is the simplest. All it does is wrap the value
    `v` into an instance of `Some`. Equally simple is the implementation of `fapply`
    for `None`. As there is no value, we simply return `None` again.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`pure` 的实现是最简单的。它所做的只是将值 `v` 包装成 `Some` 的一个实例。对于 `None` 的 `fapply` 实现来说，同样简单。因为没有值，所以我们再次简单地返回
    `None`。'
- en: The `fapply` implementation of `Some` ensures both arguments have a value for
    the `:v` keyword—strictly speaking they both have to be instances of `Some`. If
    `:v` is non-nil, it applies the function contained in `ag` to `v`, finally wrapping
    the result. Otherwise, it returns `None`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some` 的 `fapply` 实现确保两个参数都为 `:v` 关键字提供了值——严格来说，它们都必须是 `Some` 的实例。如果 `:v` 不是
    `nil`，它将 `ag` 中包含的函数应用于 `v`，最后将结果包装起来。否则，它返回 `None`。'
- en: 'This should be enough to try our first example using the Applicative Functor
    API:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以尝试使用应用函子 API 的第一个示例：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We are now able to work with Functors that contain functions. Additionally,
    we have also preserved the semantics of what should happen when any of the Functors
    don't have a value.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够处理包含函数的函子。此外，我们还保留了当任何函子没有值时应发生的行为的语义。
- en: 'We can now revisit the age average example from before:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回顾之前提到的年龄平均值示例：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `vararg` function `<*>` is defined by fluokitten and performs a left-associative
    `fapply` on its arguments. Essentially, it is a convenience function that makes
    `(<*> f g h)` equivalent to `(fapply (fapply f g) h)`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由 fluokitten 定义的 `vararg` 函数 `<*>` 对其参数执行左结合的 `fapply`。本质上，它是一个便利函数，使得 `(fapply
    f g h)` 等价于 `(fapply (fapply f g) h)`。
- en: We start by defining a helper function to avoid repetition. The `age-option`
    function retrieves the age of a pirate as an option for us.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个辅助函数来避免重复。`age-option` 函数为我们检索海盗的年龄作为一个选项。
- en: Next, we curry the `avg` function to `3` arguments and put it into an option.
    Then, we use the `<*>` function to apply it to the options a, b, and c. We get
    to the same result, but have the Applicative Functor take care of nil values for
    us.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `avg` 函数 Currying 到 `3` 个参数并将它放入一个选项中。然后，我们使用 `<*>` 函数将其应用于选项 a、b 和
    c。我们得到了相同的结果，但是让 Applicative Functor 为我们处理 `nil` 值。
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Function currying**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数 Currying**'
- en: Currying is the technique of transforming a function of multiple arguments into
    a higher-order function of a single argument that returns more single-argument
    functions until all arguments have been supplied.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Currying 是将多个参数的函数转换为一个更高阶的函数的技术，该函数返回更多的单参数函数，直到所有参数都已提供。
- en: 'Roughly speaking, currying makes the following snippets equivalent:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，Currying 使得以下代码片段等价：
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Using Applicative Functors this way is so common that the pattern has been
    captured as the function `alift`, as shown in the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 Applicative Functors 是如此常见，以至于这种模式已经被捕获为函数 `alift`，如下所示：
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `alift` function is responsible for lifting a function in such a way that
    it can be used with Applicative Functors without much ceremony. Because of the
    assumptions we are able to make about Applicative Functors—for instance, that
    it is also a Functor—we can write generic code that can be re-used across any
    Applicatives.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`alift` 函数负责以这种方式提升一个函数，使其可以在无需太多仪式的情况下与 Applicative Functors 一起使用。由于我们能够对
    Applicative Functors 做出的假设——例如，它也是一个 Functor——我们可以编写通用的代码，该代码可以在任何 Applicatives
    中重用。'
- en: 'With `alift` in place, our age average example turns into the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `alift` 就位后，我们的年龄平均值示例变成了以下内容：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We lift `avg` into an Applicative compatible version, making the code look
    remarkably like simple function application. And since we are not doing anything
    interesting with the let bindings, we can simplify it further as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `avg` 提升为与 Applicative 兼容的版本，使代码看起来非常像简单的函数应用。由于我们不对 let 绑定执行任何有趣的操作，我们可以进一步简化如下：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As with Functors, we can take the code as it is, and simply replace the underlying
    abstraction, preventing repetition once again:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Functors 一样，我们可以直接使用代码，并简单地替换底层的抽象，从而再次防止重复：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Gathering stats about ages
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集年龄统计数据
- en: Now that we can safely calculate the average age of a number of pirates, it
    might be interesting to take this further and calculate the median and standard
    deviation of the pirates' ages, in addition to their average age.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以安全地计算多个海盗的平均年龄，也许我们可以进一步计算海盗年龄的中位数和标准差，除了他们的平均年龄。
- en: 'We already have a function to calculate the average, so let''s just create
    the ones to calculate the median and the standard deviation of a list of numbers:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个计算平均值的函数，所以让我们创建计算数字列表的中位数和标准差的函数：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With these functions in place, we can write the code that will gather all the
    stats for us:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些函数就位后，我们可以编写将为我们收集所有统计数据的代码：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This implementation is fairly straightforward. We first retrieve all ages we're
    interested in and bind them to the locals `a`, `b`, and `c`. We then reuse the
    values when calculating the remaining stats. We finally gather all results in
    a map for easy access.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现相当直接。我们首先检索所有感兴趣的年龄并将它们绑定到局部变量 `a`、`b` 和 `c`。然后我们在计算剩余的统计数据时重用这些值。最后，我们将所有结果收集到一个映射中以便于访问。
- en: 'By now the reader will probably know where we''re headed: what if any of those
    values is `nil`?'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，读者可能已经知道我们的方向：如果这些值中的任何一个是 `nil` 会怎样？
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The second binding, `b`, returns `nil`, as we don''t have any information about
    Davy Jones. As such, it causes the calculations to fail. Like before, we can change
    our implementation to protect us from such failures:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个绑定 `b` 返回 `nil`，因为我们没有关于戴维·琼斯的信息。因此，它导致计算失败。像之前一样，我们可以更改我们的实现以保护我们免受此类失败的影响：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This time it''s even worse than when we only had to calculate the average;
    the code is checking for `nil` values in four extra spots: before calling the
    three stats functions and just before gathering the stats into the result map.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这次甚至比我们只需要计算平均值时还要糟糕；代码正在检查四个额外的`nil`值：在调用三个统计函数之前和将统计结果收集到结果映射之前。
- en: Can we do better?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？
- en: Monads
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monads
- en: 'Our last abstraction will solve the very problem we raised in the previous
    section: how to safely perform intermediate calculations by preserving the semantics
    of the abstractions we''re working with—in this case, options.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的抽象将解决上一节中提出的问题：如何通过保留我们正在工作的抽象的语义来安全地进行中间计算——在这个例子中，是选项。
- en: 'It should be no surprise now that fluokitten also provides a protocol for Monads,
    simplified and shown as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该不会感到惊讶，fluokitten 也提供了一个用于 Monads 的协议，简化并如下所示：
- en: '[PRE59]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If you think in terms of a class hierarchy, Monads would be at the bottom of
    it, inheriting from Applicative Functors, which, in turn, inherit from Functors.
    That is, if you're working with a Monad, you can assume it is also an Applicative
    and a Functor.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从类层次结构的角度思考，Monads 将位于底部，继承自 Applicative Functors，而 Applicative Functors
    又继承自 Functors。也就是说，如果你正在使用 Monad，你可以假设它也是一个 Applicative 和一个 Functor。
- en: 'The `bind` function of monads takes a function `g` as its second argument.
    This function receives as input the value contained in `mv` and returns another
    Monad containing its result. This is a crucial part of the contract: `g` has to
    return a Monad.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Monads 的 `bind` 函数将其第二个参数作为函数 `g`。这个函数接收 `mv` 中包含的值作为输入，并返回另一个包含其结果的 Monad。这是合同的关键部分：`g`
    必须返回一个 Monad。
- en: 'The reason why will become clearer after some examples. But first, let''s promote
    our Option abstraction to a Monad—at this point, Option is already an Applicative
    Functor and a Functor:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 原因将在一些例子之后变得更加清晰。但首先，让我们将我们的 Option 抽象提升为 Monad——在这个时候，Option 已经是一个 Applicative
    Functor 和一个 Functor。
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The implementation is fairly simple. In the `None` version, we can't really
    do anything, so just like we have been doing so far, we return an instance of
    `None`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单。在 `None` 版本中，我们实际上无法做任何事情，所以我们就像到目前为止所做的那样，返回一个 `None` 的实例。
- en: The `Some` implementation extracts the value from the Monad `mv` and applies
    the function `g` to it. Note how this time we don't need to wrap the result as
    the function `g` already returns a Monad instance.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some` 实现从 Monad `mv` 中提取值，并将其应用于函数 `g`。注意这次我们不需要将结果包装起来，因为函数 `g` 已经返回了一个 Monad
    实例。'
- en: 'Using the Monad API, we could sum the ages of our pirates as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Monad API，我们可以这样计算海盗的年龄总和：
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Firstly, we are making use of Applicative's `pure` function in the inner-most
    function. Remember that role of `pure` is to provide a generic way to put a value
    into an Applicative Functor. Since Monads are also Applicative, we make use of
    them here.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在最内层的函数中使用了 Applicative 的 `pure` 函数。记住 `pure` 的作用是提供一个将值放入 Applicative
    Functor 中的通用方式。由于 Monads 也是 Applicative，所以我们在这里使用它们。
- en: However, since Clojure is a dynamically typed language, we need to hint pure
    with the context—container—type we wish to use. This context is simply an instance
    of either `Some` or `None`. They both have the same pure implementation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Clojure 是一种动态类型语言，我们需要通过上下文——容器类型来提示我们希望使用的纯函数。这个上下文简单地是 `Some` 或 `None`
    的一个实例。它们都有相同的纯实现。
- en: While we do get the right answer, the preceding example is far from what we
    would like to write due to its excessive nesting. It is also hard to read.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们得到了正确的结果，但前面的例子离我们想要写的代码还远，因为它有太多的嵌套。它也难以阅读。
- en: 'Thankfully, fluokitten provides a much better way to write monadic code, called
    the do-notation:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，fluokitten 提供了一种更好的方式来编写 monadic 代码，称为 do-notation：
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Suddenly, the same code becomes a lot cleaner and easier to read, without losing
    any of the semantics of the Option Monad. This is because `mdo` is a macro that
    expands to the code equivalent of the nested version, as we can verify by expanding
    the macro as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 突然之间，相同的代码变得更加干净和易于阅读，而没有丢失 Option Monad 的任何语义。这是因为 `mdo` 是一个宏，它扩展为嵌套版本的代码等效，我们可以通过以下方式展开宏来验证：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to stop for a moment here and appreciate the power of Clojure—and
    Lisp in general.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里停下来，花一点时间来欣赏 Clojure（以及 Lisp 的一般）的力量是很重要的。
- en: Languages such as Haskell and Scala, which make heavy use of abstractions such
    as Functors, Applicative, and Monads, also have their own versions of the do-notation.
    However, this support is baked into the compiler itself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Haskell 和 Scala 这样的语言，它们大量使用 Functors、Applicative 和 Monads 这样的抽象，也有它们自己的 do-notation
    版本。然而，这种支持已经内置到编译器本身中。
- en: As an example, when Haskell added do-notation to the language, a new version
    of the compiler was released, and developers wishing to use the new feature had
    to upgrade.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Haskell 向语言添加 do-notation 为例，一个新版本的编译器被发布，希望使用新功能的开发者必须升级。
- en: In Clojure, on the other hand, this new feature can be shipped as a library
    due to the power and flexibility of macros. This is exactly what fluokitten has
    done.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在Clojure中，由于宏的强大和灵活性，这个新特性可以作为一个库发布。这正是fluokitten所做的事情。
- en: Now, we are ready to go back to our original problem, gathering stats about
    the pirates' ages.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备回到我们的原始问题，收集海盗的年龄统计数据。
- en: 'First, we will define a couple of helper functions that convert the result
    of our stats functions into the Option Monad:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义几个辅助函数，将我们的统计函数的结果转换为Option Monad：
- en: '[PRE64]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we take advantage of function composition to create monadic versions of
    existing functions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用函数组合来创建现有函数的monadic版本。
- en: 'Next, we will rewrite our solution using the monadic do-notation we learned
    earlier:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们之前学到的monadic do-notation重写我们的解决方案：
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This time we were able to write the function as we normally would, without
    having to worry about whether any values in the intermediate computations are
    empty or not. This semantic that is the very essence of the Option Monad is still
    preserved, as can be seen in the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们能够像平时一样编写函数，无需担心中间计算中的任何值是否为空。这种语义正是Option Monad的精髓所在，如下所示：
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For the sake of completeness, we will use futures to demonstrate how the do-notation
    works for any Monad:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们将使用futures来演示do-notation对于任何Monad的工作方式：
- en: '[PRE67]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This appendix has taken us on a brief tour of the world of category theory.
    We learned three of its abstractions: Functors, Applicative Functors, and Monads.
    They were the guiding principle behind imminent''s API.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录带我们简要游览了范畴论的世界。我们学习了其三个抽象：Functors、Applicative Functors和Monads。它们是imminent
    API背后的指导原则。
- en: To deepen our knowledge and understanding, we implemented our own Option Monad,
    a common abstraction used to safely handle the absence of values.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深化我们的知识和理解，我们实现了自己的Option Monad，这是一种常用的抽象，用于安全地处理值的缺失。
- en: We have also seen that using these abstractions allow us to make some assumptions
    about our code, as seen in functions such as `alift`. There are many other functions
    we would normally rewrite over and over again for different purposes, but that
    can be reused if we recognize our code fits into one of the abstractions learned.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，使用这些抽象可以使我们对代码做出一些假设，如`alift`函数所示。还有很多其他函数，我们通常需要为不同的目的反复重写，但如果我们认识到我们的代码符合学到的某个抽象，则可以重用。
- en: Finally, I hope this encourages readers to explore category theory more, as
    it will undoubtedly change the way you think. And if I can be so bold, I hope
    this will also change the way you design libraries in the future.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我希望这能鼓励读者进一步探索范畴论，因为它无疑会改变你的思维方式。而且，如果我可以如此大胆地说，我希望这也能改变你未来设计库的方式。
- en: Appendix B. Bibliography
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 参考文献列表
- en: '[1] Rene Pardo and Remy Landau, *The World''s First Electronic Spreadsheet*:
    [http://www.renepardo.com/articles/spreadsheet.pdf](http://www.renepardo.com/articles/spreadsheet.pdf)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Rene Pardo和Remy Landau，《世界上的第一张电子表格》：[http://www.renepardo.com/articles/spreadsheet.pdf](http://www.renepardo.com/articles/spreadsheet.pdf)'
- en: '[2] Conal Elliott and Paul Hudak, *Functional Reactive Animation*: [http://conal.net/papers/icfp97/icfp97.pdf](http://conal.net/papers/icfp97/icfp97.pdf)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] Conal Elliott和Paul Hudak，《函数式响应式动画》：[http://conal.net/papers/icfp97/icfp97.pdf](http://conal.net/papers/icfp97/icfp97.pdf)'
- en: '[3] Evan Czaplicki, *Elm: Concurrent FRP for Functional GUIs*: [http://elm-lang.org/papers/concurrent-frp.pdf](http://elm-lang.org/papers/concurrent-frp.pdf)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] Evan Czaplicki，《Elm：用于功能GUI的并发FRP》：[http://elm-lang.org/papers/concurrent-frp.pdf](http://elm-lang.org/papers/concurrent-frp.pdf)'
- en: '[4] Erik Meijer, *Subject/Observer is Dual to Iterator*: [http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf](http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] Erik Meijer，《Subject/Observer是Iterator的对偶》：[http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf](http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf)'
- en: '[5] Henrik Nilsson, Antony Courtney and John Peterson, *Functional Reactive
    Programming, Continued*: [http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] Henrik Nilsson、Antony Courtney和John Peterson，《函数式响应式编程，续》：[http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf)'
- en: '[6] John Hughes, *Generalising Monads to Arrows*: [http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] John Hughes，《将Monads推广到Arrows》：[http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf)'
- en: '[7] Zhanyong Wan, Walid Taha and Paul Hudak, *Real-Time FRP*: [http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] 万占勇，瓦利德·塔哈和保罗·胡达克，*实时反应式编程*：[http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf)'
- en: '[8] Walid Taha, Zhanyong Wan, and Paul Hudak, *Event-Driven FRP*: [http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf](http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] 瓦利德·塔哈，万占勇和保罗·胡达克，*事件驱动反应式编程*：[http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf](http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf)'
- en: '[9] Benjamin C. Pierce, *Basic Category Theory for Computer Scientists*: [http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&qid=1423484917&sr=8-7&keywords=category+theory](http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&qid=1423484917&sr=8-7&keywords=category+theory)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] 本杰明·C·皮尔斯，*计算机科学家基础范畴论*：[http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&qid=1423484917&sr=8-7&keywords=category+theory](http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&qid=1423484917&sr=8-7&keywords=category+theory)'
- en: '[10] Steve Awodey, *Category Theory (Oxford Logic Guides)*: [http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&qid=1423484917&sr=8-2&keywords=category+theory](http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&qid=1423484917&sr=8-2&keywords=category+theory)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[10] 史蒂夫·奥沃迪，*范畴论（牛津逻辑指南）*：[http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&qid=1423484917&sr=8-2&keywords=category+theory](http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&qid=1423484917&sr=8-2&keywords=category+theory)'
- en: '[11] Duncan Coutts, Roman Leshchinskiy, and Don Stewart, *Stream Fusion*: [http://code.haskell.org/~dons/papers/icfp088-coutts.pdf](http://code.haskell.org/~dons/papers/icfp088-coutts.pdf)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[11] 丹肯·科茨，罗马·莱斯钦斯基和唐·斯图尔特，*流融合*：[http://code.haskell.org/~dons/papers/icfp088-coutts.pdf](http://code.haskell.org/~dons/papers/icfp088-coutts.pdf)'
- en: '[12] Philip Wadler, *Transforming programs to eliminate trees*: [http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps](http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[12] 菲利普·瓦德勒，*将程序转换为消除树*：[http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps](http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps)'
