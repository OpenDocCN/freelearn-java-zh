- en: Chapter 9. A Reactive API to Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have learned a number of tools and techniques to aid
    us in building reactive applications—futures with imminent, Observables with RxClojure/RxJava,
    channels with `core.async`—and even in building reactive user interfaces using
    Om and React.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we also became acquainted with the concept of **Functional Reactive
    Programming** and **Compositional Event Systems**, as well as what makes them
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this last chapter, we will bring a few of these different tools and concepts
    together by developing an application based on a real-world use case from a client
    I worked with in Sydney, Australia. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the problem of infrastructure automation we were trying to solve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a brief look at some of Amazon's AWS services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an AWS dashboard using the concepts we have learned so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This client—which we will call BubbleCorp from now on—had a big problem that
    is all too common and well known to big enterprises: one massive monolithic application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides making them move slow, as individual components can''t be evolved independently,
    this application makes deployment incredibly hard due to its environment constraints:
    all infrastructure needs to be available in order for the application to work
    at all.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, developing new features and bug fixes involves having only a handful
    of development environments shared across dozens of developers each. This requires
    a wasteful amount of coordination between teams just so that they won't step on
    each other's toes, contributing to slow the whole life-cycle further.
  prefs: []
  type: TYPE_NORMAL
- en: The long-term solution to this problem is to break down this big application
    into smaller components, which can be deployed and worked on independently, but
    as good as this sounds, it's a laborious and lengthy process.
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, BubbleCorp decided the best thing they could improve in the
    short term is to give developers the ability to work in the application independently
    from each other, which implies being able to create a new environment as well.
  prefs: []
  type: TYPE_NORMAL
- en: Given the infrastructure constraints, running the application on a single developer
    machine is prohibitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, they turned to infrastructure automation: they wanted a tool that,
    with the press of a button, would spin up a completely new environment.'
  prefs: []
  type: TYPE_NORMAL
- en: This new environment would be already preconfigured with the proper application
    servers, database instances, DNS entries, and everything else needed to run the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This way, developers would only need to deploy their code and test their changes,
    without having to worry about the application setup.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) is the most mature and comprehensive cloud
    computing platform available today, and as such it was a natural choice for BubbleCorp
    to host its infrastructure in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t used AWS before, don''t worry, we''ll focus only on a few of
    its services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elastic Compute Cloud** (**EC2**): A service that provides users with the
    ability to rent virtual computers in which to run their applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relational Database Service** (**RDS**): This can be thought of as a specialized
    version of EC2 that provides managed database services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFormation**: With CloudFormation, users have the ability to specify
    infrastructure templates, called stacks, of several different AWS resources—such
    as EC2, AWS, and many others—as well as how they interact with each other. Once
    written, the infrastructure template can be sent to AWS to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For **BubbleCorp**, the idea was to write these infrastructure templates, which
    once submitted would result into a completely new, isolated environment containing
    all data and components required to run its app. At any given time, there would
    be dozens of these environments running with developers working on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As decent a plan as this sounds, big corporations usually have an added burden:
    cost centers. Unfortunately, BubbleCorp can''t simply allow developers to log
    into the AWS Console—where we can manage AWS resources—and spin up environments
    at will. They needed a way to, among other things, add cost center metadata to
    the environment to handle their internal billing process.'
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the application we will be focusing on for the remainder of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: AWS resources dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My team and I were tasked with building a web-based dashboard for AWS. This
    dashboard would allow developers to log in using their BubbleCorp's credentials
    and, once authenticated, create new CloudFormation environments as well as visualize
    the status of each individual resource within a CloudFormation stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application itself is fairly involved, so we will focus on a subset of
    it: interfacing with the necessary AWS services in order to gather information
    about the status of each individual resource in a given CloudFormation stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once finished, this is what our simplified dashboard will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS resources dashboard](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It will display the ID, type, and current status of each resource. This might
    not seem like much for now, but given that all this information is coming from
    different, independent web services, it is far too easy to end up with unnecessarily
    complex code.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using ClojureScript for this and therefore the JavaScript version
    of the AWS SDK, whose documentation can be found at [http://aws.amazon.com/sdk-for-node-js/](http://aws.amazon.com/sdk-for-node-js/).
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, let's have a look at each of the AWS Services APIs we
    will be interacting with.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, we will not be interacting with the real AWS services but rather
    a stub server provided for download from the book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is to make following this chapter easier, as you won't need
    to create an account as well as generate an API access key to interact with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, creating resources incurs cost, and the last thing I want is for
    you to be charged hundreds of dollars at the end of the month because someone
    accidentally left resources running for longer than they should—trust me it has
    happened before.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first service we will look at is CloudFormation. This makes sense as the
    APIs found in here will give us a starting point for finding information about
    the resources in a given stack.
  prefs: []
  type: TYPE_NORMAL
- en: The describeStacks endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This endpoint is responsible for listing all stacks associated with a particular
    AWS account. For a given stack, its response looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, it doesn't say anything about which resources belong to this
    stack. It does, however, give us the stack name, which we can use to look up resources
    in the next service.
  prefs: []
  type: TYPE_NORMAL
- en: The describeStackResources endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This endpoint receives many arguments, but the one we''re interested in is
    the stack name, which, once provided, returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We seem to be getting somewhere now. This stack has several resources: three
    EC2 instances and two RDS instances—not too bad for only two API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: However, as we mentioned previously, our dashboard needs to show the status
    of each of the resources. With the list of resource IDs at hand, we need to look
    to other services that could give us detailed information about each resource.
  prefs: []
  type: TYPE_NORMAL
- en: EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next service we will look at is specific to EC2\. As we will see, the responses
    of the different services aren't as consistent as we would like them to be.
  prefs: []
  type: TYPE_NORMAL
- en: The describeInstances endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This endpoint sounds promising. Based on the documentation, it seems we can
    give it a list of instance IDs and it will give us back the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Buried in this response, we can see the `State` key, which gives us the status
    of that particular EC2 instance. This is all we need as far as EC2 goes. This
    leaves us with RDS to handle.
  prefs: []
  type: TYPE_NORMAL
- en: RDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One might be tempted to think that getting the statuses of RDS instances would
    be just as easy as with EC2\. Let's see if that is the case.
  prefs: []
  type: TYPE_NORMAL
- en: The describeDBInstances endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This endpoint is equivalent in purpose to the analogous EC2 endpoint we just
    looked at. Its input, however, is slightly different: it accepts a single instance
    ID as input and, as of the time of this writing, doesn''t support filters.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if our stack has multiple RDS instances—say, in a primary/replica
    setup—we need to make multiple API calls to gather information about each one
    of them. Not a big deal, of course, but a limitation to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once given a specific database instance ID, this service responds with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The fact that a single instance comes inside a vector hints at the fact that
    filtering will be supported in the future. It just hasn't happened yet.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have all the information we need to start designing our application.
    We need to coordinate four different API calls per CloudFormation stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describeStacks`: To list all available stacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describeStackResources`: To retrieve details of all resources contained in
    a stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describeInstances`: To retrieve details of all EC2 instances in a stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describeDBInstances`: To retrieve details of all DB2 instances in a stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I would like you to step back for a moment and think about how you would
    design code like this. Go ahead, I'll wait.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you're back, let's have a look at one possible approach.
  prefs: []
  type: TYPE_NORMAL
- en: If we recall the screenshot of what the dashboard would look like, we realize
    that, for the purposes of our application, the difference between EC2 and RDS
    resources can be completely ignored so long as each one has the attributes ID,
    type, and status.
  prefs: []
  type: TYPE_NORMAL
- en: This means whatever our solution may be, it has to somehow provide a uniform
    way of abstracting the different resource types.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, apart from `describeStacks` and `describeStackResources`, which
    need to be called sequentially, `describeInstances` and `describeDBInstances`
    can be executed concurrently, after which we will need a way to merge the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since an image is worth a thousand words, the following image is what we would
    like the workflow to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the solution](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image highlights a number of key aspects of our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by retrieving stacks by calling `describeStacks`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, for each stack, we call `describeStackResources` to retrieve a list of
    resources for each one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we split the list by type, ending with a list of EC2 and one with RDS
    resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We proceed by concurrently calling `describeInstances` and `describeDBInstances`,
    yielding two lists of results, one per resource type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the response formats are different, we transform each resource into a uniform
    representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we merge all results into a single list, ready for rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is quite a bit to take in, but as you will soon realize, our solution isn't
    too far off this high-level description.
  prefs: []
  type: TYPE_NORMAL
- en: We can quite easily think of this problem as having information about several
    different types of instances flowing through this graph of API calls—being transformed
    as needed in between—until we arrive at the information we're after, in the format
    we would like to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, a great way to model this problem is to use one of the Reactive
    abstractions we learned about earlier in this book: Observables.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the AWS stub server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we jump into writing our dashboard, we should make sure our AWS stub
    server is properly set up. The stub server is a Clojure web application that simulates
    how the real AWS API behaves and is the backend our dashboard will talk to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by going into our terminal, cloning the book repository using
    Git and then starting the stub server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have started the server on port 3001\. To validate it is working
    as expected, point your browser to `http://localhost:3001/cloudFormation/describeStacks`.
    You should see the following JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the dashboard project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we previously mentioned, we will be developing the dashboard using ClojureScript
    with the UI rendered using Om. Additionally, as we have chosen Observables as
    our main Reactive abstraction, we will need RxJS, one of the many implementations
    of Microsoft's Reactive Extensions. We will be pulling these dependencies into
    our project shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new ClojureScript project called `aws-dash` using the `om-start`
    leiningen template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a starting point, but we should make sure our versions all match.
    Open up the `project.clj` file found in the root directory of the new project
    and ensure the dependencies section looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the first time we see the last two dependencies. `cljs-http` is a simple
    HTTP library we will use to make AJAX requests to our AWS stub server. `transit-cljs`
    allows us to, among other things, parse JSON responses into ClojureScript data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transit itself is a format and a set of libraries through which applications
    developed in different technologies can speak to each other. In this case, we
    are using the Clojurescript library to parse JSON, but if you're interested in
    learning more, I recommend reading the official blog post announcement by Rich
    Hickey at [http://blog.cognitect.com/blog/2014/7/22/transit](http://blog.cognitect.com/blog/2014/7/22/transit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need RxJS, which, being a JavaScript dependency, isn''t available
    via leiningen. That''s OK. We will simply download it into the application output
    directory, `aws-dash/dev-resources/public/js/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, we need to make our application aware of our new dependency on RxJS.
    Open the `aws-dash/dev-resources/public/index.html` file and add a script tag
    to pull in RxJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the dependencies in place, let''s start the auto-compilation for our
    ClojureScript source files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating AWS Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're now ready to start implementing our solution. If you recall from the Reactive
    Extensions chapter, `RxJava/RxJS/RxClojure` ship with several useful Observables.
    However, when the built-in Observables aren't enough, it gives us the tools to
    build our own.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is highly unlikely RxJS already provides Observables for Amazon's AWS
    API, we will start by implementing our own primitive Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things neat, we will do this in a new file, under `aws-dash/src/cljs/aws_dash/observables.cljs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The namespace declaration requires the necessary dependencies we will need in
    this file. Note how there is no explicit dependency on RxJS. Since it is a JavaScript
    dependency that we manually pulled in, it is globally available for us to use
    via JavaScript interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: The next line sets up a `transit` reader for JSON, which we will use when parsing
    the stub server responses.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the endpoint we will be talking to as well as a helper function
    to build the correct URIs. Make sure the variable `aws-endpoint` matches the host
    and port of the stub server started in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Observables we are about to create follow a common structure: they make
    a request to the stub server, extract some information from the response, optionally
    transforming it, and then emit each item in the transformed sequence into the
    new Observable sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid repetition, this pattern is captured in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this function down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`observable-seq` receives two arguments: the backend URI to which we will issue
    a GET request, and a `transform` function which is given the raw parsed JSON response
    and returns a sequence of transformed items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, it calls the `create` function of the RxJS object `Rx.Observable`. Note
    how we make use of JavaScript interoperability here: we access the create function
    by prepending it with a dot much like in Java interoperability. Since `Rx.Observable`
    is a global object, we access it by prepending the global JavaScript namespace
    ClojureScript makes available to our program, `js/Rx.Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observable's create function receives two arguments. One is a function that
    gets called with an Observer to which we can push items to be published in the
    Observable sequence. The second function is a function that is called whenever
    this Observable is disposed of. This is the function where we could perform any
    cleanup needed. In our case, this function simply logs the fact that it is called
    to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first function is the one that interests us though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As soon as it gets called, it performs a request to the provided URI using cljs-http's
    `get` function, which returns a `core.async` channel. That's why the whole logic
    is inside a `go` block.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the transit JSON reader we configured previously to parse the body
    of the response, feeding the result into the `transform` function. Remember this
    function, as per our design, returns a sequence of things. Therefore, all that
    is left to do is push each item into the observer in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Once we're done, we indicate that this Observable sequence won't emit any new
    item by invoking the `.onCompleted` function of the `observer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can proceed creating our Observables using this helper function, starting
    with the one responsible for retrieving CloudFormation stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an observable that will emit one item per stack, in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have stacks, we need an Observable to describe its resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It has a similar purpose and emits resource items in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re following our strategy almost to the letter, we need two more
    observables, one for each instance type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of which will emit resource items in the following formats for EC2 and
    RDS, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Combining the AWS Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems we have all major pieces in place now. All that is left to do is to
    combine the more primitive, basic Observables we just created into more complex
    and useful ones by combining them to aggregate all the data we need in order to
    render our dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a function that combines both the `describe-stacks`
    and `describe-stack-resources` Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting in the previous example, we begin to see how defining our API calls
    in terms of Observable sequences pays off: it''s almost simple combining these
    two Observables in a declarative manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the role of `flatMap`: as `describe-stack-resources` itself returns
    an Observable, we use `flatMap` to flatten both Observables, as we have done before
    in various different abstractions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `stack-resources` Observable will emit resource items for all stacks. According
    to our plan, we would like to fork the processing here in order to concurrently
    retrieve EC2 and RDS instance data.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this train of thought, we arrive at two more functions that combine
    and transform the previous Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both the functions receive an argument, resources, which is the result of calling
    the `stack-resources` Observable. That way, we only need to call it once.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, it is fairly simple to combine the Observables in a way that makes
    sense, following our high-level idea described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with `resources`, we filter out the types we're not interested in,
    retrieve its IDs, and request its detailed information by flatmapping the `describe-instances`
    and `describe-db-instances` Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that due to a limitation in the RDS API described earlier, we
    have to call it multiple times to retrieve information about all RDS instances.
  prefs: []
  type: TYPE_NORMAL
- en: This seemingly fundamental difference in how we use the API becomes a minor
    transformation in our EC2 observable, which simply accumulates all IDs into a
    vector so that we can retrieve them all at once.
  prefs: []
  type: TYPE_NORMAL
- en: Our simple Reactive API to Amazon AWS is now complete, leaving us with the UI
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now turn to building our user interface. It''s a simple one, so let''s
    just jump into it. Open up `aws-dash/src/cljs/aws_dash/core.cljs` and add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our application state contains a single key, `:instances`, which starts as an
    empty vector. As we can see from each Om component, instances will be rendered
    as rows in a HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving the file, make sure the web server is running by starting it from
    the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able point your browser to `http://localhost:3000/`, but,
    as you might have guessed, you will see nothing but an empty table.
  prefs: []
  type: TYPE_NORMAL
- en: This is because we haven't yet used our Reactive AWS API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix it and bring it all together at the bottom of `core.cljs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Yes, this is all we need! We create a `stack-resources` Observable and pass
    it as an argument to both `rds-instance-status` and `ec2-instance-status`, which
    will concurrently retrieve status information about all instances.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new Observable by merging the previous two followed by a call
    to `.reduce`, which will accumulate all information into a vector, convenient
    for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we simply subscribe to this Observable and, when it emits its results,
    we simply update our application state, leaving Om to do all the rendering for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and make sure ClojureScript has compiled successfully. Then, go
    back to your browser at `http://localhost:3000/`, and you should see all instance
    statuses, as pictured at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our previous approach, the only way to see new information about the AWS
    resources is by refreshing the whole page. Modify our implementation in such a
    way that it queries the stub services every so often—say, every 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `interval` function from RxJS can be helpful in solving this exercise. Think
    how you might use it together with our existing stream by reviewing how `flatMap`
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at a real use case for Reactive applications: building
    a dashboard for AWS CloudFormation stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how thinking of all the information needed as resources/items flowing
    through a graph fits nicely with how one creates Observables.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, by creating primitive Observables that do one thing only gives
    us a nice declarative way to combine them into more complex Observables, giving
    us a degree of reuse not usually found with common techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we packaged it together with a simple Om-based interface to demonstrate
    how using different abstractions in the same application does not add to complexity
    as long as the abstractions are chosen carefully for the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of what hopefully was an enjoyable and informative
    journey through the different ways of Reactive Programming.
  prefs: []
  type: TYPE_NORMAL
- en: Far from being a complete reference, this book aims to provide you, the reader,
    with enough information, as well as concrete tools and examples that you can apply
    today.
  prefs: []
  type: TYPE_NORMAL
- en: It is also my hope that the references and exercises included in this book prove
    themselves useful, should you wish to expand your knowledge and seek out more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, I strongly encourage you to turn the page and read the [Appendix](part0070_split_000.html#page
    "Appendix A. The Algebra of Library Design") , *The Algebra of Library Design*,
    as I truly believe it will, if nothing else, make you think hard about the importance
    of composition in programming.
  prefs: []
  type: TYPE_NORMAL
- en: I sincerely wish this book has been as entertaining and instructional to read
    as it was to write.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading. I look forward to seeing the great things you build.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. The Algebra of Library Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed that all reactive abstractions we have encountered in
    this book have a few things in common. For one, they work as "container-like"
    abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: Futures encapsulate a computation that eventually yields a single value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables encapsulate computations that can yield multiple values over time
    in the shape of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels encapsulate values pushed to them and can have them popped from it,
    working as a concurrent queue through which concurrent processes communicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, once we have this "container," we can operate on it in a number of ways,
    which are very similar across the different abstractions and frameworks: we can
    `filter` the values contained in them, transform them using `map`, combine abstractions
    of the same type using `bind`/`flatMap`/`selectMany`, execute multiple computations
    in parallel, aggregate the results using `sequence`, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: As such, even though the abstractions and their underlying workings are fundamentally
    different, it still feels they belong to some type of higher-level abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix, we will explore what these higher-level abstractions are,
    the relationship between them, and how we can take advantage of them in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: The semantics of map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will get started by taking a look at one of the most used operations in
    these abstractions: `map`.'
  prefs: []
  type: TYPE_NORMAL
- en: We've been using `map` for a long time in order to transform sequences. Thus,
    instead of creating a new function name for each new abstraction, library designers
    simply abstract the `map` operation over its own container type.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the mess we would end up in if we had functions such as `transform-observable`,
    `transform-channel`, `combine-futures`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, this is not the case. The semantics of `map` are well understood
    to the point that even if a developer hasn't used a specific library before, he
    will almost always assume that `map` will apply a function to the value(s) contained
    within whatever abstraction the library provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at three examples we encountered in this book. We will create a
    new leiningen project in which to experiment with the contents of this appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add a few dependencies to our `project.clj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about the last dependency—we'll get to it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start an REPL session so that we can follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enter the following into your REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The three examples—using imminent, RxClojure, and core.async, respectively—look
    remarkably similar. They all follow a simple recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the number 31 inside their respective abstraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double that number by mapping a function over the abstraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print its result to the REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As expected, this outputs the value `62` three times to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would seem `map` performs the same abstract steps in all three cases: it
    applies the provided function, puts the resulting value in a fresh new container,
    and returns it. We could continue generalizing, but we would just be rediscovering
    an abstraction that already exists: Functors.'
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functors are the first abstraction we will look at and they are rather simple:
    they define a single operation called `fmap`. In Clojure, Functors can be represented
    using protocols and are used for containers that can be mapped over. Such containers
    include, but are not limited to, lists, Futures, Observables, and channels.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Algebra* in the title of this *Appendix* refers to **Abstract Algebra**,
    a branch of Mathematics that studies algebraic structures. An algebraic structure
    is, to put it simply, a set with one or more operations defined on it.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider **Semigroups**, which is one such algebraic structure.
    It is defined to be a set of elements together with an operation that combines
    any two elements of this set. Therefore, the set of positive integers together
    with the addition operation form a Semigroup.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool used for studying algebraic structures is called Category Theory,
    of which Functors are part of.
  prefs: []
  type: TYPE_NORMAL
- en: We won't delve too much into the theory behind all this, as there are plenty
    of books [9][10] available on the subject. It was, however, a necessary detour
    to explain the title used in this appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean all of these abstractions implement a Functor protocol? Unfortunately,
    this is not the case. As Clojure is a dynamic language and it didn't have protocols
    built in—they were added in version 1.2 of the language—these frameworks tend
    to implement their own version of the `map` function, which doesn't belong to
    any protocol in particular.
  prefs: []
  type: TYPE_NORMAL
- en: The only exception is imminent, which implements the protocols included in `fluokitten`,
    a Clojure library providing concepts from Category theory such as Functors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified version of the Functor protocol found in `fluokitten`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, Functors define a single operation. `fmap` applies
    the function `g` to whatever value is inside the container, Functor, `fv`.
  prefs: []
  type: TYPE_NORMAL
- en: However, implementing this protocol does not guarantee that we have actually
    implemented a Functor. This is because, in addition to implementing the protocol,
    Functors are also required to obey a couple of laws, which we will examine briefly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The identity law is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is all we need to verify this law. It simply says that mapping
    the `identity` function over `a-functor` is the same as simply applying the `identity`
    function to the Functor itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition law is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The composition law, in turn, says that if we compose two arbitrary functions
    `f` and `g`, take the resulting function and apply that to `a-functor`, that is
    the same as mapping `g` over the Functor and then mapping `f` over the resulting
    Functor.
  prefs: []
  type: TYPE_NORMAL
- en: No amount of text will be able to replace practical examples, so we will implement
    our own Functor, which we will call `Option`. We will then revisit the laws to
    ensure we have respected them.
  prefs: []
  type: TYPE_NORMAL
- en: The Option Functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Tony Hoare once put it, null references are his one billion dollar mistake
    ([http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)).
    Regardless of background, you no doubt will have encountered versions of the dreadful
    `NullPointerException`. This usually happens when we try to call a method on an
    object reference that is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure embraces null values due to its interoperability with Java, its host
    language, but it provides improved support for dealing with them.
  prefs: []
  type: TYPE_NORMAL
- en: The core library is packed with functions that do the right thing if passed
    a nil value—Clojure's version of Java's `null`. For instance, how many elements
    are there in a `nil` sequence?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to conscious design decisions regarding `nil`, we can, for the most part,
    afford not worry about it. For all other cases, the `Option` Functor might be
    of some help.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining of the examples in this appendix should be in a file called `option.clj`
    under `library-design/src/library_design/`. You're welcome to try this in the
    REPL as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our next example by adding the namespace declaration as well as
    the data we will be working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As a Pirates of the Caribbean fan, I thought it would be interesting to play
    with pirates for this example. Let''s say we would like to calculate Jack Sparrow''s
    age. Given the data and functions we just covered, this is a simple task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what if we would like to know Davy Jones'' age? We don''t actually
    have any data for this pirate, so if we run our program again, this is what we''ll
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There it is. The dreadful `NullPointerException`. This happens because in the
    implementation of the age function, we end up trying to subtract two `nil` values,
    which is incorrect. As you might have guessed, we will attempt to fix this by
    using the `Option` Functor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, `Option` is implemented as an algebraic data type, more specifically
    a sum type with two variants: `Some` and `None`. These variants are used to identify
    whether a value is present or not without using `nils`. You can think of both
    `Some` and `None` as subtypes of `Option`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, we will represent them using records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `Some` can contain a single value whereas `None` contains nothing.
    It's simply a marker indicating the absence of content. We have also created a
    helper function called `option`, which creates the appropriate record depending
    on whether its argument is `nil` or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to extend the `Functor` protocol to both records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s where the semantic meaning of the `Option` Functor becomes apparent:
    as `Some` contains a value, its implementation of `fmap` simply applies the function
    `g` to the value inside the Functor `f`, which is of type `Some`. Finally, we
    put the result inside a new `Some` record.'
  prefs: []
  type: TYPE_NORMAL
- en: Now what does it mean to map a function over a `None`? You probably guessed
    that it doesn't really make sense—the `None` record holds no values. The only
    thing we can do is return another `None`. As we will see shortly, this gives the
    `Option` Functor a short-circuiting semantic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `fmap` implementation of `None`, we could have returned a reference to
    `this` instead of a new record instance. I've not done so simply to make it clear
    that we need to return an instance of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve implemented the Functor protocol, we can try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first example shouldn't hold any surprises. We convert the pirate map we
    get from calling `pirate-by-name` into an option, and then `fmap` the age function
    over it.
  prefs: []
  type: TYPE_NORMAL
- en: The second example is the interesting one. As stated previously, we have no
    data about Davy Jones. However, mapping `age` over it does not throw an exception
    any longer, instead returning `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem like a small benefit, but the bottom line is that the `Option`
    Functor makes it safe to chain operations together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, some readers might be thinking about the `some->` macro—introduced
    in Clojure 1.5—and how it effectively achieves the same result as the `Option`
    Functor. This intuition is correct as demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `some->` macro threads the result of the first expression through the first
    form if it is not `nil`. Then, if the result of that expression isn't `nil`, it
    threads it through the next form and so on. As soon as any of the expressions
    evaluates to nil, `some->` short-circuits and returns nil immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, Functor is a much more general concept, so as long as we are
    working with this concept, our code doesn''t need to change as we are operating
    at a higher level of abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, even though we are working with a fundamentally different
    tool—futures—the code using the result did not have to change. This is only possible
    because both Options and futures are Functors and implement the same protocol
    provided by fluokitten. We have gained composability and simplicity as we can
    use the same API to work with various different abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of composability, this property is guaranteed by the second law of
    Functors. Let''s see if our Option Functor respects this and the first—the identity—laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And we're done, our `Option` Functor is a lawful citizen. The remaining two
    abstractions also come paired with their own laws. We will not cover the laws
    in this section, but I encourage the reader to read about them ([http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/](http://www.leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/)).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the average of ages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore a different use case for the `Option` Functor.
    We would like to, given a number of pirates, calculate the average of their ages.
    This is simple enough to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note how we are using `some->` here to protect us from `nil` values. Now, what
    happens if there is a pirate for which we have no information?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It seems we're back at square one! It's worse now because using `some->` doesn't
    help if we need to use all values at once, as opposed to threading them through
    a chain of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, not all is lost. All we need to do is check if all values are present
    before calculating the average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: While this works perfectly fine, our implementation suddenly had to become aware
    that any or all of the values `a`, `b`, and `c` could be `nil`. The next abstraction
    we will look at, Applicative Functors, fixes this.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like Functors, **Applicative Functors** are a sort of container and defines
    two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `pure` function is a generic way to put a value inside an Applicative Functor.
    So far, we have been using the `option` helper function for this purpose. We will
    be using it a little later.
  prefs: []
  type: TYPE_NORMAL
- en: The `fapply` function will unwrap the function contained in the Applicative
    `ag` and apply it to the value contained in the applicative `av`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of both the functions will become clear with an example, but first,
    we need to promote our `Option` Functor into an Applicative Functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `pure` is the simplest. All it does is wrap the value
    `v` into an instance of `Some`. Equally simple is the implementation of `fapply`
    for `None`. As there is no value, we simply return `None` again.
  prefs: []
  type: TYPE_NORMAL
- en: The `fapply` implementation of `Some` ensures both arguments have a value for
    the `:v` keyword—strictly speaking they both have to be instances of `Some`. If
    `:v` is non-nil, it applies the function contained in `ag` to `v`, finally wrapping
    the result. Otherwise, it returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should be enough to try our first example using the Applicative Functor
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We are now able to work with Functors that contain functions. Additionally,
    we have also preserved the semantics of what should happen when any of the Functors
    don't have a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now revisit the age average example from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `vararg` function `<*>` is defined by fluokitten and performs a left-associative
    `fapply` on its arguments. Essentially, it is a convenience function that makes
    `(<*> f g h)` equivalent to `(fapply (fapply f g) h)`.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a helper function to avoid repetition. The `age-option`
    function retrieves the age of a pirate as an option for us.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we curry the `avg` function to `3` arguments and put it into an option.
    Then, we use the `<*>` function to apply it to the options a, b, and c. We get
    to the same result, but have the Applicative Functor take care of nil values for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Function currying**'
  prefs: []
  type: TYPE_NORMAL
- en: Currying is the technique of transforming a function of multiple arguments into
    a higher-order function of a single argument that returns more single-argument
    functions until all arguments have been supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly speaking, currying makes the following snippets equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Applicative Functors this way is so common that the pattern has been
    captured as the function `alift`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `alift` function is responsible for lifting a function in such a way that
    it can be used with Applicative Functors without much ceremony. Because of the
    assumptions we are able to make about Applicative Functors—for instance, that
    it is also a Functor—we can write generic code that can be re-used across any
    Applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `alift` in place, our age average example turns into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We lift `avg` into an Applicative compatible version, making the code look
    remarkably like simple function application. And since we are not doing anything
    interesting with the let bindings, we can simplify it further as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Functors, we can take the code as it is, and simply replace the underlying
    abstraction, preventing repetition once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Gathering stats about ages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can safely calculate the average age of a number of pirates, it
    might be interesting to take this further and calculate the median and standard
    deviation of the pirates' ages, in addition to their average age.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a function to calculate the average, so let''s just create
    the ones to calculate the median and the standard deviation of a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions in place, we can write the code that will gather all the
    stats for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is fairly straightforward. We first retrieve all ages we're
    interested in and bind them to the locals `a`, `b`, and `c`. We then reuse the
    values when calculating the remaining stats. We finally gather all results in
    a map for easy access.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now the reader will probably know where we''re headed: what if any of those
    values is `nil`?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The second binding, `b`, returns `nil`, as we don''t have any information about
    Davy Jones. As such, it causes the calculations to fail. Like before, we can change
    our implementation to protect us from such failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This time it''s even worse than when we only had to calculate the average;
    the code is checking for `nil` values in four extra spots: before calling the
    three stats functions and just before gathering the stats into the result map.'
  prefs: []
  type: TYPE_NORMAL
- en: Can we do better?
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last abstraction will solve the very problem we raised in the previous
    section: how to safely perform intermediate calculations by preserving the semantics
    of the abstractions we''re working with—in this case, options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be no surprise now that fluokitten also provides a protocol for Monads,
    simplified and shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If you think in terms of a class hierarchy, Monads would be at the bottom of
    it, inheriting from Applicative Functors, which, in turn, inherit from Functors.
    That is, if you're working with a Monad, you can assume it is also an Applicative
    and a Functor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bind` function of monads takes a function `g` as its second argument.
    This function receives as input the value contained in `mv` and returns another
    Monad containing its result. This is a crucial part of the contract: `g` has to
    return a Monad.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why will become clearer after some examples. But first, let''s promote
    our Option abstraction to a Monad—at this point, Option is already an Applicative
    Functor and a Functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is fairly simple. In the `None` version, we can't really
    do anything, so just like we have been doing so far, we return an instance of
    `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Some` implementation extracts the value from the Monad `mv` and applies
    the function `g` to it. Note how this time we don't need to wrap the result as
    the function `g` already returns a Monad instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Monad API, we could sum the ages of our pirates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we are making use of Applicative's `pure` function in the inner-most
    function. Remember that role of `pure` is to provide a generic way to put a value
    into an Applicative Functor. Since Monads are also Applicative, we make use of
    them here.
  prefs: []
  type: TYPE_NORMAL
- en: However, since Clojure is a dynamically typed language, we need to hint pure
    with the context—container—type we wish to use. This context is simply an instance
    of either `Some` or `None`. They both have the same pure implementation.
  prefs: []
  type: TYPE_NORMAL
- en: While we do get the right answer, the preceding example is far from what we
    would like to write due to its excessive nesting. It is also hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, fluokitten provides a much better way to write monadic code, called
    the do-notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Suddenly, the same code becomes a lot cleaner and easier to read, without losing
    any of the semantics of the Option Monad. This is because `mdo` is a macro that
    expands to the code equivalent of the nested version, as we can verify by expanding
    the macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to stop for a moment here and appreciate the power of Clojure—and
    Lisp in general.
  prefs: []
  type: TYPE_NORMAL
- en: Languages such as Haskell and Scala, which make heavy use of abstractions such
    as Functors, Applicative, and Monads, also have their own versions of the do-notation.
    However, this support is baked into the compiler itself.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, when Haskell added do-notation to the language, a new version
    of the compiler was released, and developers wishing to use the new feature had
    to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, on the other hand, this new feature can be shipped as a library
    due to the power and flexibility of macros. This is exactly what fluokitten has
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to go back to our original problem, gathering stats about
    the pirates' ages.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a couple of helper functions that convert the result
    of our stats functions into the Option Monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we take advantage of function composition to create monadic versions of
    existing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will rewrite our solution using the monadic do-notation we learned
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we were able to write the function as we normally would, without
    having to worry about whether any values in the intermediate computations are
    empty or not. This semantic that is the very essence of the Option Monad is still
    preserved, as can be seen in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of completeness, we will use futures to demonstrate how the do-notation
    works for any Monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This appendix has taken us on a brief tour of the world of category theory.
    We learned three of its abstractions: Functors, Applicative Functors, and Monads.
    They were the guiding principle behind imminent''s API.'
  prefs: []
  type: TYPE_NORMAL
- en: To deepen our knowledge and understanding, we implemented our own Option Monad,
    a common abstraction used to safely handle the absence of values.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen that using these abstractions allow us to make some assumptions
    about our code, as seen in functions such as `alift`. There are many other functions
    we would normally rewrite over and over again for different purposes, but that
    can be reused if we recognize our code fits into one of the abstractions learned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I hope this encourages readers to explore category theory more, as
    it will undoubtedly change the way you think. And if I can be so bold, I hope
    this will also change the way you design libraries in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B. Bibliography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] Rene Pardo and Remy Landau, *The World''s First Electronic Spreadsheet*:
    [http://www.renepardo.com/articles/spreadsheet.pdf](http://www.renepardo.com/articles/spreadsheet.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Conal Elliott and Paul Hudak, *Functional Reactive Animation*: [http://conal.net/papers/icfp97/icfp97.pdf](http://conal.net/papers/icfp97/icfp97.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Evan Czaplicki, *Elm: Concurrent FRP for Functional GUIs*: [http://elm-lang.org/papers/concurrent-frp.pdf](http://elm-lang.org/papers/concurrent-frp.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Erik Meijer, *Subject/Observer is Dual to Iterator*: [http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf](http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] Henrik Nilsson, Antony Courtney and John Peterson, *Functional Reactive
    Programming, Continued*: [http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] John Hughes, *Generalising Monads to Arrows*: [http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Zhanyong Wan, Walid Taha and Paul Hudak, *Real-Time FRP*: [http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/rt-frp.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] Walid Taha, Zhanyong Wan, and Paul Hudak, *Event-Driven FRP*: [http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf](http://www.cs.yale.edu/homes/zwan/papers/mcu/efrp.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] Benjamin C. Pierce, *Basic Category Theory for Computer Scientists*: [http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&qid=1423484917&sr=8-7&keywords=category+theory](http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing-ebook/dp/B00MG7E5WE/ref=sr_1_7?ie=UTF8&qid=1423484917&sr=8-7&keywords=category+theory)'
  prefs: []
  type: TYPE_NORMAL
- en: '[10] Steve Awodey, *Category Theory (Oxford Logic Guides)*: [http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&qid=1423484917&sr=8-2&keywords=category+theory](http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_2?ie=UTF8&qid=1423484917&sr=8-2&keywords=category+theory)'
  prefs: []
  type: TYPE_NORMAL
- en: '[11] Duncan Coutts, Roman Leshchinskiy, and Don Stewart, *Stream Fusion*: [http://code.haskell.org/~dons/papers/icfp088-coutts.pdf](http://code.haskell.org/~dons/papers/icfp088-coutts.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[12] Philip Wadler, *Transforming programs to eliminate trees*: [http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps](http://homepages.inf.ed.ac.uk/wadler/papers/deforest/deforest.ps)'
  prefs: []
  type: TYPE_NORMAL
