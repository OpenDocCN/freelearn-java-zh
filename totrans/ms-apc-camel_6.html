<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Components and Endpoints"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Components and Endpoints</h1></div></div></div><p>In the previous chapters, we have seen how to implement mediation logic and routing using processors or beans. However, both expect an incoming Exchange. It's one of the key purposes of the components and endpoints—a component creates endpoints. We have two kinds of endpoints—the producer responsible for creating Exchanges and the consumer who consumes incoming Exchanges.</p><p>The components and endpoints are responsible for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interacting with the external systems and Exchanges</li><li class="listitem" style="list-style-type: disc">Providing and handling specific data formats or transformation</li></ul></div><p>To understand these concepts, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What are components and endpoints?</li><li class="listitem" style="list-style-type: disc">Existing components and how to use them</li><li class="listitem" style="list-style-type: disc">How to create our own component and endpoints</li></ul></div><div class="section" title="Components"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Components</h1></div></div></div><p>The components are<a id="id329" class="indexterm"/> the main Camel extension point. Basically, a component is<a id="id330" class="indexterm"/> a factory of endpoints that you use in routes. If you take a look in the <code class="literal">Component</code> interface, you can see the following code:</p><div class="informalexample"><pre class="programlisting">public interface Component extends CamelContextAware {
   
   Endpoint createEndpoint(String uri) throws Exception;
   
   EndpointConfiguration createConfiguration(String uri) throws Exception;

   ComponentConfiguration createComponentConfiguration();

   boolean useRawUri();

}</pre></div><p>You can see that a <code class="literal">Component</code> <span class="emphasis"><em>lives</em></span> in the <code class="literal">CamelContext</code> (as it extends the <code class="literal">CamelContextAware</code> interface). This means that we instantiate a <code class="literal">Component</code> and add the instance in the <code class="literal">CamelContext</code>.</p><p>The <code class="literal">Component</code> is<a id="id331" class="indexterm"/> stored in the <code class="literal">CamelContext</code> using a unique identifier—the <code class="literal">scheme</code>. Later in the chapter, we will see that this schema is used to refer the <code class="literal">Component</code> in the route definition.</p><div class="section" title="Bootstrapping a component"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Bootstrapping a component</h2></div></div></div><p>A component can be bootstrapped in two ways.</p><p>The first way is to<a id="id332" class="indexterm"/> explicitly instantiate the <code class="literal">Component</code>. You can do that using code.</p><p>For instance, we can explicitly instantiate the <code class="literal">MockComponent</code> and add it in the <code class="literal">CamelContext</code> using two schemes (the expected one <code class="literal">mock</code>, and a custom one <code class="literal">my</code>):</p><div class="informalexample"><pre class="programlisting">MockComponent mockComponent = new MockComponent();
camelContext.addComponent("mock", mockComponent);
camelContext.addComponent("my", mockComponent);</pre></div><p>The second way is implicit. Camel provides a discovery mechanism that can leverage <code class="literal">classloader</code> or the IoC framework (such as Spring). Camel is searching for a file like this in <code class="literal">classloader</code>:</p><p>
<code class="literal">/META-INF/services/org/apache/camel/component/my</code>
</p><p>The <code class="literal">my</code> path is the component scheme name. The file contains the actual class with the component implementation. For instance:</p><div class="informalexample"><pre class="programlisting">class=com.packt.camel.MyComponent</pre></div><p>If Camel finds the class property, it instantiates the component and adds it in the <code class="literal">CamelContext</code>. For instance, just creating the component <code class="literal">bean</code> using <code class="literal">blueprint</code> (or Spring) is enough for Camel to discover a load in the context:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

  &lt;bean class="com.packt.camel.MyComponent"&gt;
  &lt;/bean&gt;

  &lt;camelContext &gt;
  &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre></div><p>When used in an OSGi environment (such as in the Karaf OSGi container), Camel also looks for the components using OSGi services. This means that, in OSGi, a component exposes an OSGi service.</p><p>Currently, Camel provides more than 150 ready-to-use components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some <a id="id333" class="indexterm"/>components are directly provided by <code class="literal">camel-core</code> (the low-level Camel library). For instance, <code class="literal">file</code>, <code class="literal">mock</code>, <code class="literal">bean</code>, <code class="literal">properties</code>, <code class="literal">direct</code>, <code class="literal">direct-vm</code>, <code class="literal">seda</code>, <code class="literal">vm</code>, <code class="literal">rest</code>, <code class="literal">ref</code>, <code class="literal">timer</code>, <code class="literal">xslt</code>, <code class="literal">controlbus</code>, <code class="literal">language</code>, and <code class="literal">log</code> components are directly provided (no need to install additional components).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ahc</code> allows you to communicate with a HTTP service using the Async HTTP Client library from Sonatype.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ahc-ws</code> allows you to communicate with a WebSocket service using the Async Http Client library from Sonatype.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-amqp</code> allows<a id="id334" class="indexterm"/> you to use the AMQP messaging protocol.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-apns</code> allows you to send notifications on Apple iOS devices.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-atmosphere-websocket</code> allows you to communicate with a WebSocket service using the Atmosphere library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-atom</code> allows you to work with Atom feed (internally, using the Apache Abdera library).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-avro</code> allows you to use Apache Avro to serialize data and messages.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-aws</code> allows you to use the Amazon WebService service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-beanstalk</code> allows you to use the Amazon Beanstalk service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-bean-validator</code> allows you to validate message payload using the Java Validation API (JSR-303 or JAXP Validation and the corresponding Hibernate Validator implementation).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-box</code> allows you to manage files located on a <a class="ulink" href="https://www.box.com/">https://www.box.com/</a> account.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-cache</code> allows you to use the caching mechanism in Camel route.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-chunk</code> allows you to create a message using the Chunk template.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-cmis</code> allows you to use the Apache Chemistry Client API with CMIS.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-cometd</code> allows you to deliver messages using the <code class="literal">bayeux</code> protocol (using the Jetty cometd implementation).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-couchdb</code> allows you to interact with the Apache CouchDB database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-crypto</code> allows you to sign and verify message payload using Java Cryptographic Extensions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-cxf</code> allows you to use SOAP and REST web services using Apache CXF.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-dns</code> allows you to manipulate DNS using DNSJava.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-disruptor</code> allows you to use a SEDA-like component (an asynchronous queue) using the disruptor library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-docker</code> allows you to deal with <code class="literal">docker.io</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-dropbox</code> allows <a id="id335" class="indexterm"/>you to manipulate files located on a Dropbox account.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ejb</code> allows you to use EJB3 as regular beans in route definition.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-elasticsearch</code> allows<a id="id336" class="indexterm"/> you to interact with an Elasticsearch database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-spring</code> allows you to integrate a Spring application in a route.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-eventadmin</code> allows you to interact with the OSGi EventAdmin Layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-exec</code> allows you to execute system commands from a route.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-facebook</code> allows you to interface with the Facebook APIs (using the <code class="literal">facebook4j</code> library).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-flatpack</code> allows you to use the Flatpack library to deal with fixed width and delimited files.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-fop</code> allows you to render messages (in different formats such as PDF) using Apache FOP.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-freemarker</code> allows you to create messages using the FreeMarker template.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ftp</code> allows you to consume or send files via an FTP server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-gae</code> allows you to interact with the Google App Engine service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-google-calendar</code> allows you to interact with Google Calendar (using the REST API).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-google-drive</code> allows you to retrieve or upload files on Google Drive (via the REST API).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-google-mail</code> allows you to retrieve or send e-mails through Gmail (using the REST API).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-gora</code> allows you to access the NoSQL databases using the Apache Gora library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-geocoder</code> allows you to <code class="literal">lookup</code> addresses using the geolocalization.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-github</code> allows you to interface with GitHub.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-hazelcast</code> allows you to use a Hazelcast distributed queue (such as SEDA).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-hbase</code> allows you to interact with the Apache HBase database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-hdfs</code> allows you to interact with Apache Hadoop Distributed File System (HDFS).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-hl7</code> allows you to deal with the HL7 MLLP protocol.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-infinispan</code> allows you to read and write distributed key/value pairs on Infinispan.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-http</code> allows you to interact with the HTTP service using the Apache HTTP Client.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ibatis</code> allows <a id="id337" class="indexterm"/>you to query, insert, and update using the Apache iBatis database framework.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mail</code> allows you to retrieve (using imap or pop) or send e-mails.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-irc</code> allows you<a id="id338" class="indexterm"/> to interact with IRC servers and channels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-javaspace</code> allows you to receive or send messages using JavaSpace.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jclouds</code> allows you to interact with jclouds for cloud computing and Blobstore.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jcr</code> allows you to use a Content Management system such as Apache Jackrabbit.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jdbc</code> allows you to perform database queries using JDBC.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jetty</code> allows you to expose or use a HTTP service using the Jetty library and server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jgroups</code> allows you to interact with JGroups clusters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jira</code> allows you to interact with the JIRA bug tracker.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jms</code> allows you to consume or produce messages from JMS queues or topics using a broker (such as Apache ActiveMQ or IBM MQ).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jmx</code> allows you to work with JMX notifications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jpa</code> allows you to use a JPA framework (such as Hibernate or Apache OpenJPA) to interact with a database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jsch </code>allows you to use the Session Control Protocol (SCP) to download or upload files.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jt400</code> allows you to use data queues from AS/400 systems (System i, IBM i, i5, and so on).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-kafka</code> allows you to consume or produce messages on the Apache Kafka messages broker.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-kestrel</code> allows you to consume or produce messages on the Kestrel queues.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-krati</code> allows you to interface with a Krati data store.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ldap</code> allows you to query LDAP directories.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-linkedin</code> allows you to interact with the LinkedIn site (using the REST API).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-lucene</code> allows you to use the Apache Lucene search queries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-metrics</code> allows you to use the Metrics library to collect activity metrics.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mina</code> allows you to use the Apache MINA library to interact with different network protocols (such as Telnet and so on).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mongodb</code><a id="id339" class="indexterm"/> allows you to use MongoDB.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mqtt</code> allows you to consume or produce messages through MQTT M2M brokers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-msv</code> allows you to validate message payload using the MSV library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mustache</code> allows you to create or render a message using the Mustache template.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mvel</code> allows you to create or render a message using the MVEL template.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-mybatis</code> allows you to interface with a database using the MyBatis library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-nagios</code> allows you to send checks to Nagios (using the JSendNCSA library).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-netty</code> allows you to use TCP/UDP protocols using Java NIO (using the Netty library).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-olingo</code> allows you to communicate with OData 2.0 services using the Apache Olingo library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-openshift</code> allows you to interact with Openshift applications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-optaplanner</code> allows you to solve planning problems described in a message using the OptaPlanner library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-paxlogging</code> allows you to receive log messages coming from Pax Logging (the logging framework used in Apache Karaf).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-printer</code> allows you to interface with printers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-quartz</code> provides advanced trigger endpoints (such as the timer one) using the Quartz library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-quickfix</code> allows you to receive and produce FIX messages using QuickFIX for the Java library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-rabbitmq</code> allows you to consume and produce messages with the RabbitMQ broker.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-restlet</code> allows you to expose REST services using the RESTlet library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-rmi</code> allows you to use the Java RMI service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-jing</code> allows you to validate message payload using the RelaxNG compact syntax.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-rss</code> allows you to consume RSS feed (using the ROME library).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-salesforce</code> allows you to interact with Salesforce.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-sap-netweaver</code> allows you to interact with the SAP NetWeaver gateway.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-schematron</code> <a id="id340" class="indexterm"/>allows you to validate messages containing the XML document.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-sip</code> allows you to publish or subscribe using the Telecom SIP protocol.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-smpp</code> allows you to receive or send SMS messages using the JSMPP library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-snmp</code> allows you to receive SNMP events using the SNMP4J library.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-solr</code> allows you to use an Apache Lucene Solr server via the Solrj API.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-spark-rest</code> allows you to easily create REST services.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-splunk</code> allows you to interact with applications hosted on Splunk.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-sql</code> allows you to perform SQL queries using JDBC.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-ssh</code> allows you to send commands to a SSH server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-stax</code> allows you to process XML messages using SAX ContentHandler.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-stream</code> allows you to interact with standard input, output, and error streams.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-stomp</code> allows you to interact with a broker-supported STOMP protocol (such as Apache ActiveMQ).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-twitter</code> allows you to interact with the Twitter service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-velocity</code> allows you to create/render messages using the Velocity template.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-vertx</code> allows you to interact with Vertx Event Bus.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-weather</code> allows you to retrieve weather information from Open Weather Map.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-websocket</code> allows you to communicate with WebSocket clients.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-xmlsecurity</code> allows you to sign and verify message payload using the XML signature specification.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-xmpp</code> allows you to work with the XMPP protocol, allowing you to work with instant messaging like Jabber.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-saxon</code> allows you to use XQuery on message payload (using Saxon).</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-yammer</code><a id="id341" class="indexterm"/> allows you to interact with the Yammer <a id="id342" class="indexterm"/>enterprise social network.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-zookeeper</code> allows you to interface with the Apache Zookeeper server.</li></ul></div><p>The updated and complete list of Camel <a id="id343" class="indexterm"/>components is available online: <a class="ulink" href="http://camel.apache.org/components.html">http://camel.apache.org/components.html</a>.</p></div></div></div>
<div class="section" title="Endpoint"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Endpoint</h1></div></div></div><p>As we saw in the <code class="literal">Component</code> interface, the main function of a <code class="literal">Component</code> is to create an <code class="literal">Endpoint</code>. This is the purpose<a id="id344" class="indexterm"/> of the <code class="literal">createEndpoint()</code> method. This method returns an <code class="literal">Endpoint</code>. You don't explicitly call this method. The Camel routing engine<a id="id345" class="indexterm"/> calls this method for you.</p><p>When, in a route definition, you use the following syntax:</p><div class="informalexample"><pre class="programlisting">from("my:options")</pre></div><p>During route bootstrap, the Routing Engine is looking for the my component in the <code class="literal">CamelContext</code> (loaded as explained before).</p><p>If the component is not found, we will have a no component found for scheme my message (wrapped in a <code class="literal">CamelRuntimeException</code>).</p><p>If the component is found, the routing engine instantiates the endpoint using the <code class="literal">createEndpoint()</code> method.</p><p>Let's take a look at the <code class="literal">Endpoint</code> interface:</p><div class="informalexample"><pre class="programlisting">public interface Endpoint extends IsSingleton, Service {

String getEndpointUri();

EndpointConfiguration getEndpointConfiguration();

Producer createProducer() throws Exception;

Consumer createConsumer(Processor processor) throws Exception;

PollingConsumer createPollingConsumer() throws Exception;

}</pre></div><p>In this <code class="literal">Endpoint</code> interface snippet, we can note the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can retrieve the endpoint URI using the <code class="literal">getEndpointUri()</code> method</li><li class="listitem" style="list-style-type: disc">We can retrieve the endpoint <a id="id346" class="indexterm"/>configuration using the <code class="literal">getEndpointConfiguration()</code> method</li></ul></div><p>The most<a id="id347" class="indexterm"/> important point is that we have different kinds of endpoints. Depending on the location of the endpoint in the route definition, Camel creates different kinds of endpoints.</p><p>If the endpoint is defined in a <code class="literal">to</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;to uri="my:option"/&gt;</pre></div><p>The Camel routing engine calls the <code class="literal">createProducer()</code> method. The endpoint will act as a producer, meaning that the Exchange will be transformed into an external format and sent <span class="emphasis"><em>outside</em></span> of the Camel route.</p><p>If the endpoint is defined in a <code class="literal">from</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;from uri="my:option"/&gt;</pre></div><p>The Camel routing engine calls the <code class="literal">createConsumer()</code> or <code class="literal">createPollingConsumer()</code> method (depending on the one provided by the endpoint).</p><p>We distinguish two kinds of consumers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An Event-Driven Consumer (created by the <code class="literal">createConsumer()</code> method) is an Enterprise Integration Pattern. Basically, it means that the endpoint acts as a server; it waits for incoming events or messages and instantiates an Exchange for each event. For instance, CXF, Restlet, and Jetty consumer endpoints are event driven. Camel uses a thread pool—each event is processed in its own thread.</li><li class="listitem" style="list-style-type: disc">On the other hand, a Polling Consumer (created by the <code class="literal">createPollingConsumer()</code> method) is also an Enterprise Integration Pattern. Basically, the endpoint periodically checks for a resource and instantiates an Exchange for each new resource. For instance, file, FTP, IMAP consumer endpoints are polling consumers.</li></ul></div><p>We can also design a third kind of consumer, on-demand. Basically, instead of periodically polling a resource, we want to trigger the polling on demand. For instance, we want to consume a file from the filesystem when we receive an HTTP request.</p><p>To do so, we start our Karaf container:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bin/karaf</strong></span>
</pre></div><p>We install the camel-blueprint and camel-jetty features in Karaf, using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:repo-add camel 2.12.4</strong></span>
<span class="strong"><strong>karaf@root()&gt; feature:install camel-blueprint</strong></span>
<span class="strong"><strong>karaf@root()&gt; feature:install camel-jetty</strong></span>
</pre></div><p>The camel-jetty<a id="id348" class="indexterm"/> feature provides the camel-jetty component that we will use in our route.</p><p>In the <code class="literal">Karaf deploy</code> folder, we create the following <code class="literal">route.xml</code> Camel Blueprint route definition file: </p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

  &lt;camelContext &gt;
      &lt;route&gt;
          &lt;from uri="jetty:http://0.0.0.0:8181/poll"/&gt;
          &lt;pollEnrich uri="file:/tmp/in"/&gt;
          &lt;to uri="log:poller"/&gt;
      &lt;/route&gt;
  &lt;/camelContext&gt;
 
&lt;/blueprint&gt;</pre></div><p>This route creates a Jetty event-driven consumer, waiting for incoming HTTP requests. We use the content enricher EIP through the <code class="literal">pollEnrich</code> syntax. It means that, when the Exchange is created by the Jetty endpoint, the Camel routing engine calls the file endpoint and populates the Exchange with the file consumed.</p><p>To test this route, we create the following <code class="literal">test.txt</code> file in the <code class="literal">/tmp/in</code> folder:</p><div class="informalexample"><pre class="programlisting">Hello chapter6a</pre></div><p>Next, we just access the <code class="literal">http://localhost:8181/poll</code> URL with an Internet browser:</p><div class="mediaobject"><img src="graphics/3151EN_06_01.jpg" alt="Endpoint"/></div><p>In the Karaf log, we can see the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2015-01-06 15:00:16,291 | INFO  | qtp827039346-71  | poller | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOut, BodyType: org.apache.camel.component.file.GenericFile, Body: [Body is file based: GenericFile[/tmp/in/test.txt]]]</strong></span>
</pre></div><p>The file<a id="id349" class="indexterm"/> endpoint has been called <span class="emphasis"><em>on-demand</em></span> by the <code class="literal">pollEnrich</code> syntax.</p></div>
<div class="section" title="A custom component example"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>A custom component example</h1></div></div></div><p>Even if Camel provides <a id="id350" class="indexterm"/>a lot of ready-to-use components, you might want to create your own, for instance, to support a proprietary protocol.</p><p>It's pretty easy to create our own Camel component.</p><p>In this section, we will create a component named Packt implementing a simple socket communication.</p><p>First, we create the following Maven <code class="literal">pom.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project  
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.packt.camel.component&lt;/groupId&gt;
  &lt;artifactId&gt;camel-packt&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;bundle&lt;/packaging&gt;

  &lt;properties&gt;
      &lt;camel.version&gt;2.12.4&lt;/camel.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
          &lt;artifactId&gt;camel-core&lt;/artifactId&gt;
          &lt;version&gt;${camel.version}&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
          &lt;version&gt;1.7.7&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;
              &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;
              &lt;extensions&gt;true&lt;/extensions&gt;
              &lt;version&gt;2.3.7&lt;/version&gt;
              &lt;configuration&gt;
                  &lt;instructions&gt;
                      &lt;Import-Package&gt;
                          org.slf4j;resolution:=optional,
                          *
                      &lt;/Import-Package&gt;
                      &lt;Export-Package&gt;
                          com.packt.camel.component*
                      &lt;/Export-Package&gt;
                      &lt;Export-Service&gt;
                          org.apache.camel.spi.ComponentResolver;component=packt
                      &lt;/Export-Service&gt;
                  &lt;/instructions&gt;
              &lt;/configuration&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;

&lt;/project&gt;</pre></div><p>In this <code class="literal">pom.xml</code> file, we note the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In terms of dependencies, we depend on <code class="literal">camel-core</code>, which provides the core interfaces and classes to implement components and endpoints. We also depend on <code class="literal">slf4j-api</code> just to be able to log messages.</li><li class="listitem" style="list-style-type: disc">We use<a id="id351" class="indexterm"/> the maven-bundle-plugin to create the OSGi service for our component. This is will allow us to easily deploy the component in an OSGi container like Apache Karaf, and leverage the Camel OSGi service discovery. For that, we export the <code class="literal">org.apache.camel.spi.ComponentResolver</code> service with the <code class="literal">Packt</code> scheme.</li></ul></div><p>In addition to the component discovery using the OSGi service, we also create the <code class="literal">META-INF/services/org/apache/camel/component/packt</code> file containing:</p><div class="informalexample"><pre class="programlisting">class=com.packt.camel.component.PacktComponent</pre></div><p>The class property contains the full qualified name of the <code class="literal">component</code> class.</p><p>So, now, we have to create the <code class="literal">PacktComponent</code> class:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.component;

import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;

public class PacktComponent extends DefaultComponent {

  private final static Logger LOGGER = LoggerFactory.getLogger(PacktComponent.class);

  public PacktComponent() {
      LOGGER.debug("Creating Packt Camel Component");
  }

  public PacktComponent(CamelContext camelContext) {
      super(camelContext);
      LOGGER.debug("Creating Packt Camel Component");
  }

  @Override
  protected Endpoint createEndpoint(String uri, String remaining, Map&lt;String, Object&gt; parameters) throws Exception {
      LOGGER.debug("Creating Packt Camel Endpoint");
      PacktEndpoint packtEndpoint = new PacktEndpoint(uri, this);
      setProperties(packtEndpoint, parameters);
      return packtEndpoint;
  }

}</pre></div><p>Our component is pretty simple—it extends the Camel <code class="literal">DefaultComponent</code>. We just override the <code class="literal">createEndpoint()</code> method.</p><p>This method <a id="id352" class="indexterm"/>creates  <code class="literal">PacktEndpoint</code>. So, we have to create this <code class="literal">PacktEndpoint</code>:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.component;
 
import org.apache.camel.Component;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultEndpoint;
 
public class PacktEndpoint extends DefaultEndpoint {

  public PacktEndpoint(String uri, Component component) {
      super(uri, component);
  }

  public PacktProducer createProducer() {return new PacktProducer(this);
  }

  public PacktConsumer createConsumer(Processor processor) throws Exception {
      return new PacktConsumer(this, processor);
  }

  public boolean isSingleton() {
      return false;
  }

}</pre></div><p>Our <code class="literal">PacktEndpoint</code> is the actual endpoint factory. In our component, we want to be able to create two kinds of endpoints:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">createProducer()</code> method creates <a id="id353" class="indexterm"/>a <code class="literal">PacktProducer</code> producer that we can use in a route definition with the <code class="literal">to</code> syntax.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">createConsumer()</code> method creates a <code class="literal">PacktConsumer</code> event-driven consumer, that we can use in a route<a id="id354" class="indexterm"/> definition with the <code class="literal">from</code> syntax.</li></ul></div><p>Let's start with <code class="literal">PacktConsumer</code>. <code class="literal">PacktConsumer</code> extends Camel <code class="literal">DefaultConsumer</code>.</p><p>The <code class="literal">PacktConsumer</code> creates a server socket at startup. At startup, it also creates a new thread to listen for incoming client connection.</p><p>For each incoming connection (meaning a client socket connection), we create an <code class="literal">InOut</code> Exchange that we send to the next processor in the route definition. To do so, we create a Camel <code class="literal">DefaultExchange</code> using the <code class="literal">PacktEndpoint</code> and <code class="literal">InOut</code> exchange pattern.</p><p>The next processor is provided by the Camel routing engine (via <code class="literal">getProcessor()</code> method).</p><p>As we use an <a id="id355" class="indexterm"/>
<code class="literal">InOut</code> Message Exchange Pattern, once forwarded to the next hop we are using the out message (and fallback to the <code class="literal">in</code> message) to reply to the client.</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.component;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultExchange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class PacktConsumer extends DefaultConsumer {

  private final static Logger LOGGER = LoggerFactory.getLogger(PacktConsumer.class);

  private ServerSocket serverSocket;

  public PacktConsumer(Endpoint endpoint, Processor processor) throws Exception {
      super(endpoint, processor);
      serverSocket = new ServerSocket(4444);
      LOGGER.debug("Creating Packt Consumer ...");
  }

  @Override
  protected void doStart() throws Exception {
      LOGGER.debug("Starting Packt Consumer ...");
      new Thread(new AcceptThread()).start();
      super.doStart();
  }

  @Override
  protected void doStop() throws Exception {
      super.doStop();
      LOGGER.debug("Stopping Packt Consumer ...");
      if (serverSocket != null) {
          serverSocket.close();
      }
  }

  class AcceptThread implements Runnable {


      public void run() {
          while (true) {
            // create the exchange
            Exchange exchange = new DefaultExchange(getEndpoint(), ExchangePattern.InOut);
            Socket clientSocket = null;
            try {
                clientSocket = serverSocket.accept();
                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                String inputLine = in.readLine();
                if (inputLine != null) {
                    LOGGER.debug("Get input line: {}", inputLine);
                    exchange.getIn().setBody(inputLine, String.class);
                    // send the exchange to the next processor
                    getProcessor().process(exchange);
                    // get out message
                    String response = exchange.getOut().getBody(String.class);
                    if (response == null) {
                        response = exchange.getIn().getBody(String.class);
                    }
                    if (response != null) {
                        out.println(response);
                    }
                }
            } catch (Exception e) {
                exchange.setException(e);
            } finally {
                if (clientSocket != null) {
                    try {
                        clientSocket.close();
                    } catch (Exception e) {
                        // nothing to do
                    }
                }
            }
        }
    }

  }

}</pre></div><p>Our event driven consumer is now ready. We now implement <code class="literal">PacktProducer</code>, which extends Camel <a id="id356" class="indexterm"/>
<code class="literal">DefaultProducer</code>. A producer is pretty simple, it just overrides the <code class="literal">process()</code> method.</p><p>The <code class="literal">process()</code> method has only one argument—the Camel Exchange.</p><p>As it's a producer, the Exchange comes from a previous processor or from an endpoint. Thanks to the Exchange, we have access to the <code class="literal">in</code> message.</p><p>The following is what we do in the processor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We get the body of the <code class="literal">in</code> message (thanks to the Exchange).</li><li class="listitem" style="list-style-type: disc">We create a connection to the server socket, and we send the <code class="literal">in</code> message body to<a id="id357" class="indexterm"/> this socket.</li><li class="listitem" style="list-style-type: disc">We are waiting for the socket server response. This <code class="literal">in</code> message body is overridden by the server response.</li></ul></div><div class="informalexample"><pre class="programlisting">package com.packt.camel.component;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

public class PacktProducer extends DefaultProducer {

  private final static Logger LOGGER = LoggerFactory.getLogger(PacktProducer.class);

  public PacktProducer(Endpoint endpoint) {
    super(endpoint);
    LOGGER.debug("Creating Packt Producer ...");
}

  public void process(Exchange exchange) throws Exception {
      LOGGER.debug("Processing exchange");
      String input = exchange.getIn().getBody(String.class);
      LOGGER.debug("Get input: {}", input);
      LOGGER.debug("Connecting to socket on localhost:4444");
      Socket socket = new Socket("localhost", 4444);
      PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
      BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
      out.println(input);
      String fromServer = in.readLine();
      LOGGER.debug("Get reply from server: {}", fromServer);
      LOGGER.debug("Populating the exchange");
      exchange.getIn().setBody(fromServer, String.class);
  }


}</pre></div><p>We can now build our component using Maven:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mvn clean install</strong></span>
<span class="strong"><strong>[INFO] Scanning for projects...</strong></span>
<span class="strong"><strong>[INFO]                                                               </strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Building camel-packt 1.0-SNAPSHOT</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ camel-packt ---</strong></span>
<span class="strong"><strong>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</strong></span>
<span class="strong"><strong>[INFO] Copying 1 resource</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-compiler-plugin:3.2:compile (default-compile) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO] Changes detected - recompiling the module!</strong></span>
<span class="strong"><strong>[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!</strong></span>
<span class="strong"><strong>[INFO] Compiling 4 source files to /home/jbonofre/Workspace/sample/chapter6b/target/classes</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ camel-packt ---</strong></span>
<span class="strong"><strong>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</strong></span>
<span class="strong"><strong>[INFO] skip non existing resourceDirectory /home/jbonofre/Workspace/sample/chapter6b/src/test/resources</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-compiler-plugin:3.2:testCompile (default-testCompile) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO] No sources to compile</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-surefire-plugin:2.17:test (default-test) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO] No tests to run.</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-bundle-plugin:2.3.7:bundle (default-bundle) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-install-plugin:2.5.1:install (default-install) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO] Installing /home/jbonofre/Workspace/sample/chapter6b/target/camel-packt-1.0-SNAPSHOT.jar to /home/jbonofre/.m2/repository/com/packt/camel/component/camel-packt/1.0-SNAPSHOT/camel-packt-1.0-SNAPSHOT.jar</strong></span>
<span class="strong"><strong>[INFO] Installing /home/jbonofre/Workspace/sample/chapter6b/pom.xml to /home/jbonofre/.m2/repository/com/packt/camel/component/camel-packt/1.0-SNAPSHOT/camel-packt-1.0-SNAPSHOT.pom</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-bundle-plugin:2.3.7:install (default-install) @ camel-packt ---</strong></span>
<span class="strong"><strong>[INFO] Installing com/packt/camel/component/camel-packt/1.0-SNAPSHOT/camel-packt-1.0-SNAPSHOT.jar</strong></span>
<span class="strong"><strong>[INFO] Writing OBR metadata</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 2.105s</strong></span>
<span class="strong"><strong>[INFO] Finished at: Fri Jan 09 10:59:35 CET 2015</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 15M/303M</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
</pre></div><p>Our component is now ready to be deployed in Apache Karaf.</p><p>We start Karaf and install the <code class="literal">camel-blueprint</code> feature:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ bin/karaf</strong></span>
<span class="strong"><strong>karaf@root()&gt; feature:repo-add camel 2.12.4</strong></span>
<span class="strong"><strong>Adding feature url mvn:org.apache.camel.karaf/apache-camel/2.12.4/xml/features</strong></span>
<span class="strong"><strong>karaf@root()&gt; feature:install camel-blueprint</strong></span>
</pre></div><p>We can now install<a id="id358" class="indexterm"/> our component:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; bundle:install mvn:com.packt.camel.component/camel-packt/1.0-SNAPSHOT</strong></span>
<span class="strong"><strong>Bundle ID: 73</strong></span>
<span class="strong"><strong>karaf@root()&gt; bundle:start 73</strong></span>
</pre></div><p>We can see that our component is now ready:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; la|grep -i packt</strong></span>
<span class="strong"><strong>73 | Active   |  80 | 1.0.0.SNAPSHOT  | camel-packt</strong></span>
</pre></div><p>If we take a look at the OSGi services provided by our component, we can see the <code class="literal">Component</code> service:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; bundle:services 73</strong></span>

<span class="strong"><strong>camel-packt (73) provides:</strong></span>
<span class="strong"><strong>--------------------------</strong></span>
<span class="strong"><strong>[org.apache.camel.spi.ComponentResolver]</strong></span>
</pre></div><p>Camel will use this service to resolve the component associated to the Packt scheme. To test our component, we can create the following <code class="literal">route.xml</code> Blueprint:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

      &lt;camelContext &gt;
              &lt;route id="server"&gt;
                      &lt;from uri="packt:server"/&gt;
                      &lt;to uri="log:server"/&gt;
                      &lt;setBody&gt;&lt;simple&gt;Echo ${body}&lt;/simple&gt;&lt;/setBody&gt;
              &lt;/route&gt;
              &lt;route id="client"&gt;
                      &lt;from uri="timer:fire?period=5000"/&gt;
                      &lt;setBody&gt;&lt;constant&gt;chapter6b&lt;/constant&gt;&lt;/setBody&gt;
                      &lt;to uri="packt:client"/&gt;
                      &lt;to uri="log:client"/&gt;
              &lt;/route&gt;
      &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre></div><p>The server route uses the Packt component to create a consumer endpoint while waiting for an incoming connection (<code class="literal">from</code> with <code class="literal">packt:server</code>).</p><p>We can now see<a id="id359" class="indexterm"/> the Packt scheme (defined in both the OSGi service and the META-INF service). We log the received message and return the received message prefixed by <code class="literal">Echo</code> (using the simple Camel language).</p><p>On the other hand, the <code class="literal">client</code> <code class="literal">route</code> periodically creates an exchange (using timer), and we define a <code class="literal">chapter6b</code> as the body of the <code class="literal">in</code> message (using <code class="literal">setBody</code>).</p><p>This message is sent to the server socket bound by our <code class="literal">server route</code>, using the Packt component to create a producer endpoint (<code class="literal">to</code> with <code class="literal">packt:client</code>). To deploy these routes, we just drop the <code class="literal">route.xml</code> file into the <code class="literal">Karaf deploy</code> folder. In the log, we can see the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2015-01-09 11:58:25,758 | INFO  | Thread-16      | server | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOut, BodyType: String, Body: chapter6b]</strong></span>
<span class="strong"><strong>2015-01-09 11:58:25,771 | INFO  | 1 - timer://fire | client | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOnly, BodyType: String, Body: Echo chapter6b]</strong></span>
<span class="strong"><strong>2015-01-09 11:58:30,741 | INFO  | Thread-16 | server | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOut, BodyType: String, Body: chapter6b]</strong></span>
<span class="strong"><strong>2015-01-09 11:58:30,742 | INFO  | 1 - timer://fire | client | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOnly, BodyType: String, Body: Echo chapter6b]</strong></span>
</pre></div><p>We can note<a id="id360" class="indexterm"/> that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The server route has been called by the client route</li><li class="listitem" style="list-style-type: disc">The consumer prefixed the message body (with <code class="literal">Echo</code>) as defined in the simple expression</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Summary</h1></div></div></div><p>In the previous chapters, we used beans (POJO) and processors to implement mediation logic and act as a producer. However, to implement and simplify support of some protocols, systems, data transformations, and so on, Camel components are very convenient and provide easy extension points, which are ready to use in Camel route. This allows you to decouple implementation of the connectivity from the mediation logic.</p><p>Utilizing a combination of components (provided or custom), processors, beans, and route definitions provides a complete and powerful mediation framework. However, integration and mediation requires us to address a new challenge—how to handle and process errors that can happen in the mediation. This is what we will see in the next chapter.</p></div></body></html>