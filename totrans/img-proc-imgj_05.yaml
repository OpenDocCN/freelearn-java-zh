- en: Chapter 5. Basic Measurements with ImageJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in the previous chapter how to perform some preprocessing steps that
    prepared the image data for measurement and analysis. In this chapter, we will
    take a closer look at the measurement system available in ImageJ. You will also
    learn how to create some visualizations of movement and dynamics. We will look
    at the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Selections and regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ROI Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kymographs and line profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area and line selections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semiquantitative colocalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selections and regions in ImageJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will first look at the tools that are available in ImageJ to select **Regions
    Of Interest** (**ROIs**). These tools can be useful if you wish to only process
    a small portion of your image. ROIs are a very important element in ImageJ, and
    there is also a specific manager to handle the ROIs: **ROI Manager**. It can be
    opened by going to **Analyze** | **Tools** | **ROI Manager…**, which will open
    the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selections and regions in ImageJ](img/Insert_image_4909_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the left-hand side, there is a list that will contain the ROIs, while on
    the right-hand side, there are several buttons that will perform certain actions
    on the ROIs. The checkboxes in the bottom-right corner allow the user to see all
    the regions at once (**Show All**), while the **Labels** checkbox displays the
    region label in the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of region that are supported by ImageJ. They can
    be divided into two major types: **area** **selections** and **line selections**.
    A third singular type is the **Point ROI**, which only has one member. When used
    for measurements, the parameters that can be measured are slightly different.
    Area can only be measured with the area type ROIs, while angle can only be measured
    with line selections.'
  prefs: []
  type: TYPE_NORMAL
- en: First, I will discuss a few of the common selection types that are supported
    by ImageJ, and then, we will apply them to take measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Area selections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Area selections in ImageJ contain different types with different properties.
    The following types are available in ImageJ:'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ovals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polygons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freehand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangles are mostly used to select areas to crop images or for rectangular
    objects. If your images contain more organic shapes, oval or polygon areas are
    more suitable. These types can be added to images by selecting the appropriate
    tool in the toolbar of the ImageJ program. Then, you can left-click and drag the
    mouse to enclose the area you wish to select and then release the mouse button.
    After the selection has been set, you can press the **Add** button on the ROI
    Manager (or press *Ctrl* + *T*) to add the region to the ROI Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the **Require control/command key for shortcuts** option is unchecked when
    you go to **Edit** | **Options** | **Misc…**, then pressing only the letter *T*
    is sufficient to add the ROI to the Manager.
  prefs: []
  type: TYPE_NORMAL
- en: When an ROI is added to the ROI Manager, it can be saved to a file to preserve
    it for later. When multiple ROIs are added to the ROI Manager and one is selected
    when attempting to save the ROIs, only the selected ROI will be saved. If you
    wish to save all the ROIs at once, press **Deselect** to unselect all ROIs. Alternatively,
    you can use *Ctrl* + *A* to select all the ROIs, before selecting **More »** |
    **Save** from the ROI Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single ROIs will be saved to the disk as a file with the `.roi` extension. Multiple
    ROIs will be saved as an ROI set in a `.zip` file. This zip archive contains individual
    `.roi` files, one for each selection. On Windows, extensions are hidden by default
    for known file types. So, to see the extensions, you may have to uncheck the **Hide
    extensions for known file types** option in the folder options.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding additional ROIs, it may be convenient to select the **Show All**
    checkbox in the ROI Manager. This will show all the ROIs currently in the list.
    Clicking on the ROI in the ROI Manager can set the active region. It always shows
    in the color you have set in the options (refer to, [Chapter 1](ch01.html "Chapter 1. Getting
    Started with ImageJ"), *Getting Started with ImageJ*), with small white squares
    at the corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Area selections](img/Insert_image_4909_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These small squares are control points that can be used to move and resize
    the ROI. If you modify a region by resizing it or positioning it, pressing the
    **Update** button on the ROI Manager will update the region in the list. To resize,
    click and drag one of the squares to a new location and release the mouse button.
    If you hold the *Shift* key while dragging the handles, the shape will become
    a square or circle with equal width and height. If you hold the *Ctrl* key (or
    *Cmd* key on a Mac) while clicking on the control points, the region grows in
    width and height equally around the center. If you hold the *Alt* key while resizing,
    the handle on the opposite side will stay at a fixed location while you resize
    the region, keeping the length-to-width proportion equal. If you press the *Alt*
    key and create an area that overlaps with your previous region, a subtraction
    of the overlapping part of the two regions will be formed. Conversely, if you
    hold the *Shift* key before creating a new region that overlaps a previous region,
    you will create a union of the overlapping part of the two regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Area selections](img/Insert_image_4909_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A combination of two of the keys can also be pressed while dragging for a combination
    of both resizing effects. To move a region, move the cursor inside the region
    and click and drag the region to a new location. Make sure that the cursor is
    shaped like an arrow—and not like a hand or crosshair—before you click and drag
    the region. For small regions, you might have to zoom in in order to move the
    region. If the cursor gets close to the control points, it will change to resize
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a region is placed and added to the ROI Manager, pushing the **Measure**
    button in the ROI Manager or using the *Ctrl* + *M* keyboard shortcut will measure
    the region. To select the parameters that are measured, go to **Analyze** | **Set
    Measurements…** to select the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Area selections](img/Insert_image_4909_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Mean gray value** is the average intensity within the area, while **Area**
    measures the area of the region in the units of the image. Once you click on **Measure**
    in the ROI Manager, a new window with the measurements is opened. This window
    shows the results. Some of the different measurements will be explained in the
    *Area selections and measurements* section, where we will use them to extract
    useful information from our images.'
  prefs: []
  type: TYPE_NORMAL
- en: Line selections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The line selections contain the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Straight line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmented line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angle tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageJ handles these selection types in a similar way. However, they can be
    used for different measurements. One of the most used functions for line segments
    is to plot a profile along a line or segmented line. Another option is to create
    a **kymograph**. Both these options will be demonstrated in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Point selections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third type of selection only contains one tool: the point tool. It selects
    a single pixel only and is mostly used in counting or marking an object''s center
    point. The advantage of point selection is that it requires only a single click
    to place it. However, the measurements that can be obtained are limited to the
    *X* and *Y* coordinates and the intensity.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic measurements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now look at a few techniques that can be used to measure specific parameters
    from data. For these measurements, we will use the ROI Manager and several different
    types of region to select and measure intensities, speed, and other interesting
    things. Besides measurements, regions can also be used for other purposes relevant
    to processing and image handling. One useful application of selections is that
    they can be used to limit certain processing steps to the selected area while
    leaving the unselected pixels unaffected. A few examples of these applications
    will be demonstrated as well.
  prefs: []
  type: TYPE_NORMAL
- en: Area selections and measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with some basic measurements using area selections. We will use
    these to measure some basic parameters such as area, perimeter (or circumference),
    and many more. We will start with the most basic area selection: the rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangular selections are very useful for cropping image areas. By reducing
    the size of an image, you reduce the memory required as well as the processing
    time for complicated algorithms. Another good use for a rectangular selection
    is to restrict processing in a larger image to a specific region. Some ImageJ
    algorithms and tools can work within an active selection. We will see an example
    of this type of application in a plugin that we will develop in [Chapter 9](ch09.html
    "Chapter 9. Creating ImageJ Plugins for Analysis"), *Creating ImageJ Plugins for
    Analysis*. As a result of the simplicity of the rectangle, measurements, such
    as area and perimeter are not really relevant. You can calculate the area and
    perimeter of a rectangle very easily using the width and height. We will, therefore,
    focus on some more useful applications of rectangular selections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s use the rectangular selection to modify a small section
    of an image by inverting its gray values. To start with an example, open the **Blobs**
    image from the sample images. We will invert the LUT for a single blob using these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a blob in the image using the rectangular selection tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting a blob, press *Ctrl* + *Shift* + *I* to invert the LUT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *Ctrl* + *Shift* + *A* to remove all selections and invert the LUT again
    using *Ctrl* + *Shift* + *I*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this little exercise, we focused on only modifying pixels that were selected,
    while the pixels outside of the selection were left unchanged. If no pixels were
    selected, the **Invert LUT** command worked on all pixels. This is an example
    of how to use area selection to limit processing to selected pixels only. The
    same method also works for other area selections. You could also use this method
    to highlight a specific part of an image by making it stand out. For instance,
    in the following kymograph example, we could show the lines that were acquired
    during stimulation by creating a square selection and inverting the LUT for only
    that time period.
  prefs: []
  type: TYPE_NORMAL
- en: Oval selections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ImageJ has two types of selection for rounded shapes: **ellipses** and **ovals**.
    The difference between the two types is subtle, but oval selections can only by
    shaped along the *x* or *y* axis. Ellipses, on the other hand, can be freely rotated
    as well. To create a circle, hold the *Shift* key while creating an oval selection
    to force ImageJ to make a circle with equal width and height. Another important
    property of oval selections is their shape descriptors. The shape descriptors
    that ImageJ reports in its measurements are the circularity (Circ.), roundness
    (Round), aspect ratio (AR), and solidity (Solidity). Circularity is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oval selections](img/Insert_image_4909_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *A* is the area, and *C* is the circumference. Roundness is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oval selections](img/Insert_image_4909_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the major axis is the largest diameter of an oval. Aspect ratio is the
    ratio between the major and minor axes of an oval. Solidity is defined as the
    area divided by the convex hull of the area. Solidity is helpful for irregular
    shapes. A convex hull is the smallest curve that can be fitted around an object
    without intersecting with it. It can be seen as trying to stretch an elastic band
    around the object to encompass it completely. For oval- or ellipse-shaped objects,
    this parameter does not add any information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the results when drawing a few ellipses and ovals and
    measuring their shape descriptors. Here are a few examples of elliptical selections
    (left of the image) and oval selections (right of the image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oval selections](img/Insert_image_4909_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The shapes with a circularity of 1.00 are colored orange (ellipse) and light
    green (oval). The red ellipse has a very low circularity (0.28), while the cyan
    oval has an intermediate circularity (0.48). This circularity parameter will be
    useful when trying to detect particles, as it is a very basic description of a
    shape using a single value. Round objects will have a value of 1, while flattened
    ovals will have a low value closer to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to create a doughnut selection using the oval tool. Making
    two circles, one bigger than the other, and then removing the smaller of the two
    circles can do this. The following steps will create a doughnut selection:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the larger circle first over the object you wish to select and press
    *Ctrl* + *T* to add it to the ROI Manager. Make the size of the circle 20 x 20
    pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the inner circle, you can add a new circle using the oval tool. However,
    it may not be centered. To create a centered inner circle, we will select the
    outer circle and select **Edit** | **Selection** | **Enlarge…** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a value of `-5` to shrink the circle to a new circle of 10 x 10 pixels
    and press *Ctrl* + *T* to add it to the ROI Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the doughnut, select both circles in the ROI Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With both circles selected, select **More »** | **XOR** from the ROI Manager.
    This will result in the doughnut. To add the new selection, press *Ctrl* + *T*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that creating a doughnut this way forces the new area selection to be "pixelated".
    The outline of the region will be aligned across the pixel grid unlike the ROIs
    generated by ImageJ. You can also create the doughnut by holding the *Alt* key
    while creating the inner circle. However, it can be difficult to align both circles
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Polygon selections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Other types of area selection are polygon and freehand selections. They allow
    more organic shapes to be selected. To create a polygon selection, select the
    tool and by left-clicking, you can add points to the polygon. Each point is connected
    by a straight line (vertex), and by double-clicking or by left-clicking on the
    first point, the polygon is closed and turns into an area selection. If you right-click,
    the polygon tool will add a point at the point where you clicked and close the
    polygon at the same time. A polygon requires a minimum of three points. This is
    tool is helpful for selecting irregular shapes, such as in the **Blobs** example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polygon selections](img/Insert_image_4909_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this type of irregular shape, the polygon tool is more suited to only selecting
    the blob. A similar effect can be achieved with the freehand tool. However, it
    may be more difficult to select very precisely. The freehand tool works by left-clicking
    and holding the button while you drag the mouse around the shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating an irregular area selection is to use the magic wand
    selection tool. This tool works in the same way as the wand tool in other graphics
    programs such as Photoshop and Gimp. It selects pixels that have the same intensity
    or color as the one that was clicked. To select a blob in the sample image, we
    can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Wand Tool** from the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on a blob. This will create a selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the tolerance for the selection by double-clicking on the wand tool button
    and set **Tolerance** to `60`. Then, press **OK** (see the following screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the same blob to see the effect of the tolerance setting on the
    selection:![Polygon selections](img/Insert_image_4909_05_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The wand tool allows us to set a tolerance, which means that values that fall
    within the tolerance relative to the selected pixel will be included in the selection.
    A value of `0` will only consider pixels that are identical. When enabling thresholding,
    the tolerance will be ignored (basically, it is set to `0`). The mode allows you
    to use the 4-connected or 8-connected neighbors to determine the selection. The
    difference between a tolerance of `0` (left image) and `60` (right image) for
    the blobs example can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polygon selections](img/Insert_image_4909_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tool can be very efficient for selecting organic shapes such as these blobs.
    However, it requires the contrast between the object (the blobs) and the background
    to be high. If you set the tolerance higher, in the blobs example for instance,
    not only is the object selected, but also background. If you try a tolerance value
    of `150` in the blobs example, the selection would still be OK. However, it already
    includes some background pixels. A tolerance value of `160`, however, would include
    almost the entire image if you click on one of the blobs' lighter pixels. There
    is a different way to select organic shapes such as blobs using the particle analyzer,
    which will be discussed later on.
  prefs: []
  type: TYPE_NORMAL
- en: Line selections and measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the area selection tools for measurements, there are also line selection
    tools that can be used for measurements. Line selections can be useful to select
    thin, elongated structures. Brain cells have a basic structure with a cell body
    and long, thin processes called **neurites**. Measuring along these thin processes
    can be done using line selections to determine characteristics such as length.
    In time series, a line along the neurite will allow for measurement of intensity
    over time using a specialized visualization of dynamics called a kymograph.
  prefs: []
  type: TYPE_NORMAL
- en: Kymographs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A kymograph is a representation of all the pixels along a line for each frame
    or slice. This type of image shows the dynamics of objects. Straight lines that
    run from top to bottom of the image represent static objects, while angled lines
    indicate movement. The steeper the angle, the faster the object moves. This can
    be used to measure the velocity of objects. It is also a very simple visual aid
    to identify movement in a confined space. This latter point is an important distinction.
    Any object that starts on the line but leaves it on either side will not be visualized
    and cannot be measured.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a very basic kymograph of the time series we used in the previous
    chapter when we normalized a time series. Open the `time_series.tif` image in
    ImageJ. Next, we will trace one of the stretches where many puncta are present.
    To trace an irregular shape like we have here, we want to select the segmented
    line region.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the line tool in the ImageJ main interface and select **Segmented
    Line** from the options presented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a line as indicated in the following image (feel free to take a different
    stretch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wish to create multiple kymographs, you can add each line to the ROI
    manager using *Ctrl* + *T*.![Kymographs](img/Insert_image_4909_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the line that you draw intersects the puncta and that you stay
    along their path. As stated earlier, the kymograph will only show what is on the
    line! As an exercise, you can draw a line more accurately by first creating a
    maximum projection and drawing the line there and then transferring it to the
    time series. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a maximum projection by going to **Image** | **Stacks** | **Z Project…**
    and selecting **Maximum intensity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new image, select a stretch using the segmented line and add it to the
    ROI Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the original `time_series.tif` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transfer the selection by either selecting the added ROI from the ROI Manager
    or by going to **Edit | Selection | Restore Selection** from the menu. Note that
    the latter option will only work for the last active selection, while the former
    option will work for any number of selections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our line, we will create the kymograph by going to **Image**
    | **Stacks** | **Reslice [/]…** from the menu. Alternatively, you can press the
    forward slash key (*/*). If you have a recent version of Fiji, you could also
    select **Analyze** | **Multi Kymograph** | **Multi Kymograph** to create a kymograph.
    When using the **Reslice** option, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the line is the active selection by selecting it in the ROI Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Image** | **Stacks** | **Reslice** from the menu or press the forward
    slash key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Avoid interpolation** checkbox and press **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After pressing **OK**, a new image opens. It has a width equal to the length
    of the line and a height equal to the number of frames (600). Here are the first
    300 lines from the earlier selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kymographs](img/Insert_image_4909_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using Fiji, using the **Multi Kymograph** tool that is located in the
    **Analyze** menu can generate the same effect. This plugin has an additional feature
    that allows you to average a few pixels along the line''s length. This will reduce
    the effects of noise along the line by averaging pixel intensities. To use this
    plugin, use these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select line selection in the ROI Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Analyze** | **Multi Kymograph** | **Multi Kymograph** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a value for line thickness: a value larger than 1 will create an average,
    in this case use 3 and press **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kymograph clearly shows that some of the puncta are moving, while others
    are more static. Depending on the line you drew, you should get more or less the
    same result, although some areas have less movement. As this selection was a single
    line, it is also clear from this example that some of the puncta move in a different
    direction than others.
  prefs: []
  type: TYPE_NORMAL
- en: To measure velocity in a kymograph (remember that velocity is distance divided
    by time), all we have to do is draw a single line across each section that is
    not vertical. Vertical lines have zero distance and, therefore, a velocity of
    0\. To make it a little easier to do the calculations, we will first change the
    calibration of the image (refer to [Chapter 2](ch02.html "Chapter 2. Basic Image
    Processing with ImageJ"), *Basic Image Processing with ImageJ,* for details on
    how to do this). Set the pixel width to `266.67` and the pixel height to `0.125`.
    The unit can be set to pixel. What we do here is specify that the width (*x* coordinates)
    is in nanometers, while the height (*y* coordinates) is in seconds. ImageJ does
    not fully support this notion, but this will function for our purposes nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the measurement, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Straight Line** tool and draw a line through the center of a track
    for as long as the line stays in the middle of that track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the **Bounding box** option is selected in your measurements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *M* to measure the current selection, which will be added to
    your results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the next part of the track by dragging the top handle of your line to
    the next point where the track starts to change velocity and measure again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until the track disappears from the kymograph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the **Bounding box** option was selected, you will have four columns in your
    results table, labeled **BX**, **BY**, **Width**, and **Height**. For velocity
    measurements, we only require the width and height parameters. The width is equal
    to the distance that was traveled, while the height is equal to the time spent
    traveling. To get the correct value for velocity, we will divide the width by
    the height to get the velocity, expressed in *nm/sec* with the calibration mentioned
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method of calculating the velocity for moving particles is not very difficult,
    but it is very time consuming and error prone. Also, kymographs are not suited
    for objects that travel in arbitrary directions in space (that is, not along a
    line). So, for that type of object and for a more detailed approach to tracking
    the movement of objects, we will revisit this topic in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Line profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we saw what we can do using a simple line selection
    and a time series for quantification. Line selections can also be used for single
    images, especially when quantifying features related to intensity, (co) localization,
    and intactness. For these types of assessment, we would like to know the intensity
    profile of an object. To create an intensity profile, we can use a straight line
    or a segmented line selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will look at the distribution of rings within
    a section of a tree. When trees grow, they add a ring every year of young wood.
    The thicker a ring is, the faster the tree grows, indicating favorable conditions
    for growth (sunlight, mild temperatures, rainfall, soil conditions, and so on).
    For this kind of analysis, we need to know two things: the number of rings and
    the thickness of each ring.'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, open the **Tree Rings** image from **File** | **Open Samples**.
    The image that opens shows a partial section of a tree, with the tree center at
    location (`135,54`), approximately. The rings can be seen as white areas separated
    by dark lines. Each dark line is the boundary of a growth ring. When you zoom
    in on the center of the tree, it is immediately apparent that the rings are not
    equal in width. The fourth ring, for instance, is quite thin, while the fifth
    ring is five times thicker. For the analysis, we could use the same strategy that
    we used for the kymograph. We could draw a line from dark border to border and
    measure the length each time. This has a very big drawback. It is very time consuming
    (again), and it will be difficult to keep the line straight. Measuring the width
    of each ring should be based on the shortest distance between each ring border.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a line profile, select a line across a section of the image that
    you wish to profile and go to **Analyze** | **Plot Profile** from the menu (or
    press *Ctrl* + *K*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Line profiles](img/Insert_image_4909_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the line profile at the bottom of the figure across the line in the
    image. It shows the intensity along the line's pixels. The plot profile window
    also has an option to show a live updating plot. This means that when the region
    is moved or resized, the plot is updated immediately. Each of the low points in
    the profile indicates a tree ring border. When we press the **List** button in
    the **Plot Profile** window, a window opens with intensity values for each pixel
    along the line. If we copy this to a spreadsheet program, we can calculate the
    distance between each valley to determine the width of each ring in pixels (without
    calibrating the image, the real width in practical units is unknown). The number
    of valleys gives the number of years.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, it is possible to measure the widths of the rings using the profile
    plot as shown earlier. To do this, we must draw a segmented line on the profile
    plot. Every graphics window (text and results windows excluded) in ImageJ can
    be used to draw selections. For this example, it is important to disable grid
    lines in the profile plot before creating the profile plot. This can be done by
    unchecking the **Draw grid lines** checkbox in the profile plot settings, which
    can be found by selecting **Edit** | **Options** | **Profile Plot Options…** from
    the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Draw a segmented line from the lowest point of each valley starting from the
    left-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the foreground color to black using the color picker and draw the line using
    *Ctrl* + *D* or by going to **Edit** | **Draw** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that your measurement settings include the **Bounding rectangle**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the wand tool to measure the area underneath the graph. To measure the
    width of a tree ring, click with the wand tool above your segmented line, but
    below the black line of the graph. This will select the white pixels of the chart,
    which is continuous up to the black line of the graph. You will see that only
    the section underneath the graph until your segmented line selection is selected
    (see the following image).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you press *Ctrl* + *M* to measure this selection, you will get the width
    and height for the selection.![Line profiles](img/Insert_image_4909_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The width measurement will be the thickness of the tree ring. By doing this
    for each area between the valleys, you can measure the thickness of each ring.
    Note that if the area underneath the graph is meaningful for your measurements,
    then selecting **Area** in your measurement options would give you this parameter
    as well. A similar method is used when analyzing electrophoresis gels and western
    blots. For this purpose, ImageJ has a special collection of tools to analyze gels.
    These tools can be found by going to **Analyze** | **Gels**, with an explanation
    of how to use it at [http://imagej.nih.gov/ij/docs/guide/146-30.html#toc-Subsection-30.13](http://imagej.nih.gov/ij/docs/guide/146-30.html#toc-Subsection-30.13)
    and a video explaining it at [http://imagejdocu.tudor.lu/doku.php?id=video:analysis:gel_quantification_analysis](http://imagejdocu.tudor.lu/doku.php?id=video:analysis:gel_quantification_analysis).
  prefs: []
  type: TYPE_NORMAL
- en: Colocalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we looked at ways to measure certain aspects of our
    images, such as velocity and length. This section will look at a different aspect
    of measurements that involve the colocalization of different signals. Colocalization
    means that two (or more) objects are within proximity of each other. Whenever
    two signals overlap in space, we can conclude that they are at the same location,
    within the boundaries of the resolution that an imaging system allows us. In biology,
    the localization of two labeled structures or proteins provides clues to whether
    the protein is contained within a structure or whether it moves to a certain location
    after being stimulated. For dynamic structures such as cells, we can observe a
    change in the amount of colocalization, depending on time or stimulation.
  prefs: []
  type: TYPE_NORMAL
- en: Semiquantitative colocalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Semiquantitative colocalization means that you examine the amount of colocalization
    by eye or using a crude measurement and classify it (rather arbitrarily) as colocalized
    or not. This can be a very good place to start off. However, it is very difficult
    to conclude anything if the results are not black and white. For this type of
    colocalization, we only require an image for each signal, and we need to merge
    them to see the colocalization. This is sometimes done automatically when we acquire
    images, and sometimes, images need to be merged by hand. To merge two different
    images, a few prerequisites need to be met:'
  prefs: []
  type: TYPE_NORMAL
- en: Images need to be the same size (*X*, *Y*, and optionally *Z* or *T*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images need to be the same type (8-bit, 16-bit, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images cannot be moved between each channel's acquisition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these conditions are met, then the result of the colocalization should provide
    a qualitative result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To merge two channels, go to **Image** | **Color** | **Merge Channels…** from
    the menu. Currently, ImageJ supports merging seven different images into a single
    multichannel image using seven different LUTs: red, green, blue, gray, cyan, magenta,
    and yellow. The most frequently used combination is **Red/Green**, where colocalization
    results in yellow pixels. Another good combination of colors is **Green/Magenta**,
    with colocalization showing as white pixels. The latter option is recommended
    for publications, as people with color-blindness can still appreciate the colocalization.
    Note that if one channel has very low intensities and the other channel has high
    intensities, the human visual system will only perceive the brighter channel.
    For a good visualization of colocalization, both channels need a similar distribution
    of gray values. The respective histograms should look similar.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to quantify this colocalization in a rudimentary way is to look
    at the overlap of bright pixels. To do this, we can take a threshold for each
    channel and create a mask for each image. To look at the overlap, we can use the
    image calculator to perform an `AND` operation. Overlap of pixels is classified
    as pixels that are 1 (technically, 255) at the same location in both images. After
    performing this `AND` operation, we can determine the amount of overlap by counting
    the number of white pixels in the resulting image. A simple way to do this is
    by taking the histogram by pressing *Ctrl* + *H* and then pressing the **List**
    button in the resulting histogram window. By looking at the value for 255 (at
    the bottom of the list), you will get a count for the number of pixels that overlap.
    We will revisit this topic in [Chapter 8](ch08.html "Chapter 8. Anatomy of ImageJ
    Plugins"), *Anatomy of ImageJ Plugins*, where we will apply more rigorous quantification
    using some of the plugins supplied with Fiji.
  prefs: []
  type: TYPE_NORMAL
- en: Particle analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will look at the methods available for particle analysis, a field
    that deals with detecting multiple (similar) objects within an image, with the
    purpose of segmenting and quantifying them. Many problems can be defined as a
    particle system, which consists of many individual cells within a single image,
    holes in a surface, detecting cars on a road, and so on. The basic particle analysis
    step is detecting or segmenting the particles in a single image.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing and preparations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To detect particles, they first need to be separated from the background. To
    do this, we need to create a mask that isolates all the objects from the background.
    We already saw how to set a threshold in the previous chapter and how to use it
    to create a mask. This mask image will be used for particle analysis. For this
    example, we will use a relatively simple example. Open the **Blobs** image by
    going to **File** | **Open Samples** in the ImageJ menu. When the image opens,
    go to **Image** | **Adjust** | **Threshold…** and set the threshold using the
    **Auto** button. Make sure that **Dark background** box is not checked. You should
    now see something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preprocessing and preparations](img/Insert_image_4909_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The red areas indicate the foreground, which are our potential particles, while
    everything else will be ignored. The goal will now be to segment the particles
    based on two main characteristics: their shape and size. We will finish this step
    by creating the mask by selecting **Edit** | **Selection** | **Create Mask** from
    the menu (the mask is the image on the right-hand side).'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start detecting the particles, we first need to know a few things
    about them. We need to know the size of the particles. There are two simple ways
    of determining the size of all the particles within this image, and we will start
    with the most straightforward one. To determine the size of a specific particle,
    we will just draw a region around it and measure it. In the section on area measurements,
    we used polygon selection to measure the area and shape descriptors. For particle
    analysis, we need to determine what the smallest particle is that we may still
    consider a real particle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s take the particle at (103,111) as the smallest real
    particle. After drawing a polygon around it, you may get an area of 363 pixels
    and a circularity of 0.9188\. If we take a less circular particle, for instance
    at (133,83), we get an area of 434 and a circularity of 0.7329\. Let''s take the
    minimum value for each parameter of these two observations, giving us a minimum
    area of 363 pixels and a minimum circularity of 0.7329 to continue with. We can
    now perform particle analysis by selecting **Analyze** | **Analyze Particles…**
    from the menu. Enter the following parameters in the dialog that opens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preprocessing and preparations](img/Insert_image_4909_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The size is the range of sizes that will be counted as particles, measured in
    square pixels (area). The circularity range that we found is now defined as the
    particles that are round or more round than our estimate. For the **Show** option,
    you can select multiple output types, including outlines. When you use the **Add
    to Manager** option, this output is not really required anymore and can be set
    to **Nothing**. When you do not wish to measure particles that are only partially
    in the image, you must select the **Exclude on edges** option. In [Chapter 9](ch09.html
    "Chapter 9. Creating ImageJ Plugins for Analysis"), *Creating ImageJ Plugins for
    Analysis*, we will look at an implementation of particle analysis in a time series.
  prefs: []
  type: TYPE_NORMAL
- en: After clicking on **OK**, the particles will be added to the ROI Manager, at
    which point, segmenting the particles is completed. We can now measure the particles
    using the same methods for any other area selection that we looked at in the earlier
    sections. Another way of setting the parameters for area and circularity is to
    run the particle analysis, but without restrictions on either the size or circularity
    parameter. This will detect every particle within the image, and the results can
    be filtered after the segmentation. Both methods should give you similar results,
    with an equal amount of work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw some methods to measure parameters within images and
    time series. We used some of the techniques used in the previous chapters to extract
    data from our images. You learned how to visualize dynamic data in a single image
    (kymographs). We looked at colocalization in a qualitative way, as a prelude to
    quantitative analysis later on in the book. Finally, we looked at particle analysis
    as a way to detect similar objects within a single image.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use some of the techniques that you learned and
    apply them in macros to increase your efficiency.
  prefs: []
  type: TYPE_NORMAL
