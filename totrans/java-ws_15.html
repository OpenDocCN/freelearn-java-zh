<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer111">
			</div>
		</div>
		<div class="Content" id="_idContainer112">
			<h1 id="_idParaDest-294"><a id="_idTextAnchor303"/>15. Processing Data with Streams</h1>
		</div>
		<div class="Content" id="_idContainer113">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter discusses the Stream API in Java that allows you to write effectively, with fewer lines of code. Once you have a firm grasp of the differences between parallel and sequential streams (defined and outlined in the early sections), you will be able to practice using the Java Stream API to work with arrays and collections by first learning how to create and close those streams. The next step is to explore the different types of operations available to you in Java, their definitions and their respective functions. The first you will encounter are terminal operations and reducers which you will use to extract data from a stream of elements. You will then move on to intermediate operations to filter, map, and otherwise mutate stream structures. And, finally, in this chapter's final exercise and activity, you will learn to apply different types of collectors to wrap stream elements in new containers.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor304"/>Introduction</h1>
			<p>Java 8 introduced the new Stream API. With streams, Java programmers can now use a more declarative style of writing programs that you have previously only seen in functional programming languages or functional programming libraries. </p>
			<p>Using streams, you can now write more expressive programs with fewer lines of code, and easily chain multiple operations on large lists. Streams also make it simple to parallelize your operations on lists—that is, should you have very large lists or complex operations. One thing that is important to remember about streams is that, while it might appear as though they're an improved collection, they're actually not. Streams do not have any storage of their own; instead, they use the storage of the supplied source.</p>
			<p>In Java, there are four types of streams: <strong class="source-inline">Stream</strong>, which is used for streaming objects; <strong class="source-inline">IntStream</strong>, which is for streaming integers; <strong class="source-inline">LongStream</strong>, which streams longs; and finally, <strong class="source-inline">DoubleStream</strong>, which, of course, streams doubles. All of these streams work in exactly the same way, except they're specialized to work with their respective types.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Diving into the code, you'll find that each of these types is just an interface with static methods pointing back to the <strong class="source-inline">StreamSupport</strong> class. This is the core API for anyone wanting to write stream-specific libraries. However, when building an application, you're usually fine to use the four standard stream interfaces and static generator functions.</p>
			<p>The source of a stream can be either single elements, collections, arrays, or even files. Following the stream source is a number of intermediate operations that form the core pipeline. The pipeline ends with a terminal operation that, usually, either loops through the remaining elements to create a side effect or reduces them to a specific value—for example, counting how many elements there are left in the last stream.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Streams are lazily constructed and executed. This means that a stream is not run until the terminal operation has been executed. Source elements are also only read as needed; that is, only the required elements are carried through to the next operation.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor305"/>Creating Streams</h1>
			<p>There are multiple ways of creating streams in Java; the simplest of these is by using the <strong class="source-inline">Stream.of()</strong> function. This function can take either a single object or multiple objects in <strong class="source-inline">varargs</strong>:</p>
			<p class="source-code">Stream&lt;Object&gt; objectStream = Stream.of(new Object());</p>
			<p>If you have multiple objects in your stream, then use the <strong class="source-inline">varargs</strong> version:</p>
			<p class="source-code">Stream&lt;Object&gt; objectStream = Stream.of(new Object(), new Object(), new Object());</p>
			<p>The primitive versions of these streams work in an identical fashion; just replace the <strong class="source-inline">Object</strong> instances with integers, longs, or doubles.</p>
			<p>You can also create streams from different collections—for example, lists and arrays. Creating a stream from a list will look like this:</p>
			<p class="source-code">List&lt;String&gt; stringList = List.of("string1", "string2", "string3");</p>
			<p class="source-code">Stream&lt;String&gt; stringStream = stringList.stream();</p>
			<p>To create a stream from an array of items, you can use the <strong class="source-inline">Arrays</strong> class, just like the primitive versions of streams do:</p>
			<p class="source-code">String[] stringArray = new String[]{"string1", "string2", "string3"};</p>
			<p class="source-code">Stream&lt;String&gt; stringStream = Arrays.stream(stringArray);</p>
			<p>There is one special type of stream that covers the dreaded null type gracefully, and is detailed as follows:</p>
			<p class="source-code">Stream&lt;Object&gt; nullableStream = Stream.ofNullable(new Object());</p>
			<p>This stream will take one single object that can be null. If the object is null, then it will generate an empty stream; alternatively, if the object is not null, it will generate a stream of that one object. This can, of course, be very handy in situations where we're unsure about the state of sources.</p>
			<p>Another way to generate a stream of elements is by using the <strong class="source-inline">Stream.iterate()</strong> generator function. This function will generate an infinite number of elements in your stream until you tell it to stop, starting at the seed element:</p>
			<p class="source-code">Stream&lt;Integer&gt; stream = Stream.iterate(0, (i) -&gt; {</p>
			<p class="source-code">    return i + 1;</p>
			<p class="source-code">}).limit(5);</p>
			<p>In this example, we're creating a stream of five elements, starting with index <strong class="source-inline">0</strong>. This stream will contain the elements <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and <strong class="source-inline">4</strong>:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">Stream.iterate()</strong> generator function can be quite hazardous if you do not provide the proper limits. There are a number of ways to create infinite streams—usually by placing operations in the wrong order or forgetting to apply a limit to the stream.</p>
			<p>There is also a special <strong class="source-inline">Builder</strong> class, which is embedded in the <strong class="source-inline">Stream</strong> type. This <strong class="source-inline">Builder</strong> class allows you to add elements as you create them; it removes the need to keep an <strong class="source-inline">ArrayList</strong>—or other collection—as a temporary buffer for elements.</p>
			<p>The <strong class="source-inline">Builder</strong> class has a very simple API; you can <strong class="source-inline">accept()</strong> an element into the builder, which is perfect when you want to generate elements from a loop:</p>
			<p class="source-code">Stream.Builder&lt;String&gt; streamBuilder = Stream.builder();</p>
			<p class="source-code">for (int i = 0; i &lt; 10; i++) {</p>
			<p class="source-code">    streamBuilder.accept("string" + i);</p>
			<p class="source-code">}</p>
			<p>You can also <strong class="source-inline">add()</strong> elements to the builder. The <strong class="source-inline">add()</strong> method allows chaining, which is perfect for when you don't want to generate elements from a loop, but instead add them in a single line:</p>
			<p class="source-code">Stream.Builder&lt;String&gt; streamBuilder = Stream.builder();</p>
			<p class="source-code">streamBuilder.add("string1").add("string2").add("string3");</p>
			<p>To create the stream using a builder, you can call the <strong class="source-inline">build()</strong> method when all the methods have been added. However, note that if you try to add elements to the builder after the <strong class="source-inline">build()</strong> method has been called, it will throw an <strong class="source-inline">IllegalStateException</strong>:</p>
			<p class="source-code">Stream&lt;String&gt; stream = streamBuilder.build();</p>
			<p>All these simple ways of creating streams use the same underlying helper class, called <strong class="source-inline">StreamSupport</strong>. This class has a number of helpful and advanced methods for creating streams with different properties. The common denominator for all of these streams is <strong class="source-inline">Spliterator</strong>.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor306"/>Parallel Streams</h2>
			<p>Streams are either sequential or parallel in the Java Stream API. Sequential streams use just a single thread in order to perform any operation. Usually, you'll find that this stream is more than enough to solve most problems; however, sometimes, you may require multiple threads running on multiple cores.</p>
			<p>Parallel streams are operated on in parallel by multiple threads on multiple cores. They utilize <strong class="source-inline">ForkJoinPool</strong> in the JVM to launch multiple threads. They can be a very powerful tool when you find yourself in a performance hotspot. However, as parallel streams utilize multiple threads, you should be wary of using them unless needed; the overhead of parallel streams may very well create more problems than they solve.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Parallel streams are a double-edged sword. They can be extremely useful in certain situations, however, at the same time, they can completely lock your program down. As parallel streams utilize the common <strong class="source-inline">ForkJoinPool</strong>, they spawn threads that may block your application and other system components to such a degree that the user will be affected.</p>
			<p>To create a parallel stream, you can use the <strong class="source-inline">Collections.parallelStream()</strong> method, which will attempt to create a parallel stream:</p>
			<p class="source-code">List.of("string1", "string2", "string3").parallelStream()</p>
			<p>Alternatively, you can make a stream parallel by using the <strong class="source-inline">BaseStream.parallel()</strong> intermediate operation:</p>
			<p class="source-code">List.of(1, 2, 3).stream().parallel()</p>
			<p>Note that, at any point between the source and the terminal operation, you can change the type of the stream, using the <strong class="source-inline">BaseStream.parallel()</strong> or <strong class="source-inline">BaseStream.sequential()</strong> operations. These operations will only have an impact on the stream if they need to change the underlying state of the stream; if the stream already has the correct state, it will simply return itself. Calling <strong class="source-inline">BaseStream.parallel()</strong> multiple times will have no impact on performance:</p>
			<p class="source-code">List.of(1, 2, 3).stream().parallel().parallel().parallel()</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor307"/>Encounter Order</h2>
			<p>Depending on the type of the source for the stream, it may have a different encounter order. Lists, for example, have a built-in ordering of elements—also called the index. The ordering of the source also means that elements will be encountered in that order; however, you can change this encounter order using the <strong class="source-inline">BaseStream.unordered()</strong> and <strong class="source-inline">Stream.sorted()</strong> intermediate operations.</p>
			<p>The <strong class="source-inline">unordered()</strong> operation doesn't change the ordering of a stream; instead, it only attempts to remove a specific attribute and informs us whether a stream is ordered or not. The elements will still have a specific order. The whole point of unordered streams is to make other operations more performant when applied to parallel streams. Applying the <strong class="source-inline">unordered()</strong> operation to a sequential stream will make it non-deterministic.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor308"/>Closing Streams</h2>
			<p>Much like the streams of previous Java versions, <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong>, the Stream API includes a <strong class="source-inline">close()</strong> operation. However, in most cases, you'll never actually need to worry about closing your streams. The only time you should worry about closing your streams is when the source is a system resource—such as files or sockets—which need to be closed to avoid hogging resources from the system.</p>
			<p>The <strong class="source-inline">close()</strong> operation returns void, meaning that after you call <strong class="source-inline">close()</strong>, the stream is unavailable for any other intermediate or terminal operations; although it is possible to register <strong class="source-inline">close</strong> handlers that will be informed when the stream has been closed. The <strong class="source-inline">close</strong> handler is a <strong class="source-inline">Runnable</strong> functional interface; preferably, you'll register them using a lambda function:</p>
			<p class="source-code">Stream.of(1, 2, 3, 4).onClose(() -&gt; {</p>
			<p class="source-code">    System.out.println("Closed");</p>
			<p class="source-code">}).close();</p>
			<p>You can register any number of <strong class="source-inline">close</strong> handlers in your pipeline. The <strong class="source-inline">close</strong> handlers will always run even if any one of them renders an exception in their code. Additionally, it is worth noting that they will always be called in the same order in which they're added to the pipeline, regardless of the encounter order of the stream:</p>
			<p class="source-code">Stream.of(1, 2, 3, 4).onClose(() -&gt; {</p>
			<p class="source-code">    System.out.println("Close handler 1");</p>
			<p class="source-code">}).onClose(() -&gt; {</p>
			<p class="source-code">    System.out.println("Close handler 2");</p>
			<p class="source-code">}).onClose(() -&gt; {</p>
			<p class="source-code">    System.out.println("Close handler 3");</p>
			<p class="source-code">}).close();</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Even if it's possible to register a close handler on any stream, it might not actually run if the stream doesn't need to be closed.</p>
			<p>Since Java 7, there is an interface called <strong class="source-inline">AutoCloseable</strong>, which will attempt to automatically close held resources in a <strong class="source-inline">try-with-resources</strong> statement. The <strong class="source-inline">BaseStream</strong> interface, which all streams inherit from, extends this <strong class="source-inline">AutoCloseable</strong> interface. This means that any stream will attempt to release resources automatically if wrapped in a try-with-resources statement:</p>
			<p class="source-code">try (Stream&lt;Integer&gt; stream = Stream.of(6, 3, 8, 12, 3, 9)) {</p>
			<p class="source-code">    boolean matched = stream.onClose(() -&gt; {</p>
			<p class="source-code">        System.out.println("Closed");</p>
			<p class="source-code">    }).anyMatch((e) -&gt; {</p>
			<p class="source-code">        return e &gt; 10;</p>
			<p class="source-code">    });</p>
			<p class="source-code">    System.out.println(matched);</p>
			<p class="source-code">}</p>
			<p>While the preceding example does work, there's rarely any reason to wrap a basic stream in a try-with-resources statement, other than if you explicitly need to run logic when the stream has finished running. This example will first print <strong class="source-inline">true</strong> to the terminal, and after that print <strong class="source-inline">Closed</strong>.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor309"/>Terminal Operations</h2>
			<p>Every pipeline needs to end with a terminal operation; without this, the pipeline will not be executed. Unlike intermediate operations, terminal operations may have various return values as they mark the end of the pipeline. You cannot apply another operation after a terminal operation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When a terminal operation is applied to a stream, you cannot use that stream again. Therefore, storing references to streams in code can cause confusion as to how that reference might be used – you're not allowed to "split" a stream into two different use cases. If you attempt to apply operations on a stream that already had the terminal operation executed, then it will throw an <strong class="source-inline">IllegalStateException</strong> with the message <strong class="source-inline">stream has already been operated upon or closed</strong>.</p>
			<p>There are 16 different terminal operations in the Stream API—each of them with their own specific use cases. The following is an explanation of each of them:</p>
			<ul>
				<li><strong class="source-inline">forEach</strong>: This terminal operator acts like a normal <strong class="source-inline">for</strong> loop; it will run some code for each element in the stream. This is not a thread-safe operation, so you'll need to provide synchronization should you find yourself using shared state:<p class="source-code">Stream.of(1, 4, 6, 2, 3, 7).forEach((n) -&gt; { System.out.println(n); });</p><p>If this operation is applied on a parallel pipeline, the order in which elements are acted on will not be guaranteed:</p><p class="source-code">Stream.of(1, 4, 6, 2, 3, 7).parallel().forEach((n) -&gt; { System.out.println(n); });</p><p>If the order in which the elements are acted on matters, you should use the <strong class="source-inline">forEachOrdered()</strong> terminal operation instead.</p></li>
				<li><strong class="source-inline">forEachOrdered</strong>: Much like the <strong class="source-inline">forEach()</strong> terminal operation, this will allow you to perform an action for each element in the stream. However, the <strong class="source-inline">forEachOrdered()</strong> operation will guarantee the order in which elements are processed, regardless of how many threads they're processed on:<p class="source-code">Stream.of(1, 4, 6, 2, 3, 7).parallel().forEachOrdered((n) -&gt; { System.out.println(n); });</p><p>Here, you can see a parallel stream with a defined encounter order. Using the <strong class="source-inline">forEachOrdered()</strong> operation, it will always encounter elements in the natural, indexed order.</p></li>
				<li><strong class="source-inline">toArray</strong>: These two terminal operations will allow you to convert the elements of the stream into an array. The basic version will generate an <strong class="source-inline">Object</strong> array:<p class="source-code">Object[] array = Stream.of(1, 4, 6, 2, 3, 7).toArray();</p><p>If you need a specific type of array, you can supply a constructor reference for the type of array you need:</p><p class="source-code">Integer[] array = Stream.of(1, 4, 6, 2, 3, 7).toArray(Integer[]::new);</p><p>A third option is to also write your own generator for the <strong class="source-inline">toArray()</strong> operation:</p><p class="source-code">Integer[] array = Stream.of(1, 4, 6, 2, 3, 7).toArray(elements -&gt; new Integer[elements]);</p></li>
				<li><strong class="source-inline">reduce</strong>: To perform a reduction on a stream means to only extract the interesting parts of the elements of that stream and reduce them to a single value. There are two generic <strong class="source-inline">reduce</strong> operations available. The first, simpler one, takes an accumulator function as an argument. It is usually used after a map operation is applied on a stream: <p class="source-code">int sum = Stream.of(1, 7, 4, 3, 9, 6).reduce(0, (a, b) -&gt; a + b);</p><p>The second, more complex version takes an identity that also acts as the initial value of the reduction. It also requires an accumulator function where the reduction takes place, as well as a combining function to define how two elements are reduced:</p><p class="source-code">int sum = Stream.of(1, 7, 4, 3, 9, 6).reduce(0, (total, i) -&gt; total + i, (a, b) -&gt; a + b );</p><p>In this example, the accumulator adds up the result of the combining function to the identity value, which, in this case, is the total sum of the reduction.</p></li>
				<li><strong class="source-inline">sum</strong>: This is a more specific reduction operation, which will sum all elements in the stream. This terminal operation is only available for <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong>. To use this functionality in a more generic stream, you would have to implement a pipeline using the <strong class="source-inline">reduce()</strong> operation, usually preceded by a <strong class="source-inline">map()</strong> operation. The following example illustrates the use of <strong class="source-inline">IntStream</strong>:<p class="source-code">int intSum = IntStream.of(1, 7, 4, 3, 9, 6).sum();</p><p class="source-code">System.out.println(intSum);</p><p>This will print the result as <strong class="source-inline">30</strong>. The following example illustrates the use of <strong class="source-inline">LongStream</strong>:</p><p class="source-code">long longSum = LongStream.of(7L, 4L, 9L, 2L).sum();</p><p class="source-code">System.out.println(longSum);</p><p>This will print the result as <strong class="source-inline">22</strong>. The following example illustrates the use of <strong class="source-inline">DoubleStream</strong>:</p><p class="source-code">double doubleSum = DoubleStream.of(5.4, 1.9, 7.2, 6.1).sum();</p><p class="source-code">System.out.println(doubleSum);</p><p>This will print the result as <strong class="source-inline">20.6</strong>.</p></li>
				<li><strong class="source-inline">collect</strong>: The collection operation is like the reduce operation, in that it takes the elements of a stream and creates a new result. However, instead of reducing the stream to a single value, <strong class="source-inline">collect</strong> can take the elements and generate a new container or collection that holds all the remaining elements; for example, a list. Usually, you would use the <strong class="source-inline">Collectors</strong> <strong class="source-inline">help</strong> class, as it contains a lot of ready-to-use collect operations:<p class="source-code">List&lt;Integer&gt; items = Stream.of(6, 3, 8, 12, 3, 9).collect(Collectors.toList());</p><p class="source-code">System.out.println(items);</p><p>This would print <strong class="source-inline">[6, 3, 8, 12, 3, 9]</strong> to the console. You can review more usages of <strong class="source-inline">Collectors</strong> in the <em class="italic">Using Collectors</em> section. Another option is to write your own supplier, accumulator, and combiner for the <strong class="source-inline">collect()</strong> operation:</p><p class="source-code">List&lt;Integer&gt; items = Stream.of(6, 3, 8, 12, 3, 9).collect(</p><p class="source-code">        () -&gt; { return new ArrayList&lt;Integer&gt;(); },</p><p class="source-code">        (list, i) -&gt; { list.add(i); },</p><p class="source-code">        (list, elements) -&gt; { list.addAll(elements); });</p><p class="source-code">System.out.println(items);</p><p>This can, of course, be simplified in this example by using method references:</p><p class="source-code">List&lt;Integer&gt; items = Stream.of(6, 3, 8, 12, 3, 9).collect(ArrayList::new, List::add, List::addAll);</p><p class="source-code">System.out.println(items);</p></li>
				<li><strong class="source-inline">min</strong>: As the name suggests, this terminal operation will return the minimum value, wrapped in an <strong class="source-inline">Optional</strong>, of all elements in the stream specified according to a <strong class="source-inline">Comparator</strong>. In most cases, you'd use the <strong class="source-inline">Comparator.comparingInt()</strong>, <strong class="source-inline">Comparator.comparingLong()</strong>, or <strong class="source-inline">Comparator.comparingDouble()</strong> static helper functions when applying this operation:<p class="source-code">Optional min = Stream.of(6, 3, 8, 12, 3, 9).min((a, b) -&gt; { return a - b;});</p><p class="source-code">System.out.println(min);</p><p>This should write <strong class="source-inline">Optional[3]</strong>.</p></li>
				<li><strong class="source-inline">max</strong>: The opposite of the <strong class="source-inline">min()</strong> operation, the <strong class="source-inline">max()</strong> operation returns the value of the element with the maximum value according to a specified <strong class="source-inline">Comparator</strong>, wrapped in an <strong class="source-inline">Optional</strong>:<p class="source-code">Optional max = Stream.of(6, 3, 8, 12, 3, 9).max((a, b) -&gt; { return a - b;});</p><p class="source-code">System.out.println(max);</p><p>This will print <strong class="source-inline">Optional[12]</strong> to the terminal.</p></li>
				<li><strong class="source-inline">average</strong>: This is a special type of terminal operation that is only available on <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong>. It returns an <strong class="source-inline">OptionalDouble</strong> containing the average of all elements in the stream:<p class="source-code">OptionalDouble avg = IntStream.of(6, 3, 8, 12, 3, 9).average();</p><p class="source-code">System.out.println(avg);</p><p>This will give you an <strong class="source-inline">Optional</strong> with the containing value <strong class="source-inline">6.833333333333333</strong>.</p></li>
				<li><strong class="source-inline">count</strong>: This is a simple terminal operator returning the number of elements in the stream. It's worth noting that, sometimes, the <strong class="source-inline">count()</strong> terminal operation will find more efficient ways of calculating the size of the stream. In these cases, the pipeline will not even be executed:<p class="source-code">long count = Stream.of(6, 3, 8, 12, 3, 9).count();</p><p class="source-code">System.out.println(count);</p></li>
				<li><strong class="source-inline">anyMatch</strong>: The <strong class="source-inline">anyMatch()</strong> terminal operator will return true if any of the elements in the stream match the specified predicate:<p class="source-code">boolean matched = Stream.of(6, 3, 8, 12, 3, 9).anyMatch((e) -&gt; { return e &gt; 10; });</p><p class="source-code">System.out.println(matched);</p><p>As there is an element with a value above 10, this pipeline will return <strong class="source-inline">true</strong>.</p></li>
				<li><strong class="source-inline">allMatch</strong>: The <strong class="source-inline">allMatch()</strong> terminal operator will return <strong class="source-inline">true</strong> if all the elements in the stream match the specified predicate:<p class="source-code">boolean matched = Stream.of(6, 3, 8, 12, 3, 9).allMatch((e) -&gt; { return e &gt; 10; });</p><p class="source-code">System.out.println(matched);</p><p>Since this source has elements whose values are below 10, it should return <strong class="source-inline">false</strong>.</p></li>
				<li><strong class="source-inline">noneMatch</strong>: Opposite to <strong class="source-inline">allMatch()</strong>, the <strong class="source-inline">noneMatch()</strong> terminal operator will return <strong class="source-inline">true</strong> if none of the elements in the stream match the specified predicate:<p class="source-code">boolean matched = Stream.of(6, 3, 8, 12, 3, 9).noneMatch((e) -&gt; { return e &gt; 10; });</p><p class="source-code">System.out.println(matched);</p><p>Because the stream has elements of values above 10, this will also return <strong class="source-inline">false</strong>.</p></li>
				<li><strong class="source-inline">findFirst</strong>: This retrieves the first element of the stream, wrapped in an <strong class="source-inline">Optional</strong>:<p class="source-code">Optional firstElement = Stream.of(6, 3, 8, 12, 3, 9).findFirst();</p><p class="source-code">System.out.println(firstElement);</p><p>This will print <strong class="source-inline">Optional[6]</strong> to the terminal. If there were no elements in the stream, it would instead print <strong class="source-inline">Optional.empty</strong>.</p></li>
				<li><strong class="source-inline">findAny</strong>: Much like the <strong class="source-inline">findFirst()</strong> terminal operation, the <strong class="source-inline">findAny()</strong> operation will return an element wrapped in an <strong class="source-inline">Optional</strong>. This operation, however, will return any one of the elements that remain. You should never really assume which element it will return. This operation will, usually, act faster than the <strong class="source-inline">findFirst()</strong> operation, especially in parallel streams. It's ideal when you just need to know whether there are any elements left but don't really care about which remain:<p class="source-code">Optional firstElement = Stream.of(7, 9, 3, 4, 1).findAny();</p><p class="source-code">System.out.println(firstElement);</p></li>
				<li><strong class="source-inline">iterator</strong>: This is a terminal operator that generates an iterator that lets you traverse elements:<p class="source-code">Iterator&lt;Integer&gt; iterator = Stream.of(1, 2, 3, 4, 5, 6)</p><p class="source-code">        .iterator();</p><p class="source-code">while (iterator.hasNext()) {</p><p class="source-code">    Integer next = iterator.next();</p><p class="source-code">    System.out.println(next);</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">summaryStatistics</strong>: This is a special terminal operation that is available for <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong>. It will return a special type—for example, <strong class="source-inline">IntSummaryStatistics</strong>—describing the elements of the stream:<p class="source-code">IntSummaryStatistics intStats = IntStream.of(7, 9, 3, 4, 1).summaryStatistics();</p><p class="source-code">System.out.println(intStats);</p><p class="source-code">LongSummaryStatistics longStats = LongStream.of(6L, 4L, 1L, 3L, 7L).summaryStatistics();</p><p class="source-code">System.out.println(longStats);</p><p class="source-code">DoubleSummaryStatistics doubleStats = DoubleStream.of(4.3, 5.1, 9.4, 1.3, 3.9).summaryStatistics();</p><p class="source-code">System.out.println(doubleStats);</p><p>This will print all the summaries of the three streams to the terminal, which should look like this:</p><p class="source-code">IntSummaryStatistics{count=5, sum=24, min=1, average=4,800000, max=9}</p><p class="source-code">LongSummaryStatistics{count=5, sum=21, min=1, average=4,200000, max=7}</p><p class="source-code">DoubleSummaryStatistics{count=5, sum=24,000000, min=1,300000, average=4,800000, max=9,400000}</p></li>
			</ul>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor310"/>Intermediate Operations</h1>
			<p>A stream can take any number of intermediate operations following the creation of the stream. An intermediate operation is often a filter or mapping of some type, but there are other types as well. Every intermediate operation returns another stream; that way, you can chain any number of intermediate operations to your pipeline.</p>
			<p>The order of intermediate operations is very important as the stream returned from an operation will only reference the remaining or required elements of the previous stream.</p>
			<p>There are several different types of intermediate operations. The following is an explanation of each of them:</p>
			<ul>
				<li><strong class="source-inline">filter</strong>: As the name suggests, this intermediate operation will return a subset of elements from the stream. It uses a predicate when applying the matching pattern, which is a functional interface that returns a <strong class="source-inline">Boolean</strong>. The easiest and most common way to implement this is using a lambda function:<p class="source-code">Stream.of(1, 2, 3, 4, 5, 6)</p><p class="source-code">        .filter((i) -&gt; { return i &gt; 3; })</p><p class="source-code">        .forEach(System.out::println);</p><p>In this example, the <strong class="source-inline">filter</strong> method will filter away any elements that have a value that is 3 or lower. The <strong class="source-inline">forEach()</strong> terminal operation will then take the remaining elements and print them all in a loop.</p></li>
				<li><strong class="source-inline">map</strong>: The <strong class="source-inline">map</strong> operation will apply a special function to every element of the stream and return the modified elements:<p class="source-code">Stream.of("5", "3", "8", "2")</p><p class="source-code">        .map((s) -&gt; { return Integer.parseInt(s); })</p><p class="source-code">        .forEach((i) -&gt; { System.out.println(i &gt; 3); });</p><p>This pipeline will take the strings, convert them to integers using the <strong class="source-inline">map()</strong> operation, and then print either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> depending on whether the parsed string value is more than 3. This is just one simple example of <strong class="source-inline">map</strong>; this method is incredibly versatile in transforming your stream into something very different.</p><p>There are also special versions of this intermediate operation that will return integer values, long values, and double values. They're called <strong class="source-inline">mapToInt()</strong>, <strong class="source-inline">mapToLong()</strong>, and <strong class="source-inline">mapToDouble()</strong>, respectively:</p><p class="source-code">Stream.of("5", "3", "8", "2")</p><p class="source-code">        .mapToInt((i) -&gt; { return Integer.parseInt(i); })</p><p class="source-code">        .forEach((i) -&gt; { System.out.println(i &gt; 3); });</p><p>Note that these special case <strong class="source-inline">map</strong> operations will return <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, or <strong class="source-inline">DoubleStream</strong> rather than <strong class="source-inline">Stream&lt;Integer&gt;</strong>, <strong class="source-inline">Stream&lt;Long&gt;</strong>, or <strong class="source-inline">Stream&lt;Double&gt;</strong>.</p></li>
				<li><strong class="source-inline">flatMap</strong>: This gives you an easy way of flattening a multidimensional data structure into one single stream—for example, a stream of objects that themselves contain objects or arrays. With <strong class="source-inline">flatMap()</strong>, you can take these sub elements and concatenate them into a single stream:<p class="source-code">Stream.of(List.of(1, 2, 3), List.of(4, 5, 6), List.of(7, 8, 9))</p><p class="source-code">        .flatMap((l) -&gt; { return l.stream(); })</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p>In this example pipeline, we're creating a stream from multiple lists; then, in the <strong class="source-inline">flatMap</strong> operation, we're extracting streams of each list. The <strong class="source-inline">flatMap</strong> operation then concatenates them into a single stream, which we loop through with <strong class="source-inline">forEach</strong>. The terminal will print out the full stream: <strong class="source-inline">123456789</strong>.</p><p>The <strong class="source-inline">flatMap</strong> function also exists as an integer, long, and double special operations—<strong class="source-inline">flatMapToInt</strong>, <strong class="source-inline">flatMapToLong</strong>, and <strong class="source-inline">flatMapToDouble</strong>—which, of course, will return the respective typed stream:</p></li>
				<li><strong class="source-inline">distinct</strong>: This will return all the unique elements in the stream. If there are duplicate elements in the stream, the first item will be returned:<p class="source-code">Stream.of(1, 2, 2, 2, 2, 3)</p><p class="source-code">        .distinct()</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p>Here, we're starting with a stream of six elements, however, four of them are identical in value. The <strong class="source-inline">distinct()</strong> operation will filter these elements and the remaining three will be printed to the terminal.</p></li>
				<li><strong class="source-inline">sorted</strong>: The <strong class="source-inline">sorted</strong> intermediate operation exists in two versions. The first version, without arguments, assumes that the elements of the <strong class="source-inline">map</strong> can be sorted in the natural order—implementing the <strong class="source-inline">Comparable</strong> interface. If they can't be sorted, then an exception will be thrown:<p class="source-code">Stream.of(1, 3, 6, 4, 5, 2)</p><p class="source-code">        .sorted()</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p>The second version of the <strong class="source-inline">sorted</strong> operation takes a <strong class="source-inline">Comparator</strong> as an argument, and will return the sorted elements accordingly:</p><p class="source-code">Stream.of(1, 3, 6, 4, 5, 2)</p><p class="source-code">        .sorted((a, b) -&gt; a - b)</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p></li>
				<li><strong class="source-inline">unordered</strong>: The opposite of <strong class="source-inline">sorted</strong>, the <strong class="source-inline">unordered</strong> intermediate operation will impose an unordered encounter order on the streams elements. Using this operation on parallel streams can, sometimes, improve the performance, as certain intermediate and terminal stateful operations perform better with a more relaxed ordering of elements: <p class="source-code">Stream.of(1, 2, 3, 4, 5, 6)</p><p class="source-code">        .unordered()</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p class="source-code">System.out.println();</p><p class="source-code">Stream.of(1, 2, 3, 4, 5, 6)</p><p class="source-code">        .parallel()</p><p class="source-code">        .unordered()</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p></li>
				<li><strong class="source-inline">limit</strong>: This returns a new stream with <strong class="source-inline">n</strong> number of elements. If the number of elements is fewer than the requested limit, it has no effect:<p class="source-code">Stream.of(1, 2, 3, 4, 5, 6)</p><p class="source-code">        .limit(3)</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p>The result of running this example will be <strong class="source-inline">123</strong>, ignoring any elements beyond the third element.</p></li>
				<li><strong class="source-inline">skip</strong>: This skips the first <strong class="source-inline">n</strong> elements of this stream and returns the remaining elements in a new stream:<p class="source-code">Stream.of(1, 2, 3, 4, 5, 6)</p><p class="source-code">        .skip(3)</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p>This will print <strong class="source-inline">456</strong> to the terminal, skipping the first three elements.</p></li>
				<li><strong class="source-inline">boxed</strong>: The special primitive streams, <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong>, all have access to the <strong class="source-inline">boxed()</strong> operation. This operation will "box" each primitive element in the class version of said type, and return that stream. <strong class="source-inline">IntStream</strong> will return <strong class="source-inline">Stream&lt;Integer&gt;</strong>, <strong class="source-inline">LongStream</strong> will return <strong class="source-inline">Stream&lt;Long&gt;</strong>, and <strong class="source-inline">DoubleStream</strong> will return <strong class="source-inline">Stream&lt;Double&gt;</strong>:<p class="source-code">IntStream.of(1, 2)</p><p class="source-code">        .boxed()</p><p class="source-code">        .forEach((i) -&gt; { System.out.println(i + i.getClass().getSimpleName()); });</p><p class="source-code">System.out.println();</p><p class="source-code">LongStream.of(3, 3)</p><p class="source-code">        .boxed()</p><p class="source-code">        .forEach((l) -&gt; { System.out.println(l + l.getClass().getSimpleName()); });</p><p class="source-code">System.out.println();</p><p class="source-code">DoubleStream.of(5, 6)</p><p class="source-code">        .boxed()</p><p class="source-code">        .forEach((d) -&gt; { System.out.println(d + d.getClass().getSimpleName()); });</p><p>This example will take each primitive stream, box it in the corresponding object type, and then print the value together with the class name of the type: </p><p class="source-code">1Integer</p><p class="source-code">2Integer</p><p class="source-code">3Long</p><p class="source-code">4Long</p><p class="source-code">5.0Double</p><p class="source-code">6.0Double</p></li>
				<li><strong class="source-inline">takeWhile</strong>: This is a special type of operation that acts differently depending on whether the stream is ordered or not. If the stream is ordered—that is, it has a defined encounter order—it will return a stream containing the longest streak of matching elements that match the predicate, starting with the first element in the stream. This stream of elements, which always starts with the first element, is also sometimes called a prefix:<p class="source-code">Stream.of(2, 2, 2, 3, 1, 2, 5)</p><p class="source-code">        .takeWhile((i) -&gt; { return i == 2; })</p><p class="source-code">        .forEach((i) -&gt; { System.out.println(i); });</p><p>This pipeline will print <strong class="source-inline">222</strong> to the terminal. You should note, however, that this operation will return an empty stream if the first element doesn't match the predicate. This is because of the inner workings of <strong class="source-inline">takeWhile()</strong>; that is, it will start at the first element and continue until the first element fails to match—giving you an empty stream:</p><p class="source-code">Stream.of(1, 2, 2, 3, 1, 2, 5)</p><p class="source-code">        .takeWhile((i) -&gt; { return i == 2; })</p><p class="source-code">        .forEach((i) -&gt; { System.out.println(i); });</p><p>If the stream is unordered—that is, it has no defined encounter order—the <strong class="source-inline">takeWhile()</strong> operation may return any matching subset of elements, including the empty subset. In this use case, a <strong class="source-inline">filter()</strong> operation might be more suitable.</p></li>
				<li><strong class="source-inline">dropWhile</strong>: The <strong class="source-inline">dropWhile()</strong> operation is the opposite of <strong class="source-inline">takeWhile()</strong>. Just like <strong class="source-inline">takeWhile()</strong>, it will act differently depending on whether the stream is ordered or not. If the stream is ordered, it will drop the longest prefix matching the predicate, instead of returning the prefix like <strong class="source-inline">takeWhile()</strong> does:<p class="source-code">Stream.of(2, 2, 2, 3, 1, 2, 5)</p><p class="source-code">        .dropWhile((i) -&gt; { return i == 2; })</p><p class="source-code">        .forEach((i) -&gt; { System.out.print(i); });</p><p>This pipeline will print <strong class="source-inline">3125</strong> to the terminal, dropping the matching prefix, which is the first three 2's. If the stream is unordered, the operation may drop any subset of elements, or drop an empty subset, effectively returning the whole stream. Be careful when using this operation on unordered streams.</p></li>
				<li><strong class="bold">Parallel</strong>: This returns a parallel stream. By default, the operations in a parallel stream run on threads from the common <strong class="source-inline">ForkJoinPool</strong>. Most streams are sequential unless specifically created as parallel, or turned into parallel using this intermediate operation.</li>
				<li><strong class="bold">Sequential</strong>: This returns a sequential stream and is the opposite of parallel.</li>
				<li><strong class="source-inline">peek</strong>: This intermediate operation is mainly used to examine the stream after other intermediate operations have been applied. Usually, the goal is to understand how the operations have affected the elements. In the following example, we're printing how each element traverses each stream operation in the pipeline:<p class="source-code">long count = Stream.of(6, 5, 3, 8, 1, 9, 2, 4, 7, 0)</p><p class="source-code">        .peek((i) -&gt; { System.out.print(i); })</p><p class="source-code">        .filter((i) -&gt; { return i &lt; 5; })</p><p class="source-code">        .peek((i) -&gt; { System.out.print(i); })</p><p class="source-code">        .map((i) -&gt; { return String.valueOf(i); })</p><p class="source-code">        .peek((p) -&gt; { System.out.print(p); })</p><p class="source-code">        .count();</p><p class="source-code">System.out.println(count);</p><p>The terminal will read <strong class="source-inline">653338111922244470005</strong> in this example. What we can quickly deduce is that any elements with a value of 5 or above will only be printed once. <strong class="source-inline">Peek</strong> will follow each element in turn through the whole stream; that's why the order may seem odd. 6 and 5 will only be printed once, as they're filtered after the first <strong class="source-inline">peek</strong> operation. 3, however, will be triggered on all three <strong class="source-inline">peek()</strong> operations, hence there are three 3's in a row. The last number 5 in the output is just the count of the remaining elements.</p><p>While the <strong class="source-inline">peek()</strong> operation is most commonly used to examine elements as they traverse the pipeline, it is also possible to mutate the elements of the stream using these operations. Consider the following class definition:</p><p class="source-code">class MyItem {</p><p class="source-code">    int value;</p><p class="source-code">    public MyItem(int value) {</p><p class="source-code">        this.value = value;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Then, consider adding a number of these values to a stream that has a mutating <strong class="source-inline">peek</strong> operation applied to it:</p><p class="source-code">long sum = Stream.of(new MyItem(1), new MyItem(2), new MyItem(3))</p><p class="source-code">        .peek((item) -&gt; {</p><p class="source-code">            item.value = 0;</p><p class="source-code">        })</p><p class="source-code">        .mapToInt((item) -&gt; { return item.value; })</p><p class="source-code">        .sum();</p><p class="source-code">System.out.println(sum);</p></li>
			</ul>
			<p>The sum of these objects should have been, if we disregard the <strong class="source-inline">peek()</strong> operation, 6. However, the <strong class="source-inline">peek</strong> operation is mutating each object to have a value of zero—effectively making the sum zero. While this is possible, it was never designed to be used like this. Using <strong class="source-inline">peek()</strong> to mutate is not recommended as it is not thread-safe, and accessing any shared state might cause exceptions. The different <strong class="source-inline">map()</strong> operations are usually a better option.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor311"/>Exercise 1: Using the Stream API</h2>
			<p>An online grocery shop that allows customers to collect, and save, multiple different shopping carts at the same time has asked you to implement a joint checkout for their multiple-shopping cart system. The checkout procedure should concatenate the price for all items in all shopping carts, and then present that to the customer. To do this, perform the following steps:</p>
			<ol>
				<li>If IntelliJ is already started but no project is open, then select <strong class="source-inline">Create New Project</strong>. If IntelliJ already has a project opened, then select <strong class="source-inline">File</strong> | <strong class="source-inline">New</strong> | <strong class="source-inline">Project</strong> from the menu.</li>
				<li>In the <strong class="source-inline">New Project</strong> dialog box, select the <strong class="source-inline">Java project</strong>, and then click <strong class="source-inline">Next</strong>.</li>
				<li>Check the box to create the project from a template. Select <strong class="source-inline">Command Line App</strong>, and then click <strong class="source-inline">Next</strong>.</li>
				<li>Give the new project the name <strong class="source-inline">Chapter15</strong>.</li>
				<li>IntelliJ will give you a default project location. If you wish to select one, you may enter it here.</li>
				<li>Set the package name to <strong class="source-inline">com.packt.java.chapter15</strong>.</li>
				<li>Click <strong class="source-inline">Finish</strong>.<p>IntelliJ will create your project, called <strong class="source-inline">Chapter15</strong>, with the standard folder structure. IntelliJ will also create the main entry point for your application, called <strong class="source-inline">Main.java</strong>. </p></li>
				<li>Rename this file to <strong class="source-inline">Exercise1.java</strong>. When you're done, it should look like this:<p class="source-code">package com.packt.java.chapter15;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a new inner class, called <strong class="source-inline">ShoppingArticle</strong>. Make it static so that we can easily access it from the main entry point for our program. This class should contain the name of the article and the price of that article. Let the <strong class="source-inline">price</strong> be a double variable:<p class="source-code">    private static final class ShoppingArticle {</p><p class="source-code">        final String name;</p><p class="source-code">        final double price;</p><p class="source-code">        public ShoppingArticle(String name, double price) {</p><p class="source-code">            this.name = name;</p><p class="source-code">            this.price = price;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Now create a simple <strong class="source-inline">ShoppingCart</strong> class. In this version, we will only allow one item per article in the cart, so a list will be enough to keep the articles in <strong class="source-inline">ShoppingCart</strong>:<p class="source-code">    private static final class ShoppingCart {</p><p class="source-code">        final List&lt;ShoppingArticle&gt; mArticles;</p><p class="source-code">        public ShoppingCart(List&lt;ShoppingArticle&gt; list) {</p><p class="source-code">            mArticles = List.copyOf(list);</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Create your first shopping cart, <strong class="source-inline">fruitCart</strong>, and add three fruit articles to it – <strong class="source-inline">Orange</strong>, <strong class="source-inline">Apple</strong>, and <strong class="source-inline">Banana</strong>—one of each type. Set the per-unit price to <strong class="source-inline">1.5</strong>, <strong class="source-inline">1.7</strong>, and <strong class="source-inline">2.2</strong> <strong class="source-inline">Java-$</strong> each:<p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        ShoppingCart fruitCart = new ShoppingCart(List.of(</p><p class="source-code">                new ShoppingArticle("Orange", 1.5),</p><p class="source-code">                new ShoppingArticle("Apple", 1.7),</p><p class="source-code">                new ShoppingArticle("Banana", 2.2)</p><p class="source-code">        ));</p><p class="source-code">    }</p></li>
				<li>Create another <strong class="source-inline">ShoppingCart</strong>, but this time with vegetables—<strong class="source-inline">Cucumber</strong>, <strong class="source-inline">Salad</strong>, and <strong class="source-inline">Tomatoes</strong>. Set a price in Java-$ for them as well, as <strong class="source-inline">0.8</strong>, <strong class="source-inline">1.2</strong>, and <strong class="source-inline">2.7</strong>:<p class="source-code">        ShoppingCart vegetableCart = new ShoppingCart(List.of(</p><p class="source-code">                new ShoppingArticle("Cucumber", 0.8),</p><p class="source-code">                new ShoppingArticle("Salad", 1.2),</p><p class="source-code">                new ShoppingArticle("Tomatoes", 2.7)</p><p class="source-code">        ));</p><p class="source-code">    }</p></li>
				<li>Wrap up the test shopping carts with a third and final <strong class="source-inline">shoppingCart</strong> containing some meat and fish. They're usually a little more expensive than fruit and vegetables:<p class="source-code">        ShoppingCart meatAndFishCart = new ShoppingCart(List.of(</p><p class="source-code">                new ShoppingArticle("Cod", 46.5),</p><p class="source-code">                new ShoppingArticle("Beef", 29.1),</p><p class="source-code">                new ShoppingArticle("Salmon", 35.2)</p><p class="source-code">        ));</p><p class="source-code">    }</p></li>
				<li>Now it's time to start implementing the function that will calculate the total price of all the items in the shopping carts. Declare a new function that takes a <strong class="source-inline">ShoppingCart</strong> <strong class="source-inline">vararg</strong> as an argument and returns a double. Let it be static so that we can easily use it in the <strong class="source-inline">main</strong> function:<p class="source-code">    private static double calculatePrice(ShoppingCart... carts) {</p><p class="source-code">    }</p></li>
				<li>Build a pipeline starting with a stream of all of the carts:<p class="source-code">private static double calculatePrice(ShoppingCart... carts) {</p><p class="source-code">        return Stream.of(carts)</p><p class="source-code">    }</p></li>
				<li>Add a <strong class="source-inline">flatMap()</strong> operation to extract a single stream of <strong class="source-inline">ShoppingArticles</strong> for all <strong class="source-inline">ShoppingCarts</strong>:<p class="source-code">    private static double calculatePrice(ShoppingCart... carts) {</p><p class="source-code">        return Stream.of(carts)</p><p class="source-code">            .flatMap((cart) -&gt; { return cart.mArticles.stream(); })</p><p class="source-code">    }</p></li>
				<li>Extract the price for each <strong class="source-inline">ShoppingArticle</strong> using the <strong class="source-inline">mapToDouble()</strong> operation; this will create a <strong class="source-inline">DoubleStream</strong>:<p class="source-code">    private static double calculatePrice(ShoppingCart... carts) {</p><p class="source-code">        return Stream.of(carts)</p><p class="source-code">            .flatMap((cart) -&gt; { return cart.mArticles.stream(); })</p><p class="source-code">            .mapToDouble((item) -&gt; { return item.price; })</p><p class="source-code">    }</p></li>
				<li>Finally, reduce the prices of all <strong class="source-inline">ShoppingArticle</strong> to a sum, using the <strong class="source-inline">sum()</strong> method that is available in <strong class="source-inline">DoubleStream</strong>:<p class="source-code">private static double calculatePrice(ShoppingCart... carts) {</p><p class="source-code">    return Stream.of(carts)</p><p class="source-code">            .flatMap((cart) -&gt; { return cart.mArticles.stream(); })</p><p class="source-code">            .mapToDouble((item) -&gt; { return item.price; })</p><p class="source-code">            .sum();</p><p class="source-code">}</p></li>
				<li>Now you have a function that will reduce a list of <strong class="source-inline">ShoppingCart</strong> to a unified sum in Java-$. All you have to do now is to apply this function to your <strong class="source-inline">ShoppingCart</strong> class, and then print out the resulting sum to the terminal, rounding it to two decimals:<p class="source-code">    double sum = calculatePrice(fruitCart, vegetableCart, meatAndFishCart);</p><p class="source-code">    System.out.println(String.format("Sum: %.2f", sum));</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">You can refer the complete code at: <a href="https://packt.live/2qzLaHx">https://packt.live/2qzLaHx</a>.</p></li>
			</ol>
			<p>You've now created your first complete piece of code using the functional Java Stream API. You've created a stream of complex objects, applying a mapping operation to the elements of the stream to transform them, and then another mapping operation to transform the elements yet again, changing the stream type twice. Finally, you reduced the whole stream to a single primitive value that was presented to the user.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor312"/>Activity 1: Applying Discount on the Items</h2>
			<p>Improve the preceding example by adding a function that applies a discount for certain items in the shopping carts, before calculating the final price. Ensure the price calculation is still correct.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 563.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor313"/>Using Collectors</h1>
			<p><strong class="bold">Collectors</strong> in Java are a very powerful tool when you need to extract certain data points, descriptions, or elements from large data structures. They offer a very understandable way of describing what you want to do with a stream of elements, without needing to write complex logic.</p>
			<p>There are a number of helpful default implementations of the <strong class="source-inline">Collector</strong> interface that you can start using easily. Most of these collectors will not allow null values; that is, if they find a null value in your stream, they will throw a <strong class="source-inline">NullPointerException</strong>. Before using a collector to reduce your elements in any of these containers, you should take care to handle null elements in the stream.</p>
			<p>The following is an introduction to all default Collectors:</p>
			<ul>
				<li><strong class="source-inline">toCollection</strong>: This generic collector will allow you to wrap your elements in any known class implementing the <strong class="source-inline">Collection</strong> interface; examples include <strong class="source-inline">ArrayList</strong>, <strong class="source-inline">HashSet</strong>, <strong class="source-inline">LinkedList</strong>, <strong class="source-inline">TreeSet</strong>, and others:<p class="source-code">List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toCollection(TreeSet::new));</p></li>
				<li><strong class="source-inline">toList</strong>: This will reduce your elements into an <strong class="source-inline">ArrayList</strong> implementation. If you need a more specific type of list, you should use the <strong class="source-inline">toCollection()</strong> collector:<p class="source-code">List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toList());</p></li>
				<li><strong class="source-inline">toUnmodifiableList</strong>: This is essentially the same as the <strong class="source-inline">toList()</strong> collector, with the one difference that it uses the <strong class="source-inline">List.of()</strong> generator function to make the list unmodifiable:<p class="source-code">List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toUnmodifiableList());</p></li>
				<li><strong class="source-inline">toSet</strong>: This wraps the elements in a <strong class="source-inline">HashSet</strong>:<p class="source-code">List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toSet());</p></li>
				<li><strong class="source-inline">toUnmodifiableSet</strong>: This is just like the <strong class="source-inline">toSet()</strong> collector, with the difference being that it will use the <strong class="source-inline">Set.of()</strong> generator to create an unmodifiable set:<p class="source-code">List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toUnmodifiableSet());</p></li>
				<li><strong class="source-inline">joining</strong>: This collector will use a <strong class="source-inline">StringBuilder</strong> to concatenate the elements of the stream into a string without any separating characters:<p class="source-code">String joined = List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.joining());</p><p class="source-code">System.out.println(joined);</p><p>This will print <strong class="source-inline">onetwothreefourfive</strong> to the terminal. If you need the elements to be separated by a comma, for example, use <strong class="source-inline">Collectors.joining(",")</strong>:</p><p class="source-code">String joined = List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.joining(","));</p><p class="source-code">System.out.println(joined);</p><p>In this example, you get <strong class="source-inline">one,two,three,four,five</strong> printed to the terminal. Finally, you have the option of adding a prefix and a suffix to the generated string as well:</p><p class="source-code">String joined = List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.joining(",", "Prefix", "Suffix"));</p><p class="source-code">System.out.println(joined);</p><p>The prefix and suffix are added to the string, not each element. The generated string will look like: <strong class="source-inline">Prefixone,two,three,four,fiveSuffix</strong>.</p></li>
				<li><strong class="source-inline">mapping</strong>: This is a special type of collector that allows you to apply a mapping to each element of the stream before applying a defined collector:<p class="source-code">Set&lt;String&gt; mapped = List.of("one", "two", "three", "four", "five")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.mapping((s) -&gt; { return s + "-suffix"; }, Collectors.toSet()));</p><p class="source-code">System.out.println(mapped);</p><p>Here, we're starting with a source of <strong class="source-inline">List&lt;String&gt;</strong> and collecting to a <strong class="source-inline">Set&lt;String&gt;</strong>. But before we collect, we're concatenating a <strong class="source-inline">-suffix</strong> string to each element using the <strong class="source-inline">mapping()</strong> collector.</p></li>
				<li><strong class="source-inline">flatMapping</strong>. Just like the <strong class="source-inline">flatMap()</strong> intermediate operation, this collector will allow you to apply a flat mapping to the stream elements, before collecting them to a new container. In the following example, we start with a source, <strong class="source-inline">List&lt;Set&lt;String&gt;&gt;</strong>, then we flatten it out to a <strong class="source-inline">Stream&lt;Set&lt;String&gt;&gt;</strong> and apply <strong class="source-inline">Collector.toList()</strong>—effectively turning all the sets into a single list instead:<p class="source-code">List&lt;String&gt; mapped = List.of(</p><p class="source-code">        Set.of("one", "two", "three"),</p><p class="source-code">        Set.of("four", "five"),</p><p class="source-code">        Set.of("six")</p><p class="source-code">)</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.flatMapping(</p><p class="source-code">                (set) -&gt; { return set.stream(); },</p><p class="source-code">                Collectors.toList())</p><p class="source-code">        );</p><p class="source-code">System.out.println(mapped);</p></li>
				<li><strong class="bold">filtering</strong>: Just like the <strong class="source-inline">filter()</strong> intermediate operation, here, you're allowed to apply a filtering before you implement operations on the stream. <p class="source-code">Set&lt;String&gt; collected = List.of("Andreas", "David", "Eric")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.filtering(</p><p class="source-code">                (name) -&gt; { return name.length() &lt; 6; },</p><p class="source-code">                Collectors.toSet())</p><p class="source-code">        );</p><p class="source-code">System.out.println(collected);</p></li>
				<li><strong class="source-inline">collectingAndThen</strong>: This special collector will allow you to finish the collection off with a special function; for example, turning your collection into an immutable collection:<p class="source-code">Set&lt;String&gt; immutableSet = List.of("Andreas", "David", "Eric")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.collectingAndThen(</p><p class="source-code">                Collectors.toSet(), </p><p class="source-code">                (set) -&gt; { return Collections.unmodifiableSet(set); })</p><p class="source-code">        );</p><p class="source-code">System.out.println(immutableSet);</p></li>
				<li><strong class="source-inline">counting</strong>: This produces the same result as the <strong class="source-inline">count()</strong> intermediate operation:<p class="source-code">long count = List.of("Andreas", "David", "Eric")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.counting());</p><p class="source-code">System.out.println(count);</p></li>
				<li><strong class="source-inline">minBy</strong>: This collector is equivalent to using the <strong class="source-inline">min()</strong> terminal operator. The following example will print <strong class="source-inline">Optional[1]</strong> to the terminal:<p class="source-code">Optional&lt;Integer&gt; smallest = Stream.of(1, 2, 3)</p><p class="source-code">        .collect(Collectors.minBy((a, b) -&gt; { return a - b; });</p><p class="source-code">System.out.println(smallest);</p></li>
				<li><strong class="source-inline">maxBy</strong>: You'll get the same result using this collector as you would with the <strong class="source-inline">max()</strong> terminal operator:<p class="source-code">Optional&lt;Integer&gt; biggest = Stream.of(1, 2, 3)</p><p class="source-code">        .collect(Collectors.maxBy((a, b) -&gt; { return a - b; }));</p><p class="source-code">System.out.println(biggest);</p></li>
				<li><strong class="source-inline">summingInt</strong>: This is an alternative to the <strong class="source-inline">reduce()</strong> intermediate operation, and is used to calculate the sum of all elements in the stream:<p class="source-code">int sum = Stream.of(1d, 2d, 3d)</p><p class="source-code">        .collect(Collectors.summingInt((d) -&gt; { return d.intValue(); }));</p><p class="source-code">System.out.println(sum);</p></li>
				<li><strong class="source-inline">summingLong</strong>: This is the same as <strong class="source-inline">Collector.summingInt()</strong>, but will instead produce a sum in the <strong class="source-inline">long</strong> type:<p class="source-code">long sum = Stream.of(1d, 2d, 3d)</p><p class="source-code">        .collect(Collectors.summingLong((d) -&gt; { return d.longValue(); }));</p><p class="source-code">System.out.println(sum);</p></li>
				<li><strong class="source-inline">summingDouble</strong>: This is the same as <strong class="source-inline">Collector.summingLong()</strong>, but will instead produce a sum in the <strong class="source-inline">double</strong> type:<p class="source-code">double sum = Stream.of(1, 2, 3)</p><p class="source-code">        .collect(Collectors.summingDouble((i) -&gt; { return i.doubleValue(); }));</p><p class="source-code">System.out.println(sum);</p></li>
				<li><strong class="source-inline">averagingInt</strong>: Returns the average the integers passed: <p class="source-code">double average = Stream.of(1d, 2d, 3d)</p><p class="source-code">        .collect(Collectors.averagingInt((d) -&gt; { return d.intValue(); }));</p><p class="source-code">System.out.println(average);</p></li>
				<li><strong class="source-inline">averagingLong</strong>: Returns the average the longs passed:<p class="source-code">double average = Stream.of(1d, 2d, 3d)</p><p class="source-code">        .collect(Collectors.averagingLong((d) -&gt; { return d.longValue(); }));</p><p class="source-code">System.out.println(average);</p></li>
				<li><strong class="source-inline">averagingDouble</strong>: Returns the average of the numbers passed in the argument:<p class="source-code">double average = Stream.of(1, 2, 3)</p><p class="source-code">        .collect(Collectors.averagingDouble((i) -&gt; { return i.doubleValue(); }));</p><p class="source-code">System.out.println(average);x§</p></li>
				<li><strong class="bold">Reducing</strong>: This is a collector that reduces the element of the stream to an optional. This is best utilized when used in combination with other collectors; otherwise, you are probably better off using the normal <strong class="source-inline">reduce()</strong> terminal operator, which this collector inherits its name and operation from.</li>
				<li><strong class="source-inline">groupingBy</strong>: This collector will group elements according to a given function and collect them according to a given collection type. Consider the following example class, describing a car:<p class="source-code">private static class Car {</p><p class="source-code">    String brand;</p><p class="source-code">    long enginePower;</p><p class="source-code">    Car(String brand, long enginePower) {</p><p class="source-code">        this.brand = brand;</p><p class="source-code">        this.enginePower = enginePower;</p><p class="source-code">    }</p><p class="source-code">    public String getBrand() {</p><p class="source-code">        return brand;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public String toString() {</p><p class="source-code">        return brand + ": " + enginePower;</p><p class="source-code">    }</p><p class="source-code">} </p><p>If you would like to sort a few cars according to their brand and collect them into new containers, then it's simple with the <strong class="source-inline">groupingBy()</strong> collector:</p><p class="source-code">Map&lt;String, List&lt;Car&gt;&gt; grouped = Stream.of(</p><p class="source-code">        new Car("Toyota", 92),</p><p class="source-code">        new Car("Kia", 104),</p><p class="source-code">        new Car("Hyundai", 89),</p><p class="source-code">        new Car("Toyota", 116),</p><p class="source-code">        new Car("Mercedes", 209))</p><p class="source-code">        .collect(Collectors.groupingBy(Car::getBrand));</p><p class="source-code">System.out.println(grouped);</p><p>Here, we have four different cars. Then, we apply the <strong class="source-inline">groupingBy()</strong> collector based on the brand of cars. This will produce a <strong class="source-inline">Map&lt;String, List&lt;Car&gt;&gt;</strong> collection, where <strong class="source-inline">String</strong> is the brand of the car, and the <strong class="source-inline">List</strong> contains all the cars for said brand. This will always return <strong class="source-inline">Map</strong>; however, it is possible to define what kind of collection to gather the grouped elements in. In the following example, we've grouped them into <strong class="source-inline">Set</strong> instead of the default list:</p><p class="source-code">Map&lt;String, Set&lt;Car&gt;&gt; grouped = Stream.of(</p><p class="source-code">        new Car("Toyota", 92),</p><p class="source-code">        new Car("Kia", 104),</p><p class="source-code">        new Car("Hyundai", 89),</p><p class="source-code">        new Car("Toyota", 116),</p><p class="source-code">        new Car("Mercedes", 209))</p><p class="source-code">        .collect(Collectors.groupingBy(Car::getBrand, Collectors.          toSet()));</p><p class="source-code">System.out.println(grouped);</p><p>The <strong class="source-inline">groupingBy</strong> collector becomes even more powerful if you combine it with another collector—for example, the <strong class="source-inline">reducing</strong> collector:</p><p class="source-code">Map&lt;String, Optional&lt;Car&gt;&gt; collected = Stream.of(</p><p class="source-code">        new Car("Volvo", 195),</p><p class="source-code">        new Car("Honda", 96),</p><p class="source-code">        new Car("Volvo", 165),</p><p class="source-code">        new Car("Volvo", 165),</p><p class="source-code">        new Car("Honda", 104),</p><p class="source-code">        new Car("Honda", 201),</p><p class="source-code">        new Car("Volvo", 215))</p><p class="source-code">        .collect(Collectors.groupingBy(Car::getBrand, Collectors.          reducing((carA, carB) -&gt; {</p><p class="source-code">            if (carA.enginePower &gt; carB.enginePower) {</p><p class="source-code">                return carA;</p><p class="source-code">            }</p><p class="source-code">            return carB;</p><p class="source-code">        })));</p><p class="source-code">System.out.println(collected);</p><p>In this example, we group the cars by brand and then reduce them to only show the car of each brand with the most powerful engine. This kind of combination, of course, also works with other collectors, such as filtering, counting, and others:</p></li>
				<li><strong class="bold">GroupingByConcurrent</strong>: This is a concurrent and unordered version of the <strong class="source-inline">groupingBy</strong> collector, and has the exact same API.</li>
				<li><strong class="source-inline">partitioningBy</strong>: The <strong class="source-inline">partitioningBy</strong> collector works in a similar way to the <strong class="source-inline">groupingBy</strong> collector, with the difference being that it will group elements into two collections that either matches a predicate or doesn't match a predicate. It will wrap these two collections into <strong class="source-inline">Map</strong>, where the <strong class="source-inline">true</strong> keyword will reference the collection of elements that matches the predicate, and the <strong class="source-inline">false</strong> keyword will reference the elements that don't match the predicate:<p class="source-code">Map&lt;Boolean, List&lt;Car&gt;&gt; partitioned = Stream.of(</p><p class="source-code">        new Car("Toyota", 92),</p><p class="source-code">        new Car("Kia", 104),</p><p class="source-code">        new Car("Hyundai", 89),</p><p class="source-code">        new Car("Toyota", 116),</p><p class="source-code">        new Car("Mercedes", 209))</p><p class="source-code">        .collect(Collectors.partitioningBy((car) -&gt; { return car.          enginePower &gt; 100; }));</p><p class="source-code">System.out.println(partitioned);</p><p>You can also select which kind of collection the elements should be wrapped in, just like the <strong class="source-inline">groupingBy</strong> collector:</p><p class="source-code">Map&lt;Boolean, Set&lt;Car&gt;&gt; partitioned = Stream.of(</p><p class="source-code">        new Car("Toyota", 92),</p><p class="source-code">        new Car("Kia", 104),</p><p class="source-code">        new Car("Hyundai", 89),</p><p class="source-code">        new Car("Toyota", 116),</p><p class="source-code">        new Car("Mercedes", 209))</p><p class="source-code">        .collect(Collectors.partitioningBy((car) -&gt; { return car.          enginePower &gt; 100; }, Collectors.toSet()));</p><p class="source-code">System.out.println(partitioned);</p></li>
				<li><strong class="source-inline">toMap</strong>: This collector will allow you to create a <strong class="source-inline">map</strong> from your stream elements by defining a mapping function, where you provide a key and value to put into the <strong class="source-inline">map</strong>. Often, this is just a unique identifier in the element and the element itself.<p>This can be a little bit tricky because if you provide a duplicate element, then your pipeline will throw an <strong class="source-inline">IllegalStateException</strong> since <strong class="source-inline">Map</strong> is not allowed duplicate keys:</p><p class="source-code">Map&lt;String, Integer&gt; mapped = List.of("1", "2", "3", "4", "5")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toMap((s) -&gt; {</p><p class="source-code">            return s;</p><p class="source-code">        }, (s) -&gt; {</p><p class="source-code">            return Integer.valueOf(s);</p><p class="source-code">        }));</p><p class="source-code">System.out.println(mapped);</p><p>This simple example demonstrates how to map a string representation of an integer to the actual integer. If you know you may have duplicate elements, then you can supply a <strong class="source-inline">merge</strong> function to resolve that conflict:</p><p class="source-code">Map&lt;String, Integer&gt; mapped = List.of("1", "2", "3", "4", "5", "1", "2")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toMap((s) -&gt; {</p><p class="source-code">            return s;</p><p class="source-code">        }, (s) -&gt; {</p><p class="source-code">            return Integer.valueOf(s);</p><p class="source-code">        }, (a, b) -&gt; {</p><p class="source-code">            return Integer.valueOf(b);</p><p class="source-code">        }));</p><p class="source-code">System.out.println(mapped);</p><p>You also have the option of generating your own type of <strong class="source-inline">Map</strong> by applying a <strong class="source-inline">factory</strong> function at the very end of the collector. Here, we're telling the collector to generate a fresh <strong class="source-inline">TreeMap</strong> for us:</p><p class="source-code">TreeMap&lt;String, Integer&gt; mapped = List.of("1", "2", "3", "4", "5", "1", "2")</p><p class="source-code">        .stream()</p><p class="source-code">        .collect(Collectors.toMap((s) -&gt; {</p><p class="source-code">            return s;</p><p class="source-code">        }, (s) -&gt; {</p><p class="source-code">            return Integer.valueOf(s);</p><p class="source-code">        }, (a, b) -&gt; {</p><p class="source-code">            return Integer.valueOf(b);</p><p class="source-code">        }, () -&gt; {</p><p class="source-code">            return new TreeMap&lt;&gt;();</p><p class="source-code">        }));</p><p class="source-code">System.out.println(mapped);</p></li>
				<li><strong class="source-inline">toUnmodifiableMap</strong>: This is essentially the same as <strong class="source-inline">toMap</strong>, with the same API; however, it returns unmodifiable versions of <strong class="source-inline">Map</strong> instead. This is perfect for when you know you will never mutate the data in <strong class="source-inline">Map</strong>.</li>
				<li><strong class="source-inline">toConcurrentMap</strong>: Because of the way <strong class="source-inline">Map</strong> is implemented, it can be a bit hazardous to performance when using it in parallel streams. In this case, it's recommended that you use the <strong class="source-inline">toConcurrentMap()</strong> collector instead. This has a similar API to the other <strong class="source-inline">toMap</strong> functions, with the difference being that it will return instances of <strong class="source-inline">ConcurrentMap</strong> rather than <strong class="source-inline">Map</strong>.</li>
				<li><strong class="bold">Summarizing</strong>: This is a collector that enables summary statistics for non-primitive streams. It is perfect if you need to display some statistics about complex objects without having to first apply other intermediate operations. Considering the <strong class="source-inline">Car</strong> class from previous collectors, you could produce a summary of all car engines like this:<p class="source-code">LongSummaryStatistics statistics = Stream.of(</p><p class="source-code">        new Car("Volvo", 165),</p><p class="source-code">        new Car("Volvo", 165),</p><p class="source-code">        new Car("Honda", 104),</p><p class="source-code">        new Car("Honda", 201)</p><p class="source-code">).collect(Collectors.summarizingLong((e) -&gt; {</p><p class="source-code">    return e.enginePower;</p><p class="source-code">}));</p><p class="source-code">System.out.println(statistics);</p></li>
			</ul>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor314"/>I/O Streams</h2>
			<p>Apart from collections and other primitives, you can use files and I/O streams as sources in your pipelines. This makes writing tasks against servers very descriptive.</p>
			<p>Because these types of resources generally need to be closed properly, you should use a try-with-resources statement to ensure the resources are handed back to the system when you're done with them.</p>
			<p>Consider having a CSV file called <strong class="source-inline">authors.csv</strong> with these contents:</p>
			<p class="source-code">Andreas, 42, Sweden</p>
			<p class="source-code">David, 37, Sweden</p>
			<p class="source-code">Eric, 39, USA</p>
			<p>You can put this file into a stream using a try-with-resources statement:</p>
			<p class="source-code">String filePath = System.getProperty("user.dir") + File.separator +  "res/authors.csv";</p>
			<p class="source-code">try (Stream&lt;String&gt; authors = Files.lines(Paths.get(filePath))) {</p>
			<p class="source-code">    authors.forEach((author) -&gt; {</p>
			<p class="source-code">        System.out.println(author);</p>
			<p class="source-code">    });</p>
			<p class="source-code">} catch (IOException e) {</p>
			<p class="source-code">    e.printStackTrace();</p>
			<p class="source-code">}</p>
			<p>In I/O streams, you can add <strong class="source-inline">onClose</strong> handlers to receive a notification when the stream is closed. Unlike other streams, this will be closed automatically when the resources for the stream have been closed. In this example, that's handled automatically by the try-with-resources statement. In the following example, we've added an <strong class="source-inline">onClose</strong> handler that will print the word <strong class="source-inline">Closed</strong> when the stream has been closed:</p>
			<p class="source-code">try (Stream&lt;String&gt; authors = Files.lines(Paths.get(filePath))) {</p>
			<p class="source-code">    authors.onClose(() -&gt; {</p>
			<p class="source-code">        System.out.println("Closed");</p>
			<p class="source-code">    }).forEach((author) -&gt; {</p>
			<p class="source-code">        System.out.println(author);</p>
			<p class="source-code">    });</p>
			<p class="source-code">} catch (IOException e) {</p>
			<p class="source-code">    e.printStackTrace();</p>
			<p class="source-code">}</p>
			<p>Here is the same example written with an <strong class="source-inline">InputStream</strong> instead. Notice that the code is now more verbose, having three nested object creations:</p>
			<p class="source-code">try (Stream&lt;String&gt; authors = new BufferedReader(</p>
			<p class="source-code">        new InputStreamReader(new FileInputStream(filePath))).lines()</p>
			<p class="source-code">) {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">} catch (FileNotFoundException e) {</p>
			<p class="source-code">    e.printStackTrace();</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor315"/>Exercise 2: Converting CSV to a List</h2>
			<p>A web-based grocery shop has implemented its very own database based on a standard Java <strong class="source-inline">List</strong> collection, and has also implemented a backup system where the database is backed up to CSV files. However, they still haven't built a way of restoring that database from a CSV file. They have asked you to build a system that will read such a CSV file, inflating its contents to a list.</p>
			<p>The database backup CSV file contains one single type of object: <strong class="source-inline">ShoppingArticle</strong>. Each article has a <strong class="source-inline">name</strong>, a <strong class="source-inline">price</strong>, a <strong class="source-inline">category</strong>, and finally, a <strong class="source-inline">unit</strong>. The name, category, and unit should each be a <strong class="source-inline">String</strong>, and the price a <strong class="source-inline">double</strong>:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Chapter15</strong> project in IDEA if it's not already open.</li>
				<li>Create a new Java class, using <strong class="source-inline">File</strong>| <strong class="source-inline">New</strong> | <strong class="source-inline">Java</strong>.</li>
				<li>Enter <strong class="source-inline">Exercise2</strong> as the name, and then select <strong class="source-inline">OK</strong>.<p>IntelliJ will create your new class; it should look something like the following snippet:</p><p class="source-code">package com.packt.java.chapter15;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">main</strong> method to this class. This is where you'll write the bulk of your application. Your class should now look like this:<p class="source-code">package com.packt.java.chapter15;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">ShoppingArticle</strong> inner class and make it static so that you can easily use it in the main method. Override the <strong class="source-inline">toString</strong> method to make it easy to print articles to the terminal later:<p class="source-code">    private static class ShoppingArticle {</p><p class="source-code">        final String name;</p><p class="source-code">        final String category;</p><p class="source-code">        final double price;</p><p class="source-code">        final String unit;</p><p class="source-code">        private ShoppingArticle(String name, String category, double price,           String unit) {</p><p class="source-code">            this.name = name;</p><p class="source-code">            this.category = category;</p><p class="source-code">            this.price = price;</p><p class="source-code">            this.unit = unit;</p><p class="source-code">        }</p><p class="source-code">        @Override</p><p class="source-code">        public String toString() {</p><p class="source-code">            return name + " (" + category + ")";</p><p class="source-code">        }</p><p class="source-code">    <a id="_idTextAnchor316"/>}</p></li>
				<li>Create a new folder in your project called <strong class="source-inline">res</strong> if it doesn't already exist. Then, place it in the root, next to the <strong class="source-inline">src</strong> folder.</li>
				<li>Copy the <strong class="source-inline">database.csv</strong> file from GitHub to your project and place it in the <strong class="source-inline">res</strong> folder.</li>
				<li>Back in your <strong class="source-inline">Exercise2.java</strong> class, add a function that produces <strong class="source-inline">List&lt;ShoppingArticle&gt;</strong>. This will be our function to load the database into a list. Since the function will be loading a file, it needs to throw an I/O exception (<strong class="source-inline">IOException</strong>):<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Call this function from your <strong class="source-inline">main</strong> method:<p class="source-code">public static void main(String[] args) {</p><p class="source-code">    try {</p><p class="source-code">        List&lt;ShoppingArticle&gt; database = loadDatabaseFile();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Start by loading the database file with a try-with-resources block. Use <strong class="source-inline">Files.lines</strong> to load all the lines from the <strong class="source-inline">database.csv</strong> file. It should look something like this:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Let's peek into the stream in order to look at the state of it right now. Intermediate operations will only run when there's a terminal operation defined, so add a <strong class="source-inline">count()</strong> at the end just to force it to execute the whole pipeline:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).count();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p><p>This should print every single line of the file. Notice that it also prints the header line—which we're not concerned with when converting to <strong class="source-inline">ShoppingArticles</strong>.</p></li>
				<li>Since we're not really interested in the first row, add a <strong class="source-inline">skip</strong> operation just before the <strong class="source-inline">count() </strong>method:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).skip(1).count();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Now you have every single line of the database file loaded as elements in the stream, except for the header. It's time to extract every piece of data from those lines; a suitable operation for this is <strong class="source-inline">map</strong>. Split every line into <strong class="source-inline">String</strong> arrays using the <strong class="source-inline">split()</strong> function:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).skip(1).map((line) -&gt; {</p><p class="source-code">            return line.split(",");</p><p class="source-code">        }).count();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Add another <strong class="source-inline">peek</strong> operation to find out how the <strong class="source-inline">map</strong> operation changed the stream; your stream type should now be <strong class="source-inline">Stream&lt;String[]&gt;</strong>:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).skip(1).map((line) -&gt; {</p><p class="source-code">            return line.split(",");</p><p class="source-code">        }).peek((arr) -&gt; {</p><p class="source-code">            System.out.println(Arrays.toString(arr));</p><p class="source-code">        }).count();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Add another <strong class="source-inline">map</strong> operation, but this time to turn the stream into <strong class="source-inline">Stream&lt;ShoppingArticle&gt;</strong>:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).skip(1).map((line) -&gt; {</p><p class="source-code">            return line.split(",");</p><p class="source-code">        }).peek((arr) -&gt; {</p><p class="source-code">            System.out.println(Arrays.toString(arr));</p><p class="source-code">        }).map((arr) -&gt; {</p><p class="source-code">            return new ShoppingArticle(arr[0], arr[1],               Double.valueOf(arr[2]), arr[3]);</p><p class="source-code">        }).count();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Now you can peek again to ensure the articles were created properly:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).skip(1).map((line) -&gt; {</p><p class="source-code">            return line.split(",");</p><p class="source-code">        }).peek((arr) -&gt; {</p><p class="source-code">            System.out.println(Arrays.toString(arr));</p><p class="source-code">        }).map((arr) -&gt; {</p><p class="source-code">            return new ShoppingArticle(arr[0], arr[1],               Double.valueOf(arr[2]), arr[3]);</p><p class="source-code">        }).peek((art) -&gt; {</p><p class="source-code">            System.out.println(art);</p><p class="source-code">        }).count();</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
				<li>Collect all the articles in a list. Use an unmodifiable list to protect the database from unwanted modifications:<p class="source-code">private static List&lt;ShoppingArticle&gt; loadDatabaseFile() throws IOException {</p><p class="source-code">    try (Stream&lt;String&gt; stream = Files.lines(Path.of("res/database.csv"))) {</p><p class="source-code">        return stream.peek((line) -&gt; {</p><p class="source-code">            System.out.println(line);</p><p class="source-code">        }).skip(1).map((line) -&gt; {</p><p class="source-code">            return line.split(",");</p><p class="source-code">        }).peek((arr) -&gt; {</p><p class="source-code">            System.out.println(Arrays.toString(arr));</p><p class="source-code">        }).map((arr) -&gt; {</p><p class="source-code">            return new ShoppingArticle(arr[0], arr[1],               Double.valueOf(arr[2]), arr[3]);</p><p class="source-code">        }).peek((art) -&gt; {</p><p class="source-code">            System.out.println(art);</p><p class="source-code">        }).collect(Collectors.toUnmodifiableList());</p><p class="source-code">    } catch (IOException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return null;</p><p class="source-code">}</p></li>
			</ol>
			<p>This may seem verbose, as some operations could have been applied together to make it shorter. However, there's a point to keeping every single operation small, and that's to make the whole logic very transparent. If you find a problem with the pipeline, you can simply move a single operation in the pipeline, and that should sort all problems.</p>
			<p>If you combine multiple steps in an operation, it's more difficult to move the operations around in the pipeline or to replace it fully.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor317"/>Activity 2: Searching for Specifics</h2>
			<p>With the database loaded, apply some searching logic:</p>
			<ol>
				<li value="1">Build a function that will find the cheapest fruit from a list of <strong class="source-inline">ShoppingArticles</strong>.</li>
				<li>Build a function that will find the most expensive vegetable from a list of <strong class="source-inline">ShoppingArticles</strong>.</li>
				<li>Build a function that will gather all fruits in a separate list.</li>
				<li>Build a function that will find the five least expensive articles in the database.</li>
				<li>Build a function that will find the five most expensive articles in the database.<p class="callout-heading">Note</p><p class="callout">The Solution for this Activity can be found on page 564.</p></li>
			</ol>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor318"/>Summary</h1>
			<p>Descriptive code is always an ideal to strive for when writing programs. The simpler the code is, the easier it will be to communicate your intentions to colleagues and other interested parties.</p>
			<p>The Java Streams API allows you to construct simple, and highly descriptive functions. Quite often they'll be pure functions since the Streams API makes it very easy to avoid manipulating state.</p>
			<p>In the next chapter, we'll delve further into functional programming topics, exploring the different functional interfaces available.</p>
		</div>
	</body></html>