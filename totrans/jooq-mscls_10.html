<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-129"><em class="italic"><a id="_idTextAnchor128"/>Chapter 8</em>: Fetching and Mapping</h1>
			<p>Fetching result sets and mapping them in the shape and format expected by the client is one of the most important tasks of querying a database. jOOQ excels in this area and provides a comprehensive API for fetching data and mapping it to scalars, arrays, lists, sets, maps, POJO, Java 16 records, JSON, XML, nested collections, and more. As usual, the jOOQ API hides the friction and challenges raised by different database dialects along with the boilerplate code necessary to map the result set to different data structures. In this context, our agenda covers the following topics:</p>
			<ul>
				<li>Simple fetching/mapping</li>
				<li>Fetching one record, a single record, or any record</li>
				<li>Fetching arrays, lists, sets, and maps</li>
				<li>Fetching groups</li>
				<li>Fetching via JDBC <strong class="source-inline">ResultSet</strong></li>
				<li>Fetching multiple result sets</li>
				<li>Fetching relationships</li>
				<li>Hooking POJOs</li>
				<li>jOOQ record mapper</li>
				<li>The mighty SQL/JSON and SQL/XML support</li>
				<li>Nested collections via the astonishing <strong class="source-inline">MULTISET</strong></li>
				<li>Lazy fetching</li>
				<li>Asynchronous fetching</li>
				<li>Reactive fetching</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08</a>.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Simple fetching/mapping</h1>
			<p>By <em class="italic">simple</em> fetching/mapping, we<a id="_idIndexMarker651"/> refer to the jOOQ fetching techniques that you learned earlier in this book (for instance, the ubiquitous <strong class="source-inline">into()</strong> methods) but also to the new jOOQ utility, <strong class="source-inline">org.jooq.Records</strong>. This utility is available from jOOQ 3.15 onward, and it contains two types of utility methods, as we will discuss next.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Collector methods</h2>
			<p>The collector methods are<a id="_idIndexMarker652"/> named <strong class="source-inline">intoFoo()</strong>, and their goal is<a id="_idIndexMarker653"/> to create a collector (<strong class="source-inline">java.util.stream.Collector</strong>) for collecting records (<strong class="source-inline">org.jooq.Record[N]</strong>) into arrays, lists, maps, groups, and more. These collectors can be used in <strong class="source-inline">ResultQuery.collect()</strong> as any other collector. <strong class="source-inline">ResultQuery&lt;R&gt;</strong> implements <strong class="source-inline">Iterable&lt;R&gt;</strong> and comes with convenience methods such as <strong class="source-inline">collect()</strong> on top of it. Besides the fact that <strong class="source-inline">collect()</strong> handles resources internally (there is no need to use try-with-resources), you can use it for any collectors such as standard JDK collectors, jOOλ collectors, <strong class="source-inline">Records</strong> collectors, or your own collectors. For instance, here is an example of collecting into <strong class="source-inline">List&lt;String&gt;</strong>:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(CUSTOMER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .collect(intoList()); // or, Java's Collectors.toList()</pre>
			<p>And, here is an example of collecting into <strong class="source-inline">Map&lt;Long, String&gt;</strong>:</p>
			<pre class="source-code">Map&lt;Long, String&gt; result = ctx.select(</pre>
			<pre class="source-code">           CUSTOMER.CUSTOMER_NUMBER, CUSTOMER.PHONE)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .collect(intoMap());</pre>
			<p>Note that, while the ubiquitous <strong class="source-inline">into()</strong> methods use reflection, these utilities are a pure declarative <a id="_idIndexMarker654"/>mapping of jOOQ results/records without<a id="_idIndexMarker655"/> using reflection.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Mapping methods</h2>
			<p>The mapping methods <a id="_idIndexMarker656"/>are actually multiple flavors of the mapping (<strong class="source-inline">Function[N]</strong>) method. A mapping method creates a <strong class="source-inline">RecordMapper</strong> parameter<a id="_idIndexMarker657"/> that can map from <strong class="source-inline">Record[N]</strong> to another type (for instance, POJO and Java 16 records) in a type-safe way. For instance, you can map to a Java record as follows:</p>
			<pre class="source-code">public record PhoneCreditLimit(</pre>
			<pre class="source-code">   String phone, BigDecimal creditLimit) {}</pre>
			<pre class="source-code">List&lt;PhoneCreditLimit&gt; result = ctx.select(</pre>
			<pre class="source-code">     CUSTOMER.PHONE, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetch(mapping(PhoneCreditLimit::new));</pre>
			<p>When mapping nested rows (for instance, <strong class="source-inline">LEFT JOIN</strong>) you can achieve <strong class="source-inline">null</strong> safety by combining <strong class="source-inline">mapping()</strong> with <strong class="source-inline">Functions.nullOnAllNull(Function1)</strong> or <strong class="source-inline">Functions.nullOnAnyNull(Function1)</strong>. Here is an example:</p>
			<pre class="source-code">List&lt;SalarySale&gt; result = ctx.select(</pre>
			<pre class="source-code">       EMPLOYEE.SALARY, SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .leftJoin(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .fetch(mapping(nullOnAnyNull(SalarySale::new)));</pre>
			<p>So, how does this work? For instance, when an employee has no sale (or you have an orphan sale), you'll obtain a <strong class="source-inline">null</strong> value instead of an instance of <strong class="source-inline">SalarySale</strong> having the sale as <strong class="source-inline">null</strong>, <strong class="source-inline">SalarySale[salary=120000, sale=null]</strong>. </p>
			<p>Many more examples are available for<a id="_idIndexMarker658"/> MySQL/PostgreSQL in<a id="_idIndexMarker659"/> the bundle code, <em class="italic">Records</em>.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Simple fetching/mapping continues</h2>
			<p>Next, let's see other<a id="_idIndexMarker660"/> techniques of fetching/mapping data that can be used quite intuitively and effortlessly. Since the jOOQ manual is filled to the brim with examples, let's try to niche several things in this section. For instance, a simple fetch can be done via <strong class="source-inline">DSLContext.resultQuery()</strong> and plain SQL, as follows:</p>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.resultQuery(</pre>
			<pre class="source-code">   "SELECT customer_name FROM customer").fetch();</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.resultQuery(</pre>
			<pre class="source-code">   "SELECT customer_name FROM customer")</pre>
			<pre class="source-code">      .fetchInto(String.class);</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.resultQuery(</pre>
			<pre class="source-code">   "SELECT customer_name FROM customer")</pre>
			<pre class="source-code">      .collect(intoList(r -&gt; r.get(0, String.class)));</pre>
			<p>Another approach might rely on <strong class="source-inline">DSLContext.fetch()</strong> and plain SQL, as follows:</p>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.fetch(</pre>
			<pre class="source-code">   "SELECT customer_name FROM customer");</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.fetch(</pre>
			<pre class="source-code">   "SELECT customer_name FROM customer").into(String.class);</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.fetch(</pre>
			<pre class="source-code">   "SELECT customer_name FROM customer")</pre>
			<pre class="source-code">      .collect(intoList(r -&gt; r.get(0, String.class)));</pre>
			<p>So, the idea is quite simple. Whenever you have to execute a plain SQL that you can't (or don't want to) express via a jOOQ-generated Java-based schema, then simply rely on <strong class="source-inline">ResultQuery.collect(collector)</strong> or the <strong class="source-inline">resultQuery() … fetch()</strong>/<strong class="source-inline">fetchInto()</strong> combination. Alternatively, simply pass it to the <strong class="source-inline">fetch()</strong> method and call the proper <strong class="source-inline">into()</strong> method or the <strong class="source-inline">intoFoo()</strong> method to map the result set to the <a id="_idIndexMarker661"/>necessary data structure. There are plenty of such methods that can map a result set to scalars, arrays, lists, sets, maps, POJO, XML, and more.</p>
			<p>On the other hand, using the Java-based schema (which is, of course, the recommended way to go) leads to the following less popular but handy query:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.fetchValues(CUSTOMER.CUSTOMER_NAME);</pre>
			<p>This is a shortcut for fetching a single field and obtaining the mapped result (values) without explicitly calling an <strong class="source-inline">into()</strong> method or an <strong class="source-inline">intoFoo()</strong> method. Essentially, jOOQ automatically maps the fetched field to the Java type associated with it when the Java-based schema was generated by the jOOQ generator.</p>
			<p>Whenever you need to fetch a single value, you can rely on <strong class="source-inline">fetchValue()</strong>:</p>
			<pre class="source-code">Timestamp ts = ctx.fetchValue(currentTimestamp());</pre>
			<p>The <strong class="source-inline">&lt;T&gt; T fetchValue(Field&lt;T&gt; field)</strong> and <strong class="source-inline">&lt;T&gt; List&lt;T&gt; fetchValues(TableField&lt;?,T&gt; tf)</strong> methods are just two of the many flavors of methods that are available. Check out the jOOQ documentation to see the rest of them. </p>
			<p>However, since you have made it this far in this book, I'm sure that you think of this query as a shortcut for the following four, more popular, approaches:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(CUSTOMER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .from(CUSTOMER).fetch(CUSTOMER.CUSTOMER_NAME);</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(CUSTOMER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(String.class)</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(CUSTOMER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .from(CUSTOMER).collect(intoList());</pre>
			<pre class="source-code">// or, mapping to Result&lt;Record1&lt;String&gt;&gt; </pre>
			<pre class="source-code">var result = ctx.select(CUSTOMER.CUSTOMER_NAME)          </pre>
			<pre class="source-code">   .from(CUSTOMER).fetch();</pre>
			<p>And you are right, as long <a id="_idIndexMarker662"/>as you don't also think of the following, too:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select().from(CUSTOMER)</pre>
			<pre class="source-code">   .fetch(CUSTOMER.CUSTOMER_NAME);</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">   .fetch(CUSTOMER.CUSTOMER_NAME);</pre>
			<p>All six of these queries project the same result, but they are not the same. As a jOOQ novice, it is understandable that you might a bad choice and go for the last two queries. Therefore, let's clarify this concern by looking at the generated SQLs. The first four queries produce the following SQL:</p>
			<pre class="source-code">SELECT `classicmodels`.`customer`.`customer_name`</pre>
			<pre class="source-code">FROM `classicmodels`.`customer`</pre>
			<p>In contrast, the last two queries produce the following SQL:</p>
			<pre class="source-code">SELECT `classicmodels`.`customer`.`customer_number`,</pre>
			<pre class="source-code">       `classicmodels`.`customer`.`customer_name`,</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">       `classicmodels`.`customer`.`first_buy_date`</pre>
			<pre class="source-code">FROM `classicmodels`.`customer`</pre>
			<p>Now, it is obvious that the last two queries perform unnecessary work. We only need the <strong class="source-inline">CUSTOMER_NAME</strong> field, but these queries will fetch all fields, and this is pointless work that negatively impacts <a id="_idIndexMarker663"/>performance. In such cases, don't blame jOOQ or the database because both of them did exactly what you asked! </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">As a rule of thumb, when you don't need to fetch all fields, rely on the first four approaches from earlier and enlist the necessary fields in the <strong class="source-inline">SELECT</strong> statement. In this context, allow me to reiterate the <em class="italic">SelectOnlyNeededData</em> application from <a href="B16833_05.xhtml#_idTextAnchor076"><em class="italic">Chapter 5</em></a>, <em class="italic">Tackling Different Kinds of SELECT, INSERT, UPDATE, DELETE, and MERGE Statements</em>.</p>
			<p>When you fetch more than one field, but not all fields, you should write something like this:</p>
			<pre class="source-code">// Result&lt;Record2&lt;String, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">var result = ctx.select(</pre>
			<pre class="source-code">       CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .from(CUSTOMER).fetch();</pre>
			<pre class="source-code">ExpectedType result = ctx.select(</pre>
			<pre class="source-code">       CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetchInto(…) // or, collect(), fetch(mapping(…)), ...</pre>
			<p>Now, let's consider another simple fetching method based on the following two POJOs:</p>
			<pre class="source-code">class NamePhone {String customerName; String phone;}</pre>
			<pre class="source-code">class PhoneCreditLimit {String phone; BigDecimal creditLimit;}</pre>
			<p>Populating these POJOs <a id="_idIndexMarker664"/>can be done via two <strong class="source-inline">SELECT</strong> statements, as follows:</p>
			<pre class="source-code">List&lt;NamePhone&gt; result1 = ctx.select(</pre>
			<pre class="source-code">      CUSTOMER.CUSTOMER_NAME, CUSTOMER.PHONE)</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(NamePhone.class);</pre>
			<pre class="source-code">List&lt;PhoneCreditLimit&gt; result2 = ctx.select(</pre>
			<pre class="source-code">      CUSTOMER.PHONE, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(PhoneCreditLimit.class);</pre>
			<p>However, here, jOOQ allows us to map <strong class="source-inline">Result&lt;Record&gt;</strong> into multiple results. In other words, we can obtain the same result and trigger a single <strong class="source-inline">SELECT</strong> statement, as follows:</p>
			<pre class="source-code">// Result&lt;Record3&lt;String, String, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">var result = ctx.select(CUSTOMER.CUSTOMER_NAME,    </pre>
			<pre class="source-code">                        CUSTOMER.PHONE, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .from(CUSTOMER).fetch();</pre>
			<pre class="source-code">List&lt;NamePhone&gt; r1=result.into(NamePhone.class);</pre>
			<pre class="source-code">List&lt;PhoneCreditLimit&gt; r2=result.into(PhoneCreditLimit.class);</pre>
			<p>Nice! Of course, this<a id="_idIndexMarker665"/> doesn't only apply when mapping result sets to POJOs. In the code bundle of this book, <em class="italic">SimpleFetch</em> (which is available for MySQL), you can see a result set produced by a single <strong class="source-inline">SELECT</strong> statement formatted entirely as JSON, while a part of it is mapped to a Java <strong class="source-inline">Set</strong>. Next, let's dive into the <strong class="source-inline">fetchOne()</strong>, <strong class="source-inline">fetchSingle()</strong>, and <strong class="source-inline">fetchAny()</strong> methods.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Fetching one record, a single record, or any record</h1>
			<p>jOOQ has come with three handy methods named <strong class="source-inline">fetchOne()</strong>, <strong class="source-inline">fetchSingle()</strong>, and <strong class="source-inline">fetchAny()</strong>. All three are capable of returning a resulting record, but each of them will do this under certain coordinates. So, let's go through each method in detail.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Using fetchOne()</h2>
			<p>For instance, the <strong class="source-inline">fetchOne()</strong> method returns, at <a id="_idIndexMarker666"/>most, one resulting record. In other words, if the fetched result set has more than one record, then <strong class="source-inline">fetchOne()</strong> throws a jOOQ-specific <strong class="source-inline">TooManyRowsException</strong> exception. But if the result set has no records, then <strong class="source-inline">fetchOne()</strong> returns <strong class="source-inline">null</strong>. In this context, <strong class="source-inline">fetchOne()</strong> can be useful for fetching a record by a primary key, other unique keys, or a predicate that guarantees uniqueness, while you prepare to handle potentially <strong class="source-inline">null</strong> results. Here is an example of using <strong class="source-inline">fetchOne()</strong>: </p>
			<pre class="source-code">EmployeeRecord result = ctx.selectFrom(EMPLOYEE) </pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L))</pre>
			<pre class="source-code">   .fetchOne();</pre>
			<p>Alternatively, you can fetch directly into the <strong class="source-inline">Employee</strong> POJO via <strong class="source-inline">fetchOneInto()</strong>:</p>
			<pre class="source-code">Employee result = ctx.selectFrom(EMPLOYEE) </pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L))                    </pre>
			<pre class="source-code">   .fetchOneInto(Employee.class);</pre>
			<p>However, pay attention. Remember that <strong class="source-inline">fetchOneInto(Employee.class)</strong> is not the same thing as <strong class="source-inline">fetchOne().into(Employee.class)</strong> since the latter is prone to throw <strong class="source-inline">NullPointerException</strong> exceptions. So, it is better to avoid writing something like this:</p>
			<pre class="source-code">Employee result = ctx.selectFrom(EMPLOYEE) </pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L))                    </pre>
			<pre class="source-code">   .fetchOne().into(Employee.class);</pre>
			<p>If there is no <strong class="source-inline">EMPLOYEE</strong> POJO with a primary key of <em class="italic">1370</em>, then this code throws an NPE exception.</p>
			<p>Also, avoid chaining the <strong class="source-inline">component</strong>[<strong class="source-inline">N</strong>]<strong class="source-inline">()</strong> and <strong class="source-inline">value</strong>[<strong class="source-inline">N</strong>]<strong class="source-inline">()</strong> methods, as follows (this code is also prone to throw <strong class="source-inline">NullPointerException</strong>):</p>
			<pre class="source-code">String result = ctx.select(EMPLOYEE.EMAIL).from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L))</pre>
			<pre class="source-code">   .fetchOne().value1();</pre>
			<p>Also, prefer fetching into a <a id="_idIndexMarker667"/>proper type (here, it is <strong class="source-inline">String</strong>):</p>
			<pre class="source-code">String result = ctx.select(EMPLOYEE.EMAIL).from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">   .fetchOneInto(String.class);</pre>
			<p>Of course, an NPE check is still needed before using <strong class="source-inline">result</strong>, but you can wrap this check via <strong class="source-inline">Objects.requireNonNullElseGet()</strong>, as follows:</p>
			<pre class="source-code">String result = Objects.requireNonNullElseGet(</pre>
			<pre class="source-code">   ctx.select(EMPLOYEE.EMAIL).from(EMPLOYEE)</pre>
			<pre class="source-code">      .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">      .fetchOneInto(String.class), () -&gt; "");</pre>
			<p>Alternatively, simply wrap it into an <strong class="source-inline">Optional</strong> type via the jOOQ's <strong class="source-inline">fetchOptional()</strong> method:</p>
			<pre class="source-code">Optional&lt;EmployeeRecord&gt; result = ctx.selectFrom(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">   .fetchOptional();</pre>
			<p>Alternatively, you may prefer <strong class="source-inline">fetchOptionalInto()</strong>:</p>
			<pre class="source-code">Optional&lt;Employee&gt; result = ctx.selectFrom(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L))</pre>
			<pre class="source-code">   .fetchOptionalInto(Employee.class);</pre>
			<p>As usual, <strong class="source-inline">fetchOne()</strong> comes in many flavors, all of which are available in the documentation. For instance, you can use <strong class="source-inline">DSLContext.fetchOne()</strong>as follows:</p>
			<pre class="source-code">EmployeeRecord result = ctx.fetchOne(EMPLOYEE,  </pre>
			<pre class="source-code">   EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L));</pre>
			<p>Or you can fetch a <a id="_idIndexMarker668"/>record and convert it based on a user-defined converter (this converter was introduced in <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings</em>):</p>
			<pre class="source-code">YearMonth result = ctx.select(CUSTOMER.FIRST_BUY_DATE)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .where(CUSTOMER.CUSTOMER_NUMBER.eq(112L))</pre>
			<pre class="source-code">   .fetchOne(CUSTOMER.FIRST_BUY_DATE, </pre>
			<pre class="source-code">             INTEGER_YEARMONTH_CONVERTER);</pre>
			<p>Many other examples are available in the bundled code for MySQL, <em class="italic">FetchOneAnySingle</em>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Using fetchSingle()</h2>
			<p>The <strong class="source-inline">fetchSingle()</strong> method <a id="_idIndexMarker669"/>returns exactly one resulting record. In other words, if the fetched result set contains more than one record, then <strong class="source-inline">fetchSingle()</strong> throws the jOOQ-specific <strong class="source-inline">TooManyRowsException</strong> error. And if it doesn't contain any records, then it throws the jOOQ-specific <strong class="source-inline">NoDataFoundException</strong> error. </p>
			<p>Essentially, <strong class="source-inline">fetchSingle()</strong> is similar to <strong class="source-inline">fetchOne()</strong>, except that it throws an exception instead of returning <strong class="source-inline">null</strong> when the fetched result set doesn't contain any records. This means that <strong class="source-inline">fetchSingle()</strong> is useful for fetching a record by a primary key, other unique keys, or a predicate that guarantees uniqueness when you are not expecting <strong class="source-inline">null</strong> results. For example, see the following code block:</p>
			<pre class="source-code">Employee result = ctx.selectFrom(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">   .fetchSingleInto(Employee.class);</pre>
			<p>Or you might only fetch the email of this employee, as follows:</p>
			<pre class="source-code">String result = ctx.select(EMPLOYEE.EMAIL).from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">   .fetchSingle().value1(); // fetchSingleInto(String.class)</pre>
			<p>Many other examples are <a id="_idIndexMarker670"/>available in the bundled code.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Using fetchAny()</h2>
			<p>The <strong class="source-inline">fetchAny()</strong> method returns the<a id="_idIndexMarker671"/> first resulting record. In other words, if the fetched result set contains more than one record, then <strong class="source-inline">fetchAny()</strong> returns the first one. And, if it doesn't contain any records, then it returns <strong class="source-inline">null</strong>. This is similar to <strong class="source-inline">…limit(1).fetchOne();</strong>. So, pay attention to avoid any usages that are prone to throw a <strong class="source-inline">NullPointerException</strong> exception. Here's an example:</p>
			<pre class="source-code">SaleRecord result = ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">   .fetchAny();</pre>
			<p>Let's see another example:</p>
			<pre class="source-code">String result = ctx.select(SALE.TREND).from(SALE)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.eq(1370L)) </pre>
			<pre class="source-code">   .fetchAnyInto(String.class);</pre>
			<p>Many other examples are available for MySQL in <em class="italic">FetchOneAnySingle</em>.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Fetching arrays, lists, sets, and maps</h1>
			<p>jOOQ reduces the code that is needed for fetching <strong class="source-inline">Result&lt;Record&gt;</strong> as an array, list, set, or map down to a simple call of its amazing API. </p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Fetching arrays</h2>
			<p>Fetching arrays can be done via<a id="_idIndexMarker672"/> a comprehensive set of jOOQ methods, including <strong class="source-inline">fetchArray()</strong> (along with its flavors), <strong class="source-inline">fetchOneArray()</strong>, <strong class="source-inline">fetchSingleArray()</strong>, <strong class="source-inline">fetchAnyArray()</strong>, <strong class="source-inline">fetchArrays()</strong>, and <strong class="source-inline">intoArray()</strong>. For instance, fetching all the <strong class="source-inline">DEPARTMENT</strong>  fields as an array of <strong class="source-inline">Record</strong> can be done as follows:</p>
			<pre class="source-code">Record[] result = ctx.select().from(DEPARTMENT).fetchArray();</pre>
			<p>In comparison, you can just fetch <strong class="source-inline">DEPARTMENT.NAME</strong> as a <strong class="source-inline">String[]</strong> as follows:</p>
			<pre class="source-code">String[] result = ctx.select(DEPARTMENT.NAME).from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetchArray(DEPARTMENT.NAME);</pre>
			<pre class="source-code">String[] result = ctx.select(DEPARTMENT.NAME).from(DEPARTMENT)</pre>
			<pre class="source-code">   .collect(intoArray(new String[0]));</pre>
			<p>Alternatively, fetching all <strong class="source-inline">CUSTOMER.FIRST_BUY_DATE</strong> fields as an array of the <strong class="source-inline">YearMonth</strong> type can be done via <strong class="source-inline">fetchArray(Field&lt;T&gt; field, Converter&lt;? super T,? extends U&gt; cnvrtr)</strong>, as follows (note that the <strong class="source-inline">INTEGER_YEARMONTH_CONVERTER</strong> converter was introduced in <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings</em>):</p>
			<pre class="source-code">YearMonth[] result = ctx.select(CUSTOMER.FIRST_BUY_DATE)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetchArray(CUSTOMER.FIRST_BUY_DATE, </pre>
			<pre class="source-code">               INTEGER_YEARMONTH_CONVERTER);</pre>
			<p>What do you think about fetching a database array into a Java array, such as the <strong class="source-inline">DEPARTMENT.TOPIC</strong> field that was defined in our PostgreSQL schema? Well, the result, in this case, is <strong class="source-inline">String[][]</strong>:</p>
			<pre class="source-code">String[][] result = ctx.select(DEPARTMENT.TOPIC)</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetchArray(DEPARTMENT.TOPIC);</pre>
			<p>If we return this <strong class="source-inline">String[][]</strong> from <a id="_idIndexMarker673"/>a Spring Boot REST controller, the result will be a JSON array:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  ["publicity", "promotion"],</pre>
			<pre class="source-code">  ["commerce","trade","sellout","transaction"],</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">]</pre>
			<p>What about fetching a UDT type into a Java array? In our PostgreSQL schema, we have the <strong class="source-inline">MANAGER.MANAGER_EVALUATION</strong> UDT type, so let's give it a try and fetch it as an array next to the <strong class="source-inline">MANAGER_NAME</strong> type:</p>
			<pre class="source-code">// Record2&lt;String, EvaluationCriteriaRecord&gt;[]</pre>
			<pre class="source-code">var result = ctx.select(MANAGER.MANAGER_NAME, </pre>
			<pre class="source-code">                        MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .from(MANAGER).fetchArray();</pre>
			<p>Let's print out the first manager name and their evaluation:</p>
			<pre class="source-code">System.out.println(result[0].value1()+"\n"</pre>
			<pre class="source-code">        + result[0].value2().format());</pre>
			<p>Here is the output (the <strong class="source-inline">format()</strong> method formats <strong class="source-inline">EvaluationCriteriaRecord</strong> as a tabular text):</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B16833_Figure_8.1.jpg" alt="Figure 8.1– Printing the first manager and their evaluation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1– Printing the first manager and their evaluation</p>
			<p>Finally, let's try fetching an embeddable type as an array, too:</p>
			<pre class="source-code">OfficeFullAddressRecord[] result = ctx.select(</pre>
			<pre class="source-code">      OFFICE.OFFICE_FULL_ADDRESS).from(OFFICE)</pre>
			<pre class="source-code">   .fetchArray(OFFICE.OFFICE_FULL_ADDRESS);</pre>
			<pre class="source-code">OfficeFullAddressRecord[] result = ctx.select(</pre>
			<pre class="source-code">      OFFICE.OFFICE_FULL_ADDRESS).from(OFFICE)</pre>
			<pre class="source-code">   .collect(intoArray(new OfficeFullAddressRecord[0]));</pre>
			<p>The last example from this section relies on <strong class="source-inline">fetchArrays()</strong>:</p>
			<pre class="source-code">Object[][] result = ctx.select(DEPARTMENT.DEPARTMENT_ID, </pre>
			<pre class="source-code">         DEPARTMENT.OFFICE_CODE, DEPARTMENT.NAME)</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetchArrays();</pre>
			<p>If we return this <strong class="source-inline">Object[][]</strong> from a <a id="_idIndexMarker674"/>Spring Boot REST controller, then the result will be a JSON array of arrays:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  [1, "1", "Advertising"],</pre>
			<pre class="source-code">  [2, "1", "Sales"],</pre>
			<pre class="source-code">  [3, "2", "Accounting"],</pre>
			<pre class="source-code">  [4, "3", "Finance"]</pre>
			<pre class="source-code">]</pre>
			<p>In the bundled code, you can find over 15 examples of fetching jOOQ results as arrays. </p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Fetching lists and sets</h2>
			<p>So far, most examples fetch the result set in <strong class="source-inline">java.util.List</strong> or <strong class="source-inline">org.jooq.Result</strong> (that is, the<a id="_idIndexMarker675"/> jOOQ wrappers of <strong class="source-inline">List</strong>), so there is no mystery regarding how the following examples work:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(DEPARTMENT.NAME)</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetch(DEPARTMENT.NAME);</pre>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(DEPARTMENT.NAME)</pre>
			<pre class="source-code">   .from(DEPARTMENT).collect(intoList());</pre>
			<pre class="source-code">List&lt;Department&gt; result = ctx.select(DEPARTMENT.DEPARTMENT_ID,    </pre>
			<pre class="source-code">       DEPARTMENT.OFFICE_CODE, DEPARTMENT.NAME)</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetchInto(Department.class);</pre>
			<p>So, let's focus on more interesting cases, such as how to fetch the <strong class="source-inline">DEPARTMENT.TOPIC</strong> array field defined in our PostgreSQL schema:</p>
			<pre class="source-code">List&lt;String[]&gt; result = ctx.select(DEPARTMENT.TOPIC)</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetch(DEPARTMENT.TOPIC, String[].class);</pre>
			<p>Instead of calling <strong class="source-inline">fetch()</strong>, which <a id="_idIndexMarker676"/>will return <strong class="source-inline">Result&lt;Record1&lt;String[]&gt;&gt;</strong>, we prefer to call <strong class="source-inline">fetch(Field&lt;?&gt; field, Class&lt;? extends U&gt; type)</strong>. This allow us to return a <strong class="source-inline">List&lt;String[]&gt;</strong>. </p>
			<p>Trying to fetch <strong class="source-inline">DEPARTMENT.TOPIC</strong> as a <strong class="source-inline">Set&lt;String[]&gt;</strong> can be done via the jOOQ <strong class="source-inline">fetchSet()</strong> method (check out the documentation to see all the flavors of this method):</p>
			<pre class="source-code">Set&lt;String[]&gt; result = ctx.select(DEPARTMENT.TOPIC)</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetchSet(DEPARTMENT.TOPIC);</pre>
			<p>Consider the bundled code, which contains more examples of fetching lists and sets, including fetching UDT and embeddable types. </p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Fetching maps</h2>
			<p>jOOQ comes <a id="_idIndexMarker677"/>with a set of <strong class="source-inline">fetchMap()</strong>/<strong class="source-inline">intoMap()</strong> methods that allow us to split a result set into key-value pairs of a <strong class="source-inline">java.util.Map</strong> wrapper. There are more than 20 such methods, but we can primarily distinguish between the <strong class="source-inline">fetchMap(key)</strong>/<strong class="source-inline">intoMap(Function keyMapper)</strong> methods. These methods allow us to specify the field(s) representing the key, while the value is inferred from the <strong class="source-inline">SELECT</strong> result, and the <strong class="source-inline">fetchMap(key, value)</strong>/<strong class="source-inline">intoMap(Function keyMapper, Function valueMapper)</strong> methods in which we specify the field(s) that represents the key and the value, respectively. The <strong class="source-inline">Records.intoMap()</strong> method without any arguments is only useful if you have a two-column <strong class="source-inline">ResultQuery</strong> and you want to map the first column as a key and the second column as a value.</p>
			<p>For instance, let's fetch a <strong class="source-inline">Map</strong> that has <strong class="source-inline">DEPARTMENT_ID</strong> as the key (so, the <strong class="source-inline">DEPARTMENT</strong> primary key) and <strong class="source-inline">DepartmentRecord</strong> as the value: </p>
			<pre class="source-code">Map&lt;Integer, DepartmentRecord&gt; </pre>
			<pre class="source-code">       result = ctx.selectFrom(DEPARTMENT)</pre>
			<pre class="source-code">   .fetchMap(DEPARTMENT.DEPARTMENT_ID);</pre>
			<pre class="source-code">Map&lt;Integer, DepartmentRecord&gt; </pre>
			<pre class="source-code">       result = ctx.selectFrom(DEPARTMENT)</pre>
			<pre class="source-code">   .collect(intoMap(r -&gt; r.get(DEPARTMENT.DEPARTMENT_ID)));</pre>
			<p>Alternatively, let's instruct jOOQ that the map value should be a <strong class="source-inline">Department</strong> POJO (generated by jOOQ) instead of <strong class="source-inline">DepartmentRecord</strong>:</p>
			<pre class="source-code">Map&lt;Integer, Department&gt; result = ctx.selectFrom(DEPARTMENT)</pre>
			<pre class="source-code">   .fetchMap(DEPARTMENT.DEPARTMENT_ID, Department.class);</pre>
			<p>Do you think this is impressive? How about mapping a one-to-one relationship between the <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">CUSTOMERDETAIL</strong> tables? Here is the magical code:</p>
			<pre class="source-code">Map&lt;Customer, Customerdetail&gt; result = ctx.select()</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .on(CUSTOMER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">       .eq(CUSTOMERDETAIL.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .fetchMap(Customer.class, Customerdetail.class);</pre>
			<p>In order to obtain a correct mapping, you have to provide explicit <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods for the<a id="_idIndexMarker678"/> involved POJOs.</p>
			<p>Simply returning this <strong class="source-inline">Map</strong> from a REST controller will result in the following JSON code:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">   "Customer (99, Australian Home, Paoule, Sart, </pre>
			<pre class="source-code">    40.11.2555, 1370, 21000.00, 20210)":</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">      "customerNumber": 99, "addressLineFirst": "43 Rue 2",</pre>
			<pre class="source-code">      "addressLineSecond": null, "city": "Paris", "state":    </pre>
			<pre class="source-code">       null, "postalCode": "25017", "country": "France"</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">   ...</pre>
			<p>Alterantively, you might want to fetch this one-to-one relationship by only using a subset of fields:</p>
			<pre class="source-code">Map&lt;Record, Record&gt; result = ctx.select(</pre>
			<pre class="source-code">      CUSTOMER.CONTACT_FIRST_NAME, CUSTOMER.CONTACT_LAST_NAME,   </pre>
			<pre class="source-code">      CUSTOMERDETAIL.CITY, CUSTOMERDETAIL.COUNTRY)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .on(CUSTOMER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">      .eq(CUSTOMERDETAIL.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .fetchMap(new Field[]{CUSTOMER.CONTACT_FIRST_NAME,  </pre>
			<pre class="source-code">                         CUSTOMER.CONTACT_LAST_NAME},</pre>
			<pre class="source-code">             new Field[]{CUSTOMERDETAIL.CITY, </pre>
			<pre class="source-code">                         CUSTOMERDETAIL.COUNTRY});</pre>
			<p>In the bundled code,<em class="italic"> ArrListMap</em> (which is available for PostgreSQL), you can see more examples, including mapping a<a id="_idIndexMarker679"/> flattened one-to-many relationship, mapping arrays, UDTs and embeddable types, and using <strong class="source-inline">fetchMaps()</strong>, <strong class="source-inline">fetchSingleMap()</strong>, <strong class="source-inline">fetchOneMap()</strong>, and <strong class="source-inline">fetchAnyMap()</strong>. Next, let's talk about fetching groups.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Fetching groups</h1>
			<p>The jOOQ fetching groups<a id="_idIndexMarker680"/> feature is similar to fetching maps, except that it allows us to fetch a list of records as the value of each key-value pair. There are over 40 flavors of the <strong class="source-inline">fetchGroups()</strong>, <strong class="source-inline">intoGroups()</strong>, and <strong class="source-inline">intoResultGroup()</strong> methods; therefore, take your time to practice (or, at the very least, read about) each of them.</p>
			<p>We can distinguish between the <strong class="source-inline">fetchGroups(key)</strong> and <strong class="source-inline">intoGroups(Function keyMapper)</strong> methods that allow us to specify the field(s) representing the key, while the value is inferred from the <strong class="source-inline">SELECT</strong> result as the <strong class="source-inline">Result&lt;Record&gt;</strong>/<strong class="source-inline">List&lt;Record&gt;</strong> and <strong class="source-inline">fetchGroups(key, value)</strong>/<strong class="source-inline">intoGroups(Function keyMapper, Function valueMapper)</strong> methods in which we specify the field(s) that represents the key and the value, respectively, which could be <strong class="source-inline">Result&lt;Record&gt;</strong>, <strong class="source-inline">List&lt;POJO&gt;</strong>, <strong class="source-inline">List&lt;scalar&gt;</strong>, and more. The <strong class="source-inline">Records.intoGroups()</strong> method without any arguments is only useful if you have a two-column <strong class="source-inline">ResultQuery</strong>, and you want to map the first column as a key and the second column as a value. Additionally, the <strong class="source-inline">intoResultGroup()</strong> method returns a collector that collects a jOOQ <strong class="source-inline">Record</strong>, which results from a <strong class="source-inline">ResultQuery</strong> in a <strong class="source-inline">Map</strong> using the result of the <strong class="source-inline">RecordMapper</strong> parameter as a key to collect the records themselves into a jOOQ <strong class="source-inline">Result</strong>.</p>
			<p>For instance, you can fetch all the <strong class="source-inline">OrderRecord</strong> values and group them by customer (<strong class="source-inline">CUSTOMER_NUMBER</strong>) as follows:</p>
			<pre class="source-code">Map&lt;Long, Result&lt;OrderRecord&gt;&gt; result = ctx.selectFrom(ORDER)</pre>
			<pre class="source-code">   .fetchGroups(ORDER.CUSTOMER_NUMBER);</pre>
			<pre class="source-code">Map&lt;Long, List&lt;OrderRecord&gt;&gt; result = ctx.selectFrom(ORDER)</pre>
			<pre class="source-code">   .collect(intoGroups(r -&gt; r.get(ORDER.CUSTOMER_NUMBER)));</pre>
			<p>Or you can group all bank<a id="_idIndexMarker681"/> transfers (<strong class="source-inline">BANK_TRANSACTION.TRANSFER_AMOUNT</strong>) by customer (<strong class="source-inline">BANK_TRANSACTION.CUSTOMER_NUMBER</strong>) into <strong class="source-inline">Map&lt;Long, List&lt;BigDecimal&gt;&gt;</strong>:</p>
			<pre class="source-code">Map&lt;Long, List&lt;BigDecimal&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">      BANK_TRANSACTION.CUSTOMER_NUMBER,    </pre>
			<pre class="source-code">      BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">   .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .fetchGroups(BANK_TRANSACTION.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">                BANK_TRANSACTION.TRANSFER_AMOUNT);</pre>
			<pre class="source-code">Map&lt;Long, List&lt;BigDecimal&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">      BANK_TRANSACTION.CUSTOMER_NUMBER,   </pre>
			<pre class="source-code">      BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">    .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">    .collect(intoGroups());</pre>
			<pre class="source-code">    // or, …</pre>
			<pre class="source-code">    .collect(intoGroups(</pre>
			<pre class="source-code">        r -&gt; r.get(BANK_TRANSACTION.CUSTOMER_NUMBER),</pre>
			<pre class="source-code">        r -&gt; r.get(BANK_TRANSACTION.TRANSFER_AMOUNT)));</pre>
			<p>You can group them into <strong class="source-inline">Map&lt;Long, List&lt;Record2&lt;Long, BigDecimal&gt;&gt;&gt;</strong> or <strong class="source-inline">Map&lt;Long, Result&lt;Record2&lt;Long, BigDecimal&gt;&gt;&gt;</strong>, respectively:</p>
			<pre class="source-code">Map&lt;Long, List&lt;Record2&lt;Long, BigDecimal&gt;&gt;&gt; result </pre>
			<pre class="source-code">   = ctx.select(BANK_TRANSACTION.CUSTOMER_NUMBER,    </pre>
			<pre class="source-code">                BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">        .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">        .collect(intoGroups(r -&gt; </pre>
			<pre class="source-code">            r.get(BANK_TRANSACTION.CUSTOMER_NUMBER)));</pre>
			<pre class="source-code">Map&lt;Long, Result&lt;Record2&lt;Long, BigDecimal&gt;&gt;&gt; result </pre>
			<pre class="source-code">   = ctx.select(BANK_TRANSACTION.CUSTOMER_NUMBER,    </pre>
			<pre class="source-code">                BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">        .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">        .collect(intoResultGroups(r -&gt; </pre>
			<pre class="source-code">            r.get(BANK_TRANSACTION.CUSTOMER_NUMBER)));</pre>
			<p>As you've probably<a id="_idIndexMarker682"/> intuited already, <strong class="source-inline">fetchGroups()</strong> is very handy for fetching and mapping one-to-many relationships. For instance, each product line (<strong class="source-inline">PRODUCTLINE</strong>) has multiple products (<strong class="source-inline">PRODUCT</strong>), and we can fetch this data as follows:</p>
			<pre class="source-code">Map&lt;Productline, List&lt;Product&gt;&gt; result = ctx.select()</pre>
			<pre class="source-code">    .from(PRODUCTLINE)</pre>
			<pre class="source-code">    .innerJoin(PRODUCT)</pre>
			<pre class="source-code">    .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">    .fetchGroups(Productline.class, Product.class);</pre>
			<p>Returning this map from a REST controller results in the following JSON:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "Productline (Motorcycles, 599302, Our motorcycles ...)": [</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">      "productId": 1,</pre>
			<pre class="source-code">      "productName": "1969 Harley Davidson Ultimate Chopper",</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">      "productId": 3,</pre>
			<pre class="source-code">      "productName": "1996 Moto Guzzi 1100i",</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">  ],</pre>
			<pre class="source-code">  "Productline (Classic Cars, 599302 ... )": [</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  ]</pre>
			<pre class="source-code">}</pre>
			<p>Of course, relying on<a id="_idIndexMarker683"/> user-defined POJOs/Java records is also possible. For instance, let's say you just need the code and name of each product line, along with the product ID and buy price of each product. Having the proper POJOs named <strong class="source-inline">SimpleProductline</strong> and <strong class="source-inline">SimpleProduct</strong>, we can map the following one-to-many relationship:</p>
			<pre class="source-code">Map&lt;SimpleProductline, List&lt;SimpleProduct&gt;&gt; result = </pre>
			<pre class="source-code">  ctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE,</pre>
			<pre class="source-code">             PRODUCT.PRODUCT_ID, PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">  .from(PRODUCTLINE)</pre>
			<pre class="source-code">  .innerJoin(PRODUCT)</pre>
			<pre class="source-code">  .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">  .fetchGroups(SimpleProductline.class, SimpleProduct.class);</pre>
			<p>In order to obtain a <a id="_idIndexMarker684"/>correct mapping, you have to provide explicit <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods for the involved POJOs. For the jOOQ-generated POJO, this is a configuration step that can be accomplished via <strong class="source-inline">&lt;pojosEqualsAndHashCode/&gt;</strong>, as follows:</p>
			<pre class="source-code">&lt;generate&gt;   </pre>
			<pre class="source-code">   &lt;pojosEqualsAndHashCode&gt;true&lt;/pojosEqualsAndHashCode&gt;     </pre>
			<pre class="source-code">&lt;/generate&gt;                                                   </pre>
			<p>Notice that using <strong class="source-inline">fetchGroups()</strong> works as expected for <strong class="source-inline">INNER JOIN</strong>, but not for <strong class="source-inline">LEFT JOIN</strong>. If the fetched parent doesn't have children, then instead of an empty list, you'll get a list containing a single <strong class="source-inline">NULL</strong> item. So, if you want to use <strong class="source-inline">LEFT JOIN</strong> (at least until <a href="https://github.com/jOOQ/jOOQ/issues/11888">https://github.com/jOOQ/jOOQ/issues/11888</a> is resolved), you can rely on the mighty <strong class="source-inline">ResultQuery.collect()</strong>collector, as follows:</p>
			<pre class="source-code">Map&lt;Productline, List&lt;Product&gt;&gt; result = ctx.select()</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .leftOuterJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">   .collect(groupingBy(</pre>
			<pre class="source-code">       r -&gt; r.into(Productline.class),</pre>
			<pre class="source-code">          filtering(</pre>
			<pre class="source-code">             r -&gt; r.get(PRODUCT.PRODUCT_ID) != null,</pre>
			<pre class="source-code">             mapping(</pre>
			<pre class="source-code">                 r -&gt; r.into(Product.class),</pre>
			<pre class="source-code">                 toList()</pre>
			<pre class="source-code">             )</pre>
			<pre class="source-code">          )</pre>
			<pre class="source-code">   ));</pre>
			<p>This time, a parent with no children produces an empty list.</p>
			<p>Fetching and mapping a many-to-many relationship is also possible. We can do it elegantly via <strong class="source-inline">CROSS APPLY</strong> (for additional details, check out <a href="B16833_06.xhtml#_idTextAnchor093"><em class="italic">Chapter 6</em></a>, <em class="italic">Tackling Different Kinds of JOIN Statements</em>). For instance, we have a many-to-many relationship between <strong class="source-inline">OFFICE</strong> and <strong class="source-inline">MANAGER</strong> via the <strong class="source-inline">OFFICE_HAS_MANAGER</strong> junction table, and <a id="_idIndexMarker685"/>we can map it via <strong class="source-inline">fetchGroups()</strong>, as follows:</p>
			<pre class="source-code">Map&lt;Manager, List&lt;Office&gt;&gt; result = ctx.select().from(MANAGER)</pre>
			<pre class="source-code">    .crossApply(select().from(OFFICE).join(OFFICE_HAS_MANAGER)</pre>
			<pre class="source-code">      .on(OFFICE.OFFICE_CODE</pre>
			<pre class="source-code">         .eq(OFFICE_HAS_MANAGER.OFFICES_OFFICE_CODE))</pre>
			<pre class="source-code">   .where(MANAGER.MANAGER_ID</pre>
			<pre class="source-code">      .eq(OFFICE_HAS_MANAGER.MANAGERS_MANAGER_ID)))</pre>
			<pre class="source-code">   .fetchGroups(Manager.class, Office.class);</pre>
			<p>Passing this map through a REST controller produces the necessary JSON. Of course, mapping a one-to-many relationship with a junction table is quite obvious based on the previous examples.</p>
			<p>However, please consider Lukas Eder's note: </p>
			<p><em class="italic">"When talking about </em><em class="italic">fetchGroups(), I think it's always worth pointing out that RDBMS can often do this natively as well, using ARRAY_AGG(), JSON_ARRAYAGG(), or XMLAGG(). Chances are (to be verified), that this may be faster, as less data has to be transferred over the wire."</em></p>
			<p>In the bundled code, you can<a id="_idIndexMarker686"/> practice many more examples of how to use <strong class="source-inline">fetchGroups()</strong>. The application is named <em class="italic">FetchGroups</em> (and is available for PostgreSQL).</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Fetching via JDBC ResultSet</h1>
			<p>jOOQ is an extremely versatile<a id="_idIndexMarker687"/> and transparent tool. For instance, jOOQ acts as a wrapper for JDBC <strong class="source-inline">ResultSet</strong> but also allows us to access it directly and even provide support to do this smoothly and <em class="italic">painlessly</em>. Practically, we can do the following:</p>
			<ul>
				<li>Execute a <strong class="source-inline">ResultQuery</strong> with jOOQ, but return a JDBC <strong class="source-inline">ResultSet</strong> (this relies on the <strong class="source-inline">fetchResultSet()</strong> method).</li>
				<li>Transform the jOOQ <strong class="source-inline">Result</strong> object into a JDBC <strong class="source-inline">ResultSet</strong> (this relies on the <strong class="source-inline">intoResultSet()</strong> method).</li>
				<li>Fetch data from a legacy <strong class="source-inline">ResultSet</strong> using jOOQ.</li>
			</ul>
			<p>All three of these bullets are exemplified in the bundled code. However, here, let's consider the second bullet that starts with the following jOOQ query:</p>
			<pre class="source-code">// Result&lt;Record2&lt;String, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">var result = ctx.select(CUSTOMER.CUSTOMER_NAME,  </pre>
			<pre class="source-code">   CUSTOMER.CREDIT_LIMIT).from(CUSTOMER).fetch();</pre>
			<p>We understand that the returned result is a jOOQ-specific <strong class="source-inline">Result</strong> that was built automatically from the underlying <strong class="source-inline">ResultSet</strong>. So, can we reverse this operation and obtain the <strong class="source-inline">ResultSet</strong> from the jOOQ <strong class="source-inline">Result</strong>? Yes, we can! We can do this via <strong class="source-inline">intoResultSet()</strong>, as follows:</p>
			<pre class="source-code">ResultSet rsInMem = result.intoResultSet();</pre>
			<p>The important thing to note is that this magic happens without an active connection to the database. By default, jOOQ closes the database connection after the jOOQ <strong class="source-inline">Result</strong> is fetched. This means that, when we call <strong class="source-inline">intoResultSet()</strong> to obtain this in-memory <strong class="source-inline">ResultSet</strong>, there is no active connection to the database. jOOQ mirrors the <strong class="source-inline">Result</strong> object back into a <strong class="source-inline">ResultSet</strong> without interacting with the database. Next, processing this <strong class="source-inline">ResultSet</strong> is straightforward:</p>
			<pre class="source-code">while (rsInMem.next()) {</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>This matters because, typically, operating on a JDBC <strong class="source-inline">ResultSet</strong> can be done as long as you hold an open<a id="_idIndexMarker688"/> connection to your database. Check out the complete code next to the other two bullets in the bundled application named <em class="italic">ResultSetFetch</em> (which is available for MySQL).</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Fetching multiple result sets</h1>
			<p>Some RDBMSs (for instance, SQL Server and MySQL after appending the <strong class="source-inline">allowMultiQueries=true</strong> property <a id="_idIndexMarker689"/>to the JDBC URL) can return multiple result sets. Here is such a jOOQ query for MySQL:</p>
			<pre class="source-code">ctx.resultQuery(</pre>
			<pre class="source-code">  "SELECT * FROM employee LIMIT 10; </pre>
			<pre class="source-code">   SELECT * FROM sale LIMIT 5");</pre>
			<p>To fetch multiple result sets in jOOQ, call <strong class="source-inline">fetchMany()</strong>. This method returns an object of the <strong class="source-inline">org.jooq.Results</strong> type, as shown in the following snippet (notice the pluralization to avoid any confusion with <strong class="source-inline">org.jooq.Result</strong>):</p>
			<pre class="source-code">Results results = ctx.resultQuery(</pre>
			<pre class="source-code">   "SELECT * FROM employee LIMIT 10; </pre>
			<pre class="source-code">    SELECT * FROM sale LIMIT 5")</pre>
			<pre class="source-code"> .fetchMany();    </pre>
			<p>Next, you can map each result set to its POJO:</p>
			<pre class="source-code">List&lt;Employee&gt; employees =results.get(0).into(Employee.class);</pre>
			<pre class="source-code">List&lt;Sale&gt; sales = results.get(1).into(Sale.class);</pre>
			<p>Lukas Eder says: </p>
			<p><em class="italic">"Perhaps out of scope, but the Results type also allows for accessing interleaved update counts and exceptions, which is something that is done frequently in T-SQL databases, like SQL Server or Sybase."</em></p>
			<p>Done! In <a id="_idIndexMarker690"/>the <em class="italic">FetchMany</em> application (which is available for MySQL and SQL Server), you can check out this example next to another one that returns two result sets from a query that combines <strong class="source-inline">DELETE</strong> and <strong class="source-inline">SELECT</strong>.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Fetching relationships</h1>
			<p>I'm pretty sure that<a id="_idIndexMarker691"/> you're familiar with the one-to-one, one-to-many, and many-to-many relationships. An emblematic mapping of unidirectional one-to-many roughly looks like this:</p>
			<pre class="source-code">public class SimpleProductLine implements Serializable {</pre>
			<pre class="source-code">   ... </pre>
			<pre class="source-code">   private List&lt;SimpleProduct&gt; products = new ArrayList&lt;&gt;();  </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class SimpleProduct implements Serializable { ... }</pre>
			<p>Moreover, when <strong class="source-inline">SimpleProduct</strong> contains a reference to <strong class="source-inline">SimpleProductLine</strong>, this is considered a bidirectional one-to-many relationship:</p>
			<pre class="source-code">public class SimpleProduct implements Serializable {</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">   private SimpleProductLine productLine;</pre>
			<pre class="source-code">}</pre>
			<p>If we have this POJO model, can we map the corresponding result set to it via the jOOQ API? The answer is definitely yes, and this can be done in several ways. From the <strong class="source-inline">fetchInto()</strong>, <strong class="source-inline">fetchMap()</strong>, and <strong class="source-inline">fetchGroups()</strong> methods that you already saw to the record mappers, the mighty SQL JSON/XML mapping, and the astonishing MULTISET value constructor operator, jOOQ provides so many fetching modes that it is almost impossible to not find a solution.</p>
			<p>Anyway, let's not deviate too much from the subject. Let's consider the following query:</p>
			<pre class="source-code">// Map&lt;Record, Result&lt;Record&gt;&gt;</pre>
			<pre class="source-code">var map = ctx.select(PRODUCTLINE.PRODUCT_LINE, </pre>
			<pre class="source-code">     PRODUCTLINE.TEXT_DESCRIPTION,PRODUCT.PRODUCT_NAME,      </pre>
			<pre class="source-code">     PRODUCT.PRODUCT_VENDOR, PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .join(PRODUCT)</pre>
			<pre class="source-code">   .on(PRODUCTLINE.PRODUCT_LINE</pre>
			<pre class="source-code">      .eq(PRODUCT.PRODUCT_LINE))                </pre>
			<pre class="source-code">   .orderBy(PRODUCTLINE.PRODUCT_LINE).limit(3)</pre>
			<pre class="source-code">   .fetchGroups(new Field[]{PRODUCTLINE.PRODUCT_LINE,</pre>
			<pre class="source-code">          PRODUCTLINE.TEXT_DESCRIPTION},</pre>
			<pre class="source-code">                new Field[]{PRODUCT.PRODUCT_NAME,  </pre>
			<pre class="source-code">          PRODUCT.PRODUCT_VENDOR, PRODUCT.QUANTITY_IN_STOCK});</pre>
			<p>With <strong class="source-inline">Map&lt;Record, Result&lt;Record&gt;&gt;</strong> (which, most of the time, is all you need), we can populate our<a id="_idIndexMarker692"/> bidirectional domain model, as follows:</p>
			<pre class="source-code">List&lt;SimpleProductLine&gt; result = map.entrySet()</pre>
			<pre class="source-code">   .stream()</pre>
			<pre class="source-code">   .map((e) -&gt; {</pre>
			<pre class="source-code">      SimpleProductLine productLine </pre>
			<pre class="source-code">         = e.getKey().into(SimpleProductLine.class);</pre>
			<pre class="source-code">      List&lt;SimpleProduct&gt; products </pre>
			<pre class="source-code">         = e.getValue().into(SimpleProduct.class);</pre>
			<pre class="source-code">                    </pre>
			<pre class="source-code">      productLine.setProducts(products);</pre>
			<pre class="source-code">      products.forEach(p -&gt; </pre>
			<pre class="source-code">        ((SimpleProduct) p).setProductLine(productLine));</pre>
			<pre class="source-code">                    </pre>
			<pre class="source-code">      return productLine;</pre>
			<pre class="source-code">   }).collect(Collectors.toList());</pre>
			<p>If you want to avoid passing through <strong class="source-inline">fetchGroups()</strong>, then you can rely on <strong class="source-inline">ResultQuery.collect()</strong> and <strong class="source-inline">Collectors.groupingBy()</strong>. This is especially useful if you want to run a <strong class="source-inline">LEFT JOIN</strong> statement since <strong class="source-inline">fetchGroups()</strong> has the following issue: <a href="https://github.com/jOOQ/jOOQ/issues/11888">https://github.com/jOOQ/jOOQ/issues/11888</a>. Another approach is to map from <strong class="source-inline">ResultSet</strong>. You can see these approaches along with other approaches for<a id="_idIndexMarker693"/> unidirectional/bidirectional one-to-one and many-to-many relationships in the bundled code in the <em class="italic">OneToOne</em>, <em class="italic">OneToMany</em>, and <em class="italic">ManyToMany</em> applications (which are available for MySQL).</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Hooking POJOs</h1>
			<p>You already<a id="_idIndexMarker694"/> know that jOOQ can generate POJOs on our behalf and it can handle user-defined POJOs, too. Moreover, you saw a significant number of mappings of a jOOQ result into POJOs (typically, via <strong class="source-inline">fetchInto()</strong>); therefore, this is not a brand new topic for you. However, in this section, let's take a step further and really focus on different types of POJOs that are supported by jOOQ.</p>
			<p>If all we configure is <strong class="source-inline">&lt;pojos&gt;true&lt;/pojos&gt;</strong> (here, Maven), then jOOQ generates POJOs with <strong class="source-inline">private</strong> fields, empty constructors, constructors with arguments, getters and setters, and <strong class="source-inline">toString()</strong>. However, jOOQ can also handle a very simple user-defined POJO such as this one:</p>
			<pre class="source-code">public class SimplestCustomer { </pre>
			<pre class="source-code">   public String customerName; </pre>
			<pre class="source-code">   public String customerPhone; </pre>
			<pre class="source-code">}</pre>
			<p>Here is a query that <a id="_idIndexMarker695"/>populates this POJO:</p>
			<pre class="source-code">List&lt;SimplestCustomer&gt; result = ctx.select(</pre>
			<pre class="source-code">   CUSTOMER.CUSTOMER_NAME, CUSTOMER.PHONE.as("customerPhone"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(SimplestCustomer.class);</pre>
			<p>Pay attention to the <strong class="source-inline">as("customerPhone")</strong> alias. This is needed to map <strong class="source-inline">CUSTOMER.PHONE</strong> to POJO's <strong class="source-inline">customerPhone</strong> field; otherwise, this POJO field will be left <strong class="source-inline">null</strong> since jOOQ cannot find the proper match. Another approach is to add a constructor with arguments, as shown in the following POJO:</p>
			<pre class="source-code">public class SimpleDepartment {</pre>
			<pre class="source-code">   private String depName;</pre>
			<pre class="source-code">   private Short depCode;</pre>
			<pre class="source-code">   private String[] depTopic;</pre>
			<pre class="source-code">   public SimpleDepartment(String depName, </pre>
			<pre class="source-code">          Short depCode, String[] depTopic) {</pre>
			<pre class="source-code">      this.depName = depName;</pre>
			<pre class="source-code">      this.depCode = depCode;</pre>
			<pre class="source-code">      this.depTopic = depTopic;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>Even if none of the POJO's field names match the names of the fetched fields, the POJO is correctly populated by jOOQ based on this constructor with arguments:</p>
			<pre class="source-code">List&lt;SimpleDepartment&gt; result = ctx.select(</pre>
			<pre class="source-code">      DEPARTMENT.NAME, DEPARTMENT.CODE, DEPARTMENT.TOPIC)</pre>
			<pre class="source-code">   .from(DEPARTMENT).fetchInto(SimpleDepartment.class);</pre>
			<pre class="source-code">List&lt;SimpleDepartment&gt; result = ctx.select(</pre>
			<pre class="source-code">      DEPARTMENT.NAME, DEPARTMENT.CODE, DEPARTMENT.TOPIC)</pre>
			<pre class="source-code">   .from(DEPARTMENT)</pre>
			<pre class="source-code">   .fetch(mapping(SimpleDepartment::new));</pre>
			<p>User-defined POJOs are <a id="_idIndexMarker696"/>useful for mapping jOOQ results that contain fields from multiple tables. For example, a POJO can be used to flatten a one-to-many relationship, as shown here:</p>
			<pre class="source-code">public class FlatProductline {</pre>
			<pre class="source-code">    private String productLine;</pre>
			<pre class="source-code">    private Long code;</pre>
			<pre class="source-code">    private String productName;    </pre>
			<pre class="source-code">    private String productVendor;    </pre>
			<pre class="source-code">    private Integer quantityInStock;</pre>
			<pre class="source-code">    // constructors, getters, setters, toString()</pre>
			<pre class="source-code">}</pre>
			<p>And, here's the jOOQ query:</p>
			<pre class="source-code">List&lt;FlatProductline&gt; result = ctx.select(</pre>
			<pre class="source-code">      PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE,</pre>
			<pre class="source-code">      PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, </pre>
			<pre class="source-code">      PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .join(PRODUCT)</pre>
			<pre class="source-code">   .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">   .fetchInto(FlatProductline.class);</pre>
			<pre class="source-code">// .fetch(mapping(FlatProductline::new));</pre>
			<p>Alternatively, you can map UDTs and/or embeddable types. For instance, here is a user-defined POJO that<a id="_idIndexMarker697"/> fetches a String and an embeddable type containing a UDT. For the embeddable type, we relied on the jOOQ-generated POJO:</p>
			<pre class="source-code">import jooq.generated.embeddables.pojos.ManagerStatus;</pre>
			<pre class="source-code">public class SimpleManagerStatus {    </pre>
			<pre class="source-code">   private Long managerId;</pre>
			<pre class="source-code">   private ManagerStatus ms;</pre>
			<pre class="source-code">   // constructors, getters, setters, toString()</pre>
			<pre class="source-code">}</pre>
			<p>And, the<a id="_idIndexMarker698"/> jOOQ query is as follows:</p>
			<pre class="source-code">List&lt;SimpleManagerStatus&gt; result =   </pre>
			<pre class="source-code">       ctx.select(MANAGER.MANAGER_ID, MANAGER.MANAGER_STATUS)</pre>
			<pre class="source-code">   .from(MANAGER).fetchInto(SimpleManagerStatus.class);</pre>
			<p>More examples are available in the bundled code (that is, in the <em class="italic">PojoTypes</em> application, which is available for PostgreSQL). Next, let's talk about the different types of POJOs supported by jOOQ.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Types of POJOs</h2>
			<p>Besides the<a id="_idIndexMarker699"/> typical POJOs from the previous section, jOOQ also supports several other types of POJOs. For instance, it supports immutable POJOs.</p>
			<h3>Immutable POJOs</h3>
			<p>A<a id="_idIndexMarker700"/> user-defined immutable<a id="_idIndexMarker701"/> POJO can be written as follows:</p>
			<pre class="source-code">public final class ImmutableCustomer {</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    private final String customerName;</pre>
			<pre class="source-code">    private final YearMonth ym;</pre>
			<pre class="source-code">    // constructor and only getters</pre>
			<pre class="source-code">}</pre>
			<p>And a jOOQ query that maps to this POJO is shown next:</p>
			<pre class="source-code">List&lt;ImmutableCustomer&gt; result = ctx.select(</pre>
			<pre class="source-code">      CUSTOMER.CUSTOMER_NAME,   </pre>
			<pre class="source-code">      CUSTOMER.FIRST_BUY_DATE.coerce(YEARMONTH))</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetchInto(ImmutableCustomer.class);</pre>
			<pre class="source-code">// .fetch(mapping(ImmutableCustomer::new));</pre>
			<p>To work as expected, immutable POJOs require an exact match between the fetched fields and the POJO's fields (the constructor arguments). However, you can explicitly relax this match via <strong class="source-inline">@ConstructorProperties</strong> (<strong class="source-inline">java.beans.ConstructorProperties</strong>). Please check the bundled code (<em class="italic">Example 2.2</em>) for a meaningful example.</p>
			<p>jOOQ can generate immutable POJOs on our behalf via the following configuration in the <strong class="source-inline">&lt;generate/&gt;</strong> tag:</p>
			<pre class="source-code">&lt;immutablePojos&gt;true&lt;/immutablePojos&gt;</pre>
			<p>Also, it can generate <strong class="source-inline">@ConstructorProperties</strong> via the following:</p>
			<pre class="source-code">&lt;constructorPropertiesAnnotationOnPojos&gt;</pre>
			<pre class="source-code">   true</pre>
			<pre class="source-code">&lt;/constructorPropertiesAnnotationOnPojos&gt;</pre>
			<p>In the <a id="_idIndexMarker702"/>bundled code, next to the other examples, you can also practice mapping UDTs and embeddable types via <a id="_idIndexMarker703"/>user-defined immutable POJOs.</p>
			<h3>POJOs decorated with @Column (jakarta.persistence.Column)</h3>
			<p>jOOQ can map a <strong class="source-inline">Result</strong> object<a id="_idIndexMarker704"/> to a POJO as follows:</p>
			<pre class="source-code">public class JpaCustomer {</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">   @Column(name = "customer_name") </pre>
			<pre class="source-code">   public String cn;</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">   @Column(name = "first_buy_date") </pre>
			<pre class="source-code">   public YearMonth ym;      </pre>
			<pre class="source-code">}</pre>
			<p>As you can see, jOOQ recognizes the <strong class="source-inline">@Column</strong> annotation and uses it as the primary source for mapping metainformation:</p>
			<pre class="source-code">List&lt;JpaCustomer&gt; result = ctx.select(CUSTOMER.CUSTOMER_NAME, </pre>
			<pre class="source-code">       CUSTOMER.FIRST_BUY_DATE.coerce(YEARMONTH))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(JpaCustomer.class);</pre>
			<p>jOOQ can generate such POJOs via the following configuration in <strong class="source-inline">&lt;generate/&gt;</strong>:</p>
			<pre class="source-code">&lt;jpaAnnotations&gt;true&lt;/jpaAnnotations&gt;</pre>
			<p>Check out more<a id="_idIndexMarker705"/> examples in the bundled code.</p>
			<h3>JDK 16 records</h3>
			<p>Consider the <a id="_idIndexMarker706"/>following JDK 16<a id="_idIndexMarker707"/> record:</p>
			<pre class="source-code">public record RecordDepartment(</pre>
			<pre class="source-code">   String name, Integer code, String[] topic) {}</pre>
			<p>And the jOOQ query is as follows:</p>
			<pre class="source-code">List&lt;RecordDepartment&gt; result = ctx.select(</pre>
			<pre class="source-code">        DEPARTMENT.NAME, DEPARTMENT.CODE, DEPARTMENT.TOPIC)</pre>
			<pre class="source-code">              .from(DEPARTMENT)</pre>
			<pre class="source-code">              .fetchInto(RecordDepartment.class);</pre>
			<pre class="source-code">           // .fetch(mapping(RecordDepartment::new));</pre>
			<p>Alternatively, here is a user-defined JDK 16 record along with a UDT type:</p>
			<pre class="source-code">public record RecordEvaluationCriteria(</pre>
			<pre class="source-code">   Integer communicationAbility, Integer ethics, </pre>
			<pre class="source-code">   Integer performance, Integer employeeInput) {}</pre>
			<pre class="source-code">public record RecordManager(</pre>
			<pre class="source-code">   String managerName, RecordEvaluationCriteria rec) {}</pre>
			<p>And the jOOQ query is as follows:</p>
			<pre class="source-code">List&lt;RecordManager&gt; result = ctx.select(</pre>
			<pre class="source-code">       MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .from(MANAGER).fetchInto(RecordManager.class);</pre>
			<p>Or you can use a user-defined JDK 16 record with an embeddable type (here, we are using the POJO generated by jOOQ for the embeddable type):</p>
			<pre class="source-code">import jooq.generated.embeddables.pojos.OfficeFullAddress;</pre>
			<pre class="source-code">public record RecordOffice(</pre>
			<pre class="source-code">   String officecode, OfficeFullAddress ofa) {}</pre>
			<p>And here is the<a id="_idIndexMarker708"/> jOOQ query:</p>
			<pre class="source-code">List&lt;RecordOffice&gt; result = ctx.select(</pre>
			<pre class="source-code">         OFFICE.OFFICE_CODE, OFFICE.OFFICE_FULL_ADDRESS)</pre>
			<pre class="source-code">   .from(OFFICE).fetchInto(RecordOffice.class);</pre>
			<p>jOOQ can generate JDK 16 records on our behalf via the following configuration in <strong class="source-inline">&lt;generate/&gt;</strong>:</p>
			<pre class="source-code">&lt;pojosAsJavaRecordClasses&gt;true&lt;/pojosAsJavaRecordClasses&gt;</pre>
			<p>In the bundled code, you can <a id="_idIndexMarker709"/>practice JDK 16 records for UDT, embeddable types, and more.</p>
			<h3>Interfaces and abstract classes </h3>
			<p>Finally, jOOQ can map a<a id="_idIndexMarker710"/> result into interfaces (abstract classes) known as "proxyable" types. You <a id="_idIndexMarker711"/>can find examples in the bundled code and in the <a id="_idIndexMarker712"/>jOOQ manual at <a href="https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/">https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/</a>.</p>
			<p>Moreover, jOOQ can generate interfaces on our behalf via this configuration in the <strong class="source-inline">&lt;generate/&gt;</strong> tag:</p>
			<pre class="source-code">&lt;interfaces&gt;true&lt;/interfaces&gt;</pre>
			<p>If POJOs are also generated, then they will implement these interfaces.</p>
			<h3>Useful configurations for POJOs</h3>
			<p>Among POJO's<a id="_idIndexMarker713"/> configurations, we can ask jOOQ to not generate the <strong class="source-inline">toString()</strong> method for the POJO via the <strong class="source-inline">&lt;pojosToString/&gt;</strong> flag, to not generate serializable POJOs (to not implement <strong class="source-inline">Serializable</strong>) via the <strong class="source-inline">&lt;serializablePojos/&gt;</strong> flag, and to generate fluent setters via the <strong class="source-inline">&lt;fluentSetters/&gt;</strong> flag. Moreover, besides POJOs for Java, we can ask jOOQ to generate POJOs for Kotlin via the <strong class="source-inline">&lt;pojosAsKotlinDataClasses/&gt;</strong> flag or for Scala via the <strong class="source-inline">&lt;pojosAsScalaCaseClasses/&gt;</strong> flag.</p>
			<p>In addition, under the <strong class="source-inline">&lt;database/&gt;</strong> tag, we can force <strong class="source-inline">LocalDateTime</strong> into POJOs via <strong class="source-inline">&lt;dateAsTimestamp/&gt;</strong> and use unsigned types via <strong class="source-inline">&lt;unsignedTypes/&gt;</strong>.</p>
			<p>The complete code is<a id="_idIndexMarker714"/> named <em class="italic">PojoTypes</em> (which is available for PostgreSQL (Maven/Gradle)). In the next section, let's talk about record mappers.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>jOOQ record mappers</h1>
			<p>Sometimes, we need a <a id="_idIndexMarker715"/>custom mapping that cannot be achieved via the <strong class="source-inline">fetchInto() </strong>method, the <strong class="source-inline">fetchMap()</strong> method, the <strong class="source-inline">fetchGroups()</strong> method, or the <strong class="source-inline">Records</strong> utility. A <a id="_idIndexMarker716"/>simple approach relies on <strong class="source-inline">Iterable.forEach(Consumer)</strong>, as shown in the following mapping:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, EMPLOYEE.EMAIL)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .forEach((Record3&lt;String, String, String&gt; record) -&gt; {</pre>
			<pre class="source-code">      System.out.println("\n\nTo: " </pre>
			<pre class="source-code">       + record.getValue(EMPLOYEE.EMAIL));</pre>
			<pre class="source-code">      System.out.println("From: " </pre>
			<pre class="source-code">       + "hrdepartment@classicmodelcars.com");</pre>
			<pre class="source-code">      System.out.println("Body: \n   Dear, "</pre>
			<pre class="source-code">       + record.getValue(EMPLOYEE.FIRST_NAME)</pre>
			<pre class="source-code">       + " " + record.getValue(EMPLOYEE.LAST_NAME) + " ...");</pre>
			<pre class="source-code">});</pre>
			<p>You can check out this example for MySQL in <em class="italic">ForEachConsumer</em>.</p>
			<p>However, especially for such cases, jOOQ provides a functional interface that allows us to express the custom mappings of a jOOQ result. In this context, we have <strong class="source-inline">org.jooq.RecordMapper</strong>, which returns<a id="_idIndexMarker717"/> the result produced after applying a custom mapping to the jOOQ result. For instance, let's consider a legacy POJO that was implemented via the <strong class="source-inline">Builder</strong> pattern and is named <strong class="source-inline">LegacyCustomer</strong>:</p>
			<pre class="source-code">public final class LegacyCustomer {</pre>
			<pre class="source-code">   private final String customerName;</pre>
			<pre class="source-code">   private final String customerPhone;</pre>
			<pre class="source-code">   private final BigDecimal creditLimit;</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">   public static CustomerBuilder getBuilder(</pre>
			<pre class="source-code">                             String customerName) {</pre>
			<pre class="source-code">      return new LegacyCustomer.CustomerBuilder(customerName);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   public static final class CustomerBuilder {</pre>
			<pre class="source-code">      …</pre>
			<pre class="source-code">      public LegacyCustomer build() {</pre>
			<pre class="source-code">         return new LegacyCustomer(this);</pre>
			<pre class="source-code">      }      </pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">}</pre>
			<p>Mapping a jOOQ result into <strong class="source-inline">LegacyCustomer</strong> can be done via a <strong class="source-inline">RecordMapper</strong> parameter, as follows:</p>
			<pre class="source-code">List&lt;LegacyCustomer&gt; result </pre>
			<pre class="source-code">        = ctx.select(CUSTOMER.CUSTOMER_NAME, CUSTOMER.PHONE,   </pre>
			<pre class="source-code">                     CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .fetch((Record3&lt;String, String, BigDecimal&gt; record) -&gt; {</pre>
			<pre class="source-code">      LegacyCustomer customer = LegacyCustomer.getBuilder(</pre>
			<pre class="source-code">         record.getValue(CUSTOMER.CUSTOMER_NAME))</pre>
			<pre class="source-code">         .customerPhone(record.getValue(CUSTOMER.PHONE))</pre>
			<pre class="source-code">         .creditLimit(record.getValue(CUSTOMER.CREDIT_LIMIT))</pre>
			<pre class="source-code">         .build();</pre>
			<pre class="source-code">                    </pre>
			<pre class="source-code">      return customer;</pre>
			<pre class="source-code">});</pre>
			<p>This example is available in the bundled code, <em class="italic">RecordMapper</em> (which is available for PostgreSQL), next to other examples such as using a <strong class="source-inline">RecordMapper</strong> parameter to map a jOOQ result into a <a id="_idIndexMarker718"/>max-heap. Moreover, in <a href="B16833_18.xhtml#_idTextAnchor338"><em class="italic">Chapter 18</em></a>, <em class="italic">jOOQ SPI (Providers and Listeners)</em>, you'll see how to configure record mappers via <strong class="source-inline">RecordMapperProvider</strong> so that jOOQ will automatically pick them up.</p>
			<p>However, if you need more generic mapping algorithms, then we have to check out some third-party libraries that work with jOOQ. In the top three such libraries, we have ModelMapper, SimpleFlatMapper, and Orika Mapper.</p>
			<p>It is beyond the scope of this book to deep dive into all these libraries. Therefore, I decided to go with the SimpleFlatMapper library (<a href="https://simpleflatmapper.org/">https://simpleflatmapper.org/</a>). Let's assume the following one-to-many mapping:</p>
			<pre class="source-code">public class SimpleProductLine {</pre>
			<pre class="source-code">   private String productLine;</pre>
			<pre class="source-code">   private String textDescription;   </pre>
			<pre class="source-code">   private List&lt;SimpleProduct&gt; products;</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class SimpleProduct {</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">   private String productName;</pre>
			<pre class="source-code">   private String productVendor;</pre>
			<pre class="source-code">   private Short quantityInStock;</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">}</pre>
			<p>Essentially, SimpleFlatMapper can<a id="_idIndexMarker719"/> map a jOOQ result via <strong class="source-inline">SelectQueryMapper</strong>, as shown in the following self-explanatory example:</p>
			<pre class="source-code">private final SelectQueryMapper&lt;SimpleProductLine&gt; sqMapper;</pre>
			<pre class="source-code">private final DSLContext ctx;</pre>
			<pre class="source-code">public ClassicModelsRepository(DSLContext ctx) {</pre>
			<pre class="source-code">   this.ctx = ctx;</pre>
			<pre class="source-code">   this.sqMapper = SelectQueryMapperFactory</pre>
			<pre class="source-code">      .newInstance().newMapper(SimpleProductLine.class);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public List&lt;SimpleProductLine&gt; findProductLineWithProducts() {</pre>
			<pre class="source-code">   List&lt;SimpleProductLine&gt; result = sqMapper.asList(</pre>
			<pre class="source-code">     ctx.select(PRODUCTLINE.PRODUCT_LINE,  </pre>
			<pre class="source-code">         PRODUCTLINE.TEXT_DESCRIPTION,</pre>
			<pre class="source-code">         PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, </pre>
			<pre class="source-code">         PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">        .from(PRODUCTLINE)</pre>
			<pre class="source-code">        .innerJoin(PRODUCT)</pre>
			<pre class="source-code">        .on(PRODUCTLINE.PRODUCT_LINE</pre>
			<pre class="source-code">           .eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">        .orderBy(PRODUCTLINE.PRODUCT_LINE));</pre>
			<pre class="source-code">   return result;</pre>
			<pre class="source-code">}</pre>
			<p>In this code, SimpleFlatMapper maps the jOOQ result, so it acts directly on the jOOQ records. This code is available in the <em class="italic">SFMOneToManySQM</em> application (available for MySQL). However, as <a id="_idIndexMarker720"/>you can see in the <em class="italic">SFMOneToManyJM</em> application, this library can also take advantage of the fact that jOOQ allows us to manipulate the <strong class="source-inline">ResultSet</strong> object itself, so it can act directly on the <strong class="source-inline">ResultSet</strong> object via an API named <strong class="source-inline">JdbcMapper</strong>. This way, SimpleFlatMapper bypasses the jOOQ mapping to <strong class="source-inline">Record</strong>.</p>
			<p>Moreover, the bundled code includes applications for mapping one-to-one and many-to-many relationships next to <em class="italic">SFMOneToManyTupleJM</em>, which is an application that combines SimpleFlatMapper and the jOOL <strong class="source-inline">Tuple2</strong> API to map a one-to-many relationship without using POJOs. For brevity, we cannot list this code in the book, so you need to reserve some time to explore it by yourself.</p>
			<p>From another perspective, via the same <strong class="source-inline">SelectQueryMapper</strong> and <strong class="source-inline">JdbcMapper</strong> APIs, the SimpleFlatMapper<a id="_idIndexMarker721"/> library can co-work with jOOQ to map chained and/or nested <strong class="source-inline">JOIN</strong> statements. For instance, consider this model:</p>
			<pre class="source-code">public class SimpleEmployee {</pre>
			<pre class="source-code">   private Long employeeNumber;</pre>
			<pre class="source-code">   private String firstName;</pre>
			<pre class="source-code">   private String lastName;</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">   private Set&lt;SimpleCustomer&gt; customers;</pre>
			<pre class="source-code">   private Set&lt;SimpleSale&gt; sales;</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class SimpleCustomer { private String customerName; … }</pre>
			<pre class="source-code">public class SimpleSale { private Float sale; … }</pre>
			<p>Using the SimpleFlatMapper and jOOQ combination, we can populate this model as follows:</p>
			<pre class="source-code">this.sqMapper = …;</pre>
			<pre class="source-code">List&lt;SimpleEmployee&gt; result = sqMapper.asList(</pre>
			<pre class="source-code">   ctx.select(EMPLOYEE.EMPLOYEE_NUMBER, EMPLOYEE.FIRST_NAME,</pre>
			<pre class="source-code">       EMPLOYEE.LAST_NAME, CUSTOMER.CUSTOMER_NAME, SALE.SALE_)</pre>
			<pre class="source-code">      .from(EMPLOYEE)</pre>
			<pre class="source-code">      .leftOuterJoin(CUSTOMER)</pre>
			<pre class="source-code">      .on(CUSTOMER.SALES_REP_EMPLOYEE_NUMBER</pre>
			<pre class="source-code">        .eq(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">      .leftOuterJoin(SALE)</pre>
			<pre class="source-code">      .on(EMPLOYEE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">        .eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">      .where(EMPLOYEE.OFFICE_CODE.eq(officeCode))</pre>
			<pre class="source-code">      .orderBy(EMPLOYEE.EMPLOYEE_NUMBER));</pre>
			<p>The complete code is named <em class="italic">SFMMultipleJoinsSQM</em>. The version of this code that uses <strong class="source-inline">JdbcMapper</strong> is named <em class="italic">SFMMultipleJoinsJM</em>. Moreover, in the bundled code, you can find an example of mapping a deep hierarchical JOIN of type (<strong class="source-inline">EMPLOYEE</strong> has <strong class="source-inline">CUSTOMER</strong> has <strong class="source-inline">ORDER</strong> has <strong class="source-inline">ORDERDETAIL</strong> has <strong class="source-inline">PRODUCT</strong>). This JOIN is also mapped in <em class="italic">SFMMultipleJoinsInnerLevelsTupleJM</em> using jOOL <strong class="source-inline">Tuple2</strong> and no POJOs. Anyway, even if such things work, I don't recommend you to do it in real applications. You better rely on the SQL/JSON/XML operators or MULTISET, as you'll do later.</p>
			<p>Again, for brevity, we <a id="_idIndexMarker722"/>cannot list this code in the book, so you need to reserve some time to explore it by yourself. At this point, we have reached the climax of this chapter. It's time to beat the drums because the next section covers the outstanding mapping support of jOOQ SQL/JSON and SQL/XML.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>The mighty SQL/JSON and SQL/XML support</h1>
			<p>Starting with jOOQ 3.14, we have support for mapping a result set to any kind of hierarchical/nested structure that can be shaped via JSON or XML into, practically, almost anything. For instance, if you develop a REST API, you can return JSON/XML data in the exact desired shape without mapping anything to your domain model.</p>
			<p>As you probably know, most RDBMSs support SQL/JSON (standard or vendor-specific), and some of them support SQL/XML, too. </p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Handling SQL/JSON support</h2>
			<p>In a nutshell, for<a id="_idIndexMarker723"/> SQL/JSON, we can talk about the following operators that have a jOOQ implementation in the <strong class="source-inline">org.jooq.impl.DSL</strong> class:</p>
			<ul>
				<li><strong class="source-inline">JSON_OBJECT</strong> (<strong class="source-inline">DSL.jsonObject()</strong>, <strong class="source-inline">DSL.jsonEntry()</strong>), <strong class="source-inline">JSON_ARRAY</strong> (<strong class="source-inline">DSL.jsonArray()</strong>), and <strong class="source-inline">JSON_VALUE</strong> (<strong class="source-inline">DSL.jsonValue()</strong>) to construct JSON data from values</li>
				<li><strong class="source-inline">JSON_ARRAYAGG</strong> (<strong class="source-inline">DSL.jsonArrayAgg()</strong>) and <strong class="source-inline">JSON_OBJECTAGG</strong> (<strong class="source-inline">DSL.jsonObjectAgg()</strong>) to aggregate data into nested JSON documents</li>
				<li><strong class="source-inline">JSON_EXISTS</strong> (<strong class="source-inline">DSL.jsonExists()</strong>) to query documents with the JSON path</li>
				<li><strong class="source-inline">JSON_TABLE</strong> (<strong class="source-inline">DSL.jsonTable()</strong>) to transform JSON values into SQL tables</li>
				<li>SQL Server's <strong class="source-inline">FOR JSON</strong> syntax (including <strong class="source-inline">ROOT</strong>, <strong class="source-inline">PATH</strong>, <strong class="source-inline">AUTO</strong>, and <strong class="source-inline">WITHOUT_ARRAY_WRAPPER</strong>); the jOOQ commercial edition emulates the <strong class="source-inline">FOR JSON</strong> syntax for the databases that don't support it (in this book, you can see this for SQL Server and Oracle)</li>
			</ul>
			<p>Let's see some introductory examples of these operators via the jOOQ DSL API.</p>
			<h3>Constructing and aggregating JSON data from the values</h3>
			<p>Constructing JSON data<a id="_idIndexMarker724"/> from values can be done via the <strong class="source-inline">JSON_OBJECT</strong> operator. This is implemented in jOOQ via different flavors of the <strong class="source-inline">DSL.jsonObject()</strong> method. For instance, you can map the <strong class="source-inline">CUSTOMER.CUSTOMER_NAME</strong> and <strong class="source-inline">CUSTOMER.CREDIT_LIMIT</strong> fields to an <strong class="source-inline">org.jooq.JSON</strong> object as follows:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code">   key("customerName").value(CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">   key("creditLimit").value(CUSTOMER.CREDIT_LIMIT))</pre>
			<pre class="source-code">      .as("json_result"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetch();</pre>
			<p>In contrast to the <strong class="source-inline">key().value()</strong> construction, we can use <strong class="source-inline">jsonObject(JSON Entry&lt;?&gt;... entries)</strong>, as follows:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code">   jsonEntry("customerName", CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">   jsonEntry("creditLimit", CUSTOMER.CREDIT_LIMIT))</pre>
			<pre class="source-code">      .as("json_result"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetch();</pre>
			<p>The returned <strong class="source-inline">Result</strong> object (remember that this is a wrapper of <strong class="source-inline">java.util.List</strong>) has a size equal to the number of fetched customers. Each <strong class="source-inline">Record1</strong> object wraps an <strong class="source-inline">org.jooq.JSON</strong> instance<a id="_idIndexMarker725"/> representing a customer name and credit limit. If we just want to format this <strong class="source-inline">Result</strong> object as a JSON, we can call the <strong class="source-inline">formatJSON()</strong> method (this will be presented in the next chapter). This will return a simple formatted representation such as the one here:</p>
			<pre class="source-code">System.out.println(result.formatJSON());</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code"> "fields": [{"name": "json_result", "type": "JSON"}],</pre>
			<pre class="source-code"> "records": </pre>
			<pre class="source-code"> [</pre>
			<pre class="source-code">  [{"creditLimit": 21000, "customerName": "Australian Home"}],</pre>
			<pre class="source-code">  [{"creditLimit": 21000, "customerName": "Joliyon"}],</pre>
			<pre class="source-code">  [{"creditLimit": 21000, "customerName": "Marquez Xioa"}]</pre>
			<pre class="source-code">  …</pre>
			<pre class="source-code"> ]</pre>
			<pre class="source-code">}</pre>
			<p>However, this response is too verbose to send to the client. For instance, you might only need the <strong class="source-inline">"records"</strong> key. In such cases, we can rely on the <strong class="source-inline">formatJSON(JSONFormat)</strong> flavor as follows:</p>
			<pre class="source-code">System.out.println(          </pre>
			<pre class="source-code">   result.formatJSON(JSONFormat.DEFAULT_FOR_RECORDS));</pre>
			<pre class="source-code">[</pre>
			<pre class="source-code"> [{"creditLimit": 50000.00, "customerName":"GOLD"}],</pre>
			<pre class="source-code"> [{"creditLimit": null, "customerName": "Australian Home"}],</pre>
			<pre class="source-code"> [{"creditLimit": null, "customerName": "Joliyon"}],</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">]</pre>
			<p>Supposing that you just want to <a id="_idIndexMarker726"/>send the first JSON array, you can extract it from the <strong class="source-inline">Result</strong> object as <strong class="source-inline">result.get(0).value1().data()</strong>:</p>
			<pre class="source-code">result.get(0) // 0-first JSON, 1-second JSON, 2-third JSON …</pre>
			<pre class="source-code">.value1()     // this is the value from Record1, a JSON</pre>
			<pre class="source-code">.data()       // this is the data of the first JSON as String</pre>
			<pre class="source-code">{"creditLimit": 21000.00, "customerName": "Australian Home"}</pre>
			<p>However, perhaps you are planning to send all these JSONs as a <strong class="source-inline">List&lt;String&gt;</strong> to the client. Then, rely on <strong class="source-inline">fetchInto(String.class)</strong>, which will return all of the JSONs as a <strong class="source-inline">List&lt;String&gt;</strong>. Note that each <strong class="source-inline">String</strong> is a JSON:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code">      jsonEntry("customerName", CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">      jsonEntry("creditLimit", CUSTOMER.CREDIT_LIMIT))</pre>
			<pre class="source-code">         .as("json_result"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(String.class);</pre>
			<p>Also, you can send the response as a list of JSON arrays. Just wrap each JSON object into an array via <strong class="source-inline">jsonArray()</strong>, as follows:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(jsonArray(jsonObject(</pre>
			<pre class="source-code">   jsonEntry("customerName", CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">   jsonEntry("creditLimit", CUSTOMER.CREDIT_LIMIT)))</pre>
			<pre class="source-code">      .as("json_result"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchInto(String.class);</pre>
			<p>This time, the first JSON <a id="_idIndexMarker727"/>array (at index 0 in the list) is <em class="italic">[{"creditLimit": 21000.00, "customerName": "Australian Home"}]</em>, the second one (at index 1 in the list) is <em class="italic">[{"creditLimit": 21000, "customerName": "Joliyon"}]</em>, and so on.</p>
			<p>However, it is more practical to <a id="_idIndexMarker728"/>aggregate all of these JSONs into a single array. This is possible via <strong class="source-inline">jsonArrayAgg()</strong>, which will return a single JSON array containing all of the fetched data:</p>
			<pre class="source-code">String result = ctx.select(jsonArrayAgg(jsonObject(</pre>
			<pre class="source-code">      jsonEntry("customerName", CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">      jsonEntry("creditLimit", CUSTOMER.CREDIT_LIMIT)))</pre>
			<pre class="source-code">         .as("json_result"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchSingleInto(String.class);</pre>
			<p>The aggregated JSON array is given here:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  {"creditLimit": 21000,"customerName": "Australian Home"},</pre>
			<pre class="source-code">  {"creditLimit": 21000,"customerName": "Joliyon"},</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">]</pre>
			<p>However, we can also aggregate the fetched data as a single JSON object that has <strong class="source-inline">CUSTOMER_NAME</strong> as the key and <strong class="source-inline">CREDIT_LIMIT</strong> as the value. This can be done via the <strong class="source-inline">jsonObjectAgg()</strong> method, as follows:</p>
			<pre class="source-code">String result = ctx.select(jsonObjectAgg(</pre>
			<pre class="source-code">      CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">         .as("json_result"))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetchSingleInto(String.class);</pre>
			<p>This time, the<a id="_idIndexMarker729"/> resulting JSON is as follows:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "Joliyon": 21000,</pre>
			<pre class="source-code">  "Falafel 3": 21000,</pre>
			<pre class="source-code">  "Petit Auto": 79900,</pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">}</pre>
			<p>If you are a SQL Server fan, then you know that fetching data as JSON can be done via the non-standard <strong class="source-inline">FOR JSON</strong> syntax. jOOQ supports this syntax via the <strong class="source-inline">forJson()</strong> API. It also supports clauses such as <strong class="source-inline">ROOT</strong> via <strong class="source-inline">root()</strong>, <strong class="source-inline">PATH</strong> via <strong class="source-inline">path()</strong>, <strong class="source-inline">AUTO</strong> via <strong class="source-inline">auto()</strong>, and <strong class="source-inline">WITHOUT_ARRAY_WRAPPER</strong> via <strong class="source-inline">withoutArrayWrapper()</strong>. Here is an example that produces nested results by using dot-separated column names via <strong class="source-inline">PATH</strong>:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">      CUSTOMER.CONTACT_FIRST_NAME, CUSTOMER.CREDIT_LIMIT,</pre>
			<pre class="source-code">      PAYMENT.INVOICE_AMOUNT.as("Payment.Amount"),</pre>
			<pre class="source-code">      PAYMENT.CACHING_DATE.as("Payment.CachingDate"))</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .join(PAYMENT)</pre>
			<pre class="source-code">   .on(CUSTOMER.CUSTOMER_NUMBER.eq(PAYMENT.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .orderBy(CUSTOMER.CREDIT_LIMIT).limit(5)</pre>
			<pre class="source-code">   .forJSON().path().root("customers")</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And here is an example of using <strong class="source-inline">AUTO</strong>, which automatically produces the output based on the structure<a id="_idIndexMarker730"/> of the <strong class="source-inline">SELECT</strong> statement:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">      CUSTOMER.CONTACT_FIRST_NAME, CUSTOMER.CREDIT_LIMIT,</pre>
			<pre class="source-code">      PAYMENT.INVOICE_AMOUNT, PAYMENT.CACHING_DATE)</pre>
			<pre class="source-code">  .from(CUSTOMER)</pre>
			<pre class="source-code">  .join(PAYMENT)</pre>
			<pre class="source-code">  .on(CUSTOMER.CUSTOMER_NUMBER.eq(PAYMENT.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">  .orderBy(CUSTOMER.CREDIT_LIMIT).limit(5)</pre>
			<pre class="source-code">  .forJSON().auto().withoutArrayWrapper().fetch();</pre>
			<p>You can check out these examples in the bundled code for <em class="italic">SimpleJson</em> and get familiar with the produced JSONs. For now, let's talk about ordering and limiting the content of the resulting JSON when using SQL-standard JSON operators (for SQL Server's <strong class="source-inline">FOR JSON</strong> syntax, consider the previous two examples).</p>
			<h3>Using ORDER BY and LIMIT</h3>
			<p>When we don't use <a id="_idIndexMarker731"/>aggregation operators, ordering and limiting are quite similar to regular queries. For instance, you can order by <strong class="source-inline">CUSTOMER_NAME</strong> and limit the result to three JSONs as follows:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code">      key("customerName").value(CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">      key("creditLimit").value(CUSTOMER.CREDIT_LIMIT))</pre>
			<pre class="source-code">         .as("json_result"))</pre>
			<pre class="source-code">         .from(CUSTOMER)</pre>
			<pre class="source-code">   .orderBy(CUSTOMER.CUSTOMER_NAME).limit(3)</pre>
			<pre class="source-code">   .fetchInto(String.class);</pre>
			<p>On the other hand, when the <a id="_idIndexMarker732"/>aggregation operators (<strong class="source-inline">jsonArrayAgg()</strong> and <strong class="source-inline">jsonObjectAgg()</strong>) are involved, limiting should be done before the aggregation (for instance, in a subquery, <strong class="source-inline">JOIN</strong>, and more). Otherwise, this operation will be applied to the resulted aggregation itself, not to the aggregated data. During aggregation, ordering can be done before limiting, respectively. For instance, in the following example, the subquery orders the customers by <strong class="source-inline">CUSTOMER_NAME</strong> and limits the<a id="_idIndexMarker733"/> returned result to 3, while the aggregation orders this result by <strong class="source-inline">CREDIT_LIMIT</strong>:</p>
			<pre class="source-code">String result = ctx.select(jsonArrayAgg(jsonObject(</pre>
			<pre class="source-code">      jsonEntry("customerName", field("customer_name")),</pre>
			<pre class="source-code">      jsonEntry("creditLimit", field("credit_limit"))))</pre>
			<pre class="source-code">        .orderBy(field("credit_limit")).as("json_result"))</pre>
			<pre class="source-code">   .from(select(CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">     .from(CUSTOMER).orderBy(CUSTOMER.CUSTOMER_NAME).limit(3))</pre>
			<pre class="source-code">   .fetchSingleInto(String.class); </pre>
			<p>The resulting aggregation is ordered by <strong class="source-inline">CREDIT_LIMIT</strong>:</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  {"creditLimit": 0,"customerName": "American Souvenirs Inc"},</pre>
			<pre class="source-code">  {"creditLimit": 61100,"customerName": "Alpha Cognac"},</pre>
			<pre class="source-code">  {"creditLimit": 113000,"customerName": "Amica Models &amp; Co."}</pre>
			<pre class="source-code">]</pre>
			<p>More examples are available in the bundled code for <em class="italic">SimpleJson</em>. Note that, in the applications that uses PostgreSQL and Oracle, you can see the SQL standard's <strong class="source-inline">NULL ON NULL</strong> (<strong class="source-inline">nonOnNull()</strong>) and <strong class="source-inline">ABSENT ON NULL</strong> (<strong class="source-inline">absentOnNull()</strong>) syntax at work. For now, let's query documents with the JSON path.</p>
			<h3>Querying JSON documents with the JSON path</h3>
			<p>Via <strong class="source-inline">JSON_EXISTS</strong> and <strong class="source-inline">JSON_VALUE</strong>, we can query and construct JSON documents that rely on the JSON path. In <a id="_idIndexMarker734"/>order to practice jOOQ's <strong class="source-inline">jsonExists()</strong> and <strong class="source-inline">jsonValue()</strong> queries, let's consider the <strong class="source-inline">MANAGER.MANAGER_DETAIL</strong> field, which stores data in JSON format. Please take a quick look at this JSON so that you can become familiar with its structure and content.</p>
			<p>Now, selecting the <strong class="source-inline">MANAGER.MANAGER_ID</strong> and <strong class="source-inline">MANAGER.MANAGER_NAME</strong> fields of the managers that are also shareholders(with the <strong class="source-inline">"shareholder"</strong> key in JSON) can be done via <strong class="source-inline">jsonExists()</strong> and the JSON path, as follows:</p>
			<pre class="source-code">Result&lt;Record2&lt;Long, String&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">        MANAGER.MANAGER_ID, MANAGER.MANAGER_NAME)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .where(jsonExists(MANAGER.MANAGER_DETAIL, "$.shareholder"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>If the fetched JSON is constructed from JSON values, then we should rely on <strong class="source-inline">jsonValue()</strong> and the JSON path. For instance, fetching the cities of all managers can be done like this:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">     jsonValue(MANAGER.MANAGER_DETAIL, "$.address.city")</pre>
			<pre class="source-code">        .as("city"))</pre>
			<pre class="source-code">  .from(MANAGER).fetch();</pre>
			<p>Combining <strong class="source-inline">jsonExists()</strong> and <strong class="source-inline">jsonValue()</strong> allows us to query and construct JSON results from JSON documents. For instance, in PostgreSQL and Oracle, we can select the emails of the managers that had the role of <em class="italic">Principal Manager</em> by exploiting the JSON path:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">     jsonValue(MANAGER.MANAGER_DETAIL, "$.email").as("email"))</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .where(jsonExists(MANAGER.MANAGER_DETAIL, </pre>
			<pre class="source-code">     "$[*] ? (@.projects[*].role == \"Principal Manager\")"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>More examples are available<a id="_idIndexMarker735"/> in the bundled code, <em class="italic">SimpleJson</em>. Next, let's tackle <strong class="source-inline">JSON_TABLE</strong>.</p>
			<h3>Transforming JSON values into SQL tables</h3>
			<p>Transforming JSON values into <a id="_idIndexMarker736"/>SQL tables can be done via the <strong class="source-inline">JSON_TABLE</strong> operator, which, in<a id="_idIndexMarker737"/> jOOQ, is equivalent to the <strong class="source-inline">jsonTable()</strong> method. For instance, let's build a SQL table containing all projects of the development type via the <strong class="source-inline">jsonTable(Field&lt;JSON&gt; json, Field&lt;String&gt; path)</strong> flavor:</p>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.select(table("t").asterisk())</pre>
			<pre class="source-code">   .from(MANAGER, jsonTable(MANAGER.MANAGER_DETAIL, </pre>
			<pre class="source-code">                            val("$.projects[*]"))</pre>
			<pre class="source-code">   .column("id").forOrdinality()</pre>
			<pre class="source-code">   .column("name", VARCHAR).column("start", DATE)</pre>
			<pre class="source-code">   .column("end", DATE).column("type", VARCHAR)</pre>
			<pre class="source-code">   .column("role", VARCHAR).column("details", VARCHAR).as("t"))</pre>
			<pre class="source-code">   .where(field("type").eq("development")).fetch();</pre>
			<p>This query will produce a table, as follows:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B16833_Figure_8.2.jpg" alt="Figure 8.2 – The result of the previous query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The result of the previous query</p>
			<p>Once you fetch a SQL table, you can think and act on it in the same way as any other database table. For <a id="_idIndexMarker738"/>brevity, I simply used <strong class="source-inline">VARCHAR</strong>, but it is better to <a id="_idIndexMarker739"/>specify a size in order to avoid defaulting to <strong class="source-inline">VARCHAR(max)</strong>.</p>
			<p>More examples, including how to use <strong class="source-inline">JSON_TABLE</strong> with aggregates, <strong class="source-inline">ORDER BY</strong>, <strong class="source-inline">LIMIT</strong>, and how to transform back into JSON from a SQL table, are available in the bundled code, <em class="italic">SimpleJson</em>.</p>
			<h3>Handling relationships via SQL/JSON</h3>
			<p>The well-known <a id="_idIndexMarker740"/>one-to-one, one-to-many, and many-to-many relationships can be easily<a id="_idIndexMarker741"/> shaped via SQL/JSON support. </p>
			<h4>Mapping relationships to JSON</h4>
			<p>So, if by any chance you <a id="_idIndexMarker742"/>had a feeling that there is a shortcoming<a id="_idIndexMarker743"/> in jOOQ regarding mapping relationships, then you'll be very happy to see that a one-to-many relationship <a id="_idIndexMarker744"/>can be easily fetched directly into JSON as follows (in this case, we're looking at the relationship between <strong class="source-inline">PRODUCTLINE</strong> and <strong class="source-inline">PRODUCT</strong>):</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code">  key("productLine").value(PRODUCTLINE.PRODUCT_LINE),</pre>
			<pre class="source-code">  key("textDescription").value(PRODUCTLINE.TEXT_DESCRIPTION),</pre>
			<pre class="source-code">  key("products").value(select(jsonArrayAgg(</pre>
			<pre class="source-code">    jsonObject(key("productName").value(PRODUCT.PRODUCT_NAME),</pre>
			<pre class="source-code">     key("productVendor").value(PRODUCT.PRODUCT_VENDOR),</pre>
			<pre class="source-code">     key("quantityInStock").value(PRODUCT.QUANTITY_IN_STOCK)))   </pre>
			<pre class="source-code">    .orderBy(PRODUCT.QUANTITY_IN_STOCK))</pre>
			<pre class="source-code">    .from(PRODUCT)</pre>
			<pre class="source-code">    .where(PRODUCTLINE.PRODUCT_LINE</pre>
			<pre class="source-code">      .eq(PRODUCT.PRODUCT_LINE)))))</pre>
			<pre class="source-code">      .from(PRODUCTLINE).orderBy(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">      .fetch();</pre>
			<p>As you can infer from the <a id="_idIndexMarker745"/>preceding code, expressing the one-to-one and <a id="_idIndexMarker746"/>many-to-many relationships is just a matter of juggling with the SQL/JSON operators. You can find these examples, including how to use <strong class="source-inline">JOIN</strong> instead of a <strong class="source-inline">SELECT</strong> subquery, in the bundled code for <em class="italic">JsonRelationships</em>. </p>
			<p>If you think that <strong class="source-inline">Result&lt;Record1&lt;JSON&gt;&gt;</strong> is not ready to be sent to the client (for instance, via a REST controller), then decorate it a little bit more by aggregating all the product lines under a JSON array and relying on <strong class="source-inline">fetchSingleInto()</strong>:</p>
			<pre class="source-code">String result = ctx.select(</pre>
			<pre class="source-code">   jsonArrayAgg(jsonObject(…))</pre>
			<pre class="source-code">   …  </pre>
			<pre class="source-code">   .orderBy(PRODUCTLINE.PRODUCT_LINE))</pre>
			<pre class="source-code">   .from(PRODUCTLINE).fetchSingleInto(String.class);</pre>
			<p>In SQL Server, we can obtain a <a id="_idIndexMarker747"/>similar result via <strong class="source-inline">forJson()</strong>:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select( </pre>
			<pre class="source-code"> PRODUCTLINE.PRODUCT_LINE.as("productLine"),  </pre>
			<pre class="source-code"> PRODUCTLINE.TEXT_DESCRIPTION.as("textDescription"),</pre>
			<pre class="source-code"> select(PRODUCT.PRODUCT_NAME.as("productName"), </pre>
			<pre class="source-code">  PRODUCT.PRODUCT_VENDOR.as("productVendor"), </pre>
			<pre class="source-code">  PRODUCT.QUANTITY_IN_STOCK.as("quantityInStock"))</pre>
			<pre class="source-code"> .from(PRODUCT)</pre>
			<pre class="source-code"> .where(PRODUCT.PRODUCT_LINE.eq(PRODUCTLINE.PRODUCT_LINE))</pre>
			<pre class="source-code"> .orderBy(PRODUCT.QUANTITY_IN_STOCK)                        </pre>
			<pre class="source-code"> .forJSON().path().asField("products"))</pre>
			<pre class="source-code">  .from(PRODUCTLINE)</pre>
			<pre class="source-code">  .orderBy(PRODUCTLINE.PRODUCT_LINE).forJSON().path().fetch();</pre>
			<p>Or we can obtain<a id="_idIndexMarker748"/> a <strong class="source-inline">String</strong> via <strong class="source-inline">formatJSON(JSONformat)</strong>:</p>
			<pre class="source-code">String result = ctx.select(</pre>
			<pre class="source-code">  PRODUCTLINE.PRODUCT_LINE.as("productLine"),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  .forJSON().path()</pre>
			<pre class="source-code">  .fetch()</pre>
			<pre class="source-code">  .formatJSON(JSONFormat.DEFAULT_FOR_RECORDS);    </pre>
			<p>Both examples will produce a JSON, as follows (as you can see, altering the default JSON keys inferred from the field <a id="_idIndexMarker749"/>names can be done with aliases via <strong class="source-inline">as("alias")</strong>):</p>
			<pre class="source-code">[</pre>
			<pre class="source-code">  {</pre>
			<pre class="source-code">    "productLine": "Classic Cars",</pre>
			<pre class="source-code">    "textDescription": "Attention car enthusiasts...",</pre>
			<pre class="source-code">    "products": [</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">        "productName": "1968 Ford Mustang",</pre>
			<pre class="source-code">        "productVendor": "Autoart Studio Design",</pre>
			<pre class="source-code">        "quantityInStock": 68</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">        "productName": "1970 Chevy Chevelle SS 454",</pre>
			<pre class="source-code">        "productVendor": "Unimax Art Galleries",</pre>
			<pre class="source-code">        "quantityInStock": 1005</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">    ]</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  {</pre>
			<pre class="source-code">    "productLine": "Motorcycles", ...</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">]</pre>
			<p>In the bundled <a id="_idIndexMarker750"/>code for <em class="italic">JsonRelationships</em>, you can find a lot of examples to do with one-to-one, one-to-many, and many-to-many relationships. Moreover, you can check out several examples of how to map arrays and UDTs into JSON.</p>
			<h4>Mapping JSON relationships to POJOs</h4>
			<p>As you just saw, jOOQ can<a id="_idIndexMarker751"/> fetch and map a relationship <a id="_idIndexMarker752"/>directly into JSON. However, that's not all! jOOQ can go even further and map the resulted JSON to the domain model (POJOs). Yes, you read that right; as long as we have Gson, Jackson (Spring Boot has this by default), or JAXB in the classpath, jOOQ can automatically map the query results to our nested data structures. This is quite useful when you don't actually need the JSON itself – you can just rely on JSON to facilitate the nesting data structures and map them back to Java. For instance, let's assume the following domain model:</p>
			<pre class="source-code">public class SimpleProductLine {</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    private String productLine;</pre>
			<pre class="source-code">    private String textDescription;   </pre>
			<pre class="source-code">    private List&lt;SimpleProduct&gt; products;    </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class SimpleProduct {</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    private String productName;</pre>
			<pre class="source-code">    private String productVendor;</pre>
			<pre class="source-code">    private Short quantityInStock;</pre>
			<pre class="source-code">}</pre>
			<p>Can we populate this<a id="_idIndexMarker753"/> model from jOOQ <strong class="source-inline">Result</strong> by just using jOOQ? Yes, we<a id="_idIndexMarker754"/> can do it via SQL/JSON support, as follows:</p>
			<pre class="source-code">List&lt;SimpleProductLine&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code">   key("productLine").value(PRODUCTLINE.PRODUCT_LINE),</pre>
			<pre class="source-code">   key("textDescription").value(PRODUCTLINE.TEXT_DESCRIPTION),</pre>
			<pre class="source-code">   key("products").value(select(jsonArrayAgg(jsonObject(</pre>
			<pre class="source-code">     key("productName").value(PRODUCT.PRODUCT_NAME),        </pre>
			<pre class="source-code">     key("productVendor").value(PRODUCT.PRODUCT_VENDOR),</pre>
			<pre class="source-code">     key("quantityInStock").value(PRODUCT.QUANTITY_IN_STOCK)))</pre>
			<pre class="source-code">       .orderBy(PRODUCT.QUANTITY_IN_STOCK)).from(PRODUCT)</pre>
			<pre class="source-code">       .where(PRODUCTLINE.PRODUCT_LINE</pre>
			<pre class="source-code">          .eq(PRODUCT.PRODUCT_LINE)))))</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .orderBy(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">   .fetchInto(SimpleProductLine.class);</pre>
			<p>That's so cool, right?! The same<a id="_idIndexMarker755"/> thing can be accomplished for one-to-one and many-to-many relationships, as you can see in the bundled code. All examples <a id="_idIndexMarker756"/>are available in <em class="italic">JsonRelationshipsInto</em>. </p>
			<h4>Mapping arbitrary models</h4>
			<p>If you think that what<a id="_idIndexMarker757"/> you've just seen is impressive, then get ready for more because jOOQ can fetch and map almost any kind of arbitrary model, not just the well-known 1:1,1:n, and n:n relationships. Let's consider the following three arbitrary models:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B16833_Figure_8.3.jpg" alt="Figure 8.3 – Arbitrary domain models&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Arbitrary domain models</p>
			<p>Which one do you choose to be exemplified in the book? The second one (<strong class="bold">Model 2</strong>), of course! So, our goal is to write a query <a id="_idIndexMarker758"/>that returns a JSON that mirrors this model. For this, we rely on <strong class="source-inline">jsonObject()</strong> and <strong class="source-inline">jsonArrayAgg()</strong>, as follows:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(jsonObject(</pre>
			<pre class="source-code"> jsonEntry("customerName", CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code"> jsonEntry("creditLimit", CUSTOMER.CREDIT_LIMIT),</pre>
			<pre class="source-code"> jsonEntry("payments", select(jsonArrayAgg(jsonObject(</pre>
			<pre class="source-code">  jsonEntry("customerNumber", PAYMENT.CUSTOMER_NUMBER),</pre>
			<pre class="source-code">  jsonEntry("invoiceAmount", PAYMENT.INVOICE_AMOUNT),</pre>
			<pre class="source-code">  jsonEntry("cachingDate", PAYMENT.CACHING_DATE),</pre>
			<pre class="source-code">  jsonEntry("transactions", select(jsonArrayAgg(jsonObject(</pre>
			<pre class="source-code">    jsonEntry("bankName", BANK_TRANSACTION.BANK_NAME),</pre>
			<pre class="source-code">    jsonEntry("transferAmount", </pre>
			<pre class="source-code">              BANK_TRANSACTION.TRANSFER_AMOUNT)))</pre>
			<pre class="source-code">    .orderBy(BANK_TRANSACTION.TRANSFER_AMOUNT))</pre>
			<pre class="source-code">    .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">    .where(BANK_TRANSACTION.CUSTOMER_NUMBER</pre>
			<pre class="source-code">      .eq(PAYMENT.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">       .and(BANK_TRANSACTION.CHECK_NUMBER</pre>
			<pre class="source-code">         .eq(PAYMENT.CHECK_NUMBER))))))</pre>
			<pre class="source-code">    .orderBy(PAYMENT.CACHING_DATE))</pre>
			<pre class="source-code">    .from(PAYMENT)</pre>
			<pre class="source-code">    .where(PAYMENT.CUSTOMER_NUMBER</pre>
			<pre class="source-code">      .eq(CUSTOMER.CUSTOMER_NUMBER))),</pre>
			<pre class="source-code">  jsonEntry("details", select(</pre>
			<pre class="source-code">   jsonObject(jsonEntry("city", CUSTOMERDETAIL.CITY),</pre>
			<pre class="source-code">    jsonEntry("addressLineFirst",</pre>
			<pre class="source-code">          CUSTOMERDETAIL.ADDRESS_LINE_FIRST),</pre>
			<pre class="source-code">    jsonEntry("state", CUSTOMERDETAIL.STATE)))</pre>
			<pre class="source-code">   .from(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .where(CUSTOMERDETAIL.CUSTOMER_NUMBER</pre>
			<pre class="source-code">    .eq(CUSTOMER.CUSTOMER_NUMBER)))))</pre>
			<pre class="source-code">   .from(CUSTOMER).orderBy(CUSTOMER.CREDIT_LIMIT).fetch();</pre>
			<p>Lukas Eder states that: </p>
			<p><em class="italic">"What I always like to mention in this regard is that there are no accidental Cartesian Products or costly de-duplication</em><em class="italic"><a id="_idIndexMarker759"/></em><em class="italic"> going on (as with JPA), because all the data is already nested correctly in SQL, and transferred optimally. This approach should be the first choice when nesting collections with SQL or producing JSON/XML for some frontend. Never use ordinary joins, which should be used only for flat results or aggregations."</em></p>
			<p>Take your time to dissect this query and check out the bundled code to see the output. Moreover, in the bundled code, you can practice <strong class="bold">Model 1</strong> and <strong class="bold">Model 3</strong>, too. For each of these models, you have the JSON result and the corresponding mapping to POJOs. The application is named <em class="italic">NestedJson</em>.</p>
			<p>I'm sure that, as a SQL Server fan, you are impatient to see the version of the previous query expressed via <strong class="source-inline">forJson()</strong>, so here it is:</p>
			<pre class="source-code">Result&lt;Record1&lt;JSON&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code"> CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT,</pre>
			<pre class="source-code"> select(PAYMENT.CUSTOMER_NUMBER, PAYMENT.INVOICE_AMOUNT, </pre>
			<pre class="source-code">  PAYMENT.CACHING_DATE,</pre>
			<pre class="source-code">   select(BANK_TRANSACTION.BANK_NAME,   </pre>
			<pre class="source-code">          BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">   .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .where(BANK_TRANSACTION.CUSTOMER_NUMBER</pre>
			<pre class="source-code">     .eq(PAYMENT.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">     .and(BANK_TRANSACTION.CHECK_NUMBER</pre>
			<pre class="source-code">       .eq(PAYMENT.CHECK_NUMBER)))</pre>
			<pre class="source-code">   .orderBy(BANK_TRANSACTION.TRANSFER_AMOUNT)                 </pre>
			<pre class="source-code">   .forJSON().path().asField("transactions")).from(PAYMENT)</pre>
			<pre class="source-code"> .where(PAYMENT.CUSTOMER_NUMBER</pre>
			<pre class="source-code">   .eq(CUSTOMER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code"> .orderBy(PAYMENT.CACHING_DATE)                       </pre>
			<pre class="source-code"> .forJSON().path().asField("payments"),</pre>
			<pre class="source-code"> select(CUSTOMERDETAIL.CITY,   </pre>
			<pre class="source-code">  CUSTOMERDETAIL.ADDRESS_LINE_FIRST,CUSTOMERDETAIL.STATE)</pre>
			<pre class="source-code"> .from(CUSTOMERDETAIL)</pre>
			<pre class="source-code">  .where(CUSTOMERDETAIL.CUSTOMER_NUMBER</pre>
			<pre class="source-code">   .eq(CUSTOMER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code"> .forJSON().path().asField("details")).from(CUSTOMER)</pre>
			<pre class="source-code"> .orderBy(CUSTOMER.CREDIT_LIMIT).forJSON().path().fetch();</pre>
			<p>Of course, you can check out these <a id="_idIndexMarker760"/>examples in the bundled code next to the examples for <strong class="bold">Model 1</strong> and <strong class="bold">Model 3</strong>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Next to SQL/JSON support, jOOQ also provides SQL/JSONB support. You can explicitly use JSONB via <strong class="source-inline">org.jooq.JSONB</strong> and the operators such as <strong class="source-inline">jsonbObject()</strong>, <strong class="source-inline">jsonbArrayAgg()</strong>, and <strong class="source-inline">jsonbTable()</strong>. </p>
			<p>Now, it is time to talk about SQL/XML support.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Handling SQL/XML support</h2>
			<p>In a nutshell, for SQL/XML, we can talk <a id="_idIndexMarker761"/>about the following operators that have a jOOQ implementation in the <strong class="source-inline">org.jooq.impl.DSL</strong> class:</p>
			<ul>
				<li><strong class="source-inline">XMLELEMENT</strong> (<strong class="source-inline">DSL.xmlelement()</strong>), <strong class="source-inline">XMLATTRIBUTES</strong> (<strong class="source-inline">DSL.xmlattributes()</strong>), <strong class="source-inline">XMLFOREST</strong> (<strong class="source-inline">DSL.xmlforest()</strong>), <strong class="source-inline">XMLCONCAT</strong> (<strong class="source-inline">DSL.xmlconcat()</strong>), and <strong class="source-inline">XMLCOMMENT</strong> (<strong class="source-inline">DSL.xmlcomment()</strong>) to construct XML data</li>
				<li><strong class="source-inline">XMLAGG</strong> (<strong class="source-inline">DSL.xmlagg()</strong>) to aggregate data into nested XML documents</li>
				<li><strong class="source-inline">XMLEXISTS</strong> (<strong class="source-inline">DSL.xmlexists()</strong>) and <strong class="source-inline">XMLQUERY</strong> (<strong class="source-inline">DSL.xmlquery()</strong>) to query XML documents with <strong class="source-inline">XPath</strong></li>
				<li><strong class="source-inline">XMLPARSE</strong> (<strong class="source-inline">DSL.xmlparseContent()</strong> and <strong class="source-inline">DSL.xmlparseDocument()</strong>) for parsing XML content and documents</li>
				<li><strong class="source-inline">XMLPI</strong> (<strong class="source-inline">DSL.xmlpi()</strong>) for producing XML processing instructions</li>
				<li><strong class="source-inline">XMLTABLE</strong> (<strong class="source-inline">DSL.xmltable()</strong>) to transform XML values into SQL tables</li>
			</ul>
			<p>SQL Server's <strong class="source-inline">FOR XML</strong> syntax (including <strong class="source-inline">ROOT</strong>, <strong class="source-inline">PATH</strong>, <strong class="source-inline">ELEMENTS</strong>, <strong class="source-inline">RAW</strong>, and <strong class="source-inline">AUTO</strong>, and <strong class="source-inline">EXPLICIT (jOOQ 3.17.x +)</strong>) – jOOQ's commercial editions emulate the <strong class="source-inline">FOR XML</strong> syntax for databases that don't support it (in this book, you <a id="_idIndexMarker762"/>can practice this for SQL Server and Oracle).</p>
			<p>Let's see some introductory examples of these operators via the jOOQ DSL API.</p>
			<h3>Constructing and aggregating XML data from values</h3>
			<p>A good start for constructing XML data from <a id="_idIndexMarker763"/>values relies on the <strong class="source-inline">XMLELEMENT</strong> operator. In jOOQ, <strong class="source-inline">XMLELEMENT</strong> is rendered via the <strong class="source-inline">xmlelement()</strong> method. For instance, the following snippet of code fetches the <strong class="source-inline">CUSTOMER_NAME</strong> field of each customer and uses it as the text of an XML element named <strong class="source-inline">&lt;name/&gt;</strong>:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">      xmlelement("name", CUSTOMER.CUSTOMER_NAME))</pre>
			<pre class="source-code">   .from(CUSTOMER).fetch();</pre>
			<p>The returned <strong class="source-inline">Result</strong> has a size that is equal to the number of fetched customers. Each <strong class="source-inline">Record1</strong> wraps an <strong class="source-inline">org.jooq.XML</strong> instance representing a <strong class="source-inline">&lt;name/&gt;</strong> element. If we just want to format this <strong class="source-inline">Result</strong> as an XML, we can call the <strong class="source-inline">formatXML()</strong> method (this will be presented in the next chapter). This will return a simple formatted representation such as the one here:</p>
			<pre class="source-code">&lt;result xmlns="http:…"&gt;</pre>
			<pre class="source-code">&lt;fields&gt;</pre>
			<pre class="source-code">  &lt;field name="xmlconcat" type="XML"/&gt;</pre>
			<pre class="source-code">&lt;/fields&gt;</pre>
			<pre class="source-code">&lt;records&gt;</pre>
			<pre class="source-code">  &lt;record xmlns="http:…"&gt;</pre>
			<pre class="source-code">    &lt;value field="xmlconcat"&gt;</pre>
			<pre class="source-code">      &lt;name&gt;Australian Home&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;/value&gt;</pre>
			<pre class="source-code">  &lt;/record&gt;</pre>
			<pre class="source-code">  &lt;record xmlns="http:…"&gt;</pre>
			<pre class="source-code">    &lt;value field="xmlconcat"&gt;</pre>
			<pre class="source-code">      &lt;name&gt;Joliyon&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;/value&gt;</pre>
			<pre class="source-code">  &lt;/record&gt;</pre>
			<pre class="source-code">…</pre>
			<p>However, this response is too verbose<a id="_idIndexMarker764"/> to send to the client. For instance, you might only need the <strong class="source-inline">"records"</strong> element. In such cases, we can rely on the <strong class="source-inline">formatXML(XMLFormat)</strong> flavor, as you'll see in the bundled code. Supposing that you want to just send the first <strong class="source-inline">&lt;name/&gt;</strong> element, you can extract it from the <strong class="source-inline">Result</strong> object as <strong class="source-inline">result.get(0).value1().data()</strong>:</p>
			<pre class="source-code">result.get(0) // 0-first &lt;name/&gt;, 1-second &lt;name/&gt; …</pre>
			<pre class="source-code">.value1()     // this is the value from Record1, a XML</pre>
			<pre class="source-code">.data()       // this is the data of the first XML as String</pre>
			<pre class="source-code">&lt;name&gt;Australian Home&lt;/name&gt;</pre>
			<p>However, perhaps you are planning to send all of these <strong class="source-inline">&lt;name/&gt;</strong> tags as a <strong class="source-inline">List&lt;String&gt;</strong> to the client. Then, rely<a id="_idIndexMarker765"/> on <strong class="source-inline">fetchInto(String.class)</strong> to return all the <strong class="source-inline">&lt;name/&gt;</strong> elements as a <strong class="source-inline">List&lt;String&gt;</strong>. Note that each <strong class="source-inline">String</strong> is a <strong class="source-inline">&lt;name/&gt;</strong>:</p>
			<pre class="source-code">List&lt;String&gt; result = ctx.select(</pre>
			<pre class="source-code">    xmlelement("name", CUSTOMER.CUSTOMER_NAME))</pre>
			<pre class="source-code">  .from(CUSTOMER).fetchInto(String.class);</pre>
			<p>Alternatively, it would be more practical to <a id="_idIndexMarker766"/>aggregate all these <strong class="source-inline">&lt;name/&gt;</strong> elements as a single <strong class="source-inline">String</strong>. This is possible via <strong class="source-inline">xmlagg()</strong>, which returns a single XML containing all of the fetched data (for convenience, let's aggregate everything under the <strong class="source-inline">&lt;names/&gt;</strong> tag):</p>
			<pre class="source-code">String result = ctx.select(xmlelement("names", xmlagg(</pre>
			<pre class="source-code">      xmlelement("name", CUSTOMER.CUSTOMER_NAME))))</pre>
			<pre class="source-code">  .from(CUSTOMER).fetchSingleInto(String.class);     </pre>
			<p>The aggregated XML is shown here:</p>
			<pre class="source-code">&lt;names&gt;</pre>
			<pre class="source-code">  &lt;name&gt;Australian Home&lt;/name&gt;</pre>
			<pre class="source-code">  &lt;name&gt;Joliyon&lt;/name&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">&lt;/names&gt;</pre>
			<p>What about adding attributes to the XML elements? This can be done via <strong class="source-inline">xmlattributes()</strong>, as shown in the following intuitive example:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(xmlelement("contact",</pre>
			<pre class="source-code">   xmlattributes(CUSTOMER.CONTACT_FIRST_NAME.as("firstName"),</pre>
			<pre class="source-code">   CUSTOMER.CONTACT_LAST_NAME.as("lastName"), CUSTOMER.PHONE)))</pre>
			<pre class="source-code"> .from(CUSTOMER).fetch();</pre>
			<p>The expected XML will look like this:</p>
			<pre class="source-code">&lt;contact firstName="Sart" </pre>
			<pre class="source-code">         lastName="Paoule" phone="40.11.2555"/&gt;</pre>
			<p>A relatively useful XML operator is <strong class="source-inline">xmlforest()</strong>. This operator converts its parameters into XML and <a id="_idIndexMarker767"/>returns an XML fragment obtained by the concatenation of these converted arguments. Here is an example:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select( </pre>
			<pre class="source-code">  xmlelement("allContacts", xmlagg(xmlelement("contact",</pre>
			<pre class="source-code">   xmlforest(CUSTOMER.CONTACT_FIRST_NAME.as("firstName"),</pre>
			<pre class="source-code">             CUSTOMER.CONTACT_LAST_NAME.as("lastName"),</pre>
			<pre class="source-code">             CUSTOMER.PHONE)))))</pre>
			<pre class="source-code"> .from(CUSTOMER).fetch();</pre>
			<p>The effect of <strong class="source-inline">xmlforest()</strong> can be seen in the resulting XML:</p>
			<pre class="source-code">&lt;allContacts&gt;</pre>
			<pre class="source-code">      &lt;contact&gt;</pre>
			<pre class="source-code">           &lt;firstName&gt;Sart&lt;/firstName&gt;</pre>
			<pre class="source-code">           &lt;lastName&gt;Paoule&lt;/lastName&gt;</pre>
			<pre class="source-code">           &lt;phone&gt;40.11.2555&lt;/phone&gt;</pre>
			<pre class="source-code">      &lt;/contact&gt;</pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">&lt;/allContacts&gt;</pre>
			<p>If you are a SQL Server fan, then you know that fetching data as XML can be done via the non-standard <strong class="source-inline">FOR XML</strong> syntax. jOOQ supports this syntax via the <strong class="source-inline">forXml()</strong> API. It also supports clauses such as <strong class="source-inline">ROOT</strong> via <strong class="source-inline">root()</strong>, <strong class="source-inline">PATH</strong> via <strong class="source-inline">path()</strong>, <strong class="source-inline">AUTO</strong> via <strong class="source-inline">auto()</strong>, <strong class="source-inline">RAW</strong> via <strong class="source-inline">raw()</strong>, and <strong class="source-inline">ELEMENTS</strong> via <strong class="source-inline">elements()</strong>, as you can see in the following example:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">         OFFICE.OFFICE_CODE, OFFICE.CITY, OFFICE.COUNTRY)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .forXML().path("office").elements().root("offices")</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The produced XML<a id="_idIndexMarker768"/> looks like this:</p>
			<pre class="source-code">&lt;offices&gt;</pre>
			<pre class="source-code">     &lt;office&gt;</pre>
			<pre class="source-code">           &lt;office_code&gt;1&lt;/office_code&gt;</pre>
			<pre class="source-code">           &lt;city&gt;San Francisco&lt;/city&gt;</pre>
			<pre class="source-code">           &lt;country&gt;USA&lt;/country&gt;</pre>
			<pre class="source-code">     &lt;/office&gt;</pre>
			<pre class="source-code">     &lt;office&gt;</pre>
			<pre class="source-code">           &lt;office_code&gt;10&lt;/office_code&gt;</pre>
			<pre class="source-code">     &lt;/office&gt;</pre>
			<pre class="source-code">     &lt;office&gt;</pre>
			<pre class="source-code">           &lt;office_code&gt;11&lt;/office_code&gt;</pre>
			<pre class="source-code">           &lt;city&gt;Paris&lt;/city&gt;</pre>
			<pre class="source-code">           &lt;country&gt;France&lt;/country&gt;</pre>
			<pre class="source-code">     &lt;/office&gt;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">&lt;/offices&gt;</pre>
			<p>Note that missing tags (check the second <strong class="source-inline">&lt;office/&gt;</strong> instance, which does not have <strong class="source-inline">&lt;city/&gt;</strong> or <strong class="source-inline">&lt;country/&gt;</strong>) represent missing data. </p>
			<p>As a side note, allow me to mention that jOOQ can also transform XML into an <strong class="source-inline">org.w3c.dom.Document</strong> by calling a flavor of <strong class="source-inline">intoXML()</strong> on <strong class="source-inline">Record1&lt;XML&gt;</strong>. Moreover, you'll love jOOX, or object-oriented XML (<a href="https://github.com/jOOQ/jOOX">https://github.com/jOOQ/jOOX</a>), which can be used to XSL<a id="_idIndexMarker769"/> transform or navigate the resulting XML document in a jQuery style.</p>
			<p>I totally agree (sharing his enthusiasm) with Lukas Eder, who states: </p>
			<p><em class="italic">"I don't know about you, but when I see these examples, I just want to write a huge application using jOOQ :) I mean, how else would anyone ever want to query databases and produce JSON or XML documents??"</em></p>
			<p>You can see these examples (alongside many others) in the bundled code for <em class="italic">SimpleXml</em> and get familiar with the produced XMLs. For now, let's talk about how to order and limit the content of the resulting XML.</p>
			<h3>Using ORDER BY and LIMIT</h3>
			<p>When we don't use the <strong class="source-inline">xmlagg()</strong> aggregation operator, ordering and limiting is the same as for regular<a id="_idIndexMarker770"/> queries. For instance, you can order by <strong class="source-inline">CUSTOMER_NAME</strong> and limit the result to three XMLs as follows:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">    xmlelement("name", CUSTOMER.CUSTOMER_NAME))</pre>
			<pre class="source-code"> .from(CUSTOMER)</pre>
			<pre class="source-code"> .orderBy(CUSTOMER.CUSTOMER_NAME).limit(3).fetch();</pre>
			<p>On the other hand, when the <strong class="source-inline">xmlagg()</strong> aggregation operator is used, then limiting should be done before the aggregation (for instance, in a subquery, <strong class="source-inline">JOIN</strong>, and more). Otherwise, this operation will be <a id="_idIndexMarker771"/>applied to the resulting aggregation itself. During aggregation, ordering can be done before limiting, respectively. For instance, in the following example, the subquery orders the customers by <strong class="source-inline">CONTACT_LAST_NAME</strong> and limits the returned results to 3, while the aggregation orders this result by <strong class="source-inline">CONTACT_FIRST_NAME</strong>:</p>
			<pre class="source-code">String result = ctx.select(xmlelement("allContacts",  </pre>
			<pre class="source-code"> xmlagg(xmlelement("contact",</pre>
			<pre class="source-code">   xmlforest(field("contact_first_name").as("firstName"),</pre>
			<pre class="source-code">    field("contact_last_name").as("lastName"),field("phone"))))</pre>
			<pre class="source-code"> .orderBy(field("contact_first_name"))))</pre>
			<pre class="source-code"> .from(select(CUSTOMER.CONTACT_FIRST_NAME, </pre>
			<pre class="source-code">              CUSTOMER.CONTACT_LAST_NAME, CUSTOMER.PHONE)</pre>
			<pre class="source-code"> .from(CUSTOMER).orderBy(CUSTOMER.CONTACT_LAST_NAME).limit(3))</pre>
			<pre class="source-code"> .fetchSingleInto(String.class);</pre>
			<p>The resulted aggregation is<a id="_idIndexMarker772"/> ordered by <strong class="source-inline">CUSTOMER_FIRST_NAME</strong>:</p>
			<pre class="source-code">&lt;allContacts&gt;</pre>
			<pre class="source-code">     &lt;contact&gt;</pre>
			<pre class="source-code">           &lt;firstName&gt;Mel&lt;/firstName&gt;</pre>
			<pre class="source-code">           &lt;lastName&gt;Andersen&lt;/lastName&gt;</pre>
			<pre class="source-code">           &lt;phone&gt;030-0074555&lt;/phone&gt;</pre>
			<pre class="source-code">     &lt;/contact&gt;</pre>
			<pre class="source-code">     &lt;contact&gt;</pre>
			<pre class="source-code">           &lt;firstName&gt;Paolo&lt;/firstName&gt;</pre>
			<pre class="source-code">           &lt;lastName&gt;Accorti&lt;/lastName&gt;</pre>
			<pre class="source-code">           &lt;phone&gt;011-4988555&lt;/phone&gt;</pre>
			<pre class="source-code">     &lt;/contact&gt;</pre>
			<pre class="source-code">     &lt;contact&gt;</pre>
			<pre class="source-code">           &lt;firstName&gt;Raanan&lt;/firstName&gt;</pre>
			<pre class="source-code">           &lt;lastName&gt;Altagar,G M&lt;/lastName&gt;</pre>
			<pre class="source-code">           &lt;phone&gt;+ 972 9 959 8555&lt;/phone&gt;</pre>
			<pre class="source-code">     &lt;/contact&gt;</pre>
			<pre class="source-code">&lt;/allContacts&gt;</pre>
			<p>More examples are available in the bundle code for <em class="italic">SimpleXml</em>. For now, let's learn how to query XML documents with XPath.</p>
			<h3>Querying XML documents with XPath</h3>
			<p>Querying XML documents <a id="_idIndexMarker773"/>can be done via the XPath expressions, and we can distinguish between queries that check for the existence of an<a id="_idIndexMarker774"/> element/attribute via <strong class="source-inline">XMLEXISTS</strong> (<strong class="source-inline">xmlexists()</strong>) and queries that fetches certain data from an XML document via <strong class="source-inline">XMLQUERY</strong> (<strong class="source-inline">xmlquery()</strong>). For instance, in <strong class="source-inline">PRODUCTLINE</strong>, we have a field named <strong class="source-inline">HTML_DESCRIPTION</strong> that holds the description of a product line in XML format. If a product line has a description, then this description starts with the <strong class="source-inline">&lt;productline/&gt;</strong> tag. So, fetching all product lines that have a description can be done via <strong class="source-inline">xmlexists()</strong>, as follows:</p>
			<pre class="source-code">Result&lt;Record1&lt;String&gt;&gt; result = </pre>
			<pre class="source-code">   ctx.select(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">      .from(PRODUCTLINE)</pre>
			<pre class="source-code">      .where(xmlexists("/productline")</pre>
			<pre class="source-code">      .passing(PRODUCTLINE.HTML_DESCRIPTION)).fetch();</pre>
			<p>In <strong class="source-inline">xmlexists("/productline").passing(…)</strong>,<strong class="source-inline">/productline</strong> represents the XPath that should be searched, and the argument of the <strong class="source-inline">passing()</strong> method represents the XML document (or fragment) in which this XPath is searched.</p>
			<p>On the other hand, the following snippet of code relies on <strong class="source-inline">xmlquery()</strong> to fetch an XML containing certain data from <strong class="source-inline">HTML_DESCRIPTION</strong>:</p>
			<pre class="source-code">String result = ctx.select(xmlagg(</pre>
			<pre class="source-code">   xmlquery("productline/capacity/c[position()=last()]")</pre>
			<pre class="source-code">     .passing(PRODUCTLINE.HTML_DESCRIPTION)))</pre>
			<pre class="source-code">     .from(PRODUCTLINE).fetchSingleInto(String.class);</pre>
			<p>Of course, the argument of <strong class="source-inline">passing()</strong> can be an XML build from certain fields, too:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">    xmlquery("//contact/phone").passing(</pre>
			<pre class="source-code">    xmlelement("allContacts", xmlagg(xmlelement("contact",</pre>
			<pre class="source-code">    xmlforest(CUSTOMER.CONTACT_FIRST_NAME.as("firstName"),</pre>
			<pre class="source-code">              CUSTOMER.CONTACT_LAST_NAME.as("lastName"),</pre>
			<pre class="source-code">              CUSTOMER.PHONE))))))</pre>
			<pre class="source-code">  .from(CUSTOMER).fetch();</pre>
			<p>This query fetches all the <strong class="source-inline">&lt;phone/&gt;</strong> tags from the<a id="_idIndexMarker775"/> given XML (for instance, <strong class="source-inline">&lt;phone&gt;(26) 642-7555&lt;/phone&gt;</strong>). More examples are available in <em class="italic">SimpleXml</em>. Next, let's<a id="_idIndexMarker776"/> tackle <strong class="source-inline">XMLTABLE</strong>.</p>
			<h3>Transforming XML values into SQL tables</h3>
			<p>Transforming XML values<a id="_idIndexMarker777"/> into SQL tables can be done via the <strong class="source-inline">XMLTABLE</strong> operator, which, in jOOQ, is equivalent to <strong class="source-inline">xmltable()</strong>. For<a id="_idIndexMarker778"/> instance, let's build a SQL table containing the details of each product line extracted from <strong class="source-inline">HTML_DESCRIPTION</strong>:</p>
			<pre class="source-code">Result&lt;Record&gt; result = ctx.select(table("t").asterisk())</pre>
			<pre class="source-code">   .from(PRODUCTLINE, xmltable("//productline/details")</pre>
			<pre class="source-code">     .passing(PRODUCTLINE.HTML_DESCRIPTION)</pre>
			<pre class="source-code">     .column("id").forOrdinality()</pre>
			<pre class="source-code">     .column("power", VARCHAR)</pre>
			<pre class="source-code">     .column("type", VARCHAR)</pre>
			<pre class="source-code">     .column("nr_of_lines", INTEGER).path("type/@nr_of_lines")</pre>
			<pre class="source-code">     .column("command", VARCHAR).path("type/@command")</pre>
			<pre class="source-code">     .as("t")).fetch();</pre>
			<p>This query will produce a table as follows:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B16833_Figure_8.4.jpg" alt="Figure 8.4 – The result of the previous query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The result of the previous query</p>
			<p>Once you fetch a SQL table, you can think and act on it in the same way as any other database table. For<a id="_idIndexMarker779"/> brevity, I simply used <strong class="source-inline">VARCHAR</strong>, but it is better to specify a size in order to avoid <a id="_idIndexMarker780"/>defaulting to <strong class="source-inline">VARCHAR(max)</strong>.</p>
			<p>More examples, including how to use <strong class="source-inline">XMLTABLE</strong> with aggregates, <strong class="source-inline">ORDER BY</strong>, <strong class="source-inline">LIMIT</strong>, and how to transform back into XML from a SQL table, are available in <em class="italic">SimpleXml</em>.</p>
			<h3>Handling relationships via SQL/XML</h3>
			<p>Handling the typical 1:1, 1:n, and n:n relationships can<a id="_idIndexMarker781"/> be done <a id="_idIndexMarker782"/>via jOOQ SQL/XML support. Let's go through a quick rundown of it. </p>
			<h4>Mapping relationships to XML</h4>
			<p>Most of the time, such relationships <a id="_idIndexMarker783"/>can be materialized into XML via a thoughtful combination of <strong class="source-inline">xmlelement()</strong>, <strong class="source-inline">xmlagg()</strong>, and <strong class="source-inline">xmlforest()</strong>. Since you are already<a id="_idIndexMarker784"/> familiar with the one-to-many relationship between <strong class="source-inline">PRODUCTLINE</strong> and <strong class="source-inline">PRODUCT</strong>, let's shape it into XML via SQL/XML support:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code">  xmlelement("productLine",</pre>
			<pre class="source-code">  xmlelement("productLine", PRODUCTLINE.PRODUCT_LINE),</pre>
			<pre class="source-code">  xmlelement("textDescription", PRODUCTLINE.TEXT_DESCRIPTION),</pre>
			<pre class="source-code">  xmlelement("products", field(select(xmlagg(</pre>
			<pre class="source-code">  xmlelement("product", xmlforest(</pre>
			<pre class="source-code">   PRODUCT.PRODUCT_NAME.as("productName"),</pre>
			<pre class="source-code">   PRODUCT.PRODUCT_VENDOR.as("productVendor"),</pre>
			<pre class="source-code">   PRODUCT.QUANTITY_IN_STOCK.as("quantityInStock")))))</pre>
			<pre class="source-code"> .from(PRODUCT)</pre>
			<pre class="source-code"> .where(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))))))</pre>
			<pre class="source-code"> .from(PRODUCTLINE)</pre>
			<pre class="source-code"> .orderBy(PRODUCTLINE.PRODUCT_LINE).fetch();  </pre>
			<p>As you can infer from the preceding code, expressing the one-to-one and many-to-many relationships is just a matter<a id="_idIndexMarker785"/> of juggling with the SQL/XML operators. You can find these examples, including how to use <strong class="source-inline">JOIN</strong> instead of a <strong class="source-inline">SELECT</strong> subquery, in the bundled code for <em class="italic">XmlRelationships</em>.</p>
			<p>If you think that <strong class="source-inline">Result&lt;Record1&lt;XML&gt;&gt;</strong> is not ready to be sent to the client (for instance, via a REST controller), then<a id="_idIndexMarker786"/> decorate it a little bit more by aggregating all the product lines under a XML element (root) and relying on <strong class="source-inline">fetchSingleInto()</strong>, as follows:</p>
			<pre class="source-code">String result = ctx.select(</pre>
			<pre class="source-code">  xmlelement("productlines", xmlagg(</pre>
			<pre class="source-code">  xmlelement("productLine",</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code"> .from(PRODUCTLINE).fetchSingleInto(String.class);</pre>
			<p>In SQL Server, we can obtain a similar result via <strong class="source-inline">forXml()</strong>:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select( </pre>
			<pre class="source-code">  PRODUCTLINE.PRODUCT_LINE.as("productLine"),</pre>
			<pre class="source-code">  PRODUCTLINE.TEXT_DESCRIPTION.as("textDescription"),</pre>
			<pre class="source-code">  select(PRODUCT.PRODUCT_NAME.as("productName"),</pre>
			<pre class="source-code">    PRODUCT.PRODUCT_VENDOR.as("productVendor"),</pre>
			<pre class="source-code">    PRODUCT.QUANTITY_IN_STOCK.as("quantityInStock"))     </pre>
			<pre class="source-code">     .from(PRODUCT)</pre>
			<pre class="source-code">     .where(PRODUCT.PRODUCT_LINE.eq(PRODUCTLINE.PRODUCT_LINE))</pre>
			<pre class="source-code">     .forXML().path().asField("products"))</pre>
			<pre class="source-code">  .from(PRODUCTLINE)</pre>
			<pre class="source-code">  .forXML().path("productline").root("productlines")</pre>
			<pre class="source-code">  .fetch(); </pre>
			<p>Or we can <a id="_idIndexMarker787"/>obtain a <strong class="source-inline">String</strong> via <strong class="source-inline">formatXML(XMLformat)</strong>:</p>
			<pre class="source-code">String result = ctx.select(</pre>
			<pre class="source-code">       PRODUCTLINE.PRODUCT_LINE.as("productLine"), </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  .forXML().path("productline").root("productlines")</pre>
			<pre class="source-code">  .fetch()</pre>
			<pre class="source-code">  .formatXML(XMLFormat.DEFAULT_FOR_RECORDS);</pre>
			<p>Both examples will produce almost<a id="_idIndexMarker788"/> an identical XML, as follows (as you can see, altering the default XML tags inferred from the field names can be done with aliases via <strong class="source-inline">as("alias")</strong>):</p>
			<pre class="source-code">&lt;productlines&gt;</pre>
			<pre class="source-code">  &lt;productline&gt;</pre>
			<pre class="source-code">    &lt;productLine&gt;Classic Cars&lt;/productLine&gt;</pre>
			<pre class="source-code">    &lt;textDescription&gt;Attention ...&lt;/textDescription&gt;</pre>
			<pre class="source-code">    &lt;products&gt;</pre>
			<pre class="source-code">      &lt;product&gt;</pre>
			<pre class="source-code">        &lt;productName&gt;1952 Alpine Renault 1300&lt;/productName&gt;</pre>
			<pre class="source-code">        &lt;productVendor&gt;Classic Metal Creations&lt;/productVendor&gt;</pre>
			<pre class="source-code">        &lt;quantityInStock&gt;7305&lt;/quantityInStock&gt;</pre>
			<pre class="source-code">      &lt;/product&gt;</pre>
			<pre class="source-code">      &lt;product&gt;</pre>
			<pre class="source-code">        &lt;productName&gt;1972 Alfa Romeo GTA&lt;/productName&gt;</pre>
			<pre class="source-code">        &lt;productVendor&gt;Motor City Art Classics&lt;/productVendor&gt;</pre>
			<pre class="source-code">        &lt;quantityInStock&gt;3252&lt;/quantityInStock&gt;</pre>
			<pre class="source-code">      &lt;/product&gt;</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">    &lt;/products&gt;</pre>
			<pre class="source-code">  &lt;/productline&gt;</pre>
			<pre class="source-code">  &lt;productline&gt;</pre>
			<pre class="source-code">    &lt;productLine&gt;Motorcycles&lt;/productLine&gt;</pre>
			<pre class="source-code">    ...</pre>
			<p>You <a id="_idIndexMarker789"/>can check out these<a id="_idIndexMarker790"/> examples in the <em class="italic">XmlRelationships</em> application.</p>
			<h4>Mapping arbitrary nested models</h4>
			<p>jOOQ allows us to map arbitrarily nested <a id="_idIndexMarker791"/>models, not just the well-known 1:1,1:n, and n:n relationships, via SQL/XML support. Remember <strong class="bold">Model 2</strong> (see <em class="italic">Figure 8.3</em>)? Well, you already know how to fetch and map that model via SQL/JSON support, so this time, let's see how it can be done via SQL/XML:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code"> xmlelement("customer",</pre>
			<pre class="source-code">  xmlelement("customerName", CUSTOMER.CUSTOMER_NAME),</pre>
			<pre class="source-code">  xmlelement("creditLimit", CUSTOMER.CREDIT_LIMIT),</pre>
			<pre class="source-code">  xmlelement("payments", field(select(xmlagg(</pre>
			<pre class="source-code">  xmlelement("payment", // optional</pre>
			<pre class="source-code">   xmlforest(PAYMENT.CUSTOMER_NUMBER.as("customerNumber"),</pre>
			<pre class="source-code">    PAYMENT.INVOICE_AMOUNT.as("invoiceAmount"),</pre>
			<pre class="source-code">    PAYMENT.CACHING_DATE.as("cachingDate"),</pre>
			<pre class="source-code">    field(select(xmlagg(xmlelement("transaction", // optional</pre>
			<pre class="source-code">     xmlforest(BANK_TRANSACTION.BANK_NAME.as("bankName"),</pre>
			<pre class="source-code">     BANK_TRANSACTION.TRANSFER_AMOUNT.as("transferAmount")))))</pre>
			<pre class="source-code"> .from(BANK_TRANSACTION)</pre>
			<pre class="source-code"> .where(BANK_TRANSACTION.CUSTOMER_NUMBER</pre>
			<pre class="source-code">   .eq(PAYMENT.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">     .and(BANK_TRANSACTION.CHECK_NUMBER</pre>
			<pre class="source-code">       .eq(PAYMENT.CHECK_NUMBER)))).as("transactions")))))</pre>
			<pre class="source-code"> .from(PAYMENT).where(PAYMENT.CUSTOMER_NUMBER</pre>
			<pre class="source-code">   .eq(CUSTOMER.CUSTOMER_NUMBER)))),</pre>
			<pre class="source-code">  xmlelement("details", field(select(xmlagg(</pre>
			<pre class="source-code">   xmlforest(CUSTOMERDETAIL.ADDRESS_LINE_FIRST</pre>
			<pre class="source-code">    .as("addressLineFirst"),</pre>
			<pre class="source-code">    CUSTOMERDETAIL.STATE.as("state"))))</pre>
			<pre class="source-code">  .from(CUSTOMERDETAIL)</pre>
			<pre class="source-code">  .where(CUSTOMERDETAIL.CUSTOMER_NUMBER</pre>
			<pre class="source-code">    .eq(CUSTOMER.CUSTOMER_NUMBER))))))</pre>
			<pre class="source-code">  .from(CUSTOMER).orderBy(CUSTOMER.CREDIT_LIMIT).fetch();</pre>
			<p>This is the power of example; there is not much else to say. Take your time to dissect this query, and check out the bundled code to see the output. Moreover, in the bundled code, you can see <strong class="bold">Model 1</strong> and <strong class="bold">Model 3</strong>, too. The application is named <em class="italic">NestedXml</em>.</p>
			<p>As a SQL Server fan, you <a id="_idIndexMarker792"/>might be more interested in the previous query expressed via <strong class="source-inline">forXML()</strong>, so here it is:</p>
			<pre class="source-code">Result&lt;Record1&lt;XML&gt;&gt; result = ctx.select(</pre>
			<pre class="source-code"> CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT,</pre>
			<pre class="source-code"> select(PAYMENT.CUSTOMER_NUMBER, PAYMENT.INVOICE_AMOUNT,  </pre>
			<pre class="source-code">  PAYMENT.CACHING_DATE, select(BANK_TRANSACTION.BANK_NAME,    </pre>
			<pre class="source-code">   BANK_TRANSACTION.TRANSFER_AMOUNT).from(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .where(BANK_TRANSACTION.CUSTOMER_NUMBER</pre>
			<pre class="source-code">    .eq(PAYMENT.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">     .and(BANK_TRANSACTION.CHECK_NUMBER</pre>
			<pre class="source-code">       .eq(PAYMENT.CHECK_NUMBER)))</pre>
			<pre class="source-code">   .orderBy(BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">   .forXML().path().asField("transactions")).from(PAYMENT)</pre>
			<pre class="source-code">   .where(PAYMENT.CUSTOMER_NUMBER</pre>
			<pre class="source-code">     .eq(CUSTOMER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .orderBy(PAYMENT.CACHING_DATE)</pre>
			<pre class="source-code">   .forXML().path().asField("payments"),</pre>
			<pre class="source-code">  select(CUSTOMERDETAIL.CITY,</pre>
			<pre class="source-code">   CUSTOMERDETAIL.ADDRESS_LINE_FIRST, CUSTOMERDETAIL.STATE)</pre>
			<pre class="source-code">   .from(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .where(CUSTOMERDETAIL.CUSTOMER_NUMBER</pre>
			<pre class="source-code">     .eq(CUSTOMER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .forXML().path().asField("details"))</pre>
			<pre class="source-code">   .from(CUSTOMER).orderBy(CUSTOMER.CREDIT_LIMIT)</pre>
			<pre class="source-code">   .forXML().path().fetch();</pre>
			<p>In the bundled code, <em class="italic">NestedXml</em>, you can practice many more examples that, for brevity reasons, couldn't be listed here. Remember that, especially for this chapter, I beat the drums. Now, it is<a id="_idIndexMarker793"/> time to bring in an entire orchestra and pay tribute to the coolest feature of jOOQ mapping. Ladies and gentlemen, allow me to introduce the MULTISET!</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Nested collections via the astonishing MULTISET </h1>
			<p>The MULTISET value<a id="_idIndexMarker794"/> constructor (or MULTISET for short) is a SQL standard future that shapes nested subqueries (except scalar subqueries) into a <a id="_idIndexMarker795"/>single nested collection value. jOOQ 3.15+ provides marvelous and glorious support for MULTISET. It's marvelous because despite its tremendous power, it is quite easy (effortless) and intuitive to use via jOOQ, and it is glorious because it can produce any nested collection value of jOOQ <strong class="source-inline">Record</strong> or DTO (POJO/Java records) in a fully type-safe manner, with 0 reflections, no N+1 risks, no deduplications. This allows the database to perform nesting and to optimize the query execution plan. </p>
			<p>Consider the well-known one-to-many relationship between <strong class="source-inline">PRODUCTLINE</strong> and <strong class="source-inline">PRODUCT</strong>. We can fetch and map this relationship via jOOQ's <strong class="source-inline">&lt;R extends Record&gt; Field&lt;Result&lt;R&gt;&gt; multiset(Select&lt;R&gt; select)</strong>, in jOOQ before 3.17.x, and <strong class="source-inline">Field&lt;Result&lt;R&gt;&gt;</strong> <strong class="source-inline">multiset(TableLike&lt;R&gt; table)</strong> starting with jOOQ 3.17.x as follows (later, we will refer to this example as <em class="italic">Exhibit A</em>):</p>
			<pre class="source-code">var result = ctx.select(</pre>
			<pre class="source-code">       PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION,</pre>
			<pre class="source-code">    multiset(</pre>
			<pre class="source-code">       select(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, </pre>
			<pre class="source-code">              PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">          .from(PRODUCT)</pre>
			<pre class="source-code">          .where(PRODUCTLINE.PRODUCT_LINE</pre>
			<pre class="source-code">             .eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">    ).as("products")) // MULTISET ends here</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .orderBy(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So, the usage is quite simple! The jOOQ <strong class="source-inline">multiset()</strong> constructor gets a <strong class="source-inline">SELECT</strong> statement as an argument(or, a table-like object, starting with jOOQ 3.17.x). Formally speaking, the result set of this <strong class="source-inline">SELECT</strong> statement represents a collection that will be nested in<a id="_idIndexMarker796"/> the outer collection (the result set produced by the outer <strong class="source-inline">SELECT</strong> statement). By nesting/mixing <strong class="source-inline">multiset()</strong> and <strong class="source-inline">select()</strong> (or <strong class="source-inline">selectDistinct()</strong>), we can achieve any level or shape/hierarchy of nested collections. Previously, we used the Java 10 <strong class="source-inline">var</strong> keyword as the type of result, but the real type is <strong class="source-inline">Result&lt;Record3&lt;String, String, Result&lt;Record3&lt;String, String, Integer&gt;&gt;&gt;&gt;</strong>. Of course, more nesting will produce a really hard-to-digest <strong class="source-inline">Result</strong> object, so using <strong class="source-inline">var</strong> is the recommended way to go. As you already<a id="_idIndexMarker797"/> intuited, <strong class="source-inline">Result&lt;Record3&lt;String, String, Integer&gt;&gt;</strong> is produced by the <strong class="source-inline">SELECT</strong> statement from <strong class="source-inline">multiset()</strong>, while <strong class="source-inline">Result&lt;Record3&lt;String, String, nested_result&gt;&gt;</strong> is produced by the outer <strong class="source-inline">SELECT</strong> statement. The following diagram will help you to better understand this type:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B16833_Figure_8.5.jpg" alt="Figure 8.5 – The type returned by the previous query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The type returned by the previous query</p>
			<p>Since MULTISET <a id="_idIndexMarker798"/>has quite poor native support in <a id="_idIndexMarker799"/>databases, jOOQ has to emulate it via the SQL/JSON or SQL/XML operators. For instance, the previous query renders the following SQL in MySQL (check out how jOOQ uses <strong class="source-inline">json_merge_preserve()</strong> and <strong class="source-inline">json_array()</strong>):</p>
			<pre class="source-code">SET @t = @@group_concat_max_len;</pre>
			<pre class="source-code">SET @@group_concat_max_len = 4294967295;</pre>
			<pre class="source-code">SELECT `classicmodels`.`productline`.`product_line`,</pre>
			<pre class="source-code">       `classicmodels`.`productline`.`text_description`,</pre>
			<pre class="source-code">  (SELECT coalesce(json_merge_preserve('[]', concat('[', </pre>
			<pre class="source-code">          group_concat(json_array(`v0`, `v1`, `v2`) separator </pre>
			<pre class="source-code">          ','), ']')), json_array())</pre>
			<pre class="source-code">   FROM</pre>
			<pre class="source-code">     (SELECT `classicmodels`.`product`.`product_name` AS `v0`,</pre>
			<pre class="source-code">         `classicmodels`.`product`.`product_vendor` AS `v1`,</pre>
			<pre class="source-code">         `classicmodels`.`product`.`quantity_in_stock` AS `v2`</pre>
			<pre class="source-code">      FROM `classicmodels`.`product`</pre>
			<pre class="source-code">      WHERE `classicmodels`.`productline`.`product_line` =     </pre>
			<pre class="source-code">            `classicmodels`.`product`.`product_line`) </pre>
			<pre class="source-code">                AS `t`) AS `products`</pre>
			<pre class="source-code">FROM `classicmodels`.`productline`</pre>
			<pre class="source-code">ORDER BY `classicmodels`.`productline`.`product_line`;</pre>
			<pre class="source-code">SET @@group_concat_max_len = @t;</pre>
			<p>At any moment, you can transform this collection of <strong class="source-inline">Record</strong> into plain JSON or XML via <strong class="source-inline">formatJSON()</strong>/<strong class="source-inline">formatXML()</strong>. However, allow me to take this opportunity to highlight that if all you want is to fetch a JSON/XML (since this is what your client needs), then it is better to use the SQL/JSON and SQL/XML operators directly (as you saw in the previous <a id="_idIndexMarker800"/>section) instead of passing through MULTISET. You can find examples in the bundled code, <em class="italic">MultisetRelationships</em>, alongside examples of how to use MULTISET for one-to-one and many-to-many relationships. In the example for many-to-many<a id="_idIndexMarker801"/> relationships, you can see how well the jOOQ type-safe implicit (one-to-one) join feature fits with MULTISET.</p>
			<p>Remember <strong class="bold">Model 2</strong> (see <em class="italic">Figure 8.3</em>)? Well, you already know how to fetch and map that model via SQL/JSON and SQL/XML support, so let's see how to do it via MULTISET, too (later on, we will refer to this example as <em class="italic">Exhibit B</em>):</p>
			<pre class="source-code">var result = ctx.select(</pre>
			<pre class="source-code"> CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT,</pre>
			<pre class="source-code"> multiset(select(PAYMENT.CUSTOMER_NUMBER,    </pre>
			<pre class="source-code">                 PAYMENT.INVOICE_AMOUNT, PAYMENT.CACHING_DATE,</pre>
			<pre class="source-code">         multiset(select(BANK_TRANSACTION.BANK_NAME, </pre>
			<pre class="source-code">                         BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">                 .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">                 .where(BANK_TRANSACTION.CUSTOMER_NUMBER</pre>
			<pre class="source-code">                  .eq(PAYMENT.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">                  .and(BANK_TRANSACTION.CHECK_NUMBER</pre>
			<pre class="source-code">                   .eq(PAYMENT.CHECK_NUMBER)))</pre>
			<pre class="source-code">                 .orderBy(BANK_TRANSACTION.TRANSFER_AMOUNT)))</pre>
			<pre class="source-code">         .from(PAYMENT)</pre>
			<pre class="source-code">         .where(PAYMENT.CUSTOMER_NUMBER</pre>
			<pre class="source-code">          .eq(CUSTOMER.CUSTOMER_NUMBER))).as("payments"),</pre>
			<pre class="source-code"> multiset(select(CUSTOMERDETAIL.CITY, </pre>
			<pre class="source-code">                 CUSTOMERDETAIL.ADDRESS_LINE_FIRST,  </pre>
			<pre class="source-code">                 CUSTOMERDETAIL.STATE)</pre>
			<pre class="source-code">         .from(CUSTOMERDETAIL)</pre>
			<pre class="source-code">         .where(CUSTOMERDETAIL.CUSTOMER_NUMBER</pre>
			<pre class="source-code">          .eq(CUSTOMER.CUSTOMER_NUMBER)))</pre>
			<pre class="source-code">           .as("customer_details"))</pre>
			<pre class="source-code"> .from(CUSTOMER)</pre>
			<pre class="source-code"> .orderBy(CUSTOMER.CREDIT_LIMIT.desc())</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>This time, the returned type<a id="_idIndexMarker802"/> is<a id="_idIndexMarker803"/> quite verbose: <strong class="source-inline">Result&lt;Record4&lt;String, BigDecimal, Result&lt;Record4&lt;Long, BigDecimal, LocalDateTime, Result&lt;Record2&lt;String, BigDecimal&gt;&gt;&gt;&gt;, Result&lt;Record3&lt;String, String, String&gt;&gt;&gt;&gt;</strong>. The<a id="_idIndexMarker804"/> following diagram explains this:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B16833_Figure_8.6.jpg" alt="Figure 8.6 – The type returned by the previous query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – The type returned by the previous query</p>
			<p>You can find this example next to Model 1 and Model 3 in the application named <em class="italic">NestedMultiset</em>. Next, let's see<a id="_idIndexMarker805"/> how we can map MULTISET to DTO (for instance, POJO and Java 16 records).</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Mapping MULTISET to DTO</h2>
			<p>Having the result of a MULTISET as a<a id="_idIndexMarker806"/> generic structural type is cool, but most probably, you'll love to have a <strong class="source-inline">List</strong> of POJO/Java records instead. For<a id="_idIndexMarker807"/> instance, if we think of <em class="italic">Exhibit A</em>, then you'll probably write the following Java records as the mapping model:</p>
			<pre class="source-code">public record RecordProduct(String productName, </pre>
			<pre class="source-code">  String productVendor, Integer quantityInStock) {}</pre>
			<pre class="source-code">public record RecordProductLine(String productLine, </pre>
			<pre class="source-code">  String textDescription, List&lt;RecordProduct&gt; products) {}</pre>
			<p>So, you're expecting that <strong class="source-inline">Result&lt;Record3&lt;String, String, Integer&gt;&gt;</strong> will be fetched via MULTISET to be mapped to <strong class="source-inline">List&lt;RecordProduct&gt;</strong> and the whole query result to <strong class="source-inline">List&lt;RecordProductLine&gt;</strong>. The first part can be accomplished via the new ad hoc <strong class="source-inline">Field.convertFrom()</strong> converter, which was introduced in <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings</em>. With <strong class="source-inline">Field.convertFrom()</strong>, we convert the given <strong class="source-inline">Field&lt;T&gt;</strong> (here, <strong class="source-inline">Field&lt;Result&lt;Record3&lt;String, String, Integer&gt;&gt;&gt;</strong> is returned by <strong class="source-inline">multiset()</strong>) into a read-only <strong class="source-inline">Field&lt;U&gt;</strong> (here, <strong class="source-inline">Field&lt;List&lt;RecordProduct&gt;&gt;</strong>) for ad hoc usage:</p>
			<pre class="source-code">Field&lt;List&lt;RecordProduct&gt;&gt; result = multiset(</pre>
			<pre class="source-code">  select(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, </pre>
			<pre class="source-code">         PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code"> .from(PRODUCT)</pre>
			<pre class="source-code"> .where(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE)))</pre>
			<pre class="source-code">  .as("products").convertFrom(r -&gt; </pre>
			<pre class="source-code">                    r.map(mapping(RecordProduct::new)));</pre>
			<p>The <strong class="source-inline">r</strong> parameter from <strong class="source-inline">r -&gt; r.map(mapping(RecordProduct::new))</strong> is <strong class="source-inline">Result&lt;Record3&lt;String, String, Integer&gt;&gt;</strong>, so this lambda can be seen as <strong class="source-inline">Result&lt;Record3&lt;String, String, Integer&gt;&gt; -&gt; RecordProduct</strong>. The <strong class="source-inline">r.map(…)</strong> part is the <strong class="source-inline">Result.map(RecordMapper&lt;R, E&gt;)</strong> method. Finally, the <strong class="source-inline">Records.mapping()</strong> method (introduced earlier in this chapter) turns the constructor reference of the <strong class="source-inline">Function3&lt;String, String, Integer, RecordProduct&gt;</strong> type into a <strong class="source-inline">RecordMapper</strong> parameter, which is further used to turn a <strong class="source-inline">Result&lt;Record3&lt;String, String, Integer&gt;&gt;</strong> into a <strong class="source-inline">List&lt;RecordProduct&gt;</strong>. The resulting <strong class="source-inline">Field&lt;List&lt;SimpleProduct&gt;&gt;</strong> (which is like any other jOOQ <strong class="source-inline">Field</strong>) is now part of the outer <strong class="source-inline">SELECT</strong> next to <strong class="source-inline">PRODUCTLINE.PRODUCT_LINE</strong> (which is a <strong class="source-inline">String</strong>), and <strong class="source-inline">PRODUCTLINE.TEXT_DESCRIPTION</strong> (which is also a <strong class="source-inline">String</strong>).</p>
			<p>So, our last mission is to<a id="_idIndexMarker808"/> convert the outer-most <strong class="source-inline">Result3&lt;String, String, List&lt;RecordProduct&gt;&gt;</strong> into <strong class="source-inline">List&lt;RecordProductLine&gt;</strong>. For this, we <a id="_idIndexMarker809"/>rely only on <strong class="source-inline">mapping()</strong>, as follows:</p>
			<pre class="source-code">List&lt;RecordProductLine&gt; resultRecord = ctx.select(</pre>
			<pre class="source-code">  PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION,</pre>
			<pre class="source-code">  multiset(</pre>
			<pre class="source-code">    select(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, </pre>
			<pre class="source-code">           PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">    .from(PRODUCT)</pre>
			<pre class="source-code">    .where(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE)))</pre>
			<pre class="source-code">      .as("products").convertFrom(r -&gt;    </pre>
			<pre class="source-code">         r.map(Records.mapping(RecordProduct::new))))</pre>
			<pre class="source-code">    .from(PRODUCTLINE)</pre>
			<pre class="source-code">    .orderBy(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">    .fetch(mapping(RecordProductLine::new));</pre>
			<p>Done! Now, we can <a id="_idIndexMarker810"/>manipulate the <strong class="source-inline">List&lt;RecordProductLine&gt;</strong>. You can find this example in <em class="italic">MultisetRelationshipsInto</em>. By applying what<a id="_idIndexMarker811"/> we've learned here to the more complex <em class="italic">Exhibit B</em>, we obtain the following model:</p>
			<pre class="source-code">public record RecordBank (</pre>
			<pre class="source-code"> String bankName, BigDecimal transferAmount) {}</pre>
			<pre class="source-code">public record RecordCustomerDetail(</pre>
			<pre class="source-code"> String city, String addressLineFirst, String state) {}</pre>
			<pre class="source-code">public record RecordPayment(</pre>
			<pre class="source-code"> Long customerNumber, BigDecimal invoiceAmount, </pre>
			<pre class="source-code"> LocalDateTime cachingDate, List&lt;RecordBank&gt; transactions) {}</pre>
			<pre class="source-code">public record RecordCustomer(String customerName, </pre>
			<pre class="source-code"> BigDecimal creditLimit, List&lt;RecordPayment&gt; payments,  </pre>
			<pre class="source-code"> List&lt;RecordCustomerDetail&gt; details) {}</pre>
			<p>And the <em class="italic">Exhibit B</em> query is<a id="_idIndexMarker812"/> as<a id="_idIndexMarker813"/> follows:</p>
			<pre class="source-code"><strong class="bold">List&lt;RecordCustomer&gt;</strong> resultRecord = ctx.select(</pre>
			<pre class="source-code"> CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT,</pre>
			<pre class="source-code"> multiset(select(PAYMENT.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">                 PAYMENT.INVOICE_AMOUNT, PAYMENT.CACHING_DATE,</pre>
			<pre class="source-code">  multiset(select(BANK_TRANSACTION.BANK_NAME, </pre>
			<pre class="source-code">                  BANK_TRANSACTION.TRANSFER_AMOUNT)</pre>
			<pre class="source-code">           .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">           .where(BANK_TRANSACTION.CUSTOMER_NUMBER</pre>
			<pre class="source-code">            .eq(PAYMENT.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">             .and(BANK_TRANSACTION.CHECK_NUMBER</pre>
			<pre class="source-code">              .eq(PAYMENT.CHECK_NUMBER)))</pre>
			<pre class="source-code">           .orderBy(BANK_TRANSACTION.TRANSFER_AMOUNT))</pre>
			<pre class="source-code">           .convertFrom(r -&gt; r.map(mapping(RecordBank::new))))</pre>
			<pre class="source-code">  .from(PAYMENT)           </pre>
			<pre class="source-code">  .where(PAYMENT.CUSTOMER_NUMBER</pre>
			<pre class="source-code">   .eq(CUSTOMER.CUSTOMER_NUMBER))).as("payments")</pre>
			<pre class="source-code">  .convertFrom(r -&gt; r.map(mapping(RecordPayment::new))),</pre>
			<pre class="source-code"> multiset(select(CUSTOMERDETAIL.CITY, </pre>
			<pre class="source-code">                 CUSTOMERDETAIL.ADDRESS_LINE_FIRST, </pre>
			<pre class="source-code">                 CUSTOMERDETAIL.STATE)</pre>
			<pre class="source-code">         .from(CUSTOMERDETAIL)</pre>
			<pre class="source-code">         .where(CUSTOMERDETAIL.CUSTOMER_NUMBER          </pre>
			<pre class="source-code">          .eq(CUSTOMER.CUSTOMER_NUMBER)))</pre>
			<pre class="source-code">         .as("customer_details")</pre>
			<pre class="source-code">         .convertFrom(r -&gt; </pre>
			<pre class="source-code">           r.map(mapping(RecordCustomerDetail::new))))</pre>
			<pre class="source-code"> .from(CUSTOMER)</pre>
			<pre class="source-code"> .orderBy(CUSTOMER.CREDIT_LIMIT.desc())</pre>
			<pre class="source-code"> .fetch(mapping(RecordCustomer::new));</pre>
			<p>This example, next to the<a id="_idIndexMarker814"/> examples for Model 1 and Model 3 from <em class="italic">Figure 8.3</em>, is <a id="_idIndexMarker815"/>available in <em class="italic">NestedMultiset</em>. Next, let's tackle the <strong class="source-inline">MULTISET_AGG()</strong> function.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>The MULTISET_AGG() function</h2>
			<p>The jOOQ <strong class="source-inline">MULTISET_AGG()</strong> function is a <a id="_idIndexMarker816"/>synthetic aggregate function that can be used as an alternative to MULTISET. Its goal is to aggregate data into a nested collection represented as a jOOQ <strong class="source-inline">Result</strong> in a type-safe manner. The <strong class="source-inline">MULTISET_AGG()</strong> function is a convenient solution when we need to order by some aggregate value or create a <strong class="source-inline">WHERE</strong> statement based on result of not-deeply nested collection. For instance, the well-known one-to-many <strong class="source-inline">PRODUCTLINE</strong>:<strong class="source-inline">PRODUCT</strong> relationship can be aggregated as a nested collection as follows (the result type is <strong class="source-inline">Result&lt;Record3&lt;String, String, Result&lt;Record3&lt;String, String, Integer&gt;&gt;&gt;&gt;</strong>):</p>
			<p>Starting with jOOQ 3.17.x, we can turn an expression of type <strong class="source-inline">String</strong>, <strong class="source-inline">Name</strong>, <strong class="source-inline">Field</strong>, and so in, into a multiset via <strong class="source-inline">DSL.asMultiset()</strong> methods. Check out the jOOQ documentation for more details.</p>
			<pre class="source-code">var result = ctx.select(</pre>
			<pre class="source-code">  PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION,</pre>
			<pre class="source-code">  <strong class="bold">multisetAgg</strong>(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR,</pre>
			<pre class="source-code">              PRODUCT.QUANTITY_IN_STOCK).as("products"))</pre>
			<pre class="source-code">  .from(PRODUCTLINE)</pre>
			<pre class="source-code">  .join(PRODUCT)</pre>
			<pre class="source-code">  .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">  .groupBy(PRODUCTLINE.PRODUCT_LINE, </pre>
			<pre class="source-code">           PRODUCTLINE.TEXT_DESCRIPTION)</pre>
			<pre class="source-code">  .orderBy(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>This example is available, along with more examples, in <em class="italic">MultisetAggRelationships</em>.</p>
			<p>Mapping the <strong class="source-inline">Result</strong> object to a DTO (for instance, POJO and Java 16 records) is accomplished by following the same principles as in the case of MULTISET:</p>
			<pre class="source-code"><strong class="bold">List&lt;RecordProductLine&gt;</strong> resultRecord = ctx.select(</pre>
			<pre class="source-code">  PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION,</pre>
			<pre class="source-code">  multisetAgg(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR,</pre>
			<pre class="source-code">              PRODUCT.QUANTITY_IN_STOCK).as("products")</pre>
			<pre class="source-code">    .convertFrom(r -&gt; r.map(mapping(RecordProduct::new))))</pre>
			<pre class="source-code">  .from(PRODUCTLINE)</pre>
			<pre class="source-code">  .join(PRODUCT)</pre>
			<pre class="source-code">  .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">  .groupBy(PRODUCTLINE.PRODUCT_LINE,  </pre>
			<pre class="source-code">           PRODUCTLINE.TEXT_DESCRIPTION)</pre>
			<pre class="source-code">  .orderBy(PRODUCTLINE.PRODUCT_LINE)</pre>
			<pre class="source-code">  .fetch(mapping(RecordProductLine::new));</pre>
			<p>This example is available <a id="_idIndexMarker817"/>alongside other examples in <em class="italic">MultisetAggRelationshipsInto</em>. Next, let's try to compare MULTISETs.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Comparing MULTISETs</h2>
			<p>MULTISETs can be used in<a id="_idIndexMarker818"/> predicates, too. Check out the following example:</p>
			<pre class="source-code">ctx.select(count().as("equal_count"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(multiset(selectDistinct(SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">                   .from(SALE)</pre>
			<pre class="source-code">                   .where(EMPLOYEE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">                      .eq(SALE.EMPLOYEE_NUMBER)))</pre>
			<pre class="source-code">         .eq(multiset(select(val(2003).union(select(val(2004))</pre>
			<pre class="source-code">                     .union(select(val(2007)))))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But when we can say that two <a id="_idIndexMarker819"/>MULTISETs are equal? Check out the following examples that are meant to clarify this:</p>
			<pre class="source-code">// A</pre>
			<pre class="source-code">ctx.selectCount()</pre>
			<pre class="source-code">   .where(multiset(select(val("a"), val("b"), val("c")))</pre>
			<pre class="source-code">   .eq(multiset(select(val("a"), val("b"), val("c")))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">// B</pre>
			<pre class="source-code">ctx.selectCount()</pre>
			<pre class="source-code">   .where(multiset(select(val("a"), val("b"), val("c")))</pre>
			<pre class="source-code">   .eq(multiset(select(val("a"), val("c"), val("b")))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">// C</pre>
			<pre class="source-code">ctx.selectCount()</pre>
			<pre class="source-code">   .where(multiset(select(val("a")).union(select(val("b"))</pre>
			<pre class="source-code">                   .union(select(val("c")))))</pre>
			<pre class="source-code">   .eq(multiset(select(val("a")).union(select(val("b"))</pre>
			<pre class="source-code">                   .union(select(val("c")))))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">// D</pre>
			<pre class="source-code">ctx.selectCount()</pre>
			<pre class="source-code">   .where(multiset(select(val("a")).union(select(val("b"))</pre>
			<pre class="source-code">                   .union(select(val("c")))))</pre>
			<pre class="source-code">   .eq(multiset(select(val("a")).union(select(val("b"))))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So, which of A, B, C, and D will return 1? The correct answer is A and C. This means that two MULTISETs are equal if they have the exactly same number of elements in the same order. The application<a id="_idIndexMarker820"/> is named <em class="italic">MultisetComparing</em>. Feel free to determine when a MULTISET X is greater/lesser/contained … than a MULTISET Y. </p>
			<p>Also, don't forget to read <a href="https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/">https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/</a> and <a href="https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/">https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/</a>. It looks as though jOOQ 3.17 will enrich MULTISET support with even more cool features, <a href="https://twitter.com/JavaOOQ/status/1493261571103105030">https://twitter.com/JavaOOQ/status/1493261571103105030</a>, so stay tuned!</p>
			<p>Moreover, since <strong class="source-inline">MULTISET</strong> and <strong class="source-inline">MULTISET_AGG()</strong> are such hot topics you should constantly update your skills from real scenarios exposed at <a href="https://stackoverflow.com/search?q=%5Bjooq%5D+multiset">https://stackoverflow.com/search?q=%5Bjooq%5D+multiset</a>. </p>
			<p>Next, let's talk about lazy fetching.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Lazy fetching</h1>
			<p>Hibernate JPA guy: So, how do<a id="_idIndexMarker821"/> you handle huge result sets in jOOQ?</p>
			<p>jOOQ guy (me): jOOQ supports lazy fetching.</p>
			<p>Hibernate JPA guy: And how do you manage <strong class="source-inline">LazyInitializationException</strong>?</p>
			<p>jOOQ guy (me): For Hibernate JPA users that have just got here, I'd like to stress this right from the start – don't assume that jOOQ lazy fetching is related to or similar to Hibernate JPA lazy loading. jOOQ doesn't have and doesn't need a Persistence Context and doesn't rely on a <strong class="source-inline">Session</strong> object and proxy objects. Your code is not prone to any kind of lazy loading exceptions! </p>
			<p>Then, what is jOOQ lazy fetching?</p>
			<p>Well, most of the time, fetching the entire result set into memory is the best way to exploit your RDBMS (especially in web applications that face high traffic by optimizing small result sets and short transactions). However, there are cases (for instance, you might have a huge result set) when you'll like to fetch and process the result set in small chunks (for example, one by one). For such scenarios, jOOQ comes with the <strong class="source-inline">org.jooq.Cursor</strong> API. Practically, jOOQ holds a reference to an open result set and allows you to iterate (that is, load and process into memory) the result set via a number of methods such as <strong class="source-inline">fetchNext()</strong>, <strong class="source-inline">fetchNextOptional()</strong>, <strong class="source-inline">fetchNextInto()</strong>, and <strong class="source-inline">fetchNextOptionalInto()</strong>. However, to get a reference to an open result set, we have to call the <strong class="source-inline">fetchLazy()</strong> method, as shown in the following examples:</p>
			<pre class="source-code">try (Cursor&lt;CustomerRecord&gt; cursor </pre>
			<pre class="source-code">    = ctx.selectFrom(CUSTOMER).fetchLazy()) {</pre>
			<pre class="source-code">   while (cursor.hasNext()) {</pre>
			<pre class="source-code">      CustomerRecord customer = cursor.fetchNext();</pre>
			<pre class="source-code">      System.out.println("Customer:\n" + customer);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Notice that we are relying on the try-with-resources wrapping to ensure that the underlying result set is closed at the end of the iterating process. In this snippet of code, jOOQ fetches the records from the underlying result set into memory one by one via <strong class="source-inline">fetchNext()</strong>, but this<a id="_idIndexMarker822"/> doesn't mean that the JDBC driver does the same thing. JDBC drivers act differently across different database vendors and even across different versions of the same database. For instance, MySQL and PostgreSQL pre-fetches all records in a single database round-trip, SQL Server uses adaptive buffering (in the JDBC URL, we have <strong class="source-inline">selectMethod = direct; responseBuffering = adaptive;</strong>) and a default fetch size of 128 to avoid out-of-memory errors, and Oracle JDBC fetches a result set of 10 rows at a time from the database cursor (on the JDBC URL level, this can be altered via the <strong class="source-inline">defaultRowPrefetch</strong> property).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Bear in mind that the fetch size is just a JDBC hint trying to instruct the driver about the number of rows to fetch in one go from the database. However, the JDBC driver is free to ignore this hint.</p>
			<p>In jOOQ, configuring the fetch size can be done via <strong class="source-inline">ResultQuery.fetchSize(int size)</strong> or <strong class="source-inline">Settings.withFetchSize(int size)</strong>. jOOQ uses this configuration to set the underlying <strong class="source-inline">Statement.setFetchSize(int size)</strong> JDBC. Most JDBC drivers only apply this setting in certain contexts. For instance, MySQL should only apply this setting if we do the following:</p>
			<ul>
				<li>Set a forward-only result set (this can be set via jOOQ, <strong class="source-inline">resultSetType()</strong>).</li>
				<li>Set a concurrency read-only result set (via jOOQ, <strong class="source-inline">resultSetConcurrency()</strong>).</li>
			</ul>
			<p>The fetch size is either set to <strong class="source-inline">Integer.MIN_VALUE</strong> for fetching records one by one or to the desired size while adding <strong class="source-inline">useCursorFetch=true</strong> to the JDBC URL for relying on cursor-based streaming.</p>
			<p>Here is a snippet of <a id="_idIndexMarker823"/>code that takes advantage of these settings for MySQL:</p>
			<pre class="source-code">try (Cursor&lt;CustomerRecord&gt; cursor = ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">   .resultSetType(ResultSet.TYPE_FORWARD_ONLY)</pre>
			<pre class="source-code">   .resultSetConcurrency(ResultSet.CONCUR_READ_ONLY)</pre>
			<pre class="source-code">   .fetchSize(Integer.MIN_VALUE).fetchLazy()) {</pre>
			<pre class="source-code">   while (cursor.hasNext()) {</pre>
			<pre class="source-code">      CustomerRecord customer = cursor.fetchNext();</pre>
			<pre class="source-code">      System.out.println("Customer:\n" + customer);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>The complete example is named <em class="italic">LazyFetching</em>.</p>
			<p>On the other hand, PostgreSQL uses the fetch size if we do the following:</p>
			<ul>
				<li>Set forward-only result set (can be set via jOOQ, <strong class="source-inline">resultSetType()</strong>)</li>
				<li>Disable the <em class="italic">auto-commit</em> mode (in Spring Boot with the default Hikari CP connection pool, this can be done in <strong class="source-inline">application.properties</strong> via the following flag-property, <strong class="source-inline">spring.datasource.hikari.auto-commit=false</strong>, or in jOOQ via <strong class="source-inline">&lt;autoCommit&gt;false&lt;/autoCommit&gt;</strong> in the <strong class="source-inline">&lt;jdbc/&gt;</strong> tag of your configuration)</li>
			</ul>
			<p>So, the code for PostgreSQL can be as follows:</p>
			<pre class="source-code">try ( Cursor&lt;CustomerRecord&gt; cursor = ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">  .resultSetType(ResultSet.TYPE_FORWARD_ONLY) // default</pre>
			<pre class="source-code">  .fetchSize(1).fetchLazy()) {</pre>
			<pre class="source-code">  while (cursor.hasNext()) {</pre>
			<pre class="source-code">    CustomerRecord customer = cursor.fetchNext();</pre>
			<pre class="source-code">    System.out.println("Customer:\n" + customer);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Moreover, in PostgreSQL, the fetch size can be altered via <strong class="source-inline">defaultRowFetchSize</strong> and added to the JDBC URL. The complete example is also named <em class="italic">LazyFetching</em>.</p>
			<p>For SQL Server and Oracle, we <a id="_idIndexMarker824"/>can rely on the default fetch size since both of them prevent out-of-memory errors. Nevertheless, enabling the fetch size in SQL Server is quite challenging while using the Microsoft JDBC driver (as in this book). It is much simpler if you rely on the jTDS driver.</p>
			<p>Our examples for SQL Server and Oracle (<em class="italic">LazyFetching</em>) rely on the default fetching size; therefore, 128 for SQL Server and 10 for Oracle.</p>
			<p>Finally, you can combine <strong class="source-inline">ResultSet</strong> and the Cursor API as follows:</p>
			<pre class="source-code">ResultSet rs = ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">  .fetchLazy().resultSet();</pre>
			<pre class="source-code">Cursor&lt;Record&gt; cursor = ctx.fetchLazy(rs);</pre>
			<p>Additionally, you can do it like this:</p>
			<pre class="source-code">Cursor&lt;Record&gt; result = ctx.fetchLazy(</pre>
			<pre class="source-code">   rs, CUSTOMER.CUSTOMER_NAME, CUSTOMER.CREDIT_LIMIT);</pre>
			<pre class="source-code">Cursor&lt;Record&gt; result = ctx.fetchLazy(</pre>
			<pre class="source-code">   rs, VARCHAR, DECIMAL);</pre>
			<pre class="source-code">Cursor&lt;Record&gt; result = ctx.fetchLazy(</pre>
			<pre class="source-code">   rs, String.class, BigDecimal.class);</pre>
			<p>Next, let's talk about<a id="_idIndexMarker825"/> lazy fetching via streaming.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Lazy featching via fetchStream()/fetchStreamInto()</h2>
			<p>In jOOQ, lazy fetching can also be achieved via <strong class="source-inline">fetchStream()</strong>/<strong class="source-inline">fetchStreamInto()</strong>. This method <a id="_idIndexMarker826"/>keeps an open JDBC result set internally and allows us to stream its content (that is, lazy fetching the result set into memory). For example, plain SQL can take <a id="_idIndexMarker827"/>advantage of <strong class="source-inline">DSLContext.fetchStream()</strong>, as follows:</p>
			<pre class="source-code">try ( Stream&lt;Record&gt; stream </pre>
			<pre class="source-code">       = ctx.fetchStream("SELECT sale FROM sale")) {</pre>
			<pre class="source-code"> stream.filter(rs -&gt; rs.getValue("sale", Double.class) &gt; 5000)</pre>
			<pre class="source-code">       .forEach(System.out::println);</pre>
			<pre class="source-code">}</pre>
			<p>Or we can use the generated Java-based schema, as follows:</p>
			<pre class="source-code">try ( Stream&lt;SaleRecord&gt; stream </pre>
			<pre class="source-code">       = ctx.selectFrom(SALE).fetchStream()) {</pre>
			<pre class="source-code"> stream.filter(rs -&gt; rs.getValue(SALE.SALE_) &gt; 5000)</pre>
			<pre class="source-code">       .forEach(System.out::println);</pre>
			<pre class="source-code">}</pre>
			<p>This code works in the same way as the next one, which uses <strong class="source-inline">stream()</strong>, not <strong class="source-inline">fetchStream()</strong>:</p>
			<pre class="source-code">try ( Stream&lt;SaleRecord&gt; stream </pre>
			<pre class="source-code">       = ctx.selectFrom(SALE).stream()) {</pre>
			<pre class="source-code"> stream.filter(rs -&gt; rs.getValue(SALE.SALE_) &gt; 5000)</pre>
			<pre class="source-code">       .forEach(System.out::println);</pre>
			<pre class="source-code">}</pre>
			<p>However, pay attention as this code is not the same as the next one (the previous example uses <strong class="source-inline">org.jooq.ResultQuery.stream()</strong>, while the next example uses <strong class="source-inline">java.</strong><strong class="source-inline">util.</strong><strong class="source-inline">Collection.stream()</strong>):</p>
			<pre class="source-code">ctx.selectFrom(SALE)</pre>
			<pre class="source-code"> .fetch()  // jOOQ fetches the whole result set into memory </pre>
			<pre class="source-code">           // and closes the database connection</pre>
			<pre class="source-code"> .stream() // stream over the in-memory result set </pre>
			<pre class="source-code">           // (no database connection is active)</pre>
			<pre class="source-code"> .filter(rs -&gt; rs.getValue(SALE.SALE_) &gt; 5000)</pre>
			<pre class="source-code"> .forEach(System.out::println);</pre>
			<p>Here, the <strong class="source-inline">fetch()</strong> method <a id="_idIndexMarker828"/>fetches the whole result set into memory and closes the database connection – this time, we don't need the<a id="_idIndexMarker829"/> try-with-resources wrapping since we are, essentially, streaming a list of records. Next, the <strong class="source-inline">stream()</strong> method opens a stream over the in-memory result set and no database connection is kept open. So, pay attention to how you write such snippets of code since you will be prone to accidental mistakes – for instance, you might need lazy fetching but accidentally add <strong class="source-inline">fetch()</strong>, or you might want eager fetching but accidentally forget to add <strong class="source-inline">fetch()</strong>.</p>
			<h3>Using org.jooq.ResultQuery.collect()</h3>
			<p>Sometimes, we need<a id="_idIndexMarker830"/> the stream pipeline to apply specific operations (for instance, <strong class="source-inline">filter()</strong>), and to collect the results, as shown in the following example:</p>
			<pre class="source-code">try ( Stream&lt;Record1&lt;Double&gt;&gt; stream = ctx.select(SALE.SALE_)</pre>
			<pre class="source-code">      .from(SALE).fetchStream()) {  // jOOQ API ends here    </pre>
			<pre class="source-code"> SimpleSale result = stream.filter( // Stream API starts here</pre>
			<pre class="source-code">   rs -&gt; rs.getValue(SALE.SALE_) &gt; 5000)                    </pre>
			<pre class="source-code">      .collect(Collectors.teeing(</pre>
			<pre class="source-code">        summingDouble(rs -&gt; rs.getValue(SALE.SALE_)),</pre>
			<pre class="source-code">        mapping(rs -&gt; rs.getValue(SALE.SALE_), toList()),</pre>
			<pre class="source-code">        SimpleSale::new));</pre>
			<pre class="source-code">}</pre>
			<p>However, if we don't actually need the stream pipeline (for instance, we don't need the <strong class="source-inline">filter()</strong> call or any other operation), and all we want is to lazily collect the result set, then it is pointless calling <strong class="source-inline">fetchStream()</strong>. But if we remove <strong class="source-inline">fetchStream()</strong>, how can we still collect in a lazy fashion? The answer is the jOOQ <strong class="source-inline">collect()</strong> method, which is available in <strong class="source-inline">org.</strong><strong class="source-inline">jooq.</strong><strong class="source-inline">ResultQuery</strong>. This method is very handy because it can handle resources<a id="_idIndexMarker831"/> internally and bypass the intermediate <strong class="source-inline">Result</strong> data structure. As you can see, there is no need to use try-with-resources after removing the <strong class="source-inline">fetchStream()</strong> call:</p>
			<pre class="source-code">SimpleSale result = ctx.select(SALE.SALE_).from(SALE)</pre>
			<pre class="source-code"> .collect(Collectors.teeing( // org.jooq.ResultQuery.collect()</pre>
			<pre class="source-code">   summingDouble(rs -&gt; rs.getValue(SALE.SALE_)),</pre>
			<pre class="source-code">   mapping(rs -&gt; rs.getValue(SALE.SALE_), toList()),</pre>
			<pre class="source-code">   SimpleSale::new));</pre>
			<p>However, please bear in mind the following note.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is always a good practice to ensure that streaming is really needed. If your stream operations have SQL counterparts (for example, <strong class="source-inline">filter()</strong> can be replaced with a <strong class="source-inline">WHERE</strong> clause and <strong class="source-inline">summingDouble()</strong> can be replaced with the SQL's <strong class="source-inline">SUM()</strong> aggregate function), then go for the SQL. This will be much faster due to the significantly lower data transfer. So, always ask yourself: "<em class="italic">Can I translate this streaming operation into my SQL?</em>" If yes, then do it! If not, then go for streaming, as we will do in the following example.</p>
			<p>Here is another<a id="_idIndexMarker832"/> example that lazy fetches groups. jOOQ doesn't fetch everything in memory thanks to <strong class="source-inline">collect()</strong>, and since we also set the fetch size, the JDBC driver fetches the result set in small chunks (here, a chunk has five records). The PostgreSQL version is as follows:</p>
			<pre class="source-code">Map&lt;Productline, List&lt;Product&gt;&gt; result = ctx.select()</pre>
			<pre class="source-code"> .from(PRODUCTLINE).leftOuterJoin(PRODUCT)</pre>
			<pre class="source-code"> .on(PRODUCTLINE.PRODUCT_LINE.eq(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code"> .fetchSize(5) // Set the fetch size for JDBC driver           </pre>
			<pre class="source-code"> .collect(Collectors.groupingBy(</pre>
			<pre class="source-code">    rs -&gt; rs.into(Productline.class),</pre>
			<pre class="source-code">          Collectors.mapping(</pre>
			<pre class="source-code">    rs -&gt; rs.into(Product.class), toList())));</pre>
			<p>The complete application is named <em class="italic">LazyFetchingWithStreams</em>. Next, let's talk about asynchronous fetching.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Asynchronous fetching</h1>
			<p>Whenever you consider that you need <a id="_idIndexMarker833"/>asynchronous fetching (for instance, a query takes too long to wait for it or multiple queries can run independently of each other (non-atomically)) you can rely on the jOOQ + <strong class="source-inline">CompletableFuture</strong> combination. For instance, the following asynchronous operation chains an <strong class="source-inline">INSERT</strong> statement, an <strong class="source-inline">UPDATE</strong> statement, and a <strong class="source-inline">DELETE</strong> statement using the <strong class="source-inline">CompletableFuture</strong> API and the threads obtained from the default <strong class="source-inline">ForkJoinPool</strong> API (if you are not familiar with this API, then you can consider purchasing the <em class="italic">Java Coding Problems</em> book from Packt, which dives deeper into this topic):</p>
			<pre class="source-code">@Async</pre>
			<pre class="source-code">public CompletableFuture&lt;Void&gt; insertUpdateDeleteOrder() {</pre>
			<pre class="source-code"> return CompletableFuture.supplyAsync(() -&gt; {</pre>
			<pre class="source-code">  return ctx.insertInto(ORDER)</pre>
			<pre class="source-code">   .values(null, LocalDate.of(2003, 2, 12), </pre>
			<pre class="source-code">    LocalDate.of(2003, 3, 1), LocalDate.of(2003, 2, 27),    </pre>
			<pre class="source-code">    "Shipped", "New order inserted...", 363L, BigDecimal.ZERO)</pre>
			<pre class="source-code">   .returning().fetchOne();</pre>
			<pre class="source-code">  }).thenApply(order -&gt; {</pre>
			<pre class="source-code">    order.setStatus("ON HOLD");</pre>
			<pre class="source-code">    order.setComments("Reverted to on hold ...");</pre>
			<pre class="source-code">    ctx.executeUpdate(order);</pre>
			<pre class="source-code">            </pre>
			<pre class="source-code">    return order.getOrderId();            </pre>
			<pre class="source-code">  }).thenAccept(id -&gt; ctx.deleteFrom(ORDER)</pre>
			<pre class="source-code">    .where(ORDER.ORDER_ID.eq(id)).execute());</pre>
			<pre class="source-code">}</pre>
			<p>This example is available for MySQL<a id="_idIndexMarker834"/> next to another one in the application named <em class="italic">SimpleAsync</em>.</p>
			<p>You can exploit <strong class="source-inline">CompletableFuture</strong> and jOOQ, as demonstrated in the previous example. However, you can also rely on two jOOQ shortcuts, <strong class="source-inline">fetchAsync()</strong> and <strong class="source-inline">executeAsync()</strong>. For instance, let's suppose that we want to fetch managers (<strong class="source-inline">MANAGER</strong>), offices (<strong class="source-inline">OFFICE</strong>), and employees (<strong class="source-inline">EMPLOYEE</strong>) and serve them to the client in HTML format. Fetching managers, offices, and employees can be done asynchronously since these three queries <a id="_idIndexMarker835"/>are not dependent on each other. In this context, the jOOQ <strong class="source-inline">fetchAsync()</strong> method allows us to write the following three methods:</p>
			<pre class="source-code">@Async</pre>
			<pre class="source-code">public CompletableFuture&lt;String&gt; fetchManagersAsync() {   </pre>
			<pre class="source-code">   return ctx.select(MANAGER.MANAGER_ID, MANAGER.MANAGER_NAME)</pre>
			<pre class="source-code">   .from(MANAGER).fetchAsync()</pre>
			<pre class="source-code">   .thenApply(rs -&gt; rs.formatHTML()).toCompletableFuture();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">@Async</pre>
			<pre class="source-code">public CompletableFuture&lt;String&gt; fetchOfficesAsync() {</pre>
			<pre class="source-code"> return ctx.selectFrom(OFFICE).fetchAsync()</pre>
			<pre class="source-code">   .thenApply(rs -&gt; rs.formatHTML()).toCompletableFuture();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">@Async</pre>
			<pre class="source-code">public CompletableFuture&lt;String&gt; fetchEmployeesAsync() {</pre>
			<pre class="source-code">  return ctx.select(EMPLOYEE.OFFICE_CODE, </pre>
			<pre class="source-code">                    EMPLOYEE.JOB_TITLE, EMPLOYEE.SALARY)  </pre>
			<pre class="source-code"> .from(EMPLOYEE).fetchAsync()</pre>
			<pre class="source-code"> .thenApply(rs -&gt; rs.formatHTML()).toCompletableFuture();</pre>
			<pre class="source-code">}</pre>
			<p>Next, we wait for these three asynchronous <a id="_idIndexMarker836"/>methods to complete via the <strong class="source-inline">CompletableFuture.allOf()</strong> method:</p>
			<pre class="source-code">public String fetchCompanyAsync() {</pre>
			<pre class="source-code"> CompletableFuture&lt;String&gt;[] fetchedCf </pre>
			<pre class="source-code">                         = new CompletableFuture[]{</pre>
			<pre class="source-code">  classicModelsRepository.fetchManagersAsync(),</pre>
			<pre class="source-code">  classicModelsRepository.fetchOfficesAsync(),</pre>
			<pre class="source-code">  classicModelsRepository.fetchEmployeesAsync()};</pre>
			<pre class="source-code">  // Wait until they are all done</pre>
			<pre class="source-code">  CompletableFuture&lt;Void&gt; allFetchedCf </pre>
			<pre class="source-code">                         = CompletableFuture.allOf(fetchedCf);</pre>
			<pre class="source-code">  allFetchedCf.join();</pre>
			<pre class="source-code">  // collect the final result</pre>
			<pre class="source-code">  return allFetchedCf.thenApply(r -&gt; {</pre>
			<pre class="source-code">   StringBuilder result = new StringBuilder();</pre>
			<pre class="source-code">   for (CompletableFuture&lt;String&gt; cf : fetchedCf) {</pre>
			<pre class="source-code">    result.append(cf.join());</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return result.toString();</pre>
			<pre class="source-code">   }).join();</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">String</strong> returned by this method (for instance, from a REST controller) represents a piece of HTML produced by jOOQ via the <strong class="source-inline">formatHTML()</strong> method. Curious about what this HTML looks like? Then, simply run the <em class="italic">FetchAsync</em> application under MySQL and use the provided controller to<a id="_idIndexMarker837"/> fetch the data in a browser. You might also like to practice the <em class="italic">ExecuteAsync</em> (which is available for MySQL) application that uses the jOOQ <strong class="source-inline">executeAsync()</strong> method as an example. </p>
			<p>Lukas Eder mentions that: </p>
			<p><em class="italic">"Perhaps worth mentioning that there's an ExecutorProvider SPI that allows for routing these async executions elsewhere when the default ForkJoinPool is not the correct place? jOOQ's own CompletionStage implementations also make sure that everything is always executed on the Executor provided by ExecutorProvider, unlike the JDK APIs, which always defaults back to the ForkJoinPool again (unless that has changed, recently)."</em></p>
			<p>Next, let's tackle reactive fetching.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Reactive fetching</h1>
			<p>Reactive fetching refers to the use of a reactive <a id="_idIndexMarker838"/>API in combination with jOOQ. Since you are using Spring Boot, there is a big chance that you are already familiar with the Project <a id="_idIndexMarker839"/>Reactor reactive library (<a href="https://projectreactor.io/">https://projectreactor.io/</a>) or the <strong class="source-inline">Mono</strong> and <strong class="source-inline">Flux</strong> APIs. So, without going into further detail, let's take an example of combining <strong class="source-inline">Flux</strong> and jOOQ in a controller:</p>
			<pre class="source-code">@GetMapping(value = "/employees", </pre>
			<pre class="source-code">            produces = MediaType.TEXT_EVENT_STREAM_VALUE)</pre>
			<pre class="source-code">public Flux&lt;String&gt; fetchEmployees() {</pre>
			<pre class="source-code"> return Flux.from(</pre>
			<pre class="source-code">   ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">              EMPLOYEE.JOB_TITLE, EMPLOYEE.SALARY)</pre>
			<pre class="source-code">      .from(EMPLOYEE))</pre>
			<pre class="source-code">      .map(e -&gt; e.formatHTML())</pre>
			<pre class="source-code">        .delayElements(Duration.ofSeconds(2))</pre>
			<pre class="source-code">        .share();</pre>
			<pre class="source-code">}</pre>
			<p>So, jOOQ is responsible for fetching some data from <strong class="source-inline">EMPLOYEE</strong>, and <strong class="source-inline">Flux</strong> is responsible for publishing the fetched data. You can practice this example in <em class="italic">SimpleReactive</em> (which is available for MySQL).</p>
			<p>What about a more<a id="_idIndexMarker840"/> complex example? One of the important architectures that can be applied to mitigate data loss in a <a id="_idIndexMarker841"/>streaming pipeline is <strong class="bold">Hybrid Message Logging</strong> (<strong class="bold">HML</strong>). Imagine a streaming pipeline for meetup RSVPs. In order to ensure that we don't lose any RSVPs, we can rely on <strong class="bold">Receiver-Based Message Logging</strong> (<strong class="bold">RBML</strong>) to write <a id="_idIndexMarker842"/>every received RSVP to stable storage (for instance, PostgreSQL) before any action is performed on it. Moreover, we <a id="_idIndexMarker843"/>can rely on <strong class="bold">Sender-Based Message Logging</strong> (<strong class="bold">SBML</strong>) to write each RSVP in the stable storage right before we send it further on in the pipeline (for example, to a message queuing). This is the RSVP that was processed by the application business logic, so it might not the same as the received RSVP. The following diagram represents data flowing through an HML implementation:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B16833_Figure_8.7.jpg" alt="Figure 8.7 – Data flow through HML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Data flow through HML</p>
			<p>Based on the preceding diagram, we <a id="_idIndexMarker844"/>can implement the processing and recovery of data asynchronously. For instance, the RBML part can be expressed in jOOQ as follows:</p>
			<pre class="source-code">public void insertRsvps(String message) {</pre>
			<pre class="source-code"> Flux&lt;RsvpDocument&gt; fluxInsertRsvp =    </pre>
			<pre class="source-code">  Flux.from(ctx.insertInto(RSVP_DOCUMENT)</pre>
			<pre class="source-code">   .columns(RSVP_DOCUMENT.ID, RSVP_DOCUMENT.RSVP, </pre>
			<pre class="source-code">                 RSVP_DOCUMENT.STATUS)</pre>
			<pre class="source-code">   .values((long) Instant.now().getNano(), message, "PENDING")</pre>
			<pre class="source-code">   .returningResult(RSVP_DOCUMENT.ID, RSVP_DOCUMENT.RSVP, </pre>
			<pre class="source-code">                    RSVP_DOCUMENT.STATUS))</pre>
			<pre class="source-code">   .map(rsvp -&gt; new RsvpDocument(rsvp.value1(), rsvp.value2(), </pre>
			<pre class="source-code">              rsvp.value3()));</pre>
			<pre class="source-code">   processRsvp(fluxInsertRsvp);</pre>
			<pre class="source-code">}</pre>
			<p>On the other hand, the SBML part can be expressed as follows:</p>
			<pre class="source-code">private void recoverRsvps() {</pre>
			<pre class="source-code"> Flux&lt;RsvpDocument&gt; fluxFindAllRsvps = Flux.from(</pre>
			<pre class="source-code">  ctx.select(RSVP_DOCUMENT.ID, RSVP_DOCUMENT.RSVP, </pre>
			<pre class="source-code">             RSVP_DOCUMENT.STATUS)</pre>
			<pre class="source-code">     .from(RSVP_DOCUMENT))</pre>
			<pre class="source-code">     .map(rsvp -&gt; new RsvpDocument(rsvp.value1(), </pre>
			<pre class="source-code">            rsvp.value2(), rsvp.value3()));</pre>
			<pre class="source-code"> processRsvp(fluxFindAllRsvps);</pre>
			<pre class="source-code">}</pre>
			<p>What about deleting or updating <a id="_idIndexMarker845"/>an RSVP? For the complete code, check out the <em class="italic">HML</em> application, which is available for PostgreSQL.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Summary</h1>
			<p>This was a big chapter that covered one of the most powerful capabilities of jOOQ, fetching and mapping data. As you learned, jOOQ supports a wide range of approaches for fetching and mapping data, from simple fetching to record mappers, to the fancy SQL/JSON and SQL/XML, to the marvelous and glorious MULTISET support, and finally, to lazy, asynchronous, and reactive fetching. In the next chapter, we will talk about how to batch and bulk data.</p>
		</div>
	</body></html>