- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding Bytecodes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解字节码
- en: In the intricate world of the JVM, bytecode serves as the intermediary language
    that enables Java programs to transcend the boundaries of platform-specific hardware
    and operating systems. As we delve into the heart of JVM internals, this chapter
    focuses on deciphering the bytecode, a fundamental component in executing Java
    applications. Bytecode, represented as a set of instructions, acts as the bridge
    between high-level Java code and the machine-specific language of the underlying
    hardware. By comprehending bytecode, developers gain insights into the inner workings
    of the JVM, empowering them to optimize code performance and troubleshoot intricate
    issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM错综复杂的领域中，字节码作为中介语言，使Java程序能够超越特定平台硬件和操作系统的限制。当我们深入JVM内部的核心时，本章专注于解码字节码，这是执行Java应用程序的基本组件。字节码，作为一组指令的表示，充当了高级Java代码和底层硬件特定语言之间的桥梁。通过理解字节码，开发者可以深入了解JVM的内部工作原理，从而优化代码性能并解决复杂问题。
- en: At the core of bytecode lies a diverse set of instructions that dictate the
    low-level operations performed by the JVM. This chapter unravels the nuances of
    arithmetic operations, shedding light on how the JVM handles mathematical calculations.
    From essential addition and subtraction to more complex procedures, we explore
    the bytecode instructions that govern these processes. Furthermore, we delve into
    value conversions, demystifying how the JVM transforms data between different
    types. Understanding these low-level operations is paramount for developers seeking
    to fine-tune their applications for optimal performance and efficiency. Join us
    on a journey into the bytecode realm, where the intricacies of arithmetic operations
    and value conversions pave the way for mastering the JVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码的核心是一系列指令，这些指令决定了JVM执行的底层操作。本章揭示了算术操作的细微差别，阐明了JVM如何处理数学计算。从基本的加法和减法到更复杂的程序，我们探讨了管理这些过程的字节码指令。此外，我们还深入探讨了值转换，揭示了JVM如何在不同类型之间转换数据。理解这些底层操作对于寻求优化应用程序性能和效率的开发者至关重要。加入我们，一起探索字节码领域，在这里，算术操作和值转换的复杂性为掌握JVM铺平了道路。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Bytecode unveiled
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看字节码
- en: Arithmetic operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算
- en: Value conversions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换
- en: Object manipulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象操作
- en: Conditional instructions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件指令
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Java 21
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03)
- en: Bytecode unveiled
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看字节码
- en: Bytecode, a pivotal concept in Java programming, is the intermediary language
    that facilitates the cross-platform compatibility and execution of Java applications
    on the JVM. This session aims to demystify bytecode, providing a comprehensive
    overview of its significance, purpose, and the spectrum of operations it enables
    within the JVM.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码，Java编程中的关键概念，是促进Java应用程序在JVM上实现跨平台兼容性和执行的中介语言。本次会议旨在揭开字节码的神秘面纱，提供一个对其重要性、目的以及它在JVM内允许的操作范围的全面概述。
- en: At its core, bytecode acts as a bridge between high-level Java code and the
    machine-specific language of the underlying hardware. When a Java program is compiled,
    the source code is transformed into bytecode, a set of instructions comprehensible
    to the JVM. This platform-independent bytecode allows Java applications to execute
    seamlessly across diverse environments, a fundamental tenet of Java’s *Write Once,
    Run* *Anywhere* mantra.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，字节码充当了高级Java代码和底层硬件特定语言之间的桥梁。当Java程序编译时，源代码被转换成字节码，这是一组JVM可理解的指令。这种平台无关的字节码允许Java应用程序在不同环境中无缝执行，这是Java“一次编写，到处运行”信条的基本原则。
- en: Why do we have bytecode? The answer lies in the portability and versatility
    it brings to Java applications. By introducing an intermediate step between the
    high-level source code and machine code, Java programs can run on any device equipped
    with a JVM, irrespective of its architecture or operating system. This abstraction
    shields developers from the intricacies of hardware-specific details, fostering
    a more universal and accessible programming environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们有字节码？答案在于它为Java应用程序带来的可移植性和多功能性。通过在高级源代码和机器代码之间引入一个中间步骤，Java程序可以在任何配备JVM的设备上运行，无论其架构或操作系统如何。这种抽象保护开发者免受硬件特定细节的复杂性，促进了一个更通用和易于访问的编程环境。
- en: Now, let’s delve into the operations encoded within bytecode. Bytecode instructions
    cover a myriad of functionalities, ranging from basic load and save operations
    to intricate arithmetic calculations. The JVM’s stack-based architecture governs
    these operations, where values are pushed and popped onto and off the stack, forming
    the basis for data manipulation. Arithmetic operations, encompassing addition,
    subtraction, multiplication, and more, are executed through specific bytecode
    instructions, allowing developers to understand and optimize the mathematical
    underpinnings of their code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨字节码中编码的操作。字节码指令涵盖了众多功能，从基本的加载和保存操作到复杂的算术计算。JVM的基于栈的架构控制这些操作，其中值被推入和弹出栈，形成数据操作的基础。包括加法、减法、乘法等在内的算术操作通过特定的字节码指令执行，使开发者能够理解和优化代码的数学基础。
- en: '**Value conversion**, another facet of bytecode operations, involves transforming
    data between different types. Whether converting integers to floating point numbers
    or managing other type transitions, bytecode instructions provide the foundation
    for these operations. This flexibility is crucial for developers crafting code
    and seamlessly handling diverse data types within the Java ecosystem.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**值转换**是字节码操作的另一个方面，涉及在不同类型之间转换数据。无论是将整数转换为浮点数还是管理其他类型转换，字节码指令为这些操作提供了基础。这种灵活性对于开发者编写代码和在Java生态系统中无缝处理各种数据类型至关重要。'
- en: Beyond this, bytecode orchestrates the creation and manipulation of objects,
    governs conditional statements, and manages the invocation and return of methods.
    Each bytecode instruction contributes to the overall execution flow of a Java
    program, and understanding these operations empowers developers to craft efficient,
    performant, and reliable applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，字节码负责对象的创建和操作，控制条件语句，并管理方法的调用和返回。每条字节码指令都对Java程序的总体执行流程做出贡献，理解这些操作使开发者能够构建高效、性能良好且可靠的应用程序。
- en: Indeed, understanding the bytecode behavior is crucial for navigating the intricacies
    of the JVM. Bytecode instructions are designed to operate on specific types of
    values, and recognizing the type being operated upon is fundamental to writing
    efficient and correct Java code. The initial letter of each bytecode mnemonic
    often serves as a valuable hint for discerning the type of operation being performed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，理解字节码行为对于导航JVM的复杂性至关重要。字节码指令旨在操作特定类型的值，识别被操作的类型对于编写高效和正确的Java代码是基本的。每个字节码助记符的首字母通常是一个宝贵的提示，有助于辨别正在执行的操作类型。
- en: 'Let’s delve into this tip for recognizing the type of operation based on the
    initial letter of the bytecode mnemonic:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这个基于字节码助记符首字母识别操作类型的技巧：
- en: '**i for integer operations**: Bytecodes starting with **i**, such as **iload**
    (load integer), **iadd** (add integer), or **isub** (subtract integer), signify
    operations involving integer values. These bytecode instructions manipulate data
    stored as 32-bit signed integers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i用于整数操作**：以**i**开头的字节码，例如**iload**（加载整数）、**iadd**（加整数）或**isub**（减整数），表示涉及整数值的操作。这些字节码指令操作存储为32位有符号整数的数据。'
- en: '**l for long operations**: The **l** prefix, as seen in **lload** (load long)
    or **lmul** (multiply long), indicates operations on 64-bit signed long integers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**l用于长操作**：**l**前缀，如在**lload**（加载长整型）或**lmul**（乘长整型）中看到的那样，表示对64位有符号长整数的操作。'
- en: '**s for short operations**: Bytecodes beginning with **s**, for instance, **sload**
    (load short), are associated with operations on 16-bit signed short integers.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s用于短操作**：以**s**开头的字节码，例如**sload**（加载短整型），与16位有符号短整数的操作相关。'
- en: '**b for byte operations**: The **b** prefix, found in bytecode instructions
    such as **bload** (load byte), denotes operations on 8-bit signed byte integers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**b用于字节操作**：在**bload**（加载字节）等字节码指令中发现的**b**前缀表示对8位有符号字节整数的操作。'
- en: '**c for char operations**: Operations on 16-bit Unicode characters are represented
    by bytecode instructions starting with **c**, such as **caload** (the load array
    of **char**).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**c用于字符操作**：对16位Unicode字符的操作通过以**c**开头的字节码指令表示，例如**caload**（加载**char**数组）。'
- en: '**f for float operations**: The **f** prefix, seen in bytecode mnemonics such
    as **fload** (load float) or **fadd** (add float), signals operations involving
    32-bit single-precision floating point numbers.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f用于浮点操作**：在**fload**（加载浮点数）或**fadd**（加浮点数）等字节码助记符中看到的**f**前缀表示涉及32位单精度浮点数的运算。'
- en: '**d for double operations**: Double-precision floating point numbers (64-bit)
    are the focus of bytecode instructions starting with **d**, such as **dload**
    (load double) or **dmul** (multiply double).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d用于双精度操作**：双精度浮点数（64位）是字节码指令以**d**开头关注的焦点，例如**dload**（加载双精度）或**dmul**（乘双精度）。'
- en: '**a for reference operations**: Operations involving object references are
    represented by bytecode instructions starting with **a**, such as **aload** (load
    reference) or **areturn** (return reference).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**a用于引用操作**：涉及对象引用的运算通过以**a**开头的字节码指令表示，例如**aload**（加载引用）或**areturn**（返回引用）。'
- en: This systematic naming convention helps developers quickly identify the type
    of data being manipulated by a bytecode instruction. By recognizing the initial
    letter and associating it with a specific data type, developers can write more
    informed and precise code, ensuring that the bytecode operations align with the
    intended data types and behaviors within the JVM. This understanding is fundamental
    for mastering bytecode and optimizing Java applications for performance and reliability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统性的命名约定有助于开发者快速识别字节码指令所操作的数据类型。通过识别初始字母并将其与特定数据类型关联，开发者可以编写更明智和精确的代码，确保字节码操作与JVM中预期的数据类型和行为保持一致。这种理解对于掌握字节码和优化Java应用程序的性能和可靠性至关重要。
- en: 'In Java bytecode, Boolean values are typically represented using integers (`0`
    for `false` and `1` for `true`). However, it’s essential to note that Boolean
    values do not have dedicated bytecode instructions; instead, the standard integer
    arithmetic and logical instructions are used. For instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java字节码中，布尔值通常使用整数表示（`0`表示`false`，`1`表示`true`）。然而，需要注意的是，布尔值没有专门的字节码指令；相反，使用标准的整数算术和逻辑指令。例如：
- en: '**iadd**, **isub**, **imul**, **idiv**, and similar instructions work seamlessly
    with Boolean values'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iadd**、**isub**、**imul**、**idiv**以及类似的指令可以无缝地与布尔值一起工作'
- en: Logical operations such as *and* (**iand**), *or* (**ior**), and *xor* (**ixor**)
    can be used for Boolean logic
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算如*与*（**iand**）、*或*（**ior**）和*异或*（**ixor**）可用于布尔逻辑
- en: The key takeaway is that Boolean values are treated as integers in bytecode,
    allowing developers to use the same arithmetic and logical instructions for both
    numerical and Boolean computations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是布尔值在字节码中被视为整数，这使得开发者可以使用相同的算术和逻辑指令进行数值和布尔计算。
- en: Bytecode provides the groundwork for arithmetic operations, shaping the mathematical
    core of Java programs. Our journey continues in the next section, where we’ll
    delve into the intricate world of arithmetic operations in bytecode. We’ll dissect
    the instructions governing addition, subtraction, multiplication, and more, unraveling
    the bytecode sequences defining Java applications’ mathematical essence.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码为算术运算提供了基础，塑造了Java程序数学核心。我们的旅程将在下一节继续，我们将深入探讨字节码中算术运算的复杂世界。我们将剖析控制加法、减法、乘法等运算的指令，揭示定义Java应用程序数学本质的字节码序列。
- en: By understanding the arithmetic operations encoded in bytecode, developers gain
    insights into the inner workings of their code, enabling them to optimize performance
    and enhance efficiency. Join us in the next section to uncover the secrets behind
    arithmetic operations and pave the way for mastering the intricacies of the JVM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解字节码中编码的算术运算，开发者可以深入了解他们代码的内部工作原理，从而能够优化性能并提高效率。请加入我们下一节，揭开算术运算背后的秘密，为掌握JVM的复杂性铺平道路。
- en: Arithmetic operations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算
- en: 'In this section, we embark on a focused exploration of one of the cornerstone
    aspects of bytecode: arithmetic operations. These operations are the mathematical
    underpinnings that breathe life into Java programs, shaping the numerical landscape
    of computations within the JVM.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Bytecode arithmetic operations follow a fundamental principle: they operate
    on the first two values on the `operand` stack, performing the specified operation
    and returning the result to the stack. This session delves into the intricacies
    of bytecode arithmetic, shedding light on its nuances, behavior, and impact on
    program execution.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The arithmetic operations in bytecode are subdivided into two major categories:
    those involving floating point numbers and those dealing with integers. Each category
    exhibits distinct behaviors, and understanding these differences is crucial for
    Java developers seeking precision and reliability in their numerical computations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate the bytecode arithmetic terrain, we explore the instructions
    governing addition, subtraction, multiplication, and division for floats and integers.
    We dissect the bytecode sequences encapsulating these operations, clarifying their
    implementation and performance implications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Addition, subtraction, multiplication, and division
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fundamental arithmetic operations are the building blocks of numerical
    computations in Java. From adding integers (`iadd`) to dividing doubles (`ddiv`),
    each bytecode instruction is meticulously designed to handle specific data types.
    Uncover the nuances of adding, subtracting, multiplying, and dividing integers,
    longs, floats, and doubles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition**:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iadd**: Adds two integers'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ladd**: Adds two longs'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fadd**: Adds two floats'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dadd**: Adds two doubles'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtraction**:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isub**: Subtracts the second integer from the first'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lsub**: Subtracts the second long from the first'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fsub**: Subtracts the second float from the first'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dsub**: Subtracts the second double from the first'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplication**:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**imul**: Multiplies two integers'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lmul**: Multiplies two longs'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fmul**: Multiplies two floats'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dmul**: Multiplies two doubles'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division**:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**idiv**: Divides the first integer by the second'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ldiv**: Divides the first long by the second'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fdiv**: Divides the first float by the second'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ddiv**: Divides the first double by the second'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remainder and negation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Remainder (remainder)**:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**irem**: Computes the remainder of dividing the first integer by the second'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lrem**: Computes the remainder of dividing the first long by the second'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**frem**: Computes the remainder of dividing the first float by the second'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**drem**: Computes the remainder of dividing the first double by the second'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negation (negation)**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ineg**: Negates (changes the sign of) the integer'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lneg**: Negates the long'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fneg**: Negates the float'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dneg**: Negates the double'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shift and bitwise operations
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dive into the world of bitwise operations (`ior`, `iand`, `ixor`, `lor`, `land`,
    `lxor`) and shift operations (`ishl`, `ishr`, `iushr`, `lshl`, `lshr`, `lushr`).
    Discover how these operations manipulate individual bits, offering powerful tools
    for advanced computations and optimizations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 深入位运算（`ior`、`iand`、`ixor`、`lor`、`land`、`lxor`）和移位操作（`ishl`、`ishr`、`iushr`、`lshl`、`lshr`、`lushr`）的世界。了解这些操作如何操纵单个位，为高级计算和优化提供强大的工具：
- en: '**Shift** **operations (shift)**:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移位** **操作（移位）**:'
- en: '**ishl**, **ishr**, **iushr**: Shifts the bits of an integer to the left, right
    (with sign extension), or right (without sign extension)'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ishl**, **ishr**, **iushr**: 将整数的位向左、右（带符号扩展）或右（不带符号扩展）移动'
- en: '**lshl**, **lshr**, **lushr**: Shifts the bits of a long to the left, right
    (with sign extension), or right (without sign extension)'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lshl**, **lshr**, **lushr**: 将长整数的位向左、右（带符号扩展）或右（不带符号扩展）移动'
- en: '**Bitwise operations**:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位运算**:'
- en: '**ior**, **lor**: Bitwise *or* for integers and longs'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ior**, **lor**: 整数和长整数的位或'
- en: '**iand**, **land**: Bitwise *and* for integers and longs'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iand**, **land**: 整数和长整数的位与'
- en: '**ixor**, **lxor**: Bitwise exclusive *or* for integers and longs'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ixor**, **lxor**: 整数和长整数的位异或'
- en: Local variable increment
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量增量
- en: 'Unlock the potential of the `iinc` instruction, a subtle yet powerful operation
    that increments a local variable by a constant value. Learn how this bytecode
    instruction can enhance code readability and efficiency in specific scenarios:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁 `iinc` 指令的潜力，这是一个微妙但强大的操作，可以通过一个常量值增加局部变量。了解这个字节码指令如何在特定场景中提高代码的可读性和效率：
- en: '**Local variable increment** (**iinc**): **iinc** increments a local variable
    by a constant value'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量增量**（**iinc**）: **iinc** 通过一个常量值增加局部变量'
- en: Comparison operations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: 'Delve into the world of comparing values with instructions such as `cmpg`,
    `dcmpl`, `fcmpg`, `fcmpl`, and `lcmp`. Uncover the subtleties of yielding results
    such as 1, -1, or 0, indicating greater, less, or equal comparisons for doubles,
    floats, and longs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 深入比较值的世界，使用 `cmpg`、`dcmpl`、`fcmpg`、`fcmpl` 和 `lcmp` 等指令。揭示产生 1、-1 或 0 等结果的内幕，这些结果表示双精度浮点数、浮点数和长整数的比较结果：
- en: '**Comparison**:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较**:'
- en: '**dcmpg**, **dcmpl**: Compares two doubles, yielding 1, -1, or 0 (greater,
    less, or equal)'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dcmpg**, **dcmpl**: 比较两个双精度浮点数，返回 1、-1 或 0（表示大于、小于或等于）'
- en: '**fcmpg**, **fcmpl**: Compares two floats, yielding 1, -1, or 0 (greater, less,
    or equal)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fcmpg**, **fcmpl**: 比较两个浮点数，返回 1、-1 或 0（表示大于、小于或等于）'
- en: '**lcmp**: Compares two longs, yielding 1, -1, or 0 (greater, less, or equal)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lcmp**: 比较两个长整数，返回 1、-1 或 0（表示大于、小于或等于）'
- en: In the world of bytecode comparison, instructions such as `dcmpg` and `dcmpl`
    effectively compare double-precision floating point numbers, yielding 1, -1, or
    0 to signify greater, lesser, or equal comparisons. Similarly, `fcmpg` and `fcmpl`
    handle single-precision floats. However, when it comes to long integers, `lcmp`
    simplifies things by providing a single result of 1, -1, or 0, indicating greater,
    lesser, or equal comparisons. This streamlined approach optimizes long integer
    comparisons in bytecode.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码比较的世界中，`dcmpg` 和 `dcmpl` 指令有效地比较双精度浮点数，返回 1、-1 或 0 以表示大于、小于或等于比较。同样，`fcmpg`
    和 `fcmpl` 处理单精度浮点数。然而，当涉及到长整数时，`lcmp` 通过提供一个单一的 1、-1 或 0 的结果来简化事情，表示大于、小于或等于比较。这种简化的方法优化了字节码中的长整数比较。
- en: These bytecode instructions form the backbone of arithmetic and logical operations
    in Java programs. It’s crucial to note that the behavior of these operations may
    differ for integers and floating point numbers, especially when dealing with edge
    cases such as division by zero or overflow conditions. Understanding these bytecode
    instructions provides developers with the tools to craft precise and robust numerical
    computations in their Java applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码指令构成了 Java 程序中算术和逻辑操作的基础。需要注意的是，这些操作的行为可能因整数和浮点数而异，尤其是在处理除以零或溢出条件等边缘情况时。理解这些字节码指令为开发者提供了在
    Java 应用程序中构建精确且健壮数值计算的工具。
- en: After explaining the concept of bytecode and showcasing some arithmetic operations,
    we will delve deeper into the world of bytecode arithmetic within the JVM by examining
    a practical example. Our focus will be on understanding the process by analyzing
    a simple Java code snippet, which performs a basic arithmetic operation, i.e.,
    adding two integers. This hands-on exploration aims to unravel the intricate workings
    of bytecode arithmetic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了字节码的概念并展示了某些算术操作之后，我们将通过检查一个实际示例来深入探讨JVM内部的字节码算术世界。我们的重点是通过对一个简单的Java代码片段进行分析来理解这个过程，该代码片段执行基本的算术操作，即添加两个整数。这次动手探索旨在揭示字节码算术的复杂运作。
- en: 'Consider the following Java code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Java代码片段：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save the code in a file named `ArithmeticExample.java` and compile it using
    the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存到名为`ArithmeticExample.java`的文件中，并使用以下命令进行编译：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s use the `javap` command to disassemble the bytecode:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`javap`命令来反汇编字节码：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After executing the command, it will generate the output of the bytecode:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，它将生成字节码的输出：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following takes place in these bytecode instructions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些字节码指令中发生以下操作：
- en: '**iload_1**: Loads the value of the local variable **a** onto the stack'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iload_1**：将局部变量**a**的值加载到栈上'
- en: '**iload_2**: Loads the value of the local variable **b** onto the stack'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iload_2**：将局部变量**b**的值加载到栈上'
- en: '**iadd**: Adds the top two values on the stack (which are **a** and **b**)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iadd**：将栈顶的两个值（即**a**和**b**）相加'
- en: '**istore_3**: Stores the result of the addition back into the local variable
    result'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**istore_3**：将加法的结果存储回局部变量result'
- en: These bytecode instructions precisely reflect the arithmetic operation `int
    result = a + b`; in the Java code. The `iadd` instruction performs the addition
    of the loaded values, and the `istore_3` instruction stores the result back into
    a local variable for further use. Understanding this bytecode provides a detailed
    look at how the JVM executes a simple arithmetic operation in a Java program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码指令精确地反映了Java代码中的算术操作`int result = a + b`。`iadd`指令执行加载值的加法，而`istore_3`指令将结果存储回局部变量以供进一步使用。理解这些字节码提供了对JVM在Java程序中执行简单算术操作的详细视图。
- en: In our journey through bytecode arithmetic, we’ve dissected the seemingly mundane
    yet profoundly impactful process of adding two integers in a Java program. The
    bytecode instructions unveiled a hidden layer of intricacy, showcasing how high-level
    operations transform into machine-executable code within the **Java virtual**
    **machine** (**JVM**).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过字节码算术的旅程中，我们已经剖析了在Java程序中添加两个整数的看似平凡却又深刻影响的过程。字节码指令揭示了隐藏的复杂层，展示了高级操作如何在Java虚拟机（JVM）中转化为可执行的机器代码。
- en: 'As we close this section, our next destination awaits: the realm of value conversions.
    Understanding how different data types interact in bytecode is pivotal for crafting
    robust and efficient Java applications. In the upcoming section, let us delve
    into the intricacies of value conversions, unraveling the nuances of transforming
    data within the JVM. The journey continues, and each bytecode instruction brings
    us one step closer to mastering the depths of Java bytecode.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这一部分时，我们的下一个目的地等待着：值转换的领域。理解不同数据类型在字节码中的交互对于构建健壮和高效的Java应用程序至关重要。在下一节中，让我们深入探讨值转换的复杂性，揭示在JVM中转换数据的细微差别。旅程继续，每一行字节码指令都让我们更接近掌握Java字节码的深度。
- en: Value conversions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值转换
- en: 'In this section, we immerse ourselves in the intricate realm of value conversions
    within the JVM. These conversions serve as the chameleons of the bytecode landscape,
    enabling variables to transform their types gracefully by allowing integers to
    stretch into longs and floats to transcend into doubles without compromising the
    fidelity of their original values. The bytecode instructions that facilitate these
    metamorphoses are crucial in maintaining precision, preventing data loss, and
    ensuring the seamless integration of different data types. Join us as we dissect
    these instructions, uncovering the symphony of elegance and accuracy that underpins
    Java programming:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer to long** (**i2l**)**:** Explore how the **i2l** instruction promotes
    an integer variable to a long, preserving the original value’s precision'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer to float** (**i2f**)**:** Delve into the world of **i2f**, where
    an integer gracefully transforms into a float without sacrificing precision'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer to double** (**i2d**)**:** Witness the precision-preserving journey
    from integer to double through the **i2d** instruction'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long to float** (**l2f**) **and long to double** (**l2d**): Examine the elegance
    of **l2f** and **l2d**, where long values seamlessly transition to float and double,
    respectively'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float to Double** (**f2d**)**:** Explore the **f2d** instruction, showcasing
    the promotion of float to double while maintaining precision'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we navigate the intricacies of bytecode, we encounter a critical segment
    devoted to managing shortening—a delicate process marked by potential loss and
    overflow considerations. In this exploration, we delve into the bytecode instructions
    that transform variables into shorter data types, acknowledging the nuanced challenges
    associated with precision loss and overflow risks. Let us now explore this set
    of instructions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer to byte** (**i2b**), **integer to short** (**i2s**), **integer to
    char** (**i2c**): Investigate the potential precision loss as integers transform
    into byte, short, and char types through **i2b**, **i2s**, and **i2c** instructions'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long to integer** (**l2i**)**:** Examine the considerations involved in converting
    long to integer using the **l2i** instruction, acknowledging the possibility of
    overflow'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float to integer** (**f2i**), **float to long** (**f2l**)**:** Uncover the
    challenges of converting float to integer and long through **f2i** and **f2l**,
    taking note of precision and overflow concerns'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double to integer** (**d2i**), **double to long** (**d2l**), **double to
    float** (**d2f**)**:** Navigate through the **d2i**, **d2l**, and **d2f** instructions,
    understanding the delicate balance of precision and potential overflow in converting
    double to integer, long, and float'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the realm of bytecode intricacies, the following best practices serve as
    a compass guiding us through practical considerations. Here, we bridge theory
    and application, exploring the tangible implications of bytecode instructions
    on real-world Java programming scenarios. From preserving precision in complex
    arithmetic operations to navigating the flexibility of object-oriented design,
    these practical considerations illuminate the significance of understanding and
    mastering bytecode in the development landscape.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码的复杂性领域，以下最佳实践作为指南，引导我们通过实际考虑。在这里，我们连接理论和应用，探讨字节码指令对现实世界Java编程场景的实质性影响。从在复杂算术操作中保持精度到导航面向对象设计的灵活性，这些实际考虑照亮了理解和掌握字节码在开发领域中的重要性。
- en: '**Preserving precision in arithmetic:** Connect the dots between value conversions
    and arithmetic operations, ensuring precision is maintained in complex calculations'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持算术精度：**在值转换和算术操作之间建立联系，确保在复杂计算中保持精度'
- en: '**Handling object references:** Explore how value conversions contribute to
    the flexibility of object-oriented programming, allowing smooth transitions between
    classes and interfaces'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理对象引用：**探索值转换如何有助于面向对象编程的灵活性，允许在类和接口之间实现平滑过渡'
- en: As we decipher the bytecode instructions governing value conversions, the preceding
    points equip you with the insights needed to navigate the subtleties of transforming
    variable types within the JVM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在解码控制值转换的字节码指令时，前面的观点为您提供了导航变量类型在JVM内部转换细微差别的见解。
- en: 'In the following illustrative Java code sample, we spotlight value conversions,
    explicitly focusing on conventions that transform variable types within the JVM.
    The code snippet demonstrates the subtle dance of promotions and considerations
    for precision loss or overflow. As we traverse the bytecode results, our attention
    remains steadfast on the instructions that bring these conventions to life:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例Java代码片段中，我们聚焦于值转换，明确关注在JVM内部转换变量类型的约定。代码片段展示了提升和考虑精度损失或溢出的微妙舞蹈。随着我们遍历字节码结果，我们的注意力始终集中在使这些约定得以实现的指令上：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results are displayed as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the provided Java code in a file named `ValueConversionsExample.java`.
    Open your terminal or command prompt and navigate to the directory where the file
    is saved. Then, use the following command to compile the code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供的Java代码保存为名为`ValueConversionsExample.java`的文件。打开您的终端或命令提示符，导航到文件保存的目录。然后，使用以下命令编译代码：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After compiling, you can use the `javap` command to disassemble the bytecode
    and display the relevant parts. Execute the following command in the terminal
    or command prompt:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，您可以使用`javap`命令反汇编字节码并显示相关部分。在终端或命令提示符中执行以下命令：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this analysis, we focus on specific segments of bytecode to explore how Java
    code transforms into machine-executable instructions within the JVM. Our attention
    centers on selected bytecode parts, revealing the intricacies of promotions, precision
    considerations, and shortening in the realm of Java programming. Follow along
    as we decipher the language of the JVM, offering a visual narrative of the conventions
    that shape Java bytecode.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次分析中，我们专注于字节码的特定段，以探索Java代码如何在JVM内部转换为可执行指令。我们的注意力集中在选定的字节码部分，揭示了Java编程领域中提升、精度考虑和缩短的复杂性。随着我们解读JVM的语言，提供了一幅描绘塑造Java字节码约定的视觉叙事。
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this Java code, we witness both promotions and shortening conventions in
    action. The bytecode snippets focus specifically on the instructions associated
    with these conventions, providing a detailed look at how the JVM handles the enlargement
    and shortening of variable types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段Java代码中，我们可以看到提升和缩短约定在实际中的应用。字节码片段专门关注与这些约定相关的指令，详细展示了JVM如何处理变量类型的扩展和缩短。
- en: In our exploration of value conversions within the JVM, we’ve dissected the
    bytecode instructions orchestrating promotions and considerations for precision
    loss or overflow. These intricacies underscore the nuanced dance of data types
    in Java programming. As we conclude this segment, the seamless translation of
    high-level code to bytecode becomes clearer, revealing the meticulous choreography
    of the JVM. In the next section, we shift our focus to the captivating realm of
    object manipulation within bytecode, unraveling the threads that weave the tapestry
    of Java’s object-oriented paradigm. In this forthcoming journey, we’ll scrutinize
    bytecode instructions that mold and maneuver through objects, delving into the
    heart of dynamic, versatile Java programming.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Object manipulation
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this immersive session, we embark on a comprehensive exploration of object
    manipulation within the intricate fabric of Java bytecode. Our journey unveils
    the bytecode instructions instrumental in creating and manipulating instances,
    forging arrays, and accessing both static and instance attributes of a class.
    We scrutinize instructions that load values from arrays, save to the stack, inquire
    about array lengths, and perform crucial checks on instances or arrays. From the
    foundational `new` instruction to the dynamic intricacies of `multianewarray`,
    each bytecode command propels us deeper into the realm of object-oriented manipulation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In the bytecode tapestry of Java, the `new` instruction stands as a gateway
    to the realm of object creation and manipulation. It not only allocates memory
    for an object but also invokes its constructor, initiating the birth of a dynamic
    entity. Join us in this deep dive into the bytecode intricacies, where the seemingly
    simple `new` instruction unveils the foundational steps involved in bringing Java
    objects to life. As we dissect this bytecode command, the underlying symphony
    of memory allocation and constructor invocation becomes clearer, paving the way
    for a richer understanding of instance creation within the JVM.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**new**: This instantiates a new object, allocating memory and invoking the
    object’s constructor. The reference to the newly created object is placed on the
    stack.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the orchestration of Java bytecode, the commands for array creation emerge
    as a tapestry of versatility. In this segment, we delve into the bytecode instructions
    that sculpt arrays, offering a dynamic canvas for data storage. From the foundational
    `newarray` for primitive types to the nuanced `anewarray` for object references
    and the sophisticated `multianewarray` for multi-dimensional arrays, each bytecode
    instruction contributes to the vibrant array ecosystem within the JVM. As we dissect
    these commands, the artistry behind array instantiation within the JVM comes to
    light, opening the door to a deeper comprehension of data structure dynamics in
    Java programming.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**newarray**: Creates a new array of primitive types'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**anewarray**: Creates a new array of object references'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**multianewarray**: Creates a multi-dimensional array'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the intricate dance of Java bytecode, the instructions for accessing static
    or instance attributes of a class—`getfield`, `putfield`, `getstatic`, and `putstatic`—take
    center stage. From gracefully retrieving instance field values to dynamically
    setting static field values, each bytecode instruction contributes to the nuanced
    choreography of object-oriented programming. Join us in unraveling the elegance
    of bytecode access, where the delicate balance between instance and class attributes
    unfolds, revealing the underlying mechanisms that govern data manipulation within
    the JVM. As we dissect these instructions, the ballet of accessing class attributes
    comes alive, paving the way for a profound understanding of object-oriented intricacies
    in Java programming.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**getfield**: Retrieves the value of an instance field from an object'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**putfield**: Sets the value of an instance field in an object'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getstatic**: Retrieves the value of a static field from a class'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**putstatic**: Sets the value of a static field in a class'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the bytecode symphony of Java, the loading instructions — `baload`, `caload`,
    `saload`, `iaload`, `laload`, `faload`, `daload`, and `aaload` — take center stage,
    defining the choreography for retrieving values from arrays. In this segment,
    we immerse ourselves in the rhythmic bytecode commands that gracefully bring array
    elements to the forefront. From extracting bytes and characters to loading integers,
    longs, floats, doubles, and object references, each instruction plays a crucial
    role in the harmonious interaction between arrays and the JVM. These loading instructions
    unveil the orchestrated ballet that unfolds as Java bytecode seamlessly navigates
    through arrays, showcasing the versatility and precision of array element retrieval.
    As we explore these loading commands, the intricate dance of loading values from
    arrays comes alive, providing a deeper insight into the fluid dynamics of Java
    programming.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'In the bytecode masterpiece of Java, the saving instructions — `bastore`, `castore`,
    `sastore`, `iastore`, `lastore`, `fastore`, `dastore`, and `aastore` — intricately
    command the canvas of array manipulation. These instructions are pivotal for storing
    values into arrays of different types. Let’s delve into their significance with
    examples:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**bastore****:** Stores a byte or Boolean value into a byte array'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**castore****:** Stores a character value into a char array'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sastore****:** Stores a short value into a short array'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iastore****:** Stores an integer value into an int array'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lastore****:** Stores a long value into a long array'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dastore****:** Stores a double value into a double array'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions play a fundamental role in array manipulation, allowing for
    the precise storage of various data types within arrays.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The `arraylength` instruction serves as a compass in Java bytecode, guiding
    developers through the metrics of arrays by providing the length of the array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**arraylength**: Retrieves the length of an array and pushes it onto the stack.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the realm of Java bytecode, the instructions `instanceof` and `checkcast`
    serve as vigilant guardians, ensuring the integrity of object types and their
    alignment with specified classes. While our earlier exploration delved into array
    manipulation, let’s now shift our focus to these instructions’ essential roles
    in type checking. `Instanceof` assesses whether an object belongs to a particular
    class, providing crucial insights into object types. On the other hand, `checkcast`
    meticulously scrutinizes and casts objects, ensuring their harmonious alignment
    with designated classes. Together, these bytecode guardians play pivotal roles
    in maintaining the robustness and coherence of object-oriented paradigms within
    the JVM:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**instanceof**: Checks if an object is an instance of a particular class'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**checkcast**: Checks and casts an object to a given class, ensuring type compatibility'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These bytecode instructions provide the foundation for manipulating objects
    in Java, allowing for the creation, access, and modification of instances and
    arrays. Whether it’s instantiating new objects, working with arrays, accessing
    class attributes, or performing dynamic checks, each instruction contributes to
    the flexibility and power of object-oriented programming in Java bytecode. Understanding
    these instructions is key to mastering the intricacies of Java’s object manipulation
    capabilities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compile and display bytecode:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s focus on relevant parts of the bytecode that correspond to object manipulation,
    including object creation (`new`), attribute access (`getfield`, `putfield`),
    and method invocation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s break down the key bytecode instructions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Object creation (**new**):'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0: new #3**: Creates a new object of type **Person**'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3: dup**: Duplicates the object reference on the stack'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4: ldc #4**: Pushes the constant string **"John"** onto the stack'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**6: invokespecial #5**: Invokes the constructor (**<init>**) to initialize
    the object'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attribute access (**getfield, putfield**):'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1: getfield #2**: Retrieves the value of the **name** field'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2: putfield #2**: Sets the value of the **name** field'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method invocation:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**22: invokevirtual #9**: Invokes the **getName** method'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**31: invokevirtual #11**: Invokes the **setName** method'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These bytecode snippets highlight the fundamental instructions associated with
    object manipulation, offering insights into the dynamic nature of Java programming
    at the low-level bytecode level.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In navigating the bytecode tapestry of object manipulation within the simplified
    `Person` class, we’ve uncovered the orchestration of instructions governing object
    creation, attribute access, and method invocation. As the bytecode symphony unfolds,
    we transition seamlessly to the next segment, where we will delve into the dynamic
    realm of method calls and returns. Join us in deciphering the bytecode instructions
    that underpin the essence of method invocation, shedding light on the intricacies
    that define the flow of program execution within the JVM. As we move forward,
    the exploration of method calls and returns promises to enrich our understanding
    of the bytecode symphony, unveiling the next layer of Java programming intricacies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Method calls and returns
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us embark on a journey into the intricate dynamics of method calls and the
    nuanced return of values within the Java programming landscape. We will unveil
    the subtleties of dynamically invoking methods and agile invocation of interface
    methods and explore the distinctive chord of calling private or superclass methods
    and the powerful tone resonating from the invocation of static methods. Amidst
    this exploration, we will encounter the introduction of dynamic construction,
    showcasing the adaptability of Java programming. Remember the rhythm of value
    return is defined by specific instructions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring the symphony of method invocation in Java bytecode, the following
    instructions orchestrate various tones in the melody of method calls, each contributing
    uniquely to the language’s dynamic and versatile nature:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**invokevirtual:** Initiating the melody of method invocation, this instruction
    calls a method from an instance, providing the backbone for dynamic and polymorphic
    behavior in Java'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokeinterface:** Adding a harmonic note, this instruction calls a method
    from an interface, contributing to the flexibility and adaptability of Java’s
    object-oriented paradigm'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokespecial:** Introducing a distinctive chord, this instruction calls
    a private or superclass method, encapsulating privileged method invocations'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokestatic:** Striking a powerful tone, this instruction calls a static
    method, emphasizing the invocation of methods that don’t rely on instance creation'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokedynamic:** Playing a versatile tune, this instruction constructs an
    object dynamically, showcasing the dynamic capabilities of Java’s method invocation'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rhythm of method execution is complemented by return instructions (`ireturn`,
    `lreturn`, `freturn`, `dreturn`, and `areturn`), defining the cadence of values
    returned from methods. In the event of unexpected interruptions with exceptions,
    the `athrow` call takes center stage, managing the orchestration of error handling.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'We dive further into the intricacies of synchronous methods, where the monitor,
    marked by the `ACC_SYNCHRONIZED` flag, orchestrates a controlled dance. With the
    `monitorenter` instruction, the method enters the monitor, ensuring exclusive
    execution, and gracefully exits with `monitorexit` upon completion, crafting a
    synchronous symphony within the bytecode tapestry. Let’s now delve into a live
    demonstration of method calls and returns within Java code. The following is a
    simple Java program that performs calculations through method calls. We’ll then
    scrutinize the bytecode to decipher the orchestration of these method invocations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile and display bytecode:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the bytecode, we’ll focus on the instructions related to method calls (`invokevirtual`,
    `invokespecial`, `invokestatic`) and the return instructions (`ireturn`).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simplified excerpt compiled from `MethodCallsExample.java`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This bytecode excerpt showcases the essential instructions related to method
    calls and returns, providing a glimpse into the bytecode symphony of the provided
    Java code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: As we draw the curtains on our exploration of method calls and returns within
    the Java bytecode, we’ve uncovered the intricate dance of instructions orchestrating
    the flow of our program. The symphony of `invokevirtual`, `invokeinterface`, `invokespecial`,
    and `invokestatic` has echoed through our bytecode tapestry, showcasing the dynamic
    nature of method invocation and the rhythmic return of values. As we pivot to
    the next section, the spotlight shifts to conditional instructions, where bytecode
    decisions shape the course of program execution. Join us in decoding the bytecode
    intricacies of conditional statements, unraveling the logic that guides the JVM
    through pathways defined by conditions, and in our continuous journey through
    the depths of Java programming intricacies.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Conditional instructions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we delve into the nuanced realm of conditional instructions,
    unraveling the intricacies of decision-making within the JVM. These instructions
    form the backbone of conditional statements, guiding the JVM through pathways
    dictated by Boolean outcomes. Join us as we decipher the bytecode intricacies
    of conditional instructions, unveiling the logic that dynamically shapes program
    flow within the JVM. This exploration provides insights into the fundamental principles
    that govern the execution of conditional statements in Java programming.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the realm of Java bytecode unveils a set of instructions that intricately
    control conditional logic within the JVM. These commands stand as the architects
    of conditional statements, orchestrating precise decision-making and influencing
    program flow based on Boolean outcomes. This exploration peels back the layers
    of bytecode intricacies, offering insights into the dynamic pathways shaped by
    these fundamental instructions within the JVM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore a set of bytecode instructions that wield unique powers to control
    program flow and decision-making in Java. These instructions encompass a range
    of conditions, switches, and jumps, each playing a distinct role in directing
    the execution path of a Java program:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**ifeq:** Branches to the target instruction if the top value on the stack
    is equal to 0'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifne:** Branches to the target instruction if the top value on the stack
    is not equal to 0'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iflt:** Branches to the target instruction if the top value on the stack
    is less than 0'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifle:** Branches to the target instruction if the top value on the stack
    is less than or equal to 0'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifgt:** Branches to the target instruction if the top value on the stack
    is greater than 0'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifge:** Branches to the target instruction if the top value on the stack
    is greater than or equal to 0'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifnull:** Branches to the target instruction if the top value on the stack
    is null'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifnonnull:** Branches to the target instruction if the top value on the stack
    is not null'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpeq:** Branches to the target instruction if the two integer values
    on the stack are equal'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpne:** Branches to the target instruction if the two integer values
    on the stack are not equal'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmplt:** Branches to the target instruction if the second integer value
    on the stack is less than the first'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmple:** Branches to the target instruction if the second integer value
    on the stack is less than or equal to the first'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpgt:** Branches to the target instruction if the second integer value
    on the stack is greater than the first'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpge:** Branches to the target instruction if the second integer value
    on the stack is greater than or equal to the first'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_acmpeq:** Branches to the target instruction if the two object references
    on the stack are equal'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_acmpne:** Branches to the target instruction if the two object references
    on the stack are not equal'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tableswitch:** Provides a more efficient way to implement a switch statement
    with consecutive integer cases'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lookupswitch:** Similar to **tableswitch**, but supports sparse case values'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**goto:** Unconditionally branches to the target instruction'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**goto_w:** Unconditionally branches to the target instruction (wide index)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jsr:** Jumps to a subroutine, saving the return address on the stack'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jsr_w:** Jumps to a subroutine (wide index), saving the return address on
    the stack'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ret:** Returns from a subroutine, using the return address saved by a previous
    **jsr** instruction'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions play a crucial role in constructing conditional statements
    and controlling the flow of program execution based on various conditions and
    comparisons. Understanding their behavior is key to deciphering and optimizing
    Java bytecode.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile and display bytecode:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the bytecode, we’ll focus on conditional instructions, such as `ifeq`, `ifne`,
    and `if_acmpeq`, which handle the branching based on equality conditions. The
    following is a simplified excerpt:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Compiled from `ConditionalExample.java`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This bytecode excerpt showcases the conditional instructions (`if_icmpne` and
    `if_acmpeq`) in action, directing the program flow based on the equality conditions
    specified in the Java code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In this exploration of Java bytecode, we’ve deciphered the intricate dance of
    conditional instructions that shape the logic within the JVM. From branching based
    on equality to unconditional jumps, these bytecode commands have guided decision-making
    processes. As we conclude this section on *Conditional instructions*, the horizon
    broadens, leading us to the next leg of our journey. The upcoming segment delves
    into the bytecode representation of entire classes, unraveling the layers of instructions
    that encapsulate the essence of Java programs. Join us in this transition, where
    the focus expands from isolated conditions to the holistic view of classes in
    bytecode, illuminating the inner workings of Java’s runtime environment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Show me the bytecode
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our exploration of Java bytecode continues, we now set our sights on the
    entire class, a comprehensive dive into the binary representation of Java programs.
    It’s worth noting that the bytecode we examine may vary depending on the JVM version
    and the specific JVM vendor. In this session, we unravel the intricacies of compiling
    and examining the bytecode that encapsulates the essence of a complete Java class.
    From class initialization to method implementations, every facet of the class
    manifests in bytecode. Together, let us lift the veil on the holistic view of
    Java programs, exploring the nuances of how our code transforms into a language
    understood by the JVM.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'In our journey through Java bytecode, let’s begin by crafting a simple yet
    versatile `Animal` class. The following is the Java code snippet that defines
    the class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s navigate through the process of compiling and peering into the bytecode:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this, we embark on a fascinating exploration, compiling our Java class
    and unveiling the intricacies of bytecode that lie beneath the surface. Join us
    as we decode the language of the JVM and illuminate the bytecode representation
    of our `Animal` class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'This section of the bytecode output provides metadata about the compiled class
    file. Let’s break down the key information:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Last modified****:** Indicates the date of the last modification to the class
    file; in this case, it’s **November** **16, 2023**.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size****:** Specifies the size of the class file in bytes, which is **433**
    bytes in this instance.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SHA-256 checksum****:** Represents the SHA-256 checksum of the class file.
    This **checksum** serves as a unique identifier for the file and ensures its integrity.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiled from "Animal.java"****:** Informs us that this bytecode is compiled
    from the source file **Animal.java**.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class declaration****:** Declares the class named **Animal**.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version information****:**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**minor version**: Set to 0.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**major version**: Set to 65, indicating compatibility with Java 11.'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags****:** Displays hexadecimal flags indicating the access control modifiers
    applied to the class. In this case, it is a public class (**ACC_PUBLIC**) with
    additional properties (**ACC_SUPER**).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class hierarchy:**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**this_class**: Points to the constant pool index (**#8**) representing the
    current class, which is **Animal**.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**super_class**: Points to the constant pool index (**#2**) representing the
    superclass, which is **java/lang/Object**.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfaces, fields, methods, and attributes****:** Provides counts for these
    elements in the class.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This metadata offers a snapshot of the class file’s properties, including its
    version, access modifiers, and structural details.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Constant pool` section in the bytecode output provides a glimpse into
    the constant pool, a table of structures used to store various constants, such
    as strings, method and field references, class names, and more. Let’s decipher
    the entries in this constant pool:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will show field points here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Method reference to **Object**’s constructor:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#1 = Methodref #2.#3 //** **java/lang/Object."<init>":()V**'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This entry references the constructor of the **java/lang/Object** class, denoted
    as **<init>**. It indicates the initialization method that every class implicitly
    inherits from the **Object** class.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class reference to **Object** class:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#2 = Class #4 //** **java/lang/Object**'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Points to the class reference for **java/lang/Object**, indicating that the
    **Animal** class extends **Object**.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name and type for **Object**’s constructor:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#3 = NameAndType #5:#6 // "<****init>":()V**'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifies the name and type of the constructor (**<init>**) with no parameters
    and returns void.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entry for **Object** class name:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#4 =** **UTF-8 java/lang/Object**'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Represents the name of the **java/lang/Object** class in UTF-8 encoding.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entries for constructor and parameter type:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#5 =** **UTF-8 <init>**'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#6 =** **UTF-8 ()V**'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Denotes the constructor’s name (**<init>**) and its type (no parameters and
    returning void) in UTF-8 encoding.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Field reference to **Animal**’s **name** field:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#7 = Fieldref #8.#9 //** **Animal.name:Ljava/lang/String;**'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Refers to the **name** field in the **Animal** class, which is of type **java/lang/String**.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class reference to **Animal** class:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#8 = Class #10 //** **Animal**'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Points to the class reference for the **Animal** class.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name and type for the **name** field:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#9 = NameAndType #11:#12 //** **name:Ljava/lang/String;**'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifies the name and type of the **name** field: its name (**name**) and
    type (**String**).'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entry for **Animal** class name:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#10 =** **UTF-8 Animal**'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Represents the name of the **Animal** class in UTF-8 encoding.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entries for the **name** field:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#11 =** **UTF-8 name**'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#12 =** **UTF-8 Ljava/lang/String;**'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Denote the name of the **name** field and its type (**String**) in UTF-8 encoding.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar entries exist for the `age` field and `bark` method, referencing field
    and method names, their types, and class names in the constant pool. Overall,
    the constant pool is a crucial component for resolving symbolic references during
    the execution of the bytecode.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'The bytecode snippets provided represent the methods within the `Animal` class.
    Let’s break down each method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor method (**public Animal();**):'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()V** (no parameters, returns void)'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This constructor initializes the `Animal` object by invoking the constructor
    of its superclass (`Object`). The `aload_0` instruction loads the object reference
    (`this`) onto the stack, and `invokespecial` invokes the superclass constructor.
    The `LineNumberTable` indicates that this code corresponds to line `1` in the
    source file.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Method **public** **java.lang.String name();**:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()Ljava/lang/String;** (no parameters, returns **String**)'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method `name()` retrieves the value of the `name` field and returns it.
    `aload_0` loads the object reference (`this`), and `getfield` fetches the value
    of the `name` field. The `LineNumberTable` indicates that this code corresponds
    to line `9` in the source file.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Method **public** **int age();**:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()I** (no parameters, returns int)'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similar to the `name` method, this retrieves the value of the `age` field and
    returns it. `getfield` fetches the value, and `ireturn` returns it. The `LineNumberTable`
    indicates that this code corresponds to line `13` in the source file.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Method **public** **java.lang.String bark();**:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()Ljava/lang/String;** (no parameters, returns **String**)'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `bark()` method directly returns the string `woof` without accessing any
    fields. `ldc` loads a constant string and `areturn` returns it. The `LineNumberTable`
    indicates that this code corresponds to line `17` in the source file.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These bytecode snippets encapsulate the logic of each method within the `Animal`
    class, showcasing the low-level operations performed during method execution.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java bytecode, each variable and method parameter is assigned a type descriptor
    to indicate its data type. These descriptors are compact representations used
    to convey information about the variable type or parameter. Here’s a detailed
    explanation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**B** (**byte**): Represents a signed 8-bit integer'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C** (**char**): Denotes a Unicode character'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D** (**double**): Stands for a double-precision floating-point value'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F** (**float**): Represents a single-precision floating point value'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I** (**int**): Denotes a 32-bit integer'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**J** (**long**): Represents a 64-bit long integer'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L Classname** (**reference**): Points to an instance of the specified class;
    the fully qualified class name follows the **L** and ends with a semicolon'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S** (**short**): Represents a 16-bit short integer'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z** (**Boolean**): Indicates a Boolean value (true or false)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[** (**array reference**): Denotes an array. The type of the array elements
    is determined by additional characters following the **[**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For array references:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**[L Classname**: Represents an array of objects of the specified class'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[[B**: Represents a two-dimensional array of bytes'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These type descriptors are crucial when examining the bytecode instructions
    related to method declarations, field definitions, and variable usage within Java
    classes. They enable a concise representation of data types in the low-level bytecode
    representation of Java programs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude our exploration of Java bytecode and its intricate conditional
    instructions, readers have acquired a solid understanding of the nuanced control
    flow within Java programs. Armed with knowledge about bytecode’s decision-making
    capabilities, readers are well-equipped to optimize their code for efficiency
    and precision. The journey now propels us into the heart of the JVM with a focus
    on the execution engine in the upcoming chapter. Readers can anticipate delving
    into the mechanics of bytecode interpretation and the transformative realm of
    **just-in-time** (**JIT**) compilation. These skills are invaluable in real-life
    workplaces, where optimizing Java applications for performance is a critical task.
    Join us in unraveling the secrets of the JVM’s Execution Engine, where the binary
    dance of bytecode evolves into optimized machine instructions, empowering readers
    to enhance the runtime magic of Java applications.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Which bytecode instruction is used to compare if two integers are equal and
    branch accordingly?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ifeq**'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_icmpeq**'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_acmpeq**'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**tableswitch**'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the bytecode instruction **ifeq** do?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches if the top value on the stack is equal to 0
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches if two integers on the stack are equal
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Jumps to a subroutine
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Loads an integer from an array
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which bytecode instruction is used for unconditional branching?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**goto**'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ifne**'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**jsr_w**'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**lookupswitch**'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java bytecode, what does the **jsr** instruction do?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jumps to a subroutine
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls a static method
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compares two doubles
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches if the top value on the stack is null
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which bytecode instruction is used to check if two object references are not
    equal and branches to the target instruction?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_acmpeq**'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_acmpne**'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ifnull**'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**goto_w**'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: B. **if_icmpeq**
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Branches if the top value on the stack is equal to 0
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. **goto**
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Jumps to a subroutine
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. **if_acmpne**
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
