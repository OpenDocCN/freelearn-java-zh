- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Bytecodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the intricate world of the JVM, bytecode serves as the intermediary language
    that enables Java programs to transcend the boundaries of platform-specific hardware
    and operating systems. As we delve into the heart of JVM internals, this chapter
    focuses on deciphering the bytecode, a fundamental component in executing Java
    applications. Bytecode, represented as a set of instructions, acts as the bridge
    between high-level Java code and the machine-specific language of the underlying
    hardware. By comprehending bytecode, developers gain insights into the inner workings
    of the JVM, empowering them to optimize code performance and troubleshoot intricate
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: At the core of bytecode lies a diverse set of instructions that dictate the
    low-level operations performed by the JVM. This chapter unravels the nuances of
    arithmetic operations, shedding light on how the JVM handles mathematical calculations.
    From essential addition and subtraction to more complex procedures, we explore
    the bytecode instructions that govern these processes. Furthermore, we delve into
    value conversions, demystifying how the JVM transforms data between different
    types. Understanding these low-level operations is paramount for developers seeking
    to fine-tune their applications for optimal performance and efficiency. Join us
    on a journey into the bytecode realm, where the intricacies of arithmetic operations
    and value conversions pave the way for mastering the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode unveiled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bytecode unveiled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bytecode, a pivotal concept in Java programming, is the intermediary language
    that facilitates the cross-platform compatibility and execution of Java applications
    on the JVM. This session aims to demystify bytecode, providing a comprehensive
    overview of its significance, purpose, and the spectrum of operations it enables
    within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, bytecode acts as a bridge between high-level Java code and the
    machine-specific language of the underlying hardware. When a Java program is compiled,
    the source code is transformed into bytecode, a set of instructions comprehensible
    to the JVM. This platform-independent bytecode allows Java applications to execute
    seamlessly across diverse environments, a fundamental tenet of Java’s *Write Once,
    Run* *Anywhere* mantra.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we have bytecode? The answer lies in the portability and versatility
    it brings to Java applications. By introducing an intermediate step between the
    high-level source code and machine code, Java programs can run on any device equipped
    with a JVM, irrespective of its architecture or operating system. This abstraction
    shields developers from the intricacies of hardware-specific details, fostering
    a more universal and accessible programming environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s delve into the operations encoded within bytecode. Bytecode instructions
    cover a myriad of functionalities, ranging from basic load and save operations
    to intricate arithmetic calculations. The JVM’s stack-based architecture governs
    these operations, where values are pushed and popped onto and off the stack, forming
    the basis for data manipulation. Arithmetic operations, encompassing addition,
    subtraction, multiplication, and more, are executed through specific bytecode
    instructions, allowing developers to understand and optimize the mathematical
    underpinnings of their code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Value conversion**, another facet of bytecode operations, involves transforming
    data between different types. Whether converting integers to floating point numbers
    or managing other type transitions, bytecode instructions provide the foundation
    for these operations. This flexibility is crucial for developers crafting code
    and seamlessly handling diverse data types within the Java ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond this, bytecode orchestrates the creation and manipulation of objects,
    governs conditional statements, and manages the invocation and return of methods.
    Each bytecode instruction contributes to the overall execution flow of a Java
    program, and understanding these operations empowers developers to craft efficient,
    performant, and reliable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, understanding the bytecode behavior is crucial for navigating the intricacies
    of the JVM. Bytecode instructions are designed to operate on specific types of
    values, and recognizing the type being operated upon is fundamental to writing
    efficient and correct Java code. The initial letter of each bytecode mnemonic
    often serves as a valuable hint for discerning the type of operation being performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into this tip for recognizing the type of operation based on the
    initial letter of the bytecode mnemonic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i for integer operations**: Bytecodes starting with **i**, such as **iload**
    (load integer), **iadd** (add integer), or **isub** (subtract integer), signify
    operations involving integer values. These bytecode instructions manipulate data
    stored as 32-bit signed integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**l for long operations**: The **l** prefix, as seen in **lload** (load long)
    or **lmul** (multiply long), indicates operations on 64-bit signed long integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s for short operations**: Bytecodes beginning with **s**, for instance, **sload**
    (load short), are associated with operations on 16-bit signed short integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**b for byte operations**: The **b** prefix, found in bytecode instructions
    such as **bload** (load byte), denotes operations on 8-bit signed byte integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**c for char operations**: Operations on 16-bit Unicode characters are represented
    by bytecode instructions starting with **c**, such as **caload** (the load array
    of **char**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**f for float operations**: The **f** prefix, seen in bytecode mnemonics such
    as **fload** (load float) or **fadd** (add float), signals operations involving
    32-bit single-precision floating point numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**d for double operations**: Double-precision floating point numbers (64-bit)
    are the focus of bytecode instructions starting with **d**, such as **dload**
    (load double) or **dmul** (multiply double).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**a for reference operations**: Operations involving object references are
    represented by bytecode instructions starting with **a**, such as **aload** (load
    reference) or **areturn** (return reference).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This systematic naming convention helps developers quickly identify the type
    of data being manipulated by a bytecode instruction. By recognizing the initial
    letter and associating it with a specific data type, developers can write more
    informed and precise code, ensuring that the bytecode operations align with the
    intended data types and behaviors within the JVM. This understanding is fundamental
    for mastering bytecode and optimizing Java applications for performance and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java bytecode, Boolean values are typically represented using integers (`0`
    for `false` and `1` for `true`). However, it’s essential to note that Boolean
    values do not have dedicated bytecode instructions; instead, the standard integer
    arithmetic and logical instructions are used. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iadd**, **isub**, **imul**, **idiv**, and similar instructions work seamlessly
    with Boolean values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operations such as *and* (**iand**), *or* (**ior**), and *xor* (**ixor**)
    can be used for Boolean logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key takeaway is that Boolean values are treated as integers in bytecode,
    allowing developers to use the same arithmetic and logical instructions for both
    numerical and Boolean computations.
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode provides the groundwork for arithmetic operations, shaping the mathematical
    core of Java programs. Our journey continues in the next section, where we’ll
    delve into the intricate world of arithmetic operations in bytecode. We’ll dissect
    the instructions governing addition, subtraction, multiplication, and more, unraveling
    the bytecode sequences defining Java applications’ mathematical essence.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the arithmetic operations encoded in bytecode, developers gain
    insights into the inner workings of their code, enabling them to optimize performance
    and enhance efficiency. Join us in the next section to uncover the secrets behind
    arithmetic operations and pave the way for mastering the intricacies of the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we embark on a focused exploration of one of the cornerstone
    aspects of bytecode: arithmetic operations. These operations are the mathematical
    underpinnings that breathe life into Java programs, shaping the numerical landscape
    of computations within the JVM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bytecode arithmetic operations follow a fundamental principle: they operate
    on the first two values on the `operand` stack, performing the specified operation
    and returning the result to the stack. This session delves into the intricacies
    of bytecode arithmetic, shedding light on its nuances, behavior, and impact on
    program execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The arithmetic operations in bytecode are subdivided into two major categories:
    those involving floating point numbers and those dealing with integers. Each category
    exhibits distinct behaviors, and understanding these differences is crucial for
    Java developers seeking precision and reliability in their numerical computations.'
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate the bytecode arithmetic terrain, we explore the instructions
    governing addition, subtraction, multiplication, and division for floats and integers.
    We dissect the bytecode sequences encapsulating these operations, clarifying their
    implementation and performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: Addition, subtraction, multiplication, and division
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fundamental arithmetic operations are the building blocks of numerical
    computations in Java. From adding integers (`iadd`) to dividing doubles (`ddiv`),
    each bytecode instruction is meticulously designed to handle specific data types.
    Uncover the nuances of adding, subtracting, multiplying, and dividing integers,
    longs, floats, and doubles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iadd**: Adds two integers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ladd**: Adds two longs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fadd**: Adds two floats'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dadd**: Adds two doubles'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtraction**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isub**: Subtracts the second integer from the first'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lsub**: Subtracts the second long from the first'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fsub**: Subtracts the second float from the first'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dsub**: Subtracts the second double from the first'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplication**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**imul**: Multiplies two integers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lmul**: Multiplies two longs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fmul**: Multiplies two floats'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dmul**: Multiplies two doubles'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**idiv**: Divides the first integer by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ldiv**: Divides the first long by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fdiv**: Divides the first float by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ddiv**: Divides the first double by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remainder and negation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Remainder (remainder)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**irem**: Computes the remainder of dividing the first integer by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lrem**: Computes the remainder of dividing the first long by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**frem**: Computes the remainder of dividing the first float by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**drem**: Computes the remainder of dividing the first double by the second'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negation (negation)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ineg**: Negates (changes the sign of) the integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lneg**: Negates the long'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fneg**: Negates the float'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dneg**: Negates the double'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shift and bitwise operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dive into the world of bitwise operations (`ior`, `iand`, `ixor`, `lor`, `land`,
    `lxor`) and shift operations (`ishl`, `ishr`, `iushr`, `lshl`, `lshr`, `lushr`).
    Discover how these operations manipulate individual bits, offering powerful tools
    for advanced computations and optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shift** **operations (shift)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ishl**, **ishr**, **iushr**: Shifts the bits of an integer to the left, right
    (with sign extension), or right (without sign extension)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lshl**, **lshr**, **lushr**: Shifts the bits of a long to the left, right
    (with sign extension), or right (without sign extension)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise operations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ior**, **lor**: Bitwise *or* for integers and longs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iand**, **land**: Bitwise *and* for integers and longs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ixor**, **lxor**: Bitwise exclusive *or* for integers and longs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variable increment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlock the potential of the `iinc` instruction, a subtle yet powerful operation
    that increments a local variable by a constant value. Learn how this bytecode
    instruction can enhance code readability and efficiency in specific scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local variable increment** (**iinc**): **iinc** increments a local variable
    by a constant value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Delve into the world of comparing values with instructions such as `cmpg`,
    `dcmpl`, `fcmpg`, `fcmpl`, and `lcmp`. Uncover the subtleties of yielding results
    such as 1, -1, or 0, indicating greater, less, or equal comparisons for doubles,
    floats, and longs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparison**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dcmpg**, **dcmpl**: Compares two doubles, yielding 1, -1, or 0 (greater,
    less, or equal)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fcmpg**, **fcmpl**: Compares two floats, yielding 1, -1, or 0 (greater, less,
    or equal)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lcmp**: Compares two longs, yielding 1, -1, or 0 (greater, less, or equal)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the world of bytecode comparison, instructions such as `dcmpg` and `dcmpl`
    effectively compare double-precision floating point numbers, yielding 1, -1, or
    0 to signify greater, lesser, or equal comparisons. Similarly, `fcmpg` and `fcmpl`
    handle single-precision floats. However, when it comes to long integers, `lcmp`
    simplifies things by providing a single result of 1, -1, or 0, indicating greater,
    lesser, or equal comparisons. This streamlined approach optimizes long integer
    comparisons in bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: These bytecode instructions form the backbone of arithmetic and logical operations
    in Java programs. It’s crucial to note that the behavior of these operations may
    differ for integers and floating point numbers, especially when dealing with edge
    cases such as division by zero or overflow conditions. Understanding these bytecode
    instructions provides developers with the tools to craft precise and robust numerical
    computations in their Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: After explaining the concept of bytecode and showcasing some arithmetic operations,
    we will delve deeper into the world of bytecode arithmetic within the JVM by examining
    a practical example. Our focus will be on understanding the process by analyzing
    a simple Java code snippet, which performs a basic arithmetic operation, i.e.,
    adding two integers. This hands-on exploration aims to unravel the intricate workings
    of bytecode arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Java code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the code in a file named `ArithmeticExample.java` and compile it using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s use the `javap` command to disassemble the bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the command, it will generate the output of the bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following takes place in these bytecode instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iload_1**: Loads the value of the local variable **a** onto the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iload_2**: Loads the value of the local variable **b** onto the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iadd**: Adds the top two values on the stack (which are **a** and **b**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**istore_3**: Stores the result of the addition back into the local variable
    result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These bytecode instructions precisely reflect the arithmetic operation `int
    result = a + b`; in the Java code. The `iadd` instruction performs the addition
    of the loaded values, and the `istore_3` instruction stores the result back into
    a local variable for further use. Understanding this bytecode provides a detailed
    look at how the JVM executes a simple arithmetic operation in a Java program.
  prefs: []
  type: TYPE_NORMAL
- en: In our journey through bytecode arithmetic, we’ve dissected the seemingly mundane
    yet profoundly impactful process of adding two integers in a Java program. The
    bytecode instructions unveiled a hidden layer of intricacy, showcasing how high-level
    operations transform into machine-executable code within the **Java virtual**
    **machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we close this section, our next destination awaits: the realm of value conversions.
    Understanding how different data types interact in bytecode is pivotal for crafting
    robust and efficient Java applications. In the upcoming section, let us delve
    into the intricacies of value conversions, unraveling the nuances of transforming
    data within the JVM. The journey continues, and each bytecode instruction brings
    us one step closer to mastering the depths of Java bytecode.'
  prefs: []
  type: TYPE_NORMAL
- en: Value conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we immerse ourselves in the intricate realm of value conversions
    within the JVM. These conversions serve as the chameleons of the bytecode landscape,
    enabling variables to transform their types gracefully by allowing integers to
    stretch into longs and floats to transcend into doubles without compromising the
    fidelity of their original values. The bytecode instructions that facilitate these
    metamorphoses are crucial in maintaining precision, preventing data loss, and
    ensuring the seamless integration of different data types. Join us as we dissect
    these instructions, uncovering the symphony of elegance and accuracy that underpins
    Java programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer to long** (**i2l**)**:** Explore how the **i2l** instruction promotes
    an integer variable to a long, preserving the original value’s precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer to float** (**i2f**)**:** Delve into the world of **i2f**, where
    an integer gracefully transforms into a float without sacrificing precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer to double** (**i2d**)**:** Witness the precision-preserving journey
    from integer to double through the **i2d** instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long to float** (**l2f**) **and long to double** (**l2d**): Examine the elegance
    of **l2f** and **l2d**, where long values seamlessly transition to float and double,
    respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float to Double** (**f2d**)**:** Explore the **f2d** instruction, showcasing
    the promotion of float to double while maintaining precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we navigate the intricacies of bytecode, we encounter a critical segment
    devoted to managing shortening—a delicate process marked by potential loss and
    overflow considerations. In this exploration, we delve into the bytecode instructions
    that transform variables into shorter data types, acknowledging the nuanced challenges
    associated with precision loss and overflow risks. Let us now explore this set
    of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer to byte** (**i2b**), **integer to short** (**i2s**), **integer to
    char** (**i2c**): Investigate the potential precision loss as integers transform
    into byte, short, and char types through **i2b**, **i2s**, and **i2c** instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long to integer** (**l2i**)**:** Examine the considerations involved in converting
    long to integer using the **l2i** instruction, acknowledging the possibility of
    overflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float to integer** (**f2i**), **float to long** (**f2l**)**:** Uncover the
    challenges of converting float to integer and long through **f2i** and **f2l**,
    taking note of precision and overflow concerns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double to integer** (**d2i**), **double to long** (**d2l**), **double to
    float** (**d2f**)**:** Navigate through the **d2i**, **d2l**, and **d2f** instructions,
    understanding the delicate balance of precision and potential overflow in converting
    double to integer, long, and float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the realm of bytecode intricacies, the following best practices serve as
    a compass guiding us through practical considerations. Here, we bridge theory
    and application, exploring the tangible implications of bytecode instructions
    on real-world Java programming scenarios. From preserving precision in complex
    arithmetic operations to navigating the flexibility of object-oriented design,
    these practical considerations illuminate the significance of understanding and
    mastering bytecode in the development landscape.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preserving precision in arithmetic:** Connect the dots between value conversions
    and arithmetic operations, ensuring precision is maintained in complex calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling object references:** Explore how value conversions contribute to
    the flexibility of object-oriented programming, allowing smooth transitions between
    classes and interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we decipher the bytecode instructions governing value conversions, the preceding
    points equip you with the insights needed to navigate the subtleties of transforming
    variable types within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following illustrative Java code sample, we spotlight value conversions,
    explicitly focusing on conventions that transform variable types within the JVM.
    The code snippet demonstrates the subtle dance of promotions and considerations
    for precision loss or overflow. As we traverse the bytecode results, our attention
    remains steadfast on the instructions that bring these conventions to life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the provided Java code in a file named `ValueConversionsExample.java`.
    Open your terminal or command prompt and navigate to the directory where the file
    is saved. Then, use the following command to compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling, you can use the `javap` command to disassemble the bytecode
    and display the relevant parts. Execute the following command in the terminal
    or command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this analysis, we focus on specific segments of bytecode to explore how Java
    code transforms into machine-executable instructions within the JVM. Our attention
    centers on selected bytecode parts, revealing the intricacies of promotions, precision
    considerations, and shortening in the realm of Java programming. Follow along
    as we decipher the language of the JVM, offering a visual narrative of the conventions
    that shape Java bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this Java code, we witness both promotions and shortening conventions in
    action. The bytecode snippets focus specifically on the instructions associated
    with these conventions, providing a detailed look at how the JVM handles the enlargement
    and shortening of variable types.
  prefs: []
  type: TYPE_NORMAL
- en: In our exploration of value conversions within the JVM, we’ve dissected the
    bytecode instructions orchestrating promotions and considerations for precision
    loss or overflow. These intricacies underscore the nuanced dance of data types
    in Java programming. As we conclude this segment, the seamless translation of
    high-level code to bytecode becomes clearer, revealing the meticulous choreography
    of the JVM. In the next section, we shift our focus to the captivating realm of
    object manipulation within bytecode, unraveling the threads that weave the tapestry
    of Java’s object-oriented paradigm. In this forthcoming journey, we’ll scrutinize
    bytecode instructions that mold and maneuver through objects, delving into the
    heart of dynamic, versatile Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: Object manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this immersive session, we embark on a comprehensive exploration of object
    manipulation within the intricate fabric of Java bytecode. Our journey unveils
    the bytecode instructions instrumental in creating and manipulating instances,
    forging arrays, and accessing both static and instance attributes of a class.
    We scrutinize instructions that load values from arrays, save to the stack, inquire
    about array lengths, and perform crucial checks on instances or arrays. From the
    foundational `new` instruction to the dynamic intricacies of `multianewarray`,
    each bytecode command propels us deeper into the realm of object-oriented manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: In the bytecode tapestry of Java, the `new` instruction stands as a gateway
    to the realm of object creation and manipulation. It not only allocates memory
    for an object but also invokes its constructor, initiating the birth of a dynamic
    entity. Join us in this deep dive into the bytecode intricacies, where the seemingly
    simple `new` instruction unveils the foundational steps involved in bringing Java
    objects to life. As we dissect this bytecode command, the underlying symphony
    of memory allocation and constructor invocation becomes clearer, paving the way
    for a richer understanding of instance creation within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: '**new**: This instantiates a new object, allocating memory and invoking the
    object’s constructor. The reference to the newly created object is placed on the
    stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the orchestration of Java bytecode, the commands for array creation emerge
    as a tapestry of versatility. In this segment, we delve into the bytecode instructions
    that sculpt arrays, offering a dynamic canvas for data storage. From the foundational
    `newarray` for primitive types to the nuanced `anewarray` for object references
    and the sophisticated `multianewarray` for multi-dimensional arrays, each bytecode
    instruction contributes to the vibrant array ecosystem within the JVM. As we dissect
    these commands, the artistry behind array instantiation within the JVM comes to
    light, opening the door to a deeper comprehension of data structure dynamics in
    Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**newarray**: Creates a new array of primitive types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**anewarray**: Creates a new array of object references'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**multianewarray**: Creates a multi-dimensional array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the intricate dance of Java bytecode, the instructions for accessing static
    or instance attributes of a class—`getfield`, `putfield`, `getstatic`, and `putstatic`—take
    center stage. From gracefully retrieving instance field values to dynamically
    setting static field values, each bytecode instruction contributes to the nuanced
    choreography of object-oriented programming. Join us in unraveling the elegance
    of bytecode access, where the delicate balance between instance and class attributes
    unfolds, revealing the underlying mechanisms that govern data manipulation within
    the JVM. As we dissect these instructions, the ballet of accessing class attributes
    comes alive, paving the way for a profound understanding of object-oriented intricacies
    in Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**getfield**: Retrieves the value of an instance field from an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**putfield**: Sets the value of an instance field in an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getstatic**: Retrieves the value of a static field from a class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**putstatic**: Sets the value of a static field in a class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the bytecode symphony of Java, the loading instructions — `baload`, `caload`,
    `saload`, `iaload`, `laload`, `faload`, `daload`, and `aaload` — take center stage,
    defining the choreography for retrieving values from arrays. In this segment,
    we immerse ourselves in the rhythmic bytecode commands that gracefully bring array
    elements to the forefront. From extracting bytes and characters to loading integers,
    longs, floats, doubles, and object references, each instruction plays a crucial
    role in the harmonious interaction between arrays and the JVM. These loading instructions
    unveil the orchestrated ballet that unfolds as Java bytecode seamlessly navigates
    through arrays, showcasing the versatility and precision of array element retrieval.
    As we explore these loading commands, the intricate dance of loading values from
    arrays comes alive, providing a deeper insight into the fluid dynamics of Java
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the bytecode masterpiece of Java, the saving instructions — `bastore`, `castore`,
    `sastore`, `iastore`, `lastore`, `fastore`, `dastore`, and `aastore` — intricately
    command the canvas of array manipulation. These instructions are pivotal for storing
    values into arrays of different types. Let’s delve into their significance with
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bastore****:** Stores a byte or Boolean value into a byte array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**castore****:** Stores a character value into a char array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sastore****:** Stores a short value into a short array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iastore****:** Stores an integer value into an int array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lastore****:** Stores a long value into a long array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dastore****:** Stores a double value into a double array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions play a fundamental role in array manipulation, allowing for
    the precise storage of various data types within arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `arraylength` instruction serves as a compass in Java bytecode, guiding
    developers through the metrics of arrays by providing the length of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '**arraylength**: Retrieves the length of an array and pushes it onto the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the realm of Java bytecode, the instructions `instanceof` and `checkcast`
    serve as vigilant guardians, ensuring the integrity of object types and their
    alignment with specified classes. While our earlier exploration delved into array
    manipulation, let’s now shift our focus to these instructions’ essential roles
    in type checking. `Instanceof` assesses whether an object belongs to a particular
    class, providing crucial insights into object types. On the other hand, `checkcast`
    meticulously scrutinizes and casts objects, ensuring their harmonious alignment
    with designated classes. Together, these bytecode guardians play pivotal roles
    in maintaining the robustness and coherence of object-oriented paradigms within
    the JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '**instanceof**: Checks if an object is an instance of a particular class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**checkcast**: Checks and casts an object to a given class, ensuring type compatibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These bytecode instructions provide the foundation for manipulating objects
    in Java, allowing for the creation, access, and modification of instances and
    arrays. Whether it’s instantiating new objects, working with arrays, accessing
    class attributes, or performing dynamic checks, each instruction contributes to
    the flexibility and power of object-oriented programming in Java bytecode. Understanding
    these instructions is key to mastering the intricacies of Java’s object manipulation
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and display bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s focus on relevant parts of the bytecode that correspond to object manipulation,
    including object creation (`new`), attribute access (`getfield`, `putfield`),
    and method invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the key bytecode instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object creation (**new**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0: new #3**: Creates a new object of type **Person**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3: dup**: Duplicates the object reference on the stack'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4: ldc #4**: Pushes the constant string **"John"** onto the stack'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**6: invokespecial #5**: Invokes the constructor (**<init>**) to initialize
    the object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attribute access (**getfield, putfield**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1: getfield #2**: Retrieves the value of the **name** field'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2: putfield #2**: Sets the value of the **name** field'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method invocation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**22: invokevirtual #9**: Invokes the **getName** method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**31: invokevirtual #11**: Invokes the **setName** method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These bytecode snippets highlight the fundamental instructions associated with
    object manipulation, offering insights into the dynamic nature of Java programming
    at the low-level bytecode level.
  prefs: []
  type: TYPE_NORMAL
- en: In navigating the bytecode tapestry of object manipulation within the simplified
    `Person` class, we’ve uncovered the orchestration of instructions governing object
    creation, attribute access, and method invocation. As the bytecode symphony unfolds,
    we transition seamlessly to the next segment, where we will delve into the dynamic
    realm of method calls and returns. Join us in deciphering the bytecode instructions
    that underpin the essence of method invocation, shedding light on the intricacies
    that define the flow of program execution within the JVM. As we move forward,
    the exploration of method calls and returns promises to enrich our understanding
    of the bytecode symphony, unveiling the next layer of Java programming intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: Method calls and returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us embark on a journey into the intricate dynamics of method calls and the
    nuanced return of values within the Java programming landscape. We will unveil
    the subtleties of dynamically invoking methods and agile invocation of interface
    methods and explore the distinctive chord of calling private or superclass methods
    and the powerful tone resonating from the invocation of static methods. Amidst
    this exploration, we will encounter the introduction of dynamic construction,
    showcasing the adaptability of Java programming. Remember the rhythm of value
    return is defined by specific instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring the symphony of method invocation in Java bytecode, the following
    instructions orchestrate various tones in the melody of method calls, each contributing
    uniquely to the language’s dynamic and versatile nature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**invokevirtual:** Initiating the melody of method invocation, this instruction
    calls a method from an instance, providing the backbone for dynamic and polymorphic
    behavior in Java'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokeinterface:** Adding a harmonic note, this instruction calls a method
    from an interface, contributing to the flexibility and adaptability of Java’s
    object-oriented paradigm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokespecial:** Introducing a distinctive chord, this instruction calls
    a private or superclass method, encapsulating privileged method invocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokestatic:** Striking a powerful tone, this instruction calls a static
    method, emphasizing the invocation of methods that don’t rely on instance creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**invokedynamic:** Playing a versatile tune, this instruction constructs an
    object dynamically, showcasing the dynamic capabilities of Java’s method invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rhythm of method execution is complemented by return instructions (`ireturn`,
    `lreturn`, `freturn`, `dreturn`, and `areturn`), defining the cadence of values
    returned from methods. In the event of unexpected interruptions with exceptions,
    the `athrow` call takes center stage, managing the orchestration of error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We dive further into the intricacies of synchronous methods, where the monitor,
    marked by the `ACC_SYNCHRONIZED` flag, orchestrates a controlled dance. With the
    `monitorenter` instruction, the method enters the monitor, ensuring exclusive
    execution, and gracefully exits with `monitorexit` upon completion, crafting a
    synchronous symphony within the bytecode tapestry. Let’s now delve into a live
    demonstration of method calls and returns within Java code. The following is a
    simple Java program that performs calculations through method calls. We’ll then
    scrutinize the bytecode to decipher the orchestration of these method invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and display bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the bytecode, we’ll focus on the instructions related to method calls (`invokevirtual`,
    `invokespecial`, `invokestatic`) and the return instructions (`ireturn`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simplified excerpt compiled from `MethodCallsExample.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This bytecode excerpt showcases the essential instructions related to method
    calls and returns, providing a glimpse into the bytecode symphony of the provided
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: As we draw the curtains on our exploration of method calls and returns within
    the Java bytecode, we’ve uncovered the intricate dance of instructions orchestrating
    the flow of our program. The symphony of `invokevirtual`, `invokeinterface`, `invokespecial`,
    and `invokestatic` has echoed through our bytecode tapestry, showcasing the dynamic
    nature of method invocation and the rhythmic return of values. As we pivot to
    the next section, the spotlight shifts to conditional instructions, where bytecode
    decisions shape the course of program execution. Join us in decoding the bytecode
    intricacies of conditional statements, unraveling the logic that guides the JVM
    through pathways defined by conditions, and in our continuous journey through
    the depths of Java programming intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we delve into the nuanced realm of conditional instructions,
    unraveling the intricacies of decision-making within the JVM. These instructions
    form the backbone of conditional statements, guiding the JVM through pathways
    dictated by Boolean outcomes. Join us as we decipher the bytecode intricacies
    of conditional instructions, unveiling the logic that dynamically shapes program
    flow within the JVM. This exploration provides insights into the fundamental principles
    that govern the execution of conditional statements in Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the realm of Java bytecode unveils a set of instructions that intricately
    control conditional logic within the JVM. These commands stand as the architects
    of conditional statements, orchestrating precise decision-making and influencing
    program flow based on Boolean outcomes. This exploration peels back the layers
    of bytecode intricacies, offering insights into the dynamic pathways shaped by
    these fundamental instructions within the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore a set of bytecode instructions that wield unique powers to control
    program flow and decision-making in Java. These instructions encompass a range
    of conditions, switches, and jumps, each playing a distinct role in directing
    the execution path of a Java program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ifeq:** Branches to the target instruction if the top value on the stack
    is equal to 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifne:** Branches to the target instruction if the top value on the stack
    is not equal to 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iflt:** Branches to the target instruction if the top value on the stack
    is less than 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifle:** Branches to the target instruction if the top value on the stack
    is less than or equal to 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifgt:** Branches to the target instruction if the top value on the stack
    is greater than 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifge:** Branches to the target instruction if the top value on the stack
    is greater than or equal to 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifnull:** Branches to the target instruction if the top value on the stack
    is null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ifnonnull:** Branches to the target instruction if the top value on the stack
    is not null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpeq:** Branches to the target instruction if the two integer values
    on the stack are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpne:** Branches to the target instruction if the two integer values
    on the stack are not equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmplt:** Branches to the target instruction if the second integer value
    on the stack is less than the first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmple:** Branches to the target instruction if the second integer value
    on the stack is less than or equal to the first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpgt:** Branches to the target instruction if the second integer value
    on the stack is greater than the first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_icmpge:** Branches to the target instruction if the second integer value
    on the stack is greater than or equal to the first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_acmpeq:** Branches to the target instruction if the two object references
    on the stack are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if_acmpne:** Branches to the target instruction if the two object references
    on the stack are not equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tableswitch:** Provides a more efficient way to implement a switch statement
    with consecutive integer cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lookupswitch:** Similar to **tableswitch**, but supports sparse case values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**goto:** Unconditionally branches to the target instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**goto_w:** Unconditionally branches to the target instruction (wide index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jsr:** Jumps to a subroutine, saving the return address on the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jsr_w:** Jumps to a subroutine (wide index), saving the return address on
    the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ret:** Returns from a subroutine, using the return address saved by a previous
    **jsr** instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions play a crucial role in constructing conditional statements
    and controlling the flow of program execution based on various conditions and
    comparisons. Understanding their behavior is key to deciphering and optimizing
    Java bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and display bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the bytecode, we’ll focus on conditional instructions, such as `ifeq`, `ifne`,
    and `if_acmpeq`, which handle the branching based on equality conditions. The
    following is a simplified excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled from `ConditionalExample.java`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This bytecode excerpt showcases the conditional instructions (`if_icmpne` and
    `if_acmpeq`) in action, directing the program flow based on the equality conditions
    specified in the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: In this exploration of Java bytecode, we’ve deciphered the intricate dance of
    conditional instructions that shape the logic within the JVM. From branching based
    on equality to unconditional jumps, these bytecode commands have guided decision-making
    processes. As we conclude this section on *Conditional instructions*, the horizon
    broadens, leading us to the next leg of our journey. The upcoming segment delves
    into the bytecode representation of entire classes, unraveling the layers of instructions
    that encapsulate the essence of Java programs. Join us in this transition, where
    the focus expands from isolated conditions to the holistic view of classes in
    bytecode, illuminating the inner workings of Java’s runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: Show me the bytecode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our exploration of Java bytecode continues, we now set our sights on the
    entire class, a comprehensive dive into the binary representation of Java programs.
    It’s worth noting that the bytecode we examine may vary depending on the JVM version
    and the specific JVM vendor. In this session, we unravel the intricacies of compiling
    and examining the bytecode that encapsulates the essence of a complete Java class.
    From class initialization to method implementations, every facet of the class
    manifests in bytecode. Together, let us lift the veil on the holistic view of
    Java programs, exploring the nuances of how our code transforms into a language
    understood by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our journey through Java bytecode, let’s begin by crafting a simple yet
    versatile `Animal` class. The following is the Java code snippet that defines
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s navigate through the process of compiling and peering into the bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this, we embark on a fascinating exploration, compiling our Java class
    and unveiling the intricacies of bytecode that lie beneath the surface. Join us
    as we decode the language of the JVM and illuminate the bytecode representation
    of our `Animal` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section of the bytecode output provides metadata about the compiled class
    file. Let’s break down the key information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Last modified****:** Indicates the date of the last modification to the class
    file; in this case, it’s **November** **16, 2023**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size****:** Specifies the size of the class file in bytes, which is **433**
    bytes in this instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SHA-256 checksum****:** Represents the SHA-256 checksum of the class file.
    This **checksum** serves as a unique identifier for the file and ensures its integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiled from "Animal.java"****:** Informs us that this bytecode is compiled
    from the source file **Animal.java**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class declaration****:** Declares the class named **Animal**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version information****:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**minor version**: Set to 0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**major version**: Set to 65, indicating compatibility with Java 11.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags****:** Displays hexadecimal flags indicating the access control modifiers
    applied to the class. In this case, it is a public class (**ACC_PUBLIC**) with
    additional properties (**ACC_SUPER**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class hierarchy:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**this_class**: Points to the constant pool index (**#8**) representing the
    current class, which is **Animal**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**super_class**: Points to the constant pool index (**#2**) representing the
    superclass, which is **java/lang/Object**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfaces, fields, methods, and attributes****:** Provides counts for these
    elements in the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This metadata offers a snapshot of the class file’s properties, including its
    version, access modifiers, and structural details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Constant pool` section in the bytecode output provides a glimpse into
    the constant pool, a table of structures used to store various constants, such
    as strings, method and field references, class names, and more. Let’s decipher
    the entries in this constant pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show field points here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method reference to **Object**’s constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#1 = Methodref #2.#3 //** **java/lang/Object."<init>":()V**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This entry references the constructor of the **java/lang/Object** class, denoted
    as **<init>**. It indicates the initialization method that every class implicitly
    inherits from the **Object** class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class reference to **Object** class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#2 = Class #4 //** **java/lang/Object**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Points to the class reference for **java/lang/Object**, indicating that the
    **Animal** class extends **Object**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name and type for **Object**’s constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#3 = NameAndType #5:#6 // "<****init>":()V**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifies the name and type of the constructor (**<init>**) with no parameters
    and returns void.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entry for **Object** class name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#4 =** **UTF-8 java/lang/Object**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Represents the name of the **java/lang/Object** class in UTF-8 encoding.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entries for constructor and parameter type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#5 =** **UTF-8 <init>**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#6 =** **UTF-8 ()V**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Denotes the constructor’s name (**<init>**) and its type (no parameters and
    returning void) in UTF-8 encoding.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Field reference to **Animal**’s **name** field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#7 = Fieldref #8.#9 //** **Animal.name:Ljava/lang/String;**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Refers to the **name** field in the **Animal** class, which is of type **java/lang/String**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class reference to **Animal** class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#8 = Class #10 //** **Animal**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Points to the class reference for the **Animal** class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name and type for the **name** field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#9 = NameAndType #11:#12 //** **name:Ljava/lang/String;**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifies the name and type of the **name** field: its name (**name**) and
    type (**String**).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entry for **Animal** class name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#10 =** **UTF-8 Animal**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Represents the name of the **Animal** class in UTF-8 encoding.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UTF-8 entries for the **name** field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#11 =** **UTF-8 name**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#12 =** **UTF-8 Ljava/lang/String;**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Denote the name of the **name** field and its type (**String**) in UTF-8 encoding.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar entries exist for the `age` field and `bark` method, referencing field
    and method names, their types, and class names in the constant pool. Overall,
    the constant pool is a crucial component for resolving symbolic references during
    the execution of the bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bytecode snippets provided represent the methods within the `Animal` class.
    Let’s break down each method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor method (**public Animal();**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()V** (no parameters, returns void)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This constructor initializes the `Animal` object by invoking the constructor
    of its superclass (`Object`). The `aload_0` instruction loads the object reference
    (`this`) onto the stack, and `invokespecial` invokes the superclass constructor.
    The `LineNumberTable` indicates that this code corresponds to line `1` in the
    source file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Method **public** **java.lang.String name();**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()Ljava/lang/String;** (no parameters, returns **String**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The method `name()` retrieves the value of the `name` field and returns it.
    `aload_0` loads the object reference (`this`), and `getfield` fetches the value
    of the `name` field. The `LineNumberTable` indicates that this code corresponds
    to line `9` in the source file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Method **public** **int age();**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()I** (no parameters, returns int)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the `name` method, this retrieves the value of the `age` field and
    returns it. `getfield` fetches the value, and `ireturn` returns it. The `LineNumberTable`
    indicates that this code corresponds to line `13` in the source file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Method **public** **java.lang.String bark();**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptor**: **()Ljava/lang/String;** (no parameters, returns **String**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `bark()` method directly returns the string `woof` without accessing any
    fields. `ldc` loads a constant string and `areturn` returns it. The `LineNumberTable`
    indicates that this code corresponds to line `17` in the source file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These bytecode snippets encapsulate the logic of each method within the `Animal`
    class, showcasing the low-level operations performed during method execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java bytecode, each variable and method parameter is assigned a type descriptor
    to indicate its data type. These descriptors are compact representations used
    to convey information about the variable type or parameter. Here’s a detailed
    explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**B** (**byte**): Represents a signed 8-bit integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C** (**char**): Denotes a Unicode character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D** (**double**): Stands for a double-precision floating-point value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F** (**float**): Represents a single-precision floating point value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I** (**int**): Denotes a 32-bit integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**J** (**long**): Represents a 64-bit long integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L Classname** (**reference**): Points to an instance of the specified class;
    the fully qualified class name follows the **L** and ends with a semicolon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S** (**short**): Represents a 16-bit short integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z** (**Boolean**): Indicates a Boolean value (true or false)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[** (**array reference**): Denotes an array. The type of the array elements
    is determined by additional characters following the **[**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For array references:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[L Classname**: Represents an array of objects of the specified class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[[B**: Represents a two-dimensional array of bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These type descriptors are crucial when examining the bytecode instructions
    related to method declarations, field definitions, and variable usage within Java
    classes. They enable a concise representation of data types in the low-level bytecode
    representation of Java programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude our exploration of Java bytecode and its intricate conditional
    instructions, readers have acquired a solid understanding of the nuanced control
    flow within Java programs. Armed with knowledge about bytecode’s decision-making
    capabilities, readers are well-equipped to optimize their code for efficiency
    and precision. The journey now propels us into the heart of the JVM with a focus
    on the execution engine in the upcoming chapter. Readers can anticipate delving
    into the mechanics of bytecode interpretation and the transformative realm of
    **just-in-time** (**JIT**) compilation. These skills are invaluable in real-life
    workplaces, where optimizing Java applications for performance is a critical task.
    Join us in unraveling the secrets of the JVM’s Execution Engine, where the binary
    dance of bytecode evolves into optimized machine instructions, empowering readers
    to enhance the runtime magic of Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which bytecode instruction is used to compare if two integers are equal and
    branch accordingly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ifeq**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_icmpeq**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_acmpeq**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**tableswitch**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the bytecode instruction **ifeq** do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches if the top value on the stack is equal to 0
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches if two integers on the stack are equal
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Jumps to a subroutine
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Loads an integer from an array
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which bytecode instruction is used for unconditional branching?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**goto**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ifne**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**jsr_w**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**lookupswitch**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java bytecode, what does the **jsr** instruction do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jumps to a subroutine
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls a static method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compares two doubles
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Branches if the top value on the stack is null
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which bytecode instruction is used to check if two object references are not
    equal and branches to the target instruction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_acmpeq**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**if_acmpne**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ifnull**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**goto_w**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: B. **if_icmpeq**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Branches if the top value on the stack is equal to 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. **goto**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Jumps to a subroutine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. **if_acmpne**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
