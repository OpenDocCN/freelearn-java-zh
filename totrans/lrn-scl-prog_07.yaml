- en: Understanding Algebraic Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at some standard Scala effects and identified
    lots of similarities among them. We also promised to dive deeper and find out
    what principles underly these commonalities.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving deep into the ocean of abstractions, let's fish for the simpler
    concepts first to gain some familiarity and skill working with them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll take a look at a few abstract algebraic structures—structures that
    are fully identified by the laws defining them. We will start with a simpler yet
    usable abstraction and advance to more complex topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Semigroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foldable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available under our GitHub repository at:
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to abstract algebraic structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract algebraic structure is something that is fully defined by a set
    of laws. Abstract algebraic structures have their roots in category theory, a
    branch of mathematics dedicated to studying them.
  prefs: []
  type: TYPE_NORMAL
- en: The "abstractness" of the topic has two consequences for us. First, we need
    to get into a specific state of mind and talk about things in general as opposed
    to the concrete implementations that we were discussing up until now. Second,
    the structures we'll be looking at, the semigroup, monoid, group, and foldable, are
    applicable to a wide spectrum of cases, and each case can lead to the implementation
    of the abstract concept at hand. If this sounds too theoretical, don't worry;
    we'll get practical in a moment with `Semigroup`.
  prefs: []
  type: TYPE_NORMAL
- en: Semigroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Semigroup is probably the simplest yet most useful algebraic structure. It
    is fully defined by two qualities:'
  prefs: []
  type: TYPE_NORMAL
- en: It is defined for some (possibly infinite) set of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a binary operation defined for any pairs of elements in this set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also has the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The operation is closed, which means that the result of the operation belongs
    to the same set as its operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operation is associative, meaning that multiple operations should produce
    the same result, regardless of the order in which they are applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can translate these definitions into the Scala code almost literally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`S` denotes the type that the set elements belong to, and `op` denotes the
    operation. The result type is also `S`—we have defined the property of closeness
    of the operation on the type level. Formally, it is said that `S` *forms a semigroup
    under op*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Readers that are familiar with [Chapter 5](dba6e932-4169-4b60-9bde-26ac2073a1ab.xhtml), *Property-Based
    Testing in Scala*, will also remember that we talked about associativity as one
    of the ways to formulate `ScalaCheck` properties. It is very easy to define this
    property to check the second semigroup law in the same way we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need the `S` type to have a `Semigroup` and `Arbitrary`, the former of which
    we need to get the implementation we want to check and the latter to be able to
    generate random data for `S`.
  prefs: []
  type: TYPE_NORMAL
- en: The property itself, `sg.op(sg.op(a, b), c) == sg.op(a, sg.op(b, c))`, just
    verify that operations that are applied in a different order produce the same
    result—exactly as specified verbally.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that properties we define in this chapter can also be executed by
    running tests in SBT directly. To do this, it is enough to start the SBT session
    and type test followed by the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: OK, we now have a definition of a semigroup for `S` and a way to check that
    the semigroup is properly implemented, but what are these `S`'s? Well, this is
    the beauty of the abstract algebraic data structure. The `S` can be absolutely
    anything as long as semigroup laws hold. As an example, we can stick to our figure
    of speech regarding fishing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify at least two `eat` operations for `S` that are defined on all
    of the fish. The *the big* fish eats the little fish** operation is defined on
    two fish with the result that the bigger fish has a volume equal to the sum of
    the volumes of both fish participating in the operation. Similarly, *the heavy
    fish eats the light fish* is defined by the same principle but in terms of the
    fish''s weight. It''s easy to see that the first property of this semigroup holds
    by definition. The following diagrams represent the proof for the second property.
    The first diagram illustrates the associativity of the *Big eats small/Heavy eats
    light* operation on the fish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d9a645c-9ffa-49b2-9a8c-6ef69050c483.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Big fish eats small fish/Heavy fish eats light fish'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the same property for the *More teeth win* rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34508783-6cb4-417b-b87b-d0aec9c0d350.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: More teeth win'
  prefs: []
  type: TYPE_NORMAL
- en: 'This final illustration shows that associativity also holds for the property
    of toxicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90cab0be-a578-4c76-9789-90edfe538bc4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3\. Combinations of toxic fish
  prefs: []
  type: TYPE_NORMAL
- en: The semigroup operation does not need to be an addition. For instance, we can
    define it so that, from both participants, the most poisonous fish is on the left
    as a result. This book has no age restriction, so we should pretend that the second
    fish was scared away in the process. But experienced fishers know the creatures—instead,
    we have to constrain the semigroup for this operation to the set of all *living*
    fish, which allows us to avoid ambiguity for the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: As per our analogy, we could define another operation in terms of teeth—the
    fish with the bigger teeth is on the left as a result of the operation. Again,
    to avoid ambiguity, our semigroup is formed by *solid*, living fish under this
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the semigroups we just defined, we need a definition
    of fish. Let''s have it represented as a case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The relevant properties are represented as fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the big and small fish semigroup. The law checking property
    we defined previously requires an implicit semigroup in scope, so we''ll mark
    our instance as `implicit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can check which fish wins by comparing their volumes. The bigger fish incorporates
    the volume of the fish eaten during the operation.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, some of you must be scratching your heads, trying to remember
    why this structure looks so familiar. The astute reader will have already recognized
    the *type class pattern* we talked about in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml), *Getting
    to Know Implicits and Type* *Classes*. Good job, astute reader!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation is so simple that it cannot be incorrect, but for completeness''
    sake, let''s define a property for it. First, we need a generator for `Fish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement it by combining generators for single properties, exactly as we
    did in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml), *Getting to Know
    Implicits and Type* *Classes*. Now, defining the check itself boils down to importing
    the proper implicit and delegating to the property we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The definitions of the properties in this chapter cannot be pasted in REPL because
    they need to be placed in a test wrapper. Please see the accompanying code to
    see how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this property is also done in the same way as in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml), *Getting
    to Know Implicits and Type* *Classes*, so there should be no surprises here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Ouch, it turns out there are surprises! Our implementation does not satisfy
    the associativity requirements for the case where the fish have the same volume!
  prefs: []
  type: TYPE_NORMAL
- en: 'This little case demonstrates how important it is to check that an implementation
    of an abstract algebraic structure obeys the laws defined for it for all possible
    input values. In our case, we don''t actually have a proper semigroup implementation
    yet. Let''s fix that by pretending that the bigger fish incorporates all of the
    properties of the eaten one. This might look strange for the number of teeth and
    venom, but we''re talking about abstractions, after all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a slightly simpler semigroup implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the fish being of an equal volume, the right fish wins. This
    is a random choice, but this makes our semigroup right-biased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s retry our check (if you''re playing with the code in REPL, you''ll need
    to paste the definition of `fishGen` and `arbFish` again to apply them to the
    new definition of the `Fish`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This states that we are on the right track—it passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define and check other semigroups by analogy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code reflects our earlier discussion about how different attributes of
    the fish work during the operation. The definition is basically always the same;
    it just refers to the different properties of the fish! We omitted the definition
    of the `ScalaCheck` properties because they are identical to the ones we already
    looked at.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be a disappointment if semigroups were only useful in the realm of
    fishing. Let''s take a look at another example—mixing colored shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0429374-d3ba-44d6-8909-8994442e5541.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Colored circles with different transparency levels'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pick one of the following operations to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: Combine transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine colors (represented as textures on the image)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are represented in the following diagrams. The first addresses the transparency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61ba75dd-f89f-465b-8bfd-f9c3098f5890.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Combining transparencies'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is about combining shapes in a consistent way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/375c9416-1e59-4cd0-952d-41329bd02f4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Combining shapes'
  prefs: []
  type: TYPE_NORMAL
- en: 'This final diagram shows us that combining colors (fillings) produces the same
    result as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a3f80cc-3dc1-41c7-94d0-8e9c6a6e987c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Combining colors (fillings)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagrams provide proof that the associative law holds and that
    the closure property again holds by definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you noticed the commonality between both the fishing and shapes examples?
    We pick a numeric property of the entity and apply an operation to this property.
    For instance, all of our fishing examples can be reduced to just two cases: integer
    addition (for volume and weight) and integer comparison (for teeth and poisonousness).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we also can specify semigroups for these cases. The numbers form
    a semigroup under addition as well as under multiplication. We can demonstrate
    this with an example of the `Int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition is completely analogous to what we had before, and so is the
    result of the execution of the test command in SBT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings form semigroups under concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This semigroup is implemented entirely like the others, but conceptually this
    is a bit different from what we had before. In the case of a `String`, the operation
    is defined not in terms of some property but in terms of content. In a sense,
    we're defining a semigroup for the container of chars and the operation is specified
    as bringing the contents of both containers together in an ordered fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our fishing realm, a similar example would be a combination of two fish:
    one with caviar and one with milk, which would spawn a number of smaller fish
    as a result. This can''t be an example of a semigroup as long as we''re talking
    about single fish because the operation is not closed—we expect a single fish
    as a result, but the operation returns many of them. We can turn the situation
    around if we start to talk about buckets of fish. Combining two buckets, each
    with a single fish, will produce a bucket full of small fish. This operation is
    closed and if we can prove that it is associative, this would be a valid example
    of a semigroup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Switching perspectives from a single item to a container has another subtle
    effect: it is now possible to have an empty container (bucket) for any operation.
    In the situation where one of the operands is an empty container, the operation
    just returns another operand as a result. This makes our abstraction more powerful.
    It turns a semigroup into a monoid.'
  prefs: []
  type: TYPE_NORMAL
- en: Monoid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A monoid is a semigroup with an *identity* element. Formally, the identity element
    `z` is an element for which an equation, `z + x = x + z = x`, holds for any `x`.
    This equation is called identity property. Both closure and associativity properties
    that are defined for semigroups are also required to hold for a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existence of the identity property requires us to implement the monoid,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The check we specified for the semigroup also needs to be augmented for the
    monoid to verify that the new property holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define our first monoid, which will put all of the fish from the
    two buckets into a single bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we represent a `Bucket` with a `List` and just merge two buckets to denote
    that the contents of both have been put together. Are you curious to check if
    this implementation is a monoid? The property definition is unspectacular as it
    just delegates to the `monoidProp` we defined before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But, there is a bit of machinery underneath. First, we need to define a generator
    for buckets of fish so that we can use it to formulate a combined property of
    associativity and identity. Luckily, the property holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Are monoids only defined for containers? No, they're definitely not. Containers
    are just a special, comfortable case, because, in the majority of cases, it is
    obvious what should be an identity element of the corresponding monoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking away from containers and back to the colors example from the previous
    section, we can also pick an identity element for the operations we defined there
    to extend semigroups to monoids:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining transparency would require a fully transparent identity element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining shapes has an identity without a shape—a dot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining colors might have a white color as an identity (this identity element
    will make the color less saturated, but it won't change the color itself)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could even be creative and specify an identity element that's suitable for
    all of these operations—a fully transparent white-colored dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the other semigroups we''ve defined so far? From math, we know that
    natural numbers have identity elements for addition and multiplication, that is,
    zero and one, respectively. This allows us to upgrade the semigroups we implemented
    for ints to monoids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This definition is similar to the one we had for the semigroup—we've just added
    the identity element to it. The implementation of the property check is also identical
    to what we had before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, strings also form a monoid under concatenation and, as we noticed
    before, the identity element would be an empty container—a blank `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Another nice thing about containers is that it is actually possible to not only
    define an algebraic structure in terms of the container as a whole, but to the
    reuse existing algebraic structures that have been defined for its elements.
  prefs: []
  type: TYPE_NORMAL
- en: This is the real power of abstract algebraic structures—they compose!
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s cheat a bit and define a weightless and toothless
    non-poisonousness fish with zero volume as an identity element for our fishing
    examples. Here is a definition for the *big fish eats little fish* monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The monoids for the other three cases are implemented similarly by adding a
    `ZeroFish` as an identity element to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having this definition in scope, we can now implement the survival logic for
    two buckets of fish. First, we''ll form a pair of fish from both buckets, and
    then one fish from the pair should survive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define our monoid in terms of a simpler monoid. The operation itself
    is built from the original operation converted to the tuple form and is applied
    to the pairs of fish from both buckets. This is defined for buckets of size less
    or equal than `100` because the identity bucket for this operation needs to contain
    enough `ZeroFish` in the case that the buckets we're combining have a different
    number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test out different survival strategies just by having an instance
    of the desired monoid in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to import both monoids in scope so that the implicit resolution works
    properly. In this example, from every pair of fish, the more toxic fish will survive.
    This can easily be changed by bringing a different monoid into scope, for example,
    the `weightMonoid` gives heavier fish a chance of survival:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can check and see that the properties of the derived monoid hold. This can
    even be proved mathematically—by zipping two monoids, we created a product monoid,
    which has been proven to obey monoid laws.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting aspect of monoids and semigroups is their ability to be
    used to reduce any iterable collection to a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following is the `reduce` method that was defined for `IterableOnce`
    from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes an associative binary operator and applies it between all elements
    of the collection. The type signature tells us that it is a good application for
    a semigroup as its operation satisfies the requirements of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we generated a random bucket of fish and then applied
    the `poisonSemigroup` to it by specifying its operation as an argument for the
    `reduce` method.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, any semigroup operation is a perfect fit as soon as types match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the implementation of `reduce` throws an `UnsupportedOperationException`
    for empty collections, which makes it unsuitable for real functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There is a sibling of `reduce` called `reduceOption` that returns `None` for
    empty collections instead of throwing an exception, but this makes the whole result
    type optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of similar methods defined on `IterableOnce`. Grouping them
    together would allow us to represent the "reducibility" property as a standalone
    concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This does not look very nice because, as we have already discussed, the methods
    either throw an exception or introduce an effect of optionality. How could we
    improve this implementation? We could make use of the monoids' identity property!
  prefs: []
  type: TYPE_NORMAL
- en: Foldable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The monoid identity property allows us to handle empty collections in a general
    way. So, instead of having the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have a definition that takes an identity element as another parameter.
    By convention, this approach is called `fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the name `foldLeft` is that the identity element is used as
    an initial argument for reducing the collection, which leads to the following
    sequence of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, it is represented in postfix-notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Which is, well, kind of folding the collection, starting with the identity and
    the first element of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The associativity of the operation and the identity element tells us that another
    approach is also possible, starting from the identity and the last element of
    the collection and then moving toward its head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Folding in this direction is naturally called `foldRight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The same properties also give us the ability to fold the collection, starting
    from any place! This is particularly useful in a balanced fold, which works from
    both ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, both sides can be dealt with recursively, in that we can split
    each of them into two parts and use a balanced fold again. Even more interestingly,
    as the left and right sides are folded independently from each other, the folding
    can be done in parallel!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, as we did for `Reducible`, we can group these functions into
    yet another abstraction, `MonoidFoldable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we define it as a type class that is capable of folding collections
    of type `F` with elements of type `A`. For most of the existing collections, instances
    of this type class should be able to delegate the `foldLeft` and `foldRight` implementations
    to the `F`. Let''s demonstrate this with an instance of `ListMonoidFoldable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we require that type `A` is a monoid. Then, we get an instance
    of it by using the usual approach of calling implicitly. Then, we implement `foldRight`
    and `foldLeft` by calling the corresponding methods on the underlying `List`.
    Finally, we implement `foldBalanced` in a head-recursive manner. This implementation
    splits the list into two halves and folds them independently, exactly as we reasoned
    before. It is not done in parallel, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can improve on that aspect by utilizing the `Future` we discussed in the
    previous chapter. We introduced a new method, `foldPar`, which takes an additional
    `implicit` `ExecutionContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution context needs to pass over the moment we create a `Future` for
    our parallel computation. The structure of the method is similar to the `balancedFold`,
    since we have to split the collection into two parts and fold it recursively.
    This time, we limit the minimal number of items in the collection to be folded
    in parallel because it might be more computationally expensive to create a `Future`
    than to fold a handful of elements in a sequential manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, we've hardcoded the minimal number of elements eligible for
    parallel computation, but it can be passed over as a parameter. In the method
    itself, we either spawn a balanced fold in a separate thread if the collection
    is shorter than the limit or we initiate two parallel folds the same way we did
    before, but this time we use `Future.reduceLeft` to combine them together at the
    moment both computations are finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect `foldPar` to be quicker than other folds. Let''s write a property
    for that. This endeavor will be more involved than before. The reason for this
    is that the monoids we''ve to build so far are very simple and, because of that,
    very fast. Because of this, we won''t be able to see the advantages of parallelization—the
    price of spawning a `Future` will outweigh the folding itself. For our purposes,
    we''ll make our monoid a bit slower by adding a small delay to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Another point is that the list should be long enough, otherwise we won''t be
    really testing the parallelization feature. We need to create a dedicated generator
    for lists between 100 and 1,000 in length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a `helper` method to measure the execution time of the code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For `foldPar`, we also need an implicit execution context. We''ll use the global
    one as it is good enough for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the preparations out of the way, we can formulate our property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the body, we''ll first measure the execution time of different folding approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`foldPar` returns a `Future[Fish]` as the result, so we''re waiting for it
    to complete. Finally, we check that the result of all of folds is the same and
    that the parallel folding does not take more time than the other approaches. We
    label these properties appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our test and check that our implementation lives up to our
    expectations if tested in SBT session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that it does!
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say that it is possible to define other instances of the `MonoidFoldable`
    type class. Moreover, the collection does not need to be linear. As soon as it
    is possible to iterate over its elements, any structure will do—a binary tree,
    a map, a bag, or anything even more sophisticated. This possibility of being able
    to abstract over different data structures and to parallelize computations is
    what makes monoids especially useful in big data and distributed scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, we need to emphasize that `MonoidFoldable` can be made even
    more flexible and general-purpose. To understand how this can be done, we need
    to look once again at the definition of the fold process we gave earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can notice from this that the recursive operation takes two arguments and
    returns a result that becomes the first argument for the next iteration. This
    observation leads to the conclusion that the folding function does not need to
    have both arguments of the same type. As long as the return type is the same as
    the type of the first argument and the same as the type of the identity element,
    any function will be good for folding. This allows us to define a more generic
    `Foldable` abstraction that can convert elements of the collection and combine
    them at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach allows us to use any function, not only monoids, for folding.
    Of course, it is still possible to use existing monoid definitions, for example,
    by defining a method that would accept a monoid as an implicit parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This definition relies on the existence of some complementary function, `f`,
    which converts elements of the collection into the appropriate type before they
    can be combined using the monoid operation.
  prefs: []
  type: TYPE_NORMAL
- en: Looking in the opposite direction, abstract algebraic structures do not end
    with monoids. In fact, there are a lot of more advanced definitions out there
    like the group, abelian group, and ring.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a short look at the implementation of the group just to reinforce
    our understanding of the topic of algebraic structures.
  prefs: []
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A group adds an invertibility property to the properties of the monoid, which
    means that for every element, `a`, from the set, `S`, on which the group is defined,
    there is an inverse element so that the result of the operation on both of them
    is an identity element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formalized in the code, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ScalaCheck` property for this new law looks similar to the properties
    we defined for semigroup and monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we did previously, we can define an overarching check that aggregates
    single properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By adding a `commutative` *property* to the group, we'll get an abelian group.
    The `commutative` property states that for any two input elements, the order of
    arguments does not matter. For a group to be abelian, it does not need to implement
    anything; all it needs to do is satisfy this additional property!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our check definitions to incorporate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Again, we also define a single comprehensive property to check all of the laws
    of the abelian group at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of the abelian group is integer under addition. It can be implemented
    by extending the monoid we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties we defined previously can help to ensure that this is indeed
    a valid abelian group implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We will leave the reader with the task of executing these properties to check
    that our implementation is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of the abelian group concludes our discussion of abstract algebraic
    structures; that is, the structures solely defined by the laws they satisfy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at three such structures: semigroup, monoid, and group. The semigroup
    is defined by a binary operation that is closed and associative. The monoid adds
    to this an identity element so that the operation applied to it and another argument
    returns the second argument unchanged. The group extends monoids with an invertibility
    law, stating that for each element there should be another element so that the
    operation applied on them returns an identity element. If the operation defined
    by the group is commutative, the group is called abelian.'
  prefs: []
  type: TYPE_NORMAL
- en: We provided an example implementation for all these algebraic equations, along
    with `ScalaCheck` properties for verifying that our implementations are sane.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, our code is for demonstration purposes only, and because of
    this, it is quite simplistic.
  prefs: []
  type: TYPE_NORMAL
- en: There are at least two major functional programming libraries in the Scala ecosystem
    in which the concepts we discussed are implemented more rigorously—cats ([https://typelevel.org/cats/](https://typelevel.org/cats/)),
    and scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
    They are well-documented and regularly blogged and talked about, and provide a
    solid grounding for readers who are curious about using the notions we've talked
    about in real-life projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll work out our abstraction muscle by studying effects
    in general, extending the toolbox we started to fill in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*, with new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is the property of associativity that is essential for the monoid useful
    in a distributed setup?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a monoid for a `Boolean` under `OR`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a monoid for a `Boolean` under `AND`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a `Monoid[A]`, implement `Monoid[Option[A]]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a `Monoid[R]`, implement `Monoid[Either[L, R]].`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generalize two previous implementations for any effect parameterized by `A`,
    or describe why this is not possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atul S. Khot, *Scala Functional Programming Patterns*: Grok and performing effective
    functional programming in Scala
  prefs: []
  type: TYPE_NORMAL
- en: Ivan Nikolov, *Scala Design Patterns* - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala
  prefs: []
  type: TYPE_NORMAL
