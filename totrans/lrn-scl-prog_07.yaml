- en: Understanding Algebraic Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代数结构
- en: In the previous chapter, we looked at some standard Scala effects and identified
    lots of similarities among them. We also promised to dive deeper and find out
    what principles underly these commonalities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们查看了一些标准的Scala效果，并发现了它们之间许多相似之处。我们还承诺要深入挖掘，找出这些相似性背后的原则。
- en: Before diving deep into the ocean of abstractions, let's fish for the simpler
    concepts first to gain some familiarity and skill working with them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入抽象的海洋之前，让我们先去捕捉一些简单的概念，以便获得一些熟悉和操作它们的技能。
- en: In this chapter, we’ll take a look at a few abstract algebraic structures—structures that
    are fully identified by the laws defining them. We will start with a simpler yet
    usable abstraction and advance to more complex topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些抽象代数结构——这些结构完全由定义它们的法则所识别。我们将从一个更简单但可用的抽象开始，并逐步深入更复杂的话题。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Semigroup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半群
- en: Monoid
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单群
- en: Foldable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foldable
- en: Group
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保您已安装以下内容：
- en: Java 1.8+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 1.8+
- en: SBT 1.2+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: 'The source code for this chapter is available under our GitHub repository at:
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的GitHub仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07)。
- en: Introduction to abstract algebraic structures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象代数结构简介
- en: An abstract algebraic structure is something that is fully defined by a set
    of laws. Abstract algebraic structures have their roots in category theory, a
    branch of mathematics dedicated to studying them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代数结构是由一组法则完全定义的东西。抽象代数结构的根源在于范畴论，这是数学的一个分支，致力于研究这些结构。
- en: The "abstractness" of the topic has two consequences for us. First, we need
    to get into a specific state of mind and talk about things in general as opposed
    to the concrete implementations that we were discussing up until now. Second,
    the structures we'll be looking at, the semigroup, monoid, group, and foldable, are
    applicable to a wide spectrum of cases, and each case can lead to the implementation
    of the abstract concept at hand. If this sounds too theoretical, don't worry;
    we'll get practical in a moment with `Semigroup`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题的“抽象性”对我们有两个后果。首先，我们需要进入一种特定的思维状态，并就一般事物进行讨论，而不是我们现在所讨论的具体实现。其次，我们将要查看的结构，即半群、单群、群和Foldable，适用于广泛的案例，每个案例都可以导致抽象概念的实现。如果这听起来太理论化，请不要担心；我们将在
    `Semigroup` 中很快变得实用。
- en: Semigroup
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 半群
- en: 'Semigroup is probably the simplest yet most useful algebraic structure. It
    is fully defined by two qualities:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 半群可能是最简单但最有用的代数结构。它完全由两个特性定义：
- en: It is defined for some (possibly infinite) set of elements
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一些（可能是无限的）元素集合
- en: It has a binary operation defined for any pairs of elements in this set
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为这个集合中任意两个元素的任意对定义了二元运算
- en: 'It also has the following two properties:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有以下两个特性：
- en: The operation is closed, which means that the result of the operation belongs
    to the same set as its operands
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算是封闭的，这意味着运算的结果属于与操作数相同的集合
- en: The operation is associative, meaning that multiple operations should produce
    the same result, regardless of the order in which they are applied
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算是结合的，这意味着多次运算应该产生相同的结果，无论它们的操作顺序如何
- en: 'We can translate these definitions into the Scala code almost literally:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以逐字逐句地将这些定义翻译成Scala代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`S` denotes the type that the set elements belong to, and `op` denotes the
    operation. The result type is also `S`—we have defined the property of closeness
    of the operation on the type level. Formally, it is said that `S` *forms a semigroup
    under op*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`S` 表示集合元素所属的类型，`op` 表示运算。结果类型也是 `S`——我们在类型级别上定义了运算的封闭性。形式上，可以说 `S` 在 `op`
    下 *构成一个半群*。'
- en: 'Readers that are familiar with [Chapter 5](dba6e932-4169-4b60-9bde-26ac2073a1ab.xhtml), *Property-Based
    Testing in Scala*, will also remember that we talked about associativity as one
    of the ways to formulate `ScalaCheck` properties. It is very easy to define this
    property to check the second semigroup law in the same way we mentioned earlier:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉[第5章](dba6e932-4169-4b60-9bde-26ac2073a1ab.xhtml)，“Scala中的基于属性的测试”的读者也会记得我们提到结合律是制定`ScalaCheck`属性的一种方式。以我们之前提到的方式定义这个属性来检查第二个半群法是非常容易的：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need the `S` type to have a `Semigroup` and `Arbitrary`, the former of which
    we need to get the implementation we want to check and the latter to be able to
    generate random data for `S`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`S`类型具有`Semigroup`和`Arbitrary`，前者我们需要获取要检查的实现，后者能够为`S`生成随机数据。
- en: The property itself, `sg.op(sg.op(a, b), c) == sg.op(a, sg.op(b, c))`, just
    verify that operations that are applied in a different order produce the same
    result—exactly as specified verbally.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性本身，`sg.op(sg.op(a, b), c) == sg.op(a, sg.op(b, c))`，只是验证以不同顺序应用的操作会产生相同的结果——正如口头所述。
- en: Please note that properties we define in this chapter can also be executed by
    running tests in SBT directly. To do this, it is enough to start the SBT session
    and type test followed by the *Enter* key.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这章中定义的属性也可以通过在SBT中直接运行测试来执行。为此，只需启动SBT会话，然后按*Enter*键输入test。
- en: OK, we now have a definition of a semigroup for `S` and a way to check that
    the semigroup is properly implemented, but what are these `S`'s? Well, this is
    the beauty of the abstract algebraic data structure. The `S` can be absolutely
    anything as long as semigroup laws hold. As an example, we can stick to our figure
    of speech regarding fishing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在为`S`定义了一个半群以及检查半群是否正确实现的方法，但`S`是什么？嗯，这就是抽象代数数据结构的美丽之处。只要半群法则成立，`S`可以是任何东西。作为一个例子，我们可以坚持我们关于捕鱼的比喻。
- en: 'We can specify at least two `eat` operations for `S` that are defined on all
    of the fish. The *the big* fish eats the little fish** operation is defined on
    two fish with the result that the bigger fish has a volume equal to the sum of
    the volumes of both fish participating in the operation. Similarly, *the heavy
    fish eats the light fish* is defined by the same principle but in terms of the
    fish''s weight. It''s easy to see that the first property of this semigroup holds
    by definition. The following diagrams represent the proof for the second property.
    The first diagram illustrates the associativity of the *Big eats small/Heavy eats
    light* operation on the fish:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`S`指定至少两个定义在所有鱼上的`eat`操作。*大鱼吃小鱼*操作定义在两条鱼上，结果是较大的鱼的体积等于参与运算的两条鱼的体积之和。同样，*重鱼吃轻鱼*也是按照相同的原则定义的，但以鱼的重量为标准。很容易看出，这个半群的第一个属性按定义是成立的。以下图表代表了第二个属性的证明。第一个图表说明了*大鱼吃小鱼/重鱼吃轻鱼*操作的结合律：
- en: '![](img/8d9a645c-9ffa-49b2-9a8c-6ef69050c483.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d9a645c-9ffa-49b2-9a8c-6ef69050c483.png)'
- en: 'Figure 1: Big fish eats small fish/Heavy fish eats light fish'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：大鱼吃小鱼/重鱼吃轻鱼
- en: 'The following diagram illustrates the same property for the *More teeth win* rule:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了“牙齿越多越有利”规则的相同属性：
- en: '![](img/34508783-6cb4-417b-b87b-d0aec9c0d350.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34508783-6cb4-417b-b87b-d0aec9c0d350.png)'
- en: 'Figure 2: More teeth win'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：牙齿越多越有利
- en: 'This final illustration shows that associativity also holds for the property
    of toxicity:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的插图表明，结合律也适用于毒性属性：
- en: '![](img/90cab0be-a578-4c76-9789-90edfe538bc4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90cab0be-a578-4c76-9789-90edfe538bc4.png)'
- en: Figure 3\. Combinations of toxic fish
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：有毒鱼类的组合
- en: The semigroup operation does not need to be an addition. For instance, we can
    define it so that, from both participants, the most poisonous fish is on the left
    as a result. This book has no age restriction, so we should pretend that the second
    fish was scared away in the process. But experienced fishers know the creatures—instead,
    we have to constrain the semigroup for this operation to the set of all *living*
    fish, which allows us to avoid ambiguity for the result of the operation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 半群运算不一定是加法。例如，我们可以定义它，使得从两个参与者中，毒性最强的鱼位于左侧作为结果。这本书没有年龄限制，所以我们应该假装在这个过程中第二条鱼被吓跑了。但经验丰富的渔民知道这些生物——相反，我们必须将这个运算的半群约束在所有*活鱼*的集合中，这样我们就可以避免对运算结果的不确定性。
- en: As per our analogy, we could define another operation in terms of teeth—the
    fish with the bigger teeth is on the left as a result of the operation. Again,
    to avoid ambiguity, our semigroup is formed by *solid*, living fish under this
    operation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的类比，我们可以定义另一个以牙齿为术语的操作——操作结果中牙齿更大的鱼位于左侧。为了避免歧义，我们的半群由在这个操作下*坚固*、*活着的*鱼组成。
- en: 'In order to implement the semigroups we just defined, we need a definition
    of fish. Let''s have it represented as a case class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们刚刚定义的半群，我们需要一个鱼的定义。让我们将其表示为一个案例类：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The relevant properties are represented as fields.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相关属性表示为字段。
- en: 'Let''s start with the big and small fish semigroup. The law checking property
    we defined previously requires an implicit semigroup in scope, so we''ll mark
    our instance as `implicit`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从大鱼和小鱼的半群开始。我们之前定义的定律检查属性需要一个作用域内的隐式半群，所以我们将我们的实例标记为`implicit`：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can check which fish wins by comparing their volumes. The bigger fish incorporates
    the volume of the fish eaten during the operation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过比较它们的体积来检查哪条鱼获胜。在操作过程中，大鱼包含了被吃掉的鱼的体积。
- en: At the moment, some of you must be scratching your heads, trying to remember
    why this structure looks so familiar. The astute reader will have already recognized
    the *type class pattern* we talked about in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml), *Getting
    to Know Implicits and Type* *Classes*. Good job, astute reader!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你们中的一些人可能正在挠头，试图回忆为什么这个结构看起来如此熟悉。敏锐的读者已经在我们之前提到的[第4章](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)，“了解隐式和类型类”中识别出了*类型类模式*。干得好，敏锐的读者！
- en: 'Our implementation is so simple that it cannot be incorrect, but for completeness''
    sake, let''s define a property for it. First, we need a generator for `Fish`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现如此简单，以至于不可能出错，但为了完整性，让我们为它定义一个属性。首先，我们需要一个`Fish`的生成器：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We implement it by combining generators for single properties, exactly as we
    did in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml), *Getting to Know
    Implicits and Type* *Classes*. Now, defining the check itself boils down to importing
    the proper implicit and delegating to the property we defined previously:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过组合单个属性的生成器来实现它，正如我们在[第4章](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)，“了解隐式和类型类”中所做的那样。现在，定义检查本身归结为导入适当的隐式并将任务委托给之前定义的属性：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The definitions of the properties in this chapter cannot be pasted in REPL because
    they need to be placed in a test wrapper. Please see the accompanying code to
    see how it is done.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中属性的定义不能粘贴到REPL中，因为它们需要放置在测试包装器中。请参阅附带的代码以了解如何操作。
- en: 'Running this property is also done in the same way as in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml), *Getting
    to Know Implicits and Type* *Classes*, so there should be no surprises here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个属性的方式与[第4章](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)，“了解隐式和类型类”中相同，所以这里不应该有任何惊喜：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ouch, it turns out there are surprises! Our implementation does not satisfy
    the associativity requirements for the case where the fish have the same volume!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，结果发现还有惊喜！我们的实现不满足相同体积的鱼的情况下的结合律要求！
- en: 'This little case demonstrates how important it is to check that an implementation
    of an abstract algebraic structure obeys the laws defined for it for all possible
    input values. In our case, we don''t actually have a proper semigroup implementation
    yet. Let''s fix that by pretending that the bigger fish incorporates all of the
    properties of the eaten one. This might look strange for the number of teeth and
    venom, but we''re talking about abstractions, after all:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小案例展示了检查一个抽象代数结构的实现是否遵守为其定义的定律对于所有可能的输入值是多么重要。在我们的情况下，我们实际上还没有一个合适的半群实现。让我们通过假装大鱼包含了被吃掉鱼的全部属性来解决这个问题。这可能会让牙齿和毒液的数量看起来很奇怪，但毕竟我们是在谈论抽象：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us a slightly simpler semigroup implementation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了一个稍微简单一些的半群实现：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the case of the fish being of an equal volume, the right fish wins. This
    is a random choice, but this makes our semigroup right-biased.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在鱼体积相等的情况下，右边的鱼获胜。这是一个随机选择，但这使我们的半群具有右偏置。
- en: 'Let''s retry our check (if you''re playing with the code in REPL, you''ll need
    to paste the definition of `fishGen` and `arbFish` again to apply them to the
    new definition of the `Fish`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重试我们的检查（如果你在REPL中玩代码，你需要再次粘贴`fishGen`和`arbFish`的定义以应用它们到新的`Fish`定义）：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This states that we are on the right track—it passes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们正在正确的道路上——它通过了。
- en: 'We can define and check other semigroups by analogy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过类比定义和检查其他半群：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code reflects our earlier discussion about how different attributes of
    the fish work during the operation. The definition is basically always the same;
    it just refers to the different properties of the fish! We omitted the definition
    of the `ScalaCheck` properties because they are identical to the ones we already
    looked at.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码反映了我们之前关于鱼在操作期间不同属性如何工作的讨论。定义基本上总是相同的；它只是指代了鱼的不同属性！我们省略了`ScalaCheck`属性的定义，因为它们与我们之前查看的属性相同。
- en: 'It would be a disappointment if semigroups were only useful in the realm of
    fishing. Let''s take a look at another example—mixing colored shapes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果半群只在捕鱼领域有用，那将是个失望。让我们看看另一个例子——混合彩色形状：
- en: '![](img/e0429374-d3ba-44d6-8909-8994442e5541.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0429374-d3ba-44d6-8909-8994442e5541.png)'
- en: 'Figure 3: Colored circles with different transparency levels'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：不同透明度级别的彩色圆圈
- en: 'We can pick one of the following operations to work with:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择以下操作之一来工作：
- en: Combine transparency
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合透明度
- en: Combine shapes
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合形状
- en: Combine colors (represented as textures on the image)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合颜色（在图像上表示为纹理）
- en: 'These are represented in the following diagrams. The first addresses the transparency:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在以下图中表示。第一个关注透明度：
- en: '![](img/61ba75dd-f89f-465b-8bfd-f9c3098f5890.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61ba75dd-f89f-465b-8bfd-f9c3098f5890.png)'
- en: 'Figure 4: Combining transparencies'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：组合透明度
- en: 'The second is about combining shapes in a consistent way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是关于以一致方式组合形状：
- en: '![](img/375c9416-1e59-4cd0-952d-41329bd02f4b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/375c9416-1e59-4cd0-952d-41329bd02f4b.png)'
- en: 'Figure 5: Combining shapes'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：组合形状
- en: 'This final diagram shows us that combining colors (fillings) produces the same
    result as well:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这张最后的图表明，结合颜色（填充）会产生与之前相同的结果：
- en: '![](img/0a3f80cc-3dc1-41c7-94d0-8e9c6a6e987c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a3f80cc-3dc1-41c7-94d0-8e9c6a6e987c.png)'
- en: 'Figure 6: Combining colors (fillings)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：组合颜色（填充）
- en: The preceding diagrams provide proof that the associative law holds and that
    the closure property again holds by definition.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图提供了证明结合律成立，并且闭包性质再次由定义成立的证据。
- en: 'Have you noticed the commonality between both the fishing and shapes examples?
    We pick a numeric property of the entity and apply an operation to this property.
    For instance, all of our fishing examples can be reduced to just two cases: integer
    addition (for volume and weight) and integer comparison (for teeth and poisonousness).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到捕鱼和形状示例之间的共性？我们选择实体的一个数值属性，并对此属性应用操作。例如，我们所有的捕鱼示例都可以简化为两种情况：整数加法（体积和重量）和整数比较（牙齿和毒性）。
- en: 'Of course, we also can specify semigroups for these cases. The numbers form
    a semigroup under addition as well as under multiplication. We can demonstrate
    this with an example of the `Int` type:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以为这些情况指定半群。数字在加法和乘法下都形成半群。我们可以用一个`Int`类型的例子来展示这一点：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This definition is completely analogous to what we had before, and so is the
    result of the execution of the test command in SBT:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与之前我们所拥有的完全类似，因此SBT中执行测试命令的结果也是如此：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Strings form semigroups under concatenation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在连接下形成半群：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This semigroup is implemented entirely like the others, but conceptually this
    is a bit different from what we had before. In the case of a `String`, the operation
    is defined not in terms of some property but in terms of content. In a sense,
    we're defining a semigroup for the container of chars and the operation is specified
    as bringing the contents of both containers together in an ordered fashion.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个半群完全像其他半群一样实现，但在概念上这与我们之前所拥有的略有不同。在`String`的情况下，操作不是基于某个属性，而是基于内容定义的。从某种意义上说，我们正在定义一个关于字符容器和操作的半群，操作被指定为以有序方式将两个容器的内容结合起来。
- en: 'In our fishing realm, a similar example would be a combination of two fish:
    one with caviar and one with milk, which would spawn a number of smaller fish
    as a result. This can''t be an example of a semigroup as long as we''re talking
    about single fish because the operation is not closed—we expect a single fish
    as a result, but the operation returns many of them. We can turn the situation
    around if we start to talk about buckets of fish. Combining two buckets, each
    with a single fish, will produce a bucket full of small fish. This operation is
    closed and if we can prove that it is associative, this would be a valid example
    of a semigroup.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的捕鱼领域，一个类似的例子是两种鱼的组合：一种含有鱼子酱，另一种含有牛奶，这会产生许多小鱼作为结果。只要我们谈论的是单条鱼，这就不能作为一个半群的例子，因为操作不是封闭的——我们期望得到一条鱼作为结果，但操作返回了许多条。如果我们开始谈论鱼桶，情况就不同了。将两个装有单条鱼的桶组合起来，将产生一个装满小鱼的大桶。这个操作是封闭的，如果我们能证明它是结合的，这将是一个有效的半群例子。
- en: 'Switching perspectives from a single item to a container has another subtle
    effect: it is now possible to have an empty container (bucket) for any operation.
    In the situation where one of the operands is an empty container, the operation
    just returns another operand as a result. This makes our abstraction more powerful.
    It turns a semigroup into a monoid.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个项目到容器的视角转换还有另一个微妙的影响：现在可以为任何操作有一个空容器（桶）。在其中一个操作数是空容器的情况下，操作只返回另一个操作数作为结果。这使得我们的抽象更强大。它将半群转化为幺半群。
- en: Monoid
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幺半群
- en: A monoid is a semigroup with an *identity* element. Formally, the identity element
    `z` is an element for which an equation, `z + x = x + z = x`, holds for any `x`.
    This equation is called identity property. Both closure and associativity properties
    that are defined for semigroups are also required to hold for a monoid.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群是一个带有*单位*元素的半群。形式上，单位元素`z`是一个元素，对于任何`x`，方程`z + x = x + z = x`都成立。这个方程被称为单位属性。为半群定义的封闭性和结合性属性也必须对幺半群成立。
- en: 'The existence of the identity property requires us to implement the monoid,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 单位属性的存在要求我们实现幺半群，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The check we specified for the semigroup also needs to be augmented for the
    monoid to verify that the new property holds:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为半群指定的检查也需要增强，以验证新的属性在幺半群中是否成立：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can define our first monoid, which will put all of the fish from the
    two buckets into a single bucket:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的第一个幺半群，它将把两个桶中的所有鱼放入一个桶中：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we represent a `Bucket` with a `List` and just merge two buckets to denote
    that the contents of both have been put together. Are you curious to check if
    this implementation is a monoid? The property definition is unspectacular as it
    just delegates to the `monoidProp` we defined before:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用`List`来表示`Bucket`，只是合并两个桶来表示两个桶的内容已经被合并在一起。你好奇要检查这个实现是否是一个幺半群吗？属性定义并不引人注目，因为它只是委托给之前定义的`monoidProp`：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But, there is a bit of machinery underneath. First, we need to define a generator
    for buckets of fish so that we can use it to formulate a combined property of
    associativity and identity. Luckily, the property holds:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，下面有一套机制。首先，我们需要定义一个鱼桶的生成器，这样我们就可以用它来制定结合性和单位性的组合属性。幸运的是，这个属性是成立的：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Are monoids only defined for containers? No, they're definitely not. Containers
    are just a special, comfortable case, because, in the majority of cases, it is
    obvious what should be an identity element of the corresponding monoid.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群是否只定义在容器上？不，绝对不是。容器只是一个特殊、舒适的例子，因为在大多数情况下，显然应该有一个单位元素作为相应幺半群的单位。
- en: 'Looking away from containers and back to the colors example from the previous
    section, we can also pick an identity element for the operations we defined there
    to extend semigroups to monoids:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器上移开目光，回到上一节中的颜色示例，我们还可以为那里定义的操作选择一个单位元素，以将半群扩展到幺半群：
- en: Combining transparency would require a fully transparent identity element
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合透明度需要一个完全透明的单位元素
- en: Combining shapes has an identity without a shape—a dot
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合形状有一个没有形状的单位——一个点
- en: Combining colors might have a white color as an identity (this identity element
    will make the color less saturated, but it won't change the color itself)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合颜色可能有一个白色作为单位（这个单位元素会使颜色不那么饱和，但不会改变颜色本身）
- en: We could even be creative and specify an identity element that's suitable for
    all of these operations—a fully transparent white-colored dot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以富有创意，指定一个适合所有这些操作的单位元素——一个完全透明的白色点。
- en: 'How about the other semigroups we''ve defined so far? From math, we know that
    natural numbers have identity elements for addition and multiplication, that is,
    zero and one, respectively. This allows us to upgrade the semigroups we implemented
    for ints to monoids:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们之前定义的其他半群呢？从数学上我们知道，自然数对于加法和乘法有单位元素，分别是零和一。这使我们能够将我们为整数实现的半群升级为单例：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This definition is similar to the one we had for the semigroup—we've just added
    the identity element to it. The implementation of the property check is also identical
    to what we had before.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与我们之前为半群定义的类似——我们只是向其中添加了单位元素。属性检查的实现也与之前相同。
- en: 'Obviously, strings also form a monoid under concatenation and, as we noticed
    before, the identity element would be an empty container—a blank `String`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，字符串在连接下也形成一个单例，正如我们之前注意到的，单位元素将是一个空容器——一个空白的`String`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another nice thing about containers is that it is actually possible to not only
    define an algebraic structure in terms of the container as a whole, but to the
    reuse existing algebraic structures that have been defined for its elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还有一个很好的特性，实际上不仅可以在整体上定义一个代数结构，还可以重用为其元素定义的现有代数结构。
- en: This is the real power of abstract algebraic structures—they compose!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是抽象代数结构的真正力量——它们可以组合！
- en: 'To demonstrate this, let''s cheat a bit and define a weightless and toothless
    non-poisonousness fish with zero volume as an identity element for our fishing
    examples. Here is a definition for the *big fish eats little fish* monoid:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们稍微作弊一下，定义一个无重量、无牙齿、无毒、体积为零的鱼作为我们钓鱼示例的单位元素。以下是“大鱼吃小鱼”单例的定义：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The monoids for the other three cases are implemented similarly by adding a
    `ZeroFish` as an identity element to all of them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他三种情况，通过向所有这些情况添加一个`ZeroFish`作为单位元素来实现单例。
- en: 'Having this definition in scope, we can now implement the survival logic for
    two buckets of fish. First, we''ll form a pair of fish from both buckets, and
    then one fish from the pair should survive:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域中有这个定义后，我们现在可以实施两个鱼桶的生存逻辑。首先，我们将从两个桶中形成一对鱼，然后这对鱼中的一条应该存活下来：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we define our monoid in terms of a simpler monoid. The operation itself
    is built from the original operation converted to the tuple form and is applied
    to the pairs of fish from both buckets. This is defined for buckets of size less
    or equal than `100` because the identity bucket for this operation needs to contain
    enough `ZeroFish` in the case that the buckets we're combining have a different
    number of elements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据一个更简单的单例定义我们的单例。操作本身是由原始操作转换为元组形式并应用于两个鱼桶中的鱼对。这适用于大小小于或等于`100`的鱼桶，因为对于这个操作的单位桶，在组合的桶具有不同元素数量的情况下，需要包含足够的`ZeroFish`。
- en: 'Now, we can test out different survival strategies just by having an instance
    of the desired monoid in scope:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需通过在作用域中有一个所需单例的实例，就可以测试不同的生存策略：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to import both monoids in scope so that the implicit resolution works
    properly. In this example, from every pair of fish, the more toxic fish will survive.
    This can easily be changed by bringing a different monoid into scope, for example,
    the `weightMonoid` gives heavier fish a chance of survival:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入作用域内的两个单例，以便隐式解析正常工作。在这个例子中，从每对鱼中，毒性更强的鱼会存活下来。这可以通过引入不同的单例到作用域中轻松改变，例如，`weightMonoid`给较重的鱼提供了生存的机会：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can check and see that the properties of the derived monoid hold. This can
    even be proved mathematically—by zipping two monoids, we created a product monoid,
    which has been proven to obey monoid laws.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查并看到派生单例的性质是成立的。这甚至可以通过数学证明——通过压缩两个单例，我们创建了一个乘积单例，这已经被证明遵守单例法则。
- en: Another interesting aspect of monoids and semigroups is their ability to be
    used to reduce any iterable collection to a single value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 单例和半群的一个有趣方面是它们能够将任何可迭代的集合简化为单个值。
- en: 'For instance, the following is the `reduce` method that was defined for `IterableOnce`
    from the standard library:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是从标准库中为`IterableOnce`定义的`reduce`方法：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This takes an associative binary operator and applies it between all elements
    of the collection. The type signature tells us that it is a good application for
    a semigroup as its operation satisfies the requirements of this function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这接受一个关联二元操作符，并将其应用于集合的所有元素之间。类型签名告诉我们，它非常适合半群作为其操作满足此函数的要求：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding snippet, we generated a random bucket of fish and then applied
    the `poisonSemigroup` to it by specifying its operation as an argument for the
    `reduce` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们生成一个随机的鱼桶，然后通过指定`reduce`方法的参数来应用`poisonSemigroup`操作。
- en: Obviously, any semigroup operation is a perfect fit as soon as types match.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只要类型匹配，任何半群操作都是完美的选择。
- en: 'Unfortunately, the implementation of `reduce` throws an `UnsupportedOperationException`
    for empty collections, which makes it unsuitable for real functional programming:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`reduce`的实现对于空集合抛出`UnsupportedOperationException`，这使得它不适合真正的函数式编程：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is a sibling of `reduce` called `reduceOption` that returns `None` for
    empty collections instead of throwing an exception, but this makes the whole result
    type optional.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`reduceOption`的`reduce`的兄弟函数，对于空集合返回`None`而不是抛出异常，但这使得整个结果类型变为可选。
- en: 'There are a couple of similar methods defined on `IterableOnce`. Grouping them
    together would allow us to represent the "reducibility" property as a standalone
    concept:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IterableOnce`上定义了一些类似的方法。将它们组合在一起将允许我们表示“可折叠”属性作为一个独立的概念：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This does not look very nice because, as we have already discussed, the methods
    either throw an exception or introduce an effect of optionality. How could we
    improve this implementation? We could make use of the monoids' identity property!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太美观，因为我们已经讨论过，这些方法要么抛出异常，要么引入可选性的效果。我们如何改进这个实现呢？我们可以利用单例的恒等性质！
- en: Foldable
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Foldable
- en: 'The monoid identity property allows us to handle empty collections in a general
    way. So, instead of having the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 单例恒等性质允许我们以通用方式处理空集合。所以，而不是有如下：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll have a definition that takes an identity element as another parameter.
    By convention, this approach is called `fold`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个定义，它将恒等元素作为另一个参数。按照惯例，这种方法被称为`fold`：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The reason for the name `foldLeft` is that the identity element is used as
    an initial argument for reducing the collection, which leads to the following
    sequence of calls:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldLeft`这个名字的由来是因为将恒等元素用作减少集合的初始参数，这导致了以下调用序列：'
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Optionally, it is represented in postfix-notation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，它可以用后缀表示法表示：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Which is, well, kind of folding the collection, starting with the identity and
    the first element of it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是将集合折叠起来，从其身份和第一个元素开始。
- en: 'The associativity of the operation and the identity element tells us that another
    approach is also possible, starting from the identity and the last element of
    the collection and then moving toward its head:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的关联性和恒等元素告诉我们，另一种方法也是可能的，即从集合的恒等元素和最后一个元素开始，然后向其头部移动：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Folding in this direction is naturally called `foldRight`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这个方向折叠自然被称为`foldRight`：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The same properties also give us the ability to fold the collection, starting
    from any place! This is particularly useful in a balanced fold, which works from
    both ends:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的属性也赋予了我们从任何地方折叠集合的能力！这在平衡折叠中尤其有用，因为它从两端工作：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Interestingly, both sides can be dealt with recursively, in that we can split
    each of them into two parts and use a balanced fold again. Even more interestingly,
    as the left and right sides are folded independently from each other, the folding
    can be done in parallel!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这两边都可以递归处理，即我们可以将它们各自分成两部分，然后再次使用平衡折叠。更有趣的是，由于左右两边是独立折叠的，折叠操作可以并行进行！
- en: 'In the same way, as we did for `Reducible`, we can group these functions into
    yet another abstraction, `MonoidFoldable`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，正如我们为`Reducible`所做的那样，我们可以将这些函数组合成另一个抽象，`MonoidFoldable`：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This time, we define it as a type class that is capable of folding collections
    of type `F` with elements of type `A`. For most of the existing collections, instances
    of this type class should be able to delegate the `foldLeft` and `foldRight` implementations
    to the `F`. Let''s demonstrate this with an instance of `ListMonoidFoldable`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将其定义为一种类型类，它能够折叠类型为`F`的集合，其元素类型为`A`。对于大多数现有的集合，此类型类的实例应该能够将`foldLeft`和`foldRight`的实现委托给`F`。让我们通过`ListMonoidFoldable`的一个实例来演示这一点：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First of all, we require that type `A` is a monoid. Then, we get an instance
    of it by using the usual approach of calling implicitly. Then, we implement `foldRight`
    and `foldLeft` by calling the corresponding methods on the underlying `List`.
    Finally, we implement `foldBalanced` in a head-recursive manner. This implementation
    splits the list into two halves and folds them independently, exactly as we reasoned
    before. It is not done in parallel, though.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保类型`A`是一个幺半群。然后，我们通过隐式调用通常的方法来获取它的实例。然后，我们通过在底层的`List`上调用相应的方法来实现`foldRight`和`foldLeft`。最后，我们以头递归的方式实现`foldBalanced`。这种实现将列表分成两半并独立折叠，正如我们之前所推理的那样。不过，它并不是并行完成的。
- en: 'We can improve on that aspect by utilizing the `Future` we discussed in the
    previous chapter. We introduced a new method, `foldPar`, which takes an additional
    `implicit` `ExecutionContext`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用上一章中讨论的`Future`来改进这一点。我们引入了一个新方法`foldPar`，它接受一个额外的`implicit` `ExecutionContext`：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The execution context needs to pass over the moment we create a `Future` for
    our parallel computation. The structure of the method is similar to the `balancedFold`,
    since we have to split the collection into two parts and fold it recursively.
    This time, we limit the minimal number of items in the collection to be folded
    in parallel because it might be more computationally expensive to create a `Future`
    than to fold a handful of elements in a sequential manner:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文需要在创建用于并行计算的`Future`时传递这个时刻。由于我们必须将集合分成两部分并递归折叠，所以方法的结构与`balancedFold`相似。这次，我们限制了并行折叠的集合中元素的最小数量，因为创建`Future`可能比以顺序方式折叠少量元素更耗费计算资源：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For simplicity, we've hardcoded the minimal number of elements eligible for
    parallel computation, but it can be passed over as a parameter. In the method
    itself, we either spawn a balanced fold in a separate thread if the collection
    is shorter than the limit or we initiate two parallel folds the same way we did
    before, but this time we use `Future.reduceLeft` to combine them together at the
    moment both computations are finished.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们硬编码了适用于并行计算的最小元素数量，但这个值可以作为参数传递。在方法本身中，如果集合的长度小于限制，我们将在单独的线程中启动一个平衡的折叠；否则，我们将以之前相同的方式启动两个并行折叠，但这次我们使用`Future.reduceLeft`在两个计算完成时将它们组合在一起。
- en: 'We expect `foldPar` to be quicker than other folds. Let''s write a property
    for that. This endeavor will be more involved than before. The reason for this
    is that the monoids we''ve to build so far are very simple and, because of that,
    very fast. Because of this, we won''t be able to see the advantages of parallelization—the
    price of spawning a `Future` will outweigh the folding itself. For our purposes,
    we''ll make our monoid a bit slower by adding a small delay to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望`foldPar`比其他折叠更快。让我们为这一点编写一个属性。这次的努力将比以前更复杂。原因是到目前为止，我们构建的幺半群非常简单，因此非常快。正因为如此，我们将无法看到并行化的优势——启动`Future`的成本将超过折叠本身。为了我们的目的，我们将通过向其中添加一个小延迟来使我们的幺半群变慢：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another point is that the list should be long enough, otherwise we won''t be
    really testing the parallelization feature. We need to create a dedicated generator
    for lists between 100 and 1,000 in length:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点是列表应该足够长，否则我们实际上不会真正测试并行化功能。我们需要创建一个长度在100到1,000之间的列表的专用生成器：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also need a `helper` method to measure the execution time of the code block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个`helper`方法来测量代码块的执行时间：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For `foldPar`, we also need an implicit execution context. We''ll use the global
    one as it is good enough for our purposes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`foldPar`，我们同样需要一个隐式执行上下文。我们将使用全局的，因为它对我们的目的来说已经足够好了：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With all the preparations out of the way, we can formulate our property:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有准备工作后，我们可以制定我们的属性：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the body, we''ll first measure the execution time of different folding approaches:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在主体中，我们首先测量不同折叠方法的执行时间：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`foldPar` returns a `Future[Fish]` as the result, so we''re waiting for it
    to complete. Finally, we check that the result of all of folds is the same and
    that the parallel folding does not take more time than the other approaches. We
    label these properties appropriately:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldPar`返回一个`Future[Fish]`作为结果，所以我们正在等待它完成。最后，我们检查所有折叠的结果是否相同，以及并行折叠是否比其他方法花费更多时间。我们适当地标记这些属性：'
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can run our test and check that our implementation lives up to our
    expectations if tested in SBT session:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的测试，并在SBT会话中检查我们的实现是否符合预期：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It turns out that it does!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明它确实如此！
- en: Needless to say that it is possible to define other instances of the `MonoidFoldable`
    type class. Moreover, the collection does not need to be linear. As soon as it
    is possible to iterate over its elements, any structure will do—a binary tree,
    a map, a bag, or anything even more sophisticated. This possibility of being able
    to abstract over different data structures and to parallelize computations is
    what makes monoids especially useful in big data and distributed scenarios.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，可以定义`MonoidFoldable`类型类的其他实例。此外，集合不需要是线性的。一旦可以迭代其元素，任何结构都可以——二叉树、映射、包，或者任何更复杂的结构。能够抽象不同的数据结构并并行化计算的可能性使得幺半群在大数据和分布式场景中特别有用。
- en: 'Having said that, we need to emphasize that `MonoidFoldable` can be made even
    more flexible and general-purpose. To understand how this can be done, we need
    to look once again at the definition of the fold process we gave earlier:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们需要强调的是`MonoidFoldable`可以变得更加灵活和通用。要理解如何做到这一点，我们需要再次看看我们之前给出的折叠过程的定义：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can notice from this that the recursive operation takes two arguments and
    returns a result that becomes the first argument for the next iteration. This
    observation leads to the conclusion that the folding function does not need to
    have both arguments of the same type. As long as the return type is the same as
    the type of the first argument and the same as the type of the identity element,
    any function will be good for folding. This allows us to define a more generic
    `Foldable` abstraction that can convert elements of the collection and combine
    them at the same time:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，递归操作接受两个参数，并返回一个结果，该结果成为下一次迭代的第一个参数。这个观察导致了一个结论，即折叠函数不需要两个参数都是同一类型。只要返回类型与第一个参数的类型相同，并且与单位元素的类型相同，任何函数都适用于折叠。这允许我们定义一个更通用的`Foldable`抽象，它可以在转换集合元素的同时将它们组合：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This approach allows us to use any function, not only monoids, for folding.
    Of course, it is still possible to use existing monoid definitions, for example,
    by defining a method that would accept a monoid as an implicit parameter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们使用任何函数进行折叠，而不仅仅是幺半群。当然，仍然可以使用现有的幺半群定义，例如，通过定义一个接受幺半群作为隐式参数的方法：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This definition relies on the existence of some complementary function, `f`,
    which converts elements of the collection into the appropriate type before they
    can be combined using the monoid operation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义依赖于存在某个互补函数`f`，它在元素可以结合使用幺半群操作之前，将集合的元素转换为适当的类型。
- en: Looking in the opposite direction, abstract algebraic structures do not end
    with monoids. In fact, there are a lot of more advanced definitions out there
    like the group, abelian group, and ring.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从相反的方向看，抽象代数结构并不止于幺半群。实际上，还有很多更高级的定义，比如群、阿贝尔群和环。
- en: We'll take a short look at the implementation of the group just to reinforce
    our understanding of the topic of algebraic structures.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要地看看群的实现，以加强我们对代数结构主题的理解。
- en: Group
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群
- en: A group adds an invertibility property to the properties of the monoid, which
    means that for every element, `a`, from the set, `S`, on which the group is defined,
    there is an inverse element so that the result of the operation on both of them
    is an identity element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 群给幺半群的性质添加了一个可逆性属性，这意味着对于定义在集合`S`上的每个元素`a`，其中群被定义，都有一个逆元素，使得对这两个元素的操作结果是单位元素。
- en: 'Formalized in the code, it looks like the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 用代码形式化，看起来如下：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `ScalaCheck` property for this new law looks similar to the properties
    we defined for semigroup and monoid:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个新定律的`ScalaCheck`属性看起来与我们为半群和幺半群定义的属性相似：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Like we did previously, we can define an overarching check that aggregates
    single properties:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们可以定义一个综合的单个属性检查：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By adding a `commutative` *property* to the group, we'll get an abelian group.
    The `commutative` property states that for any two input elements, the order of
    arguments does not matter. For a group to be abelian, it does not need to implement
    anything; all it needs to do is satisfy this additional property!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向群添加一个`commutative`属性，我们将得到一个阿贝尔群。`commutative`属性表明，对于任何两个输入元素，参数的顺序并不重要。为了使一个群成为阿贝尔群，它不需要实现任何东西；它只需要满足这个额外的属性！
- en: 'We can extend our check definitions to incorporate this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的检查定义扩展以包含这一点：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Again, we also define a single comprehensive property to check all of the laws
    of the abelian group at once.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们也定义了一个单一的综合属性，以一次性检查交换群的全部定律。
- en: 'One example of the abelian group is integer under addition. It can be implemented
    by extending the monoid we defined previously:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 交换群的例子是加法下的整数。它可以通过扩展我们之前定义的幺半群来实现：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The properties we defined previously can help to ensure that this is indeed
    a valid abelian group implementation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的属性可以帮助确保这确实是一个有效的交换群实现：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will leave the reader with the task of executing these properties to check
    that our implementation is correct.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将留给读者执行这些属性的任务，以检查我们的实现是否正确。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The definition of the abelian group concludes our discussion of abstract algebraic
    structures; that is, the structures solely defined by the laws they satisfy.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 交换群的定义结束了我们对抽象代数结构的讨论；也就是说，这些结构仅由它们满足的定律定义。
- en: 'We looked at three such structures: semigroup, monoid, and group. The semigroup
    is defined by a binary operation that is closed and associative. The monoid adds
    to this an identity element so that the operation applied to it and another argument
    returns the second argument unchanged. The group extends monoids with an invertibility
    law, stating that for each element there should be another element so that the
    operation applied on them returns an identity element. If the operation defined
    by the group is commutative, the group is called abelian.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了三种这样的结构：半群、幺半群和群。半群由一个封闭且结合的二元运算定义。幺半群在此基础上添加了一个单位元素，使得对它和另一个参数的操作返回第二个参数不变。群通过可逆性定律扩展了幺半群，表明对于每个元素，都应该存在另一个元素，使得它们之间的操作返回一个单位元素。如果群定义的运算是对称的，则该群称为阿贝尔群。
- en: We provided an example implementation for all these algebraic equations, along
    with `ScalaCheck` properties for verifying that our implementations are sane.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为所有这些代数方程提供了一个示例实现，以及`ScalaCheck`属性来验证我们的实现是否合理。
- en: Needless to say, our code is for demonstration purposes only, and because of
    this, it is quite simplistic.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，我们的代码仅用于演示目的，因此它相当简单。
- en: There are at least two major functional programming libraries in the Scala ecosystem
    in which the concepts we discussed are implemented more rigorously—cats ([https://typelevel.org/cats/](https://typelevel.org/cats/)),
    and scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
    They are well-documented and regularly blogged and talked about, and provide a
    solid grounding for readers who are curious about using the notions we've talked
    about in real-life projects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala生态系统中有至少两个主要的函数式编程库，其中我们讨论的概念被更严格地实现——cats ([https://typelevel.org/cats/](https://typelevel.org/cats/))，和
    scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz))。它们有很好的文档，并且经常在博客和讨论中被提及，为对在实际项目中使用我们讨论的概念感兴趣的读者提供了坚实的基础。
- en: In the next chapter, we’ll work out our abstraction muscle by studying effects
    in general, extending the toolbox we started to fill in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*, with new concepts.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过研究一般效果来锻炼我们的抽象能力，扩展我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，“探索内置效果”中开始填充的工具箱，引入新的概念。
- en: Questions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is the property of associativity that is essential for the monoid useful
    in a distributed setup?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么交换性这一对幺半群至关重要的性质在分布式设置中有用？
- en: Implement a monoid for a `Boolean` under `OR`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个在`OR`下的`Boolean`幺半群。
- en: Implement a monoid for a `Boolean` under `AND`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个在`AND`下的`Boolean`幺半群。
- en: Given a `Monoid[A]`, implement `Monoid[Option[A]]`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定`Monoid[A]`，实现`Monoid[Option[A]]`。
- en: Given a `Monoid[R]`, implement `Monoid[Either[L, R]].`
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个`Monoid[R]`，实现`Monoid[Either[L, R]]`。
- en: Generalize two previous implementations for any effect parameterized by `A`,
    or describe why this is not possible.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前两个实现推广到任何由`A`参数化的效果，或者描述为什么这是不可能的。
- en: Further reading
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Atul S. Khot, *Scala Functional Programming Patterns*: Grok and performing effective
    functional programming in Scala
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 阿图尔·S·科特，《Scala函数式编程模式》：掌握Scala中的函数式编程并有效执行
- en: Ivan Nikolov, *Scala Design Patterns* - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 伊万·尼古洛夫，《Scala设计模式》—— 第二版：学习如何使用Scala编写高效、简洁且可重用的代码
