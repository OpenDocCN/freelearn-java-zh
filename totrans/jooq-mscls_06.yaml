- en: '*Chapter 4*: Building a DAO Layer (Evolving the Generated DAO Layer)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：构建 DAO 层（演进生成的 DAO 层）'
- en: At this point, we know how to enable the jOOQ Code Generator and how to express
    queries via the jOOQ DSL API, and we have a decent level of understanding of how
    jOOQ works. In other words, we know how to start and configure a Spring Boot application
    relying on jOOQ for the persistence layer implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何启用 jOOQ 代码生成器，以及如何通过 jOOQ DSL API 表达查询，并且我们对 jOOQ 的工作原理有了相当的了解。换句话说，我们知道如何启动和配置一个依赖
    jOOQ 进行持久层实现的 Spring Boot 应用程序。
- en: 'In this chapter, we tackle different approaches for organizing our queries
    in a **Data Access Object** (**DAO**) layer. Being a Spring Boot fan, you are
    most probably familiar with a DAO layer that is repository-centric, therefore,
    you''ll see how jOOQ fits into this context. By the end of this chapter, you''ll
    be familiar with the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 **数据访问对象** （**DAO**）层中组织查询的不同方法。作为一个 Spring Boot 粉丝，你很可能熟悉以仓库为中心的
    DAO 层，因此，你会看到 jOOQ 如何适应这个环境。到本章结束时，你将熟悉以下内容：
- en: Hooking the DAO layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 DAO 层
- en: Shaping the DAO design pattern and using jOOQ
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 DAO 设计模式并使用 jOOQ
- en: Shaping the generic DAO design pattern and using jOOQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建通用的 DAO 设计模式并使用 jOOQ
- en: Extending the jOOQ built-in DAO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 jOOQ 内置 DAO
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04)。
- en: Hooking the DAO layer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 DAO 层
- en: 'DAO is a design pattern that stands for **Data Access Object**. Following the
    separation of logic principle, DAO separates the data persistence logic in a dedicated
    layer and abstracts away the low-level database operations. Typically, the DAO
    is sketched around three main components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: DAO 是一个代表 **数据访问对象** 的设计模式。遵循逻辑分离原则，DAO 将数据持久化逻辑分离到一个专用层，并抽象出低级数据库操作。通常，DAO
    围绕三个主要组件进行设计：
- en: A model representing the data that is transferred between layers (for example,
    the `Sale` model corresponds to the `SALE` database table)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示层与层之间传输的数据的模型（例如，`Sale` 模型对应于 `SALE` 数据库表）
- en: An interface containing the API that should be implemented for the model (for
    example, `SaleDao`, or in Spring terms, `SaleRepository`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含应实现模型 API 的接口（例如，`SaleDao`，或者在 Spring 术语中，`SaleRepository`）
- en: A concrete implementation of this interface (for example, `SaleDaoImpl`, or
    in Spring terms, `SaleRepositoryImpl`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该接口的具体实现（例如，`SaleDaoImpl`，或者在 Spring 术语中，`SaleRepositoryImpl`）
- en: 'The following diagram represents the relationships between these components
    using `Sale`, `SaleRepository`, and `SaleRepositoryImpl`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了使用 `Sale`、`SaleRepository` 和 `SaleRepositoryImpl` 之间的关系：
- en: '![Figure 4.1 – DAO design pattern'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – DAO 设计模式](img/Figure_4.1_DAO_design_pattern.jpg)'
- en: '](img/B16833_Figure_4.1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B16833_4.1.jpg](img/B16833_Figure_4.1.jpg)'
- en: Figure 4.1 – DAO design pattern
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – DAO 设计模式
- en: If you are a `JdbcTemplate` fan, you most probably recognize this pattern in
    your own applications. On the other hand, if you are familiar with Spring Data
    JPA/JDBC, then you can associate `Sale` with a JPA/JDBC entity, `SaleRepository`
    with an extension of the Spring repository (for instance, `CrudRepository` or
    `JpaRepository`), and `SaleRepositoryImpl` with the Spring proxy instance automatically
    created for `SaleRepository`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 `JdbcTemplate` 粉丝，你很可能在自己的应用程序中认出这个模式。另一方面，如果你熟悉 Spring Data JPA/JDBC，那么你可以将
    `Sale` 关联到 JPA/JDBC 实体，将 `SaleRepository` 关联到 Spring 仓库的扩展（例如，`CrudRepository`
    或 `JpaRepository`），将 `SaleRepositoryImpl` 关联到为 `SaleRepository` 自动创建的 Spring 代理实例。
- en: A flavor of this design pattern is known as *generic DAO*. In this case, the
    goal is to isolate the query methods that are common to all repositories (for
    instance, `fetchAll()`, `fetchById()`, `insert()`, `update()`, and so on) from
    the query methods that are repository-specific (for instance, `findSaleByFiscalYear()`).
    This time, we add the common methods in a generic interface (such as `ClassicModelsRepository<>`)
    and we provide an implementation for it (`ClassicModelsRepositoryImpl<>`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的一种变体被称为 *通用 DAO*。在这种情况下，目标是隔离所有仓库共有的查询方法（例如，`fetchAll()`、`fetchById()`、`insert()`、`update()`
    等等）与特定于仓库的查询方法（例如，`findSaleByFiscalYear()`）。这次，我们在一个通用接口（例如，`ClassicModelsRepository<>`）中添加了常用方法，并为它提供了实现（`ClassicModelsRepositoryImpl<>`）。
- en: 'The following diagrams depict two classical flavors of the generic DAO using
    the same `Sale`, `SaleRepository` and `SaleRepositoryImpl`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示例描绘了使用相同的 `Sale`、`SaleRepository` 和 `SaleRepositoryImpl` 的两种泛型 DAO 经典风味：
- en: '![Figure 4.2 – Generic DAO (1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 泛型 DAO (1)'
- en: '](img/B16833_Figure_4.2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16833_Figure_4.2.jpg]'
- en: Figure 4.2 – Generic DAO (1)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 泛型 DAO (1)
- en: 'In *Figure 4.2*, the implementation of `SaleRepository` must provide an implementation
    of the generic `ClassicModelsRepository` as well. Each repository will follow
    this technique. To increase the DAO layer flexibility, we add a separate implementation
    for the generic interface as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.2* 中，`SaleRepository` 的实现必须提供一个通用 `ClassicModelsRepository` 的实现。每个存储库都将遵循此技术。为了增加
    DAO 层的灵活性，我们添加了一个通用接口的单独实现，如下图所示：
- en: '![Figure 4.3 – Generic DAO (2)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 泛型 DAO (2)'
- en: '](img/B16833_Figure_4.3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16833_Figure_4.3.jpg]'
- en: Figure 4.3 – Generic DAO (2)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 泛型 DAO (2)
- en: If you are familiar with Spring Data JPA/JDBC, then you can associate `ClassicModelsRepository`
    with a Spring built-in repository (for example, `CrudRepository` or `JpaRepository`)
    and the implementation of this interface, `ClassicModelsRepositoryImpl`, with
    a Spring built-in implementation such as `SimpleJpaRepository`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 Spring Data JPA/JDBC，那么您可以将 `ClassicModelsRepository` 与 Spring 内置的存储库（例如，`CrudRepository`
    或 `JpaRepository`）以及此接口的实现 `ClassicModelsRepositoryImpl` 与 Spring 内置的实现（例如，`SimpleJpaRepository`）相关联。
- en: Next, let's see how we can shape these DAO patterns and use jOOQ.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何塑造这些 DAO 模式并使用 jOOQ。
- en: Shaping the DAO design pattern and using jOOQ
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 塑造 DAO 设计模式和使用 jOOQ
- en: Let's assume that we have a bunch of SQLs written in jOOQ for the `SALE` table,
    and we want to shape a simple DAO implementation around them. This is quite simple
    because all we have to do is to follow *Figure 4.1* from the previous section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一系列针对 `SALE` 表的 jOOQ SQL 语句，我们想要围绕它们构建一个简单的 DAO 实现。这相当简单，因为我们只需遵循上一节中的
    *图 4.1*。
- en: 'First of all, the model is provided as POJOs by the jOOQ generator (we can
    have user-defined POJOs as well), therefore, we already have the `Sale` POJO.
    Next, we write `SaleRepository`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，模型由 jOOQ 生成器以 POJO 的形式提供（我们也可以有用户定义的 POJO），因此，我们已经有 `Sale` POJO。接下来，我们编写
    `SaleRepository`：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`SaleRepositoryImpl` provides a jOOQ implementation for these two methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaleRepositoryImpl` 为这两个方法提供了 jOOQ 实现：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Done! Further, we can simply inject `SaleRepository` and call the query methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！接下来，我们可以简单地注入 `SaleRepository` 并调用查询方法：
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the same way, we can evolve this DAO layer by adding more repositories and
    implementations for other models. This application is available for Maven and
    Gradle as *SimpleDao*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，我们可以通过添加更多存储库和其他模型实现来演进这个 DAO 层。此应用程序以 *SimpleDao* 的形式适用于 Maven 和 Gradle。
- en: 'Moreover, if you have to combine Spring Data JPA DAO with the user-defined
    jOOQ DAO in a single interface, then simply extend the needed interfaces as in
    the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您必须将 Spring Data JPA DAO 与用户定义的 jOOQ DAO 结合在一个接口中，那么只需简单地扩展所需的接口，如下例所示：
- en: '[PRE35]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once you inject `SaleRepository`, you'll have access to a Spring Data JPA DAO
    and the user-defined jOOQ DAO in the same service. This example is named `JpaSimpleDao`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注入 `SaleRepository`，您将能够访问 Spring Data JPA DAO 和用户定义的 jOOQ DAO，在同一服务中。此示例命名为
    `JpaSimpleDao`。
- en: Shaping the generic DAO design pattern and using jOOQ
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 塑造泛型 DAO 设计模式和使用 jOOQ
- en: 'Trying to implement the generic DAO from *Figure 4.2* starts with the generic
    interface, `ClassicModelsRepository`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从 *图 4.2* 实现泛型 DAO 以通用接口 `ClassicModelsRepository` 为起点：
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While `ClassicModelsRepository` contains the common query methods, `SaleRepository`
    extends it to add specific query methods, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ClassicModelsRepository` 包含了常见的查询方法，但 `SaleRepository` 通过添加特定的查询方法对其进行扩展，如下所示：
- en: '[PRE49]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The implementation of `SaleRepository` provides implementations for methods
    from both interfaces:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaleRepository` 的实现提供了两个接口的方法实现：'
- en: '[PRE56]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The complete example is named *SimpleGenericDao*. Moreover, if you have to combine
    Spring Data JPA DAO with the user-defined jOOQ generic DAO in a single interface,
    then extend the needed interfaces as in *JPASimpleGenericDao*. Once you inject
    `SaleRepository`, you'll have access to Spring Data JPA DAO and the user-defined
    jOOQ generic DAO in the same service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例命名为 *SimpleGenericDao*。此外，如果您必须将 Spring Data JPA DAO 与用户定义的 jOOQ 泛型 DAO
    结合在一个接口中，那么就像在 *JPASimpleGenericDao* 中那样扩展所需的接口。一旦注入 `SaleRepository`，您将能够访问 Spring
    Data JPA DAO 和用户定义的 jOOQ 泛型 DAO，在同一服务中。
- en: How about implementing the generic DAO from *Figure 4.3*? This is more flexible
    but not that easy to do it. Because of *genericity* aspects, we can't reference
    tables and fields directly as we did in the previous case. The query methods from
    `ClassicModelsRepository` are written in a generic fashion, therefore, the jOOQ
    queries written via the DSL support in `ClassicModelsRepositoryImpl` must be written
    in a generic fashion as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实现*图4.3*中的通用DAO，怎么样？这更加灵活，但并不容易实现。由于*通用性*方面，我们无法直接引用表和字段，就像在之前的例子中那样。`ClassicModelsRepository`中的查询方法是通用的，因此，通过`ClassicModelsRepositoryImpl`中的DSL支持编写的jOOQ查询也必须以通用方式编写。
- en: It is not trivial to intuit how to express jOOQ SQLs in a generic fashion, but
    you can do it after studying the source code of the jOOQ built-in `DAO` interface
    and the `DAOImpl` class. For those who want to deep dive into this approach, consider
    the example named *GenericDao*. If you want to involve Spring Data JPA as well
    then check out *JpaGenericDao*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地表达jOOQ SQL的通用方式并不简单，但你在研究了jOOQ内置`DAO`接口和`DAOImpl`类的源代码之后可以做到。对于那些想要深入研究这种方法的人，可以考虑名为*GenericDao*的示例。如果你还想涉及Spring
    Data JPA，那么可以查看*JpaGenericDao*。
- en: But, as you saw in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing
    the jOOQ Level of Involvement*, jOOQ can generate a DAO layer on our behalf. Let's
    extend it and enrich/customize it as we like.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你在[*第二章*](B16833_02.xhtml#_idTextAnchor024)中看到的，“自定义jOOQ的参与级别”，jOOQ可以代表我们生成DAO层。让我们扩展它，并按我们的喜好丰富/自定义它。
- en: Extending the jOOQ built-in DAO
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展jOOQ内置DAO
- en: Let's assume that you have configured the jOOQ generator to output the generated
    DAO layer in the `jooq.generated.tables.daos` package. While the generated DAO
    exposes common query methods such as `insert()`, `update()`, `delete()`, and a
    few specific queries of the `fetchBy...()` or `fetchRange...()` types, we want
    to extend it with our own query methods.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经配置了jOOQ生成器，使其在`jooq.generated.tables.daos`包中输出生成的DAO层。虽然生成的DAO公开了常见的查询方法，如`insert()`、`update()`、`delete()`以及一些`fetchBy...()`或`fetchRange...()`类型的特定查询，但我们希望扩展它，添加我们自己的查询方法。
- en: Important Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This is one of my favorite ways of writing a DAO layer in a Spring Boot and
    jOOQ application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我最喜欢的在Spring Boot和jOOQ应用程序中编写DAO层的方式之一。
- en: 'The jOOQ DAO layer contains a set of generated classes that mirrors the database
    tables and extends the built-in `org.jooq.impl.DAOImpl` class. For example, the
    `jooq.generated.tables.daos.SaleRepository` class (or, `jooq.generated.tables.daos.SaleDao`
    if you keep the default naming strategy used by jOOQ) corresponds to the `SALE`
    table. In order to extend `SaleRepository`, we have to take a quick look at its
    source code and highlight a part of it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ DAO层包含一组生成的类，这些类反映了数据库表并扩展了内置的`org.jooq.impl.DAOImpl`类。例如，`jooq.generated.tables.daos.SaleRepository`类（或者，如果你保留了jOOQ使用的默认命名策略，则为`jooq.generated.tables.daos.SaleDao`）对应于`SALE`表。为了扩展`SaleRepository`，我们必须快速查看其源代码，并突出以下部分：
- en: '[PRE71]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The highlighted code represents the climax of extending `SaleRepository`. When
    we extend `SaleRepository` (or any other jOOQ DAO class), it is our responsibility
    to pass a jOOQ valid configuration, otherwise, the code will produce `NullPointerException`.
    This is an easy task that can be accomplished as shown in the following snippet
    of code (basically, we pass into `SaleRepository` the configuration of `DSLContext`
    prepared by Spring Boot):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码代表了扩展`SaleRepository`的高潮。当我们扩展`SaleRepository`（或任何其他jOOQ DAO类）时，我们有责任传递一个有效的jOOQ配置，否则代码将产生`NullPointerException`。这是一个简单的任务，可以通过以下代码片段完成（基本上，我们将`DSLContext`的配置传递给`SaleRepository`，该配置由Spring
    Boot准备）：
- en: '[PRE82]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'That''s all! Now, you can exploit the query methods defined in `SaleRepositoryImpl`
    and `SaleRepository` as well. In other words, you can use the jOOQ built in and
    your own DAO as a "single" DAO. Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了！现在，你可以利用`SaleRepositoryImpl`和`SaleRepository`中定义的查询方法。换句话说，你可以将jOOQ内置的DAO和你的DAO作为一个“单一”的DAO来使用。以下是一个示例：
- en: '[PRE92]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Please consider the following note as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下说明。
- en: Important Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'At the time of writing, jOOQ DAOs work under the following statements:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，jOOQ DAO在以下语句下工作：
- en: "\x98 jOOQ DAOs can be instantiated as much as you like since they don't have\
    \ their own state."
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ DAO可以实例化任意多次，因为它们没有自己的状态。"
- en: "\x98 jOOQ DAOs cannot generate methods on DAOs that use the interfaces of POJOs\
    \ instead of classes. Actually, at the time of writing, the `<interfaces/>` and\
    \ `<immutableInterfaces/>` features have been proposed to be removed. You can\
    \ track this here: [https://github.com/jOOQ/jOOQ/issues/10509](https://github.com/jOOQ/jOOQ/issues/10509)."
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ DAO 无法为使用 POJO 接口而不是类的 DAO 生成方法。实际上，在撰写本文时，`<interfaces/>` 和 `<immutableInterfaces/>`\
    \ 功能已被提议移除。您可以在此处跟踪此问题：[https://github.com/jOOQ/jOOQ/issues/10509](https://github.com/jOOQ/jOOQ/issues/10509)。"
- en: "\x98 jOOQ cannot generate interfaces for DAOs."
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ 无法为 DAO 生成接口。"
- en: "\x98 jOOQ DAOs can be annotated with `@Repository` but they are not running\
    \ by default in a transactional context (they cannot be annotated with `@Transactional`\
    \ by the jOOQ generator). You can track this here: [https://github.com/jOOQ/jOOQ/issues/10756](https://github.com/jOOQ/jOOQ/issues/10756)."
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ DAO 可以用 `@Repository` 注解，但它们默认不在事务上下文中运行（jOOQ 生成器不能将它们注解为 `@Transactional`）。您可以在此处跟踪此问题：[https://github.com/jOOQ/jOOQ/issues/10756](https://github.com/jOOQ/jOOQ/issues/10756)。"
- en: "\x98 The DAO's generated `insert()` method cannot return the newly generated\
    \ ID from the database or the POJO. It simply returns `void`. You can track this\
    \ here: [https://github.com/jOOQ/jOOQ/issues/2536](https://github.com/jOOQ/jOOQ/issues/2536)\
    \ and [https://github.com/jOOQ/jOOQ/issues/3021](https://github.com/jOOQ/jOOQ/issues/3021)."
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 生成的 DAO 的 `insert()` 方法无法从数据库或 POJO 返回新生成的 ID。它只是返回 `void`。您可以在此处跟踪此问题：[https://github.com/jOOQ/jOOQ/issues/2536](https://github.com/jOOQ/jOOQ/issues/2536)\
    \ 和 [https://github.com/jOOQ/jOOQ/issues/3021](https://github.com/jOOQ/jOOQ/issues/3021)。"
- en: You don't have to consider these shortcomings as the end of the road. The jOOQ
    team filters dozens of features in order to choose the most popular ones that
    fit a significant number of scenarios and deserve an implementation directly in
    the jOOQ releases. Nevertheless, any corner-case or edge-case feature can be supplied
    by you via a custom generator, custom strategy, or customer configuration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必将这些缺点视为终点。jOOQ 团队过滤了数十个功能，以便选择最流行的、适用于大量场景并值得直接在 jOOQ 发布中实现的功能。尽管如此，任何边缘情况或特殊情况功能都可以通过自定义生成器、自定义策略或客户配置由您提供。
- en: The complete example from this section is named *jOOQ DAO*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的完整示例命名为 *jOOQ DAO*。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered several approaches to developing, from scratch,
    a DAO layer or evolving the jOOQ-generated DAO layer in a Spring Boot and jOOQ
    application. Each of the presented applications can serve as a stub application
    for your own applications. Just choose the one that is suitable for you, replace
    the schema, and start developing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了从零开始开发 DAO 层或演进 jOOQ 生成的 DAO 层在 Spring Boot 和 jOOQ 应用程序中的几种方法。所展示的每个应用程序都可以作为您自己应用程序的占位符应用程序。只需选择适合您的一个，替换模式，然后开始开发。
- en: In the next chapter, we'll use jOOQ to express a wide range of queries involving
    `SELECT`, `INSERT`, `UPDATE`, and `DELETE`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 jOOQ 表达涉及 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 的广泛查询。
