- en: '*Chapter 4*: Building a DAO Layer (Evolving the Generated DAO Layer)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we know how to enable the jOOQ Code Generator and how to express
    queries via the jOOQ DSL API, and we have a decent level of understanding of how
    jOOQ works. In other words, we know how to start and configure a Spring Boot application
    relying on jOOQ for the persistence layer implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we tackle different approaches for organizing our queries
    in a **Data Access Object** (**DAO**) layer. Being a Spring Boot fan, you are
    most probably familiar with a DAO layer that is repository-centric, therefore,
    you''ll see how jOOQ fits into this context. By the end of this chapter, you''ll
    be familiar with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the DAO layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaping the DAO design pattern and using jOOQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaping the generic DAO design pattern and using jOOQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the jOOQ built-in DAO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the DAO layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DAO is a design pattern that stands for **Data Access Object**. Following the
    separation of logic principle, DAO separates the data persistence logic in a dedicated
    layer and abstracts away the low-level database operations. Typically, the DAO
    is sketched around three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: A model representing the data that is transferred between layers (for example,
    the `Sale` model corresponds to the `SALE` database table)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface containing the API that should be implemented for the model (for
    example, `SaleDao`, or in Spring terms, `SaleRepository`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A concrete implementation of this interface (for example, `SaleDaoImpl`, or
    in Spring terms, `SaleRepositoryImpl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents the relationships between these components
    using `Sale`, `SaleRepository`, and `SaleRepositoryImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – DAO design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_4.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – DAO design pattern
  prefs: []
  type: TYPE_NORMAL
- en: If you are a `JdbcTemplate` fan, you most probably recognize this pattern in
    your own applications. On the other hand, if you are familiar with Spring Data
    JPA/JDBC, then you can associate `Sale` with a JPA/JDBC entity, `SaleRepository`
    with an extension of the Spring repository (for instance, `CrudRepository` or
    `JpaRepository`), and `SaleRepositoryImpl` with the Spring proxy instance automatically
    created for `SaleRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: A flavor of this design pattern is known as *generic DAO*. In this case, the
    goal is to isolate the query methods that are common to all repositories (for
    instance, `fetchAll()`, `fetchById()`, `insert()`, `update()`, and so on) from
    the query methods that are repository-specific (for instance, `findSaleByFiscalYear()`).
    This time, we add the common methods in a generic interface (such as `ClassicModelsRepository<>`)
    and we provide an implementation for it (`ClassicModelsRepositoryImpl<>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagrams depict two classical flavors of the generic DAO using
    the same `Sale`, `SaleRepository` and `SaleRepositoryImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Generic DAO (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_4.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Generic DAO (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.2*, the implementation of `SaleRepository` must provide an implementation
    of the generic `ClassicModelsRepository` as well. Each repository will follow
    this technique. To increase the DAO layer flexibility, we add a separate implementation
    for the generic interface as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Generic DAO (2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_4.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Generic DAO (2)
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Spring Data JPA/JDBC, then you can associate `ClassicModelsRepository`
    with a Spring built-in repository (for example, `CrudRepository` or `JpaRepository`)
    and the implementation of this interface, `ClassicModelsRepositoryImpl`, with
    a Spring built-in implementation such as `SimpleJpaRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can shape these DAO patterns and use jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: Shaping the DAO design pattern and using jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that we have a bunch of SQLs written in jOOQ for the `SALE` table,
    and we want to shape a simple DAO implementation around them. This is quite simple
    because all we have to do is to follow *Figure 4.1* from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the model is provided as POJOs by the jOOQ generator (we can
    have user-defined POJOs as well), therefore, we already have the `Sale` POJO.
    Next, we write `SaleRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`SaleRepositoryImpl` provides a jOOQ implementation for these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Further, we can simply inject `SaleRepository` and call the query methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, we can evolve this DAO layer by adding more repositories and
    implementations for other models. This application is available for Maven and
    Gradle as *SimpleDao*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if you have to combine Spring Data JPA DAO with the user-defined
    jOOQ DAO in a single interface, then simply extend the needed interfaces as in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once you inject `SaleRepository`, you'll have access to a Spring Data JPA DAO
    and the user-defined jOOQ DAO in the same service. This example is named `JpaSimpleDao`.
  prefs: []
  type: TYPE_NORMAL
- en: Shaping the generic DAO design pattern and using jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trying to implement the generic DAO from *Figure 4.2* starts with the generic
    interface, `ClassicModelsRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'While `ClassicModelsRepository` contains the common query methods, `SaleRepository`
    extends it to add specific query methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `SaleRepository` provides implementations for methods
    from both interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named *SimpleGenericDao*. Moreover, if you have to combine
    Spring Data JPA DAO with the user-defined jOOQ generic DAO in a single interface,
    then extend the needed interfaces as in *JPASimpleGenericDao*. Once you inject
    `SaleRepository`, you'll have access to Spring Data JPA DAO and the user-defined
    jOOQ generic DAO in the same service.
  prefs: []
  type: TYPE_NORMAL
- en: How about implementing the generic DAO from *Figure 4.3*? This is more flexible
    but not that easy to do it. Because of *genericity* aspects, we can't reference
    tables and fields directly as we did in the previous case. The query methods from
    `ClassicModelsRepository` are written in a generic fashion, therefore, the jOOQ
    queries written via the DSL support in `ClassicModelsRepositoryImpl` must be written
    in a generic fashion as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is not trivial to intuit how to express jOOQ SQLs in a generic fashion, but
    you can do it after studying the source code of the jOOQ built-in `DAO` interface
    and the `DAOImpl` class. For those who want to deep dive into this approach, consider
    the example named *GenericDao*. If you want to involve Spring Data JPA as well
    then check out *JpaGenericDao*.
  prefs: []
  type: TYPE_NORMAL
- en: But, as you saw in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing
    the jOOQ Level of Involvement*, jOOQ can generate a DAO layer on our behalf. Let's
    extend it and enrich/customize it as we like.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the jOOQ built-in DAO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that you have configured the jOOQ generator to output the generated
    DAO layer in the `jooq.generated.tables.daos` package. While the generated DAO
    exposes common query methods such as `insert()`, `update()`, `delete()`, and a
    few specific queries of the `fetchBy...()` or `fetchRange...()` types, we want
    to extend it with our own query methods.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: This is one of my favorite ways of writing a DAO layer in a Spring Boot and
    jOOQ application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ DAO layer contains a set of generated classes that mirrors the database
    tables and extends the built-in `org.jooq.impl.DAOImpl` class. For example, the
    `jooq.generated.tables.daos.SaleRepository` class (or, `jooq.generated.tables.daos.SaleDao`
    if you keep the default naming strategy used by jOOQ) corresponds to the `SALE`
    table. In order to extend `SaleRepository`, we have to take a quick look at its
    source code and highlight a part of it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code represents the climax of extending `SaleRepository`. When
    we extend `SaleRepository` (or any other jOOQ DAO class), it is our responsibility
    to pass a jOOQ valid configuration, otherwise, the code will produce `NullPointerException`.
    This is an easy task that can be accomplished as shown in the following snippet
    of code (basically, we pass into `SaleRepository` the configuration of `DSLContext`
    prepared by Spring Boot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Now, you can exploit the query methods defined in `SaleRepositoryImpl`
    and `SaleRepository` as well. In other words, you can use the jOOQ built in and
    your own DAO as a "single" DAO. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Please consider the following note as well.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, jOOQ DAOs work under the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 jOOQ DAOs can be instantiated as much as you like since they don't have\
    \ their own state."
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 jOOQ DAOs cannot generate methods on DAOs that use the interfaces of POJOs\
    \ instead of classes. Actually, at the time of writing, the `<interfaces/>` and\
    \ `<immutableInterfaces/>` features have been proposed to be removed. You can\
    \ track this here: [https://github.com/jOOQ/jOOQ/issues/10509](https://github.com/jOOQ/jOOQ/issues/10509)."
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 jOOQ cannot generate interfaces for DAOs."
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 jOOQ DAOs can be annotated with `@Repository` but they are not running\
    \ by default in a transactional context (they cannot be annotated with `@Transactional`\
    \ by the jOOQ generator). You can track this here: [https://github.com/jOOQ/jOOQ/issues/10756](https://github.com/jOOQ/jOOQ/issues/10756)."
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 The DAO's generated `insert()` method cannot return the newly generated\
    \ ID from the database or the POJO. It simply returns `void`. You can track this\
    \ here: [https://github.com/jOOQ/jOOQ/issues/2536](https://github.com/jOOQ/jOOQ/issues/2536)\
    \ and [https://github.com/jOOQ/jOOQ/issues/3021](https://github.com/jOOQ/jOOQ/issues/3021)."
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to consider these shortcomings as the end of the road. The jOOQ
    team filters dozens of features in order to choose the most popular ones that
    fit a significant number of scenarios and deserve an implementation directly in
    the jOOQ releases. Nevertheless, any corner-case or edge-case feature can be supplied
    by you via a custom generator, custom strategy, or customer configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The complete example from this section is named *jOOQ DAO*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered several approaches to developing, from scratch,
    a DAO layer or evolving the jOOQ-generated DAO layer in a Spring Boot and jOOQ
    application. Each of the presented applications can serve as a stub application
    for your own applications. Just choose the one that is suitable for you, replace
    the schema, and start developing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use jOOQ to express a wide range of queries involving
    `SELECT`, `INSERT`, `UPDATE`, and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
