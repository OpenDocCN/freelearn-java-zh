- en: '*Chapter 4*: Building a DAO Layer (Evolving the Generated DAO Layer)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we know how to enable the jOOQ Code Generator and how to express
    queries via the jOOQ DSL API, and we have a decent level of understanding of how
    jOOQ works. In other words, we know how to start and configure a Spring Boot application
    relying on jOOQ for the persistence layer implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we tackle different approaches for organizing our queries
    in a **Data Access Object** (**DAO**) layer. Being a Spring Boot fan, you are
    most probably familiar with a DAO layer that is repository-centric, therefore,
    you''ll see how jOOQ fits into this context. By the end of this chapter, you''ll
    be familiar with the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the DAO layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaping the DAO design pattern and using jOOQ
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaping the generic DAO design pattern and using jOOQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the jOOQ built-in DAO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the DAO layer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DAO is a design pattern that stands for **Data Access Object**. Following the
    separation of logic principle, DAO separates the data persistence logic in a dedicated
    layer and abstracts away the low-level database operations. Typically, the DAO
    is sketched around three main components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A model representing the data that is transferred between layers (for example,
    the `Sale` model corresponds to the `SALE` database table)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface containing the API that should be implemented for the model (for
    example, `SaleDao`, or in Spring terms, `SaleRepository`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A concrete implementation of this interface (for example, `SaleDaoImpl`, or
    in Spring terms, `SaleRepositoryImpl`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents the relationships between these components
    using `Sale`, `SaleRepository`, and `SaleRepositoryImpl`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – DAO design pattern'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_4.1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – DAO design pattern
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If you are a `JdbcTemplate` fan, you most probably recognize this pattern in
    your own applications. On the other hand, if you are familiar with Spring Data
    JPA/JDBC, then you can associate `Sale` with a JPA/JDBC entity, `SaleRepository`
    with an extension of the Spring repository (for instance, `CrudRepository` or
    `JpaRepository`), and `SaleRepositoryImpl` with the Spring proxy instance automatically
    created for `SaleRepository`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: A flavor of this design pattern is known as *generic DAO*. In this case, the
    goal is to isolate the query methods that are common to all repositories (for
    instance, `fetchAll()`, `fetchById()`, `insert()`, `update()`, and so on) from
    the query methods that are repository-specific (for instance, `findSaleByFiscalYear()`).
    This time, we add the common methods in a generic interface (such as `ClassicModelsRepository<>`)
    and we provide an implementation for it (`ClassicModelsRepositoryImpl<>`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagrams depict two classical flavors of the generic DAO using
    the same `Sale`, `SaleRepository` and `SaleRepositoryImpl`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Generic DAO (1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_4.2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Generic DAO (1)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.2*, the implementation of `SaleRepository` must provide an implementation
    of the generic `ClassicModelsRepository` as well. Each repository will follow
    this technique. To increase the DAO layer flexibility, we add a separate implementation
    for the generic interface as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Generic DAO (2)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_4.3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Generic DAO (2)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Spring Data JPA/JDBC, then you can associate `ClassicModelsRepository`
    with a Spring built-in repository (for example, `CrudRepository` or `JpaRepository`)
    and the implementation of this interface, `ClassicModelsRepositoryImpl`, with
    a Spring built-in implementation such as `SimpleJpaRepository`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can shape these DAO patterns and use jOOQ.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Shaping the DAO design pattern and using jOOQ
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that we have a bunch of SQLs written in jOOQ for the `SALE` table,
    and we want to shape a simple DAO implementation around them. This is quite simple
    because all we have to do is to follow *Figure 4.1* from the previous section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the model is provided as POJOs by the jOOQ generator (we can
    have user-defined POJOs as well), therefore, we already have the `Sale` POJO.
    Next, we write `SaleRepository`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`SaleRepositoryImpl` provides a jOOQ implementation for these two methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Done! Further, we can simply inject `SaleRepository` and call the query methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the same way, we can evolve this DAO layer by adding more repositories and
    implementations for other models. This application is available for Maven and
    Gradle as *SimpleDao*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if you have to combine Spring Data JPA DAO with the user-defined
    jOOQ DAO in a single interface, then simply extend the needed interfaces as in
    the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once you inject `SaleRepository`, you'll have access to a Spring Data JPA DAO
    and the user-defined jOOQ DAO in the same service. This example is named `JpaSimpleDao`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Shaping the generic DAO design pattern and using jOOQ
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trying to implement the generic DAO from *Figure 4.2* starts with the generic
    interface, `ClassicModelsRepository`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While `ClassicModelsRepository` contains the common query methods, `SaleRepository`
    extends it to add specific query methods, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The implementation of `SaleRepository` provides implementations for methods
    from both interfaces:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The complete example is named *SimpleGenericDao*. Moreover, if you have to combine
    Spring Data JPA DAO with the user-defined jOOQ generic DAO in a single interface,
    then extend the needed interfaces as in *JPASimpleGenericDao*. Once you inject
    `SaleRepository`, you'll have access to Spring Data JPA DAO and the user-defined
    jOOQ generic DAO in the same service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How about implementing the generic DAO from *Figure 4.3*? This is more flexible
    but not that easy to do it. Because of *genericity* aspects, we can't reference
    tables and fields directly as we did in the previous case. The query methods from
    `ClassicModelsRepository` are written in a generic fashion, therefore, the jOOQ
    queries written via the DSL support in `ClassicModelsRepositoryImpl` must be written
    in a generic fashion as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It is not trivial to intuit how to express jOOQ SQLs in a generic fashion, but
    you can do it after studying the source code of the jOOQ built-in `DAO` interface
    and the `DAOImpl` class. For those who want to deep dive into this approach, consider
    the example named *GenericDao*. If you want to involve Spring Data JPA as well
    then check out *JpaGenericDao*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: But, as you saw in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing
    the jOOQ Level of Involvement*, jOOQ can generate a DAO layer on our behalf. Let's
    extend it and enrich/customize it as we like.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Extending the jOOQ built-in DAO
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that you have configured the jOOQ generator to output the generated
    DAO layer in the `jooq.generated.tables.daos` package. While the generated DAO
    exposes common query methods such as `insert()`, `update()`, `delete()`, and a
    few specific queries of the `fetchBy...()` or `fetchRange...()` types, we want
    to extend it with our own query methods.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This is one of my favorite ways of writing a DAO layer in a Spring Boot and
    jOOQ application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ DAO layer contains a set of generated classes that mirrors the database
    tables and extends the built-in `org.jooq.impl.DAOImpl` class. For example, the
    `jooq.generated.tables.daos.SaleRepository` class (or, `jooq.generated.tables.daos.SaleDao`
    if you keep the default naming strategy used by jOOQ) corresponds to the `SALE`
    table. In order to extend `SaleRepository`, we have to take a quick look at its
    source code and highlight a part of it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The highlighted code represents the climax of extending `SaleRepository`. When
    we extend `SaleRepository` (or any other jOOQ DAO class), it is our responsibility
    to pass a jOOQ valid configuration, otherwise, the code will produce `NullPointerException`.
    This is an easy task that can be accomplished as shown in the following snippet
    of code (basically, we pass into `SaleRepository` the configuration of `DSLContext`
    prepared by Spring Boot):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'That''s all! Now, you can exploit the query methods defined in `SaleRepositoryImpl`
    and `SaleRepository` as well. In other words, you can use the jOOQ built in and
    your own DAO as a "single" DAO. Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Please consider the following note as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, jOOQ DAOs work under the following statements:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 jOOQ DAOs can be instantiated as much as you like since they don't have\
    \ their own state."
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: "\x98 jOOQ DAOs cannot generate methods on DAOs that use the interfaces of POJOs\
    \ instead of classes. Actually, at the time of writing, the `<interfaces/>` and\
    \ `<immutableInterfaces/>` features have been proposed to be removed. You can\
    \ track this here: [https://github.com/jOOQ/jOOQ/issues/10509](https://github.com/jOOQ/jOOQ/issues/10509)."
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ DAO 无法为使用 POJO 接口而不是类的 DAO 生成方法。实际上，在撰写本文时，`<interfaces/>` 和 `<immutableInterfaces/>`\
    \ 功能已被提议移除。您可以在此处跟踪此问题：[https://github.com/jOOQ/jOOQ/issues/10509](https://github.com/jOOQ/jOOQ/issues/10509)。"
- en: "\x98 jOOQ cannot generate interfaces for DAOs."
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ 无法为 DAO 生成接口。"
- en: "\x98 jOOQ DAOs can be annotated with `@Repository` but they are not running\
    \ by default in a transactional context (they cannot be annotated with `@Transactional`\
    \ by the jOOQ generator). You can track this here: [https://github.com/jOOQ/jOOQ/issues/10756](https://github.com/jOOQ/jOOQ/issues/10756)."
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 jOOQ DAO 可以用 `@Repository` 注解，但它们默认不在事务上下文中运行（jOOQ 生成器不能将它们注解为 `@Transactional`）。您可以在此处跟踪此问题：[https://github.com/jOOQ/jOOQ/issues/10756](https://github.com/jOOQ/jOOQ/issues/10756)。"
- en: "\x98 The DAO's generated `insert()` method cannot return the newly generated\
    \ ID from the database or the POJO. It simply returns `void`. You can track this\
    \ here: [https://github.com/jOOQ/jOOQ/issues/2536](https://github.com/jOOQ/jOOQ/issues/2536)\
    \ and [https://github.com/jOOQ/jOOQ/issues/3021](https://github.com/jOOQ/jOOQ/issues/3021)."
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: "\x98 生成的 DAO 的 `insert()` 方法无法从数据库或 POJO 返回新生成的 ID。它只是返回 `void`。您可以在此处跟踪此问题：[https://github.com/jOOQ/jOOQ/issues/2536](https://github.com/jOOQ/jOOQ/issues/2536)\
    \ 和 [https://github.com/jOOQ/jOOQ/issues/3021](https://github.com/jOOQ/jOOQ/issues/3021)。"
- en: You don't have to consider these shortcomings as the end of the road. The jOOQ
    team filters dozens of features in order to choose the most popular ones that
    fit a significant number of scenarios and deserve an implementation directly in
    the jOOQ releases. Nevertheless, any corner-case or edge-case feature can be supplied
    by you via a custom generator, custom strategy, or customer configuration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必将这些缺点视为终点。jOOQ 团队过滤了数十个功能，以便选择最流行的、适用于大量场景并值得直接在 jOOQ 发布中实现的功能。尽管如此，任何边缘情况或特殊情况功能都可以通过自定义生成器、自定义策略或客户配置由您提供。
- en: The complete example from this section is named *jOOQ DAO*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的完整示例命名为 *jOOQ DAO*。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered several approaches to developing, from scratch,
    a DAO layer or evolving the jOOQ-generated DAO layer in a Spring Boot and jOOQ
    application. Each of the presented applications can serve as a stub application
    for your own applications. Just choose the one that is suitable for you, replace
    the schema, and start developing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了从零开始开发 DAO 层或演进 jOOQ 生成的 DAO 层在 Spring Boot 和 jOOQ 应用程序中的几种方法。所展示的每个应用程序都可以作为您自己应用程序的占位符应用程序。只需选择适合您的一个，替换模式，然后开始开发。
- en: In the next chapter, we'll use jOOQ to express a wide range of queries involving
    `SELECT`, `INSERT`, `UPDATE`, and `DELETE`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 jOOQ 表达涉及 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 的广泛查询。
