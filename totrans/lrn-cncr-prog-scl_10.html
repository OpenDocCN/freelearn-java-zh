<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 10.  Reactors"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/><span class="koboSpan" id="kobo.1.1">Chapter 10.    Reactors   </span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"Simplicity is prerequisite for reliability."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Edsger W. </span><span class="koboSpan" id="kobo.7.2">Dijkstra</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">Location-transparency, serializable event-handling, and non-blocking semantics of sends, make the actor model a powerful foundation for building distributed systems. </span><span class="koboSpan" id="kobo.8.2">However, the actor model has several important limitations, which only become apparent when building larger systems. </span><span class="koboSpan" id="kobo.8.3">First, actors cannot simultaneously contain multiple message entry points. </span><span class="koboSpan" id="kobo.8.4">All messages must arrive through the same </span><code class="literal"><span class="koboSpan" id="kobo.9.1">receive</span></code><span class="koboSpan" id="kobo.10.1"> block. </span><span class="koboSpan" id="kobo.10.2">Consequently, two different protocols cannot reuse the same message type, and must be aware of each other. </span><span class="koboSpan" id="kobo.10.3">The main example where we saw this was the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Identify</span></code><span class="koboSpan" id="kobo.12.1"> message, which required users to incorporate a unique token into the message. </span><span class="koboSpan" id="kobo.12.2">Second, actors cannot await specific combinations of messages. </span><span class="koboSpan" id="kobo.12.3">For example, it is cumbersome to simultaneously send a request message to two target actors, and proceed after both replies arrive. </span><span class="koboSpan" id="kobo.12.4">Third, the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">receive</span></code><span class="koboSpan" id="kobo.14.1"> statement is not a first-class citizen. </span><span class="koboSpan" id="kobo.14.2">Event streams, which we saw in the Rx framework, are first-class citizens, and this improves program composition, modularity, and separation of concerns.</span></p><p><span class="koboSpan" id="kobo.15.1">In this chapter, we study the reactor programming model for distributed computing, which retains the advantages of the actor model, but overcomes the above limitations. </span><span class="koboSpan" id="kobo.15.2">This framework allows creating complex concurrent and distributed applications more easily, by providing correct, robust, and composable abstractions for distributed programming. </span><span class="koboSpan" id="kobo.15.3">Similar to the actor model, the reactor model allows writing location-transparent programs. </span><span class="koboSpan" id="kobo.15.4">Clear separation between units of concurrency is achieved through special entities called reactors. </span><span class="koboSpan" id="kobo.15.5">This separation makes it easier to reason about concurrent programs, as was the case with actors. </span><span class="koboSpan" id="kobo.15.6">However, computations and message exchange patterns can be more easily subdivided into modular components in the reactor model. </span><span class="koboSpan" id="kobo.15.7">The improved composition at the core of the reactor model is the result of a careful integration of the traditional actor model and functional reactive programming concepts.</span></p><p><span class="koboSpan" id="kobo.16.1">We use the Reactors framework throughout this chapter to learn about the reactor programming model. </span><span class="koboSpan" id="kobo.16.2">We will cover the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.17.1">Utilizing and composing event-streams to structure logic within a reactor</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.18.1">Defining reactors and starting reactor instances</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.19.1">Customizing reactor instances and using custom schedulers</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.20.1">Using reactor system services to access non-standard events, and defining custom services</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.21.1">The basics of protocol composition, along with several concrete protocol examples</span></li></ul></div><p><span class="koboSpan" id="kobo.22.1">We start by recounting what we learned about concurrent and distributed programming, and explaining why the reactor model is important.</span></p><div class="section" title="The need for reactors"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec64"/><span class="koboSpan" id="kobo.23.1">The need for reactors</span></h1></div></div></div><p><span class="koboSpan" id="kobo.24.1">As you may have concluded by reading this book, writing concurrent and distributed programs is not easy. </span><span class="koboSpan" id="kobo.24.2">Ensuring program correctness, scalability, and fault-tolerance is harder than in a sequential program. </span><span class="koboSpan" id="kobo.24.3">Here, we recall some of the reasons for this:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.25.1">First of all, most concurrent and distributed computations are, by their nature, non-deterministic. </span><span class="koboSpan" id="kobo.25.2">This non-determinism is not a consequence of poor programming abstractions, but is inherent in systems that need to react to external events.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.26.1">Data races are a basic characteristic of most shared-memory multicore systems. </span><span class="koboSpan" id="kobo.26.2">Combined with inherent non-determinism, these lead to subtle bugs that are hard to detect or reproduce.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.27.1">When it comes to distributed computing, things get even more complicated. </span><span class="koboSpan" id="kobo.27.2">Random faults, network outages, or interruptions, present in distributed programming, compromise correctness and robustness of distributed systems.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.28.1">Furthermore, shared-memory programs do not work in distributed environments, and existing shared-memory programs are not easily ported to a distributed setup.</span></li></ul></div><p><span class="koboSpan" id="kobo.29.1">There is one more reason why concurrent and distributed programming is hard. </span><span class="koboSpan" id="kobo.29.2">When building large systems, we would like to compose simpler program components into larger entities. </span><span class="koboSpan" id="kobo.29.3">However, it is often hard to correctly compose concurrent and distributed programs. </span><span class="koboSpan" id="kobo.29.4">Correctness of specific components is no guarantee for global program correctness when those components are used together. </span><span class="koboSpan" id="kobo.29.5">Deadlocks inherent to locks are one such example, and potential race conditions in actors are another.</span></p><p><span class="koboSpan" id="kobo.30.1">Frameworks that we have seen in this book strive to address the aforementioned problems in concurrent and distributed programming. </span><span class="koboSpan" id="kobo.30.2">Different concurrency models try to address these issues from different angles. </span><span class="koboSpan" id="kobo.30.3">The intent of the reactor model, described in this chapter, is to borrow some of the best characteristics of existing frameworks, such as location-transparency, serializability and data-race freedom, and especially address the issue of composability.</span></p><p><span class="koboSpan" id="kobo.31.1">To achieve these goals, the reactor model employs several minimalist abstractions, which can compose into complex protocols, algorithms, and program components. </span><span class="koboSpan" id="kobo.31.2">In particular, the model is based on the following:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.32.1">Location-transparent </span><span class="strong"><strong><span class="koboSpan" id="kobo.33.1">reactors</span></strong></span><span class="koboSpan" id="kobo.34.1">, lightweight entities that execute concurrently with each other, but are internally always single-threaded, and can be ported from a single machine to a distributed setting. </span><span class="koboSpan" id="kobo.34.2">Every reactor is created with one main event stream. </span><span class="koboSpan" id="kobo.34.3">A reactor is a generalization of an actor from the traditional actor model.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.35.1">Asynchronous first-class </span><span class="strong"><strong><span class="koboSpan" id="kobo.36.1">event streams</span></strong></span><span class="koboSpan" id="kobo.37.1"> that can be reasoned about in a declarative, functional manner, and are the basis for composing components. </span><span class="koboSpan" id="kobo.37.2">An event stream is the reading end of a channel. </span><span class="koboSpan" id="kobo.37.3">Only the reactor that owns the channel can read from the corresponding event stream. </span><span class="koboSpan" id="kobo.37.4">Event streams cannot be shared between different reactors. </span><span class="koboSpan" id="kobo.37.5">To borrow the analogy from the actor model, an event stream is a counterpart of the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">receive</span></code><span class="koboSpan" id="kobo.39.1"> statement.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.40.1">Channels</span></strong></span><span class="koboSpan" id="kobo.41.1"> that can be shared between reactors, and are used to send events asynchronously. </span><span class="koboSpan" id="kobo.41.2">A channel is the writing end of the corresponding event stream, and any number of reactors can write to a channel. </span><span class="koboSpan" id="kobo.41.3">A channel is a close equivalent of the actor reference that we saw in the actor model.</span></li></ul></div><p><span class="koboSpan" id="kobo.42.1">These three unique abstractions are the core prerequisite for building powerful distributed computing abstractions. </span><span class="koboSpan" id="kobo.42.2">Most other utilities in the Reactors framework, which we study in this chapter, are built in terms of reactors, channels, and event streams.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Getting started with Reactors"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec65"/><span class="koboSpan" id="kobo.1.1">Getting started with Reactors</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">This section contains instructions on how to get Reactors working in your project. </span><span class="koboSpan" id="kobo.2.2">The Reactors framework has multiple languages frontend, and works on multiple platforms. </span><span class="koboSpan" id="kobo.2.3">At the time of writing this book, Reactors can be used with Scala and Java as a JVM library, or alternatively on NodeJS or inside the browser if you are using the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Scala.js</span></code><span class="koboSpan" id="kobo.4.1"> frontend of Reactors.</span></p><p><span class="koboSpan" id="kobo.5.1">If you are developing with SBT, the easiest way is to include Reactors into your project as a library dependency. </span><span class="koboSpan" id="kobo.5.2">To get started with </span><code class="literal"><span class="koboSpan" id="kobo.6.1">Reactors.IO</span></code><span class="koboSpan" id="kobo.7.1">, you should grab the latest snapshot version distributed on </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">Maven</span></strong></span><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">If you are using SBT, add the following to your project definition:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">resolvers ++= Seq( 
  "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots", 
  "Sonatype OSS Releases" at "https://oss.sonatype.org/content/repositories/releases" 
) 
libraryDependencies ++= Seq( 
  "io.reactors" %% "reactors" % "0.8") 
</span></pre><p><span class="koboSpan" id="kobo.11.1">At the time of writing this, the latest version is </span><code class="literal"><span class="koboSpan" id="kobo.12.1">0.8</span></code><span class="koboSpan" id="kobo.13.1"> for Scala </span><code class="literal"><span class="koboSpan" id="kobo.14.1">2.11</span></code><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">After a version of Reactors is released for Scala </span><code class="literal"><span class="koboSpan" id="kobo.16.1">2.12</span></code><span class="koboSpan" id="kobo.17.1">, you might have to replace the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">0.8</span></code><span class="koboSpan" id="kobo.19.1"> version in the preceding code.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The &quot;Hello World&quot; program"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec66"/><span class="koboSpan" id="kobo.1.1">The "Hello World" program</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we go through a simple, working Hello World program. </span><span class="koboSpan" id="kobo.2.2">We will not go into too much, yet we will provide deeper information in the subsequent sections. </span><span class="koboSpan" id="kobo.2.3">For now, we will just define a reactor that waits for one incoming event, prints a message to the standard output once this event arrives, and then terminate.</span></p><p><span class="koboSpan" id="kobo.3.1">We start by importing the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.4.1">io.reactors</span></code><span class="koboSpan" id="kobo.5.1"> package:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.6.1">import io.reactors._ 
</span></pre><p><span class="koboSpan" id="kobo.7.1">This allows us to use the facilities provided by the Reactors framework. </span><span class="koboSpan" id="kobo.7.2">In the following snippet, we declare a simple reactor-based program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">
object ReactorHelloWorld { 
  def main(args: Array[String]): Unit = { 
    val welcomeReactor = Reactor[String] { self =&gt; 
      self.main.events onEvent { name =&gt; 
        println(s"Welcome, $name!") 
        self.main.seal() 
      } 
    } 
    val system = ReactorSystem.default("test-system") 
    val ch = system.spawn(welcomeReactor) 
    ch ! </span><span class="koboSpan" id="kobo.8.2">"Alan" 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.9.1">The program above declares an anonymous reactor called </span><code class="literal"><span class="koboSpan" id="kobo.10.1">welcomeReactor</span></code><span class="koboSpan" id="kobo.11.1">, which waits for a name to arrive on its main event stream, prints that name, and then seals its main channel, therefore terminating itself. </span><span class="koboSpan" id="kobo.11.2">The main program then creates a new reactor system, uses the reactor template to start a new running instance of the previously defined </span><code class="literal"><span class="koboSpan" id="kobo.12.1">welcomeReactor</span></code><span class="koboSpan" id="kobo.13.1">, and sends an event </span><code class="literal"><span class="koboSpan" id="kobo.14.1">"Alan"</span></code><span class="koboSpan" id="kobo.15.1"> to it.</span></p><p><span class="koboSpan" id="kobo.16.1">By analyzing the previous program, we conclude the following:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.17.1">A reactor is defined using the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Reactor[T]</span></code><span class="koboSpan" id="kobo.19.1"> constructor, where </span><code class="literal"><span class="koboSpan" id="kobo.20.1">T</span></code><span class="koboSpan" id="kobo.21.1"> is the type of the events that can be sent to the reactor on its main channel.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.22.1">A reactor reacts to incoming events as specified in the callback function passed to the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">onEvent</span></code><span class="koboSpan" id="kobo.24.1"> method. </span><span class="koboSpan" id="kobo.24.2">We can call </span><code class="literal"><span class="koboSpan" id="kobo.25.1">onEvent</span></code><span class="koboSpan" id="kobo.26.1">, for example, on the main event stream of the reactor, which is obtained with the expression </span><code class="literal"><span class="koboSpan" id="kobo.27.1">main.events</span></code><span class="koboSpan" id="kobo.28.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.29.1">Calling </span><code class="literal"><span class="koboSpan" id="kobo.30.1">main.seal()</span></code><span class="koboSpan" id="kobo.31.1"> terminates the reactor.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.32.1">A reactor with a specific definition is started with the </span><code class="literal"><span class="koboSpan" id="kobo.33.1">spawn</span></code><span class="koboSpan" id="kobo.34.1"> method, which returns the reactor's main channel.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.35.1">Events are sent to the reactor by calling the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">!</span></code><span class="koboSpan" id="kobo.37.1"> operator on one of its channels.</span></li></ul></div><p><span class="koboSpan" id="kobo.38.1">The subsequent sections will explain each of these features in greater depth.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Event streams"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec67"/><span class="koboSpan" id="kobo.1.1">Event streams</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we study the basic data-type that drives most computations in the Reactors framework: an event stream. </span><span class="koboSpan" id="kobo.2.2">Event streams represent special program values that can occasionally produce events. </span><span class="koboSpan" id="kobo.2.3">Event streams are represented by the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Event[T]</span></code><span class="koboSpan" id="kobo.4.1"> type.</span></p><p><span class="koboSpan" id="kobo.5.1">Semantically, an event stream is very similar to the </span><code class="literal"><span class="koboSpan" id="kobo.6.1">Observable</span></code><span class="koboSpan" id="kobo.7.1"> type, which we saw in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.8.1">Chapter 6</span></a><span class="koboSpan" id="kobo.9.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">As we will see, the main difference between </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Observable</span></code><span class="koboSpan" id="kobo.13.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Events</span></code><span class="koboSpan" id="kobo.15.1"> is that an </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Observable</span></code><span class="koboSpan" id="kobo.17.1"> object can generally be used from different threads, and even emit events across different threads when the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">observeOn</span></code><span class="koboSpan" id="kobo.19.1"> method is used. </span><span class="koboSpan" id="kobo.19.2">An </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Events</span></code><span class="koboSpan" id="kobo.21.1"> object, by contrast, can only be used inside the reactor that owns that event stream.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip107"/><span class="koboSpan" id="kobo.22.1">Tip</span></h3><p><span class="koboSpan" id="kobo.23.1">Never share an event stream between two reactors. </span><span class="koboSpan" id="kobo.23.2">An event stream can only be used by the reactor that owns the corresponding channel.</span></p></div></div><p><span class="koboSpan" id="kobo.24.1">In the following, we show an example event stream called </span><code class="literal"><span class="koboSpan" id="kobo.25.1">myEvents</span></code><span class="koboSpan" id="kobo.26.1">, which produces events of type </span><code class="literal"><span class="koboSpan" id="kobo.27.1">String</span></code><span class="koboSpan" id="kobo.28.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">val myEvents: Events[String] = createEventStreamOfStrings() 
</span></pre><p><span class="koboSpan" id="kobo.30.1">For now, we assume that the method </span><code class="literal"><span class="koboSpan" id="kobo.31.1">createEventStreamOfStrings</span></code><span class="koboSpan" id="kobo.32.1"> is already defined, and that it returns an event stream of type </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Events[String]</span></code><span class="koboSpan" id="kobo.34.1">.</span></p><p><span class="koboSpan" id="kobo.35.1">To be useful, an event stream must allow the users to somehow manipulate the events it produces. </span><span class="koboSpan" id="kobo.35.2">For this purpose, every event stream has a method called </span><code class="literal"><span class="koboSpan" id="kobo.36.1">onEvent</span></code><span class="koboSpan" id="kobo.37.1">, which takes a user callback function and invokes it every time an event arrives:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">myEvents.onEvent(x =&gt; println(x)) 
</span></pre><p><span class="koboSpan" id="kobo.39.1">The </span><code class="literal"><span class="koboSpan" id="kobo.40.1">onEvent</span></code><span class="koboSpan" id="kobo.41.1"> method is similar to what most callback-based frameworks expose: a way to provide an executable snippet of code that is invoked later, once an event becomes available. </span><span class="koboSpan" id="kobo.41.2">However, just like the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">Observable</span></code><span class="koboSpan" id="kobo.43.1"> object in Reactive Extensions, the receiver of the </span><code class="literal"><span class="koboSpan" id="kobo.44.1">onEvent</span></code><span class="koboSpan" id="kobo.45.1"> method, that is, the event stream, is a first-class value. </span><span class="koboSpan" id="kobo.45.2">This subtle difference allows passing the event stream as an argument to other methods, and consequently allows writing more general abstractions. </span><span class="koboSpan" id="kobo.45.3">For example, we can implement a reusable </span><code class="literal"><span class="koboSpan" id="kobo.46.1">trace</span></code><span class="koboSpan" id="kobo.47.1"> method as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">def trace[T](events: Events[T]): Unit = { 
  events.onEvent(println) 
} 
</span></pre><p><span class="koboSpan" id="kobo.49.1">The </span><code class="literal"><span class="koboSpan" id="kobo.50.1">onEvent</span></code><span class="koboSpan" id="kobo.51.1"> method returns a special </span><code class="literal"><span class="koboSpan" id="kobo.52.1">Subscription</span></code><span class="koboSpan" id="kobo.53.1"> object. </span><span class="koboSpan" id="kobo.53.2">Events are propagated to the user-specified callback until the user decides to call the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">unsubscribe</span></code><span class="koboSpan" id="kobo.55.1"> method of that </span><code class="literal"><span class="koboSpan" id="kobo.56.1">Subscription</span></code><span class="koboSpan" id="kobo.57.1"> object. </span><span class="koboSpan" id="kobo.57.2">These </span><code class="literal"><span class="koboSpan" id="kobo.58.1">Subscription</span></code><span class="koboSpan" id="kobo.59.1"> objects have similar semantics as those seen in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.60.1">Reactive Extensions</span></strong></span><span class="koboSpan" id="kobo.61.1"> framework.</span></p><p><span class="koboSpan" id="kobo.62.1">Before we continue, we note that event streams are entirely a single-threaded entity. </span><span class="koboSpan" id="kobo.62.2">The same event stream will never concurrently produce two events at the same time, so the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">onEvent</span></code><span class="koboSpan" id="kobo.64.1"> method will never be invoked by two different threads at the same time on the same event stream. </span><span class="koboSpan" id="kobo.64.2">As we will see, this property simplifies the programming model and makes event-based programs easier to reason about.</span></p><p><span class="koboSpan" id="kobo.65.1">To understand this better, let's study a concrete event stream called an emitter, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">Events.Emitter[T]</span></code><span class="koboSpan" id="kobo.67.1"> type. </span><span class="koboSpan" id="kobo.67.2">In the following, we instantiate an emitter:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.68.1">val emitter = new Events.Emitter[Int] 
</span></pre><p><span class="koboSpan" id="kobo.69.1">An emitter is simultaneously an event stream and an event source. </span><span class="koboSpan" id="kobo.69.2">We can imperatively tell the emitter to produce an event by calling its </span><code class="literal"><span class="koboSpan" id="kobo.70.1">react</span></code><span class="koboSpan" id="kobo.71.1"> method. </span><span class="koboSpan" id="kobo.71.2">When we do that, the emitter invokes the callbacks previously registered with the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">onEvent</span></code><span class="koboSpan" id="kobo.73.1"> method.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.74.1">var luckyNumber = 0 
emitter.onEvent(luckyNumber = _) 
emitter.react(7) 
assert(luckyNumber == 7) 
emitter.react(8) 
assert(luckyNumber == 8) 
</span></pre><p><span class="koboSpan" id="kobo.75.1">By running the above snippet, we convince ourselves that the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">react</span></code><span class="koboSpan" id="kobo.77.1"> call really forces the emitter to produce an event. </span><span class="koboSpan" id="kobo.77.2">Furthermore, the call </span><code class="literal"><span class="koboSpan" id="kobo.78.1">emitter.react(8)</span></code><span class="koboSpan" id="kobo.79.1"> will always execute after </span><code class="literal"><span class="koboSpan" id="kobo.80.1">emitter.react(7)</span></code><span class="koboSpan" id="kobo.81.1">, and the callback will be first invoked with </span><code class="literal"><span class="koboSpan" id="kobo.82.1">7</span></code><span class="koboSpan" id="kobo.83.1">, and then with </span><code class="literal"><span class="koboSpan" id="kobo.84.1">8</span></code><span class="koboSpan" id="kobo.85.1">, but not concurrently. </span><span class="koboSpan" id="kobo.85.2">Event propagation will occur on the same thread on which </span><code class="literal"><span class="koboSpan" id="kobo.86.1">react</span></code><span class="koboSpan" id="kobo.87.1"> was called.</span></p><div class="section" title="Lifecycle of an event stream"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec89"/><span class="koboSpan" id="kobo.88.1">Lifecycle of an event stream</span></h2></div></div></div><p><span class="koboSpan" id="kobo.89.1">We now take a closer look at the events that an event stream can produce. </span><span class="koboSpan" id="kobo.89.2">An event stream of type </span><code class="literal"><span class="koboSpan" id="kobo.90.1">Events[T]</span></code><span class="koboSpan" id="kobo.91.1"> usually emits events of type </span><code class="literal"><span class="koboSpan" id="kobo.92.1">T</span></code><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">However, type </span><code class="literal"><span class="koboSpan" id="kobo.94.1">T</span></code><span class="koboSpan" id="kobo.95.1"> is not the only type of events that an event stream can produce. </span><span class="koboSpan" id="kobo.95.2">Some event streams are finite. </span><span class="koboSpan" id="kobo.95.3">After they emit all their events, they emit a special event that denotes that there will be no further events. </span><span class="koboSpan" id="kobo.95.4">Sometimes, event streams run into exceptional situations, and emit exceptions instead of normal events.</span></p><p><span class="koboSpan" id="kobo.96.1">The </span><code class="literal"><span class="koboSpan" id="kobo.97.1">onEvent</span></code><span class="koboSpan" id="kobo.98.1"> method that we saw earlier can only react to normal events. </span><span class="koboSpan" id="kobo.98.2">To listen to other event kinds, event streams have the more general </span><code class="literal"><span class="koboSpan" id="kobo.99.1">onReaction</span></code><span class="koboSpan" id="kobo.100.1"> method. </span><span class="koboSpan" id="kobo.100.2">The </span><code class="literal"><span class="koboSpan" id="kobo.101.1">onReaction</span></code><span class="koboSpan" id="kobo.102.1"> method takes an </span><code class="literal"><span class="koboSpan" id="kobo.103.1">Observer</span></code><span class="koboSpan" id="kobo.104.1"> object as an argument. </span><span class="koboSpan" id="kobo.104.2">An </span><code class="literal"><span class="koboSpan" id="kobo.105.1">Observer</span></code><span class="koboSpan" id="kobo.106.1"> object has three different methods used to react to different event types. </span><span class="koboSpan" id="kobo.106.2">In the following code snippet, we instantiate an emitter and listen to all its events:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.107.1">var seen = List[Int]() 
var errors = List[String]() 
var done = 0 
val e = new Events.Emitter[Int] 
e.onReaction(new Observer[Int] { 
  def react(x: Int, hint: Any) = seen ::= x 
  def except(t: Throwable) = errors ::= t.getMessage 
  def unreact() = done += 1 
}) 
</span></pre><p><span class="koboSpan" id="kobo.108.1">The type  </span><code class="literal"><span class="koboSpan" id="kobo.109.1">Observer[T]</span></code><span class="koboSpan" id="kobo.110.1"> has three methods:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.111.1">The </span><code class="literal"><span class="koboSpan" id="kobo.112.1">react</span></code><span class="koboSpan" id="kobo.113.1"> method, which is invoked when a normal event gets emitted. </span><span class="koboSpan" id="kobo.113.2">The second, optional hint argument may contain an additional value, but is usually set to </span><code class="literal"><span class="koboSpan" id="kobo.114.1">null</span></code><span class="koboSpan" id="kobo.115.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.116.1">The </span><code class="literal"><span class="koboSpan" id="kobo.117.1">except</span></code><span class="koboSpan" id="kobo.118.1"> method, which is invoked when the event stream produces an exception. </span><span class="koboSpan" id="kobo.118.2">An event stream can produce multiple exceptions. </span><span class="koboSpan" id="kobo.118.3">An exception, however, does not terminate the stream, and many exceptions can be emitted by the same event stream. </span><span class="koboSpan" id="kobo.118.4">This is one big difference with respect to the type </span><code class="literal"><span class="koboSpan" id="kobo.119.1">Observable</span></code><span class="koboSpan" id="kobo.120.1"> from Reactive Extensions.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.121.1">The </span><code class="literal"><span class="koboSpan" id="kobo.122.1">unreact</span></code><span class="koboSpan" id="kobo.123.1"> method, which is invoked when the event stream stops producing events. </span><span class="koboSpan" id="kobo.123.2">After this method is invoked on the observer, no further events or exceptions will be produced by the event stream.</span></li></ul></div><p><span class="koboSpan" id="kobo.124.1">Let's assert that this contract is correct for </span><code class="literal"><span class="koboSpan" id="kobo.125.1">Events.Emitter</span></code><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">We already learned that we can produce events with emitters by calling the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">react</span></code><span class="koboSpan" id="kobo.128.1"> method. </span><span class="koboSpan" id="kobo.128.2">We can similarly call </span><code class="literal"><span class="koboSpan" id="kobo.129.1">except</span></code><span class="koboSpan" id="kobo.130.1"> to produce exceptions, or the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">unreact</span></code><span class="koboSpan" id="kobo.132.1"> method to signal that there will be no more events. </span><span class="koboSpan" id="kobo.132.2">For example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.133.1">e.react(1) 
e.react(2) 
e.except(new Exception("^_^")) 
e.react(3) 
assert(seen == 3 :: 2 :: 1 :: Nil) 
assert(errors == "^_^" :: Nil) 
assert(done == 0) 
e.unreact() 
assert(done == 1) 
e.react(4) 
e.except(new Exception("o_O")) 
assert(seen == 3 :: 2 :: 1 :: Nil) 
assert(errors == "^_^" :: Nil) 
assert(done == 1) 
</span></pre><p><span class="koboSpan" id="kobo.134.1">If you run the preceding code snippet, you will see that, after calling the </span><code class="literal"><span class="koboSpan" id="kobo.135.1">unreact</span></code><span class="koboSpan" id="kobo.136.1"> method, subsequent calls to the </span><code class="literal"><span class="koboSpan" id="kobo.137.1">react</span></code><span class="koboSpan" id="kobo.138.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.139.1">except</span></code><span class="koboSpan" id="kobo.140.1"> methods have no effect, and the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">unreact</span></code><span class="koboSpan" id="kobo.142.1"> call effectively terminates the emitter. </span><span class="koboSpan" id="kobo.142.2">Not all event streams are as imperative as emitters, however. </span><span class="koboSpan" id="kobo.142.3">Most other event streams are created by functionally composing different event streams.</span></p></div><div class="section" title="Functional composition of event streams"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec90"/><span class="koboSpan" id="kobo.143.1">Functional composition of event streams</span></h2></div></div></div><p><span class="koboSpan" id="kobo.144.1">Using event stream methods such as </span><code class="literal"><span class="koboSpan" id="kobo.145.1">onEvent</span></code><span class="koboSpan" id="kobo.146.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.147.1">onReaction</span></code><span class="koboSpan" id="kobo.148.1"> can easily result in a callback hell: a program composed of a large number of unstructured </span><code class="literal"><span class="koboSpan" id="kobo.149.1">onXYZ</span></code><span class="koboSpan" id="kobo.150.1"> calls, which is hard to understand and maintain. </span><span class="koboSpan" id="kobo.150.2">Having first-class event streams is a step in the right direction, but it is not sufficient.</span></p><p><span class="koboSpan" id="kobo.151.1">Event streams support functional composition, seen in the earlier chapters. </span><span class="koboSpan" id="kobo.151.2">This pattern allows declaratively forming complex values by composing simpler ones. </span><span class="koboSpan" id="kobo.151.3">Consider the following example, in which we compute the sum of squares of incoming events:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.152.1">var squareSum = 0 
val e = new Events.Emitter[Int] 
e.onEvent(x =&gt; squareSum += x * x) 
for (i &lt;- 0 until 5) e react i 
</span></pre><p><span class="koboSpan" id="kobo.153.1">The example is fairly straightforward, but what if we want to make </span><code class="literal"><span class="koboSpan" id="kobo.154.1">squareSum</span></code><span class="koboSpan" id="kobo.155.1"> an event stream so that another part of the program can react to its changes? </span><span class="koboSpan" id="kobo.155.2">We would have to create another emitter and have our </span><code class="literal"><span class="koboSpan" id="kobo.156.1">onEvent</span></code><span class="koboSpan" id="kobo.157.1"> callback invoke the </span><code class="literal"><span class="koboSpan" id="kobo.158.1">react</span></code><span class="koboSpan" id="kobo.159.1"> method on that new emitter, passing it the value of </span><code class="literal"><span class="koboSpan" id="kobo.160.1">squareSum</span></code><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">This could work, but it is not elegant, as shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.162.1">val ne = new Events.Emitter[Int] 
e onEvent { x =&gt; 
  squareSum += x * x 
  ne.react(squareSum) 
} 
</span></pre><p><span class="koboSpan" id="kobo.163.1">We now rewrite the previous snippet using event stream combinators. </span><span class="koboSpan" id="kobo.163.2">Concretely, we use the </span><code class="literal"><span class="koboSpan" id="kobo.164.1">map</span></code><span class="koboSpan" id="kobo.165.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.166.1">scanPast</span></code><span class="koboSpan" id="kobo.167.1"> combinators. </span><span class="koboSpan" id="kobo.167.2">The </span><code class="literal"><span class="koboSpan" id="kobo.168.1">map</span></code><span class="koboSpan" id="kobo.169.1"> combinator transforms events in one event stream into events for a derived event stream. </span><span class="koboSpan" id="kobo.169.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.170.1">map</span></code><span class="koboSpan" id="kobo.171.1"> combinatory to produce a square of each integer event. </span><span class="koboSpan" id="kobo.171.2">The </span><code class="literal"><span class="koboSpan" id="kobo.172.1">scanPast</span></code><span class="koboSpan" id="kobo.173.1"> combinator combines the last and the current event to produce a new event for the derived event stream. </span><span class="koboSpan" id="kobo.173.2">We use </span><code class="literal"><span class="koboSpan" id="kobo.174.1">scanPast</span></code><span class="koboSpan" id="kobo.175.1"> to add the previous value of the sum to the current one. </span><span class="koboSpan" id="kobo.175.2">For example, if an input event stream produces numbers </span><code class="literal"><span class="koboSpan" id="kobo.176.1">0</span></code><span class="koboSpan" id="kobo.177.1">, </span><code class="literal"><span class="koboSpan" id="kobo.178.1">1</span></code><span class="koboSpan" id="kobo.179.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.180.1">2</span></code><span class="koboSpan" id="kobo.181.1">, the event stream produced by </span><code class="literal"><span class="koboSpan" id="kobo.182.1">scanPast(0)(_ + _)</span></code><span class="koboSpan" id="kobo.183.1"> would produce numbers </span><code class="literal"><span class="koboSpan" id="kobo.184.1">0</span></code><span class="koboSpan" id="kobo.185.1">, </span><code class="literal"><span class="koboSpan" id="kobo.186.1">1</span></code><span class="koboSpan" id="kobo.187.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.188.1">3</span></code><span class="koboSpan" id="kobo.189.1">.</span></p><p><span class="koboSpan" id="kobo.190.1">Here is how we can rewrite the previous example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.191.1">val e = new Events.Emitter[Int] 
val sum = e.map(x =&gt; x * x).scanPast(0)(_ + _) 
for (i &lt;- 0 until 5) e react i 
</span></pre><p><span class="koboSpan" id="kobo.192.1">The type </span><code class="literal"><span class="koboSpan" id="kobo.193.1">Events[T]</span></code><span class="koboSpan" id="kobo.194.1"> comes with a large number of predefined combinators. </span><span class="koboSpan" id="kobo.194.2">You can find other combinators in the online API documentation. </span><span class="koboSpan" id="kobo.194.3">A set of event streams composed using functional combinators forms a dataflow graph. </span><span class="koboSpan" id="kobo.194.4">Emitters are usually source nodes in this graph, event streams created by various combinators are inner nodes, and callback methods, such as </span><code class="literal"><span class="koboSpan" id="kobo.195.1">onEvent</span></code><span class="koboSpan" id="kobo.196.1">, are sink nodes. </span><span class="koboSpan" id="kobo.196.2">Combinators such as </span><code class="literal"><span class="koboSpan" id="kobo.197.1">union</span></code><span class="koboSpan" id="kobo.198.1"> take several input event streams. </span><span class="koboSpan" id="kobo.198.2">Such event streams correspond to graph nodes with multiple input edges. </span><span class="koboSpan" id="kobo.198.3">Here is one example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.199.1">val numbers = new Events.Emitter[Int] 
val even = numbers.filter(_ % 2 == 0) 
val odd = numbers.filter(_ % 2 == 1) 
val numbersAgain = even union odd 
</span></pre><p><span class="koboSpan" id="kobo.200.1">Dataflow graphs induced by event streams are similar in nature to dataflow graphs induced by Scala futures and </span><code class="literal"><span class="koboSpan" id="kobo.201.1">Observable</span></code><span class="koboSpan" id="kobo.202.1"> objects from Reactive Extensions, so we will not study them further in this chapter. </span><span class="koboSpan" id="kobo.202.2">The most important thing to remember about event streams in the reactor model is that they are single-threaded entities. </span><span class="koboSpan" id="kobo.202.3">As we will see in the next section, each event stream can only belong to a single reactor.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Reactors"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec68"/><span class="koboSpan" id="kobo.1.1">Reactors</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">As we learned previously, event streams always propagate events on a single thread. </span><span class="koboSpan" id="kobo.2.2">This is useful from the standpoint of program comprehension, but we still need a way to express concurrency in our programs. </span><span class="koboSpan" id="kobo.2.3">In this section, we will see how to achieve concurrency by using entities called reactors.</span></p><p><span class="koboSpan" id="kobo.3.1">A reactor is the basic unit of concurrency. </span><span class="koboSpan" id="kobo.3.2">While actors receive messages, we will adopt the terminology in which reactors receive events, in order to disambiguate. </span><span class="koboSpan" id="kobo.3.3">However, while an actor a in particular state has only a single point where it can receive a message, namely, the </span><code class="literal"><span class="koboSpan" id="kobo.4.1">receive</span></code><span class="koboSpan" id="kobo.5.1"> statement, a reactor can receive an event from many different sources at any time. </span><span class="koboSpan" id="kobo.5.2">Despite this flexibility, one reactor will always process, at most, one event at any time. </span><span class="koboSpan" id="kobo.5.3">We say that events received by a reactor are </span><span class="strong"><strong><span class="koboSpan" id="kobo.6.1">serialized</span></strong></span><span class="koboSpan" id="kobo.7.1">, similar to how messages received by an actor are serialized.</span></p><p><span class="koboSpan" id="kobo.8.1">To be able to create new reactors, we need a </span><code class="literal"><span class="koboSpan" id="kobo.9.1">ReactorSystem</span></code><span class="koboSpan" id="kobo.10.1"> object, which tracks reactors in a single machine:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">val system = new ReactorSystem("test-system") 
</span></pre><p><span class="koboSpan" id="kobo.12.1">Before we can start a reactor instance, we need to define its template. </span><span class="koboSpan" id="kobo.12.2">One way to do this is to call </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Reactor.apply[T]</span></code><span class="koboSpan" id="kobo.14.1"> method, which returns a </span><code class="literal"><span class="koboSpan" id="kobo.15.1">Proto</span></code><span class="koboSpan" id="kobo.16.1"> object for the reactor. </span><span class="koboSpan" id="kobo.16.2">The </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Proto</span></code><span class="koboSpan" id="kobo.18.1"> object is a reactor prototype, which can be used to start the reactor. </span><span class="koboSpan" id="kobo.18.2">The following reactor prints all the events it receives to the standard output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">val proto: Proto[Reactor[String]] = Reactor[String] { self =&gt; 
  self.main.events onEvent { 
    x =&gt; println(x) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.20.1">Let's examine this code more closely. </span><span class="koboSpan" id="kobo.20.2">The </span><code class="literal"><span class="koboSpan" id="kobo.21.1">Reactor.apply</span></code><span class="koboSpan" id="kobo.22.1"> method is called with the type argument </span><code class="literal"><span class="koboSpan" id="kobo.23.1">String</span></code><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">This means that the reactor encoded in the resulting </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Proto</span></code><span class="koboSpan" id="kobo.26.1"> object by default receives events whose type is </span><code class="literal"><span class="koboSpan" id="kobo.27.1">String</span></code><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">This is the first difference with respect to the standard actor model, in which actors can receive messages of any type. </span><span class="koboSpan" id="kobo.28.3">Events received by reactors are well typed.</span></p><p><span class="koboSpan" id="kobo.29.1">In the reactor model, every reactor can access a special event stream called </span><code class="literal"><span class="koboSpan" id="kobo.30.1">main.events</span></code><span class="koboSpan" id="kobo.31.1">, which emits events that the reactor receives from other reactors. </span><span class="koboSpan" id="kobo.31.2">Since we are declaring an anonymous reactor with the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">Reactor.apply</span></code><span class="koboSpan" id="kobo.33.1"> method, we need to add a prefix </span><code class="literal"><span class="koboSpan" id="kobo.34.1">self</span></code><span class="koboSpan" id="kobo.35.1"> to access members of the reactor. </span><span class="koboSpan" id="kobo.35.2">We previously learned that we can call </span><code class="literal"><span class="koboSpan" id="kobo.36.1">onEvent</span></code><span class="koboSpan" id="kobo.37.1"> to register callbacks to event streams, and we used it in this example to print the events using </span><code class="literal"><span class="koboSpan" id="kobo.38.1">println</span></code><span class="koboSpan" id="kobo.39.1">.</span></p><p><span class="koboSpan" id="kobo.40.1">After defining a reactor template, the next step is to spawn a new reactor. </span><span class="koboSpan" id="kobo.40.2">We do this by calling the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">spawn</span></code><span class="koboSpan" id="kobo.42.1"> method on the reactor system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">val ch: Channel[String] = system.spawn(proto) 
</span></pre><p><span class="koboSpan" id="kobo.44.1">The </span><code class="literal"><span class="koboSpan" id="kobo.45.1">spawn</span></code><span class="koboSpan" id="kobo.46.1"> method takes a </span><code class="literal"><span class="koboSpan" id="kobo.47.1">Proto</span></code><span class="koboSpan" id="kobo.48.1"> object as a parameter. </span><span class="koboSpan" id="kobo.48.2">The </span><code class="literal"><span class="koboSpan" id="kobo.49.1">Proto</span></code><span class="koboSpan" id="kobo.50.1"> object can generally encode the reactor's constructor arguments, scheduler, name, and other options. </span><span class="koboSpan" id="kobo.50.2">In our example, we created a </span><code class="literal"><span class="koboSpan" id="kobo.51.1">Proto</span></code><span class="koboSpan" id="kobo.52.1"> object for an anonymous reactor with the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">Reactor.apply</span></code><span class="koboSpan" id="kobo.54.1"> method, so we do not have access to any constructor arguments. </span><span class="koboSpan" id="kobo.54.2">We will later see alternative ways of declaring reactors and configuring prototypes.</span></p><p><span class="koboSpan" id="kobo.55.1">The </span><code class="literal"><span class="koboSpan" id="kobo.56.1">spawn</span></code><span class="koboSpan" id="kobo.57.1"> method does two things. </span><span class="koboSpan" id="kobo.57.2">First, it registers and starts a new reactor instance. </span><span class="koboSpan" id="kobo.57.3">Second, it returns a </span><code class="literal"><span class="koboSpan" id="kobo.58.1">Channel</span></code><span class="koboSpan" id="kobo.59.1"> object, which is used to send events to the newly created reactor. </span><span class="koboSpan" id="kobo.59.2">We show the relationship between a reactor, its event stream, and the channel in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.60.1"><img src="graphics/image_10_001.jpg" alt="Reactors"/></span></div><p><span class="koboSpan" id="kobo.61.1">The only way for the outside world to access the inside of a reactor is to send events to its channel. </span><span class="koboSpan" id="kobo.61.2">These events are eventually delivered to the corresponding event stream, which the reactor can listen to. </span><span class="koboSpan" id="kobo.61.3">The channel and event stream can only pass events whose type corresponds to the type of the reactor.</span></p><p><span class="koboSpan" id="kobo.62.1">Let's send an event to our reactor. </span><span class="koboSpan" id="kobo.62.2">We do this by calling the bang operator </span><code class="literal"><span class="koboSpan" id="kobo.63.1">!</span></code><span class="koboSpan" id="kobo.64.1"> on the channel:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.65.1">ch ! </span><span class="koboSpan" id="kobo.65.2">"Hola!" 
</span></pre><p><span class="koboSpan" id="kobo.66.1">Running the last statement should print the string </span><code class="literal"><span class="koboSpan" id="kobo.67.1">"Hola!"</span></code><span class="koboSpan" id="kobo.68.1"> to the standard output.</span></p><div class="section" title="Defining and configuring reactors"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec91"/><span class="koboSpan" id="kobo.69.1">Defining and configuring reactors</span></h2></div></div></div><p><span class="koboSpan" id="kobo.70.1">In earlier sections, we saw how to define a reactor using the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">Reactor.apply</span></code><span class="koboSpan" id="kobo.72.1"> method. </span><span class="koboSpan" id="kobo.72.2">In this section, we take a look at an alternative way of defining a reactor--by extending the </span><code class="literal"><span class="koboSpan" id="kobo.73.1">Reactor</span></code><span class="koboSpan" id="kobo.74.1"> base class. </span><span class="koboSpan" id="kobo.74.2">Recall that the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">Reactor.apply</span></code><span class="koboSpan" id="kobo.76.1"> method defines an anonymous reactor template. </span><span class="koboSpan" id="kobo.76.2">Extending the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">Reactor</span></code><span class="koboSpan" id="kobo.78.1"> class declares a named reactor template.</span></p><p><span class="koboSpan" id="kobo.79.1">In the following, we declare the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">HelloReactor</span></code><span class="koboSpan" id="kobo.81.1"> class, which must be top-level:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.82.1">class HelloReactor extends Reactor[String] { 
  main.events onEvent { 
    x =&gt; println(x) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.83.1">To run this reactor, we first create a prototype to configure it. </span><span class="koboSpan" id="kobo.83.2">The method </span><code class="literal"><span class="koboSpan" id="kobo.84.1">Proto.apply</span></code><span class="koboSpan" id="kobo.85.1"> takes the type of the reactor and returns a prototype for that reactor type. </span><span class="koboSpan" id="kobo.85.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">spawn</span></code><span class="koboSpan" id="kobo.87.1"> method with that </span><code class="literal"><span class="koboSpan" id="kobo.88.1">Proto</span></code><span class="koboSpan" id="kobo.89.1"> object to start the reactor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">val ch = system.spawn(Proto[HelloReactor]) 
ch ! </span><span class="koboSpan" id="kobo.90.2">"Howdee!" 
</span></pre><p><span class="koboSpan" id="kobo.91.1">We can also use the prototype to, for example, set the scheduler that the reactor instance should use. </span><span class="koboSpan" id="kobo.91.2">If we want the reactor instance to run on its own dedicated thread to give it more priority, we can do the following:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.92.1">system.spawn( 
  Proto[HelloReactor].withScheduler(JvmScheduler.Key.newThread)) 
</span></pre><p><span class="koboSpan" id="kobo.93.1">Note that if you are running Reactors on </span><code class="literal"><span class="koboSpan" id="kobo.94.1">Scala.js</span></code><span class="koboSpan" id="kobo.95.1">, you will need to use a </span><code class="literal"><span class="koboSpan" id="kobo.96.1">Scala.js</span></code><span class="koboSpan" id="kobo.97.1"> specific scheduler. </span><span class="koboSpan" id="kobo.97.2">The reason for this is because the JavaScript runtime, which </span><code class="literal"><span class="koboSpan" id="kobo.98.1">Scala.js</span></code><span class="koboSpan" id="kobo.99.1"> compiles to, is not multi-threaded. </span><span class="koboSpan" id="kobo.99.2">Asynchronous executions are placed on a single queue, and executed one after another. </span><span class="koboSpan" id="kobo.99.3">On </span><code class="literal"><span class="koboSpan" id="kobo.100.1">Scala.js</span></code><span class="koboSpan" id="kobo.101.1">, you will need to use the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">JsScheduler.Key.default</span></code><span class="koboSpan" id="kobo.103.1"> scheduler.</span></p><p><span class="koboSpan" id="kobo.104.1">There are several other configuration options for </span><code class="literal"><span class="koboSpan" id="kobo.105.1">Proto</span></code><span class="koboSpan" id="kobo.106.1"> objects, and you can find out more about them in the online API documentation. </span><span class="koboSpan" id="kobo.106.2">We can summarize this section as follows. </span><span class="koboSpan" id="kobo.106.3">Starting a reactor is generally a three-step process:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.107.1">A named reactor template is created by extending the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">Reactor</span></code><span class="koboSpan" id="kobo.109.1"> class.</span></li><li class="listitem"><span class="koboSpan" id="kobo.110.1">A reactor configuration object is created with the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">Proto.apply</span></code><span class="koboSpan" id="kobo.112.1"> method.</span></li><li class="listitem"><span class="koboSpan" id="kobo.113.1">A reactor instance is started with the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">spawn</span></code><span class="koboSpan" id="kobo.115.1"> method of the reactor system.</span></li></ol></div><p><span class="koboSpan" id="kobo.116.1">For convenience, we can fuse the first two steps by using the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">Reactor.apply</span></code><span class="koboSpan" id="kobo.118.1"> method, which creates an anonymous reactor template and directly returns a prototype object of type </span><code class="literal"><span class="koboSpan" id="kobo.119.1">Proto[I]</span></code><span class="koboSpan" id="kobo.120.1">, for some reactor type </span><code class="literal"><span class="koboSpan" id="kobo.121.1">I</span></code><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">Typically, this is what we do in the tests, or when trying things out in the Scala REPL.</span></p></div><div class="section" title="Using channels"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec92"/><span class="koboSpan" id="kobo.123.1">Using channels</span></h2></div></div></div><p><span class="koboSpan" id="kobo.124.1">Now that we understand how to create and configure reactors in different ways, we can take a closer look at channels, which are the reactor's means of communicating with its environment. </span><span class="koboSpan" id="kobo.124.2">As noted before, every reactor is created with a default channel called </span><code class="literal"><span class="koboSpan" id="kobo.125.1">main</span></code><span class="koboSpan" id="kobo.126.1">, which is often sufficient. </span><span class="koboSpan" id="kobo.126.2">But sometimes a reactor needs to be able to receive more than just one type of an event, and needs additional channels for this purpose.</span></p><p><span class="koboSpan" id="kobo.127.1">Let's declare a reactor that stores key-value pairs. </span><span class="koboSpan" id="kobo.127.2">The reactor must react to requests for storing key-value pairs, and for retrieving a value under a specific key. </span><span class="koboSpan" id="kobo.127.3">Since the reactor's input channel will have to serve two purposes, we need the following data type:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.128.1">trait Op[K, V] 
case class Put[K, V](k: K, v: V) extends Op[K, V] 
case class Get[K, V](k: K, ch: Channel[V]) extends Op[K, V] 
</span></pre><p><span class="koboSpan" id="kobo.129.1">The </span><code class="literal"><span class="koboSpan" id="kobo.130.1">Op</span></code><span class="koboSpan" id="kobo.131.1"> datatype has two type parameters called </span><code class="literal"><span class="koboSpan" id="kobo.132.1">K</span></code><span class="koboSpan" id="kobo.133.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.134.1">V</span></code><span class="koboSpan" id="kobo.135.1">, which denote the types of keys and values being stored. </span><span class="koboSpan" id="kobo.135.2">The </span><code class="literal"><span class="koboSpan" id="kobo.136.1">Put</span></code><span class="koboSpan" id="kobo.137.1"> case class is used to store a value into the reactor, so it contains the new key and value. </span><span class="koboSpan" id="kobo.137.2">The </span><code class="literal"><span class="koboSpan" id="kobo.138.1">Get</span></code><span class="koboSpan" id="kobo.139.1"> case class is used to retrieve the value that was previously stored with some key, so it encodes the key and the channel of type </span><code class="literal"><span class="koboSpan" id="kobo.140.1">V</span></code><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">When the reactor receives the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">Get</span></code><span class="koboSpan" id="kobo.143.1"> event, it must look up the value associated with the key, and send the value along the channel.</span></p><p><span class="koboSpan" id="kobo.144.1">With the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">Op[K, V]</span></code><span class="koboSpan" id="kobo.146.1"> data type, we can define </span><code class="literal"><span class="koboSpan" id="kobo.147.1">MapReactor</span></code><span class="koboSpan" id="kobo.148.1">, shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.149.1">class MapReactor[K, V] extends Reactor[Op[K, V]] { 
  val map = mutable.Map[K, V]() 
  main.events onEvent { 
    case Put(k, v) =&gt; map(k) = v 
    case Get(k, ch) =&gt; ch ! </span><span class="koboSpan" id="kobo.149.2">map(k) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.150.1">Let's start </span><code class="literal"><span class="koboSpan" id="kobo.151.1">MapReactor</span></code><span class="koboSpan" id="kobo.152.1"> and test it. </span><span class="koboSpan" id="kobo.152.2">We will use the </span><code class="literal"><span class="koboSpan" id="kobo.153.1">MapReactor</span></code><span class="koboSpan" id="kobo.154.1"> to store some DNS aliases. </span><span class="koboSpan" id="kobo.154.2">We will map each alias </span><code class="literal"><span class="koboSpan" id="kobo.155.1">String</span></code><span class="koboSpan" id="kobo.156.1"> key to a URL, where the URLs are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">List[String]</span></code><span class="koboSpan" id="kobo.158.1"> type. </span><span class="koboSpan" id="kobo.158.2">We first initialize as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.159.1">val mapper = system.spawn(Proto[MapReactor[String, List[String]]]) 
</span></pre><p><span class="koboSpan" id="kobo.160.1">We then send a couple of </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Put</span></code><span class="koboSpan" id="kobo.162.1"> messages to store some alias values:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.163.1">mapper ! </span><span class="koboSpan" id="kobo.163.2">Put("dns-main", "dns1" :: "lan" :: Nil) 
mapper ! </span><span class="koboSpan" id="kobo.163.3">Put("dns-backup", "dns2" :: "com" :: Nil) 
</span></pre><p><span class="koboSpan" id="kobo.164.1">Next, we create a client reactor that we control by sending it </span><code class="literal"><span class="koboSpan" id="kobo.165.1">String</span></code><span class="koboSpan" id="kobo.166.1"> events. </span><span class="koboSpan" id="kobo.166.2">This means that the reactor's type will be </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Reactor[String]</span></code><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">However, the client reactor will also have to contact the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">MapReactor</span></code><span class="koboSpan" id="kobo.170.1"> and ask it for one of the URLs. </span><span class="koboSpan" id="kobo.170.2">Since the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">MapReactor</span></code><span class="koboSpan" id="kobo.172.1"> can only send it back </span><code class="literal"><span class="koboSpan" id="kobo.173.1">List[String]</span></code><span class="koboSpan" id="kobo.174.1"> events that do not correspond to the client's default channel type, the client's default channel is not be able to receive the reply. </span><span class="koboSpan" id="kobo.174.2">Therefore, the client will have to provide the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">MapReactor</span></code><span class="koboSpan" id="kobo.176.1"> with a different channel. </span><span class="koboSpan" id="kobo.176.2">The following expression is used to create a new channel:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.177.1">val c: Connector[EventType] = system.channels.open[EventType] 
</span></pre><p><span class="koboSpan" id="kobo.178.1">The expression </span><code class="literal"><span class="koboSpan" id="kobo.179.1">system.channels</span></code><span class="koboSpan" id="kobo.180.1"> returns a channel builder object, which provides methods such as </span><code class="literal"><span class="koboSpan" id="kobo.181.1">named</span></code><span class="koboSpan" id="kobo.182.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.183.1">daemon</span></code><span class="koboSpan" id="kobo.184.1">, used to customize the channel (see the online API docs for more details). </span><span class="koboSpan" id="kobo.184.2">In this example, we will create </span><span class="strong"><strong><span class="koboSpan" id="kobo.185.1">daemon channel</span></strong></span><span class="koboSpan" id="kobo.186.1">, to indicate that the channel does not need to be closed (more on that a bit later). </span><span class="koboSpan" id="kobo.186.2">To create a new channel, we call the </span><code class="literal"><span class="koboSpan" id="kobo.187.1">open</span></code><span class="koboSpan" id="kobo.188.1"> method on the channel builder with the appropriate type parameter.</span></p><p><span class="koboSpan" id="kobo.189.1">The resulting </span><code class="literal"><span class="koboSpan" id="kobo.190.1">Connector</span></code><span class="koboSpan" id="kobo.191.1"> object contains two members: the </span><code class="literal"><span class="koboSpan" id="kobo.192.1">channel</span></code><span class="koboSpan" id="kobo.193.1"> field, which is the newly created channel, and the </span><code class="literal"><span class="koboSpan" id="kobo.194.1">events</span></code><span class="koboSpan" id="kobo.195.1"> field, which is the event stream corresponding to that channel. </span><span class="koboSpan" id="kobo.195.2">The event stream propagates all events that were sent and delivered on the channel, and can only be used by the reactor that created it. </span><span class="koboSpan" id="kobo.195.3">The channel, on the other hand, can be shared with other reactors.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip108"/><span class="koboSpan" id="kobo.196.1">Tip</span></h3><p><span class="koboSpan" id="kobo.197.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.198.1">open</span></code><span class="koboSpan" id="kobo.199.1"> operation on the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">system.channels</span></code><span class="koboSpan" id="kobo.201.1"> object to create new connectors. </span><span class="koboSpan" id="kobo.201.2">Each connector holds a pair of a channel and its event stream.</span></p></div></div><p><span class="koboSpan" id="kobo.202.1">Let's define a client reactor that waits for a </span><code class="literal"><span class="koboSpan" id="kobo.203.1">"start"</span></code><span class="koboSpan" id="kobo.204.1"> message, and then checks a DNS entry. </span><span class="koboSpan" id="kobo.204.2">This reactor will use the </span><code class="literal"><span class="koboSpan" id="kobo.205.1">onMatch</span></code><span class="koboSpan" id="kobo.206.1"> handler instead of </span><code class="literal"><span class="koboSpan" id="kobo.207.1">onEvent</span></code><span class="koboSpan" id="kobo.208.1">, to listen only to certain </span><code class="literal"><span class="koboSpan" id="kobo.209.1">String</span></code><span class="koboSpan" id="kobo.210.1"> events and ignore others:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.211.1">val ch = system.spawn(Reactor[String] { self =&gt; 
  self.main.events onMatch { 
    case "start" =&gt; 
      val reply = self.system.channels.daemon.open[List[String]] 
      mapper ! </span><span class="koboSpan" id="kobo.211.2">Get("dns-main", reply.channel) 
      reply.events onEvent { url =&gt; 
        println(url) 
      } 
    case "end" =&gt; 
      self.main.seal() 
  } 
}) 
</span></pre><p><span class="koboSpan" id="kobo.212.1">In the preceding code snippet, when the reactor receives the </span><code class="literal"><span class="koboSpan" id="kobo.213.1">"start"</span></code><span class="koboSpan" id="kobo.214.1"> event from the main program, it opens a new </span><code class="literal"><span class="koboSpan" id="kobo.215.1">reply</span></code><span class="koboSpan" id="kobo.216.1"> channel that accepts </span><code class="literal"><span class="koboSpan" id="kobo.217.1">List[String]</span></code><span class="koboSpan" id="kobo.218.1"> events. </span><span class="koboSpan" id="kobo.218.2">It then sends a </span><code class="literal"><span class="koboSpan" id="kobo.219.1">Get</span></code><span class="koboSpan" id="kobo.220.1"> event to the </span><code class="literal"><span class="koboSpan" id="kobo.221.1">MapReactor</span></code><span class="koboSpan" id="kobo.222.1"> with the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">"dns-main"</span></code><span class="koboSpan" id="kobo.224.1"> key and the </span><code class="literal"><span class="koboSpan" id="kobo.225.1">reply</span></code><span class="koboSpan" id="kobo.226.1"> channel. </span><span class="koboSpan" id="kobo.226.2">Finally, the reactor listens to events sent back along the </span><code class="literal"><span class="koboSpan" id="kobo.227.1">reply</span></code><span class="koboSpan" id="kobo.228.1"> channel, and prints the URL to the standard output. </span><span class="koboSpan" id="kobo.228.2">In the </span><code class="literal"><span class="koboSpan" id="kobo.229.1">"end"</span></code><span class="koboSpan" id="kobo.230.1"> case of the main pattern match, the reactor calls the </span><code class="literal"><span class="koboSpan" id="kobo.231.1">seal</span></code><span class="koboSpan" id="kobo.232.1"> method on the main channel to indicate that it will not receive any further events on that channel. </span><span class="koboSpan" id="kobo.232.2">Once all non-daemon channels become sealed, the reactor terminates.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip109"/><span class="koboSpan" id="kobo.233.1">Tip</span></h3><p><span class="koboSpan" id="kobo.234.1">A reactor terminates either when all its non-daemon channels are sealed, or when its constructor or some event handler throws an exception.</span></p></div></div><p><span class="koboSpan" id="kobo.235.1">Let's start the client reactor and see what happens:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.236.1">ch ! </span><span class="koboSpan" id="kobo.236.2">"start" 
</span></pre><p><span class="koboSpan" id="kobo.237.1">At this point, we should witness the URL on the standard output. </span><span class="koboSpan" id="kobo.237.2">Finally, we can send the </span><code class="literal"><span class="koboSpan" id="kobo.238.1">"end"</span></code><span class="koboSpan" id="kobo.239.1"> message to the client reactor to stop it.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.240.1">ch ! </span><span class="koboSpan" id="kobo.240.2">"end" 
</span></pre><p><span class="koboSpan" id="kobo.241.1">In the next section, we will see how to customize reactors with custom scheduling policies.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Schedulers"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec69"/><span class="koboSpan" id="kobo.1.1">Schedulers</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Each reactor template can be used to start multiple reactor instances, and each reactor instance can be started with a different reactor scheduler. </span><span class="koboSpan" id="kobo.2.2">Different schedulers have different characteristics in terms of execution priority, frequency, latency, and throughput. </span><span class="koboSpan" id="kobo.2.3">In this section, we take a look at how to use a non-default scheduler, and how to define custom schedulers when necessary.</span></p><p><span class="koboSpan" id="kobo.3.1">We start by defining a reactor that logs incoming events, reports every time it gets scheduled, and ends after being scheduled three times. </span><span class="koboSpan" id="kobo.3.2">We will use the </span><code class="literal"><span class="koboSpan" id="kobo.4.1">sysEvents</span></code><span class="koboSpan" id="kobo.5.1"> stream of the reactor, which will be explained in the next section. </span><span class="koboSpan" id="kobo.5.2">For now, all you need to know is that the system event stream produces events when the reactor gets some execution time (that is, gets scheduled), and pauses its execution (that is, gets pre-empted).</span></p><p><span class="koboSpan" id="kobo.6.1">The </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Logger</span></code><span class="koboSpan" id="kobo.8.1"> reactor is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">class Logger extends Reactor[String] { 
  var count = 3 
  sysEvents onMatch { 
    case ReactorScheduled =&gt; 
      println("scheduled") 
    case ReactorPreempted =&gt; 
      count -= 1 
      if (count == 0) { 
        main.seal() 
        println("terminating") 
      } 
  } 
  main.events.onEvent(println) 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Before starting an instance of the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Logger</span></code><span class="koboSpan" id="kobo.12.1"> reactor, we need to create a reactor system, as we learned in the earlier sections:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">val system = new ReactorSystem("test-system") 
</span></pre><p><span class="koboSpan" id="kobo.14.1">Every reactor system is bundled with a default scheduler and some additional predefined schedulers. </span><span class="koboSpan" id="kobo.14.2">When a reactor is started, it uses the default scheduler, unless specified otherwise. </span><span class="koboSpan" id="kobo.14.3">In the following, we override the default scheduler with the one using Scala's global execution context, that is, Scala's own default thread pool:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">val proto = Proto[Logger].withScheduler( 
  JvmScheduler.Key.globalExecutionContext) 
val ch = system.spawn(proto) 
</span></pre><p><span class="koboSpan" id="kobo.16.1">Running the snippet above should start the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Logger</span></code><span class="koboSpan" id="kobo.18.1"> reactor and print the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">"scheduled"</span></code><span class="koboSpan" id="kobo.20.1"> string once, because starting a reactor schedules it even before any events arrive. </span><span class="koboSpan" id="kobo.20.2">If we now send an event to the main channel, we will see the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">"scheduled"</span></code><span class="koboSpan" id="kobo.22.1"> string printed again, followed by the event itself. </span><span class="koboSpan" id="kobo.22.2">We do this as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">ch ! </span><span class="koboSpan" id="kobo.23.2">"event 1" 
</span></pre><p><span class="koboSpan" id="kobo.24.1">Sending the event again decrements the reactor's counter. </span><span class="koboSpan" id="kobo.24.2">The main channel gets sealed, leaving the reactor in a state without non-daemon channels, and the reactor terminates:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">ch ! </span><span class="koboSpan" id="kobo.25.2">"event 2" 
</span></pre><p><span class="koboSpan" id="kobo.26.1">Reactor systems also allow registering custom scheduler instances. </span><span class="koboSpan" id="kobo.26.2">In the following, we create and register a custom </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Timer</span></code><span class="koboSpan" id="kobo.28.1"> scheduler, which schedules the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Logger</span></code><span class="koboSpan" id="kobo.30.1"> reactor for execution once every 1,000 milliseconds:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">system.bundle.registerScheduler("customTimer", 
  new JvmScheduler.Timer(1000)) 
val periodic = system.spawn( 
  Proto[Logger].withScheduler("customTimer")) 
</span></pre><p><span class="koboSpan" id="kobo.32.1">By running the code above, we can see that the reactor gets scheduled even if no events were sent to it. </span><span class="koboSpan" id="kobo.32.2">The </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Timer</span></code><span class="koboSpan" id="kobo.34.1"> scheduler ensures that the reactor gets scheduled exactly once every N seconds, and then processes some of its pending events.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Reactor lifecycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec70"/><span class="koboSpan" id="kobo.1.1">Reactor lifecycle</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Every reactor goes through a certain set of stages during its lifetime, which are jointly called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">reactor lifecycle</span></strong></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">When the reactor enters a specific stage, it emits a lifecycle event. </span><span class="koboSpan" id="kobo.4.3">These lifecycle events are dispatched on a special daemon event stream called </span><code class="literal"><span class="koboSpan" id="kobo.5.1">sysEvents</span></code><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">Every reactor is created with this special event stream.</span></p><p><span class="koboSpan" id="kobo.7.1">The reactor lifecycle can be summarized as follows:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">After calling the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">spawn</span></code><span class="koboSpan" id="kobo.10.1"> method, the reactor is scheduled for execution. </span><span class="koboSpan" id="kobo.10.2">Its constructor is started asynchronously, and immediately after that, a </span><code class="literal"><span class="koboSpan" id="kobo.11.1">ReactorStarted</span></code><span class="koboSpan" id="kobo.12.1"> event is dispatched.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.13.1">Then, whenever the reactor gets execution time, the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">ReactorScheduled</span></code><span class="koboSpan" id="kobo.15.1"> event gets dispatched. </span><span class="koboSpan" id="kobo.15.2">After that, events get dispatched on normal event streams.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.16.1">When the scheduling system decides to pre-empt the reactor, the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">ReactorPreempted</span></code><span class="koboSpan" id="kobo.18.1"> event is dispatched. </span><span class="koboSpan" id="kobo.18.2">This scheduling cycle can be repeated any number of times.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.19.1">Eventually, the reactor terminates, either by normal execution or exceptionally. </span><span class="koboSpan" id="kobo.19.2">If a user code exception terminates execution, a </span><code class="literal"><span class="koboSpan" id="kobo.20.1">ReactorDied</span></code><span class="koboSpan" id="kobo.21.1"> event is dispatched.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.22.1">In either normal or exceptional execution, a </span><code class="literal"><span class="koboSpan" id="kobo.23.1">ReactorTerminated</span></code><span class="koboSpan" id="kobo.24.1"> event gets emitted.</span></li></ul></div><p><span class="koboSpan" id="kobo.25.1">This reactor lifecycle is shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.26.1"><img src="graphics/image_10_002.jpg" alt="Reactor lifecycle"/></span></div><p><span class="koboSpan" id="kobo.27.1">To test this, we define the following reactor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">class LifecycleReactor extends Reactor[String] { 
  var first = true 
  sysEvents onMatch { 
    case ReactorStarted =&gt; 
      println("started") 
    case ReactorScheduled =&gt; 
      println("scheduled") 
    case ReactorPreempted =&gt; 
      println("preempted") 
      if (first) first = false 
      else throw new Exception 
    case ReactorDied(_) =&gt; 
      println("died") 
    case ReactorTerminated =&gt; 
      println("terminated") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">Upon creating the lifecycle reactor, the reactor gets the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">ReactorStarted</span></code><span class="koboSpan" id="kobo.31.1"> event, and then the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">ReactorStarted</span></code><span class="koboSpan" id="kobo.33.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.34.1">ReactorScheduled</span></code><span class="koboSpan" id="kobo.35.1"> events. </span><span class="koboSpan" id="kobo.35.2">The reactor then gets suspended, and remains that way until the scheduler gives it more execution time.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.36.1">val ch = system.spawn(Proto[LifecycleReactor]) 
</span></pre><p><span class="koboSpan" id="kobo.37.1">The scheduler executes the reactor again when it detects that there are pending messages for that reactor. </span><span class="koboSpan" id="kobo.37.2">If we send an event to the reactor now, we will see the same cycle of </span><code class="literal"><span class="koboSpan" id="kobo.38.1">ReactorScheduled</span></code><span class="koboSpan" id="kobo.39.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.40.1">ReactorPreempted</span></code><span class="koboSpan" id="kobo.41.1"> events from the standard output. </span><span class="koboSpan" id="kobo.41.2">However, the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">ReactorPreempted</span></code><span class="koboSpan" id="kobo.43.1"> handler this time throws an exception. </span><span class="koboSpan" id="kobo.43.2">The exception gets caught, and a </span><code class="literal"><span class="koboSpan" id="kobo.44.1">ReactorDied</span></code><span class="koboSpan" id="kobo.45.1"> event is emitted, followed by the mandatory </span><code class="literal"><span class="koboSpan" id="kobo.46.1">ReactorTerminated</span></code><span class="koboSpan" id="kobo.47.1"> event.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">ch ! </span><span class="koboSpan" id="kobo.48.2">"event" 
</span></pre><p><span class="koboSpan" id="kobo.49.1">At this point, the reactor is fully removed from the reactor system.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Reactor system services"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/><span class="koboSpan" id="kobo.1.1">Reactor system services</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the earlier sections, we learned that reactors delimit concurrent executions, and that event streams allow routing events within each reactor. </span><span class="koboSpan" id="kobo.2.2">This is already a powerful set of abstractions, and we can use reactors and event streams to write all kinds of distributed programs. </span><span class="koboSpan" id="kobo.2.3">However, such a model is restricted to reactor computations only. </span><span class="koboSpan" id="kobo.2.4">We cannot, for example, start blocking I/O operations, read from a temperature sensor implemented in hardware, wait until a GPU computation completes, or react to temporal events. </span><span class="koboSpan" id="kobo.2.5">In some cases, we need to interact with the native capabilities of the OS, or tap into a rich ecosystem of existing libraries. </span><span class="koboSpan" id="kobo.2.6">For this purpose, every reactor system has a set of </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">services</span></strong></span><span class="koboSpan" id="kobo.4.1">: protocols that relate event streams to the outside world.</span></p><p><span class="koboSpan" id="kobo.5.1">In this section, we will take a closer look at various services that are available by default, and also show how to implement custom services and plug them into reactor systems.</span></p><div class="section" title="The logging service"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec93"/><span class="koboSpan" id="kobo.6.1">The logging service</span></h2></div></div></div><p><span class="koboSpan" id="kobo.7.1">We start with the simplest possible service called </span><code class="literal"><span class="koboSpan" id="kobo.8.1">Log</span></code><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">This service is used to print logging messages to the standard output. </span><span class="koboSpan" id="kobo.9.3">In the following, we create an anonymous reactor that uses the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Log</span></code><span class="koboSpan" id="kobo.11.1"> service. </span><span class="koboSpan" id="kobo.11.2">We start by importing the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Log</span></code><span class="koboSpan" id="kobo.13.1"> service:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.14.1">import io.reactors.services.Log 
</span></pre><p><span class="koboSpan" id="kobo.15.1">Next, we create a reactor system, and start a reactor instance. </span><span class="koboSpan" id="kobo.15.2">The reactor invokes the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">service</span></code><span class="koboSpan" id="kobo.17.1"> method on the reactor system, which returns the service singleton with the specified type. </span><span class="koboSpan" id="kobo.17.2">The reactor then calls the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">apply</span></code><span class="koboSpan" id="kobo.19.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">log</span></code><span class="koboSpan" id="kobo.21.1"> object to print a message, and seals itself.</span></p><p><span class="koboSpan" id="kobo.22.1">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">system.spawn(Reactor[String] { self =&gt; 
  val log = system.service[Log] 
  log("Test reactor started!") 
  self.main.seal() 
}) 
</span></pre><p><span class="koboSpan" id="kobo.24.1">Running the above snippet prints the timestamped message to the standard output. </span><span class="koboSpan" id="kobo.24.2">This example is very simple, but we use it to describe some important properties of services:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.25.1">Reactor system's method </span><code class="literal"><span class="koboSpan" id="kobo.26.1">service[S]</span></code><span class="koboSpan" id="kobo.27.1"> returns a service of type </span><code class="literal"><span class="koboSpan" id="kobo.28.1">S</span></code><span class="koboSpan" id="kobo.29.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.30.1">The service obtained this way is a lazily initialized singleton instance. </span><span class="koboSpan" id="kobo.30.2">There exists at most one instance of the service per reactor system, and it is created only after being requested by some reactor.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.31.1">Some standard services are eagerly initialized when the reactor system gets created. </span><span class="koboSpan" id="kobo.31.2">Such services are usually available as a standalone method on the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">ReactorSystem</span></code><span class="koboSpan" id="kobo.33.1"> class. </span><span class="koboSpan" id="kobo.33.2">For example, </span><code class="literal"><span class="koboSpan" id="kobo.34.1">system.log</span></code><span class="koboSpan" id="kobo.35.1"> is an alternative way to obtain the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">Log</span></code><span class="koboSpan" id="kobo.37.1"> service.</span></li></ul></div></div><div class="section" title="The clock service"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec94"/><span class="koboSpan" id="kobo.38.1">The clock service</span></h2></div></div></div><p><span class="koboSpan" id="kobo.39.1">Having seen a trivial service example, let's take a look at a more involved service that connects reactors with the outside world of events, namely, the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">Clock</span></code><span class="koboSpan" id="kobo.41.1"> service. </span><span class="koboSpan" id="kobo.41.2">The </span><code class="literal"><span class="koboSpan" id="kobo.42.1">Clock</span></code><span class="koboSpan" id="kobo.43.1"> service is capable of producing time-driven events, for example, timeouts, countdowns, or periodic counting. </span><span class="koboSpan" id="kobo.43.2">This service is standard, so it is available by calling either </span><code class="literal"><span class="koboSpan" id="kobo.44.1">system.clock</span></code><span class="koboSpan" id="kobo.45.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.46.1">system.service[Clock]</span></code><span class="koboSpan" id="kobo.47.1">.</span></p><p><span class="koboSpan" id="kobo.48.1">In the following, we create an anonymous reactor that uses the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">Clock</span></code><span class="koboSpan" id="kobo.50.1"> service to create a timeout event after one second. </span><span class="koboSpan" id="kobo.50.2">The </span><code class="literal"><span class="koboSpan" id="kobo.51.1">timeout</span></code><span class="koboSpan" id="kobo.52.1"> method of the clock service returns an event stream of the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">Unit</span></code><span class="koboSpan" id="kobo.54.1"> type that always produces at most one event. </span><span class="koboSpan" id="kobo.54.2">We install a callback to the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">timeout</span></code><span class="koboSpan" id="kobo.56.1"> event stream, which seals the main channel of this reactor. </span><span class="koboSpan" id="kobo.56.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">import scala.concurrent.duration._ 
system.spawn(Reactor[String] { self =&gt; 
  system.clock.timeout(1.second) on { 
    println("done") 
    self.main.seal() 
  } 
}) 
</span></pre><p><span class="koboSpan" id="kobo.58.1">The </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Clock</span></code><span class="koboSpan" id="kobo.60.1"> service uses a separate timer thread under-the-hood, which sends events to the reactor when the timer thread decides it is time to do so. </span><span class="koboSpan" id="kobo.60.2">The events are sent on a special channel created by the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">timeout</span></code><span class="koboSpan" id="kobo.62.1"> method, so they are seen only on the corresponding event stream combinator. </span><span class="koboSpan" id="kobo.62.2">This is summarized in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.63.1"><img src="graphics/image_10_003.jpg" alt="The clock service"/></span></div><p><span class="koboSpan" id="kobo.64.1">When the main channel gets sealed, the reactor terminates. </span><span class="koboSpan" id="kobo.64.2">This is because the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">timeout</span></code><span class="koboSpan" id="kobo.66.1"> event stream creates a daemon channel under-the-hood, which does not prevent our anonymous reactor from terminating after non-daemon channels are gone.</span></p><p><span class="koboSpan" id="kobo.67.1">The </span><code class="literal"><span class="koboSpan" id="kobo.68.1">Clock</span></code><span class="koboSpan" id="kobo.69.1"> service shows a general pattern: when a native entity or an external event needs to communicate with a reactor, it creates a new channel, and then asynchronously sends events to it.</span></p></div><div class="section" title="The channels service"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec95"/><span class="koboSpan" id="kobo.70.1">The channels service</span></h2></div></div></div><p><span class="koboSpan" id="kobo.71.1">Some services provide event streams that work with reactor system internals. </span><span class="koboSpan" id="kobo.71.2">The </span><code class="literal"><span class="koboSpan" id="kobo.72.1">Channels</span></code><span class="koboSpan" id="kobo.73.1"> service is one such example--it provides an event-driven view over all channels that exist in the current reactor system. </span><span class="koboSpan" id="kobo.73.2">This allows polling the channels that are currently available, or waiting until a channel with a specific name becomes available. </span><span class="koboSpan" id="kobo.73.3">Awaiting a channel is particularly useful, as it allows easier handling of asynchrony between reactors, which is inherent to distributed systems.</span></p><p><span class="koboSpan" id="kobo.74.1">As a side-note, we actually saw and used the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">Channels</span></code><span class="koboSpan" id="kobo.76.1"> service earlier, when we opened a second channel in a reactor. </span><span class="koboSpan" id="kobo.76.2">The expression </span><code class="literal"><span class="koboSpan" id="kobo.77.1">system.channels.open</span></code><span class="koboSpan" id="kobo.78.1"> actually calls the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">open</span></code><span class="koboSpan" id="kobo.80.1"> method on the standard channel service. </span><span class="koboSpan" id="kobo.80.2">The channels service thus not only allows querying channels that exist in the reactor system, but also creating new channels within existing reactors.</span></p><p><span class="koboSpan" id="kobo.81.1">To show basic usage of the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">Channels</span></code><span class="koboSpan" id="kobo.83.1"> service, we construct two reactors. </span><span class="koboSpan" id="kobo.83.2">The first reactor will create a channel named </span><code class="literal"><span class="koboSpan" id="kobo.84.1">"hidden"</span></code><span class="koboSpan" id="kobo.85.1"> after some delay, and the second reactor will wait for that channel. </span><span class="koboSpan" id="kobo.85.2">When the channel appears, the second reactor will send an event to that channel. </span><span class="koboSpan" id="kobo.85.3">The first reactor prints the string </span><code class="literal"><span class="koboSpan" id="kobo.86.1">"event received"</span></code><span class="koboSpan" id="kobo.87.1"> after it receives the message, sealing its main channel. </span><span class="koboSpan" id="kobo.87.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.88.1">val first = Reactor[String] { self =&gt; 
  system.clock.timeout(1.second) on { 
    val c = system.channels.daemon.named("hidden").open[Int] 
    c.events on { 
      println("event received") 
      self.main.seal() 
    } 
  } 
} 
system.spawn(first.withName("first")) 
system.spawn(Reactor[String] { self =&gt; 
  system.channels.await[Int]("first", "hidden") onEvent { ch =&gt; 
    ch ! </span><span class="koboSpan" id="kobo.88.2">7 
    self.main.seal() 
  } 
}) 
</span></pre><p><span class="koboSpan" id="kobo.89.1">In the preceding program, we use the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">Clock</span></code><span class="koboSpan" id="kobo.91.1"> service seen earlier to introduce a delay in the first reactor. </span><span class="koboSpan" id="kobo.91.2">In the second reactor, we use the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">Channels</span></code><span class="koboSpan" id="kobo.93.1"> service to wait for the channel named </span><code class="literal"><span class="koboSpan" id="kobo.94.1">"hidden"</span></code><span class="koboSpan" id="kobo.95.1"> of the reactor named </span><code class="literal"><span class="koboSpan" id="kobo.96.1">"first"</span></code><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">Both reactors start at approximately the same time.</span></p><p><span class="koboSpan" id="kobo.98.1">After one second, the first reactor uses the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Channels</span></code><span class="koboSpan" id="kobo.100.1"> service to open a new daemon channel named </span><code class="literal"><span class="koboSpan" id="kobo.101.1">"hidden"</span></code><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">The first reactor then installs a callback: when the first event arrives on the hidden channel, it prints a message to the standard output, and the main channel is sealed, to ensure that the reactor terminates. </span><span class="koboSpan" id="kobo.102.3">The second reactor gets an event from the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">Channels</span></code><span class="koboSpan" id="kobo.104.1"> service, since a channel with the desired name now exists. </span><span class="koboSpan" id="kobo.104.2">This reactor sends a value </span><code class="literal"><span class="koboSpan" id="kobo.105.1">7</span></code><span class="koboSpan" id="kobo.106.1"> to the hidden channel, and terminates.</span></p><p><span class="koboSpan" id="kobo.107.1">To conclude, waiting for channels to appear is important when establishing temporal order in an asynchronous system. </span><span class="koboSpan" id="kobo.107.2">In general, the creation of the hidden channel in the first reactor could have been delayed by an arbitrary amount by the reactor system, and the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">Channels</span></code><span class="koboSpan" id="kobo.109.1"> service allows the computation to proceed only after specific channels in other reactors get created.</span></p></div><div class="section" title="Custom services"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec96"/><span class="koboSpan" id="kobo.110.1">Custom services</span></h2></div></div></div><p><span class="koboSpan" id="kobo.111.1">Having seen a few existing services, we now show how to create a custom service. </span><span class="koboSpan" id="kobo.111.2">To do this, we must implement the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">Protocol.Service</span></code><span class="koboSpan" id="kobo.113.1"> trait, which has a single member method called </span><code class="literal"><span class="koboSpan" id="kobo.114.1">shutdown</span></code><span class="koboSpan" id="kobo.115.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.116.1">class CustomService(val system: ReactorSystem) 
extends Protocol.Service { 
  def shutdown(): Unit = ??? 
</span><span class="koboSpan" id="kobo.116.2">} 
</span></pre><p><span class="koboSpan" id="kobo.117.1">The </span><code class="literal"><span class="koboSpan" id="kobo.118.1">shutdown</span></code><span class="koboSpan" id="kobo.119.1"> method is called when the corresponding reactor system gets shut down, and is used to free any resources that the service potentially has. </span><span class="koboSpan" id="kobo.119.2">Any custom service must additionally have a single parameter constructor that takes a </span><code class="literal"><span class="koboSpan" id="kobo.120.1">ReactorSystem</span></code><span class="koboSpan" id="kobo.121.1"> object, which allows the service to interact with and use the reactor system during its existence.</span></p><p><span class="koboSpan" id="kobo.122.1">As noted earlier, a service is a mechanism that gives access to events that a reactor normally cannot obtain from other reactors. </span><span class="koboSpan" id="kobo.122.2">Let's implement a service that notifies a reactor when the enclosing reactor system gets shut down. </span><span class="koboSpan" id="kobo.122.3">For this, we will need to keep a map of the channels that subscribed to the shutdown event and a lock to protect access to that state. </span><span class="koboSpan" id="kobo.122.4">Finally, we will expose a method </span><code class="literal"><span class="koboSpan" id="kobo.123.1">state</span></code><span class="koboSpan" id="kobo.124.1">, which creates an event stream that emits an event when the reactor system is shut down.</span></p><p><span class="koboSpan" id="kobo.125.1">The </span><code class="literal"><span class="koboSpan" id="kobo.126.1">state</span></code><span class="koboSpan" id="kobo.127.1"> method will return a special kind of event stream called a </span><code class="literal"><span class="koboSpan" id="kobo.128.1">Signal</span></code><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">The </span><code class="literal"><span class="koboSpan" id="kobo.130.1">Signal</span></code><span class="koboSpan" id="kobo.131.1"> type extends the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Events</span></code><span class="koboSpan" id="kobo.133.1"> type, and a signal object emits events whenever its value changes. </span><span class="koboSpan" id="kobo.133.2">Additionally, a </span><code class="literal"><span class="koboSpan" id="kobo.134.1">Signal</span></code><span class="koboSpan" id="kobo.135.1"> caches the value of the previously emitted event, which can be accessed with the signal's </span><code class="literal"><span class="koboSpan" id="kobo.136.1">apply</span></code><span class="koboSpan" id="kobo.137.1"> method. </span><span class="koboSpan" id="kobo.137.2">Any event stream can be converted into a signal by calling the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">toSignal</span></code><span class="koboSpan" id="kobo.139.1"> method.</span></p><p><span class="koboSpan" id="kobo.140.1">The </span><code class="literal"><span class="koboSpan" id="kobo.141.1">state</span></code><span class="koboSpan" id="kobo.142.1"> method, called by a specific reactor, must create a new daemon channel called </span><code class="literal"><span class="koboSpan" id="kobo.143.1">shut</span></code><span class="koboSpan" id="kobo.144.1">. </span><span class="koboSpan" id="kobo.144.2">This channel is added to the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">subscribers</span></code><span class="koboSpan" id="kobo.146.1"> set of the shutdown service. </span><span class="koboSpan" id="kobo.146.2">The event stream associated with this channel is converted into a signal with the initial value </span><code class="literal"><span class="koboSpan" id="kobo.147.1">false</span></code><span class="koboSpan" id="kobo.148.1">, and returned to the caller.</span></p><p><span class="koboSpan" id="kobo.149.1">The implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.150.1">Shutdown</span></code><span class="koboSpan" id="kobo.151.1"> service is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.152.1">class Shutdown(val system: ReactorSystem) 
extends Protocol.Service { 
  private val subscribers = mutable.Set[Channel[Boolean]]() 
  private val lock = new AnyRef 
  def state: Signal[Boolean] = { 
    val shut = system.channels.daemon.open[Boolean] 
    lock.synchronized { 
      subscribers += shut.channel 
    } 
    shut.events.toSignal(false) 
  } 
  def shutdown() { 
    lock.synchronized { 
      for (ch &lt;- subscribers) ch ! </span><span class="koboSpan" id="kobo.152.2">true 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.153.1">We can now use the </span><code class="literal"><span class="koboSpan" id="kobo.154.1">Shutdown</span></code><span class="koboSpan" id="kobo.155.1"> service in user programs. </span><span class="koboSpan" id="kobo.155.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.156.1">val system = ReactorSystem.default("test-shutdown-system") 
system.spawn(Reactor[Unit] { self =&gt; 
  system.service[Shutdown].state on { 
    println("Releasing important resource.") 
    self.main.seal() 
  } 
}) 
</span></pre><p><span class="koboSpan" id="kobo.157.1">Later, when we shut down the system, we expect that the code in the callback runs and completes the promise:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.158.1">system.shutdown() 
</span></pre><p><span class="koboSpan" id="kobo.159.1">Note that, when implementing a custom service, we are no longer in the same ballpark as when writing normal reactor code. </span><span class="koboSpan" id="kobo.159.2">A service may be invoked by multiple reactors concurrently, and this is why we had to synchronize access to the subscribers map in the </span><code class="literal"><span class="koboSpan" id="kobo.160.1">Shutdown</span></code><span class="koboSpan" id="kobo.161.1"> implementation. </span><span class="koboSpan" id="kobo.161.2">In general, when implementing a custom service, we have to take care to:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.162.1">Never block or acquire a lock in the service constructor</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.163.1">Ensure that access to shared state of the service is properly synchronized</span></li></ul></div><p><span class="koboSpan" id="kobo.164.1">In conclusion, you should use custom services when you have a native event-driven API that must deliver events to reactors in your program, or wish to expose access to internals of the reactor system, the OS or the underlying hardware. </span><span class="koboSpan" id="kobo.164.2">Often the implementation of a reactor system service will employ some lower-level concurrency primitives, but will expose a high-level API that relies on event streams and channels.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec72"/><span class="koboSpan" id="kobo.1.1">Protocols</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Reactors, event streams, and channels form the cornerstone of the reactor programming model. </span><span class="koboSpan" id="kobo.2.2">These basic primitives allow composing powerful communication abstractions. </span><span class="koboSpan" id="kobo.2.3">In this section, we go through some of the basic communication protocols that the Reactors framework implements in terms of its basic primitives. </span><span class="koboSpan" id="kobo.2.4">What these protocols have in common is that they are not artificial extensions of the basic model. </span><span class="koboSpan" id="kobo.2.5">Rather, they are composed from basic abstractions and other simpler protocols.</span></p><p><span class="koboSpan" id="kobo.3.1">We start with one of the simplest protocols, namely the </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1">server-client</span></strong></span><span class="koboSpan" id="kobo.5.1"> protocol. </span><span class="koboSpan" id="kobo.5.2">First, we show how to implement a simple server-client protocol ourselves. </span><span class="koboSpan" id="kobo.5.3">After that, we show how to use the standard server-client implementation provided by the Reactors framework. </span><span class="koboSpan" id="kobo.5.4">In the later sections on protocols, we will not dive into the implementation, but instead immediately show how to use the protocol predefined in the framework.</span></p><p><span class="koboSpan" id="kobo.6.1">This approach will serve several purposes. </span><span class="koboSpan" id="kobo.6.2">First, you should get an idea of how to implement a communication pattern using event streams and channels. </span><span class="koboSpan" id="kobo.6.3">Second, you will see that there is more than one way to implement a protocol and expose it to clients. </span><span class="koboSpan" id="kobo.6.4">Finally, you will see how protocols are structured and exposed in the Reactors framework.</span></p><div class="section" title="Custom server-client protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec97"/><span class="koboSpan" id="kobo.7.1">Custom server-client protocol</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In this subsection, we implement the server-client protocol ourselves. </span><span class="koboSpan" id="kobo.8.2">Before we start, we have to create a default reactor system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">val system = ReactorSystem.default("system") 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Let's now consider the server-client protocol more closely. </span><span class="koboSpan" id="kobo.10.2">This protocol proceeds as follows: first, the client sends a request value to the server. </span><span class="koboSpan" id="kobo.10.3">Then, the server uses the request to compute a response value and send it to the client. </span><span class="koboSpan" id="kobo.10.4">But to do that, the server needs a response channel, which serves as the destination to send the response value to. </span><span class="koboSpan" id="kobo.10.5">This means that the client must not only send the request value to the server, but also send a channel used for the reply. </span><span class="koboSpan" id="kobo.10.6">The request sent by the client is thus a tuple with a value and the reply channel. </span><span class="koboSpan" id="kobo.10.7">The server channel used by the server must accept such tuples. </span><span class="koboSpan" id="kobo.10.8">We capture these relationships with the following two types:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">type Req[T, S] = (T, Channel[S]) 
type Server[T, S] = Channel[Req[T, S]] 
</span></pre><p><span class="koboSpan" id="kobo.12.1">Here, </span><code class="literal"><span class="koboSpan" id="kobo.13.1">T</span></code><span class="koboSpan" id="kobo.14.1"> is the type of the request value, and </span><code class="literal"><span class="koboSpan" id="kobo.15.1">S</span></code><span class="koboSpan" id="kobo.16.1"> is the type of the response value. </span><span class="koboSpan" id="kobo.16.2">The </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Req</span></code><span class="koboSpan" id="kobo.18.1"> type represents the request: a tuple of the request value </span><code class="literal"><span class="koboSpan" id="kobo.19.1">T</span></code><span class="koboSpan" id="kobo.20.1"> and the reply channel for responses of type </span><code class="literal"><span class="koboSpan" id="kobo.21.1">S</span></code><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">The </span><code class="literal"><span class="koboSpan" id="kobo.23.1">Server</span></code><span class="koboSpan" id="kobo.24.1"> type is then just a channel that accepts request objects.</span></p><p><span class="koboSpan" id="kobo.25.1">Next, we ask ourselves--how do we create a </span><code class="literal"><span class="koboSpan" id="kobo.26.1">Server</span></code><span class="koboSpan" id="kobo.27.1"> channel? </span><span class="koboSpan" id="kobo.27.2">There are several requirements that a factory method for the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">Server</span></code><span class="koboSpan" id="kobo.29.1"> channel should satisfy. </span><span class="koboSpan" id="kobo.29.2">First, the server method should be generic in the request and the response type. </span><span class="koboSpan" id="kobo.29.3">Second, it should be generic in how the request type is mapped to the response type. </span><span class="koboSpan" id="kobo.29.4">Third, when a request is sent to the server, the mapped response should be sent back to the server. </span><span class="koboSpan" id="kobo.29.5">Putting these requirements together, we arrive at the following implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">server</span></code><span class="koboSpan" id="kobo.31.1"> method, which instantiates a new server:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">def server[T, S](f: T =&gt; S): Server[T, S] = { 
  val c = system.channels.open[Req[T, S]] 
  c.events onMatch { 
    case (x, reply) =&gt; reply ! </span><span class="koboSpan" id="kobo.32.2">f(x) 
  } 
  c.channel 
} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">The </span><code class="literal"><span class="koboSpan" id="kobo.34.1">server</span></code><span class="koboSpan" id="kobo.35.1"> method starts by creating a connector for </span><code class="literal"><span class="koboSpan" id="kobo.36.1">Req[T, S]</span></code><span class="koboSpan" id="kobo.37.1"> type. </span><span class="koboSpan" id="kobo.37.2">It then adds a callback to the event stream of the newly created connector. </span><span class="koboSpan" id="kobo.37.3">The callback decomposes the request tuple into the request value </span><code class="literal"><span class="koboSpan" id="kobo.38.1">x</span></code><span class="koboSpan" id="kobo.39.1"> of type </span><code class="literal"><span class="koboSpan" id="kobo.40.1">T</span></code><span class="koboSpan" id="kobo.41.1"> and the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">reply</span></code><span class="koboSpan" id="kobo.43.1"> channel, then maps the input value using the specified mapping function </span><code class="literal"><span class="koboSpan" id="kobo.44.1">f</span></code><span class="koboSpan" id="kobo.45.1">, and finally sends the mapped value of type </span><code class="literal"><span class="koboSpan" id="kobo.46.1">S</span></code><span class="koboSpan" id="kobo.47.1"> back along the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">reply</span></code><span class="koboSpan" id="kobo.49.1"> channel. </span><span class="koboSpan" id="kobo.49.2">The </span><code class="literal"><span class="koboSpan" id="kobo.50.1">server</span></code><span class="koboSpan" id="kobo.51.1"> method returns the channel associated with this connector. </span><span class="koboSpan" id="kobo.51.2">We can use this method to start a server that maps request strings to uppercase strings, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.52.1">val proto = Reactor[Unit] { self =&gt; 
  val s = server[String, String](_.toUpperCase) 
} 
system.spawn(proto) 
</span></pre><p><span class="koboSpan" id="kobo.53.1">Next, we will implement the client protocol. </span><span class="koboSpan" id="kobo.53.2">We will define a new method called </span><code class="literal"><span class="koboSpan" id="kobo.54.1">?</span></code><span class="koboSpan" id="kobo.55.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">Channel</span></code><span class="koboSpan" id="kobo.57.1"> type, which sends the request to the server. </span><span class="koboSpan" id="kobo.57.2">This method cannot immediately return the server's response, because the response arrives asynchronously. </span><span class="koboSpan" id="kobo.57.3">Instead, method </span><code class="literal"><span class="koboSpan" id="kobo.58.1">?</span></code><span class="koboSpan" id="kobo.59.1"> must return an event stream with the server's reply. </span><span class="koboSpan" id="kobo.59.2">So, the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">?</span></code><span class="koboSpan" id="kobo.61.1"> method must create a reply channel, send the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">Req</span></code><span class="koboSpan" id="kobo.63.1"> object to the server, and then return the event stream associated with the reply channel. </span><span class="koboSpan" id="kobo.63.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.64.1">implicit class ServerOps[T, S: Arrayable](val s: Server[T, S]) { 
  def ?(x: T): Events[S] = { 
    val reply = system.channels.daemon.open[S] 
    s ! </span><span class="koboSpan" id="kobo.64.2">(x, reply.channel) 
    reply.events 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.65.1">In the code above, we defined an extension method </span><code class="literal"><span class="koboSpan" id="kobo.66.1">?</span></code><span class="koboSpan" id="kobo.67.1"> for objects of the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">Server</span></code><span class="koboSpan" id="kobo.69.1"> type by declaring an implicit class </span><code class="literal"><span class="koboSpan" id="kobo.70.1">ServerOps</span></code><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">The </span><code class="literal"><span class="koboSpan" id="kobo.72.1">Arrayable</span></code><span class="koboSpan" id="kobo.73.1"> context bound on type </span><code class="literal"><span class="koboSpan" id="kobo.74.1">S</span></code><span class="koboSpan" id="kobo.75.1"> is required in the Reactors framework to enable the creation of arrays. </span><span class="koboSpan" id="kobo.75.2">The Reactors framework requires the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">Arrayable</span></code><span class="koboSpan" id="kobo.77.1"> type class whenever we want to open a channel of a generic type, which is in this case the type </span><code class="literal"><span class="koboSpan" id="kobo.78.1">S</span></code><span class="koboSpan" id="kobo.79.1">.</span></p><p><span class="koboSpan" id="kobo.80.1">We now show the interaction between the server and the client by instantiating the two protocols within the same reactor. </span><span class="koboSpan" id="kobo.80.2">The server just returns an uppercase version of the input string, while the client sends the request with the content </span><code class="literal"><span class="koboSpan" id="kobo.81.1">"hello"</span></code><span class="koboSpan" id="kobo.82.1">, and prints the response to the standard output. </span><span class="koboSpan" id="kobo.82.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.83.1">val serverClient = Reactor[Unit] { self =&gt; 
  val s = server[String, String](_.toUpperCase) 
 
  (s ? </span><span class="koboSpan" id="kobo.83.2">"hello") onEvent { upper =&gt; 
    println(upper) 
  } 
} 
system.spawn(serverClient) 
</span></pre><p><span class="koboSpan" id="kobo.84.1">Our implementation works, but it is not very useful to start the server-client protocol inside a single reactor. </span><span class="koboSpan" id="kobo.84.2">Normally, the server and the client are separated by the network, or are at least different reactors running inside the same reactor system.</span></p><p><span class="koboSpan" id="kobo.85.1">It turns out that, with our toy implementation of the server-client protocol, it is not straightforward to instantiate the protocol in two different reactors. </span><span class="koboSpan" id="kobo.85.2">The main reason for this is that once the server channel is instantiated within one reactor, we have no way of </span><span class="emphasis"><em><span class="koboSpan" id="kobo.86.1">seeing</span></em></span><span class="koboSpan" id="kobo.87.1"> it in another reactor. </span><span class="koboSpan" id="kobo.87.2">The server channel is hidden inside the lexical scope of the server reactor. </span><span class="koboSpan" id="kobo.87.3">We will see how to easily overcome this problem with the standard server-client implementation that the Reactors framework provides.</span></p></div><div class="section" title="Standard server-client protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec98"/><span class="koboSpan" id="kobo.88.1">Standard server-client protocol</span></h2></div></div></div><p><span class="koboSpan" id="kobo.89.1">We have just seen an example implementation of the server-client protocol, which relies only on the basic primitives provided by the Reactors framework. </span><span class="koboSpan" id="kobo.89.2">However, the implementation that was presented is very simplistic, and it ignores several important concerns. </span><span class="koboSpan" id="kobo.89.3">For example, how do we stop the server protocol? </span><span class="koboSpan" id="kobo.89.4">Also, we instantiated the server-client protocol in a single reactor, but is it possible to instantiate server-client in two different reactors?</span></p><p><span class="koboSpan" id="kobo.90.1">In this section, we take a closer look at how the server-client protocol is exposed in the Reactors framework, and explain how some of the above concerns are addressed. </span><span class="koboSpan" id="kobo.90.2">Most predefined protocols can be instantiated in several ways:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.91.1">By installing the protocol on the existing connector inside an existing reactor, which has an appropriate type for that protocol. </span><span class="koboSpan" id="kobo.91.2">The main benefit of this is that you can install the protocol on, for example, the main channel of a reactor. </span><span class="koboSpan" id="kobo.91.3">This also makes the protocol accessible to other reactors that are aware of that respective channel.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.92.1">By creating a new connector for the protocol, and then installing the protocol to that connector. </span><span class="koboSpan" id="kobo.92.2">The main benefit of this is that you can fully customize the protocol's connector (for example, name it), but you will need to find some way of sharing the protocol's channel with other reactors, for example, by using it on the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">Channels</span></code><span class="koboSpan" id="kobo.94.1"> service, or by sending the channel to specific reactors.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.95.1">By creating a new </span><code class="literal"><span class="koboSpan" id="kobo.96.1">Proto</span></code><span class="koboSpan" id="kobo.97.1"> object for a reactor that exclusively runs a specific protocol. </span><span class="koboSpan" id="kobo.97.2">The main benefit of this is being able to fully configure the reactor that you wish to start (for example, specify a scheduler, reactor name, or transport).</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.98.1">By immediately spawning a reactor that runs a specific protocol. </span><span class="koboSpan" id="kobo.98.2">This is the most concise option.</span></li></ul></div><p><span class="koboSpan" id="kobo.99.1">These approaches are mostly equivalent, but they represent different trade-offs between convenience and customization. </span><span class="koboSpan" id="kobo.99.2">Let's take a look at the predefined server-client protocol to study these approaches in turn.</span></p><div class="section" title="Using an existing connector"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec0"/><span class="koboSpan" id="kobo.100.1">Using an existing connector</span></h3></div></div></div><p><span class="koboSpan" id="kobo.101.1">When using an existing connector, we need to ensure that the connector's type matches the type needed by the protocol. </span><span class="koboSpan" id="kobo.101.2">In the case of a server, the connector's event type must be </span><code class="literal"><span class="koboSpan" id="kobo.102.1">Server.Req</span></code><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">In the following, we define a server prototype that multiplies the request integer by </span><code class="literal"><span class="koboSpan" id="kobo.104.1">2</span></code><span class="koboSpan" id="kobo.105.1"> to compute a response. </span><span class="koboSpan" id="kobo.105.2">To install the server-client protocol, we call the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">serve</span></code><span class="koboSpan" id="kobo.107.1"> method on the connector:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.108.1">val proto = Reactor[Server.Req[Int, Int]] { self =&gt; 
  self.main.serve(x =&gt; x * 2) 
} 
val server = system.spawn(proto) 
</span></pre><p><span class="koboSpan" id="kobo.109.1">The client can then query the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">server</span></code><span class="koboSpan" id="kobo.111.1"> channel using the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">?</span></code><span class="koboSpan" id="kobo.113.1"> operator. </span><span class="koboSpan" id="kobo.113.2">For convenience, we use the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">spawnLocal</span></code><span class="koboSpan" id="kobo.115.1"> method, which simultaneously defines an anonymous reactor template and uses it to spawn a new client reactor. </span><span class="koboSpan" id="kobo.115.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.116.1">system.spawnLocal[Unit] { self =&gt; 
  (server ? </span><span class="koboSpan" id="kobo.116.2">7) onEvent { response =&gt; 
    println(response) 
  } 
} 
</span></pre></div><div class="section" title="Creating a new connector"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec1"/><span class="koboSpan" id="kobo.117.1">Creating a new connector</span></h3></div></div></div><p><span class="koboSpan" id="kobo.118.1">Let's say that the main channel is already used for something else. </span><span class="koboSpan" id="kobo.118.2">For example, the main channel could be accepting termination requests. </span><span class="koboSpan" id="kobo.118.3">Consequently, the main channel cannot be shared with the server protocol, as protocols usually need exclusive ownership of the respective channel. </span><span class="koboSpan" id="kobo.118.4">In such cases, we want to create a new connector for the protocol.</span></p><p><span class="koboSpan" id="kobo.119.1">This approach is very similar to using an existing connector. </span><span class="koboSpan" id="kobo.119.2">The only difference is that we must first create the connector itself, giving us an opportunity to customize it. </span><span class="koboSpan" id="kobo.119.3">In particular, we will make the server a </span><code class="literal"><span class="koboSpan" id="kobo.120.1">daemon</span></code><span class="koboSpan" id="kobo.121.1"> channel, and we will assign it a specific name </span><code class="literal"><span class="koboSpan" id="kobo.122.1">"server"</span></code><span class="koboSpan" id="kobo.123.1">, so that other reactors can find it. </span><span class="koboSpan" id="kobo.123.2">We will name the reactor itself </span><code class="literal"><span class="koboSpan" id="kobo.124.1">"Multiplier"</span></code><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">To create a server connector, we use the convenience method called </span><code class="literal"><span class="koboSpan" id="kobo.126.1">server</span></code><span class="koboSpan" id="kobo.127.1"> on the channel builder object, to get a new connector of the appropriate type.</span></p><p><span class="koboSpan" id="kobo.128.1">We can then call the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">serve</span></code><span class="koboSpan" id="kobo.130.1"> method on the connector to start the protocol. </span><span class="koboSpan" id="kobo.130.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.131.1">val proto = Reactor[String] { self =&gt; 
  self.main.events onMatch { 
    case "terminate" =&gt; self.main.seal() 
  } 
  self.system.channels.daemon.named("server") 
    .server[Int, Int].serve(_ * 2) 
} 
system.spawn(proto.withName("Multiplier")) 
</span></pre><p><span class="koboSpan" id="kobo.132.1">The client must now query the name service to find the server channel, and from there on it proceeds as before, as shown in the following:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.133.1">system.spawnLocal[Unit] { self =&gt; 
  self.system.channels.await[Server.Req[Int, Int]]( 
    "Multiplier", "server" 
  ) onEvent { server =&gt; 
    (server ? </span><span class="koboSpan" id="kobo.133.2">7) onEvent { response =&gt; 
      println(response) 
    } 
  } 
} 
</span></pre></div><div class="section" title="Creating a protocol-specific reactor prototype"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec2"/><span class="koboSpan" id="kobo.134.1">Creating a protocol-specific reactor prototype</span></h3></div></div></div><p><span class="koboSpan" id="kobo.135.1">When we are sure that the reactor will exist only, or mainly, for the purposes of the server protocol, we can directly create a reactor server. </span><span class="koboSpan" id="kobo.135.2">To do this, we use the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">server</span></code><span class="koboSpan" id="kobo.137.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">Reactor</span></code><span class="koboSpan" id="kobo.139.1"> companion object. </span><span class="koboSpan" id="kobo.139.2">The </span><code class="literal"><span class="koboSpan" id="kobo.140.1">server</span></code><span class="koboSpan" id="kobo.141.1"> method returns the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">Proto</span></code><span class="koboSpan" id="kobo.143.1"> object for the server, which can then be further customized before spawning the reactor. </span><span class="koboSpan" id="kobo.143.2">The </span><code class="literal"><span class="koboSpan" id="kobo.144.1">server</span></code><span class="koboSpan" id="kobo.145.1"> method takes a user function that is invoked each time a request arrives. </span><span class="koboSpan" id="kobo.145.2">This user function takes the state of the server and the request event, and returns the response event. </span><span class="koboSpan" id="kobo.145.3">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.146.1">val proto = Reactor.server[Int, Int]((state, x) =&gt; x * 2) 
val server = system.spawn(proto) 
 
system.spawnLocal[Unit] { self =&gt; 
  (server ? </span><span class="koboSpan" id="kobo.146.2">7) onEvent { response =&gt; 
    println(response) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.147.1">The </span><code class="literal"><span class="koboSpan" id="kobo.148.1">state</span></code><span class="koboSpan" id="kobo.149.1"> object for the server contains a </span><code class="literal"><span class="koboSpan" id="kobo.150.1">Subscription</span></code><span class="koboSpan" id="kobo.151.1"> object, which allows the users to stop the server if, for example, an unexpected event arrives.</span></p></div><div class="section" title="Spawning a protocol-specific reactor directly"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec3"/><span class="koboSpan" id="kobo.152.1">Spawning a protocol-specific reactor directly</span></h3></div></div></div><p><span class="koboSpan" id="kobo.153.1">Finally, we can immediately start a server reactor, without any customization. </span><span class="koboSpan" id="kobo.153.2">This is done by passing a server function to the </span><code class="literal"><span class="koboSpan" id="kobo.154.1">server</span></code><span class="koboSpan" id="kobo.155.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.156.1">ReactorSystem</span></code><span class="koboSpan" id="kobo.157.1">, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.158.1">val server = system.server[Int, Int]((state, x) =&gt; x * 2) 
 
system.spawnLocal[Unit] { self =&gt; 
  (server ? </span><span class="koboSpan" id="kobo.158.2">7) onEvent { response =&gt; println(response)  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.159.1">In the subsequent sections, we will take a look at some other predefined protocols, which have similar API as the server-client protocol.</span></p></div></div><div class="section" title="Router protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec99"/><span class="koboSpan" id="kobo.160.1">Router protocol</span></h2></div></div></div><p><span class="koboSpan" id="kobo.161.1">In this section, we take a look at a simple router protocol. </span><span class="koboSpan" id="kobo.161.2">Here, events coming to a specific channel are routed between a set of target channels, according to some user-specified policy. </span><span class="koboSpan" id="kobo.161.3">In practice, there are a number of applications of this protocol, ranging from data replication and sharding, to load-balancing and multicasting. </span><span class="koboSpan" id="kobo.161.4">The protocol is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.162.1"><img src="graphics/image_10_004.jpg" alt="Router protocol"/></span></div><p><span class="koboSpan" id="kobo.163.1">To show the router protocol in action, we will instantiate a master reactor that will route the incoming requests between two workers. </span><span class="koboSpan" id="kobo.163.2">In a real system, requests typically represent workloads, and workers execute computations based on those requests. </span><span class="koboSpan" id="kobo.163.3">For simplicity, requests will be just strings, and the workers will just print those strings to the standard output.</span></p><p><span class="koboSpan" id="kobo.164.1">As was the case with the server-client protocol, there are several ways to instantiate the router protocol. </span><span class="koboSpan" id="kobo.164.2">First, the protocol can be started within an existing reactor, in which case it is just one of the protocols running inside that reactor. </span><span class="koboSpan" id="kobo.164.3">Alternatively, the protocol can be started as a standalone reactor, in which case that reactor is dedicated to the router protocol. </span><span class="koboSpan" id="kobo.164.4">In our example, we create an instance of the router protocol in an existing reactor.</span></p><p><span class="koboSpan" id="kobo.165.1">We first start two workers, called </span><code class="literal"><span class="koboSpan" id="kobo.166.1">worker1</span></code><span class="koboSpan" id="kobo.167.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.168.1">worker2</span></code><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">These two reactors will print incoming events to the standard output. </span><span class="koboSpan" id="kobo.169.3">We use a shorthand method </span><code class="literal"><span class="koboSpan" id="kobo.170.1">spawnLocal</span></code><span class="koboSpan" id="kobo.171.1">, to concisely start the reactors without creating the </span><code class="literal"><span class="koboSpan" id="kobo.172.1">Proto</span></code><span class="koboSpan" id="kobo.173.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.174.1">val worker1 = system.spawnLocal[String] { self =&gt; 
  self.main.events.onEvent(x =&gt; println(s"1: ${x}")) 
} 
val worker2 = system.spawnLocal[String] { self =&gt; 
  self.main.events.onEvent(x =&gt; println(s"2: ${x}")) 
} 
</span></pre><p><span class="koboSpan" id="kobo.175.1">Next, we declare a reactor whose main channel takes </span><code class="literal"><span class="koboSpan" id="kobo.176.1">Unit</span></code><span class="koboSpan" id="kobo.177.1"> events, since we will not be using the main channel for anything special. </span><span class="koboSpan" id="kobo.177.2">Inside that reactor, we first call the </span><code class="literal"><span class="koboSpan" id="kobo.178.1">router</span></code><span class="koboSpan" id="kobo.179.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.180.1">channels</span></code><span class="koboSpan" id="kobo.181.1"> service to open a connector with the appropriate type for the router. </span><span class="koboSpan" id="kobo.181.2">By just calling the </span><code class="literal"><span class="koboSpan" id="kobo.182.1">router</span></code><span class="koboSpan" id="kobo.183.1"> method, the router protocol does not yet start. </span><span class="koboSpan" id="kobo.183.2">We need to call the </span><code class="literal"><span class="koboSpan" id="kobo.184.1">route</span></code><span class="koboSpan" id="kobo.185.1"> method on the newly created connector to actually start routing.</span></p><p><span class="koboSpan" id="kobo.186.1">The </span><code class="literal"><span class="koboSpan" id="kobo.187.1">route</span></code><span class="koboSpan" id="kobo.188.1"> method expects a </span><code class="literal"><span class="koboSpan" id="kobo.189.1">Router.Policy</span></code><span class="koboSpan" id="kobo.190.1"> object as an argument. </span><span class="koboSpan" id="kobo.190.2">The policy object contains a function that returns a channel for an event that we want to route. </span><span class="koboSpan" id="kobo.190.3">This function of type </span><code class="literal"><span class="koboSpan" id="kobo.191.1">T =&gt; Channel[T]</span></code><span class="koboSpan" id="kobo.192.1"> represents the routing logic for the router protocol.</span></p><p><span class="koboSpan" id="kobo.193.1">In our example, we will use the simple round-robin policy. </span><span class="koboSpan" id="kobo.193.2">This policy can be instantiated with the </span><code class="literal"><span class="koboSpan" id="kobo.194.1">Router.roundRobin</span></code><span class="koboSpan" id="kobo.195.1"> factory method, which expects a list of channels for the round-robin policy, so we will pass a list with </span><code class="literal"><span class="koboSpan" id="kobo.196.1">worker1</span></code><span class="koboSpan" id="kobo.197.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.198.1">worker2</span></code><span class="koboSpan" id="kobo.199.1"> channels. </span><span class="koboSpan" id="kobo.199.2">We show this in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.200.1">system.spawnLocal[Unit] { self =&gt; 
  val router = system.channels.daemon.router[String] 
    .route(Router.roundRobin(Seq(worker1, worker2))) 
  router.channel ! </span><span class="koboSpan" id="kobo.200.2">"one" 
  router.channel ! </span><span class="koboSpan" id="kobo.200.3">"two" 
} 
</span></pre><p><span class="koboSpan" id="kobo.201.1">After starting the router protocol and sending the events </span><code class="literal"><span class="koboSpan" id="kobo.202.1">"one"</span></code><span class="koboSpan" id="kobo.203.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.204.1">"two"</span></code><span class="koboSpan" id="kobo.205.1"> to the router channel, the two strings are delivered to the two different workers. </span><span class="koboSpan" id="kobo.205.2">The </span><code class="literal"><span class="koboSpan" id="kobo.206.1">roundRobin</span></code><span class="koboSpan" id="kobo.207.1"> policy does not specify which of the target channels is chosen first, so the output can either contain </span><code class="literal"><span class="koboSpan" id="kobo.208.1">"1: one"</span></code><span class="koboSpan" id="kobo.209.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.210.1">"2: two"</span></code><span class="koboSpan" id="kobo.211.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.212.1">"1: two"</span></code><span class="koboSpan" id="kobo.213.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.214.1">"2: one"</span></code><span class="koboSpan" id="kobo.215.1">.</span></p><p><span class="koboSpan" id="kobo.216.1">The round-robin routing policy does not have any knowledge about the two target channels, so it just picks one after another in succession, and then the first one again when it reaches the end of the target list. </span><span class="koboSpan" id="kobo.216.2">Effectively, this policy constitutes a very simple form of load-balancing.</span></p><p><span class="koboSpan" id="kobo.217.1">There are other predefined policies that can be used with the router protocol. </span><span class="koboSpan" id="kobo.217.2">For example, the </span><code class="literal"><span class="koboSpan" id="kobo.218.1">Router.random</span></code><span class="koboSpan" id="kobo.219.1"> policy uses a random number generator to route events to different channels, which is more robust in scenarios when a high-load event gets sent periodically. </span><span class="koboSpan" id="kobo.219.2">Another policy is </span><code class="literal"><span class="koboSpan" id="kobo.220.1">Router.hash</span></code><span class="koboSpan" id="kobo.221.1">, which computes the hash code of the event, and uses it to find the target channel. </span><span class="koboSpan" id="kobo.221.2">If either of these are not satisfactory, </span><code class="literal"><span class="koboSpan" id="kobo.222.1">deficitRoundRobin</span></code><span class="koboSpan" id="kobo.223.1"> strategy tracks the expected cost of each event, and biases its routing decisions to balance the total cost sent to each target. </span><span class="koboSpan" id="kobo.223.2">Users can also create custom routing policies for other use-cases.</span></p></div><div class="section" title="Two-way protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec100"/><span class="koboSpan" id="kobo.224.1">Two-way protocol</span></h2></div></div></div><p><span class="koboSpan" id="kobo.225.1">In this section, we show a two-way communication protocol. </span><span class="koboSpan" id="kobo.225.2">In two-way communication, two parties obtain a connection handle of type </span><code class="literal"><span class="koboSpan" id="kobo.226.1">TwoWay</span></code><span class="koboSpan" id="kobo.227.1">, which allows them to simultaneously send and receive an unlimited number of events until they decide to close this connection. </span><span class="koboSpan" id="kobo.227.2">One party initiates the connection, so we call that party the client, and the other party the server. </span><span class="koboSpan" id="kobo.227.3">The </span><code class="literal"><span class="koboSpan" id="kobo.228.1">TwoWay</span></code><span class="koboSpan" id="kobo.229.1"> type has two type parameters </span><code class="literal"><span class="koboSpan" id="kobo.230.1">I</span></code><span class="koboSpan" id="kobo.231.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.232.1">O</span></code><span class="koboSpan" id="kobo.233.1">, which describe the types of input and output events, respectively, from the client's point of view. </span><span class="koboSpan" id="kobo.233.2">This is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.234.1"><img src="graphics/image_10_005.jpg" alt="Two-way protocol"/></span></div><p><span class="koboSpan" id="kobo.235.1">Note that these types are reversed depending on whether you are looking at the connection from the server-side or from the client-side. </span><span class="koboSpan" id="kobo.235.2">The type of the client-side two-way connection is:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.236.1">val clientTwoWay: TwoWay[In, Out] 
</span></pre><p><span class="koboSpan" id="kobo.237.1">Whereas the type of the server sees the two-way connection as:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.238.1">val serverTwoWay: TwoWay[Out, In] 
</span></pre><p><span class="koboSpan" id="kobo.239.1">Accordingly, the </span><code class="literal"><span class="koboSpan" id="kobo.240.1">TwoWay</span></code><span class="koboSpan" id="kobo.241.1"> object contains an output channel </span><code class="literal"><span class="koboSpan" id="kobo.242.1">output</span></code><span class="koboSpan" id="kobo.243.1">, and an input event stream </span><code class="literal"><span class="koboSpan" id="kobo.244.1">input</span></code><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">To close the connection, the </span><code class="literal"><span class="koboSpan" id="kobo.246.1">TwoWay</span></code><span class="koboSpan" id="kobo.247.1"> object contains a subscription object called </span><code class="literal"><span class="koboSpan" id="kobo.248.1">subscription</span></code><span class="koboSpan" id="kobo.249.1">, which is used to close the connection and free the associated resources.</span></p><p><span class="koboSpan" id="kobo.250.1">Let's create an instance of the two-way protocol. </span><span class="koboSpan" id="kobo.250.2">This protocol works in two phases. </span><span class="koboSpan" id="kobo.250.3">First, a client asks a two-way connection server to establish a two-way connection. </span><span class="koboSpan" id="kobo.250.4">After that, the client and the server use the two-way channel to communicate.</span></p><p><span class="koboSpan" id="kobo.251.1">In what follows, we declare a reactor, and instantiate a two-way connection server within that reactor. </span><span class="koboSpan" id="kobo.251.2">For each established two-way connection, the two-way server will receive strings, and send back the length of those strings.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.252.1">val seeker = Reactor[Unit] { self =&gt; 
  val lengthServer = self.system.channels 
    .twoWayServer[Int, String].serveTwoWay() 
</span></pre><p><span class="koboSpan" id="kobo.253.1">The two lines above declare a reactor </span><code class="literal"><span class="koboSpan" id="kobo.254.1">Proto</span></code><span class="koboSpan" id="kobo.255.1"> object, which instantiates a two-way server called </span><code class="literal"><span class="koboSpan" id="kobo.256.1">lengthServer</span></code><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">We first called the </span><code class="literal"><span class="koboSpan" id="kobo.258.1">twoWayServer</span></code><span class="koboSpan" id="kobo.259.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.260.1">Channels</span></code><span class="koboSpan" id="kobo.261.1"> service, and specified the input and the output type (from the point of view of the client). </span><span class="koboSpan" id="kobo.261.2">Then, we called the </span><code class="literal"><span class="koboSpan" id="kobo.262.1">serverTwoWay</span></code><span class="koboSpan" id="kobo.263.1"> method to start the protocol. </span><span class="koboSpan" id="kobo.263.2">In our case, we set the input type </span><code class="literal"><span class="koboSpan" id="kobo.264.1">I</span></code><span class="koboSpan" id="kobo.265.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.266.1">Int</span></code><span class="koboSpan" id="kobo.267.1">, meaning that the client will receive integers from the server, and the output type </span><code class="literal"><span class="koboSpan" id="kobo.268.1">O</span></code><span class="koboSpan" id="kobo.269.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.270.1">String</span></code><span class="koboSpan" id="kobo.271.1">, meaning that the client will be sending strings to the server.</span></p><p><span class="koboSpan" id="kobo.272.1">The resulting object </span><code class="literal"><span class="koboSpan" id="kobo.273.1">lengthServer</span></code><span class="koboSpan" id="kobo.274.1"> represents the state of the connection. </span><span class="koboSpan" id="kobo.274.2">It contains an event stream called </span><code class="literal"><span class="koboSpan" id="kobo.275.1">connections</span></code><span class="koboSpan" id="kobo.276.1">, which emits an event every time a client requests a connection. </span><span class="koboSpan" id="kobo.276.2">If we do nothing with this event stream, the server will remain silent - it will start new connections, but ignore events coming from the clients. </span><span class="koboSpan" id="kobo.276.3">How exactly the client and server communicate over the two-way connection (and when to terminate this connection) is up to the user to specify. </span><span class="koboSpan" id="kobo.276.4">To customize the two-way communication protocol with our own logic, we need to react to the </span><code class="literal"><span class="koboSpan" id="kobo.277.1">TwoWay</span></code><span class="koboSpan" id="kobo.278.1"> events emitted by the </span><code class="literal"><span class="koboSpan" id="kobo.279.1">connections</span></code><span class="koboSpan" id="kobo.280.1"> event stream, and install callbacks to the </span><code class="literal"><span class="koboSpan" id="kobo.281.1">TwoWay</span></code><span class="koboSpan" id="kobo.282.1"> objects.</span></p><p><span class="koboSpan" id="kobo.283.1">In our case, for each incoming two-way connection, we want to react to </span><code class="literal"><span class="koboSpan" id="kobo.284.1">input</span></code><span class="koboSpan" id="kobo.285.1"> strings by computing the length of the string, and then sending that length back along the </span><code class="literal"><span class="koboSpan" id="kobo.286.1">output</span></code><span class="koboSpan" id="kobo.287.1"> channel. </span><span class="koboSpan" id="kobo.287.2">We can do this as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.288.1">  lengthServer.connections.onEvent { serverTwoWay =&gt; 
    serverTwoWay.input.onEvent { s =&gt; 
      serverTwoWay.output ! </span><span class="koboSpan" id="kobo.288.2">s.length 
    } 
  } 
</span></pre><p><span class="koboSpan" id="kobo.289.1">We now have a working instance of the two-way connection server. </span><span class="koboSpan" id="kobo.289.2">The current state of the reactor can be illustrated with the following figure, where our new channel appears alongside standard reactor channels:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.290.1"><img src="graphics/image_10_006.jpg" alt="Two-way protocol"/></span></div><p><span class="koboSpan" id="kobo.291.1">Next, let's start the client-side part of the protocol. </span><span class="koboSpan" id="kobo.291.2">The client must use the two-way server channel to request a connection. </span><span class="koboSpan" id="kobo.291.3">The </span><code class="literal"><span class="koboSpan" id="kobo.292.1">lengthServer</span></code><span class="koboSpan" id="kobo.293.1"> object that we saw earlier has a field called </span><code class="literal"><span class="koboSpan" id="kobo.294.1">channel</span></code><span class="koboSpan" id="kobo.295.1"> that must be used for this purpose. </span><span class="koboSpan" id="kobo.295.2">The client must know about this channel to start the connection. </span><span class="koboSpan" id="kobo.295.3">Note that only the </span><code class="literal"><span class="koboSpan" id="kobo.296.1">channel</span></code><span class="koboSpan" id="kobo.297.1"> must be shared, not the complete </span><code class="literal"><span class="koboSpan" id="kobo.298.1">lengthServer</span></code><span class="koboSpan" id="kobo.299.1"> object. </span><span class="koboSpan" id="kobo.299.2">To make things simple, we will instantiate the client-side part of the protocol inside the same reactor as the server-side part.</span></p><p><span class="koboSpan" id="kobo.300.1">To connect to the server, the client must invoke the </span><code class="literal"><span class="koboSpan" id="kobo.301.1">connectTwoWay</span></code><span class="koboSpan" id="kobo.302.1"> extension method on the </span><code class="literal"><span class="koboSpan" id="kobo.303.1">channel</span></code><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">This method is only available when the package </span><code class="literal"><span class="koboSpan" id="kobo.305.1">io.reactors.protocol</span></code><span class="koboSpan" id="kobo.306.1"> is imported, and works on two-way server channels. </span><span class="koboSpan" id="kobo.306.2">The </span><code class="literal"><span class="koboSpan" id="kobo.307.1">connect</span></code><span class="koboSpan" id="kobo.308.1"> method returns an event stream that emits a </span><code class="literal"><span class="koboSpan" id="kobo.309.1">TwoWay</span></code><span class="koboSpan" id="kobo.310.1"> object once the connection gets established.</span></p><p><span class="koboSpan" id="kobo.311.1">In the following, we connect to the server. </span><span class="koboSpan" id="kobo.311.2">Once the server responds, we use the </span><code class="literal"><span class="koboSpan" id="kobo.312.1">TwoWay[Int, String]</span></code><span class="koboSpan" id="kobo.313.1"> object to send a string event, and then print the length event that we get back:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.314.1">  lengthServer.channel.connect() onEvent { clientTwoWay =&gt; 
    clientTwoWay.output ! </span><span class="koboSpan" id="kobo.314.2">"What's my length?" 
    </span><span class="koboSpan" id="kobo.314.3">clientTwoWay.input onEvent { len =&gt; 
      if (len == 17) println("received correct reply") 
      else println("reply incorrect: " + len) 
    } 
  } 
} 
 
system.spawn(seeker) 
</span></pre><p><span class="koboSpan" id="kobo.315.1">After the connection is established, the state of the reactor and its connectors is as shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.316.1"><img src="graphics/image_10_007.jpg" alt="Two-way protocol"/></span></div><p><span class="koboSpan" id="kobo.317.1">Note that, in this case, the two-way channel has both endpoints in the same reactor. </span><span class="koboSpan" id="kobo.317.2">This is because we called </span><code class="literal"><span class="koboSpan" id="kobo.318.1">twoWayServe</span></code><span class="koboSpan" id="kobo.319.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.320.1">connect</span></code><span class="koboSpan" id="kobo.321.1"> in the same reactor, for the purposes of demonstration. </span><span class="koboSpan" id="kobo.321.2">In real scenarios, we would typically invoke these two operations on separate reactors.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec73"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned about the reactor model, and its implementation in the Reactors framework. </span><span class="koboSpan" id="kobo.2.2">We saw how to define and instantiate reactors, compose event streams, customize reactor names and assign schedulers, use reactor system services, and define custom ones. </span><span class="koboSpan" id="kobo.2.3">Importantly, we saw how to use a few basic low-level protocols such as the server-client, router, and the two-way connection protocol.</span></p><p><span class="koboSpan" id="kobo.3.1">To learn more about reactors, you can find a lot of information on the website of the Reactors framework, at </span><a class="ulink" href="http://reactors.io/"><span class="koboSpan" id="kobo.4.1">http://reactors.io</span></a><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">The Reactors framework is relatively new, but it is under constant development. </span><span class="koboSpan" id="kobo.5.3">As the framework matures and gains more features, you will find more and more information on the website. </span><span class="koboSpan" id="kobo.5.4">To learn more about the reactor programming model itself, the paper </span><span class="emphasis"><em><span class="koboSpan" id="kobo.6.1">Reactors, Channels, and Event Streams for Composable Distributed Programming</span></em></span><span class="koboSpan" id="kobo.7.1"> is worth taking a look at.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec74"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the following exercises, you are expected to define several reactor protocols. </span><span class="koboSpan" id="kobo.2.2">In some cases, the task is to first investigate a specific algorithm online on your own, and then implement it using the Reactors framework. </span><span class="koboSpan" id="kobo.2.3">The exercises are ordered by their difficulty, and range from simple tasks to more complex ones.</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Define a method called </span><code class="literal"><span class="koboSpan" id="kobo.4.1">twice</span></code><span class="koboSpan" id="kobo.5.1">, which takes a target channel, and returns a channel that forwards every event twice to the target.</span><pre class="programlisting"><span class="koboSpan" id="kobo.6.1">        def twice[T](target: Channel[T]): Channel[T] 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.7.1">Define a method called </span><code class="literal"><span class="koboSpan" id="kobo.8.1">throttle</span></code><span class="koboSpan" id="kobo.9.1">, which throttles the rate at which events are forwarded to the target channel.</span><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">        def throttle[T](target: Channel[T]): Channel[T] 
</span></pre><p>
</p><p><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">Hint</span></strong></span><span class="koboSpan" id="kobo.12.1">: you will have to use the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Clock</span></code><span class="koboSpan" id="kobo.14.1"> service and the functional event stream composition.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.15.1">The </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Shutdown</span></code><span class="koboSpan" id="kobo.17.1"> service shown in this chapter can run out of memory if there are a lot of reactors subscribing to it. </span><span class="koboSpan" id="kobo.17.2">This is because the current implementation never removes entries from the service's </span><code class="literal"><span class="koboSpan" id="kobo.18.1">subscribers</span></code><span class="koboSpan" id="kobo.19.1"> map. </span><span class="koboSpan" id="kobo.19.2">Modify the custom </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Shutdown</span></code><span class="koboSpan" id="kobo.21.1"> service so that the clients of the </span><code class="literal"><span class="koboSpan" id="kobo.22.1">state</span></code><span class="koboSpan" id="kobo.23.1"> signals can unsubscribe from listening to shutdown events. </span><span class="koboSpan" id="kobo.23.2">Additionally, ensure that when a reactor terminates, it unsubscribes from the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Shutdown</span></code><span class="koboSpan" id="kobo.25.1"> service if it was subscribed to it. </span><span class="koboSpan" id="kobo.25.2">Use the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">sysEvents</span></code><span class="koboSpan" id="kobo.27.1"> event stream for this purpose.</span></li><li class="listitem"><span class="koboSpan" id="kobo.28.1">Assume that normal </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Channel</span></code><span class="koboSpan" id="kobo.30.1"> objects can occasionally lose some events or reorder them, but never duplicate or corrupt events. </span><span class="koboSpan" id="kobo.30.2">Implement a reliable channel protocol, which ensures that every event sent through a channel is delivered to its destination in the order it was sent. </span><span class="koboSpan" id="kobo.30.3">Define two methods </span><code class="literal"><span class="koboSpan" id="kobo.31.1">reliableServer</span></code><span class="koboSpan" id="kobo.32.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.33.1">openReliable</span></code><span class="koboSpan" id="kobo.34.1">, which are used to start the reliable connection server and open the reliable connection on the client, respectively. </span><span class="koboSpan" id="kobo.34.2">The methods must have the following signatures, where it is up to you to determine the types:</span><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">        def reliableServer[T](): Channel[Reliable.Req[T]] 
        def openReliable[T] 
        (s: Channel[Reliable.Req[T]]): Events[Channel[T]] 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.36.1">Implement the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.37.1">best-effort broadcast protocol</span></em></span><span class="koboSpan" id="kobo.38.1">, which delivers events to multiple targets. </span><span class="koboSpan" id="kobo.38.2">The broadcast method must implement the following interface, where events sent to the resulting channel must be forwarded to all the targets:</span><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">        def broadcast(targets: Seq[Channel[T]]): Channel[T] 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.40.1">Investigate and learn about how the CRDT counter algorithm works. </span><span class="koboSpan" id="kobo.40.2">Then, use the best-effort broadcast protocol from an earlier exercise to implement the CRDT counter algorithm. </span><span class="koboSpan" id="kobo.40.3">Define a method called </span><code class="literal"><span class="koboSpan" id="kobo.41.1">crdt</span></code><span class="koboSpan" id="kobo.42.1"> to allow users to create the CRDT counter.</span></li><li class="listitem"><span class="koboSpan" id="kobo.43.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.44.1">failureDetector</span></code><span class="koboSpan" id="kobo.45.1"> method, which takes a heartbeat server of </span><code class="literal"><span class="koboSpan" id="kobo.46.1">Unit</span></code><span class="koboSpan" id="kobo.47.1"> request and response types, and returns a </span><code class="literal"><span class="koboSpan" id="kobo.48.1">Signal</span></code><span class="koboSpan" id="kobo.49.1"> object that denotes whether the server is suspected to have failed:</span><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">        def failureDetector(s: Server[Unit, Unit]): Signal[Boolean] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.51.1">The protocol started by this method must regularly send heartbeat signals to the server, and expect replies within a certain time period. </span><span class="koboSpan" id="kobo.51.2">The server is suspected to have failed when its response does not arrive before that time period elapses. </span><span class="koboSpan" id="kobo.51.3">Implement a unit test to validate that the resulting signal correctly detects server failure.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.52.1">Implement the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.53.1">reliable broadcast algorithm</span></em></span><span class="koboSpan" id="kobo.54.1">, which has the same interface as the best-effort broadcast from an earlier exercise, but guarantees delivery to either all or none of the targets even if the sender dies halfway during the send operation. </span><span class="koboSpan" id="kobo.54.2">Implement unit tests to validate the correctness of your implementation.</span></li></ol></div></div></div></div></body></html>