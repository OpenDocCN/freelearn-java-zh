- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re now getting into the meat of the subject: how to do refactoring. It would
    be a bit silly to think we can cram all the refactoring techniques ever known
    into one chapter. So, we’ve decided to focus on the most common and more interesting
    ones. Our main source of wisdom comes from Martin Fowler’s fantastic work in his
    book, *Refactoring: Improving the Design of Existing Code*. He teamed up with
    Kent Beck to explain, step by step, how to do refactoring, from the simplest to
    the trickiest cases. For each one, they provide a kind of *how-to* guide so that
    you won’t mess things up. Here, we’re offering a selection of the most important
    refactoring techniques, an importance that we consider based largely on our own
    experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For those who don’t know, Martin Fowler and Kent Beck are influential figures
    in software development. Martin Fowler is known for his contributions to software
    design, refactoring, and agile methodologies, while Kent Beck is the creator of
    **Extreme Programming** (**XP**) and the JUnit testing framework. Both have had
    a significant impact on shaping agile practices and improving software development
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve tried to simplify even more what Fowler wrote and sprinkle in a bit of
    our own work background. If you haven’t already, we suggest you read the chapter
    on code smells ([*Chapter 3*](B20912_03.xhtml#_idTextAnchor070)) before you dive
    into this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for making well-structured methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving features from one object to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your data more organized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying those tricky `if`-`else` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up your method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some tips on using generalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nudge to use enums when they make sense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But let’s cut to the chase, starting with the basics: composing methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing better methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing methods is a fundamental skill that should be a part of every developer’s
    refactoring toolkit. To put it simply, almost bluntly, it’s about breaking your
    code into smaller pieces, each of which does just one thing in a very readable
    way, in a very procedural manner; you could almost think of it as a recipe (please
    forgive me; I’m Italian, so I always bring everything back to food). The details
    are hidden in the methods beneath the composed method; this allows us to read
    our logic, our code, at a high level – I dare say, almost “in prose.”
  prefs: []
  type: TYPE_NORMAL
- en: When refactoring your code, the process typically involves extracting code from
    the original method. If you find it challenging to come up with meaningful names
    for the extracted methods, it’s a clear sign that the code chunk you were about
    to extract may be too extensive. Another case I’ve come across is when someone
    (sometimes myself) suggested naming a method that contained the conjunctions “and”
    or “or”... also in this situation, it’s clear that the method we are working on
    has too many responsibilities and is doing too many things. In such cases, try
    to identify a smaller, more focused portion for extraction. Often, in longer methods,
    you may notice that certain sections are already marked with comments; these labeled
    sections can frequently be refactored into new methods.
  prefs: []
  type: TYPE_NORMAL
- en: You might find yourself, after applying this refactoring technique, having many
    short methods within the same class; this, in itself, is already an improvement.
    However, at this point, it might be desirable to further shorten the class by
    extracting a dedicated one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some guidelines you can follow when you have to compose methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The shorter, the better**: Lean toward brevity and conciseness in your code.
    Smaller functions and code blocks are generally preferred, as they enhance readability
    and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize redundancy**: When employing the composing method pattern, pay close
    attention to eliminating duplicate code fragments. This practice not only trims
    down your code base but also prevents inconsistencies and simplifies future updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show your purpose**: To foster code clarity and adopt a naming convention
    that leaves no room for ambiguity. Every variable, method, and parameter should
    be named in a way that succinctly conveys its role and function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strive for simplification**: Simplification is a guiding principle in code
    improvement. It entails the removal of unnecessary complexities, streamlining
    logic, and adhering to best practices. Simplified code is not only more elegant
    but also more maintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintain consistent detail levels**: When applying the composing method pattern,
    it’s essential to harmonize the complexity level of the methods you call. Avoid
    mixing simple, straightforward getters with functions that perform resource-intensive
    computations. Consistency in detail levels fosters code cohesion and comprehension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways to achieve these goals; next, we will see some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Extract Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen something about it in the previous chapters, but I would
    like to delve a bit deeper. In my opinion, this is the refactoring that we do
    (or should do) most often. It is quite simply taking a very long method – too
    long – and breaking it down into smaller methods. How long can a method be at
    most? Obviously, there is no general rule; it depends on your sensitivity and
    that of the team. Let’s say that I have to scroll with the mouse to read it all;
    this is already a small indicator of excessive length. I like to follow what Martin
    Fowler has taught us once again and try to limit the lines of my methods as much
    as possible; it sometimes happens that I have methods that are only two or three
    lines long. In addition to the code length for which I perform method extraction,
    sometimes I also consider the reusability of the code I am extracting, as it’s
    important to avoid copy-paste. However, I agree with Fowler (and of course I do!)
    in saying that methods should be written with their *intent* in mind; that is
    *what* those methods are supposed to do, and not *how* they’re gonna do it: isolate
    all the code needed to do a certain thing in a single method, no matter how small.
    The method’s name should then be based on “what” the method does and not “how”
    it does it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate these concepts with a very simple example. Suppose we have
    the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the method is very simple: it is a method that calculates the
    sum and difference of two numbers and prints them. Of course, the reality is much
    more complex than that, but the principles do not change. We refactor the code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have extracted three methods: one that sums up the numbers, a second that
    makes the difference, and a third that prints the result on the screen to avoid
    repetition. Don’t be fooled by the length of this specific piece of code; again,
    it’s just one example to illustrate the concept – in reality, you have to think
    of sum and difference operations as longer methods that implement perhaps more
    complex logic. Another reflection we can make here is that extracting methods
    promotes code reuse because the logic thus extracted can be invoked in many different
    points.'
  prefs: []
  type: TYPE_NORMAL
- en: Inline Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is exactly the opposite of extracting methods. It may seem strange, after
    having insisted so much on the extraction of methods, on short methods, to suggest
    that sometimes it is appropriate, instead, to inline the method. This little refactoring
    can be very useful when you have a very short method (typically a line of code
    or two) that is never reused and that already expresses very well what it does;
    in this case, isolation in a method with the sole purpose of “explaining,” through
    the name of the method itself, what the method does may be excessive.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll provide you with a very trivial example of what method inlining is. Let’s
    suppose we have the following three methods in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can easily see, we have a `calculate` method that takes two integers
    as input and performs a series of operations on them. The operations are represented
    by the `add` and `multiply` methods, which, of course, make the sum and the product
    of the two integers they take as input. These methods are used only once and are
    very simple: in fact, only one line. So, let’s take the opportunity to perform
    method inlining and make the code shorter and more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` and `multiply` methods disappeared, and their implementation, consisting
    of a single line of code, replaced them where they were invoked. We could further
    refactor the code by returning directly the result of the last operation, avoiding
    the `result` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example may seem contradictory to what we wrote in the previous chapter
    (in fact, we are now inling something that before we isolated), but it’s just
    for the sake of providing a very simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, what you have to do to perform an “Inline Method” refactoring is
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the method hasn’t been changed in subclasses. If it has been modified,
    avoid using this technique.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hunt down all the places where the method is called, then replace those calls
    with the actual code from the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and delete the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, since we are talking about refactoring, the behavior must never change;
    to be sure, there’s no other way than to include testing in the little recipe
    written previously. Be sure to always carry out a test before eliminating a method
    that you have inlined. We’ll get to that later in the book, but most modern **integrated
    development** **environments** (**IDEs**) offer tools to do this refactoring with
    a simple click of the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Inline Method refactoring in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When the method’s implementation is straightforward**: If the method’s logic
    is simple and direct, as demonstrated in the preceding example, consider employing
    this refactoring technique to eliminate it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When you want to eliminate unnecessary delegation**: At times, you may transfer
    the method’s implementation to another method or class, introducing unnecessary
    indirection in the code. To streamline the code and remove this extra layer of
    delegation, use the Inline Method technique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a foundation for subsequent refactorings**: The process of refactoring
    is not always a linear one, and there are various ways to refactor the same code.
    For instance, you can employ extract method refactoring to isolate different code
    segments. However, if the refactoring path you initially chose does not yield
    improved code, you can use the inline method to reintegrate previously extracted
    code back into its original method and then explore alternative refactoring approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract and inline variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We summarize these two refactoring techniques in a single section since – in
    our humble opinion – they are very similar to the Extract Method and Inline Method
    techniques but applied to a single variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main motivation – perhaps the only one – to introduce (extract) a variable
    instead of an expression is when the latter could be difficult to understand (not
    so much and not only on a technical level; we talk here about the motivation behind
    the expression itself). Let’s try to explain ourselves better with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we analyze a field of a generic `transport` object that
    represents a means of transport; among its various fields, the object also has
    an `equipment` object that tells us what means of transport it is. Unfortunately,
    this field is a string (see [*Chapter 3*](B20912_03.xhtml#_idTextAnchor070), *Primitive
    Obsession*), and we are forced to write an `if` statement to understand what type
    it is, whether plane or train. The code snippet is a bit clearer if we insert
    the result of `equals` within a couple of variables with a self-explanatory name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Someone would be tempted to simply insert a comment to explain what those cryptic
    strings `"PLN"` and `"TRN"` refer to, but personally, we find this kind of approach
    more effective. You could also use enums instead of plain strings so that a possible
    typo would be caught by the compiler. By introducing these “intermediate parts”
    formed by the variables, the code is made more understandable. The drawback is…
    that your code contains more variables. As always in life, it is a problem of
    balance! The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique of “inline variable,” on the other hand, is so similar to that
    of the *inline method* that it is worth explaining it directly through an example
    that is practically the same as the one seen in the relative section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, assigning to the `sum` variable the result of the addition –
    and then never using it again after printing it – does not add much to the understanding
    of the code compared to the expression itself. It is therefore better to inline
    the variable directly in the only point where it is used, eliminating the first
    line of the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Combining a function into a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the last notable example of refactoring that reorganizes code by “recomposing”
    methods, we propose one that combines several methods within a single class. This
    technique is used when we have several methods that have in common one (or more)
    input parameters; that is, that – in practice – go to act on the same classes.
    Again, let’s go directly to show an example that should better clarify the concept.
    Suppose we have this set of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these methods take a single parameter of the `Location` type. It would
    be better to enclose all the logic concerning the `Location` parameter in a single
    point. For this, we create a class that contains all the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A `Location` instance is passed only once, in the constructor. From the signatures
    of the methods we then removed the parameter; now, you no longer need to pass
    it. Of course, consider carefully whether to refactor this way; if your `Location`
    instance changes often, such as for each method call, using such a pattern might
    not be the best idea, because you should instantiate a `LocationHandler` for each
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Moving features between objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned several times, and as those who have been in this
    profession for more than a few years know organizing our code is perhaps one of
    the most challenging parts. Personally, I believe I have never managed to get
    the design of a software project right on the first try. But, once again, the
    software is fortunately (or unfortunately!) malleable, so with the right limits
    and a good amount of refactoring, we can move methods and fields from one class
    to another without too much difficulty. We can decide to extract a class or remove
    one and inline it. Above all, we can eliminate the so-called dead code. But let’s
    start showing something.
  prefs: []
  type: TYPE_NORMAL
- en: Moving a method or field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This refactoring is quite basic (Martin Fowler calls it the “bread and butter”
    of refactorings), but it is one of the most frequently performed ones. This is
    because, as we have already mentioned, it is good practice to maintain a certain
    modularity in your software project so that classes, packages, and so on are grouped
    coherently based on the context in which they operate. For example, in one package,
    we may place all classes responsible for managing user information, while in another,
    we may gather all clients for external services. There is no single criterion,
    but rather, often, a certain subjectivity. This is why it can often happen that
    methods or individual fields are moved from one class to another. This movement,
    guided by the principle of keeping related things together and separating things
    that should be separate, simplifies the code.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of those cases where doing something is simpler and more intuitive
    than explaining it, but I’ll try to give you Martin Fowler’s “recipe” for it,
    perhaps simplifying it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transferring a method from the source class to the target class involves several
    steps that must be followed to ensure a successful refactoring process:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the dependencies and other class members that the method utilizes. Determine
    if it’s necessary to relocate them to the new class as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the method is referenced by a superclass or subclass. If it’s
    being used by these classes, it may not be feasible to move the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish the method in the target class and replicate existing code into it.
    If the relocated method relies on an instance of the original class, you can pass
    it as a method parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the code within the old method and direct the call to the new method.
    (This is optional; you could also use a **feature toggle**.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, make a decision about whether to eliminate the old method entirely
    and directly invoke the new method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feature toggle
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature toggles**, also known as **feature flags**, are a technique that
    allows us to activate or deactivate specific functionalities without directly
    modifying the source code. This approach brings benefits such as continuous deployment,
    simplified testing in real-world conditions, efficient issue management, gradual
    feature rollouts for risk management, and the ability to compare feature variants
    for informed decision-making.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the most abstract sense, a feature toggle would work like this in a Java
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void` `applyLogic() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    if (``newFeatureEnabled) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`applyNewLogic();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}` `else {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`applyCurrentLogic();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it is advisable to execute your test suite. It’s essential to bear
    in mind, even though it should be implicit when discussing refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: With a single field, the process is very similar. We have a field that is used
    by another class more than the class in which it is defined. The context is not
    respected; therefore, we move the field to that other class, subsequently changing
    all points where that field is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields are often moved around when applying the **Extract Class** technique,
    and deciding which class should keep a particular field can be a bit tricky. Here’s
    a practical rule of thumb: put the field in the same class as the methods that
    use it the most, or in the class where you find most of these methods. This rule
    can also prove beneficial in scenarios where a field is clearly situated in an
    inappropriate location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, let’s present the methodology as described by Fowler:'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with a public field, refactoring becomes significantly more manageable
    by converting it into a private field and providing public access methods (you
    can utilize the **Encapsulate Field** technique for this purpose, as explained
    in the *Field* *encapsulation* section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish the same field within the receiving class along with its corresponding
    access methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine how you will access the receiving class. You may already possess a
    field or method that yields the required object. If not, you’ll need to create
    a new method or field to store the object associated with the receiving class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Substitute all occurrences where the old field is referenced with appropriate
    method calls in the receiving class. If the field is not private, address this
    in both the superclass and any subclasses as necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminate the field from the original class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving statements into/from methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Repeated code is one of the most common problems in our code base; the temptation
    to copy and paste is sometimes too strong. This can be seen before calling a certain
    method, a certain line of code; it can also happen that the same line of code
    is repeated before each call to that method. At this point, you will have understood
    that the best alternative is to take that statement and move it directly inside
    that method.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, there may be a statement within the code that doesn’t fit well
    with the context of the method; perhaps it makes sense in one execution flow but
    not in another. In this case, make the opposite move to the previous one and move
    the statement outside of the method, to the point where it’s truly needed.
  prefs: []
  type: TYPE_NORMAL
- en: I consider this technique very common but quite straightforward. For a deeper
    exploration of the “mechanics” of how it works, I refer you to the *Further* *reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This refactoring technique is applied when a class (referred to as the client)
    obtains an object of type *B* (referred to as the delegate) through another class
    of type *A* (referred to as the server). When client code calls a method defined
    on an object within a server object’s field, it establishes a direct dependency
    on that delegate object. Consequently, if the delegate object’s interface undergoes
    changes, all clients of the server relying on that delegate are affected. To eliminate
    this dependency, one can introduce a straightforward delegation method within
    the server, effectively hiding the delegate. Any subsequent modifications made
    to the delegate’s interface will then only impact the server itself, shielding
    clients from these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will clarify a bit what we just said. Let’s suppose to have two
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to get `departureAirport`, but we have an instance of `Flight`,
    our code will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is OK, of course, except for the fact that now we must also be aware of
    the `Itinerary` class; that is actually useless since we need just `departureAirport`.
    We don’t want to change our code if the `Itinerary` class changes. So, we will
    write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we just call a method of the `Flight` class to get the field we need. Of
    course, we will also have to change the client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The delegate is now hidden. We have less code and fewer relations between objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'But as a recipe, as Martin Fowler does, here are the steps to perform this
    refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: For every method in the delegate class that the client class calls, generate
    a corresponding method in the server class that forwards the call to the delegate
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the client code to invoke the methods in the server class instead of
    directly calling the delegate class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your modifications successfully eliminate the client’s dependency on the
    delegate class, you can safely remove the access method to the delegate class
    within the server class (the method originally used to obtain the delegate class).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One downside is that if you have to generate an excessive number of delegate
    methods, the server class may end up being an unnecessary intermediary, resulting
    in an abundance of middlemen.
  prefs: []
  type: TYPE_NORMAL
- en: Removing dead code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ah, here’s one of the things that satisfies me the most: deleting unnecessary
    code! Dead code refers to parts of the source code that are no longer executed
    or reachable during the program’s execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dead code can occur for various reasons, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code removal or refactoring**: When developers modify a program, they may
    delete or comment out certain sections of code that are no longer needed. These
    leftover code snippets become dead code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Conditional branches**: In some cases, code may be written within branches
    of conditional statements that are never true during execution, making the code
    within those branches effectively dead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unused variables or functions**: If variables or functions are defined but
    not used anywhere in the program, they are considered dead code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You don’t want dead code in your project: it makes it harder to understand,
    increases maintenance costs, and potentially introduces bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: So, please, if you are aware of dead code in your project – and modern IDEs
    now are perfectly capable of doing that – please just remove it. No – don’t comment
    it out! Get rid of it; if you just want to recover it, I bet you’re using a versioning
    control system (such as Git or Subversion) that will do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Watch out also for so-called **dead comments**. As we mentioned before, our
    view on comments is that there should be as few as possible and focused on explaining
    *why* something is done. In an ideal and fantastic world, the code itself should
    be able to explain without needing extra comments. What often – very often – happens
    is that comments don’t get updated along with the code, becoming not only irrelevant
    but also harmful, sometimes misleading. Even if you’re taught to add lots of comments
    to code in school (at least, I was), please try to keep it to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we’ve said about dead code can of course be applied also to modules, services,
    or even individual features. It’s quite common to see the proliferation of modules
    and services deployed in production that are no longer actually used, and their
    only effect is to consume precious (read: expensive) resources. Typically, everyone
    forgets about them until it’s time to update them (for example, due to a discovered
    vulnerability among their dependencies) or when someone realizes they’re costing
    a lot of money in hardware resources! In the case of features, it’s similar: why
    keep unused features that make the code more complex without any real benefit?
    Get rid of them at the first opportunity, and you won’t regret it!'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen a very important part of code refactoring, and we’ve learned some
    techniques for moving pieces of code without too much disruption. In addition
    to being in the right place, features must be well structured and organized. Let’s
    see some suggestions about this.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How data is organized is one of the most important aspects of our profession;
    coherently aggregating information forms the foundation for building a solid,
    maintainable, and extensible software project. Various types of refactoring assist
    us in this regard, and once again, Fowler helps us navigate them in great detail.
    In the upcoming sections, we will present a selection of those we consider to
    be the most common or potentially misleading.
  prefs: []
  type: TYPE_NORMAL
- en: Field encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will group together in a single section techniques that we believe are very
    similar to each other and ultimately concerned with not revealing the internal
    structure of a class to its users. This principle is known as **encapsulation**
    and is one of the fundamental concepts of **object-oriented programming** (**OOP**);
    hiding the internal structure of a class and providing access methods to its fields
    is beneficial because it simplifies the use of the class, protects data, improves
    maintainability, encapsulates behavior, and allows access control. Data is not
    separated from the associated behaviors, the modularity of program sections is
    not compromised, and maintenance is simplified. To achieve encapsulation starting
    from a public field, it is sufficient to make the field private and expose so-called
    *getter* and *setter* methods. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `departureAirport` field has been made private, and we expose two methods
    that respectively read and write the field itself. If you want to make the class
    immutable – something we highly recommend in general – you would just need to
    make `departureAirport` final, add it to the constructor, and eliminate the *setter*
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Someone might argue that this way, we still expose the class’s structure, and...
    they would be right! However, keep in mind that this is a very simple case: for
    example, it’s not necessary for getters and setters to exist for all fields or
    that they must exclusively perform read or write operations on the fields – they
    could also involve some logic (but be cautious about performance in this case!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important note: starting from Java 14, the `Record` keyword was introduced
    – a construct that allows you to define a class such as `Flight` in a single line,
    with less boilerplate. You can refer to the *Further reading* section for more
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also encapsulate the field within the class itself. Let’s extend our
    `Flight` class a bit, assuming that we also need to access the `departureAirport`
    field internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At times, directly accessing a private field within a class may lack the desired
    flexibility. You have the option to execute intricate operations when data within
    the field is set or received – tasks such as *lazy initialization* and validation
    of field values can be effortlessly incorporated within the field’s getters and
    setters. Other than that, you’d have the ability to override getters and setters
    in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `Flight` class would look like this (please observe the `getDepartureAirportCode`
    method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Someone could argue that we gained in flexibility but lost a bit in readability
    because of the need to read the `getDepartureAirport` method; someone else could
    say that this is untrue, as long as the methods are named well and represent just
    a getter; we’re also promoting loose coupling. It’s up to you to choose which
    path to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final case of encapsulation that we want to present concerns collections,
    and I have indeed seen this problem many times. In this case, the class contains
    a field of the `Collection` type, and its getters and setters operate on the entire
    collection, making it more challenging to interact with it. Modifying the previous
    examples slightly, let’s suppose we have a `Flight` class that contains a `Collection`
    field of airports, one for each stopover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The protocol for utilizing these collections differs slightly from that employed
    by other data types. It is important to note that the getter method should not
    return the actual collection object itself. Doing so would permit clients to manipulate
    the contents of the collection without the owner class’s awareness. Moreover,
    this would reveal an excessive amount of the object’s internal data structure
    to clients. Instead, the method for retrieving collection elements should provide
    a value that prevents any modifications to the collection and avoids revealing
    too much information about its structure. There should be no method for directly
    assigning a value to a collection. Instead, the protocol should provide operations
    for adding and deleting elements. This approach empowers the owner object to exercise
    control over the addition and removal of elements within the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the setter method and added two methods for adding and removing
    elements from the list. When we return the list through the getter, we instantiate
    a new immutable list using Java 17’s `Collections::unmodifiableList` methods (but
    we could have used Guava, Apache Commons, or whatever).
  prefs: []
  type: TYPE_NORMAL
- en: A couple of disclaimers
  prefs: []
  type: TYPE_NORMAL
- en: We are modifying objects, which goes against the concept of immutability that
    we have advocated for on these pages, so please be cautious. Also, remember that
    the type of the collection for which you are performing add and remove operations
    (in this case, `Airport`) must override the `equals` and `hashCode` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing primitives with objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This refactoring comes to our rescue when dealing with the code smell called
    `Flight` class, this time, let’s assume that a field containing the service level,
    also known as “cabin class,” is defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to filter from a list of flights only the most expensive ones,
    we would have to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not ideal. I need to know what all the possible values for the cabin class
    are, and I must know exactly which one is more expensive than the other. In these
    cases, it’s better to use a class to replace the primitive type, allowing not
    only wrapping but also the implementation of custom logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `higherThan` method allows us to implement a logic that
    compares our cabin class to another, without worrying about managing and maintaining
    the logic itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think it is worth taking a look at the `CabinClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It has a name and a value; the latter is used to determine the position in the
    “value scale” of the cabin classes, and it is assigned to the class constructor.
    We still have a lot of strings around, but I think we can do better. Let’s go
    ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing type code with subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the previous example, that of the cabin class. You may have
    noticed that defining the “type” of the cabin class by passing a string in the
    constructor is not ideal. In a simple scenario, we could make a typo while writing
    the type; in reality, the real issue is that we are delegating to the caller knowledge
    that should be internal to the `CabinClass` class. When we have a situation such
    as this, a situation in which our class has a “type,” and the behavior of the
    class itself can depend on this type, a useful refactoring is to create subclasses.
    Our `CabinClass` class would then become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But we would also have a series of subclasses defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the parameters are defined within the constructor, and how it is
    impossible for the caller to modify them. In this way, among other things, we
    leverage all the advantages of OOP, and code readability is also improved as a
    result. For completeness, here is a snippet that filters expensive flights, modified
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we simply instantiate an `Economy` class to be used into the `higherThan`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing data well means, at the end of the day, simplifying things – or at
    least making them more readable. One thing that can make code very complicated
    to read is conditional logic. Let’s see how you can simplify it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying conditional logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we will also rely on Martin Fowler and try to explain some
    of the refactorings to what we consider to be the most common problems. The selection
    is arbitrary and based solely on our experience. For further details, we refer
    you to the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a special case instead of null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do not return `null`. This is a mantra that everyone – even engineers with
    years of experience – sometimes forgets. There are cases where a method should
    return a result but cannot: some error in the execution flow; some exceptional
    cases. Java and many other languages allow returning `null`, but it’s preferable
    not to do so for obvious reasons – among them, avoiding a `NullPointerException`
    in the caller or forcing it to check every time that the method’s result is not
    `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Tony Hoare introduced Null references in **ALGOL W** back in 1965 “simply because
    it was so easy to implement,” according to him. Reflecting on that decision, he
    refers to it as his “billion-dollar mistake”. More on this in the *Further* *reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to avoid null references, but one of the most common
    is to return a so-called **Special Case** object, which is a default object with
    predefined values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can notice how we need to differentiate the logic by checking if the object
    returned by the repository is `null`. In this case, it wouldn’t even be very useful
    if the repository method returned an `Optional` because we would still need to
    write an `if` statement; in our opinion, however, it would be better because it
    would at least make the caller aware that the call may not return the desired
    result. One solution, though, is to introduce a Special Case object. Here is a
    possible implementation in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduce an interface that allows us to implement the special case, and
    then we implement it in two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `ActualCustomerAddress` class is the actual “real” one, while
    the other is a kind of “dummy object” used to allow the caller to not change the
    execution flow when calling the method. Of course, we have the (small?) disadvantage
    of creating more classes than there were before; the cleanliness of the code greatly
    benefits from this.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, we could also craft a specific exception for our situation and throw
    that instead of giving back a fake object. But, honestly, we don’t see that happening
    a lot (and we’re not big fans of it!). Still, it is worth acknowledging this for
    the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Using polymorphism instead of conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s revisit a code smell discussed in [*Chapter 3*](B20912_03.xhtml#_idTextAnchor070):
    repeated switches. When there is a lot of conditional logic, it’s better to introduce
    some structure. When a `switch` statement is repeated many times in the code,
    especially around a variable named `type`, it’s highly likely that refactoring
    is a better approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this method, which calculates the distance traveled in a travel itinerary
    – whether it’s by plane or by train – we encounter several issues. The caller
    must be aware of the possible values that `type` can take, implementing different
    logic at each point in the code where it’s needed. Furthermore, we anticipate
    that there will be other points in the code where it needs to behave differently
    based on the type of itinerary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can simply utilize polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Polymorphism in the previous code allows us to treat different types of itineraries
    (`FlightItinerary` and `TrainItinerary`) as instances of a common base class (`Itinerary`).
    This enables you to call the `calculateItineraryDistance` method on them without
    knowing their specific types, promoting code flexibility and reuse, and creating
    two classes that extend the same abstract class. At this point, the caller will
    no longer have to worry about anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Removing duplicated conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It can sometimes happen that identical code is duplicated within the two branches
    of an `if`-`else` block in a conditional statement. Why this happens, I honestly
    couldn’t say; however, I can testify that I’ve seen it more often when methods
    are very long or as a result of refactoring. In my humble opinion, it’s usually
    a simple oversight, but it’s an oversight that happens more often than you might
    think. For example, in the previous example, we can observe precisely that `calculateItineraryDistance(departureLocation,
    arrivalLocation);` is called in two different cases within the `switch` statement.
    In general, when we are in a condition in which the same call is repeated, we
    can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The advice is simply to take the duplicate call out of the `if` statement,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that maybe the method in question does not exist yet; however,
    there is repeated code that you can put together using the **Extract** **Method**
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: Guard clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last piece of advice I give you is on simplifying conditional logic concerns’
    nested `if` statements; I must admit that I suffer a lot when I find them, with
    the code moving further and further to the right of the screen, almost forming
    mandalas that need a really large monitor to be appreciated! A slope toward the
    abyss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a method that, in addition to being very trivial, has
    many nested `if` statements. It takes three parameters as input and finds the
    largest, but none of them must be negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the purpose and functionality of each conditional is challenging
    due to the lack of clarity in a typical code execution flow. These conditionals
    suggest a disorganized development process, with each condition added as a temporary
    solution without considering the optimization of the overall structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the situation, separate exceptional cases into distinct conditions
    that promptly terminate execution and return a `null` value if the guard clauses
    are evaluated as `true`. Essentially, your goal here is to streamline the code
    structure and make it more linear, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We know this code could be even more rewritten, but it’s just for explaining
    the concept. Some might argue that this method has too many returns within it
    and that it would be better to have only one. I can’t say, honestly, if there
    are too many, but it’s a good point to observe. I agree, however, with what Steve
    McConnell says in his book, *Code Complete*: use a `return` statement when it
    makes your code easier to understand. In some functions, as soon as you have the
    answer, just give it back to the calling function right away. If the function
    doesn’t need any extra cleanup after finding an error, not returning immediately
    would mean having to write more code.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the code is mainly focused on performance, stopping after the most
    usual condition can skip some extra checks. This can be really helpful, especially
    if one or two situations make up the majority, like 80 or 90% of the time it runs.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying method calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method calls are essential in OOP, as they enable objects to perform specific
    tasks or actions. There are many techniques intended to simplify the way objects
    interact with each other; we’re going to see some of the most interesting ones.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already discussed the side effects and mutability of objects in [*Chapter
    3*](B20912_03.xhtml#_idTextAnchor070), explaining why they are not ideal in a
    software project. A typical way to cause side effects is when you mix a query,
    which is a part of the code that simply retrieves information, and a modifier,
    which is code that performs an action on some data or system, thereby changing
    its state. Here’s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the method calculates the total price for a specific travel
    itinerary and simultaneously sends a summary email to the customer. We have several
    issues here. First (but this is the least of them), the name is misleading because
    it is not consistent with the actual behavior of the method. Furthermore, the
    method does more than one thing; particularly, it returns information (a `Price`
    instance) on one hand, but on the other hand, it changes the state of things by
    notifying the user. It’s better to separate these concerns, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We now have two distinct methods, one that requests information and another
    that somehow modifies the system’s state. It’s worth noting that a query method
    can be called as many times as desired without affecting the system’s state. The
    code is cleaner, and we have also removed a parameter from the `getTotalItineraryPrice`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Removing setter methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, this section should almost be a continuation of the previous one.
    Removing so-called *setter* methods, which allow you to set the value of an object’s
    field, makes them immutable, removing undesirable side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already discussed this in this chapter, but we’d like to go into a bit
    more detail. Let’s consider a very simple class representing a person; let’s include
    only two fields for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Person` class is represented with `taxCode` and `name`. `taxCode` is unique
    and represents the identifier for a person. As we see, you can instantiate this
    class and set its fields, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we returned this instance to a calling method, no one would guarantee that
    its fields would not be modified. The refactoring in question simply aims to remove
    setter methods, adding its parameter inside the constructor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `taxCode` is passed inside the constructor. In the `Person` class,
    the `taxCode` field can then become `final`.
  prefs: []
  type: TYPE_NORMAL
- en: True immutability – the builder pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make an object truly immutable in each of its fields, we recommend using
    the **builder pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern is a design pattern used to construct complex objects step
    by step. It separates the construction of an object from its representation, allowing
    you to create different representations of the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the builder pattern typically works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a builder class**: First, you create a separate builder class for
    constructing an object. This builder class has methods for setting the various
    attributes of the object you want to create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set attributes**: You use the methods in the builder class to set the attributes
    of the object. Each method typically returns the builder object itself, allowing
    you to chain method calls (this is known as **method chaining**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build` method on the builder object, which constructs and returns the final
    object with the specified configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A builder class for the `Person` class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can clearly see a static `builder` method that instantiates the builder
    itself, taking `taxCode` as its only parameter, which is mandatory. The `name`
    method is just a setter of the `name` attribute; you can have one setter for each
    field of your class. At the end, the `build` method creates and populates an instance
    of `Person`. Using the builder pattern on a type is meaningful as long as you
    do not provide any other method to instantiate that type; for example, you can
    keep the constructor of the `Person` type private and create `builder` as an inner
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of `PersonBuilder` is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once the object has been built (instantiated), you cannot modify its fields.
    In this example, the `builder` method (in this instance, the builder, in fact,
    and not the `Person` class) takes as a parameter `taxCode`, which is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: There are tools to automate the creation of builder classes, which we will discuss
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Using generalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generalization** is one of the most powerful features of OOP, and it must
    be used wisely (*with great power comes great responsibility*). I’ll report here
    just some of the most interesting refactorings in this area, going fast with the
    most basic and delving a little bit deeper with the others.'
  prefs: []
  type: TYPE_NORMAL
- en: Pull up field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This technique consists of moving a field (or variable) from a subclass to
    a superclass. This is typically done when multiple subclasses share the same field
    or when you want to establish a common interface or behavior in the superclass.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Triangle` and `Square` have a field in common; just extract an interface or
    an `abstract` class to do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Push down field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the opposite of a pull down field, and it’s used when you have a field
    (or attribute) defined in a superclass, but it’s only relevant to a specific subclass
    or a subset of subclasses. You just have to move the field from the superclass
    to the subclass where it’s actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s take a `Vehicle` class containing a single field called
    `engine`. We have two subclasses extending from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'While it makes sense for a Car to have an engine, of course, it doesn’t for
    a Bicycle. Let’s move the `engine` field into the only class it needs to be in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Pull up method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This consists of moving a method from a subclass to a superclass. This is typically
    done when multiple subclasses share a common behavior, and you want to establish
    that behavior in the superclass to promote code reuse. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s worth pulling the `calculatePerimeter` method up in the superclass and
    removing the method from `Triangle` and `Square`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Push down method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the opposite of the pull up method, and it is used when you have a method
    defined in a superclass, but its behavior is relevant only to a specific subclass
    or a subset of subclasses. You just have to move the method from the superclass
    to the subclass where it’s actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s take again a `Vehicle` class containing a single method
    called `fillTank`. We also have two subclasses extending from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can easily guess, having a `fillTank` method doesn’t make any sense
    for a class representing a bicycle, but only for a class representing a car. So,
    what we’re gonna do is just push the method down onto the `Car` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Template method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It often happens, when we program, that we have algorithms or processes of
    some kind to apply to objects in a way that is almost entirely similar but not
    exactly the same. A certain logic may apply generally to an entire category of
    objects, but these objects may have some specific characteristics that make them
    different. In the previous examples, we used the classic example of polygons.
    We can say that for a polygon, the calculation of the perimeter always involves
    summing the lengths of its respective sides. However, between a triangle and a
    square, for example, the number of sides changes. Therefore, it could be useful
    to have a method in the superclass that is implemented in the subclasses and represents
    their specific characteristics. I believe it’s easier to explain this with an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Triangle` and `Square` have a `getPerimeter` method that basically sums
    up the length of their sides; we could not just pull up the method, because the
    implementation is different – one has three potentially different sides, and the
    other has four equal sides. What we’re going to do is implement a template method,
    in which we will call another method defined in the subclasses, which just returns
    a `Collection` field of side lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We have created a `getSideLengths` template method that reduces redundancy by
    consolidating common algorithmic steps in a superclass while allowing distinctions
    to remain in the subclasses. This is a vibrant example of the **Open/Closed Principle**
    (**OCP**) in practice. If a new version of the algorithm is introduced, you can
    simply create a new subclass without needing to modify the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Using enums instead of constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have seen some of the main refactoring techniques discussed
    in the literature. Now, we move on to a final section where we allow ourselves
    to give you a couple of tips on how to better organize your code design. These
    may seem trivial, but they often lead to considerable annoyance. The first tip,
    as the title of this section suggests, concerns the excessive use of constants
    (a thorough study based solely on my perception and experience undoubtedly shows
    that these constants will be strings 99% of the time).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In another class, we defined the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In one method, let’s instantiate our `Itinerary` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Do you see anything weird? We accidentally swapped `cabinClass` with `transportType`!
    We didn’t even realize it because everything compiles when we’re just dealing
    with strings. If we don’t really need to create custom types to represent these
    concepts, such as the transport type and the cabin class, our suggestion is to
    use enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, let’s introduce enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then rewrite the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This will then be used without the possibility of error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Using enums is generally better than constants in Java because they offer the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type safety**: Enums are types themselves, meaning they allow you to define
    a set of distinct values that are of the same type. This prevents you from accidentally
    using incorrect values in your code, reducing runtime errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability**: Enums provide meaningful names for each of their values, making
    the code self-documenting. This improves code readability and comprehension because
    you can understand the purpose of each value just by looking at its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDE support**: IDEs offer features such as code completion and error checking
    specific to enums. When you use constants, you may not get the same level of support,
    and you might need to remember or look up valid values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring ease**: When you need to change or add a value, enums make it
    easier. IDEs can automatically update all references to the enum value throughout
    your code, reducing the chances of errors during maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional behaviors**: Enums can have methods and fields associated with
    them, allowing you to encapsulate behavior related to each enum value. For example,
    you can define a method that calculates a specific value or behavior for each
    enum, improving code organization and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnumSet` and `EnumMap` that are highly efficient when working with enums.
    These collections are tailored to work specifically with enum values, making your
    code more concise and performant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile-time checking**: Errors related to incorrect constant values may
    only surface at runtime, potentially causing unexpected issues. In contrast, issues
    with enums, such as missing values or incorrect references, are caught by the
    compiler, ensuring that your code is correct before it’s executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serialization support**: Enums have built-in support for serialization and
    deserialization, which simplifies tasks such as saving enum values to a file or
    transmitting them over a network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, when you use enums in Java, you get a bunch of benefits compared
    to plain constants. These perks include making your code safer, easier to read,
    and simpler to maintain. Enums also play well with your development tools, making
    your life easier. But that’s not to say constants don’t have their uses – they
    do, especially in specific situations. However, for most cases where you have
    a fixed set of values with some extra behavior, enums are the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we are, at the end of this journey through refactoring techniques. We hope
    we’ve given you some ideas on how to craft methods better, making them clear and
    readable. We’ve explored how it can sometimes be helpful to shuffle features between
    objects and better organize your data. We’ve simplified conditional logic (you
    know – those `if` statements and switches that help us solve problems quickly
    but can make our code unreadable!). We’ve simplified method calls, used a bit
    of good old generalization, and talked briefly about the immutability of objects.
    In the next chapter, we’ll dive into how to use automated tools to (hopefully!)
    make our code even better.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For other examples and use cases: Martin Fowler, *Refactoring*, Addison-Wesley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Null references: The Billion Dollar* *mistake*: [https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
