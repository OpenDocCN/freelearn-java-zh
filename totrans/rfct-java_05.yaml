- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Refactoring Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构技巧
- en: 'We’re now getting into the meat of the subject: how to do refactoring. It would
    be a bit silly to think we can cram all the refactoring techniques ever known
    into one chapter. So, we’ve decided to focus on the most common and more interesting
    ones. Our main source of wisdom comes from Martin Fowler’s fantastic work in his
    book, *Refactoring: Improving the Design of Existing Code*. He teamed up with
    Kent Beck to explain, step by step, how to do refactoring, from the simplest to
    the trickiest cases. For each one, they provide a kind of *how-to* guide so that
    you won’t mess things up. Here, we’re offering a selection of the most important
    refactoring techniques, an importance that we consider based largely on our own
    experience.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在深入主题的核心：如何进行重构。认为我们可以把所有已知重构技术都塞进一个章节里，那会有些愚蠢。因此，我们决定专注于最常见且更有趣的几种。我们智慧的主要来源是马丁·福勒在其著作《重构：改善既有代码的设计》中的出色工作。他与肯特·贝克合作，逐步解释了如何进行重构，从最简单到最复杂的情况。对于每一种情况，他们都提供了一种“如何做”的指南，以确保你不会搞砸。在这里，我们提供了一系列我们认为最重要的重构技术，其重要性很大程度上基于我们的经验。
- en: Tip
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For those who don’t know, Martin Fowler and Kent Beck are influential figures
    in software development. Martin Fowler is known for his contributions to software
    design, refactoring, and agile methodologies, while Kent Beck is the creator of
    **Extreme Programming** (**XP**) and the JUnit testing framework. Both have had
    a significant impact on shaping agile practices and improving software development
    processes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不知道的人来说，马丁·福勒和肯特·贝克是软件开发界有影响力的人物。马丁·福勒以其对软件设计、重构和敏捷方法的贡献而闻名，而肯特·贝克是**极限编程**（**XP**）和JUnit测试框架的创造者。他们都对塑造敏捷实践和改进软件开发流程产生了重大影响。
- en: We’ve tried to simplify even more what Fowler wrote and sprinkle in a bit of
    our own work background. If you haven’t already, we suggest you read the chapter
    on code smells ([*Chapter 3*](B20912_03.xhtml#_idTextAnchor070)) before you dive
    into this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图使福勒所写的内容更加简化，并加入了一些我们自己的工作经验。如果你还没有读过，我们建议你在深入研究本章之前先阅读关于代码恶臭的章节（[*第3章*](B20912_03.xhtml#_idTextAnchor070)）。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Techniques for making well-structured methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建良好结构化方法的技巧
- en: Moving features from one object to another
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能从一个对象移动到另一个对象
- en: Making your data more organized
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的数据更有组织
- en: Simplifying those tricky `if`-`else` blocks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化那些棘手的`if`-`else`块
- en: Cleaning up your method calls
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理你的方法调用
- en: Some tips on using generalization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关于使用泛化的技巧
- en: A nudge to use enums when they make sense
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用枚举类型时给予一点提示
- en: 'But let’s cut to the chase, starting with the basics: composing methods.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们直接进入正题，从基础开始：方法组合。
- en: Writing better methods
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写更好的方法
- en: Composing methods is a fundamental skill that should be a part of every developer’s
    refactoring toolkit. To put it simply, almost bluntly, it’s about breaking your
    code into smaller pieces, each of which does just one thing in a very readable
    way, in a very procedural manner; you could almost think of it as a recipe (please
    forgive me; I’m Italian, so I always bring everything back to food). The details
    are hidden in the methods beneath the composed method; this allows us to read
    our logic, our code, at a high level – I dare say, almost “in prose.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 方法组合是一项基本技能，应该是每个开发者重构工具箱的一部分。简单地说，几乎可以说是直截了当，它关乎将你的代码分解成更小的部分，每个部分都以非常可读的方式执行一项任务，以一种非常程序化的方式；你几乎可以把它想象成一份食谱（请原谅我；我是意大利人，所以我总是把一切归结为食物）。细节隐藏在组合方法之下的方法中；这使我们能够以高层次阅读我们的逻辑，我们的代码——我敢说，几乎是“散文”般的。
- en: When refactoring your code, the process typically involves extracting code from
    the original method. If you find it challenging to come up with meaningful names
    for the extracted methods, it’s a clear sign that the code chunk you were about
    to extract may be too extensive. Another case I’ve come across is when someone
    (sometimes myself) suggested naming a method that contained the conjunctions “and”
    or “or”... also in this situation, it’s clear that the method we are working on
    has too many responsibilities and is doing too many things. In such cases, try
    to identify a smaller, more focused portion for extraction. Often, in longer methods,
    you may notice that certain sections are already marked with comments; these labeled
    sections can frequently be refactored into new methods.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对代码进行重构时，通常涉及从原始方法中提取代码。如果你发现很难为提取的方法想出有意义的名称，这显然是一个明确的迹象，表明你即将提取的代码块可能过于庞大。我还遇到过另一种情况，有人（有时包括我自己）建议为一个包含“和”或“或”等连词的方法命名...在这种情况下，很明显，我们正在处理的方法承担了过多的责任，做了太多的事情。在这种情况下，尝试识别一个更小、更专注的部分进行提取。通常，在较长的方法中，你可能已经注意到某些部分已经被注释标记；这些标记的部分通常可以重构为新的方法。
- en: You might find yourself, after applying this refactoring technique, having many
    short methods within the same class; this, in itself, is already an improvement.
    However, at this point, it might be desirable to further shorten the class by
    extracting a dedicated one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用这种重构技术之后，你可能会在同一类中拥有许多短方法；这本身就是一个改进。然而，在这个时候，可能希望进一步缩短类的大小，通过提取一个专门的方法来实现。
- en: 'Here are some guidelines you can follow when you have to compose methods:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须编写方法时，以下是一些你可以遵循的指南：
- en: '**The shorter, the better**: Lean toward brevity and conciseness in your code.
    Smaller functions and code blocks are generally preferred, as they enhance readability
    and maintainability.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**越短越好**：在代码中追求简洁和精炼。较小的函数和代码块通常更受欢迎，因为它们提高了可读性和可维护性。'
- en: '**Minimize redundancy**: When employing the composing method pattern, pay close
    attention to eliminating duplicate code fragments. This practice not only trims
    down your code base but also prevents inconsistencies and simplifies future updates.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化冗余**：在应用组合方法模式时，请注意消除重复的代码片段。这种做法不仅减少了代码库的大小，而且防止了不一致性，并简化了未来的更新。'
- en: '**Show your purpose**: To foster code clarity and adopt a naming convention
    that leaves no room for ambiguity. Every variable, method, and parameter should
    be named in a way that succinctly conveys its role and function.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展示你的目的**：为了促进代码清晰度并采用一种命名约定，避免任何歧义。每个变量、方法和参数都应该以简洁的方式命名，传达其角色和功能。'
- en: '**Strive for simplification**: Simplification is a guiding principle in code
    improvement. It entails the removal of unnecessary complexities, streamlining
    logic, and adhering to best practices. Simplified code is not only more elegant
    but also more maintainable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追求简化**：简化是代码改进的指导原则。它包括去除不必要的复杂性，简化逻辑，并遵循最佳实践。简化的代码不仅更加优雅，而且更易于维护。'
- en: '**Maintain consistent detail levels**: When applying the composing method pattern,
    it’s essential to harmonize the complexity level of the methods you call. Avoid
    mixing simple, straightforward getters with functions that perform resource-intensive
    computations. Consistency in detail levels fosters code cohesion and comprehension.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持一致的细节级别**：在应用组合方法模式时，协调你调用的方法的复杂度是至关重要的。避免将简单直接的获取器与执行资源密集型计算的函数混合。在细节级别上的统一有助于代码的凝聚力和可理解性。'
- en: There are many ways to achieve these goals; next, we will see some of them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些目标有许多方法；接下来，我们将看到其中的一些。
- en: Extract Method
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取方法
- en: 'We have already seen something about it in the previous chapters, but I would
    like to delve a bit deeper. In my opinion, this is the refactoring that we do
    (or should do) most often. It is quite simply taking a very long method – too
    long – and breaking it down into smaller methods. How long can a method be at
    most? Obviously, there is no general rule; it depends on your sensitivity and
    that of the team. Let’s say that I have to scroll with the mouse to read it all;
    this is already a small indicator of excessive length. I like to follow what Martin
    Fowler has taught us once again and try to limit the lines of my methods as much
    as possible; it sometimes happens that I have methods that are only two or three
    lines long. In addition to the code length for which I perform method extraction,
    sometimes I also consider the reusability of the code I am extracting, as it’s
    important to avoid copy-paste. However, I agree with Fowler (and of course I do!)
    in saying that methods should be written with their *intent* in mind; that is
    *what* those methods are supposed to do, and not *how* they’re gonna do it: isolate
    all the code needed to do a certain thing in a single method, no matter how small.
    The method’s name should then be based on “what” the method does and not “how”
    it does it.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中已经看到了一些关于它的内容，但我还想深入探讨一下。在我看来，这是我们（或应该）最常进行重构的操作。简单来说，就是将一个非常长的方法——太长了——分解成更小的方法。一个方法最长可以有多长？显然，没有普遍的规则；这取决于你的敏感性和团队。让我们说，我必须用鼠标滚动才能读完整段代码；这已经是一个长度过长的微小信号。我喜欢遵循Martin
    Fowler曾经教给我们的，尽可能地限制方法行的数量；有时我的方法只有两行或三行长。除了我进行方法提取的代码长度外，有时我也会考虑我提取的代码的可重用性，因为避免复制粘贴很重要。然而，我同意Fowler（当然我也同意！）的说法，即方法应该根据其*意图*来编写；也就是说，这些方法应该做什么，而不是它们将如何去做：将完成某个特定事情所需的所有代码隔离在单个方法中，无论这个方法有多小。然后，方法的名字应该基于方法“做什么”，而不是“怎么做”。
- en: 'Let’s illustrate these concepts with a very simple example. Suppose we have
    the following method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常简单的例子来说明这些概念。假设我们有以下方法：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the method is very simple: it is a method that calculates the
    sum and difference of two numbers and prints them. Of course, the reality is much
    more complex than that, but the principles do not change. We refactor the code
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个方法非常简单：它是一个计算两个数字的和与差并打印它们的方法。当然，现实情况要复杂得多，但原则并没有改变。我们像这样重构代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have extracted three methods: one that sums up the numbers, a second that
    makes the difference, and a third that prints the result on the screen to avoid
    repetition. Don’t be fooled by the length of this specific piece of code; again,
    it’s just one example to illustrate the concept – in reality, you have to think
    of sum and difference operations as longer methods that implement perhaps more
    complex logic. Another reflection we can make here is that extracting methods
    promotes code reuse because the logic thus extracted can be invoked in many different
    points.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提取了三种方法：一种用于求和数字，第二种用于计算差值，第三种用于在屏幕上打印结果以避免重复。不要被这段特定代码的长度所迷惑；再次强调，这只是一个示例，用于说明概念——在现实中，你必须将求和和差值操作视为更长的、实现可能更复杂逻辑的方法。我们还可以在这里提出另一个观点，即提取方法可以促进代码重用，因为这样提取的逻辑可以在许多不同的地方被调用。
- en: Inline Method
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联方法
- en: This is exactly the opposite of extracting methods. It may seem strange, after
    having insisted so much on the extraction of methods, on short methods, to suggest
    that sometimes it is appropriate, instead, to inline the method. This little refactoring
    can be very useful when you have a very short method (typically a line of code
    or two) that is never reused and that already expresses very well what it does;
    in this case, isolation in a method with the sole purpose of “explaining,” through
    the name of the method itself, what the method does may be excessive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这与提取方法正好相反。在如此强调方法提取、短方法之后，提出有时应该内联方法，这可能会显得有些奇怪。这种微小的重构在以下情况下非常有用：当你有一个非常短的方法（通常是几行代码）且该方法从未被重用，并且已经很好地表达了它的功能；在这种情况下，将“解释”功能通过方法名本身隔离开来可能有些过度。
- en: 'I’ll provide you with a very trivial example of what method inlining is. Let’s
    suppose we have the following three methods in a class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提供一个关于方法内联的非常简单的例子。假设我们有一个类中的以下三个方法：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can easily see, we have a `calculate` method that takes two integers
    as input and performs a series of operations on them. The operations are represented
    by the `add` and `multiply` methods, which, of course, make the sum and the product
    of the two integers they take as input. These methods are used only once and are
    very simple: in fact, only one line. So, let’s take the opportunity to perform
    method inlining and make the code shorter and more readable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你容易看到的，我们有一个`calculate`方法，它接受两个整数作为输入并对它们执行一系列操作。这些操作由`add`和`multiply`方法表示，当然，它们是它们所接受的两个整数的和与积。这些方法只使用一次，并且非常简单：实际上，只有一行。所以，让我们抓住机会进行方法内联，使代码更短、更易读：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `add` and `multiply` methods disappeared, and their implementation, consisting
    of a single line of code, replaced them where they were invoked. We could further
    refactor the code by returning directly the result of the last operation, avoiding
    the `result` variable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`multiply`方法消失了，它们的实现，由一行代码组成，在它们被调用的地方取代了它们。我们可以进一步重构代码，通过直接返回最后一个操作的结果来避免`result`变量：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example may seem contradictory to what we wrote in the previous chapter
    (in fact, we are now inling something that before we isolated), but it’s just
    for the sake of providing a very simple example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能与我们之前章节中写的内容相矛盾（实际上，我们现在正在内联之前我们隔离的内容），但这只是为了提供一个非常简单的例子。
- en: 'To sum up, what you have to do to perform an “Inline Method” refactoring is
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，要执行“内联方法”重构，你需要做的是：
- en: Check that the method hasn’t been changed in subclasses. If it has been modified,
    avoid using this technique.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认该方法在子类中没有被更改。如果已被修改，请避免使用此技术。
- en: Hunt down all the places where the method is called, then replace those calls
    with the actual code from the method.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪所有调用该方法的地方，然后将这些调用替换为方法中的实际代码。
- en: Go ahead and delete the method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续删除该方法。
- en: Of course, since we are talking about refactoring, the behavior must never change;
    to be sure, there’s no other way than to include testing in the little recipe
    written previously. Be sure to always carry out a test before eliminating a method
    that you have inlined. We’ll get to that later in the book, but most modern **integrated
    development** **environments** (**IDEs**) offer tools to do this refactoring with
    a simple click of the mouse.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，既然我们在谈论重构，行为必须永远不变；为了确保这一点，没有其他方法比将测试包括在之前写的小食谱中更有效。确保在删除内联的方法之前始终执行测试。我们将在本书的后面部分讨论这个问题，但大多数现代**集成开发环境**（**IDEs**）都提供简单的点击鼠标即可进行此重构的工具。
- en: 'Use Inline Method refactoring in the following cases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用内联方法重构：
- en: '**When the method’s implementation is straightforward**: If the method’s logic
    is simple and direct, as demonstrated in the preceding example, consider employing
    this refactoring technique to eliminate it.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当方法的实现简单直接**：如果方法的逻辑简单直接，如前例所示，考虑使用这种重构技术来消除它。'
- en: '**When you want to eliminate unnecessary delegation**: At times, you may transfer
    the method’s implementation to another method or class, introducing unnecessary
    indirection in the code. To streamline the code and remove this extra layer of
    delegation, use the Inline Method technique.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当你想要消除不必要的委托**：有时，你可能将方法的实现转移到另一个方法或类中，这会在代码中引入不必要的间接引用。为了简化代码并移除这额外的委托层，使用内联方法技术。'
- en: '**As a foundation for subsequent refactorings**: The process of refactoring
    is not always a linear one, and there are various ways to refactor the same code.
    For instance, you can employ extract method refactoring to isolate different code
    segments. However, if the refactoring path you initially chose does not yield
    improved code, you can use the inline method to reintegrate previously extracted
    code back into its original method and then explore alternative refactoring approaches.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为后续重构的基础**：重构的过程并不总是线性的，对同一代码有各种重构方式。例如，你可以使用提取方法重构来隔离不同的代码段。然而，如果你最初选择的重构路径没有产生改进的代码，你可以使用内联方法将之前提取的代码重新整合到其原始方法中，然后探索其他重构方法。'
- en: Extract and inline variables
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取并内联变量
- en: We summarize these two refactoring techniques in a single section since – in
    our humble opinion – they are very similar to the Extract Method and Inline Method
    techniques but applied to a single variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些两种重构技术总结在单独的部分，因为——根据我们谦逊的观点——它们与提取方法和内联方法技术非常相似，但应用到了单个变量上。
- en: 'The main motivation – perhaps the only one – to introduce (extract) a variable
    instead of an expression is when the latter could be difficult to understand (not
    so much and not only on a technical level; we talk here about the motivation behind
    the expression itself). Let’s try to explain ourselves better with an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 引入（提取）一个变量而不是表达式的动机——或许可以说是唯一的动机——是当后者可能难以理解时（不仅是在技术层面上；我们在这里谈论的是表达式本身的动机）。让我们用一个例子来更好地解释自己：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code snippet, we analyze a field of a generic `transport` object that
    represents a means of transport; among its various fields, the object also has
    an `equipment` object that tells us what means of transport it is. Unfortunately,
    this field is a string (see [*Chapter 3*](B20912_03.xhtml#_idTextAnchor070), *Primitive
    Obsession*), and we are forced to write an `if` statement to understand what type
    it is, whether plane or train. The code snippet is a bit clearer if we insert
    the result of `equals` within a couple of variables with a self-explanatory name:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们分析了一个代表交通工具的通用 `transport` 对象的字段；在其各种字段中，该对象还有一个 `equipment` 对象，告诉我们它是哪种交通工具。不幸的是，这个字段是一个字符串（参见[*第3章*](B20912_03.xhtml#_idTextAnchor070)，*原始执着*），我们被迫编写一个
    `if` 语句来理解它的类型，是飞机还是火车。如果我们插入 `equals` 的结果到一个具有自解释名称的几个变量中，代码片段就会更清晰：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Someone would be tempted to simply insert a comment to explain what those cryptic
    strings `"PLN"` and `"TRN"` refer to, but personally, we find this kind of approach
    more effective. You could also use enums instead of plain strings so that a possible
    typo would be caught by the compiler. By introducing these “intermediate parts”
    formed by the variables, the code is made more understandable. The drawback is…
    that your code contains more variables. As always in life, it is a problem of
    balance! The choice is yours.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会简单地插入一条注释来解释那些神秘的字符串 `"PLN"` 和 `"TRN"` 指的是什么，但个人来说，我们发现这种方法更有效。你也可以使用枚举而不是纯字符串，这样编译器就能捕捉到可能的打字错误。通过引入由变量组成的这些“中间部分”，代码的可理解性得到了提高。缺点是……你的代码中包含了更多的变量。就像生活中的一切一样，这是一个平衡问题！选择权在你。
- en: 'The technique of “inline variable,” on the other hand, is so similar to that
    of the *inline method* that it is worth explaining it directly through an example
    that is practically the same as the one seen in the relative section:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，“内联变量”的技术与“内联方法”非常相似，因此值得通过一个与相对部分中看到的例子几乎相同的例子来直接解释它：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, assigning to the `sum` variable the result of the addition –
    and then never using it again after printing it – does not add much to the understanding
    of the code compared to the expression itself. It is therefore better to inline
    the variable directly in the only point where it is used, eliminating the first
    line of the snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将加法的结果赋值给 `sum` 变量——然后打印后不再使用它——与表达式本身相比，对代码的理解并没有增加多少。因此，最好将变量直接内联在它被使用的唯一点上，消除代码片段的第一行：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Combining a function into a class
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数组合到类中
- en: 'As the last notable example of refactoring that reorganizes code by “recomposing”
    methods, we propose one that combines several methods within a single class. This
    technique is used when we have several methods that have in common one (or more)
    input parameters; that is, that – in practice – go to act on the same classes.
    Again, let’s go directly to show an example that should better clarify the concept.
    Suppose we have this set of methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为重构的最后著名例子，我们提出了一种通过“重新组合”方法来重新组织代码的技术。我们提出的一种技术是在一个类中结合几个方法。当有几个方法具有一个（或多个）共同的输入参数时，即实际上作用于相同的类时，我们使用这种技术；也就是说，在实践中，它们会作用于相同的类。再次，让我们直接展示一个应该能更好地阐明概念的例子。假设我们有以下一组方法：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All of these methods take a single parameter of the `Location` type. It would
    be better to enclose all the logic concerning the `Location` parameter in a single
    point. For this, we create a class that contains all the logic:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都接受一个 `Location` 类型的单一参数。最好是将与 `Location` 参数相关的所有逻辑封装在一个单独的点中。为此，我们创建了一个包含所有逻辑的类：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A `Location` instance is passed only once, in the constructor. From the signatures
    of the methods we then removed the parameter; now, you no longer need to pass
    it. Of course, consider carefully whether to refactor this way; if your `Location`
    instance changes often, such as for each method call, using such a pattern might
    not be the best idea, because you should instantiate a `LocationHandler` for each
    call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`实例仅在构造函数中传递一次。然后我们从移除的方法签名中删除了参数；现在，你不再需要传递它。当然，仔细考虑是否以这种方式重构；如果你的`Location`实例经常变化，例如对于每次方法调用，使用这种模式可能不是最好的主意，因为你应该为每个调用实例化一个`LocationHandler`。'
- en: Moving features between objects
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象之间移动功能
- en: As we have already mentioned several times, and as those who have been in this
    profession for more than a few years know organizing our code is perhaps one of
    the most challenging parts. Personally, I believe I have never managed to get
    the design of a software project right on the first try. But, once again, the
    software is fortunately (or unfortunately!) malleable, so with the right limits
    and a good amount of refactoring, we can move methods and fields from one class
    to another without too much difficulty. We can decide to extract a class or remove
    one and inline it. Above all, we can eliminate the so-called dead code. But let’s
    start showing something.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次提到的那样，那些在这个行业工作了几年的专业人士知道，组织我们的代码可能是最具挑战性的部分之一。我个人认为，我从未在第一次尝试时就成功地设计出一个软件项目。但，再次强调，软件幸运地（或不幸地！）是可塑的，所以通过适当的限制和大量的重构，我们可以轻松地将方法和字段从一个类移动到另一个类。我们可以决定提取一个类或删除一个并将其内联。最重要的是，我们可以消除所谓的死代码。但让我们开始展示一些内容。
- en: Moving a method or field
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动方法和字段
- en: This refactoring is quite basic (Martin Fowler calls it the “bread and butter”
    of refactorings), but it is one of the most frequently performed ones. This is
    because, as we have already mentioned, it is good practice to maintain a certain
    modularity in your software project so that classes, packages, and so on are grouped
    coherently based on the context in which they operate. For example, in one package,
    we may place all classes responsible for managing user information, while in another,
    we may gather all clients for external services. There is no single criterion,
    but rather, often, a certain subjectivity. This is why it can often happen that
    methods or individual fields are moved from one class to another. This movement,
    guided by the principle of keeping related things together and separating things
    that should be separate, simplifies the code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构相当基础（马丁·福勒称之为重构的“黄油面包”），但它是最常执行的重构之一。这是因为，正如我们之前提到的，保持软件项目中的某种模块性是一种良好的实践，以便类、包等可以根据它们操作的上下文有组织地分组。例如，在一个包中，我们可能放置所有负责管理用户信息的类，而在另一个包中，我们可能收集所有外部服务的客户端。没有单一的标准，而是往往有一定的主观性。这就是为什么方法或单个字段经常从一个类移动到另一个类的原因。这种移动，遵循将相关事物放在一起和分离应该分离的事物的原则，简化了代码。
- en: This is one of those cases where doing something is simpler and more intuitive
    than explaining it, but I’ll try to give you Martin Fowler’s “recipe” for it,
    perhaps simplifying it a bit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些情况之一，做某事比解释它简单直观，但我会尽量给出马丁·福勒的“配方”，也许会稍微简化一下。
- en: 'Transferring a method from the source class to the target class involves several
    steps that must be followed to ensure a successful refactoring process:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法从源类转移到目标类涉及几个步骤，必须遵循以确保重构过程成功：
- en: Examine the dependencies and other class members that the method utilizes. Determine
    if it’s necessary to relocate them to the new class as well.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查该方法所使用到的依赖和其他类成员。确定是否需要将它们也重新定位到新类中。
- en: Check whether the method is referenced by a superclass or subclass. If it’s
    being used by these classes, it may not be feasible to move the method.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查该方法是否被超类或子类引用。如果它被这些类使用，可能无法移动该方法。
- en: Establish the method in the target class and replicate existing code into it.
    If the relocated method relies on an instance of the original class, you can pass
    it as a method parameter.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标类中建立该方法，并将现有代码复制到其中。如果重新定位的方法依赖于原始类的实例，你可以将其作为方法参数传递。
- en: Delete the code within the old method and direct the call to the new method.
    (This is optional; you could also use a **feature toggle**.)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除旧方法中的代码，并将调用直接指向新方法。（这是可选的；你也可以使用**功能开关**。）
- en: Optionally, make a decision about whether to eliminate the old method entirely
    and directly invoke the new method.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，决定是否完全消除旧方法并直接调用新方法。
- en: Feature toggle
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关
- en: '**Feature toggles**, also known as **feature flags**, are a technique that
    allows us to activate or deactivate specific functionalities without directly
    modifying the source code. This approach brings benefits such as continuous deployment,
    simplified testing in real-world conditions, efficient issue management, gradual
    feature rollouts for risk management, and the ability to compare feature variants
    for informed decision-making.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能开关**，也称为**功能标志**，是一种允许我们在不直接修改源代码的情况下激活或停用特定功能的技术。这种方法带来了诸如持续部署、简化实际条件下的测试、高效的问题管理、逐步功能发布以进行风险管理以及能够比较功能变体以进行明智决策等好处。'
- en: 'In the most abstract sense, a feature toggle would work like this in a Java
    method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在最抽象的意义上，功能开关在Java方法中可以这样工作：
- en: '`public void` `applyLogic() {`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`public void` `applyLogic() {`'
- en: '`    if (``newFeatureEnabled) {`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`    if (``newFeatureEnabled) {`'
- en: '`applyNewLogic();`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyNewLogic();`'
- en: '`}` `else {`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` `else {`'
- en: '`applyCurrentLogic();`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyCurrentLogic();`'
- en: '`    }`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`    }`'
- en: '`}`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: In the end, it is advisable to execute your test suite. It’s essential to bear
    in mind, even though it should be implicit when discussing refactoring.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，建议执行你的测试套件。即使讨论重构时应该隐含这一点，但仍然需要牢记。
- en: With a single field, the process is very similar. We have a field that is used
    by another class more than the class in which it is defined. The context is not
    respected; therefore, we move the field to that other class, subsequently changing
    all points where that field is used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个字段，过程非常相似。我们有一个字段，它被另一个类比定义它的类使用得更多。上下文没有得到尊重；因此，我们将字段移动到那个其他类，随后更改所有使用该字段的地方。
- en: 'Fields are often moved around when applying the **Extract Class** technique,
    and deciding which class should keep a particular field can be a bit tricky. Here’s
    a practical rule of thumb: put the field in the same class as the methods that
    use it the most, or in the class where you find most of these methods. This rule
    can also prove beneficial in scenarios where a field is clearly situated in an
    inappropriate location.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用**提取类**技术时，字段经常被移动，决定哪个类应该保留特定的字段可能有点棘手。这里有一个实用的经验法则：将字段放在使用它最多的方法所在的同一个类中，或者放在你找到大多数这些方法的类中。这个规则在字段显然位于不适当位置的场景中也可能是有益的。
- en: 'Once again, let’s present the methodology as described by Fowler:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们以Fowler所描述的方法来展示：
- en: When dealing with a public field, refactoring becomes significantly more manageable
    by converting it into a private field and providing public access methods (you
    can utilize the **Encapsulate Field** technique for this purpose, as explained
    in the *Field* *encapsulation* section).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理公共字段时，通过将其转换为私有字段并提供公共访问方法（你可以利用*封装字段*技术来完成这个目的，如*字段* *封装*部分所述），重构变得显著更容易管理。
- en: Establish the same field within the receiving class along with its corresponding
    access methods.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收类中建立相同的字段及其相应的访问方法。
- en: Determine how you will access the receiving class. You may already possess a
    field or method that yields the required object. If not, you’ll need to create
    a new method or field to store the object associated with the receiving class.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定如何访问接收类。你可能已经有一个字段或方法可以提供所需的对象。如果没有，你需要创建一个新的方法或字段来存储与接收类关联的对象。
- en: Substitute all occurrences where the old field is referenced with appropriate
    method calls in the receiving class. If the field is not private, address this
    in both the superclass and any subclasses as necessary.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接收类中所有引用旧字段的实例替换为适当的方法调用。如果字段不是私有的，根据需要在上层类和任何子类中处理这个问题。
- en: Eliminate the field from the original class.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从原始类中删除该字段。
- en: Moving statements into/from methods
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将语句移动到/从方法中
- en: Repeated code is one of the most common problems in our code base; the temptation
    to copy and paste is sometimes too strong. This can be seen before calling a certain
    method, a certain line of code; it can also happen that the same line of code
    is repeated before each call to that method. At this point, you will have understood
    that the best alternative is to take that statement and move it directly inside
    that method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的代码是我们代码库中最常见的问题之一；有时复制的诱惑太强烈。这可以在调用某个方法之前，看到某一行代码；也可能在每次调用该方法之前重复相同的代码行。这时，你就会明白最好的选择是将该语句直接移动到该方法内部。
- en: On the contrary, there may be a statement within the code that doesn’t fit well
    with the context of the method; perhaps it makes sense in one execution flow but
    not in another. In this case, make the opposite move to the previous one and move
    the statement outside of the method, to the point where it’s truly needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，代码中可能存在一个与该方法上下文不太吻合的语句；也许在一个执行流程中是有意义的，但在另一个执行流程中则不然。在这种情况下，采取与之前相反的措施，将语句移动到方法外部，直到它真正需要的位置。
- en: I consider this technique very common but quite straightforward. For a deeper
    exploration of the “mechanics” of how it works, I refer you to the *Further* *reading*
    section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这项技术非常常见，但相当直接。对于如何工作的“机制”的更深入探索，我建议您参考*进一步阅读*部分。
- en: Hiding delegates
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏代理
- en: This refactoring technique is applied when a class (referred to as the client)
    obtains an object of type *B* (referred to as the delegate) through another class
    of type *A* (referred to as the server). When client code calls a method defined
    on an object within a server object’s field, it establishes a direct dependency
    on that delegate object. Consequently, if the delegate object’s interface undergoes
    changes, all clients of the server relying on that delegate are affected. To eliminate
    this dependency, one can introduce a straightforward delegation method within
    the server, effectively hiding the delegate. Any subsequent modifications made
    to the delegate’s interface will then only impact the server itself, shielding
    clients from these changes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类（称为客户端）通过另一个类型为*A*（称为服务器）的类获取类型*B*（称为代理）的对象时，应用这种重构技术。当客户端代码调用服务器对象字段中定义的方法时，它将直接依赖于该代理对象。因此，如果代理对象的接口发生变化，所有依赖该代理的服务器客户端都将受到影响。为了消除这种依赖关系，可以在服务器中引入一个直接的代理方法，从而有效地隐藏代理。然后，对代理接口所做的任何后续修改都只会影响服务器本身，保护客户端免受这些更改的影响。
- en: 'An example will clarify a bit what we just said. Let’s suppose to have two
    classes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以稍微澄清我们刚才所说的。让我们假设有两个类：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to get `departureAirport`, but we have an instance of `Flight`,
    our code will be something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取`departureAirport`，但我们有一个`Flight`实例，我们的代码可能如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is OK, of course, except for the fact that now we must also be aware of
    the `Itinerary` class; that is actually useless since we need just `departureAirport`.
    We don’t want to change our code if the `Itinerary` class changes. So, we will
    write something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是可以的，但事实上我们现在还必须意识到`Itinerary`类；实际上这是无用的，因为我们只需要`departureAirport`。我们不希望因为`Itinerary`类的更改而更改我们的代码。因此，我们将编写如下所示的内容：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, we just call a method of the `Flight` class to get the field we need. Of
    course, we will also have to change the client code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需调用`Flight`类的一个方法来获取我们需要的字段。当然，我们也将不得不更改客户端代码：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The delegate is now hidden. We have less code and fewer relations between objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代理现在被隐藏了。我们的代码更少，对象之间的关系也更少。
- en: 'But as a recipe, as Martin Fowler does, here are the steps to perform this
    refactoring:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为一个配方，正如马丁·福勒所做的那样，以下是执行此重构的步骤：
- en: For every method in the delegate class that the client class calls, generate
    a corresponding method in the server class that forwards the call to the delegate
    class.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于客户端类调用的每个代理类方法，在服务器类中生成一个相应的方法，将调用转发到代理类。
- en: Modify the client code to invoke the methods in the server class instead of
    directly calling the delegate class.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改客户端代码，调用服务器类中的方法，而不是直接调用代理类。
- en: If your modifications successfully eliminate the client’s dependency on the
    delegate class, you can safely remove the access method to the delegate class
    within the server class (the method originally used to obtain the delegate class).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的修改成功消除了客户端对代理类的依赖，你可以在服务器类中安全地删除对代理类的访问方法（最初用于获取代理类的方法）。
- en: One downside is that if you have to generate an excessive number of delegate
    methods, the server class may end up being an unnecessary intermediary, resulting
    in an abundance of middlemen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺点是，如果你必须生成大量的委托方法，服务器类最终可能成为一个不必要的中间件，导致中间人的大量增加。
- en: Removing dead code
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除死代码
- en: 'Ah, here’s one of the things that satisfies me the most: deleting unnecessary
    code! Dead code refers to parts of the source code that are no longer executed
    or reachable during the program’s execution.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，这里是我最满意的事情之一：删除不必要的代码！死代码指的是在程序执行过程中不再执行或无法访问的源代码部分。
- en: 'Dead code can occur for various reasons, such as the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 死代码可能由各种原因引起，如下所示：
- en: '**Code removal or refactoring**: When developers modify a program, they may
    delete or comment out certain sections of code that are no longer needed. These
    leftover code snippets become dead code.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码删除或重构**：当开发者修改程序时，他们可能会删除或注释掉不再需要的某些代码部分。这些遗留的代码片段成为死代码。'
- en: '**Conditional branches**: In some cases, code may be written within branches
    of conditional statements that are never true during execution, making the code
    within those branches effectively dead.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**条件分支**：在某些情况下，代码可能被编写在执行过程中永远不会为真的条件语句的分支中，这使得这些分支中的代码实际上成为死代码。'
- en: '**Unused variables or functions**: If variables or functions are defined but
    not used anywhere in the program, they are considered dead code.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未使用的变量或函数**：如果变量或函数被定义了，但在程序中任何地方都没有使用，它们被认为是死代码。'
- en: 'You don’t want dead code in your project: it makes it harder to understand,
    increases maintenance costs, and potentially introduces bugs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望在项目中出现死代码：它会使项目更难理解，增加维护成本，并可能引入错误。
- en: So, please, if you are aware of dead code in your project – and modern IDEs
    now are perfectly capable of doing that – please just remove it. No – don’t comment
    it out! Get rid of it; if you just want to recover it, I bet you’re using a versioning
    control system (such as Git or Subversion) that will do the trick.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请，如果你在你的项目中发现了死代码——现代IDE现在完全有能力做到这一点——请直接删除它。不——不要将其注释掉！摆脱它；如果你只是想恢复它，我敢打赌你正在使用版本控制系统（如Git或Subversion），它将能解决这个问题。
- en: Watch out also for so-called **dead comments**. As we mentioned before, our
    view on comments is that there should be as few as possible and focused on explaining
    *why* something is done. In an ideal and fantastic world, the code itself should
    be able to explain without needing extra comments. What often – very often – happens
    is that comments don’t get updated along with the code, becoming not only irrelevant
    but also harmful, sometimes misleading. Even if you’re taught to add lots of comments
    to code in school (at least, I was), please try to keep it to a minimum.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意所谓的**死注释**。正如我们之前提到的，我们对注释的看法是应该尽可能少，并且专注于解释*为什么*要做某事。在一个理想和神奇的世界里，代码本身应该能够解释，而不需要额外的注释。但往往——非常经常——注释没有随着代码一起更新，不仅变得无关紧要，而且有害，有时甚至误导。即使你在学校被教导给代码添加很多注释（至少，我是这样），请尽量将其保持在最低限度。
- en: 'What we’ve said about dead code can of course be applied also to modules, services,
    or even individual features. It’s quite common to see the proliferation of modules
    and services deployed in production that are no longer actually used, and their
    only effect is to consume precious (read: expensive) resources. Typically, everyone
    forgets about them until it’s time to update them (for example, due to a discovered
    vulnerability among their dependencies) or when someone realizes they’re costing
    a lot of money in hardware resources! In the case of features, it’s similar: why
    keep unused features that make the code more complex without any real benefit?
    Get rid of them at the first opportunity, and you won’t regret it!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于死代码所说的当然也可以应用到模块、服务或甚至单个功能上。在生产环境中，看到模块和服务的激增，而这些模块和服务实际上不再被使用，它们唯一的作用就是消耗宝贵的（读：昂贵的）资源，这是相当常见的。通常，每个人都会忘记它们，直到需要更新它们（例如，由于发现其依赖项中的漏洞）或有人意识到它们在硬件资源上花费了大量的钱！在功能的情况下，情况类似：为什么保留那些使代码更复杂但没有实际益处的未使用功能？一旦有机会，就摆脱它们，你不会后悔的！
- en: We’ve seen a very important part of code refactoring, and we’ve learned some
    techniques for moving pieces of code without too much disruption. In addition
    to being in the right place, features must be well structured and organized. Let’s
    see some suggestions about this.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了代码重构的一个重要部分，并且我们学习了一些在不造成太大干扰的情况下移动代码片段的技术。除了位于正确的位置外，特性还必须具有良好的结构和组织。让我们看看一些关于这个的建议。
- en: Organizing data
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织数据
- en: How data is organized is one of the most important aspects of our profession;
    coherently aggregating information forms the foundation for building a solid,
    maintainable, and extensible software project. Various types of refactoring assist
    us in this regard, and once again, Fowler helps us navigate them in great detail.
    In the upcoming sections, we will present a selection of those we consider to
    be the most common or potentially misleading.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是如何组织的，是我们职业中最重要的一部分；有逻辑地聚合信息是构建一个坚实、可维护和可扩展的软件项目的基础。各种类型的重构帮助我们在这方面，而且，Fowler
    再次帮助我们详细地导航它们。在接下来的章节中，我们将展示我们认为最常见或可能具有误导性的那些。
- en: Field encapsulation
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段封装
- en: 'We will group together in a single section techniques that we believe are very
    similar to each other and ultimately concerned with not revealing the internal
    structure of a class to its users. This principle is known as **encapsulation**
    and is one of the fundamental concepts of **object-oriented programming** (**OOP**);
    hiding the internal structure of a class and providing access methods to its fields
    is beneficial because it simplifies the use of the class, protects data, improves
    maintainability, encapsulates behavior, and allows access control. Data is not
    separated from the associated behaviors, the modularity of program sections is
    not compromised, and maintenance is simplified. To achieve encapsulation starting
    from a public field, it is sufficient to make the field private and expose so-called
    *getter* and *setter* methods. For example, take a look at the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们认为非常相似且最终不向用户揭示类内部结构的技术组合在一起。这个原则被称为 **封装**，并且是 **面向对象编程**（**OOP**）的基本概念之一；隐藏类的内部结构并提供对其字段的访问方法是有益的，因为它简化了类的使用，保护了数据，提高了可维护性，封装了行为，并允许访问控制。数据不会与相关的行为分离，程序部分的模块化不会受到影响，维护也变得简单。要从公共字段开始实现封装，只需将字段设置为私有，并公开所谓的
    *getter* 和 *setter* 方法。例如，看看以下代码：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This would become the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变成以下内容：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `departureAirport` field has been made private, and we expose two methods
    that respectively read and write the field itself. If you want to make the class
    immutable – something we highly recommend in general – you would just need to
    make `departureAirport` final, add it to the constructor, and eliminate the *setter*
    method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`departureAirport` 字段已被设置为私有，我们提供了两个分别读取和写入该字段本身的方法。如果您想使类不可变——我们通常强烈推荐这样做——您只需将
    `departureAirport` 设置为 `final`，将其添加到构造函数中，并消除 *setter* 方法即可。'
- en: 'Someone might argue that this way, we still expose the class’s structure, and...
    they would be right! However, keep in mind that this is a very simple case: for
    example, it’s not necessary for getters and setters to exist for all fields or
    that they must exclusively perform read or write operations on the fields – they
    could also involve some logic (but be cautious about performance in this case!).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论说，这样我们仍然暴露了类的结构，并且...他们会是对的！然而，请记住，这是一个非常简单的案例：例如，对于所有字段来说，getters 和
    setters 不一定必须存在，或者它们不一定必须仅执行对字段的读取或写入操作——它们也可以涉及一些逻辑（但在此情况下要小心性能！）。
- en: 'Another important note: starting from Java 14, the `Record` keyword was introduced
    – a construct that allows you to define a class such as `Flight` in a single line,
    with less boilerplate. You can refer to the *Further reading* section for more
    details.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的注意事项：从 Java 14 开始，引入了 `Record` 关键字——一个允许您在一行中定义类，如 `Flight`，并减少样板代码的构造。您可以参考
    *进一步阅读* 部分以获取更多详细信息。
- en: 'We can also encapsulate the field within the class itself. Let’s extend our
    `Flight` class a bit, assuming that we also need to access the `departureAirport`
    field internally:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在类本身内封装字段。让我们扩展一下我们的 `Flight` 类，假设我们还需要内部访问 `departureAirport` 字段：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At times, directly accessing a private field within a class may lack the desired
    flexibility. You have the option to execute intricate operations when data within
    the field is set or received – tasks such as *lazy initialization* and validation
    of field values can be effortlessly incorporated within the field’s getters and
    setters. Other than that, you’d have the ability to override getters and setters
    in subclasses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，直接访问类中的私有字段可能缺乏所需的灵活性。当字段中的数据被设置或接收时，你可以选择执行复杂的操作——例如，*懒加载*和字段值的验证可以轻松地集成到字段的自定义获取器和设置器中。除此之外，你还有能力在子类中重写获取器和设置器。
- en: 'So, the `Flight` class would look like this (please observe the `getDepartureAirportCode`
    method):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Flight`类看起来会是这样（请观察`getDepartureAirportCode`方法）：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Someone could argue that we gained in flexibility but lost a bit in readability
    because of the need to read the `getDepartureAirport` method; someone else could
    say that this is untrue, as long as the methods are named well and represent just
    a getter; we’re also promoting loose coupling. It’s up to you to choose which
    path to follow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论说，我们在灵活性上有所增加，但由于需要阅读`getDepartureAirport`方法，我们在可读性上有所损失；另一些人可能会说，只要方法命名得当，仅代表获取器，这就不真实；我们也在促进松耦合。选择哪条路径取决于你。
- en: 'The final case of encapsulation that we want to present concerns collections,
    and I have indeed seen this problem many times. In this case, the class contains
    a field of the `Collection` type, and its getters and setters operate on the entire
    collection, making it more challenging to interact with it. Modifying the previous
    examples slightly, let’s suppose we have a `Flight` class that contains a `Collection`
    field of airports, one for each stopover:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示的封装的最后一个案例涉及集合，我确实看到过这个问题很多次。在这种情况下，类包含一个`Collection`类型的字段，其获取器和设置器操作整个集合，这使得与之交互更具挑战性。稍微修改之前的示例，假设我们有一个包含机场`Collection`字段的`Flight`类，每个停靠点都有一个：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The protocol for utilizing these collections differs slightly from that employed
    by other data types. It is important to note that the getter method should not
    return the actual collection object itself. Doing so would permit clients to manipulate
    the contents of the collection without the owner class’s awareness. Moreover,
    this would reveal an excessive amount of the object’s internal data structure
    to clients. Instead, the method for retrieving collection elements should provide
    a value that prevents any modifications to the collection and avoids revealing
    too much information about its structure. There should be no method for directly
    assigning a value to a collection. Instead, the protocol should provide operations
    for adding and deleting elements. This approach empowers the owner object to exercise
    control over the addition and removal of elements within the collection:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些集合的协议与其他数据类型略有不同。重要的是要注意，获取器方法不应返回实际的集合对象本身。这样做将允许客户端在不通知拥有类的情况下操作集合的内容。此外，这将向客户端揭示对象内部数据结构的过多信息。相反，用于检索集合元素的方法应提供一个值，以防止对集合进行任何修改，并避免过多地揭示其结构信息。不应有直接分配值给集合的方法。相反，协议应提供添加和删除元素的操作。这种方法使拥有对象能够控制集合中元素的添加和删除：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have removed the setter method and added two methods for adding and removing
    elements from the list. When we return the list through the getter, we instantiate
    a new immutable list using Java 17’s `Collections::unmodifiableList` methods (but
    we could have used Guava, Apache Commons, or whatever).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了设置器方法，并添加了两个方法用于向列表中添加和删除元素。当我们通过获取器返回列表时，我们使用Java 17的`Collections::unmodifiableList`方法（但我们也可以使用Guava、Apache
    Commons或其他）实例化一个新的不可变列表。
- en: A couple of disclaimers
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 几个免责声明
- en: We are modifying objects, which goes against the concept of immutability that
    we have advocated for on these pages, so please be cautious. Also, remember that
    the type of the collection for which you are performing add and remove operations
    (in this case, `Airport`) must override the `equals` and `hashCode` methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在修改对象，这与我们在这些页面上倡导的不变性概念相悖，所以请谨慎行事。另外，请记住，你正在执行添加和删除操作（在这种情况下，`Airport`）的集合类型必须重写`equals`和`hashCode`方法。
- en: Replacing primitives with objects
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用对象替换原始类型
- en: 'This refactoring comes to our rescue when dealing with the code smell called
    `Flight` class, this time, let’s assume that a field containing the service level,
    also known as “cabin class,” is defined, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理被称为`Flight`类的代码异味时，这种重构方法会帮我们解决问题，这次，让我们假设一个包含服务级别，也称为“机舱类”的字段被定义为如下：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we wanted to filter from a list of flights only the most expensive ones,
    we would have to do something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想从航班列表中过滤出最昂贵的航班，我们可能需要做如下操作：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It’s not ideal. I need to know what all the possible values for the cabin class
    are, and I must know exactly which one is more expensive than the other. In these
    cases, it’s better to use a class to replace the primitive type, allowing not
    only wrapping but also the implementation of custom logic:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。我需要知道机舱类所有可能的值，并且我必须确切知道哪一个比另一个更贵。在这些情况下，最好使用一个类来替换原始类型，这不仅允许封装，还可以实现自定义逻辑：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the `higherThan` method allows us to implement a logic that
    compares our cabin class to another, without worrying about managing and maintaining
    the logic itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`higherThan`方法允许我们实现一种逻辑，比较我们的机舱类与另一个，而无需担心管理维护这种逻辑本身。
- en: 'I think it is worth taking a look at the `CabinClass` class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为看一下`CabinClass`类是值得的：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It has a name and a value; the latter is used to determine the position in the
    “value scale” of the cabin classes, and it is assigned to the class constructor.
    We still have a lot of strings around, but I think we can do better. Let’s go
    ahead.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名称和一个值；后者用于确定机舱类在“价值尺度”中的位置，并且它被分配给类构造函数。我们周围还有很多字符串，但我认为我们可以做得更好。让我们继续前进。
- en: Replacing type code with subclasses
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用子类替换类型代码
- en: 'Let’s start with the previous example, that of the cabin class. You may have
    noticed that defining the “type” of the cabin class by passing a string in the
    constructor is not ideal. In a simple scenario, we could make a typo while writing
    the type; in reality, the real issue is that we are delegating to the caller knowledge
    that should be internal to the `CabinClass` class. When we have a situation such
    as this, a situation in which our class has a “type,” and the behavior of the
    class itself can depend on this type, a useful refactoring is to create subclasses.
    Our `CabinClass` class would then become the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前的例子开始，即机舱类。您可能已经注意到，通过在构造函数中传递一个字符串来定义机舱类的“类型”并不是理想的。在简单场景中，我们可能在编写类型时犯拼写错误；实际上，真正的问题是我们在将知识委托给调用者，而这些知识应该是`CabinClass`类内部的知识。当我们遇到这种情况时，即我们的类有一个“类型”，并且类的行为本身可能依赖于这个类型，一个有用的重构是创建子类。我们的`CabinClass`类将变成以下这样：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But we would also have a series of subclasses defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也会定义一系列如下所示的子类：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice how the parameters are defined within the constructor, and how it is
    impossible for the caller to modify them. In this way, among other things, we
    leverage all the advantages of OOP, and code readability is also improved as a
    result. For completeness, here is a snippet that filters expensive flights, modified
    accordingly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数是如何在构造函数中定义的，以及调用者无法修改它们的情况。这样，除了其他优点外，我们还利用了面向对象编程的所有优势，并且代码的可读性也因此得到了提高。为了完整性，这里是一个相应修改后用于过滤昂贵航班的代码片段：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we simply instantiate an `Economy` class to be used into the `higherThan`
    method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是简单地实例化一个`Economy`类，以便在`higherThan`方法中使用。
- en: Organizing data well means, at the end of the day, simplifying things – or at
    least making them more readable. One thing that can make code very complicated
    to read is conditional logic. Let’s see how you can simplify it a bit.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 良好地组织数据意味着，最终目的是简化事物——或者至少使它们更易于阅读。可以使代码非常难以阅读的一件事是条件逻辑。让我们看看如何稍微简化一下。
- en: Simplifying conditional logic
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化条件逻辑
- en: For this section, we will also rely on Martin Fowler and try to explain some
    of the refactorings to what we consider to be the most common problems. The selection
    is arbitrary and based solely on our experience. For further details, we refer
    you to the *Further* *reading* section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们也将依赖Martin Fowler，并尝试解释一些我们认为最常见问题的重构。选择是任意的，仅基于我们的经验。有关更多详细信息，我们建议您参考*进一步阅读*部分。
- en: Returning a special case instead of null
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回特殊值而不是null
- en: 'Do not return `null`. This is a mantra that everyone – even engineers with
    years of experience – sometimes forgets. There are cases where a method should
    return a result but cannot: some error in the execution flow; some exceptional
    cases. Java and many other languages allow returning `null`, but it’s preferable
    not to do so for obvious reasons – among them, avoiding a `NullPointerException`
    in the caller or forcing it to check every time that the method’s result is not
    `null`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不要返回`null`。这是一个每个人——甚至是有多年经验的工程师——有时会忘记的咒语。有些情况下，方法应该返回一个结果，但无法返回：执行流程中的某些错误；某些异常情况。Java和许多其他语言允许返回`null`，但出于明显的原因，最好不要这样做——其中之一是避免调用者中的`NullPointerException`，或者迫使调用者每次都检查方法的结果是否不是`null`。
- en: Tip
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Tony Hoare introduced Null references in **ALGOL W** back in 1965 “simply because
    it was so easy to implement,” according to him. Reflecting on that decision, he
    refers to it as his “billion-dollar mistake”. More on this in the *Further* *reading*
    section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼·霍尔（Tony Hoare）在1965年将空引用（Null references）引入到**ALGOL W**中，据他所说，“仅仅因为它很容易实现”。回顾这个决定，他将其称为自己的“十亿美元的错误”。更多内容请参阅*进一步阅读*部分。
- en: There are various ways to avoid null references, but one of the most common
    is to return a so-called **Special Case** object, which is a default object with
    predefined values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 避免空引用有各种方法，但最常见的一种是返回一个所谓的**特殊情况**对象，它是一个具有预定义值的默认对象。
- en: 'Take, for example, the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码片段为例：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can notice how we need to differentiate the logic by checking if the object
    returned by the repository is `null`. In this case, it wouldn’t even be very useful
    if the repository method returned an `Optional` because we would still need to
    write an `if` statement; in our opinion, however, it would be better because it
    would at least make the caller aware that the call may not return the desired
    result. One solution, though, is to introduce a Special Case object. Here is a
    possible implementation in Java:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，我们需要通过检查存储库返回的对象是否为`null`来区分逻辑。在这种情况下，如果存储库方法返回了一个`Optional`，那么这甚至可能不是很有用，因为我们仍然需要编写一个`if`语句；然而，在我们看来，这会更好，因为它至少会让调用者意识到调用可能不会返回期望的结果。尽管如此，一个解决方案是引入一个特殊情况对象。以下是一个可能的Java实现：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We introduce an interface that allows us to implement the special case, and
    then we implement it in two classes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个接口，允许我们实现特殊情况，然后我们在两个类中实现了它：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how the `ActualCustomerAddress` class is the actual “real” one, while
    the other is a kind of “dummy object” used to allow the caller to not change the
    execution flow when calling the method. Of course, we have the (small?) disadvantage
    of creating more classes than there were before; the cleanliness of the code greatly
    benefits from this.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`ActualCustomerAddress`类是实际的“真实”类，而另一个则是一种“占位符对象”，用于允许调用者在调用方法时不会改变执行流程。当然，我们有一个（小？）缺点，就是创建了比之前更多的类；代码的整洁性因此得到了极大的提升。
- en: In theory, we could also craft a specific exception for our situation and throw
    that instead of giving back a fake object. But, honestly, we don’t see that happening
    a lot (and we’re not big fans of it!). Still, it is worth acknowledging this for
    the sake of completeness.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们也可以为我们的情况创建一个特定的异常，并用它来代替返回一个假对象。但老实说，我们并没有看到这种情况发生很多（我们也不是特别支持这样做！）。然而，为了完整性，承认这一点是值得的。
- en: Using polymorphism instead of conditions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多态而不是条件
- en: 'Let’s revisit a code smell discussed in [*Chapter 3*](B20912_03.xhtml#_idTextAnchor070):
    repeated switches. When there is a lot of conditional logic, it’s better to introduce
    some structure. When a `switch` statement is repeated many times in the code,
    especially around a variable named `type`, it’s highly likely that refactoring
    is a better approach:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在[*第3章*](B20912_03.xhtml#_idTextAnchor070)中讨论过的代码异味：重复的`switch`语句。当存在大量的条件逻辑时，引入一些结构会更好。当代码中多次重复`switch`语句，尤其是在名为`type`的变量周围时，重构可能是一个更好的方法：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this method, which calculates the distance traveled in a travel itinerary
    – whether it’s by plane or by train – we encounter several issues. The caller
    must be aware of the possible values that `type` can take, implementing different
    logic at each point in the code where it’s needed. Furthermore, we anticipate
    that there will be other points in the code where it needs to behave differently
    based on the type of itinerary.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，它计算旅行行程中的行驶距离——无论是乘坐飞机还是火车——我们遇到了几个问题。调用者必须知道`type`可能采取的可能值，并在代码中需要的地方实现不同的逻辑。此外，我们预计代码中还会有其他需要根据行程类型不同而表现不同的点。
- en: 'Instead, we can simply utilize polymorphism:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以简单地利用多态性：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Polymorphism in the previous code allows us to treat different types of itineraries
    (`FlightItinerary` and `TrainItinerary`) as instances of a common base class (`Itinerary`).
    This enables you to call the `calculateItineraryDistance` method on them without
    knowing their specific types, promoting code flexibility and reuse, and creating
    two classes that extend the same abstract class. At this point, the caller will
    no longer have to worry about anything:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，多态性允许我们将不同的行程类型（`FlightItinerary`和`TrainItinerary`）视为通用基类（`Itinerary`）的实例。这使得你可以在不知道它们的具体类型的情况下调用`calculateItineraryDistance`方法，从而提高代码的灵活性和复用性，并创建两个扩展相同抽象类的类。在这个时候，调用者将不再需要担心任何事情：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Removing duplicated conditions
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除重复的条件
- en: 'It can sometimes happen that identical code is duplicated within the two branches
    of an `if`-`else` block in a conditional statement. Why this happens, I honestly
    couldn’t say; however, I can testify that I’ve seen it more often when methods
    are very long or as a result of refactoring. In my humble opinion, it’s usually
    a simple oversight, but it’s an oversight that happens more often than you might
    think. For example, in the previous example, we can observe precisely that `calculateItineraryDistance(departureLocation,
    arrivalLocation);` is called in two different cases within the `switch` statement.
    In general, when we are in a condition in which the same call is repeated, we
    can do as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能会发生这样的情况，在条件语句中的`if`-`else`块的两个分支中重复相同的代码。为什么会出现这种情况，我老实说不知道；然而，我可以证明，当方法非常长或者由于重构的结果时，这种情况出现的频率更高。在我看来，这通常是一个简单的疏忽，但它发生的频率比你想象的要高。例如，在前面的例子中，我们可以精确地观察到`calculateItineraryDistance(departureLocation,
    arrivalLocation);`在`switch`语句的两个不同情况下被调用。一般来说，当我们处于重复相同调用的条件下时，我们可以这样做：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The advice is simply to take the duplicate call out of the `if` statement,
    like so:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的建议是将重复的调用从`if`语句中移除，如下所示：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Keep in mind that maybe the method in question does not exist yet; however,
    there is repeated code that you can put together using the **Extract** **Method**
    technique.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，可能相关的方法尚未存在；然而，你可以使用**提取** **方法**技术将重复的代码组合在一起。
- en: Guard clauses
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护子句
- en: The last piece of advice I give you is on simplifying conditional logic concerns’
    nested `if` statements; I must admit that I suffer a lot when I find them, with
    the code moving further and further to the right of the screen, almost forming
    mandalas that need a really large monitor to be appreciated! A slope toward the
    abyss.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你的最后一条建议是关于简化条件逻辑中的嵌套`if`语句；我必须承认，当我发现它们时，代码会越来越向屏幕的右侧移动，几乎形成需要非常大的显示器才能欣赏的曼荼罗！这是向深渊的倾斜。
- en: 'Here is an example of a method that, in addition to being very trivial, has
    many nested `if` statements. It takes three parameters as input and finds the
    largest, but none of them must be negative:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个方法的例子，除了非常简单之外，它还有许多嵌套的`if`语句。它接受三个参数作为输入，并找出最大的一个，但它们都不能是负数：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Understanding the purpose and functionality of each conditional is challenging
    due to the lack of clarity in a typical code execution flow. These conditionals
    suggest a disorganized development process, with each condition added as a temporary
    solution without considering the optimization of the overall structure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于典型的代码执行流程中的不清晰，理解每个条件的目的和功能具有挑战性。这些条件表明开发过程缺乏组织，每个条件都是作为一个临时解决方案添加的，而没有考虑整体结构的优化。
- en: 'To simplify the situation, separate exceptional cases into distinct conditions
    that promptly terminate execution and return a `null` value if the guard clauses
    are evaluated as `true`. Essentially, your goal here is to streamline the code
    structure and make it more linear, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化情况，将异常情况分离成不同的条件，如果守卫子句评估为`true`，则立即终止执行并返回一个`null`值。本质上，你的目标在这里是简化代码结构，使其更加线性，如下所示：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We know this code could be even more rewritten, but it’s just for explaining
    the concept. Some might argue that this method has too many returns within it
    and that it would be better to have only one. I can’t say, honestly, if there
    are too many, but it’s a good point to observe. I agree, however, with what Steve
    McConnell says in his book, *Code Complete*: use a `return` statement when it
    makes your code easier to understand. In some functions, as soon as you have the
    answer, just give it back to the calling function right away. If the function
    doesn’t need any extra cleanup after finding an error, not returning immediately
    would mean having to write more code.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这段代码可以进一步重写，但这只是为了解释概念。有些人可能会争论这个方法内部有太多的返回，认为最好只有一个。我坦白地说，我不确定是否太多，但这确实是一个值得观察的好点。然而，我同意史蒂夫·麦克康奈尔在他的书《Code
    Complete》中的说法：当使用`return`语句可以使你的代码更容易理解时，就使用它。在某些函数中，一旦你有了答案，就立即将其返回给调用函数。如果函数在找到错误后不需要进行任何额外的清理，不立即返回就意味着需要编写更多的代码。
- en: Also, if the code is mainly focused on performance, stopping after the most
    usual condition can skip some extra checks. This can be really helpful, especially
    if one or two situations make up the majority, like 80 or 90% of the time it runs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果代码主要关注性能，在处理最常见的情况后停止可以跳过一些额外的检查。这实际上非常有帮助，特别是如果一种或两种情况占运行时间的80%或90%。
- en: Simplifying method calls
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化方法调用
- en: Method calls are essential in OOP, as they enable objects to perform specific
    tasks or actions. There are many techniques intended to simplify the way objects
    interact with each other; we’re going to see some of the most interesting ones.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用在面向对象编程中至关重要，因为它们使对象能够执行特定的任务或操作。有许多旨在简化对象之间交互的技术；我们将看到其中一些最有趣的技术。
- en: Avoiding side effects
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免副作用
- en: 'We already discussed the side effects and mutability of objects in [*Chapter
    3*](B20912_03.xhtml#_idTextAnchor070), explaining why they are not ideal in a
    software project. A typical way to cause side effects is when you mix a query,
    which is a part of the code that simply retrieves information, and a modifier,
    which is code that performs an action on some data or system, thereby changing
    its state. Here’s an example of this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第3章*](B20912_03.xhtml#_idTextAnchor070)中讨论了对象的外部和可变性，解释了为什么它们在软件项目中不是理想的。引起副作用的一种典型方式是在查询（代码的一部分，仅用于检索信息）和修改器（对某些数据或系统执行操作并改变其状态的代码）之间混合。以下是一个例子：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this example, the method calculates the total price for a specific travel
    itinerary and simultaneously sends a summary email to the customer. We have several
    issues here. First (but this is the least of them), the name is misleading because
    it is not consistent with the actual behavior of the method. Furthermore, the
    method does more than one thing; particularly, it returns information (a `Price`
    instance) on one hand, but on the other hand, it changes the state of things by
    notifying the user. It’s better to separate these concerns, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该方法计算特定旅行行程的总价格，并同时向客户发送总结电子邮件。这里有几个问题。首先（但这不是最严重的问题），名称具有误导性，因为它与方法的实际行为不一致。此外，该方法做了不止一件事；特别是，它在一方返回信息（一个`Price`实例），而在另一方通过通知用户改变事物的状态。最好将这些关注点分开，如下所示：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We now have two distinct methods, one that requests information and another
    that somehow modifies the system’s state. It’s worth noting that a query method
    can be called as many times as desired without affecting the system’s state. The
    code is cleaner, and we have also removed a parameter from the `getTotalItineraryPrice`
    method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个不同的方法，一个用于请求信息，另一个以某种方式修改系统的状态。值得注意的是，查询方法可以在不影响系统状态的情况下被多次调用。代码更清晰，我们还从`getTotalItineraryPrice`方法中移除了一个参数。
- en: Removing setter methods
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除设置方法
- en: Actually, this section should almost be a continuation of the previous one.
    Removing so-called *setter* methods, which allow you to set the value of an object’s
    field, makes them immutable, removing undesirable side effects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这一节几乎应该是上一节的延续。移除所谓的*setter*方法，这些方法允许你设置对象字段的值，可以使它们不可变，从而消除不希望产生的副作用。
- en: 'We’ve already discussed this in this chapter, but we’d like to go into a bit
    more detail. Let’s consider a very simple class representing a person; let’s include
    only two fields for simplicity:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中讨论了这一点，但我们想更详细地探讨一下。让我们考虑一个代表人的非常简单的类；为了简单起见，我们只包括两个字段：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Person` class is represented with `taxCode` and `name`. `taxCode` is unique
    and represents the identifier for a person. As we see, you can instantiate this
    class and set its fields, like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类通过`taxCode`和`name`来表示。`taxCode`是唯一的，代表一个人的标识符。正如我们所见，你可以实例化这个类并设置其字段，如下所示：'
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we returned this instance to a calling method, no one would guarantee that
    its fields would not be modified. The refactoring in question simply aims to remove
    setter methods, adding its parameter inside the constructor, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个实例返回给调用方法，没有人能保证其字段不会被修改。所讨论的重构简单来说就是移除setter方法，将其参数添加到构造函数中，如下所示：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how `taxCode` is passed inside the constructor. In the `Person` class,
    the `taxCode` field can then become `final`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`taxCode`是如何在构造函数中传递的。在`Person`类中，`taxCode`字段可以成为`final`。
- en: True immutability – the builder pattern
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真正的不可变性——构建器模式
- en: To make an object truly immutable in each of its fields, we recommend using
    the **builder pattern**.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要使对象在所有字段上都具有真正的不可变性，我们建议使用**构建器模式**。
- en: The builder pattern is a design pattern used to construct complex objects step
    by step. It separates the construction of an object from its representation, allowing
    you to create different representations of the same object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器模式是一种设计模式，用于逐步构建复杂对象。它将对象的构建与其表示分离，允许你创建同一对象的不同的表示形式。
- en: 'Here’s how the builder pattern typically works:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是构建器模式通常是如何工作的：
- en: '**Create a builder class**: First, you create a separate builder class for
    constructing an object. This builder class has methods for setting the various
    attributes of the object you want to create.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建构建器类**：首先，你创建一个单独的构建器类来构建对象。这个构建器类有设置你想要创建的对象的各种属性的方法。'
- en: '**Set attributes**: You use the methods in the builder class to set the attributes
    of the object. Each method typically returns the builder object itself, allowing
    you to chain method calls (this is known as **method chaining**).'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置属性**：你使用构建器类中的方法来设置对象的属性。每个方法通常返回构建器对象本身，允许你链式调用方法（这被称为**方法链式调用**）。'
- en: '`build` method on the builder object, which constructs and returns the final
    object with the specified configuration.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建器对象上的`build`方法，它构建并返回具有指定配置的最终对象。
- en: 'A builder class for the `Person` class would look like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Person`类创建的构建器类看起来是这样的：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can clearly see a static `builder` method that instantiates the builder
    itself, taking `taxCode` as its only parameter, which is mandatory. The `name`
    method is just a setter of the `name` attribute; you can have one setter for each
    field of your class. At the end, the `build` method creates and populates an instance
    of `Person`. Using the builder pattern on a type is meaningful as long as you
    do not provide any other method to instantiate that type; for example, you can
    keep the constructor of the `Person` type private and create `builder` as an inner
    class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到静态的`builder`方法，它实例化构建器本身，只接受`taxCode`作为其唯一参数，这是强制性的。`name`方法只是`name`属性的setter；你可以为你的类的每个字段有一个setter。最后，`build`方法创建并填充一个`Person`实例。在类型上使用构建器模式是有意义的，只要你不提供任何其他方法来实例化该类型；例如，你可以将`Person`类型的构造函数设为私有，并将`builder`作为一个内部类创建。
- en: 'The usage of `PersonBuilder` is quite straightforward:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonBuilder`的使用相当简单：'
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once the object has been built (instantiated), you cannot modify its fields.
    In this example, the `builder` method (in this instance, the builder, in fact,
    and not the `Person` class) takes as a parameter `taxCode`, which is mandatory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象被构建（实例化），你不能修改其字段。在这个例子中，`builder`方法（在这个例子中，实际上是构建器，而不是`Person`类）接受`taxCode`作为参数，这是强制性的。
- en: There are tools to automate the creation of builder classes, which we will discuss
    later in the book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有工具可以自动化构建器类的创建，我们将在本书的后面部分讨论。
- en: Using generalization
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛化
- en: '**Generalization** is one of the most powerful features of OOP, and it must
    be used wisely (*with great power comes great responsibility*). I’ll report here
    just some of the most interesting refactorings in this area, going fast with the
    most basic and delving a little bit deeper with the others.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛化**是面向对象编程中最强大的特性之一，必须明智地使用（*权力越大，责任越大*）。在这里，我将仅报告这一领域的一些最有趣的重构，快速处理最基础的，对其他方面则深入探讨。'
- en: Pull up field
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升字段
- en: 'This technique consists of moving a field (or variable) from a subclass to
    a superclass. This is typically done when multiple subclasses share the same field
    or when you want to establish a common interface or behavior in the superclass.
    Here’s an example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术包括将一个字段（或变量）从子类移动到超类。这通常发生在多个子类共享相同的字段或当你想在超类中建立公共接口或行为时。以下是一个例子：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Triangle` and `Square` have a field in common; just extract an interface or
    an `abstract` class to do the trick:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle` 和 `Square` 有一个共同的字段；只需提取一个接口或一个 `abstract` 类来达到目的：'
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Push down field
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降级字段
- en: This is the opposite of a pull down field, and it’s used when you have a field
    (or attribute) defined in a superclass, but it’s only relevant to a specific subclass
    or a subset of subclasses. You just have to move the field from the superclass
    to the subclass where it’s actually used.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这与降级字段相反，当你在超类中定义了一个字段（或属性），但它只对特定的子类或子类集合相关时使用。你只需将字段从超类移动到实际使用的子类中。
- en: 'For example, let’s take a `Vehicle` class containing a single field called
    `engine`. We have two subclasses extending from it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以一个包含单个字段 `engine` 的 `Vehicle` 类为例。我们有两个从它扩展出的子类：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'While it makes sense for a Car to have an engine, of course, it doesn’t for
    a Bicycle. Let’s move the `engine` field into the only class it needs to be in:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于汽车来说，有一个引擎是有意义的，但对于自行车来说则不然。让我们将 `engine` 字段移动到唯一需要的类中：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Pull up method
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升方法
- en: 'This consists of moving a method from a subclass to a superclass. This is typically
    done when multiple subclasses share a common behavior, and you want to establish
    that behavior in the superclass to promote code reuse. Here’s an example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括将一个方法从子类移动到超类。这通常发生在多个子类共享一个共同行为时，你希望在该超类中建立这种行为以促进代码重用。以下是一个例子：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It’s worth pulling the `calculatePerimeter` method up in the superclass and
    removing the method from `Triangle` and `Square`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `calculatePerimeter` 方法提升到超类中，并从 `Triangle` 和 `Square` 中移除是值得的：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Push down method
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降级方法
- en: This is the opposite of the pull up method, and it is used when you have a method
    defined in a superclass, but its behavior is relevant only to a specific subclass
    or a subset of subclasses. You just have to move the method from the superclass
    to the subclass where it’s actually used.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这与提升方法相反，当你在超类中定义了一个方法，但其行为只对特定的子类或子类集合相关时使用。你只需将方法从超类移动到实际使用的子类中。
- en: 'For example, let’s take again a `Vehicle` class containing a single method
    called `fillTank`. We also have two subclasses extending from it:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次以一个包含单个方法 `fillTank` 的 `Vehicle` 类为例。我们还从它扩展出两个子类：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can easily guess, having a `fillTank` method doesn’t make any sense
    for a class representing a bicycle, but only for a class representing a car. So,
    what we’re gonna do is just push the method down onto the `Car` subclass:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如你容易猜到的，对于代表自行车的类来说，拥有 `fillTank` 方法没有任何意义，但只对代表汽车的类有意义。所以，我们要做的是将方法降级到 `Car`
    子类中：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Template method
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板方法
- en: 'It often happens, when we program, that we have algorithms or processes of
    some kind to apply to objects in a way that is almost entirely similar but not
    exactly the same. A certain logic may apply generally to an entire category of
    objects, but these objects may have some specific characteristics that make them
    different. In the previous examples, we used the classic example of polygons.
    We can say that for a polygon, the calculation of the perimeter always involves
    summing the lengths of its respective sides. However, between a triangle and a
    square, for example, the number of sides changes. Therefore, it could be useful
    to have a method in the superclass that is implemented in the subclasses and represents
    their specific characteristics. I believe it’s easier to explain this with an
    example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，我们经常遇到需要将某些算法或过程应用于对象的情况，这些对象几乎完全相同，但又不完全一样。某种逻辑可能适用于整个对象类别，但这些对象可能有一些特定的特征使它们不同。在先前的例子中，我们使用了多边形的经典例子。我们可以这样说，对于多边形，周长的计算总是涉及其相应边长的总和。然而，例如，在三角形和正方形之间，边的数量是不同的。因此，在超类中有一个在子类中实现的方法，代表它们的特定特征，这可能是有用的。我相信用例子来说明这一点更容易：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Both `Triangle` and `Square` have a `getPerimeter` method that basically sums
    up the length of their sides; we could not just pull up the method, because the
    implementation is different – one has three potentially different sides, and the
    other has four equal sides. What we’re going to do is implement a template method,
    in which we will call another method defined in the subclasses, which just returns
    a `Collection` field of side lengths:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle`和`Square`都有`getPerimeter`方法，这个方法基本上是计算它们边长的总和；我们并不能直接调用这个方法，因为实现方式不同——一个有三个可能不同的边，而另一个有四个相等的边。我们将要实现的是一个模板方法，在这个方法中，我们将调用子类中定义的另一个方法，该方法仅返回边长的`Collection`字段：'
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have created a `getSideLengths` template method that reduces redundancy by
    consolidating common algorithmic steps in a superclass while allowing distinctions
    to remain in the subclasses. This is a vibrant example of the **Open/Closed Principle**
    (**OCP**) in practice. If a new version of the algorithm is introduced, you can
    simply create a new subclass without needing to modify the existing code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`getSideLengths`模板方法，通过在超类中合并常见的算法步骤来减少冗余，同时允许子类保持其区别。这是一个**开闭原则**（**OCP**）在实践中的生动例子。如果引入了新版本的算法，你只需创建一个新的子类，而无需修改现有代码。
- en: Using enums instead of constants
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用枚举而不是常量
- en: At this point, we have seen some of the main refactoring techniques discussed
    in the literature. Now, we move on to a final section where we allow ourselves
    to give you a couple of tips on how to better organize your code design. These
    may seem trivial, but they often lead to considerable annoyance. The first tip,
    as the title of this section suggests, concerns the excessive use of constants
    (a thorough study based solely on my perception and experience undoubtedly shows
    that these constants will be strings 99% of the time).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了文献中讨论的一些主要的重构技术。现在，我们进入最后一部分，在这里我们可以给你一些建议，关于如何更好地组织你的代码设计。这些可能看起来很微不足道，但它们往往会导致相当大的烦恼。本节的第一个建议，正如标题所暗示的，涉及到常量的过度使用（仅基于我的感知和经验进行彻底的研究无疑表明，这些常量99%的情况下将是字符串）。
- en: 'Let’s suppose we have the following class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如下所示的类：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In another class, we defined the following constants:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个类中，我们定义了以下常量：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In one method, let’s instantiate our `Itinerary` class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个方法中，让我们实例化我们的`Itinerary`类：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Do you see anything weird? We accidentally swapped `cabinClass` with `transportType`!
    We didn’t even realize it because everything compiles when we’re just dealing
    with strings. If we don’t really need to create custom types to represent these
    concepts, such as the transport type and the cabin class, our suggestion is to
    use enums.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到什么奇怪的地方了吗？我们意外地将`cabinClass`和`transportType`交换了！因为我们只是在处理字符串时，一切都能编译，所以我们甚至没有意识到这一点。如果我们真的不需要创建自定义类型来表示这些概念，比如运输类型和客舱等级，我们的建议是使用枚举。
- en: 'In fact, let’s introduce enums:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，让我们引入枚举：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can then rewrite the code like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样重写代码：
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will then be used without the possibility of error:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以避免错误地使用：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using enums is generally better than constants in Java because they offer the
    following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，使用枚举通常比使用常量更好，因为它们提供了以下功能：
- en: '**Type safety**: Enums are types themselves, meaning they allow you to define
    a set of distinct values that are of the same type. This prevents you from accidentally
    using incorrect values in your code, reducing runtime errors.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：枚举本身就是类型，这意味着它们允许你定义一组具有相同类型的不同值。这可以防止你在代码中意外使用不正确的值，从而减少运行时错误。'
- en: '**Readability**: Enums provide meaningful names for each of their values, making
    the code self-documenting. This improves code readability and comprehension because
    you can understand the purpose of each value just by looking at its name.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：枚举为它们的每个值提供了有意义的名称，使代码自文档化。这提高了代码的可读性和理解性，因为你可以通过查看其名称来理解每个值的目的。'
- en: '**IDE support**: IDEs offer features such as code completion and error checking
    specific to enums. When you use constants, you may not get the same level of support,
    and you might need to remember or look up valid values.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE支持**：IDE提供针对枚举的特定功能，如代码补全和错误检查。当你使用常量时，你可能不会得到相同级别的支持，并且可能需要记住或查找有效的值。'
- en: '**Refactoring ease**: When you need to change or add a value, enums make it
    easier. IDEs can automatically update all references to the enum value throughout
    your code, reducing the chances of errors during maintenance.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构便捷性**：当你需要更改或添加值时，枚举使这变得更容易。IDE可以自动更新代码中所有对枚举值的引用，从而在维护期间减少错误的机会。'
- en: '**Additional behaviors**: Enums can have methods and fields associated with
    them, allowing you to encapsulate behavior related to each enum value. For example,
    you can define a method that calculates a specific value or behavior for each
    enum, improving code organization and maintainability.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外行为**：枚举可以具有与之关联的方法和字段，允许你封装与每个枚举值相关的行为。例如，你可以定义一个方法，为每个枚举计算特定的值或行为，从而提高代码的组织性和可维护性。'
- en: '`EnumSet` and `EnumMap` that are highly efficient when working with enums.
    These collections are tailored to work specifically with enum values, making your
    code more concise and performant.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnumSet`和`EnumMap`在处理枚举时非常高效。这些集合专门针对枚举值进行定制，使你的代码更简洁、性能更优。'
- en: '**Compile-time checking**: Errors related to incorrect constant values may
    only surface at runtime, potentially causing unexpected issues. In contrast, issues
    with enums, such as missing values or incorrect references, are caught by the
    compiler, ensuring that your code is correct before it’s executed.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时检查**：与不正确的常量值相关的错误可能仅在运行时出现，可能引发意外问题。相比之下，与枚举相关的问题，如缺失值或错误的引用，将由编译器捕获，确保在代码执行之前代码是正确的。'
- en: '**Serialization support**: Enums have built-in support for serialization and
    deserialization, which simplifies tasks such as saving enum values to a file or
    transmitting them over a network.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化支持**：枚举具有内置的序列化和反序列化支持，这简化了将枚举值保存到文件或通过网络传输等任务。'
- en: Basically, when you use enums in Java, you get a bunch of benefits compared
    to plain constants. These perks include making your code safer, easier to read,
    and simpler to maintain. Enums also play well with your development tools, making
    your life easier. But that’s not to say constants don’t have their uses – they
    do, especially in specific situations. However, for most cases where you have
    a fixed set of values with some extra behavior, enums are the way to go.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当你在Java中使用枚举时，与普通的常量相比，你将获得一系列的好处。这些好处包括使你的代码更安全、更易于阅读和更易于维护。枚举还与你的开发工具配合良好，使你的生活更轻松。但这并不意味着常量没有它们的用途——它们确实有，尤其是在特定情况下。然而，对于大多数具有一些额外行为且值固定的情况，枚举是最佳选择。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Here we are, at the end of this journey through refactoring techniques. We hope
    we’ve given you some ideas on how to craft methods better, making them clear and
    readable. We’ve explored how it can sometimes be helpful to shuffle features between
    objects and better organize your data. We’ve simplified conditional logic (you
    know – those `if` statements and switches that help us solve problems quickly
    but can make our code unreadable!). We’ve simplified method calls, used a bit
    of good old generalization, and talked briefly about the immutability of objects.
    In the next chapter, we’ll dive into how to use automated tools to (hopefully!)
    make our code even better.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已完成了对重构技术的探索之旅。我们希望我们提供了一些关于如何更好地构建方法、使代码清晰易读的想法。我们探讨了有时在对象之间重新排列功能以及更好地组织数据可能是有帮助的。我们简化了条件逻辑（你知道的——那些帮助我们快速解决问题的`if`语句和开关，但可能会使我们的代码难以阅读！）。我们简化了方法调用，使用了一些古老而优秀的泛化，并简要讨论了对象的不可变性。在下一章中，我们将深入探讨如何使用自动化工具（希望！）使我们的代码更加出色。
- en: Further reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For other examples and use cases: Martin Fowler, *Refactoring*, Addison-Wesley'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他示例和用例：马丁·福勒，《重构》，Addison-Wesley
- en: '*Null references: The Billion Dollar* *mistake*: [https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*空引用：十亿美元的错误*：[https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)'
